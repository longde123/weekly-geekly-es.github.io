<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😌 🧖 🧞 Seccomp en Kubernetes: 7 cosas que debes saber desde el principio 🍴 🖖🏿 🥛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : Presentación de una traducción de un artículo de un ingeniero de seguridad de aplicaciones senior en la compañía británica ASOS.com. Con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seccomp en Kubernetes: 7 cosas que debes saber desde el principio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/481114/"> <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Presentación de una traducción de un artículo de un ingeniero de seguridad de aplicaciones senior en la compañía británica ASOS.com.</i>  <i>Con ella, comienza una serie de publicaciones sobre cómo mejorar la seguridad en Kubernetes mediante el uso de seccomp.</i>  <i>Si a los lectores les gusta la introducción, seguiremos al autor y continuaremos con sus futuros materiales sobre este tema.</i> <br><br><img src="https://habrastorage.org/webt/-u/nv/vk/-unvvkiylrs9ucbym-l4bsobtr8.png"><br><br>  Este artículo es el primero de una serie de publicaciones sobre cómo crear perfiles seccomp en el espíritu de SecDevOps sin recurrir a la magia y la brujería.  En la primera parte, hablaré sobre los conceptos básicos y detalles internos de la implementación de seccomp en Kubernetes. <br><br>  El ecosistema de Kubernetes ofrece una amplia variedad de formas de garantizar la seguridad y el aislamiento de los contenedores.  Este artículo trata sobre el Modo de computación segura, también conocido como <b>seccomp</b> .  Su esencia radica en el sistema de filtrado de llamadas disponibles para que los contenedores se ejecuten. <a name="habracut"></a><br><br>  ¿Por qué es esto importante?  Un contenedor es solo un proceso que se ejecuta en una máquina específica.  Y usa el kernel a la par con otras aplicaciones.  Si los contenedores pudieran realizar llamadas al sistema, muy pronto el malware lo aprovecharía para evitar el aislamiento del contenedor y afectar otras aplicaciones: interceptar información, cambiar la configuración del sistema, etc. <br><br>  Los perfiles seccomp determinan qué llamadas al sistema deben permitirse o denegarse.  El tiempo de ejecución del contenedor los activa durante su lanzamiento, de modo que el núcleo puede controlar su ejecución.  El uso de tales perfiles le permite limitar el vector de ataque y reducir el daño si algún programa dentro del contenedor (es decir, sus dependencias o sus dependencias) comienza a hacer lo que no está permitido hacer. <br><br><h2>  Comprender los conceptos básicos. </h2><br>  El perfil base de seccomp incluye tres elementos: <code>defaultAction</code> , <code>architectures</code> (o <code>archMap</code> ) y <code>syscalls</code> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"defaultAction"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ERRNO"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"architectures"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86_64"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X32"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"syscalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"names"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arch_prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"sched_yield"</span></span>, <span class="hljs-string"><span class="hljs-string">"futex"</span></span>, <span class="hljs-string"><span class="hljs-string">"write"</span></span>, <span class="hljs-string"><span class="hljs-string">"mmap"</span></span>, <span class="hljs-string"><span class="hljs-string">"exit_group"</span></span>, <span class="hljs-string"><span class="hljs-string">"madvise"</span></span>, <span class="hljs-string"><span class="hljs-string">"rt_sigprocmask"</span></span>, <span class="hljs-string"><span class="hljs-string">"getpid"</span></span>, <span class="hljs-string"><span class="hljs-string">"gettid"</span></span>, <span class="hljs-string"><span class="hljs-string">"tgkill"</span></span>, <span class="hljs-string"><span class="hljs-string">"rt_sigaction"</span></span>, <span class="hljs-string"><span class="hljs-string">"read"</span></span>, <span class="hljs-string"><span class="hljs-string">"getpgrp"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ALLOW"</span></span> } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/ef974f57693bb193f39e8add8a7040d7">medio-básico-seccomp.json</a> )</i> <br><br>  <code>defaultAction</code> determina el destino predeterminado de cualquier llamada al sistema no especificada en la sección <code>syscalls</code> .  Para simplificar la tarea, nos centramos en dos valores principales que se utilizarán: <br><br><ul><li>  <code>SCMP_ACT_ERRNO</code> : bloquea la ejecución de una llamada al sistema, </li><li>  <code>SCMP_ACT_ALLOW</code> : permite. </li></ul><br>  La sección de <code>architectures</code> enumera las arquitecturas de destino.  Esto es importante, ya que el filtro en sí, aplicado a nivel del núcleo, depende de los identificadores de las llamadas al sistema y no de sus nombres registrados en el perfil.  Antes de su uso, el tiempo de ejecución del contenedor los asigna a identificadores.  El punto es que las llamadas al sistema pueden tener ID completamente diferentes, dependiendo de la arquitectura del sistema.  Por ejemplo, la llamada al sistema <code>recvfrom</code> (utilizada para obtener información de un socket) tiene ID = 64 en sistemas x64 e ID = 517 en x86.  <a href="">Aquí</a> puede encontrar una lista de todas las llamadas al sistema para arquitecturas x86-x64. <br><br>  La sección <code>syscalls</code> enumera todas las llamadas al sistema e indica qué hacer con ellas.  Por ejemplo, puede crear una lista blanca estableciendo <code>defaultAction</code> en <code>SCMP_ACT_ERRNO</code> , y asignar llamadas a la sección <code>SCMP_ACT_ALLOW</code> a <code>SCMP_ACT_ALLOW</code> .  Por lo tanto, solo permite llamadas registradas en la sección <code>syscalls</code> y prohíbe todas las demás.  Para la lista negra, debe cambiar los valores y acciones por <code>defaultAction</code> a lo opuesto. <br><br>  Ahora se deben decir algunas palabras sobre los matices que no son tan obvios.  Tenga en cuenta que las siguientes recomendaciones provienen del hecho de que está implementando una línea de aplicaciones comerciales en Kubernetes y es importante que trabajen con los menos privilegios. <br><br><h2>  1. AllowPrivilegeEscalation = false </h2><br>  Hay un parámetro <code>AllowPrivilegeEscalation</code> en el <code>securityContext</code> contenedor.  Si se establece en <code>false</code> , los contenedores comenzarán con el bit <a href="https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt"><code>no_new_priv</code></a> establecido en (activado).  El significado de este parámetro es obvio por el nombre: no permite que el contenedor inicie nuevos procesos con privilegios mayores que los que tiene. <br><br>  Un efecto secundario de este parámetro establecido en <code>true</code> (el valor predeterminado) es que el tiempo de ejecución del contenedor aplica el perfil seccomp al comienzo del proceso de inicio.  Por lo tanto, todas las llamadas al sistema necesarias para iniciar los procesos internos del tiempo de ejecución (por ejemplo, establecer identificadores de usuario / grupo, descartar algunas capacidades) deben permitirse en el perfil. <br><br>  El contenedor que realiza el <code>echo hi</code> banal necesitará los siguientes permisos: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"defaultAction"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ERRNO"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"architectures"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86_64"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X32"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"syscalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"names"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arch_prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"brk"</span></span>, <span class="hljs-string"><span class="hljs-string">"capget"</span></span>, <span class="hljs-string"><span class="hljs-string">"capset"</span></span>, <span class="hljs-string"><span class="hljs-string">"chdir"</span></span>, <span class="hljs-string"><span class="hljs-string">"close"</span></span>, <span class="hljs-string"><span class="hljs-string">"execve"</span></span>, <span class="hljs-string"><span class="hljs-string">"exit_group"</span></span>, <span class="hljs-string"><span class="hljs-string">"fstat"</span></span>, <span class="hljs-string"><span class="hljs-string">"fstatfs"</span></span>, <span class="hljs-string"><span class="hljs-string">"futex"</span></span>, <span class="hljs-string"><span class="hljs-string">"getdents64"</span></span>, <span class="hljs-string"><span class="hljs-string">"getppid"</span></span>, <span class="hljs-string"><span class="hljs-string">"lstat"</span></span>, <span class="hljs-string"><span class="hljs-string">"mprotect"</span></span>, <span class="hljs-string"><span class="hljs-string">"nanosleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"newfstatat"</span></span>, <span class="hljs-string"><span class="hljs-string">"openat"</span></span>, <span class="hljs-string"><span class="hljs-string">"prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"read"</span></span>, <span class="hljs-string"><span class="hljs-string">"rt_sigaction"</span></span>, <span class="hljs-string"><span class="hljs-string">"statfs"</span></span>, <span class="hljs-string"><span class="hljs-string">"setgid"</span></span>, <span class="hljs-string"><span class="hljs-string">"setgroups"</span></span>, <span class="hljs-string"><span class="hljs-string">"setuid"</span></span>, <span class="hljs-string"><span class="hljs-string">"stat"</span></span>, <span class="hljs-string"><span class="hljs-string">"uname"</span></span>, <span class="hljs-string"><span class="hljs-string">"write"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ALLOW"</span></span> } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/018658f1aeea1ef696b451bde8c33a8f">hi-pod-seccomp.json</a> )</i> <br><br>  ... en lugar de estos: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"defaultAction"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ERRNO"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"architectures"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86_64"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X32"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"syscalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"names"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arch_prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"brk"</span></span>, <span class="hljs-string"><span class="hljs-string">"close"</span></span>, <span class="hljs-string"><span class="hljs-string">"execve"</span></span>, <span class="hljs-string"><span class="hljs-string">"exit_group"</span></span>, <span class="hljs-string"><span class="hljs-string">"futex"</span></span>, <span class="hljs-string"><span class="hljs-string">"mprotect"</span></span>, <span class="hljs-string"><span class="hljs-string">"nanosleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"stat"</span></span>, <span class="hljs-string"><span class="hljs-string">"write"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ALLOW"</span></span> } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/7c860ad818e3724d65a96ffdae5da808">hi-container-seccomp.json</a> )</i> <br><br>  Pero, de nuevo, ¿por qué es esto un problema?  Personalmente, evitaría incluir en la lista blanca las siguientes llamadas al sistema (si no son realmente necesarias): <code>capset</code> , <code>set_tid_address</code> , <code>setgid</code> , <code>setgroups</code> y <code>setuid</code> .  Sin embargo, la verdadera dificultad es que al permitir procesos sobre los que no tiene absolutamente ningún control, vincula los perfiles a la implementación del tiempo de ejecución del contenedor.  En otras palabras, un día puede encontrar el hecho de que después de actualizar el entorno de tiempo de ejecución del contenedor (por usted o, más probablemente, por el proveedor de servicios en la nube), los contenedores dejarán de iniciarse de repente. <br><br>  <b>Consejo # 1</b> : Ejecute contenedores con <code>AllowPrivilegeEscaltion=false</code> .  Esto reducirá el tamaño de los perfiles seccomp y los hará menos sensibles a los cambios en el tiempo de ejecución del contenedor. <br><br><h2>  2. Establecer perfiles seccomp a nivel de contenedor </h2><br>  El perfil seccomp se puede configurar a nivel de pod: <br><br><pre> <code class="plaintext hljs">annotations: seccomp.security.alpha.kubernetes.io/pod: "localhost/profile.json"</code> </pre> <br>  ... o en el nivel del contenedor: <br><br><pre> <code class="plaintext hljs">annotations: container.security.alpha.kubernetes.io/&lt;container-name&gt;: "localhost/profile.json"</code> </pre> <br>  <i>Tenga en cuenta que la sintaxis anterior cambiará cuando Kubernetes seccomp se <a href="https://github.com/kubernetes/enhancements/pull/1148">convierta en GA</a> (este evento se espera en la próxima versión de Kubernetes - 1.18 - Transl. Aprox.).</i> <br><br>  Pocas personas saben que Kubernetes siempre tuvo un <a href="https://github.com/kubernetes/kubernetes/issues/84623">error</a> que causaba que los perfiles seccomp se aplicaran al <a href="https://www.ianlewis.org/en/almighty-pause-container">contenedor de pausa</a> .  El tiempo de ejecución compensa parcialmente este inconveniente, pero este contenedor no desaparece de los pods, ya que se utiliza para configurar su infraestructura. <br><br>  El problema es que este contenedor siempre comienza con <code>AllowPrivilegeEscalation=true</code> , lo que lleva a los problemas <code>AllowPrivilegeEscalation=true</code> en el párrafo 1, y esto no se puede cambiar. <br><br>  Al aplicar los perfiles de seccomp a nivel de contenedor, evita esta trampa y puede crear un perfil que se "afinará" para un contenedor específico.  Esto tendrá que hacerse hasta que los desarrolladores arreglen el error y la nueva versión (¿tal vez 1.18?) Esté disponible para todos. <br><br>  <b>Consejo # 2</b> : Establezca los perfiles de seccomp en el nivel del contenedor. <br><br>  En un sentido práctico, esta regla generalmente sirve como una respuesta universal a la pregunta: "¿Por qué mi perfil seccomp funciona con <code>docker run</code> , pero no funciona después de la implementación en un clúster de Kubernetes?" <br><br><h2>  3. Use el tiempo de ejecución / predeterminado como último recurso </h2><br>  Kubernetes tiene dos opciones para perfiles integrados: <code>runtime/default</code> y <code>docker/default</code> .  Ambos son implementados por el tiempo de ejecución del contenedor, no por Kubernetes.  Por lo tanto, pueden diferir según el tiempo de ejecución utilizado y su versión. <br><br>  En otras palabras, como resultado de cambiar el tiempo de ejecución, el contenedor puede acceder a otro conjunto de llamadas al sistema que puede usar o no usar.  La mayoría de los tiempos de ejecución utilizan <a href="">una implementación de Docker</a> .  Si desea utilizar este perfil, asegúrese de que le quede bien. <br><br>  El <code>docker/default</code> perfil <code>docker/default</code> está en desuso desde Kubernetes 1.11, por lo tanto, evite usarlo. <br><br>  En mi opinión, el perfil de <code>runtime/default</code> es perfecto para el propósito para el que fue creado: para proteger a los usuarios de los riesgos asociados con la <code>docker run</code> en sus máquinas.  Sin embargo, si hablamos de aplicaciones empresariales que se ejecutan en clústeres de Kubernetes, me atrevería a afirmar que dicho perfil es demasiado abierto y que los desarrolladores deberían concentrarse en crear perfiles para sus aplicaciones (o tipos de aplicaciones). <br><br>  <b>Consejo # 3</b> : Cree perfiles seccomp para aplicaciones específicas.  Si esto no es posible, trate con perfiles para tipos de aplicaciones, por ejemplo, cree un perfil avanzado que incluya todas las API de aplicaciones web de Golang.  Solo como último recurso, use runtime / default. <br><br>  En futuras publicaciones, le diré cómo crear perfiles secccomp en el espíritu de SecDevOps, automatizarlos y probarlos en canalizaciones.  En otras palabras, no tendrá excusas para no cambiar a perfiles para aplicaciones específicas. <br><br><h2>  4. No confinado NO es una opción </h2><br>  Desde la <a href="https://www.cncf.io/blog/2019/08/06/open-sourcing-the-kubernetes-security-audit/">primera auditoría de seguridad de Kubernetes,</a> resultó que <a href="https://github.com/kubernetes/kubernetes/issues/81115">seccomp estaba deshabilitado</a> de forma predeterminada.  Esto significa que si no especifica una <code>PodSecurityPolicy</code> que la habilitará en el clúster, todos los pods para los que el perfil seccomp no esté definido funcionarán en el modo <code>seccomp=unconfined</code> . <br><br>  Trabajar en este modo significa que se pierde toda una capa de aislamiento, lo que proporciona protección de clúster.  Este enfoque no es recomendado por los profesionales de seguridad. <br><br>  <b>Consejo # 4</b> : Ningún contenedor en un clúster debería funcionar en modo <code>seccomp=unconfined</code> , especialmente en entornos de producción. <br><br><h2>  5. "Modo de auditoría" </h2><br>  Este punto no es exclusivo de Kubernetes, pero aún cae en la categoría de "lo que debe saber antes de comenzar". <br><br>  Dio la casualidad de que crear perfiles seccomp siempre fue un negocio complicado y se basó en gran medida en prueba y error.  El hecho es que los usuarios simplemente no tienen la oportunidad de probarlos en entornos de producción sin correr el riesgo de "descartar" la aplicación. <br><br>  Después del advenimiento del núcleo Linux 4.14, se hizo posible ejecutar partes del perfil en modo auditoría, registrando información sobre todas las llamadas del sistema en syslog, pero no bloqueándolas.  Puede activar este modo utilizando el parámetro <code>SCMT_ACT_LOG</code> : <br><br>  <i><b>SCMP_ACT_LOG</b> : seccomp no afectará la operación de un subproceso que realiza una llamada al sistema si no se encuentra bajo ninguna regla del filtro, pero se registrará información sobre la llamada al sistema.</i> <br><br>  Aquí hay una estrategia de muestra para usar esta función: <br><br><ol><li>  Permitir llamadas del sistema que sean necesarias. </li><li>  Bloquee los sistemas de llamadas que se sabe que no son útiles. </li><li>  Registre información sobre todas las demás llamadas en el registro. </li></ol><br>  Un ejemplo simplificado es el siguiente: <br><br><pre> <code class="plaintext hljs">{ "defaultAction": "SCMP_ACT_LOG", "architectures": [ "SCMP_ARCH_X86_64", "SCMP_ARCH_X86", "SCMP_ARCH_X32" ], "syscalls": [ { "names": [ "arch_prctl", "sched_yield", "futex", "write", "mmap", "exit_group", "madvise", "rt_sigprocmask", "getpid", "gettid", "tgkill", "rt_sigaction", "read", "getpgrp" ], "action": "SCMP_ACT_ALLOW" }, { "names": [ "add_key", "keyctl", "ptrace" ], "action": "SCMP_ACT_ERRNO" } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/fa4f7a89937c486d940ac8ccf48379c9">medio-mixto-seccomp.json</a> )</i> <br><br>  Pero recuerde que debe bloquear todas las llamadas que se sabe que no se utilizan y que podrían dañar el clúster.  Una buena base para el listado es la <a href="https://docs.docker.com/engine/security/seccomp/">documentación</a> oficial de <a href="https://docs.docker.com/engine/security/seccomp/">Docker</a> .  Explica en detalle qué llamadas al sistema están bloqueadas en el perfil predeterminado y por qué. <br><br>  Sin embargo, hay una trampa.  Aunque <code>SCMT_ACT_LOG</code> compatible con el kernel de Linux desde finales de 2017, solo ha ingresado recientemente al ecosistema de Kubernetes.  Por lo tanto, para utilizar este método, necesitará el kernel de Linux 4.14 y la versión runC no inferior a <a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc9">v1.0.0-rc9</a> . <br><br>  <b>Consejo # 5</b> : Puede crear un perfil de modo de auditoría para probar en producción combinando listas en blanco y negro, y registrar todas las excepciones. <br><br><h2>  6. Use listas blancas </h2><br>  Crear listas blancas requiere esfuerzos adicionales, ya que debe identificar cada llamada que la aplicación pueda necesitar, pero este enfoque mejora significativamente la seguridad: <br><br><blockquote>  <i>Se recomienda encarecidamente que utilice el enfoque de la lista blanca, ya que es más simple y más confiable.</i>  <i>La lista negra deberá actualizarse cada vez que se agregue una llamada al sistema potencialmente peligrosa (o una marca / opción peligrosa si están en la lista negra).</i>  <i>Además, a menudo puede cambiar la presentación de un parámetro sin cambiar su esencia y así evitar las limitaciones de la lista negra.</i> </blockquote><br>  Para las aplicaciones Go, desarrollé una herramienta especial que acompaña a la aplicación y recoge todas las llamadas realizadas en tiempo de ejecución.  Por ejemplo, para la siguiente aplicación: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) }</code> </pre> <br>  ... ejecuta <code>gosystract</code> así: <br><br><pre> <code class="bash hljs">go install https://github.com/pjbgf/gosystract gosystract --template=<span class="hljs-string"><span class="hljs-string">'{{- range . }}{{printf "\"%s\",\n" .Name}}{{- end}}'</span></span> application-path</code> </pre> <br>  ... y obtén el siguiente resultado: <br><br><pre> <code class="plaintext hljs">"sched_yield", "futex", "write", "mmap", "exit_group", "madvise", "rt_sigprocmask", "getpid", "gettid", "tgkill", "rt_sigaction", "read", "getpgrp", "arch_prctl",</code> </pre> <br>  Hasta ahora, esto es solo un ejemplo: los detalles sobre las herramientas serán más detallados. <br><br>  <b>Consejo # 6</b> : Solo permite llamadas que realmente necesites y bloquea a todos los demás. <br><br><h2>  7. Sentar las bases (o prepararse para un comportamiento inesperado) </h2><br>  El kernel supervisará el cumplimiento del perfil sin importar lo que haya registrado en él.  Incluso si esto no es exactamente lo que quería.  Por ejemplo, si bloquea el acceso a llamadas como <code>exit</code> o <code>exit_group</code> , el contenedor no podrá completar el trabajo correctamente e incluso un comando simple como <code>echo hi</code> <a href="https://github.com/kubernetes/kubernetes/issues/85191">suspenderá</a> por un período indefinido.  Como resultado, obtendrá una alta utilización de la CPU en el clúster: <br><br><img src="https://habrastorage.org/webt/32/no/rt/32nortxic_d8czgqc5jnbzrb-ps.png"><br><br>  En tales casos, la utilidad <code>strace</code> puede venir al rescate; mostrará cuál puede ser el problema: <br><br><img src="https://habrastorage.org/webt/hg/l3/eh/hgl3ehuqz8a6eprrsycubq_n6hu.png"><br> <i><code>sudo strace -c -p 9331</code></i> <br> <br>  Asegúrese de que los perfiles contengan todas las llamadas al sistema que necesita la aplicación mientras se está ejecutando. <br><br>  <b>Consejo # 7</b> : Presta atención a las pequeñas cosas y asegúrate de que todas las llamadas al sistema necesarias estén incluidas en la lista blanca. <br><br>  Con esto, la primera parte de una serie de artículos sobre el uso de seccomp en Kubernetes en el espíritu de SecDevOps llega a su fin.  En las siguientes partes hablaremos sobre por qué esto es importante y cómo automatizar el proceso. <br><br><h2>  PD del traductor </h2><br>  Lea también en nuestro blog: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/474012/">Seguridad para contenedores Docker</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/465141/">33+ Herramientas de seguridad de Kubernetes</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/440504/">Docker y Kubernetes en entornos exigentes de seguridad</a> "; </li><li>  "Las <a href="https://habr.com/ru/company/flant/blog/436300/">9 mejores prácticas de seguridad de Kubernetes</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481114/">https://habr.com/ru/post/481114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481102/index.html">Kit de herramientas multiplataforma .NET UI versión AvaloniaUI 0.9</a></li>
<li><a href="../481104/index.html">Mezcla de OpenJDK y NodeJS: interacciones entre idiomas y arquitectura vertical</a></li>
<li><a href="../481106/index.html">Cómo LANIT disparó una comedia de bricolaje en su oficina</a></li>
<li><a href="../481110/index.html">Revisión de Playme VEGA: grabadora combinada con pantalla táctil y montaje en espejo</a></li>
<li><a href="../481112/index.html">¿Qué dirá la "goma de mascar" de 5700 años de la persona que la masticó?</a></li>
<li><a href="../481116/index.html">Publicar automáticamente publicaciones de la comunidad VKontakte en Discord</a></li>
<li><a href="../481118/index.html">Anónimo Santa Claus 2019-2020: publicación con regalos de Año Nuevo</a></li>
<li><a href="../481120/index.html">¿Dónde y cómo se aplican los servidores perimetrales?</a></li>
<li><a href="../481122/index.html">Antipatterns PostgreSQL: pasar conjuntos y selecciones a SQL</a></li>
<li><a href="../481124/index.html">Consejos para escribir código autodocumentado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>