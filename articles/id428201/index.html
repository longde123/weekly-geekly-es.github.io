<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§”ğŸ» ğŸ–•ğŸ½ ğŸ« Lubang mol dalam JavaScript ğŸ“ ğŸ˜‘ ğŸ‘ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan untuk Anda terjemahan artikel "Lubang Cacing dalam JavaScript" oleh Mathius Buus. 





 Komputer adalah mesin yang m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lubang mol dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428201/"><p>  Halo, Habr!  Saya mempersembahkan untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Lubang Cacing dalam JavaScript"</a> oleh Mathius Buus. </p><br><p><img src="https://habrastorage.org/webt/ak/t9/k_/akt9k_w0hs5lodk-p8ezfr4f6pk.jpeg"></p><br><p>  Komputer adalah mesin yang menarik.  Secara teori, mereka bagi kita adalah ahli matematika mekanik ideal yang bekerja dengan angka dan operasi penambahan, perkalian, dan pengurangan yang berkinerja baik. </p><br><p>  Namun, abstraksi semacam itu cukup menyesatkan.  Ini menjauhkan kita dari pemahaman bahwa komputer memproses operasi matematika yang berbeda dengan kecepatan yang berbeda.  Jika Anda menulis dalam JavaScript (atau bahasa lain apa pun) dan peduli dengan kinerja algoritme yang Anda tulis, sangat penting untuk memahami cara kerja komputer di bawah tenda. </p><br><p> Jika kita tahu apa yang mampu dilakukan komputer, kita dapat menggunakan jalur terpendek atau lubang cacing untuk membuat program kita lebih cepat dari yang kita harapkan. </p><a name="habracut"></a><br><h2 id="krotovaya-nora-v-operacii-polucheniya-ostatka-ot-deleniya">  Lubang cacing dalam operasi memperoleh sisa divisi </h2><br><p>  Apa sebenarnya artinya ini?  Mari kita lihat sebuah contoh: bayangkan kita ingin menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar cincin</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar dering</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar</a> ukuran tetap di mana sisipan yang lebih besar dari ukuran daftar dipindahkan ke bagian atas daftar dan dalam lingkaran.  Daftar dering sangat nyaman untuk banyak hal - seperti mengumpulkan statistik untuk interval waktu tertentu, buffering data, dan banyak lagi, tetapi lihat implementasi ini: </p><br><pre><code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">15000</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  % -   ,     //        //    ,     i    list[i % list.length] = item }</span></span></code> </pre> <br><p>  Seberapa cepat kode ini dijalankan?  Mari kita jalankan tes kecepatan sederhana </p><br><pre> <code class="hljs matlab">console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { set(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } console.timeEnd()</code> </pre><br><p>  Di komputer saya, butuh ~ 4 detik untuk 1 miliar sisipan.  Tidak buruk. </p><br><p>  Namun, mari kita terapkan lubang cacing komputasi dan ubah ukuran array menjadi angka ajaib: </p><br><pre> <code class="hljs powershell">//     <span class="hljs-number"><span class="hljs-number">15000</span></span>  <span class="hljs-number"><span class="hljs-number">16384</span></span> const list = new Array(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span></span> { //  % -   ,     //        //    ,     i    list[<span class="hljs-type"><span class="hljs-type">i</span></span> % <span class="hljs-type"><span class="hljs-type">list.length</span></span>] = item }</code> </pre><br><p>  Mari kita coba jalankan tes kinerja lagi.  Di komputer saya, tes selesai dalam ~ 1,5 detik.  Lebih dari dua kali lipat peningkatan karena ukuran sederhana.  Untuk memahami mengapa ini terjadi, kita harus memahami yang berikut, di bawah tenda, komputer bekerja dengan angka dengan basis 2. Penting untuk mengetahui apakah kita mendapatkan sisa pembagian (% operasi).  Perhitungan seperti itu jauh lebih sederhana jika jumlahnya adalah kelipatan dari 2 (2 ^ n) b 16384 itu adalah 2 ^ 14. Sebenarnya, komputer melihat angka dalam bentuk biner dan hanya mengambil n bit terakhir. </p><br><p>  Sebagai contoh: apa yang akan terjadi ketika operasi seperti itu dilakukan 353 500% 16 384?  353 500 dalam representasi biner akan terlihat seperti 1010110010011011100. Sejak 16384 == 2 ^ 14 - kita perlu mengambil 14 bit terakhir - 10101 (10010011011100) atau 9 346. </p><br><p>  Kita bisa menggunakan pengetahuan ini dalam kaitannya dengan lubang cacing lain.  Untuk komputer, sangat sederhana dan cepat untuk mengambil n bit terakhir.  Bahkan, hanya diperlukan untuk menghasilkan biner dan (operasi &amp;) dengan nomor (2 ^ n) - 1 </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    &amp;( )  %    2 ^ n list[i &amp; (list.length - 1)] = i }</span></span></code> </pre> <br><p>  Menjalankan tes kinerja lagi di komputer saya, kita akan melihat bahwa waktu eksekusi akan berkurang hingga ~ 1s atau akan ada peningkatan kinerja empat kali lipat dibandingkan dengan yang dijalankan pertama.  Dan semua ini karena pemahaman tentang cara kerja komputer. </p><br><p>  Smart compiler atau VM dapat melakukan optimasi semacam ini dengan mengubah operasi untuk mendapatkan sisanya di belakang layar menjadi operasi bitwise dan sebaliknya.  Bahkan, V8 Javascript VM terbaru (tidak diimplementasikan di NodeJS) melakukan hal itu. </p><br><h2 id="chislovye-krotovye-nory">  Lubang Cacing Numerik </h2><br><p>  Millill lain yang bermanfaat adalah memahami cara kerja membaca dan menulis angka.  Ingat bagaimana kami menggunakan komputer 32-bit dan bagaimana kami mendapat 64 bit?  Dan hingga 32 bit kami memiliki 16 bit.  Apa sebenarnya artinya ini?  Biasanya kita berpikir seperti ini - berapa banyak RAM yang kita miliki di komputer.  2 ^ 32 = 4294967296 atau 4 GB, yang berarti bahwa kita hanya dapat mengakses 4 GB memori pada komputer 32-bit.  Ketika kami menulis program JS, kami biasanya tidak perlu memikirkannya, karena kami biasanya tidak menggunakan banyak memori. </p><br><p>  Namun, sangat penting untuk memahami perbedaan antara komputer 32-bit dan 64-bit.  Karena prosesor menerima register 64-bit pada komputer 64-bit, operasi menjadi 2 kali lebih cepat daripada pada komputer 32-bit, di mana Anda hanya memiliki register 32-bit. </p><br><p>  Bagaimana kita dapat menggunakan informasi tentang lubang cacing ini? <br>  Mari kita menulis sebuah program sederhana yang menyalin satu Uint8Array ke yang lain.  Jika Anda tidak terbiasa dengan Unit8Arrays, mereka sangat mirip dengan Buffer di NodeJS, atau hanya "bersihkan" memori. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length; i++) { //   <span class="hljs-number"><span class="hljs-number">8</span></span>-  (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>[i] } }</code> </pre> <br><p>  Sekali lagi, mari kita mengukur kecepatan dengan menjalankan tes kinerja. </p><br><pre> <code class="hljs pgsql">//    <span class="hljs-number"><span class="hljs-number">1</span></span>MB Uint8Arrays     const input = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) const output = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1e4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output) } console.timeEnd()</code> </pre><br><p>  Di komputer saya, program diselesaikan dalam ~ 7,5 detik.  Bagaimana kita bisa menggunakan lubang cacing untuk mempercepat?  Menggunakan Uint8Array, kami hanya menyalin 8 bit pada satu waktu, tetapi dengan komputer 64-bit kami dapat menyalin informasi 64 bit sekaligus.  Kita dapat melakukan ini dalam JavaScript dengan mengonversi Uint8Array ke Float64Array sebelum menyalin, yang tidak akan dikenakan biaya apa pun. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length //       <span class="hljs-number"><span class="hljs-number">64</span></span>-  //        , //      <span class="hljs-number"><span class="hljs-number">64</span></span>-  //  BigInts   JavaScript,    BigInt64Array. const input64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) const output64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input64.length; i++) { //   <span class="hljs-number"><span class="hljs-number">64</span></span>-  output64[i] = input64[i] } }</code> </pre><br><p>  Menjalankan tes kinerja lagi, kami mendapatkan runtime 1 detik, yang memberikan peningkatan kecepatan 8 kali lipat. </p><br><p>  Untuk menyalin, solusi yang dapat diterima adalah dengan menggunakan metode array.set (otherArray) untuk Uint8Array, yang memberi kita menyalin dalam kode asli - yang jauh lebih cepat daripada lubang cacing lainnya.  Sebagai referensi, ini akan memberikan hasil ~ 0,2 detik eksekusi dalam pengujian kami di komputer saya, yang 5 kali lebih cepat dari solusi sebelumnya. </p><br><h2 id="galaktika-javascript-polna-krotovyh-nor">  Galaksi JavaScript penuh lubang cacing </h2><br><p>  Menggunakan lubang cacing di atas akan membantu Anda membuat banyak algoritma dunia nyata jauh lebih cepat.  Ada banyak lubang cacing seperti itu.  Favorit saya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Math.clz32</a> , sebuah metode yang mengembalikan jumlah bit nol terdepan dalam representasi biner 32-bit dari sebuah angka.  Kita dapat menggunakan metode ini untuk banyak algoritma yang menarik.  Saya menggunakannya untuk mempercepat implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bidang bit sebanyak</a> 4 kali, yang menyebabkan penurunan konsumsi memori sebesar 4 kali dan memungkinkan saya untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengurutkan angka</a> dalam beberapa situasi jauh lebih cepat. </p><br><p>  Memahami prinsip-prinsip dasar komputer memungkinkan Anda untuk menulis program tercepat yang kami butuhkan.  Pengetahuan ini penting bahkan ketika Anda menulis dalam bahasa tingkat tinggi seperti JavaScript. </p><br><p>  <strong>PS:</strong> </p><br><p>  Terima kasih khusus untuk bantuan dalam menerjemahkan dan menyesuaikan terjemahan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Olga Pereverzeva</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428201/">https://habr.com/ru/post/id428201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428187/index.html">Cara menulis ekstensi untuk GNOME Shell: Mode Jangan Ganggu</a></li>
<li><a href="../id428189/index.html">Siapakah Paladin?</a></li>
<li><a href="../id428191/index.html">Apa yang harus kita atur hackathon, atau Bagaimana kita melakukan hackathon internal</a></li>
<li><a href="../id428193/index.html">Tentang pergi wisata</a></li>
<li><a href="../id428197/index.html">Keuangan pribadi yang efektif. Level 1</a></li>
<li><a href="../id428203/index.html">Kami melihat grafik: perkiraan dan perkiraan untuk pasar cloud computing, data pada tahun 2018</a></li>
<li><a href="../id428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../id428209/index.html">Buku masak pengembang: Resep Desain Berbasis Domain (Bagian 2, struktur dan interaksi)</a></li>
<li><a href="../id428211/index.html">Buku â€œArsitektur evolusi. Dukungan untuk perubahan terus menerus "</a></li>
<li><a href="../id428213/index.html">Bagaimana menafsirkan prediksi model dalam SHAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>