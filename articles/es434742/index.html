<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèª üôÖüèæ üõåüèæ Parte 2: uso de los controladores UDB PSoC de Cypress para reducir el n√∫mero de interrupciones en una impresora 3D ‚ò∏Ô∏è üë®üèª‚Äç‚öñÔ∏è üëû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La √∫ltima vez, consideramos la opci√≥n de generar pulsos para motores paso a paso, parcialmente eliminados del software al nivel de firmware. En caso d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parte 2: uso de los controladores UDB PSoC de Cypress para reducir el n√∫mero de interrupciones en una impresora 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434742/"><img src="https://habrastorage.org/webt/vx/mr/gy/vxmrgyrhaaffninezudmxyiex9c.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La √∫ltima vez,</a> consideramos la opci√≥n de generar pulsos para motores paso a paso, parcialmente eliminados del software al nivel de firmware.  En caso de √©xito completo, esto promete la ausencia de la necesidad de procesar interrupciones que llegan con una frecuencia de hasta 40 kHz.  Pero esa opci√≥n tiene una serie de defectos obvios.  En primer lugar, las aceleraciones no son compatibles all√≠.  En segundo lugar, la granularidad de las frecuencias de paso permitidas en esa soluci√≥n es de cientos de hercios (por ejemplo, es posible generar frecuencias de 40,000 Hz y 39966 Hz, pero es imposible generar frecuencias con una magnitud entre estos dos valores). <br><a name="habracut"></a><br><h2>  Implementaci√≥n de aceleraci√≥n </h2><br>  ¬øEs posible eliminar las desventajas indicadas usando las mismas herramientas UDB sin complicar el sistema?  Vamos a hacerlo bien.  Comencemos con lo m√°s dif√≠cil: con las aceleraciones.  Las aceleraciones se agregan al principio y al final del camino.  En primer lugar, si los pulsos de alta frecuencia se aplican inmediatamente al motor paso a paso, requerir√° una corriente mayor para comenzar la operaci√≥n.  La corriente alta permitida es el calentamiento y el ruido, por lo que es mejor limitarlo.  Pero luego el motor puede omitir los pasos al inicio.  Por lo tanto, es mejor acelerar el motor suavemente.  En segundo lugar, si una cabeza pesada se detiene abruptamente, entonces experimenta transitorios asociados con la inercia.  Las olas son visibles en pl√°stico.  Por lo tanto, es suavemente necesario no solo dispersarse, sino tambi√©n detener la cabeza.  Cl√°sicamente, se presenta un gr√°fico de la velocidad del motor en forma de trapecio.  Aqu√≠ hay un fragmento del c√≥digo fuente del firmware Marlin: <br><br><img src="https://habrastorage.org/webt/wm/gg/ce/wmggcetcc0vy5tfgs3xsr2ewwoc.png"><br><br>  Ni siquiera intentar√© averiguar si es posible implementar esto usando UDB.  Esto se debe al hecho de que otro tipo de aceleraci√≥n ahora est√° de moda: no trapezoidal, sino S-Curve.  Su horario se ve as√≠: <br><br><img src="https://habrastorage.org/webt/rs/hy/q9/rshyq94_sz6et-lgsbrpprdmyks.png"><br><br>  Esto definitivamente no es para UDB.  ¬øRendirse?  ¬°Para nada!  Ya not√© que UDB no implementa una interfaz de hardware, sino que simplemente le permite transferir parte del c√≥digo del software al nivel de firmware.  Deje que el perfil calcule el procesador central, y la formaci√≥n de pulsos escalonados todav√≠a realiza UDB.  El procesador central tiene mucho tiempo para los c√°lculos.  La tarea de eliminar las interrupciones frecuentes continuar√° resolvi√©ndose con bastante elegancia, y nadie plane√≥ llevar el proceso por completo al nivel de firmware. <br><br>  Por supuesto, el perfil deber√° estar preparado en la memoria, y UDB recoger√° los datos de all√≠ utilizando DMA.  ¬øPero cu√°nta memoria se requiere?  Un mil√≠metro necesita 200 pasos.  ¬°Ahora con codificaci√≥n de 24 bits, esto es 600 bytes por 1 mm de movimiento de cabeza!  Una vez m√°s, ¬ørecuerdas las interrupciones no tan frecuentes pero constantes para transmitir todo en fragmentos?  En realidad no!  El hecho es que el mecanismo DMA de PSoC se basa en descriptores.  Habiendo ejecutado la tarea desde un descriptor, el controlador DMA pasa al siguiente.  Y as√≠, a lo largo de la cadena, puedes usar muchos descriptores.  Ilustramos esto con algunos dibujos de la documentaci√≥n oficial: <br><br><img src="https://habrastorage.org/webt/ju/hv/6b/juhv6bqptp3uagog5bfgxlmxw0q.png"><br><br>  En realidad, este mecanismo tambi√©n se puede utilizar construyendo una cadena de tres descriptores: <br><br><table><tbody><tr><th>  No </th><th>  Explicaci√≥n </th></tr><tr><td>  1 </td><td>  De memoria a FIFO con incremento de direcci√≥n.  Indica una secci√≥n con un perfil de aceleraci√≥n. </td></tr><tr><td>  2 </td><td>  De memoria a FIFO sin incremento de direcci√≥n.  Env√≠a todo el tiempo a la misma palabra en la memoria para una velocidad constante. </td></tr><tr><td>  3 </td><td>  De memoria a FIFO con incremento de direcci√≥n.  Indica una secci√≥n con un perfil de frenado. <br></td></tr></tbody></table><br>  Resulta que la ruta principal se describe en el paso 2, y all√≠ se usa f√≠sicamente la misma palabra, que establece la velocidad constante.  El consumo de memoria no es grande.  En realidad, el segundo descriptor puede estar f√≠sicamente representado por dos o tres descriptores.  Esto se debe al hecho de que la longitud m√°xima de bombeo, seg√∫n TRM, puede ser de 64 kilobytes (la enmienda ser√° menor).  Es decir, 32.767 palabras.  Que a 200 pasos por mil√≠metro corresponder√° a una trayectoria de 163 mil√≠metros.  Puede que tenga que hacer un segmento de dos o tres partes, dependiendo de la distancia m√°xima que el motor puede recorrer a la vez. <br><br>  Sin embargo, para ahorrar memoria (y el gasto de los bloques UDB), propongo abandonar los bloques DatapPath de 24 bits, cambiando a los m√°s econ√≥micos de 16 bits. <br><br>  <b>Entonces</b>  <b>La primera propuesta de revisi√≥n.</b> <b><br><br></b>  <b>Las matrices se preparan en la memoria que codifica la duraci√≥n de los pasos.</b>  <b>Adem√°s, esta informaci√≥n va a UDB usando DMA.</b>  <b>La secci√≥n rectil√≠nea est√° codificada por una matriz de un elemento, el bloque DMA no aumenta la direcci√≥n, eligiendo el mismo elemento todo el tiempo.</b>  <b>Las secciones de aceleraci√≥n, rectil√≠neas y de frenado est√°n conectadas por los medios disponibles en el controlador DMA.</b> <br><br><h2>  Ajuste fino de rango medio </h2><br>  Ahora consideraremos c√≥mo superar el problema de la granularidad de frecuencia.  Por supuesto, no ser√° posible configurarlo exactamente.  Pero, de hecho, el "firmware" original tampoco puede hacer esto.  En cambio, usan el algoritmo de Bresenham.  Se agrega un retraso de una medida a algunos pasos.  Como resultado, la frecuencia promedio se vuelve intermedia, entre un valor m√°s peque√±o y uno m√°s grande.  Al ajustar la proporci√≥n de per√≠odos regulares y extendidos, puede cambiar suavemente la frecuencia promedio.  Si nuestra velocidad ahora se establece no a trav√©s del registro de datos, sino que se transmite a trav√©s de FIFO, y la cantidad de pulsos generalmente se establece a trav√©s de la cantidad de palabras transmitidas a trav√©s de DMA, ambos registros de datos en UDB se liberan.  Adem√°s, tambi√©n se libera una de las bater√≠as, que cuenta el n√∫mero de pulsos.  Aqu√≠ construiremos un cierto PWM sobre ellos. <br><br>  Por lo general, las ALU comparan y asignan registros con el mismo √≠ndice.  Cuando un registro tiene un √≠ndice de 0 y el otro tiene un 1, no se pueden implementar todas las versiones de la operaci√≥n.  Pero logr√© armar el solitario de los registros bajo los cuales se puede hacer PWM.  Result√≥ como se muestra en la figura. <br><br><img src="https://habrastorage.org/webt/nc/yv/vq/ncyvvqcqptj3lm4an82idlrrl-c.png"><br><br>  Cuando se cumple la condici√≥n A0 &lt;D1, agregaremos un latido adicional a la longitud de pulso dada.  Cuando la condici√≥n no se cumple, no lo haremos. <br><br><h2>  Caballo esf√©rico en condiciones normales. </h2><br>  Entonces, comenzamos a modificar el bloque desarrollado para UDB, teniendo en cuenta la nueva arquitectura.  Reemplace la profundidad de bits de Datapath: <br><br><img src="https://habrastorage.org/webt/cj/-m/ae/cj-mae3coaxgzro0er5mkraun4q.png"><br><br>  Necesitaremos muchas m√°s salidas de Datapath que la √∫ltima vez. <br><br><img src="https://habrastorage.org/webt/ua/td/hn/uatdhnswe_uzmqinll0wyhsyifg.png"><br><br>  Al hacer doble clic en ellos, vemos los detalles: <br><br><img src="https://habrastorage.org/webt/vq/3p/24/vq3p24frqv0uiumytbvn-ewhi1w.png"><br><br>  Hay m√°s d√≠gitos para la variable <b>Estado</b> , ¬°no olvides conectar la m√°s antigua!  En la versi√≥n anterior, hab√≠a un constante 0. <br><br><img src="https://habrastorage.org/webt/0l/dm/fy/0ldmfyci2byicjdsksvkdkg8k04.png"><br><br>  El gr√°fico de transici√≥n del aut√≥mata me sale as√≠: <br><br><img src="https://habrastorage.org/webt/hb/5u/nq/hb5unqu_fmfc6sd9k7m3_x0wr7s.png"><br><br>  Estamos en estado <b>inactivo</b> mientras FIFO1 est√° vac√≠o.  Por cierto, trabajar con FIFO1 y no FIFO0 es el resultado de la formaci√≥n misma del solitario.  El registro A0 se usa para implementar PWM, por lo que el ancho de pulso se determina mediante el registro A1.  Y puedo descargarlo solo de FIFO1 (tal vez hay otros m√©todos secretos, pero no los conozco).  Por lo tanto, DMA carga datos exactamente a FIFO1, y es precisamente el estado <b>"No vac√≠o"</b> para FIFO1 el que sale del estado <b>Inactivo</b> . <br><br>  ALU en estado <b>IDLE</b> anula el registro A0: <br><br><img src="https://habrastorage.org/webt/1r/i5/-i/1ri5-iydlu00cfobufepmiaqucg.png"><br><br>  Esto es necesario para que al comienzo de la operaci√≥n PWM, siempre comience a funcionar desde el principio. <br>  Pero los datos llegaron al FIFO.  La m√°quina pasa al estado <b>LoadData</b> : <br><br><img src="https://habrastorage.org/webt/3v/rf/dx/3vrfdxwme_jw6m69bwrpybhiots.png"><br><br>  En este estado, la ALU carga la siguiente palabra del FIFO en el registro A1.  En el camino, para no crear estados innecesarios, se incrementa el valor del contador A0, que se utiliza para trabajar con PWM: <br><br><img src="https://habrastorage.org/webt/t4/ki/je/t4kijee95z-kbmn1n3ikcgtc9qk.png"><br><br>  Si el contador A0 a√∫n no ha alcanzado el valor D0 (es decir, se activa la condici√≥n A0 &lt;D0, <b>activando</b> el indicador <b>NoNeedReloadA0</b> ), pasamos al estado <b>Uno</b> .  De lo contrario, el estado es <b>ClearA0</b> . <br><br>  En el estado <b>ClearA0, la</b> ALU simplemente pone a cero el valor de A0, comenzando un nuevo ciclo PWM: <br><br><img src="https://habrastorage.org/webt/0_/pj/ah/0_pjahunjhl34izkpv5k9lplxem.png"><br><br>  despu√©s de lo cual la m√°quina tambi√©n entra en <b>un</b> estado, solo un latido m√°s tarde. <br><br>  <b>Uno nos</b> es familiar de la versi√≥n anterior de la m√°quina.  ALU en √©l no realiza ninguna funci√≥n. <br><br>  Y as√≠, en este estado, se genera una unidad a la salida de <b>Out_Step</b> (aqu√≠ el optimizador funcion√≥ mejor cuando la unidad es producida por la condici√≥n, esto se detect√≥ emp√≠ricamente). <br><br><img src="https://habrastorage.org/webt/aq/mj/ml/aqmjmluzxutxzq_caddtls15hfc.png"><br><br>  Estamos en este estado hasta que el contador de siete bits que ya conocemos se restablezca a cero.  Pero si antes sal√≠amos de este estado por un camino, ahora puede haber dos caminos: directo y retrasado al ritmo. <br><br><img src="https://habrastorage.org/webt/53/fk/qc/53fkqcxnlvsf52sxzb8e1ijnpkk.png"><br><br>  Entraremos en el estado ExtraTick si se establece el indicador <b>AddCycle</b> , que se asigna para cumplir la condici√≥n A0 &lt;D1.  En este estado, la ALU no realiza ninguna acci√≥n beneficiosa.  Es solo que el ciclo dura 1 latido m√°s.  Adem√°s, todas las rutas convergen en estado de <b>retraso</b> . <br><br>  Esta condici√≥n mide la duraci√≥n del pulso.  El registro A1 (cargado mientras a√∫n est√° en el estado de <b>carga</b> ) se reduce hasta llegar a cero. <br><br><img src="https://habrastorage.org/webt/bi/ct/jt/bictjtwgqikkvuz4pqmp7owacii.png"><br><br>  Adem√°s, dependiendo de si hay datos adicionales en FIFO o no, la m√°quina cambiar√° a buscar la siguiente porci√≥n en el estado de <b>carga</b> o en el estado <b>inactivo</b> .  Veamos esto no en la figura (hay flechas largas, todo ser√° peque√±o), sino en forma de tabla, haciendo doble clic en el estado <b>Retraso</b> : <br><br><img src="https://habrastorage.org/webt/bb/cr/dq/bbcrdq1jfhxret5vbaoexfsr-iq.png"><br><br>  Ahora sale de UDB.  Convert√≠ el indicador de estar en estado <b>inactivo</b> en una comparaci√≥n asincr√≥nica (en la versi√≥n anterior hab√≠a un disparador que se activ√≥ y restableci√≥ en varios estados), ya que para ello el optimizador mostr√≥ el mejor resultado.  Adem√°s, se agreg√≥ la bandera <b>Hungry</b> , indicando a la unidad DMA que estaba lista para recibir datos.  Est√° enrollado en la bandera <b>"FIFO1 no est√° lleno"</b> .  Como no est√° lleno, DMA puede cargar otra palabra de datos all√≠. <br><br><img src="https://habrastorage.org/webt/w8/ea/b-/w8eab-2dwdxvtvyr3hfukjrev9w.png"><br><br>  En la parte autom√°tica, eso es todo. <br><br>  Agregue bloques DMA al diagrama principal del proyecto.  Por el momento, comenc√© a interrumpir los indicadores de terminaci√≥n de DMA, pero no el hecho de que esto sea correcto.  Cuando se completa el proceso de acceso directo a la memoria, puede comenzar un nuevo proceso relacionado con el mismo segmento, pero no puede comenzar a completar la informaci√≥n sobre el nuevo segmento.  FIFO todav√≠a tiene tres o cuatro elementos.  En este momento, todav√≠a es imposible reprogramar los registros D0 y D1 del bloque basados ‚Äã‚Äãen UDB, todav√≠a son necesarios para la operaci√≥n.  Por lo tanto, es posible que las interrupciones basadas en las salidas <b>Out_Idle</b> se agreguen <b>m√°s tarde</b> .  Pero esa cocina ya no se relacionar√° con la programaci√≥n de bloques UDB, por lo que solo la mencionaremos de pasada. <br><br><img src="https://habrastorage.org/webt/4o/g7/y2/4og7y21diqgqr6qn7_iehukiqho.png"><br><br><h2>  Experimentos de software </h2><br>  Como ahora no se sabe todo, no escribiremos ninguna funci√≥n especial.  Todos los controles se realizar√°n "En la frente".  Luego, bas√°ndose en experimentos exitosos, se pueden escribir funciones API.  Entonces  Hacemos que la funci√≥n <b>main () sea</b> m√≠nima.  Simplemente configura el sistema e invoca la prueba seleccionada. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CyGlobalIntEnable; <span class="hljs-comment"><span class="hljs-comment">/* Enable global interrupts. */</span></span> <span class="hljs-comment"><span class="hljs-comment">// isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); // TestShortSteps(); TestWithPacking (); for(;;) { }</span></span></code> </pre> <br>  Intentemos enviar un paquete de pulsos llamando a una funci√≥n, verificando el hecho de insertar un pulso adicional.  La llamada a la funci√≥n es simple: <br><br><pre> <code class="plaintext hljs">TestShortSteps();</code> </pre><br>  Pero el cuerpo requiere explicaci√≥n. <div class="spoiler">  <b class="spoiler_title">Dar√© toda la funci√≥n primero</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestShortSteps() { //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Ahora considere sus partes importantes. <br><br>  Si la longitud de la parte positiva del pulso es igual a 92 ciclos de reloj, entonces el osciloscopio no podr√° discernir si hay una inserci√≥n de ciclo √∫nico en la parte negativa o no.  La escala no ser√° la misma.  Es necesario hacer que la parte positiva sea lo m√°s corta posible para que el pulso total sea comparable en escala con el latido insertado.  Por lo tanto, cambio a la fuerza el per√≠odo del contador que establece la duraci√≥n de la parte positiva del pulso: <br><br><pre> <code class="plaintext hljs"> //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6);</code> </pre><br>  ¬øPero por qu√© seis medidas enteras?  ¬øPor qu√© no tres?  ¬øPor qu√© no dos?  ¬øPor qu√©, despu√©s de todo, no uno?  Esta es una historia triste.  Si el pulso positivo es m√°s corto que 6 ciclos, entonces el sistema no funciona.  La depuraci√≥n prolongada en un osciloscopio con la salida de l√≠neas de prueba al exterior mostr√≥ que DMA no es algo r√°pido.  Si la m√°quina est√° funcionando por menos de una cierta duraci√≥n, para el momento en que <b>abandona el</b> estado de <b>Retardo</b> , FIFO casi siempre est√° vac√≠o.  ¬°Es posible que a√∫n no se haya colocado una sola palabra de datos nueva!  Y solo cuando la parte positiva del pulso tiene una duraci√≥n de 6 ciclos, se garantiza que FIFO tendr√° tiempo para cargar ... <br><br><h2>  Digresi√≥n de latencia </h2><br>  Otra idea de soluci√≥n que se encuentra en mi cabeza es la aceleraci√≥n de hardware de ciertas funciones del n√∫cleo de nuestro RTOS MAX.  Pero, por desgracia, todas mis mejores ideas est√°n rotas sobre esas mismas latencias. <br><br>  Hubo un caso, estudi√© el desarrollo de aplicaciones Bare Metal para Cyclone V SoC.  Pero result√≥ que trabajar con registros FPGA √∫nicos (cuando se les escribe alternativamente y luego se les lee) reduce la operaci√≥n central cientos (!!!) veces.  Escuchaste bien.  Est√° en cientos.  Adem√°s, todo esto est√° mal documentado, pero al principio lo percib√≠ internamente y luego, a partir de fragmentos de la documentaci√≥n, prob√© que las latencias eran culpables al pasar solicitudes a trav√©s de un mont√≥n de puentes.  Si necesita expulsar una gran matriz, tambi√©n habr√° latencia, pero en t√©rminos de una palabra bombeada, no ser√° significativa.  Cuando las solicitudes son √∫nicas (y la aceleraci√≥n de hardware del n√∫cleo del sistema operativo solo las implica), la desaceleraci√≥n se produce exactamente cientos de veces.  Ser√° mucho m√°s r√°pido hacer todo de una manera puramente de software, cuando el programa trabaje con la memoria principal a trav√©s de la cach√© a una velocidad fren√©tica. <br><br>  En PSoC, tambi√©n ten√≠a ciertos planes.  En apariencia, puedes buscar maravillosamente datos en una matriz usando DMA y UDB.  ¬°Qu√© hay realmente all√≠!  ¬°Debido a la estructura del descriptor DMA, estos controladores podr√≠an realizar una b√∫squeda completamente de hardware en las listas vinculadas!  Pero despu√©s de recibir el enchufe descrito anteriormente, me di cuenta de que tambi√©n est√° asociado con la latencia.  Aqu√≠, esta latencia se describe maravillosamente en la documentaci√≥n.  Tanto en la familia TRM como en un documento separado <b>AN84810 - Temas de PSoC 3 y PSoC 5LP Advanced DMA</b> .  All√≠ la secci√≥n 3.2 est√° dedicada a esto.  Entonces se cancela la pr√≥xima aceleraci√≥n de hardware.  Una pena  Pero, como dijo Semyon Semyonovich Gorbunkov: "Vamos a buscar". <br><br><h2>  Experimentos continuos de software </h2><br>  A continuaci√≥n, configuro los par√°metros del algoritmo de Bresenham: <br><br><pre> <code class="plaintext hljs"> //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2);</code> </pre><br>  Bueno, luego viene el c√≥digo regular que transfiere una serie de palabras a trav√©s de DMA a FIFO1 de la unidad de control del motor X. <br><br>  El resultado requiere alguna explicaci√≥n.  Aqu√≠ esta: <br><br><img src="https://habrastorage.org/webt/bi/hg/ie/bihgiepg_iskg-wor_g4iqnv1ti.png"><br><br>  El valor del contador A0 se muestra en rojo cuando la m√°quina est√° en el estado <b>Uno</b> .  El asterisco verde muestra los casos en que se inserta el retraso debido a que la m√°quina est√° en estado <b>ExtraTick</b> .  Tambi√©n hay barras donde el retraso se debe a estar en el estado <b>ClearA0</b> , est√°n marcadas con una cuadr√≠cula azul. <br><br>  Como puede ver, cuando ingresa por primera vez se pierde el primer retraso.  Esto se debe al hecho de que A0 se restablece cuando est√° en <b>inactivo</b> , pero aumenta cuando ingresa <b>LoadData</b> .  Por lo tanto, hasta el punto de an√°lisis (salida del estado de <b>Uno</b> ), ya es igual a la unidad.  La cuenta comienza con ella.  Pero en general, esto no afectar√° la frecuencia media.  Solo hay que tenerlo en cuenta.  Como debe tenerse en cuenta que al restablecer A0, el reloj tambi√©n se insertar√°.  Debe tenerse en cuenta al calcular la frecuencia promedio. <br><br>  Pero en general, el n√∫mero de pulsos es correcto.  Su duraci√≥n tambi√©n es cre√≠ble. <br>  Intentemos programar una cadena de descriptores m√°s real, <br><br><div class="spoiler">  <b class="spoiler_title">consistente en una fase de aceleraci√≥n, movimiento lineal y frenado.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestWithPacking(int countOnLinearStage) { //   ,   //     . //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //    static const uint16 accelerate[] = {0x0010,0x0008,0x0004}; //    static const uint16 deccelerate[] = {0x004,0x0008,0x0010}; //  .    . static const uint16 steps[] = {0x0001}; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //   uint8 tdDeccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdDeccelerate, sizeof(deccelerate), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdDeccelerate, LO16((uint32)deccelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //       uint8 tdSteps = CyDmaTdAllocate(); //   !!! //     !!! CyDmaTdSetConfiguration(tdSteps, countOnLinearStage, tdDeccelerate, /*TD_INC_SRC_ADR |*/ TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdSteps, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //   //     !!! uint8 tdAccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdAccelerate, sizeof(accelerate), tdSteps, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdAccelerate, LO16((uint32)accelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, tdAccelerate); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Primero, llame para los mismos diez pasos (en DMA, 20 bytes realmente van): <br><br><pre> <code class="plaintext hljs">TestWithPacking (20);</code> </pre><br>  El resultado es el esperado.  Al principio, la aceleraci√≥n es visible.  Y la salida a <b>IDLE</b> (rayo azul) ocurre con un gran retraso desde el √∫ltimo pulso, fue entonces cuando el √∫ltimo paso se complet√≥ por completo, su valor es aproximadamente igual al valor del primero. <br><br><img src="https://habrastorage.org/webt/5y/tb/na/5ytbna9ixcuxv5-i35tinzixy0e.png"><br><br><h2>  Caballo real en condiciones normales </h2><br>  Al remodelar el equipo, de alguna manera salte de un ancho de pulso de 24 bits a un trabajo de 16 bits.  Pero descubrimos que esto no se puede hacer: la frecuencia de pulso m√≠nima ser√° demasiado alta.  Lo hice intencionalmente.  El hecho es que la t√©cnica para expandir la capacidad de bits de un contador de 16 bits result√≥ ser tan complicada que si hubiera comenzado a describirla junto con la m√°quina principal, habr√≠a desviado toda la atenci√≥n.  Por lo tanto, lo consideramos por separado. <br><br>  Tenemos una bater√≠a de 16 bits.  Decid√≠ agregar la entidad est√°ndar de contador de siete bits a los bits altos.  ¬øQu√© es este contador de siete bits?  Este es el dise√±o que est√° disponible en cada bloque UDB (el bloque UDB base tiene un ancho de bits de todos los registros de 8 bits, el aumento en la profundidad de bits est√° determinado por la combinaci√≥n de bloques en grupos).  De los mismos recursos, se pueden implementar registros de <b>Control / Estado</b> .  Ahora tenemos un contador y no un solo par <b>Control / Estado</b> para 16 bits de datos.  Entonces, al agregar otro contador al sistema, no demoraremos los recursos adicionales.  Solo tomamos lo que ya nos ha sido asignado.  Eso es lindo!  Realizamos el byte alto del contador de ancho de pulso a trav√©s de este mecanismo y obtenemos el ancho total del contador de ancho de pulso igual a 23 bits. <br><br><img src="https://habrastorage.org/webt/_k/nc/-h/_knc-hzlxwos6a8jdzopy3pj2ww.png"><br><br>  Primero dir√© lo que estaba pensando.  Pens√© que despu√©s de salir del estado de <b>Retraso</b> , comprobar√≠a la finalizaci√≥n del recuento de este contador adicional.  Si no ha terminado de contar, reducir√© su valor y volver√© al estado de <b>Retraso</b> .  Si cont√≥, la l√≥gica seguir√° siendo la misma, sin agregar ciclos adicionales. <br><br>  Adem√°s, la documentaci√≥n para este contador dice que tengo raz√≥n.  Literalmente dice: <br><blockquote>  Periodo <br>  Define el valor de registro del per√≠odo inicial.  Para un per√≠odo de N relojes, el valor del per√≠odo debe establecerse en el valor de N-1.  El contador contar√° desde N-1 hasta 0, lo que resulta en un per√≠odo de ciclo de reloj N.  <b><i>Un valor de registro de per√≠odo de 0 no es compatible y dar√° como resultado que la salida de recuento de terminales se mantenga en un estado alto constante.</i></b> </blockquote>  La vida ha demostrado que todo es diferente.  Deduc√≠ el estado de la l√≠nea de <b>conteo de terminales</b> en el osciloscopio y observ√© su valor en un cero precargado en <b>Periodo</b> y durante la carga del programa.  Ay y ah.  ¬°No hubo <b>un estado alto constante</b> ! <br><br>  Por prueba y error, logr√© que el sistema funcionara correctamente, pero para que esto suceda, ¬°debe suceder al menos una resta del contador!  El nuevo estado de <b>"resta"</b> no <b>est√°</b> del lado.  Ten√≠a que ser encajado en el camino requerido.  Se encuentra frente al estado de <b>retraso</b> y se llama <b>Next65536</b> . <br><br><img src="https://habrastorage.org/webt/cp/6f/oz/cp6fozy_kflvs6eu6w-ho9ebmcu.png"><br><br>  ALU en este estado no realiza ninguna acci√≥n √∫til.  En realidad, solo un nuevo contador reacciona al hecho de estar en este estado.  Aqu√≠ est√° en el diagrama: <br><br><img src="https://habrastorage.org/webt/mh/tb/br/mhtbbr8strxue23n6jmg_giocjc.png"><br><br>  Aqu√≠ est√°n sus propiedades con m√°s detalle: <br><br><img src="https://habrastorage.org/webt/oo/t5/rs/oot5rs3_cdplwr94gno3poavzkq.png"><br><br>  En general, teniendo en cuenta los art√≠culos anteriores, la esencia de este contador es clara.  Solo la l√≠nea <b>Enable</b> est√° sufriendo.  Nuevamente, no entiendo completamente por qu√© deber√≠a estar encendido cuando la m√°quina est√° en el estado <b>LoadData</b> (luego el contador vuelve a cargar el valor del per√≠odo).  Tom√© prestado este truco de las propiedades del contador que controla los LED, tomado del autor ingl√©s de la unidad de control para esos LED.  Sin √©l, el valor cero del per√≠odo no funciona.  Ella trabaja con ella <br><br>  En el c√≥digo API, agregamos la inicializaci√≥n de un nuevo contador.  Ahora la funci√≥n de inicio se ve as√≠: <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start `$INSTANCE_NAME`_Plus65536_Start(); }</code> </pre><br>  Veamos el nuevo sistema.  Aqu√≠ est√° el c√≥digo de funci√≥n para probar <br><br><div class="spoiler">  <b class="spoiler_title">(solo la primera l√≠nea difiere de la ya conocida):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void JustTest(int extra65536s) { //      65536  StepperController_X_Plus65536_WritePeriod((uint8) extra65536s); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x1000,0x1000,0x1000,0x1000 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Lo llamamos as√≠: <br><br><pre> <code class="plaintext hljs"> JustTest(0);</code> </pre><br>  En el osciloscopio vemos lo siguiente (haz amarillo - salida STEP, azul - valor de la salida TC del contador para el control del proceso).  La duraci√≥n del pulso se establece mediante la matriz de <b>pasos</b> .  En cada paso, la duraci√≥n es de 0x1000 medidas. <br><br><img src="https://habrastorage.org/webt/ap/q7/df/apq7dfk6t5kns3qtzjmkuzzw-44.png"><br><br>  Cambie a otro escaneo para que haya compatibilidad entre diferentes resultados: <br><br><img src="https://habrastorage.org/webt/zl/6s/2o/zl6s2oop2bft0ndatbawfdrtacw.png"><br><br>  Cambie la llamada de funci√≥n a esto: <br><br><pre> <code class="plaintext hljs"> JustTest(1);</code> </pre><br>  El resultado es el esperado.  Primero, la salida TC es cero para 0x1000 ciclos, luego, una unidad para 0x10000 (65536d) ciclos.  La frecuencia es aproximadamente igual a 700 hertz, descubrimos en la √∫ltima parte del art√≠culo, por lo que todo est√° bien. <br><br><img src="https://habrastorage.org/webt/nm/5q/6s/nm5q6s73zb7yqxtvuxzrxis4f5i.png"><br><br>  Bueno, probemos un deuce: <br><br><pre> <code class="plaintext hljs"> JustTest(2);</code> </pre><br>  Obtenemos: <br><br><img src="https://habrastorage.org/webt/ah/sp/7y/ahsp7ymdefdyl04acuefc3ufct8.png"><br><br>  Eso es correcto  La salida TC se invierte a uno en los √∫ltimos 65536 ciclos de reloj.  Antes de eso, estaba en cero durante 0x1000 + 0x10000 ciclos. <br><br>  Por supuesto, con este enfoque, todos los pulsos deben ir con el mismo valor del nuevo contador.  Es imposible hacer un pulso con el byte m√°s alto durante la aceleraci√≥n, digamos 3, luego 1, luego 0. Pero, de hecho, a frecuencias tan bajas (menos de setecientos hertzios) las aceleraciones no tienen un significado f√≠sico, por lo tanto, este problema puede descuidarse.  A esta frecuencia, puede trabajar con el motor linealmente. <br><br><h2>  Volar en la pomada </h2><br>  El documento TRM para la familia PSoC5LP dice: <br><blockquote>  Cada transacci√≥n puede ser de 1 a 64 KB </blockquote>  Pero en el ya mencionado AN84810 hay una frase as√≠: <br><blockquote>  1. ¬øC√≥mo puede almacenar m√°s de 4095 bytes usando DMA? <br>  El conteo m√°ximo de transferencia de un TD est√° limitado a 4095 bytes.  Si necesita transferir m√°s de 4095 bytes usando un solo canal DMA, use m√∫ltiples TDs y encad√©nelos como se muestra en el Ejemplo 5. </blockquote>  ¬øQui√©n tiene la raz√≥n?  Si realiza experimentos, los resultados se inclinar√°n a favor de la peor de las declaraciones, pero el comportamiento ser√° completamente incomprensible.  Todo el error es esta verificaci√≥n en la API: <br><br><img src="https://habrastorage.org/webt/ib/5s/i2/ib5si2yxxn4e_idcohactjo2j-u.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">cystatus CyDmaTdSetConfiguration(uint8 tdHandle, uint16 transferCount, uint8 nextTd, uint8 configuration) \ { cystatus status = CYRET_BAD_PARAM; if((tdHandle &lt; CY_DMA_NUMBEROF_TDS) &amp;&amp; (0u == (0xF000u &amp; transferCount))) { /* Set 12 bits transfer count. */ reg16 *convert = (reg16 *) &amp;CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[0u]; CY_SET_REG16(convert, transferCount); /* Set Next TD pointer. */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[2u] = nextTd; /* Configure the TD */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[3u] = configuration; status = CYRET_SUCCESS; } return(status); }</code> </pre><br></div></div><br>  Si se especifica una transacci√≥n de m√°s de 4095 bytes, se usar√° la configuraci√≥n anterior.  S√≠, no pens√© en comprobar los c√≥digos de error ... <br><br>  Los experimentos mostraron que si elimina esta comprobaci√≥n, la longitud real se cortar√° utilizando la m√°scara 0xfff (4096 = 0x1000).  Ay y ah.  Todas las esperanzas de un trabajo agradable se derrumbaron.  Por supuesto, puede crear cadenas de descriptores relacionados en 4K.  Pero, digamos, 64K son 16 cadenas.  Tres motores activos (las extrusoras tendr√°n menos pasos): 48 cadenas.  Exactamente tanto debe llenarse en el peor de los casos, antes de cada segmento.  Quiz√°s sea aceptable a tiempo.  Como m√≠nimo, hay 127 descriptores disponibles, por lo que definitivamente habr√° suficiente memoria. <br><br>  Puede enviar los datos faltantes seg√∫n sea necesario.  Se produjo una interrupci√≥n debido a que el canal DMA hab√≠a completado el trabajo, estamos transfiri√©ndole otro segmento.  En este caso, no se requieren c√°lculos, el segmento ya est√° formado, todo ser√° r√°pido.  Y no hay requisitos de rendimiento: cuando se emite una solicitud de interrupci√≥n, habr√° 4 elementos m√°s en FIFO que ser√°n atendidos cada uno durante varios cientos o incluso miles de ciclos de reloj.  Es decir, todo es real.  Una estrategia espec√≠fica ser√° m√°s f√°cil de elegir durante el trabajo real.  Pero un error en la documentaci√≥n (TRM) ech√≥ a perder todo el estado de √°nimo.  Si esto se supiera de antemano, tal vez no habr√≠a verificado la metodolog√≠a. <br><br><h2>  Conclusi√≥n </h2><br>  En apariencia, la herramienta de firmware auxiliar desarrollada se volvi√≥ aceptable, por lo que, sobre la base, ser√≠a posible hacer una versi√≥n del "Firmware", por ejemplo, Marlin, que no est√° constantemente en el controlador de interrupciones para motores paso a paso.  Hasta donde s√©, esto es especialmente cierto para las impresoras Delta, donde la demanda de recursos inform√°ticos es bastante alta.  Quiz√°s esto eliminar√° la afluencia que ocurre en mi Delta en lugares donde se detiene la cabeza.  En el MZ3D en estos mismos lugares no se observa afluencia.  Si es cierto o no, el tiempo lo dir√°, y el informe sobre esto deber√° publicarse en una rama completamente diferente. <br><br>  Mientras tanto, hemos visto que en el bloque UDB, a pesar de su simplicidad, es bastante posible implementar un coprocesador que funcione en conjunto con el procesador principal y que permita que se descargue.  Y cuando hay muchas de estas unidades, los coprocesadores pueden trabajar en paralelo. <br><br>  Un error en la documentaci√≥n del controlador DMA borr√≥ el resultado.  No obstante, se requieren interrupciones, pero no con la misma frecuencia y con la criticidad en el tiempo que estaba en la versi√≥n original.  Por lo tanto, el estado de √°nimo se echa a perder, pero el uso de un "coprocesador" basado en UDB todav√≠a ofrece una ganancia considerable en comparaci√≥n con el trabajo puramente de software. <br><br>  En el camino, se revel√≥ que DMA funciona a una velocidad bastante baja.  Como resultado de esto, se realizaron algunas mediciones tanto en el PSoC5LP como en el STM32.  Los resultados sacan otro art√≠culo.  Quiz√°s alg√∫n d√≠a lo haga si el tema resulta interesante. <br><br>  Como resultado de los experimentos, se obtuvieron dos proyectos de prueba a la vez.  El primero es m√°s f√°cil de entender.  Puedes llevarlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  El segundo se hereda del primero, pero se confunde al agregar un contador de siete bits y la l√≥gica asociada.  Puedes llevarlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Por supuesto, estos ejemplos son solo de prueba.  Todav√≠a no hay tiempo libre para integrarse en el "firmware" real.  Pero dentro del marco de estos art√≠culos, es m√°s importante practicar trabajar con UDB. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434742/">https://habr.com/ru/post/es434742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434732/index.html">Vida a 6200 DPI. Revisi√≥n de HyperX Pulsefire Core</a></li>
<li><a href="../es434734/index.html">Transformada de Fourier. El r√°pido y el furioso</a></li>
<li><a href="../es434736/index.html">Usando la base de datos de registro de Mikrotik para suprimir la fuerza bruta</a></li>
<li><a href="../es434738/index.html">Aprendizaje de refuerzo en Python</a></li>
<li><a href="../es434740/index.html">Red neuronal ense√±ada a detectar paneles solares en im√°genes satelitales y predecir el nivel de su distribuci√≥n</a></li>
<li><a href="../es434744/index.html">Samsung SSD 860 QVO 1 TB y 4 TB: el primer consumidor SATA QLC (2 partes)</a></li>
<li><a href="../es434746/index.html">BLE bajo microscopio 4</a></li>
<li><a href="../es434750/index.html">C√≥mo tomar el control de su infraestructura de red. CAPITULO DOS Limpieza y documentacion</a></li>
<li><a href="../es434752/index.html">Robomoroz: el futuro del personaje principal del A√±o Nuevo</a></li>
<li><a href="../es434756/index.html">El futuro de Kubernetes es con m√°quinas virtuales.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>