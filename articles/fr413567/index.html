<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😨 🤘🏼 ❌ Premiers pas avec les microservices dans Spring Boot 👩🏻‍🚀 👩🏻‍⚕️ ⬇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! 

 Dans cet article, nous allons démontrer les composants de base pour créer des microservices RESTful à l'aide du registre des servic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Premiers pas avec les microservices dans Spring Boot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/413567/">  Bonjour à tous! <br><br>  Dans cet article, nous allons démontrer les composants de base pour créer des microservices RESTful à l'aide du registre des services Consul, Spring Boot pour tous les échafaudages, injection de dépendance, Maven pour l'assemblage, ainsi que Spring REST et l'API Java RESTful Jersey / JaxRS. <br><br>  Les principaux avantages des microservices: <br><br><ul><li>  Les microservices vous aident à assouplir votre code </li></ul><br><ul><li>  Les microservices permettent à différentes équipes de travailler sur de petits composants à l'aide de technologies indépendantes, offrant un déploiement plus sécurisé et plus fréquent. Spring Boot prend en charge diverses implémentations pour créer une API REST </li></ul><br><ul><li>  La découverte et l'appel de services ne dépendent pas de la plateforme de service </li></ul><br><ul><li>  Swagger crée une documentation API solide et une interface d'appel </li></ul><br>  Si vous n'utilisez pas déjà les microservices, vous n'avez pas réussi à entrer dans la phase des premiers adeptes sur la courbe de perception technologique, et c'est probablement le bon moment pour commencer. <br><br><img src="https://habrastorage.org/webt/o_/ze/uu/o_zeuux9s9xpxbxjvitgdmiqox4.png"><a name="habracut"></a><br><br>  Au cours des deux dernières décennies, l'entreprise est devenue très flexible dans notre processus SDLC, mais nos applications, en règle générale, restent encore monolithiques, avec d'énormes pots prenant en charge toutes les différentes API et versions sur le marché.  Mais à l'heure actuelle, on souhaite davantage de processus Lean et DevOps, et la fonctionnalité devient «sans serveur».  La refactorisation vers les microservices peut réduire l'intrication du code et des ressources, rendre les assemblages plus petits, les versions plus sûres et les API plus stables. <br><br>  Dans cet article, nous allons créer une application simple de gestion de portefeuille boursier que les clients peuvent appeler pour évaluer leur portefeuille d'actions (tickers et valeurs boursières).  Le microservice de portefeuille récupérera le portefeuille du client, l'enverra au microservice de tarification pour appliquer les derniers prix, puis rendra le portefeuille pleinement évalué et sous-totalisé, démontrant tout cela par le biais d'un appel de repos. <br><br><img src="https://habrastorage.org/webt/qe/ea/aw/qeeaawb8mapjtsibfyw3nro_ue8.png"><br><br>  Avant de commencer à travailler sur la création de nos microservices, préparons notre environnement en créant Consul. <br><br><h3>  Télécharger Consul </h3><br>  Nous utiliserons le consul Hashicorp pour découvrir les services, alors allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.consul.io/downloads.html</a> et téléchargez Consul pour Windows, Linux, Mac, etc.  Cela vous fournira un fichier exécutable que vous devez ajouter à votre chemin. <br><br><h3>  Lancer Consul </h3><br>  À l'invite de commandes, lancez Consul en mode dev: <br><br><pre><code class="bash hljs">consul agent -dev</code> </pre> <br>  Pour vérifier qu'il fonctionne, accédez à votre navigateur et accédez à l'interface consul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 8500</a> .  Si tout se passe bien, le consul doit signaler qu'il est bel et bien vivant.  En cliquant sur le service consul (à gauche), vous recevrez des informations supplémentaires (à droite). <br><br><img src="https://habrastorage.org/webt/9p/4m/2t/9p4m2taqogtv6ahb3dnpmvvt2oc.png"><br><br>  En cas de problème pour le moment, assurez-vous d'ajouter Consul au chemin d'exécution et les ports 8500 et 8600 sont disponibles. <br><br><h3>  Créer une application SpringBoot </h3><br>  Nous utiliserons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spring Initializr</a> , qui est intégré dans la plupart des IDE, pour échafauder nos applications SpringBoot.  Les captures d'écran ci-dessous utilisent IntelliJ IDEA. <br><br>  Sélectionnez «Fichier / Nouveau projet» pour ouvrir un nouveau modèle de projet, puis «Spring Initializr». <br><br><img src="https://habrastorage.org/webt/xb/j5/3t/xbj53tf_bfr5dauohwqmv9gkdmm.png"><br><br>  En général, vous pouvez configurer un échafaudage sans IDE en remplissant un formulaire en ligne via la page Web SpringBoot Initializr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">start.spring.io</a> , qui créera un fichier zip pour votre projet vide, prêt à être téléchargé. <br><br>  Cliquez sur «Suivant» et remplissez les métadonnées du projet.  Utilisez la configuration suivante: <br><br><img src="https://habrastorage.org/webt/l0/_p/zk/l0_pzkpsppbplfrusj7suogqmyk.png"><br><br>  Cliquez sur «Suivant» pour sélectionner les dépendances, puis entrez «Jersey» et «Consul Discovery» dans la recherche de dépendances.  Ajoutez ces dépendances: <br><br><img src="https://habrastorage.org/webt/jt/t8/l8/jtt8l89pauvzyu_oo_riav_na4e.png"><br><br>  Cliquez sur «Suivant» pour indiquer le nom du projet et son emplacement.  Conservez le nom par défaut «portfolio» et spécifiez l'emplacement préféré du projet, puis cliquez sur «terminer» pour créer et ouvrir le projet: <br><br><img src="https://habrastorage.org/webt/un/xl/gh/unxlgh-ufplppxqhuyfyfdoug5g.png"><br><br>  Nous pouvons utiliser le fichier application.properties généré, mais SpringBoot reconnaît également le format YAML, qui est un peu plus facile à visualiser, nous allons donc le renommer en application.yml. <br><br>  Nous appelons le microservice «portfolio-service».  Nous pouvons spécifier un port ou utiliser le port 0 pour que l'application utilise un port disponible.  Dans notre cas, nous utiliserons le 57116. Si vous hébergez ce service en tant que conteneur Docker, vous pouvez le mapper sur n'importe quel port que vous sélectionnez.  Nommez l'application et spécifiez notre port en ajoutant ce qui suit à notre application.yml: <br><br><pre> <code class="bash hljs">spring: application: name: portfolio-service server: port: 57116</code> </pre><br>  Pour rendre notre service disponible, ajoutez une annotation à notre classe d'application SpringBoot.  Ouvrez l'application PortfolioApplication et ajoutez @EnableDiscoveryClient au-dessus de la déclaration de classe. <br><br>  Confirmez les importations.  La classe devrait ressembler à ceci: <br><br><pre> <code class="bash hljs">package com.restms.demo.portfolio; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; . . . @SpringBootApplication @EnableDiscoveryClient public class PortfolioApplication { public static void main(String[] args) { SpringApplication.run(PortfolioApplication.class, args); } }</code> </pre><br>  (Pour montrer comment les microservices peuvent être constitués de plates-formes indépendantes, nous utiliserons Jersey pour ce service et Spring REST pour le suivant). <br>  Pour configurer le service Web RESTful sur Jersey, nous devons spécifier la classe de configuration ResourceConfig.  Ajoutez la classe JerseyConfig (pour démonstration, nous l'enregistrerons dans le même package que notre classe d'application).  Il devrait ressembler à ceci, plus le package et l'importation corrects: <br><br><pre> <code class="bash hljs">@Configuration @ApplicationPath(<span class="hljs-string"><span class="hljs-string">"portfolios"</span></span>) public class JerseyConfig extends ResourceConfig { public <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JerseyConfig</span></span></span></span>() { register(PortfolioImpl.class); } }</code> </pre><br>  Notez qu'il hérite de ResourceConfig pour le désigner comme classe de configuration Jersey.  L'attribut @ApplicationPath ("portfolios") définit le contexte de l'appel, ce qui signifie que les appels doivent commencer par l'élément de chemin "portfolioios".  (Si vous l'omettez, le contexte par défaut est «/»). <br><br>  La classe PortfolioImpl servira deux demandes: portfolios / client / {id-client} renvoie tous les portefeuilles et portefeuilles / client / {id-client} / portfolio / {id-portfolio} renvoie un portefeuille.  Un portefeuille se compose d'un ensemble de tickers et du nombre d'actions détenues par ce ticker.  (Pour démonstration, il existe trois clients avec les identificateurs 0, 1 et 2, chacun ayant trois portefeuilles avec les identificateurs 0, 1 et 2). <br><br>  Votre IDE vous demandera de créer PortfolioImpl;  faites-le maintenant.  Pour le démontrer, ajoutez-le au même package.  Entrez le code ci-dessous et confirmez toutes les importations: <br><br><pre> <code class="bash hljs">@Component @Path(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) public class PortfolioImpl implements InitializingBean { private Object[][][][] clientPortfolios; @GET @Path(<span class="hljs-string"><span class="hljs-string">"customer/{customer-id}"</span></span>) @Produces(MediaType.APPLICATION_JSON) // a portfolio consists of an array of arrays, each containing an array of // stock ticker and associated shares public Object[][][] getPortfolios(@PathParam(<span class="hljs-string"><span class="hljs-string">"customer-id"</span></span>) int customerId) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> clientPortfolios[customerId]; } @GET @Path(<span class="hljs-string"><span class="hljs-string">"customer/{customer-id}/portfolio/{portfolio-id}"</span></span>) @Produces(MediaType.APPLICATION_JSON) public Object[][] getPortfolio(@PathParam(<span class="hljs-string"><span class="hljs-string">"customer-id"</span></span>) int customerId, @PathParam(<span class="hljs-string"><span class="hljs-string">"portfolio-id"</span></span>) int portfolioId) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> getPortfolios(customerId)[portfolioId]; } @Override public void afterPropertiesSet() throws Exception { Object[][][][] clientPortfolios = { { // 3 customers, 3 portfolios each {new Object[]{<span class="hljs-string"><span class="hljs-string">"JPM"</span></span>, 10201}, new Object[]{<span class="hljs-string"><span class="hljs-string">"GE"</span></span>, 20400}, new Object[]{<span class="hljs-string"><span class="hljs-string">"UTX"</span></span>, 38892}}, {new Object[]{<span class="hljs-string"><span class="hljs-string">"KO"</span></span>, 12449}, new Object[]{<span class="hljs-string"><span class="hljs-string">"JPM"</span></span>, 23454}, new Object[]{<span class="hljs-string"><span class="hljs-string">"MRK"</span></span>, 45344}}, {new Object[]{<span class="hljs-string"><span class="hljs-string">"WMT"</span></span>, 39583}, new Object[]{<span class="hljs-string"><span class="hljs-string">"DIS"</span></span>, 95867}, new Object[]{<span class="hljs-string"><span class="hljs-string">"TRV"</span></span>, 384756}}, }, { {new Object[]{<span class="hljs-string"><span class="hljs-string">"GE"</span></span>, 38475}, new Object[]{<span class="hljs-string"><span class="hljs-string">"MCD"</span></span>, 12395}, new Object[]{<span class="hljs-string"><span class="hljs-string">"IBM"</span></span>, 91234}}, {new Object[]{<span class="hljs-string"><span class="hljs-string">"VZ"</span></span>, 22342}, new Object[]{<span class="hljs-string"><span class="hljs-string">"AXP"</span></span>, 385432}, new Object[]{<span class="hljs-string"><span class="hljs-string">"UTX"</span></span>, 23432}}, {new Object[]{<span class="hljs-string"><span class="hljs-string">"IBM"</span></span>, 18343}, new Object[]{<span class="hljs-string"><span class="hljs-string">"DIS"</span></span>, 45673}, new Object[]{<span class="hljs-string"><span class="hljs-string">"AAPL"</span></span>, 23456}}, }, { {new Object[]{<span class="hljs-string"><span class="hljs-string">"AXP"</span></span>, 34543}, new Object[]{<span class="hljs-string"><span class="hljs-string">"TRV"</span></span>, 55322}, new Object[]{<span class="hljs-string"><span class="hljs-string">"NKE"</span></span>, 45642}}, {new Object[]{<span class="hljs-string"><span class="hljs-string">"CVX"</span></span>, 44332}, new Object[]{<span class="hljs-string"><span class="hljs-string">"JPM"</span></span>, 12453}, new Object[]{<span class="hljs-string"><span class="hljs-string">"JNJ"</span></span>, 45433}}, {new Object[]{<span class="hljs-string"><span class="hljs-string">"MRK"</span></span>, 32346}, new Object[]{<span class="hljs-string"><span class="hljs-string">"UTX"</span></span>, 46532}, new Object[]{<span class="hljs-string"><span class="hljs-string">"TRV"</span></span>, 45663}}, } }; this.clientPortfolios = clientPortfolios; } }</code> </pre><br>  L'annotation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">composant la</a> désigne comme classe du composant Spring et l'expose comme point de terminaison.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Les</a> annotations de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">chemin</a> sur la déclaration de classe déclarent que la classe est accessible via l'élément de chemin «/», et deux appels api pris en charge sont disponibles via portfolios / customer / {customer-id} et portfolios / customer / {customer-id} / portfolio / {portfolio- id}, comme nous le voyons dans les annotations de la méthode.  Notez que le chemin ("/") est le chemin par défaut, mais nous le laissons pour référence.  Les méthodes sont désignées comme HTTP GET via @GETannotation.  Notre méthode est conçue pour renvoyer un tableau et annotée pour renvoyer Json, elle renvoie donc un tableau Json.  Remarquez comment les annotations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Path</a> Param sont utilisées dans la signature de méthode pour extraire les paramètres affichés des requêtes affichées. <br><br>  (Pour notre démo, nous retournons des valeurs codées en dur. Bien sûr, dans la pratique, l'implémentation interrogera la base de données ou un autre service ou source de données au lieu du code dur.) <br>  Créez maintenant un projet et exécutez-le.  Si vous utilisez IntelliJ, il créera un exécutable par défaut, il vous suffit donc de cliquer sur la flèche verte «exécuter».  Vous pouvez également utiliser <br><br><pre> <code class="bash hljs">mvn spring-boot:run</code> </pre> <br>  Ou vous pouvez effectuer l'installation de maven et exécuter l'application à l'aide de java -jar, en pointant vers le fichier jar généré dans le répertoire cible: <br><br><pre> <code class="bash hljs">java -jar target\portfolio-0.0.1-SNAPSHOT.jar</code> </pre> <br>  Maintenant, nous devrions voir ce service dans Consul, alors revenons à notre navigateur, téléchargez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 8500 / ui / # / dc1 / services</a> (ou mettez à jour si vous y êtes déjà). <br><br><img src="https://habrastorage.org/webt/bs/ab/2v/bsab2vs-dswpzy7nmpevmtphdma.png"><br><br>  Hmm, nous voyons notre service là-bas, mais il est affiché comme ayant échoué.  C'est parce que Consul attend un signal de rythme cardiaque «sain» de notre service. <br>  Pour générer des signaux de pulsation, nous pouvons ajouter une dépendance sur le service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spring Actuator</a> au pom de notre application. <br><br><pre> <code class="bash hljs">&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;</code> </pre><br>  Pendant que nous sommes à pom, notons qu'il existe un conflit de version avec Jersey entre le starter Consul et le starter Jersey.  Pour lisser cela, désigner le démarreur Jersey comme la première dépendance. <br><br>  Votre pom devrait maintenant contenir les dépendances suivantes: <br><br><pre> <code class="bash hljs">&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jersey&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;</code> </pre><br>  En redémarrant Consul, le service Portfolio affiche un heureux: <br><br><img src="https://habrastorage.org/webt/uf/oq/qr/ufoqqrtcnxnlwazqy-ozrp1lceo.png"><br><br>  Maintenant, dans le service de portefeuille, il y a deux nœuds de transmission: l'un d'eux est notre implémentation du service de portefeuille, et l'autre est le rythme cardiaque. <br><br>  Vérifions le port qui a été attribué.  Vous pouvez le voir dans la sortie de l'application: <br><br><pre> <code class="bash hljs">INFO 19792 --- [ main] sbcetTomcatEmbeddedServletContainer : Tomcat started on port(s): 57116 (http)</code> </pre> <br>  Vous pouvez également voir le port directement dans l'interface utilisateur du Consul.  Cliquez sur «service client», puis sélectionnez le lien «Lien de vérification du service client», qui affiche le port de service, dans ce cas 57116. <br><br><img src="https://habrastorage.org/webt/s_/up/ce/s_upceczzu0xupqioariurhawz8.png"><br><br>  Demandez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 57116 / portfolios / customer / 1 / portfolio / 2</a> et vous verrez le tableau json [["IBM", 18343], ["DIS", 45673], ["AAPL", 23456]] <br><br>  Notre premier microservice est ouvert aux affaires! <br><br><h3>  Service de tarification </h3><br>  Ensuite, nous créerons notre service de tarification, cette fois en utilisant Spring RestController au lieu de Jersey. <br><br>  Le service de tarification acceptera l'identifiant client et l'identifiant de portefeuille comme paramètres et utilisera RestTemplate pour demander des services de portefeuille, recevoir des tickers et des stocks, et retourner les prix actuels.  (Je n'ai pas besoin de vous dire que ces valeurs sont de fausses nouvelles, alors ne les utilisez pas pour prendre des décisions commerciales!) <br><br>  Créez un nouveau projet en utilisant les informations suivantes: <br><br><img src="https://habrastorage.org/webt/gz/sy/sm/gzsysm7_cgynyxucuhgrcfoxhbs.png"><br><br>  Cette fois, sélectionnez les dépendances Web, Consul Discovery et Actuator: <br><br><img src="https://habrastorage.org/webt/1l/ke/ov/1lkeovxzix2pxqwmodb2efdw-zu.png"><br><br>  Laissez le nom par défaut du projet «pricing» et créez un projet dans le répertoire de votre choix. <br><br>  Cette fois, nous utiliserons application.properties au lieu de application.yml. <br>  Définissez le nom et le port dans application.properties comme suit: <br><br><pre> <code class="bash hljs">spring.application.name=pricing server.port=57216</code> </pre> <br>  Annoter PricingApplication avec @EnableDiscoveryClient.  La classe devrait ressembler à ceci, plus le package et l'importation. <br><br><pre> <code class="bash hljs">@SpringBootApplication @EnableDiscoveryClient public class PricingApplication { public static void main(String[] args) { SpringApplication.run(PricingApplication.class, args); } }</code> </pre><br>  Ensuite, nous créerons la classe PricingEndpoint.  Ici, je vais donner un exemple plus détaillé, car il présente plusieurs fonctions importantes, y compris la découverte de services (recherche de services de portefeuille) et l'utilisation de RestTemplate pour la requête: <br><br><pre> <code class="bash hljs">@RestController @RequestMapping(<span class="hljs-string"><span class="hljs-string">"/pricing"</span></span>) public class PricingEndpoint implements InitializingBean { @Autowired DiscoveryClient client; Map&lt;String, Double&gt; pricingMap = new HashMap&lt;&gt;(); RestTemplate restTemplate = new RestTemplate(); @GetMapping(<span class="hljs-string"><span class="hljs-string">"/customer/{customer-id}/portfolio/{portfolio-id}"</span></span>) public List&lt;String&gt; getPricedPortfolio( @PathVariable(<span class="hljs-string"><span class="hljs-string">"customer-id"</span></span>) Integer customerId, @PathVariable(<span class="hljs-string"><span class="hljs-string">"portfolio-id"</span></span>) Integer portfolioId) { List&lt;ServiceInstance&gt; instances = client.getInstances(<span class="hljs-string"><span class="hljs-string">"portfolio-service"</span></span>); ServiceInstance instance = instances.stream() .findFirst() .orElseThrow(() -&gt; new RuntimeException(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>)); String url = String.format(<span class="hljs-string"><span class="hljs-string">"%s/portfolios/customer/%d/portfolio/%d"</span></span>, instance.getUri(), customerId, portfolioId); // query <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the portfolios, returned as an array of List // of size 2, containing a ticker and a position (<span class="hljs-comment"><span class="hljs-comment"># of shares) Object[] portfolio = restTemplate.getForObject(url, Object[].class); // Look up the share prices, and return a list of Strings, formatted as // ticker, shares, price, total List&lt;String&gt; collect = Arrays.stream(portfolio).map(position -&gt; { String ticker = ((List&lt;String&gt;) position).get(0); int shares = ((List&lt;Integer&gt;) position).get(1); double price = getPrice(ticker); double total = shares * price; return String.format("%s %d %f %f", ticker, shares, price, total); }).collect(Collectors.toList()); return collect; } private double getPrice(String ticker) { return pricingMap.get(ticker); } @Override public void afterPropertiesSet() throws Exception { pricingMap.put("MMM",201.81); pricingMap.put("AXP",85.11); pricingMap.put("AAPL",161.04); pricingMap.put("BA",236.32); pricingMap.put("CAT",118.02); pricingMap.put("CVX",111.31); pricingMap.put("CSCO",31.7); pricingMap.put("KO",46.00); pricingMap.put("DIS",101.92); pricingMap.put("XOM",78.7); pricingMap.put("GE",24.9); pricingMap.put("GS",217.62); pricingMap.put("HD",155.82); pricingMap.put("IBM",144.29); pricingMap.put("INTC",35.66); pricingMap.put("JNJ",130.8); pricingMap.put("JPM",89.75); pricingMap.put("MCD",159.81); pricingMap.put("MRK",63.89); pricingMap.put("MSFT",73.65); pricingMap.put("NKE",52.78); pricingMap.put("PFE",33.92); pricingMap.put("PG",92.79); pricingMap.put("TRV",117.00); pricingMap.put("UTX",110.12); pricingMap.put("UNH",198.00); pricingMap.put("VZ",47.05); pricingMap.put("V",103.34); pricingMap.put("WMT", 80.05); } }</span></span></code> </pre><br>  Pour trouver un service de portefeuille, nous devons avoir accès à DiscoveryClient.  Il est facile d'obtenir l'annotation @Autowired de Spring. <br><br><pre> <code class="bash hljs">@Autowired DiscoveryClient client;</code> </pre><br>  Cette instance DiscoveryClient est ensuite utilisée pour rechercher le service dans l'appel: <br><br><pre> <code class="bash hljs">List&lt;ServiceInstance&gt; instances = client.getInstances(<span class="hljs-string"><span class="hljs-string">"portfolio-service"</span></span>); ServiceInstance instance = instances.stream().findFirst().orElseThrow(() -&gt; new RuntimeException(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>));</code> </pre><br>  Une fois le service trouvé, nous pouvons l'utiliser pour répondre à notre demande, que nous composons conformément à l'appel API créé dans notre service de portefeuille. <br><br><pre> <code class="bash hljs">String url = String.format(<span class="hljs-string"><span class="hljs-string">"%s/portfolios/customer/%d/portfolio/%d"</span></span>, instance.getUri(), customerId, portfolioId);</code> </pre><br>  Enfin, nous utilisons RestTemplate pour exécuter notre demande GET. <br><br><pre> <code class="bash hljs">Object[] portfolio = restTemplate.getForObject(url, Object[].class);</code> </pre> <br>  Notez que pour les contrôleurs Rest (ainsi que pour Spring MVC Request Controller), les variables de chemin sont récupérées à l'aide de l'annotation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Path</a> Variable, contrairement à Jersey, qui, comme nous l'avons vu, utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Path</a> Param. <br><br>  Ceci conclut notre tarification avec Spring RestController. <br><br><h3>  La documentation </h3><br>  Nous avons résolu tous ces problèmes afin de créer nos microservices, mais ils n'apporteront pas suffisamment d'avantages si nous ne donnons pas au monde des connaissances sur la façon de les utiliser. <br><br>  Pour ce faire, nous utilisons l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Swagger</a> pratique et facile à utiliser, qui documente non seulement nos appels API, mais fournit également un client Web pratique pour les appeler. <br><br>  Précisons d'abord Swagger dans notre pom: <br><br><pre> <code class="bash hljs">&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt;</code> </pre><br>  Ensuite, nous devons dire à Swagger laquelle de nos classes nous voulons documenter.  Présentons la nouvelle classe SwaggerConfig contenant la spécification Swagger. <br><br><pre> <code class="bash hljs">@Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.regex(<span class="hljs-string"><span class="hljs-string">"/pricing.*"</span></span>)) .build(); } }</code> </pre><br>  Voyons voir ce que fait cette classe.  Tout d'abord, nous l'avons désigné comme une configuration Swagger avec l'annotation @ EnableSwagger2. <br><br>  Ensuite, nous avons créé un composant Docket qui indique à Swagger quelles API doivent être affichées.  Dans l'exemple ci-dessus, nous avons demandé à Swagger de montrer tout chemin commençant par «/ pricing».  Une alternative serait de spécifier des classes pour la documentation, et non pour les chemins: <br><br><pre> <code class="bash hljs">.apis(RequestHandlerSelectors.basePackage(<span class="hljs-string"><span class="hljs-string">"com.restms.demo"</span></span>)) .paths(PathSelectors.any())</code> </pre><br>  Redémarrez le microservice de prix et appelez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 57216 / swagger-ui.html à</a> partir du navigateur <br><br><img src="https://habrastorage.org/webt/8x/0k/gk/8x0kgk8hxs_dpijzolsmxk8rdva.png"><br><br>  Cliquez sur Lister les opérations pour afficher les opérations de service en détail. <br>  Cliquez sur Développer les opérations pour créer une demande basée sur le formulaire.  Définissez certains paramètres, cliquez sur "Essayez-le!"  et attendez la réponse: <br><br><img src="https://habrastorage.org/webt/rf/0_/iu/rf0_ius_kz3fljd74-aaqhzwsia.png"><br><br>  Vous pouvez ajouter beaucoup plus de couleurs en ajoutant des annotations Swagger à vos méthodes. <br>  Par exemple, décorez la méthode PricingImpl.getPricedPortfolio existante à l'aide de l'annotation @ApiOperation, comme illustré ci-dessous: <br><br><pre> <code class="bash hljs">@ApiOperation(value = <span class="hljs-string"><span class="hljs-string">"Retrieves a fully priced portfolio"</span></span>, notes = <span class="hljs-string"><span class="hljs-string">"Retrieves fully priced portfolio given customer id and portfolio id"</span></span>) @GetMapping(<span class="hljs-string"><span class="hljs-string">"/customer/{customer-id}/portfolio/{portfolio-id}"</span></span>) public List&lt;String&gt; getPricedPortfolio(@PathVariable(<span class="hljs-string"><span class="hljs-string">"customer-id"</span></span>) Integer customerId, @PathVariable(<span class="hljs-string"><span class="hljs-string">"portfolio-id"</span></span>) Integer portfolioId)</code> </pre> <br>  Rechargez et mettez à jour swagger-ui pour voir la nouvelle documentation mise à jour: <br><br><img src="https://habrastorage.org/webt/1z/vy/bj/1zvybjvfyh6zmjxd7gahn5_tlyi.png"><br><br>  Et ce n'est pas tout ce que vous pouvez faire avec Swagger, alors consultez la documentation. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yuri Dvorzhetsky</a> , un conférencier dans notre cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Developer on the Spring Framework",</a> vous en dira plus sur Spring Boot: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zgd9SfSxO0Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>Article original</i></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413567/">https://habr.com/ru/post/fr413567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413557/index.html">NewSQL: SQL ne va nulle part</a></li>
<li><a href="../fr413559/index.html">Dégradation du Web ou comment rendre le Web lisible par l'homme</a></li>
<li><a href="../fr413561/index.html">Vitesse d'arbre d'expression Linq compilée</a></li>
<li><a href="../fr413563/index.html">4 façons d'importer un package dans Go</a></li>
<li><a href="../fr413565/index.html">Analyse de piratage Kubernetes - Porte dérobée via Kubelet</a></li>
<li><a href="../fr413569/index.html">Démantèlement des batteries au lithium-ion de l'usine 18650</a></li>
<li><a href="../fr413571/index.html">Numéro 25: Formation informatique - problèmes et défis actuels des grandes entreprises</a></li>
<li><a href="../fr413575/index.html">BricsCAD Shape - CAO 3D gratuit de Bricsys</a></li>
<li><a href="../fr413577/index.html">[Annonce] Hubs pour la compétition sur CodinGame.com dans sept villes de Russie</a></li>
<li><a href="../fr413579/index.html">Nous allons mettre un mot sur la décomposition du code: programmation contextuelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>