<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÅÔ∏è üë©üèø‚Äçüè´ üòµ Aplikasi TypeScript dengan tumpukan penuh ü¶á üé¥ üëµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel "Aplikasi Full-Stack TypeScript - Bagian 1: Mengembangkan API Backend dengan Nest.js" oleh Ana Ri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi TypeScript dengan tumpukan penuh</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Halo, Habr!  Saya hadir untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Aplikasi Full-Stack TypeScript - Bagian 1: Mengembangkan API Backend dengan Nest.js"</a> oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Bagian 1: Mengembangkan API server menggunakan Nest.JS </h2><br><p>  TL; DR: Ini adalah serangkaian artikel tentang cara membuat aplikasi web TypeScript menggunakan Angular dan Nest.JS.  Pada bagian pertama, kita akan menulis API server sederhana menggunakan Nest.JS.  Bagian kedua dari seri ini dikhususkan untuk aplikasi front-end menggunakan Angular.  Anda dapat menemukan kode final yang dikembangkan dalam artikel ini di <a href="">repositori GitHub</a> ini <a href="">.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  Apa itu Nest.Js dan mengapa Angular? </h3><br><p>  Nest.js adalah kerangka kerja untuk membangun aplikasi server web Node.js. </p><br><p>  Fitur khasnya adalah ia memecahkan masalah yang tidak dipecahkan oleh kerangka kerja lain: struktur proyek node.js. <a name="habracut"></a>  Jika Anda pernah mengembangkan di bawah node.js, Anda tahu bahwa Anda dapat melakukan banyak hal dengan satu modul (misalnya, middleware Express dapat melakukan segalanya mulai dari otentikasi hingga validasi), yang pada akhirnya dapat menyebabkan "kekacauan" yang tidak didukung. .  Seperti yang akan Anda lihat di bawah, nest.js akan membantu kami dengan menyediakan kelas-kelas yang berspesialisasi dalam berbagai masalah. </p><br><p>  Nest.js sangat terinspirasi oleh Angular.  Sebagai contoh <cut></cut>  kedua platform menggunakan pelindung untuk memungkinkan atau mencegah akses ke beberapa bagian dari aplikasi Anda, dan kedua platform menyediakan antarmuka CanActivate untuk menerapkan penjaga ini.  Namun, penting untuk dicatat bahwa, terlepas dari beberapa konsep yang serupa, kedua struktur tersebut saling independen satu sama lain.  Artinya, dalam artikel ini, kami akan membuat API independen untuk front-end kami, yang dapat digunakan dengan kerangka kerja lainnya (Bereaksi, Vue.JS, dan sebagainya). </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Aplikasi web untuk pesanan online </h3><br><p>  Dalam panduan ini, kami akan membuat aplikasi sederhana di mana pengguna dapat memesan di restoran.  Ini akan mengimplementasikan logika ini: </p><br><ul><li>  setiap pengguna dapat melihat menu; </li><li>  hanya pengguna yang sah yang dapat menambahkan barang ke keranjang (melakukan pemesanan) </li><li>  hanya administrator yang dapat menambahkan item menu baru. </li></ul><br><p>  Untuk kesederhanaan, kami tidak akan berinteraksi dengan basis data eksternal dan tidak mengimplementasikan fungsionalitas keranjang toko kami. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Membuat struktur file proyek Nest.js </h3><br><p>  Untuk menginstal Nest.js, kita perlu menginstal Node.js (v.8.9.x atau lebih tinggi) dan NPM.  Unduh dan instal Node.js untuk sistem operasi Anda dari situs web resmi (NPM disertakan).  Ketika semuanya sudah diinstal, periksa versinya: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Ada berbagai cara untuk membuat proyek dengan Nest.js;  mereka dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Kami akan menggunakan <code>nest-cli</code> .  Pasang itu: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  Selanjutnya, buat proyek kami dengan perintah sederhana: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  dalam prosesnya, sarang akan meminta kami untuk memilih manajer paket: <code>npm</code> atau <code>yarn</code> </p><br><p>  Jika semuanya berjalan dengan baik, <code>nest</code> akan membuat struktur file berikut: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ‚îú‚îÄ‚îÄ src ‚îÇ ‚îú‚îÄ‚îÄ app.controller.spec.ts ‚îÇ ‚îú‚îÄ‚îÄ app.controller.ts ‚îÇ ‚îú‚îÄ‚îÄ app.module.ts ‚îÇ ‚îú‚îÄ‚îÄ app.service.ts ‚îÇ ‚îî‚îÄ‚îÄ main.ts ‚îú‚îÄ‚îÄ test ‚îÇ ‚îú‚îÄ‚îÄ app.e2e-spec.ts ‚îÇ ‚îî‚îÄ‚îÄ jest-e2e.json ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ .prettierrc ‚îú‚îÄ‚îÄ nest-cli.json ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ package-lock.json ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ tsconfig.build.json ‚îú‚îÄ‚îÄ tsconfig.json ‚îî‚îÄ‚îÄ tslint.json</code> </pre> <br><p>  buka direktori yang dibuat dan mulai server pengembangan: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Buka browser dan masukkan <code>http://localhost:3000</code> .  Di layar kita akan melihat: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Sebagai bagian dari tutorial ini, kami tidak akan menguji API kami (meskipun Anda harus menulis tes untuk aplikasi yang siap digunakan).  Dengan cara ini Anda dapat menghapus direktori <code>test</code> dan menghapus file <code>src/app.controller.spec.ts</code> (yang merupakan test satu).  Akibatnya, folder sumber kami berisi file-file berikut: </p><br><ul><li>  <code>src/app.controller.ts</code> dan <code>src/app.module.ts</code> : file-file ini bertanggung jawab untuk membuat pesan <code>Hello world</code> sepanjang rute <code>/</code> .  Karena  titik masuk ini tidak penting untuk aplikasi ini kami menghapusnya.  Segera Anda akan belajar secara lebih terperinci apa itu <strong>pengontrol</strong> dan <strong>layanan</strong> . </li><li>  <code>src/app.module.ts</code> : berisi deskripsi kelas <strong>modul</strong> tipe, yang bertanggung jawab untuk mendeklarasikan impor, ekspor pengendali dan penyedia ke aplikasi nest.js.  Setiap aplikasi memiliki setidaknya satu modul, tetapi Anda dapat membuat lebih dari satu modul untuk aplikasi yang lebih kompleks (lebih banyak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . Aplikasi kami hanya akan berisi satu modul </li><li>  <code>src/main.ts</code> : ini adalah file yang bertanggung jawab untuk memulai server. </li></ul><br><blockquote><cut text=""></cut>  Catatan: setelah menghapus <code>src/app.controller.ts</code> dan <code>src/app.module.ts</code> Anda tidak akan dapat memulai aplikasi kami.  Jangan khawatir, kami akan segera memperbaikinya. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Buat titik masuk (titik akhir) </h3><br><br><p>  API kami akan tersedia pada rute <code>/items</code> .  Melalui titik entri ini, pengguna dapat menerima data, dan administrator mengelola menu.  Mari kita ciptakan. </p><br><p>  Untuk melakukan ini, buat direktori bernama <code>items</code> di dalam <code>src</code> .  Semua file yang terkait dengan rute <code>/items</code> akan disimpan di direktori baru ini. </p><br><h4 id="sozdanie-kontrollerov">  Membuat pengontrol </h4><br><p>  di <code>nest.js</code> , seperti dalam banyak kerangka kerja lain, pengontrol bertanggung jawab untuk memetakan rute dengan fungsionalitas.  Untuk membuat pengontrol di <code>nest.js</code> gunakan dekorator <code>nest.js</code> sebagai berikut: <code>@Controller(${ENDPOINT})</code> .  Selanjutnya, untuk memetakan berbagai metode <code>HTTP</code> , seperti <code>GET</code> dan <code>POST</code> , dekorator <code>@Get</code> , <code>@Post</code> , <code>@Delete</code> , dll. Digunakan. </p><br><p>  Dalam kasus kami, kami perlu membuat pengontrol yang mengembalikan hidangan yang tersedia di restoran, dan administrator mana yang akan digunakan untuk mengelola konten menu.  Mari kita membuat file bernama <code>items.controller.tc</code> di direktori <code>src/items</code> dengan konten berikut: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  untuk membuat pengontrol baru kami tersedia di aplikasi kami, daftarkan di modul: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Luncurkan aplikasi kami: <code>npm run start:dev</code> dan buka di browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 3000 / item</a> , jika Anda melakukan semuanya dengan benar, maka kita akan melihat jawaban atas permintaan kami: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Catatan Penerjemah: untuk membuat pengontrol baru, serta elemen lain dari <code>nest.js</code> : layanan, penyedia, dll., Lebih mudah menggunakan perintah <code>nest generate</code> dari paket <code>nest-cli</code> .</em>  <em>Sebagai contoh, untuk membuat controller yang dijelaskan di atas, Anda dapat menggunakan perintah <code>nest generate controller items</code> , sebagai hasilnya sarang akan membuat <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> dan <code>src/items/items.controller.tc</code> konten berikut:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>dan daftarkan di <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Menambahkan Layanan </h4><br><p>  Sekarang, ketika mengakses <code>/items</code> aplikasi kita mengembalikan array yang sama untuk setiap permintaan, yang tidak bisa kita ubah.  Memproses dan menyimpan data bukanlah bisnis pengontrol, untuk tujuan ini layanan dimaksudkan di nest.js <br>  Layanan dalam sarang adalah <code>@Injectable</code> <br>  Nama dekorator berbicara sendiri, menambahkan dekorator ini ke kelas membuatnya dapat disuntikkan ke komponen lain, seperti pengontrol. <br>  Ayo buat layanan kami.  Buat file <code>items.service.ts</code> di folder <code>items.service.ts</code> dengan konten berikut: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  dan ubah pengontrol <code>ItemsController</code> (dideklarasikan di <code>items.controller.ts</code> ) untuk menggunakan layanan kami: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  Di versi baru controller, kami menerapkan dekorator <code>@Body</code> ke argumen metode <code>create</code> .  Argumen ini digunakan untuk secara otomatis mencocokkan data yang dikirimkan melalui <code>req.body ['item']</code> ke argumen itu sendiri (dalam hal ini, <code>item</code> ). <br>  Pengontrol kami juga menerima turunan dari kelas <code>ItemsService</code> , disuntikkan melalui konstruktor.  Mendeklarasikan <code>ItemsService</code> sebagai <code>private readonly</code> membuat instance tidak dapat diubah dan hanya terlihat di dalam kelas. <br>  Dan jangan lupa untuk mendaftarkan layanan kami di <code>app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Setelah semua perubahan, mari kirim permintaan HTTP POST ke menu: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Kemudian kami akan memeriksa apakah hidangan baru muncul di menu kami dengan membuat permintaan GET (atau dengan membuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 3000 / item</a> di browser) </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Membuat Rute Keranjang Belanja </h4><br><p>  Sekarang kami memiliki versi pertama dari titik masuk <code>/items</code> API kami, mari kita terapkan fungsi keranjang belanja.  Proses pembuatan fungsi ini tidak jauh berbeda dari API yang sudah dibuat.  Oleh karena itu, agar tidak mengacaukan manual, kami akan membuat komponen yang merespons dengan status OK saat mengakses. </p><br><p>  Pertama, di folder <code>./src/shopping-cart/</code> buat file <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Daftarkan pengontrol ini di modul kami ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Untuk memverifikasi titik entri ini, jalankan perintah berikut, setelah memastikan bahwa aplikasi sedang berjalan: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Menambahkan Skrip Antarmuka untuk Item </h4><br><p>  Kembali ke layanan <code>items</code> kami.  Sekarang kami hanya menyimpan nama hidangan, tetapi ini jelas tidak cukup, dan, tentu saja, kami ingin memiliki lebih banyak informasi (misalnya, biaya hidangan).  Saya pikir Anda akan setuju bahwa menyimpan data ini sebagai array string bukan ide yang baik? <br>  Untuk mengatasi masalah ini, kita bisa membuat array objek.  Tetapi bagaimana cara menyimpan struktur benda?  Di sini antarmuka TypeScript akan membantu kita, di mana kita mendefinisikan struktur objek <code>items</code> .  Buat file baru bernama <code>item.interface.ts</code> di folder <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  Kemudian <code>items.service.ts</code> file <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  Dan juga di <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validasi input di Nest.js </h4><br><p>  Terlepas dari kenyataan bahwa kami menentukan struktur objek <code>item</code> , aplikasi kami tidak akan mengembalikan kesalahan jika kami mengirim permintaan POST yang tidak valid (semua jenis data tidak didefinisikan dalam antarmuka).  Misalnya, untuk permintaan seperti itu: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  server harus merespons dengan status 400 (permintaan buruk), tetapi sebaliknya, aplikasi kita akan merespons dengan status 200 (OK). </p><br><p>  Untuk mengatasi masalah ini, buat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DTO (Obyek Transfer Data)</a> dan komponen Pipa (saluran). </p><br><p>  DTO adalah objek yang mendefinisikan bagaimana data harus ditransfer antar proses.  Kami menjelaskan DTO di file <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Pipa di <code>Nest.js</code> adalah komponen yang digunakan untuk validasi.  Untuk API kami, buat saluran untuk memeriksa apakah data yang dikirim ke metode cocok dengan DTO.  Satu saluran dapat digunakan oleh pengontrol yang berbeda, jadi buat direktori <code>src/common/</code> dengan file <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Catatan: Kita perlu menginstal dua modul: <code>class-validator</code> dan <code>class-transformer</code> .  Untuk melakukan ini, jalankan <code>npm install class-validator class-transformer</code> di konsol dan restart server. </blockquote><p>  Menyesuaikan <code>items.controller.ts</code> untuk digunakan dengan pipa dan DTO baru kami: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Mari kita periksa lagi kode kita, sekarang entri <code>/items</code> hanya menerima data jika didefinisikan dalam DTO.  Sebagai contoh: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Rekatkan dalam data yang tidak valid (data yang tidak dapat diverifikasi di <code>ValidationPipe</code> ), akibatnya kami mendapatkan jawabannya: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Membuat Middleware </h5><br><p>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman panduan mulai cepat Auth0</a> , cara yang disarankan untuk memverifikasi token JWT yang dikeluarkan oleh Auth0 adalah dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Express middleware yang</a> disediakan oleh <code>express-jwt</code> .  Middleware ini mengotomatisasi sebagian besar pekerjaan. </p><br><p>  Mari kita membuat file <code>authentication.middleware.ts</code> di dalam direktori <code>src / common</code> dengan kode berikut: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Ganti <code>${DOMAIN}</code> dengan nilai <em>domain</em> dari pengaturan aplikasi Auth0 </p><br><blockquote>  Catatan Penerjemah: dalam aplikasi nyata, keluarkan <code>DOMAIN</code> menjadi konstanta, dan tetapkan nilainya melalui <code>env</code> (lingkungan virtual) </blockquote><p>  Instal <code>jwks-rsa</code> <code>express-jwt</code> dan <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  Kita perlu menghubungkan middleware (handler) yang dibuat ke aplikasi kita.  Untuk melakukan ini, dalam file <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  Kode di atas mengatakan bahwa permintaan POST ke rute <code>/items</code> dan <code>/shopping-cart</code> dilindungi oleh <em>middleware Express</em> , yang memeriksa token akses dalam permintaan. </p><br><p>  Mulai ulang server pengembangan ( <code>npm run start:dev</code> ) dan panggil API Nest.js: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Manajemen peran dengan Auth0 </h5><br><p>  Saat ini, setiap pengguna dengan token terverifikasi dapat memposting item di API kami.  Namun, kami ingin hanya pengguna dengan hak administrator yang dapat melakukan ini.  Untuk mengimplementasikan fungsi ini, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan (aturan) Auth0</a> . </p><br><p>  Jadi, buka panel kontrol Auth0, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian <em>Aturan</em></a> .  Di sana, klik tombol <code>+ CREATE RULE</code> dan pilih "Setel peran ke pengguna" sebagai model aturan. </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Setelah melakukan ini, kami mendapatkan file JavaScript dengan templat aturan yang menambahkan peran administrator ke setiap pengguna yang memiliki email milik domain tertentu.  Mari kita ubah beberapa detail dalam template ini untuk mendapatkan contoh fungsional.  Untuk aplikasi kami, kami hanya akan memberikan administrator akses ke alamat email kami sendiri.  Kami juga perlu mengubah lokasi untuk menyimpan informasi status administrator. </p><br><p>  Saat ini, informasi ini disimpan dalam token identifikasi (digunakan untuk memberikan informasi tentang pengguna), tetapi token akses harus digunakan untuk mengakses sumber daya di API.  Kode setelah perubahan akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Catatan: ganti <code>${YOUR_EMAIL}</code> dengan alamat email Anda.  Penting untuk dicatat bahwa, sebagai suatu peraturan, ketika Anda berurusan dengan email dalam aturan Auth0, sangat ideal untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memaksakan verifikasi email</a> .  Dalam hal ini, ini tidak diperlukan karena kami menggunakan alamat email kami sendiri. <br><br>  Catatan Penerjemah: fragmen kode di atas dimasukkan di browser pada halaman konfigurasi aturan Auth0 </blockquote><p>  Untuk memeriksa apakah token yang diteruskan ke API kami adalah token administrator, kita perlu membuat <em>guard</em> Nest.js.  Di folder <code>src/common</code> , buat file <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Sekarang, jika kita mengulangi proses login yang dijelaskan di atas dan menggunakan alamat email yang ditentukan dalam aturan, kita akan mendapatkan <code>access_token</code> baru.  Untuk memeriksa konten <code>access_token</code> ini, salin dan tempel token ke dalam bidang yang <code>Encoded</code> dari situs <code>https://jwt.io/</code> .  Kita akan melihat bahwa bagian payload token ini berisi larik berikut: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Jika token kami benar-benar menyertakan informasi ini, kami melanjutkan integrasi dengan Auth0.  Jadi, buka <code>items.controller.ts</code> dan tambahkan penjaga baru di sana: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Sekarang, dengan token baru kami, kami dapat menambahkan item baru melalui API kami: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Catatan Penerjemah: untuk verifikasi, Anda dapat melihat apa yang ada dalam item: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Ringkasan </h4><br><p>  Selamat!  Kami baru saja selesai membangun API Nest.JS kami dan sekarang kami dapat fokus mengembangkan bagian depan aplikasi kami!  Pastikan untuk memeriksa bagian kedua dari seri ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Full-Stack TypeScript - Bagian 2: Mengembangkan Frontend Angular Apps.</a> </p><br><blockquote>  Catatan Penerjemah: Terjemahan bagian kedua dalam proses </blockquote><p>  Untuk meringkas, dalam artikel ini kami menggunakan berbagai fitur Nest.js dan TypeScript: modul, pengontrol, layanan, antarmuka, pipa, middleware, dan penjaga untuk membuat API  Saya harap Anda memiliki pengalaman yang baik dan siap untuk terus mengembangkan aplikasi kami.  Jika ada sesuatu yang tidak jelas bagi Anda, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi nest.js</a> adalah sumber yang bagus dengan jawaban </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471348/">https://habr.com/ru/post/id471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471336/index.html">Holivar. Sejarah Runet. Bagian 6. Kunci: Lurk, Tape, 282 dan jalur Cina</a></li>
<li><a href="../id471340/index.html">Drimsim vs Mate 20 Pro Round! Tapi untuk siapa?</a></li>
<li><a href="../id471342/index.html">Avalonia yang bergaya</a></li>
<li><a href="../id471344/index.html">Sekali lagi Tentang ImmutableList di Jawa</a></li>
<li><a href="../id471346/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 384 (7 - 13 Oktober 2019)</a></li>
<li><a href="../id471350/index.html">Membalikkan rekayasa amplifier operasional dengan noise rendah dari komputer analog pada tahun 1969</a></li>
<li><a href="../id471352/index.html">Menulis presentasi di LaTeX</a></li>
<li><a href="../id471358/index.html">Bagaimana cara menulis kontrak pintar dengan Python pada Ontologi? Bagian 4: API Asli</a></li>
<li><a href="../id471360/index.html">Metode duplikasi. 11 contoh dari desain ICE</a></li>
<li><a href="../id471364/index.html">Manajemen tes otomatis dengan Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>