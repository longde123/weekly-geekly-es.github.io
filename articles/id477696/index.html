<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💂 📵 🖐🏻 Domain front-end berdasarkan TLS 1.3. Bagian 2 👗 🧑🏾‍🤝‍🧑🏽 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Pada bagian pertama artikel, kami memberikan deskripsi singkat tentang mekanisme SNI terenkripsi (eSNI). Mereka menunjukkan bagaimana, p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Domain front-end berdasarkan TLS 1.3. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477696/"><h3>  Pendahuluan </h3><br>  Pada bagian pertama <a href="https://habr.com/ru/post/475372/">artikel,</a> kami memberikan deskripsi singkat tentang mekanisme SNI terenkripsi (eSNI).  Mereka menunjukkan bagaimana, pada dasarnya, adalah mungkin untuk menghindari deteksi oleh sistem DPI modern (menggunakan Beeline DPI dan rutracker ILV terlarang sebagai contoh), serta menjelajahi versi baru front-end domain berdasarkan mekanisme ini. <br><br>  Di bagian kedua artikel ini, kita akan beralih ke hal-hal yang lebih praktis sehingga RedTeam akan berguna bagi para spesialis dalam pekerjaan sulit mereka.  Pada akhirnya, tujuan kami bukan untuk mendapatkan akses ke sumber daya yang diblokir (untuk hal-hal biasa seperti itu, kami memiliki VPN lama yang baik).  Untungnya, ada banyak penyedia VPN, seperti yang mereka katakan, untuk setiap selera, warna, dan anggaran. <br><br>  Kami akan mencoba menerapkan mekanisme domain-fronting untuk alat RedTeam modern, misalnya, seperti Cobalt Strike, Empire, dll., Dan memberi mereka peluang tambahan untuk meniru dan menghindari sistem penyaringan konten modern. <br><a name="habracut"></a><br>  Terakhir kali, kami menerapkan mekanisme eSNI di pustaka OpenSSL dan berhasil menggunakannya dalam utilitas curl yang umum.  Tapi satu ikal, seperti kata mereka, tidak akan penuh.  Tentu saja, saya ingin mengimplementasikan sesuatu yang serupa dalam bahasa tingkat tinggi.  Namun, sayangnya, pencarian sepintas lalu tentang luasnya jaringan mengecewakan kami, karena dukungan untuk mekanisme eSNI sepenuhnya dilaksanakan hanya di GOLANG.  Jadi, pilihan kita tidak terlalu besar: kita menulis dalam C murni atau C ++ menggunakan pustaka OpenSSL yang ditambal, atau kita menggunakan garpu GOLANG terpisah dari CloudFlare dan mencoba untuk mem-porting alat-alat kita di sana.  Pada prinsipnya, ada opsi lain, lebih klasik, tetapi juga memakan waktu - adalah untuk mengimplementasikan dukungan eSNI untuk python.  Bagaimanapun, Python juga menggunakan OpenSSL untuk bekerja dengan https.  Tetapi kami akan menyerahkan opsi ini untuk pengembangan kepada orang lain, dan kami akan puas dengan implementasi pada Golang, terutama karena Cobalt Strike yang kami cintai dapat bekerja dengan baik dengan saluran komunikasi yang dibangun oleh alat pihak ketiga (saluran C2 Eksternal) - kami akan membicarakan hal ini di akhir artikel. <br><br><h3>  Coba Lebih Keras ... </h3><br>  Salah satu alat yang diimplementasikan pada Go adalah pengembangan kami untuk berputar di dalam jaringan - <a href="https://github.com/mis-team/rsockstun">tuner</a> rsockstun, yang, kebetulan, sekarang terdeteksi oleh Microsoft dan alat-alat Symantec sebagai perangkat lunak yang sangat berbahaya yang bertujuan melanggar stabilitas dunia ... <br><br><img src="https://habrastorage.org/webt/fg/mu/z4/fgmuz4c7bq1aazvf6su5qjbh32o.png"><br><br>  Akan sangat bagus untuk menggunakan pengembangan sebelumnya dalam kasus ini.  Tapi di sini muncul masalah kecil.  Faktanya adalah bahwa rsockstun awalnya menyiratkan penggunaan saluran komunikasi SSL yang sinkron dengan server.  Ini berarti bahwa koneksi dibuat sekali dan ada untuk seluruh durasi operasi terowongan.  Dan, seperti yang Anda pahami, protokol https tidak dirancang untuk mode operasi ini - protokol ini berfungsi dalam mode respons-respons, di mana setiap permintaan http baru ada dalam kerangka koneksi tcp baru. <br><br>  Kerugian utama dari skema ini adalah bahwa server tidak dapat mentransfer data ke klien sampai klien mengirim permintaan http baru.  Tapi, untungnya, ada banyak pilihan untuk menyelesaikan masalah ini - streaming data melalui protokol http (pada akhirnya, kami berhasil menonton acara TV favorit kami dan mendengarkan musik dari portal yang berjalan di https, dan transmisi video dan audio tidak selain streaming data).  Salah satu teknologi untuk meniru operasi koneksi tcp penuh melalui protokol http adalah teknologi WebSockets, yang intinya adalah untuk mengatur koneksi jaringan penuh antara klien dan server web. <br><br>  Untuk keberuntungan kami (hore hore !!!), teknologi ini disertakan secara default dalam semua paket tarif CloudFlare dan berfungsi sangat baik jika dikombinasikan dengan eSNI.  Inilah yang akan kami gunakan untuk mengajarkan terowongan kami menggunakan front-domain dan bersembunyi dari DPI modern. <br><br><h3>  Sedikit tentang WebSockets </h3><br>  Pertama-tama, kami akan secara singkat dan dengan kata sederhana memberitahu tentang soket web sehingga setiap orang memiliki gagasan tentang apa yang akan kami kerjakan. <br><br>  Teknologi soket web memungkinkan Anda untuk sementara waktu beralih dari koneksi http ke data streaming standar melalui soket jaringan tanpa memutus koneksi tcp yang telah dibuat.  Ketika klien ingin beralih ke soket web, ia menetapkan beberapa header http dalam permintaan http-nya.  Dua header yang diperlukan adalah <i><b>Koneksi: Peningkatan</b></i> dan <i><b>Peningkatan: websocket</b></i> .  Itu juga dapat memaksa versi protokol websocket ( <i><b>Sec-Websockset-Version: 13</b></i> ) dan sesuatu seperti pengidentifikasi soket web base64 ( <i><b>Sec-WebSocket-Key: DAGDJSiREI3 + KjDfwxm1FA ==</b></i> ).  Server merespons dengan http-code 101 Switching Protocols dan juga mengatur header <i><b>Connection, Upgrade,</b></i> dan <i><b>Sec-WebSocket-Accept</b></i> .  Proses switching diilustrasikan dalam tangkapan layar di bawah ini: <br><br><img src="https://habrastorage.org/webt/ci/tp/bg/citpbgee5m4fyv9-w5akwwq5t8q.png"><br><br>  Setelah itu, koneksi WebSocket dapat dianggap selesai.  Setiap data dari klien dan server sekarang akan diberikan tidak dengan http, tetapi dengan header WebSocket (mereka mulai dengan byte 0x82).  Sekarang server tidak perlu menunggu permintaan dari klien untuk mentransfer data, seperti  koneksi tcp tidak rusak. <br><br>  Ada beberapa perpustakaan di geng soket soket web.  Yang paling populer adalah <a href="https://github.com/gorilla/websocket">Gorilla WebSocket</a> dan <a href="https://godoc.org/golang.org/x/net/websocket">WebSocket</a> standar.  Kami akan menggunakan yang terakhir, karena  itu lebih sederhana, lebih kecil dan berfungsi, seperti yang mereka katakan, sedikit lebih cepat. <br><br>  Dalam kode klien rsockstun, kita perlu mengganti panggilan net.dial atau tls.dial dengan panggilan WebSocket yang sesuai: <br><br><img src="https://habrastorage.org/webt/ye/dw/vy/yedwvync3yktwhl_ssd2vm8eniy.png"><br><br><img src="https://habrastorage.org/webt/mw/j3/fw/mwj3fwfivbj7aqqsbg7whlkt9ai.png"><br><br>  Kami ingin menjadikan klien bagian dari terowongan kami universal dan dapat bekerja baik melalui koneksi ssl langsung dan melalui protokol WebSockset.  Untuk melakukan ini, kita akan membuat fungsi fungsi <i><b>func connectForWsSocks (string alamat, string proxy) terpisah {...}</b></i> dengan analogi dengan <i><b>connectForSocks ()</b></i> dan kita akan menggunakannya untuk bekerja dengan soket web jika alamat server yang ditentukan ketika klien mulai akan mulai dengan ws: or wss: (dalam kasus Secure WebSocket). <br><br>  Untuk sisi server dari terowongan, kami juga akan membuat fungsi terpisah untuk bekerja dengan soket web.  Sebuah instance dari kelas http akan dibuat di dalamnya dan handler koneksi http (fungsi wsHandler) akan ditetapkan: <br><br><img src="https://habrastorage.org/webt/2a/r7/cv/2ar7cvjzjc7wauwsb45ursxie2q.png"><br><br>  Dan kami akan menempatkan semua logika untuk memproses koneksi (mengesahkan klien dengan kata sandi, menginstal dan mengakhiri sesi yamux) di penangan koneksi WebSocket: <br><br><img src="https://habrastorage.org/webt/6r/kz/ay/6rkzays7haarsd9vyhak3xe4kbw.png"><br><br>  Kami mengkompilasi proyek, memulai bagian server: <br><br><pre><code class="go hljs">./rsockstun –listen ws:<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> –pass P@ssw0rd</code> </pre> <br>  Dan kemudian bagian klien: <br><br><pre> <code class="go hljs">./rsockstun -connect ws:<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> –pass P@ssw0rd</code> </pre> <br>  Dan kami memeriksa pekerjaan pada host lokal: <br><br><img src="https://habrastorage.org/webt/ci/tl/jh/citljhc7govgdkorfy6xm--c-dw.png"><br><br><img src="https://habrastorage.org/webt/cp/6m/mu/cp6mmuhm2xk5iaupu2wh0kato2s.png"><br><br><h3>  Kami beralih ke domain-fronting </h3><br>  Kami sepertinya telah memilah-milah soket web.  Sekarang mari kita langsung menuju eSNI dan domain-front.  Seperti yang disebutkan sebelumnya, untuk bekerja dengan DoH dan eSNI, kita perlu mengambil cabang khusus golang dari <a href="https://github.com/cloudflare/tls-tris">CloudFlare</a> .  Kami membutuhkan cabang dengan dukungan eSNI (pwu / esni). <br><br>  Kami mengkloningnya ke diri kami sendiri secara lokal atau mengunduh dan memperluas zip yang sesuai: <br><br><pre> <code class="plaintext hljs">git clone -b pwu/esni https://github.com/cloudflare/tls-tris.git</code> </pre> <br>  Maka kita perlu menyalin direktori GOROOT, mengganti file yang sesuai dari cabang kloning dan mengaturnya sebagai yang utama.  Untuk menyelamatkan pengembang dari sakit kepala ini, orang-orang dari CloudFlare menyiapkan skrip khusus - _dev / go.sh.  Jalankan saja.  Script bersama dengan makefile akan melakukan semuanya sendiri.  Untuk bersenang-senang - Anda bisa melihat ke dalam makefile untuk detailnya. <br><br>  Setelah mengerjakan skrip, saat menyusun proyek, kita perlu menunjukkan sebagai GOROOT direktori lokal yang disiapkan oleh skrip.  Dalam kasus kami, tampilannya seperti ini: <br><br><pre> <code class="plaintext hljs">GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" go build ….</code> </pre> <br>  Selanjutnya, kita perlu mengimplementasikan fungsi meminta dan mem-parsing kunci eSNI publik untuk domain yang diinginkan.  Dalam kasus kami, ini akan menjadi kunci eSNI publik dari server front-end CloudFlare.  Untuk melakukan ini, kami akan membuat tiga fungsi: <br><br><pre> <code class="plaintext hljs">func makeDoTQuery(dnsName string) ([]byte, error) func parseTXTResponse(buf []byte, wantName string) (string, error) func QueryESNIKeysForHost(hostname string) ([]byte, error)</code> </pre> <br>  Nama-nama fungsi, pada prinsipnya, berbicara sendiri.  Kami akan mengambil isian dari file esni_query.go, yang merupakan bagian dari tls-tris.  Fungsi pertama membuat paket jaringan dengan permintaan ke server DNS CloudFlare menggunakan protokol DoH (DNS-over-HTTPS), yang kedua mem-parsing hasil kueri dan menerima nilai-nilai kunci domain publik, dan yang ketiga adalah wadah untuk dua yang pertama. <br><br>  Selanjutnya, kami <i><b>memperkenalkan</b></i> fungsi meminta kunci eSNI untuk domain ke fungsi koneksi kami yang baru dibuat untuk soket web <i><b>connectForWsSocks</b></i> .  Di mana bagian server berfungsi, setel parameter TLS, dan juga setel nama "domain penutup" palsu: <br><br><img src="https://habrastorage.org/webt/s0/kk/vu/s0kkvu24eh0wc7olaeffffknrck.png"><br><br>  Perlu dicatat di sini bahwa pada awalnya, cabang tls-tris tidak dirancang untuk penggunaan domain-fronting.  Oleh karena itu, itu tidak memperhatikan nama palsu server (bidang serverName kosong ditransmisikan sebagai bagian dari paket client-halo).  Untuk memperbaikinya, kita harus menambahkan bidang FakeServerName yang sesuai ke struktur TlsConfig.  Kami tidak dapat menggunakan bidang ServerName standar dari struktur, karena  ini digunakan oleh mekanisme internal tls dan jika berbeda dari aslinya, maka jabat tangan tls akan berakhir dengan kesalahan.  Deskripsi struktur TlsConfig terkandung dalam file <b>tls / common.go</b> - kita harus memperbaikinya: <br><br><img src="https://habrastorage.org/webt/pu/2l/f4/pu2lf425co5cex8zfa-h2ewdbw8.png"><br><br><img src="https://habrastorage.org/webt/q1/jk/2i/q1jk2iiwpohss6nhr1uanlnkqp8.png"><br><br>  Selain itu, kita harus membuat perubahan pada file <b>tls / handshake_client.go</b> untuk menggunakan bidang FakeServerName kami saat membuat jabat tangan TLS: <br><br><img src="https://habrastorage.org/webt/fy/nq/ln/fynqlnmskvfz0exd4im58vzpwfi.png"><br><br>  Itu saja!  Anda dapat mengkompilasi proyek dan memeriksa pekerjaan.  Tetapi sebelum Anda menjalankan tes, Anda harus mengonfigurasi akun CloudFlare Anda.  Nah, bagaimana Anda mengatakan untuk mengatur - cukup buat akun cloudflare dan ikat domain Anda ke sana.  Semua chip yang terkait dengan DoH, WebSocket dan ESNI termasuk dalam CloudFlare secara default.  Setelah catatan DNS diperbarui - Anda dapat memeriksa domain dengan menjalankan permintaan kunci eSNI: <br><br><pre> <code class="plaintext hljs">dig +short txt _esni.df13tester.info</code> </pre> <br><img src="https://habrastorage.org/webt/xh/9a/6g/xh9a6gmmlc1jg-deqesdliip09a.png"><br><br>  Jika Anda melihat sesuatu yang mirip dengan domain Anda, maka semuanya berfungsi untuk Anda dan Anda dapat melanjutkan ke pengujian. <br><br>  Luncurkan VPS Ubuntu, misalnya, di DigitalOcean.  PS Dalam kasus kami, alamat IP VPS yang baru saja dikeluarkan oleh penyedia berada dalam daftar hitam ILV.  Jadi jangan heran jika hal serupa terjadi pada Anda.  Saya harus menggunakan VPN untuk sampai ke VPS saya. <br><br>  Kami menyalin rsockstun yang telah dikompilasi ke VPS (ini, omong-omong, adalah pesona lain dari golang - Anda dapat mengkompilasi proyek sendiri dan menjalankannya di Linux apa pun, hanya mengamati kapasitas bit sistem) dan memulai bagian server: <br><br><img src="https://habrastorage.org/webt/kx/-w/th/kx-wth7rif35is4bd5_flfmkjzq.png"><br><br>  Dan kemudian bagian klien: <br><br><img src="https://habrastorage.org/webt/sf/er/7d/sfer7dpqq1lumfaxmzzxn1n_pfs.png"><br><br>  Seperti yang dapat kita lihat, klien berhasil terhubung ke server melalui server front-end CloudFlare menggunakan soket web.  Untuk memverifikasi bahwa terowongan berfungsi seperti terowongan, Anda dapat membuat permintaan ikal melalui socks5 lokal yang terbuka di server: <br><br><img src="https://habrastorage.org/webt/qg/na/ti/qgnati8zvd8jc9okh4bei0kbihm.png"><br><br>  Sekarang mari kita lihat apa yang dilihat DPI di saluran komunikasi: <br><br><img src="https://habrastorage.org/webt/0p/ph/av/0pphavhdhhnrtfxfkzxsf7vjcxs.png"><br><br>  Pertama, tuner terowongan, menggunakan mekanisme DoH, mengakses server Cloudflare DNS untuk kunci eSNI untuk domain tujuan (paket No. 1-19), dan kemudian mengakses server front-end dan membuat koneksi TLS, bersembunyi di bawah domain <a href="http://www.google.com/">www.google.com</a> (nilai ini secara default, ketika domain palsu tidak disetel saat startup klien).  Untuk menentukan domain palsu Anda, Anda harus menggunakan parameter -fronfDomain: <br><br><img src="https://habrastorage.org/webt/zp/8l/0_/zp8l0_a_cktaz6rrrgao4qo8c2g.png"><br><br><img src="https://habrastorage.org/webt/cq/gn/wn/cqgnwnp9bzo7hzjpb8gcgvqfd6i.png"><br><br>  Sekarang satu hal lagi.  Secara default, pengaturan akun CloudFalre diatur ke SSL Fleksibel.  Ini berarti bahwa https permintaan ke server front-end Cloudflare dari klien akan dialihkan dalam bentuk tidak terenkripsi (http) ke server kami.  Itulah sebabnya kami meluncurkan bagian server dari terowongan dalam mode non-ssl (-listen ws: 0.0.0.0), dan bukan (-listen wss: 0.0.0.0). <br><br><img src="https://habrastorage.org/webt/4j/fy/5n/4jfy5nl5csmeqc6bxd7vbgdhm7a.png"><br><br>  Untuk beralih ke mode enkripsi penuh, Anda harus memilih <b>Penuh</b> , atau <b>Penuh (ketat)</b> jika ada sertifikat ini di server.  Setelah beralih mode, kita akan dapat menerima koneksi dari CloudFlare melalui protokol https.  Ingatlah untuk membuat sertifikat yang ditandatangani sendiri untuk sisi server terowongan. <br><br><img src="https://habrastorage.org/webt/ou/9x/9i/ou9x9ihogwotva8y-xwda5v12ps.png"><br><br>  Pembaca yang menjengkelkan akan bertanya: "Bagaimana dengan akun klien di Windows?  Memang, yang pasti, aplikasi utama terowongan adalah untuk meningkatkan koneksi kembali dari mesin dan server perusahaan, dan di sana, sebagai aturan, selalu Windows.  Bagaimana saya bisa mengkompilasi sebuah terowongan untuk Windows, dan bahkan dengan tumpukan TLS tertentu?  Kami mengkompilasi untuk windows langsung dari Kali, cukup dengan menambahkan parameter GOOS = windows: <br><br><pre> <code class="plaintext hljs">GOARCH=amd64 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows go build -ldflags="-s -w"</code> </pre> <br>  Atau opsi 32-bit: <br><br><pre> <code class="plaintext hljs">GOARCH=386 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows go build -ldflags="-s -w"</code> </pre> <br>  Itu saja!  Dan tidak ada lagi masalah yang dibutuhkan.  Ini benar-benar berfungsi! <br><br><img src="https://habrastorage.org/webt/hq/cc/qf/hqccqf4y2sim1yutlrdduo3kmom.png"><br><br>  Flag compiler –w dan –s diperlukan untuk menghapus kelebihan sampah dari file yang dapat dieksekusi, membuatnya lebih sedikit beberapa megabyte.  Selain itu, kemudian dapat dikemas menggunakan UPX untuk mengurangi ukuran lebih lanjut. <br><br><h3>  Alih-alih sebuah kesimpulan </h3><br>  Dalam artikel kami, menggunakan contoh tuner yang ditulis pada golang, dengan jelas menunjukkan penggunaan teknologi baru domain-fronting, diimplementasikan pada fitur yang agak menarik dari protokol TLS 1.3.  Demikian pula, Anda dapat mengadaptasi toolkit yang ada yang ditulis pada golang untuk bekerja melalui server CloudFlare, misalnya <a href="https://github.com/Ne0nd0g/merlin">Merlin</a> , C2 yang terkenal, atau memaksa CobaltStrike Beacon untuk menggunakan domain-depan eSNI saat bekerja dengan Teamserver melalui <a href="https://github.com/ryhanson/ExternalC2">Kanal C2 Eksternal</a> , diterapkan pada golang, atau pada standar C ++ menggunakan versi OpenSSL yang ditambal, yang kita bicarakan di bagian akhir artikel.  Secara umum, fantasi tidak memiliki batas. <br><br>  Contoh terowongan dan CloudFlare disajikan dalam bentuk konsep dan masih sulit untuk mengatakan tentang prospek yang jauh dari jenis domain yang menghadap ke depan.  Saat ini, dukungan eSNI hanya tersedia di CloudFlare dan, pada prinsipnya, tidak ada yang mencegah mereka menonaktifkan front-end seperti ini dan, misalnya, memutuskan koneksi ketika SNI dan eSNI tidak cocok.  Secara umum, masa depan akan ditampilkan.  Tetapi untuk saat ini, prospek bekerja di bawah kedok kremlin.ru tampaknya cukup menarik.  Benar? <br><br>  Kode terowongan yang diperbarui, serta file exe yang dapat dieksekusi yang dikompilasi, terletak di cabang proyek terpisah di <a href="https://github.com/mis-team/rsockstun">github</a> .  Lebih baik menulis masalah tentang semua masalah terowongan yang mungkin terjadi pada halaman proyek di GitHub. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477696/">https://habr.com/ru/post/id477696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477684/index.html">Angular: Sahabat Bangunan Terbaik untuk aplikasi Interaktif</a></li>
<li><a href="../id477686/index.html">Kami di Konferensi Perjalanan AI</a></li>
<li><a href="../id477688/index.html">Desember Acara TI Digest</a></li>
<li><a href="../id477692/index.html">Pengalaman menggunakan ZGC dan Shenandoah GC dalam produksi</a></li>
<li><a href="../id477694/index.html">JavaScript tidak perlu diganti dengan apa pun - bahasa lain juga akan menghadapi masalah yang sama</a></li>
<li><a href="../id477700/index.html">Prinsip Hollywood (IoC)</a></li>
<li><a href="../id477704/index.html">CodeSide. Game baru untuk kompetisi Piala AI Rusia yang terkenal</a></li>
<li><a href="../id477706/index.html">Konten campuran saat mengunduh dari HTTPS: cara menemukan dan mengatasinya</a></li>
<li><a href="../id477710/index.html">Apa yang tidak mereka ajarkan di sekolah: bagaimana kami melatih teknisi pendukung teknis</a></li>
<li><a href="../id477712/index.html">Objek versus Struktur Data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>