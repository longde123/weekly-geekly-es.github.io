<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌍 💅 🔂 使用C＃8.0中的模式执行更多操作 📚 🗼 💔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Visual Studio 2019预览版2已经发布！ 有了它，您可以尝试更多的C＃8.0功能。 它主要与模式匹配有关，尽管最后我将介绍其他一些新闻和更改。 
 原始博客 

 在更多地方有更多图案 


当C＃7.0引入模式匹配时，我们说过我们希望在将来的更多地方添加更多模式。 那个时候到了！ 我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用C＃8.0中的模式执行更多操作</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/438256/"><img width="120" align="left" src="https://habrastorage.org/webt/8w/rq/7v/8wrq7vfhyqv2saamr2d5z2jha5o.png"><p>  Visual Studio 2019预览版2已经发布！ 有了它，您可以尝试更多的C＃8.0功能。 它主要与模式匹配有关，尽管最后我将介绍其他一些新闻和更改。 </p><br><a name="habracut"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始博客</a> <br><br><h1> 在更多地方有更多图案 </h1><br><p>当C＃7.0引入模式匹配时，我们说过我们希望在将来的<em>更多</em>地方添加<em>更多</em>模式。 那个时候到了！ 我们将添加所谓的<em>递归模式</em> ，以及更紧凑的<code>switch</code>语句的表达式形式，称为（您猜对了！）switch <em>表达式</em> 。 </p><br><p> 这是一个简单的C＃7.0模式示例，可以让我们开始： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { get; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { get; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre><br><h2> 切换表达式 </h2><br><p> 首先，让我们观察一下，许多<code>switch</code>语句在<code>case</code>主体中确实没有做很多有趣的工作。 通常，它们都只是通过将值分配给变量或通过返回值来产生值（如上所述）。 在所有这些情况下，坦率地说switch语句都比较笨拙。 感觉就像是拥有5多年历史的语言功能，而且还有很多仪式。 </p><br><p> 我们认为是时候添加<code>switch</code>的表达形式了。 在这里，适用于以上示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre><br><p> 这里有几件事与switch语句有所不同。 让我们列出它们： </p><br><ul><li>  <code>switch</code>关键字是测试值和案例列表之间的“中缀”。 这使得它与其他表达式更加融合，并且更容易从视觉上区分switch语句。 </li><li> 为简洁起见， <code>case</code>关键字和<code>:</code>已替换为lambda箭头<code>=&gt;</code> 。 </li><li> 为简洁起见， <code>default</code>已被<code>_</code>丢弃模式替换。 </li><li> 身体是表情！ 所选正文的结果成为switch表达式的结果。 </li></ul><br><p> 由于表达式需要具有值或引发异常，因此未匹配而到达末尾的switch表达式将引发异常。 当可能出现这种情况时，编译器会尽力警告您，但不会强迫您以包罗万象的结尾来结束所有switch表达式：您可能会更好！ </p><br><p> 当然，由于我们的<code>Display</code>方法现在由单个return语句组成，因此我们可以将其简化为表达式形式： </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p> 老实说，我不确定我们将在此处给出什么格式指导，但是应该清楚，这更加简洁明了，尤其是因为简洁起见，您通常可以使用“表格”格式来设置开关格式，如上所述，其中模式和主体在同一行上，并且<code>=&gt;</code>彼此对齐。 </p><br><p> 顺便说一句，我们计划在最后一种情况之后允许尾随逗号<code>,</code>以与C＃中的所有其他“大括号中的逗号分隔列表”保持一致，但是Preview 2尚不允许这样做。 </p><br><h2> 属性模式 </h2><br><p> 简而言之，模式突然变成了上面switch表达式中最重的元素！ 让我们为此做些事情。 </p><br><p> 请注意，switch表达式使用<em>类型模式</em> <code>Point p</code> （两次）以及<code>when</code>子句为第一种<code>case</code>添加其他条件。 </p><br><p> 在C＃8.0中，我们向类型模式添加了更多可选元素，这允许模式本身进一步挖掘与模式匹配的值。 您可以通过添加<code>{...}</code>的包含嵌套模式的<em>属性模式，</em>以将其应用于值的可访问属性或字段。 让我们如下重写switch表达式： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } p =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p> 两种情况仍然检查<code>o</code>是否为<code>Point</code> 。 然后，第一种情况将常量模式<code>0</code>递归应用于<code>p</code>的<code>X</code>和<code>Y</code>属性，检查它们是否具有该值。 因此<code>when</code>在这种情况和许多常见情况下，我们可以消除<code>when</code>子句。 </p><br><p> 第二种情况将<code>var</code>模式应用于<code>X</code>和<code>Y</code>每个。 回想一下，C＃7.0中的<code>var</code>模式始终会成功，并且只需声明一个新鲜变量即可保存该值。 因此， <code>x</code>和<code>y</code>包含<code>pX</code>和<code>pY</code> 。 </p><br><p> 我们从不使用<code>p</code> ，实际上可以在这里省略它： </p><br><pre> <code class="cpp hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre><br><p> 对于所有类型模式（包括属性模式）而言，一件事都是正确的，那就是它们要求该值必须为非null。 这就打开了将“空”属性模式<code>{}</code>用作紧凑的“非空”模式的可能性。 例如，我们可以将后备情况替换为以下两种情况： </p><br><pre> <code class="cpp hljs"> {} =&gt; o.ToString(), null =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre><br><p>  <code>{}</code>处理剩余的非null对象，而<code>null</code>获得null，因此切换是详尽的，编译器将不会抱怨值丢失。 </p><br><h2> 位置模式 </h2><br><p> 属性模式并不能完全<em>缩短</em>第二个<code>Point</code>大小写，似乎不值得在那儿麻烦，但还有很多事情可以做。 </p><br><p> 注意<code>Point</code>类具有<code>Deconstruct</code>方法，即所谓的<em>deconstructor</em> 。 在C＃7.0中，解构函数允许在赋值时解构一个值，因此您可以编写例如： </p><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre><br><p>  C＃7.0没有将解构与模式集成在一起。 这随<em>位置模式</em>而变化，这是我们在C＃8.0中扩展类型模式的另一种方式。 如果匹配类型是元组类型或具有解构函数，则可以使用位置模式作为应用递归模式的紧凑方式，而不必命名属性： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(var x, var y) =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p> 一旦将对象匹配为<code>Point</code> ，就应用解构函数，并将嵌套模式应用于结果值。 </p><br><p> 解构函数并不总是合适的。 仅应将它们添加到真正清楚哪个值是哪个值的类型中。 例如，对于<code>Point</code>类，假定第一个值为<code>X</code> ，第二个值为<code>Y</code> ，则是安全直观的，因此上述开关表达式直观且易于阅读。 </p><br><h2> 元组模式 </h2><br><p> 位置模式的一个非常有用的特殊情况是将其应用于元组。 如果将switch语句直接应用于元组表达式，我们甚至允许省略多余的括号集，如<code>switch (x, y, z)</code>而不是<code>switch ((x, y, z))</code> 。 </p><br><p> 元组模式非常适合同时测试多个输入。 这是状态机的简单实现： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p> 当然，我们可以选择在已打开的元组中包含<code>hasKey</code>而不是使用<code>when</code>子句-这实际上是一个问题： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p> 总之，我希望您能看到递归模式和switch表达式可以导致更清晰和更具声明性的程序逻辑。 </p><br><h1> 预览2中的其他C＃8.0功能 </h1><br><p> 虽然模式功能是VS 2019 Preview 2中上线的主要功能，但是我希望您能从中找到一些有用的功能和有趣的一些小功能。 我不会在这里详细介绍，而只是给您一个简短的描述。 </p><br><h2> 使用声明 </h2><br><p> 在C＃中， <code>using</code>语句总是导致一定程度的嵌套，这可能会非常烦人并损害可读性。 对于仅希望在作用域末尾清除资源的简单情况，现在可以<em>使用声明</em>代替。  using声明只是局部变量声明，其前面带有<code>using</code>关键字，它们的内容位于当前语句块的末尾。 所以代替： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre><br><p> 你可以简单地写 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> var options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre><br><h2> 一次性引用结构 </h2><br><p> 引用结构是在C＃7.2中引入的，并不是在这里重申其有用性，但是作为回报，它们具有一些严重的局限性，例如无法实现接口。 现在，仅通过在其中具有<code>Dispose</code>方法，就可以在不实现<code>IDisposable</code>接口的情况下使用ref结构。 </p><br><h2> 静态局部功能 </h2><br><p> 如果要确保您的局部函数不会产生与包围范围中的“捕获”（引用）变量相关的运行时开销，则可以将其声明为<code>static</code> 。 然后，编译器将阻止引用封闭函数中声明的任何内容-除了其他静态局部函数！ </p><br><h1> 自预览版1以来的更改 </h1><br><p> 预览1的主要功能是可为空的引用类型和异步流。 两者在Preview 2中都有一些改进，因此，如果您开始使用它们，则以下几点很容易意识到。 </p><br><h2> 可空引用类型 </h2><br><p> 我们在源代码中（通过<code>#nullable</code>和<code>#pragma warning</code>指令）和项目级别添加了更多选项来控制可为空的警告。 我们还将项目文件选择加入更改为<code>&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;</code> 。 </p><br><h2> 异步流 </h2><br><p> 我们更改了编译器期望的<code>IAsyncEnumerable&lt;T&gt;</code>接口的形状！ 这会使编译器与.NET Core 3.0 Preview 1中提供的接口不同步，这可能会引起一些麻烦。 但是，.NET Core 3.0 Preview 2即将发布，这将使界面恢复同步。 </p><br><h1> 加油！ </h1><br><p> 一如既往，我们热切期待您的反馈！ 请特别试用新的图案功能。 你碰到砖墙吗？ 有烦人的事吗？ 您为他们找到了哪些有趣且有用的方案？ 点击反馈按钮，让我们知道！ </p><br><p> 快乐黑客 </p><br><p>  Mads Torgersen，C＃设计负责人 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438256/">https://habr.com/ru/post/zh-CN438256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438244/index.html">我们以逮捕毒ord为例处理俄罗斯的密码法规</a></li>
<li><a href="../zh-CN438248/index.html">GitHub行动生活</a></li>
<li><a href="../zh-CN438250/index.html">对信息安全原则的无知并不免除</a></li>
<li><a href="../zh-CN438252/index.html">为什么不起飞房地产门户网站。 第一部分</a></li>
<li><a href="../zh-CN438254/index.html">Eclipse推出适用于Java EE 8的GlassFish 5.1</a></li>
<li><a href="../zh-CN438260/index.html">“现代” C ++：带有哀叹的哀叹会话</a></li>
<li><a href="../zh-CN438262/index.html">现代世界中的网络物理系统</a></li>
<li><a href="../zh-CN438264/index.html">Direct Connect中的流量加密，第1部分</a></li>
<li><a href="../zh-CN438266/index.html">为什么渗透测试对您的业务很重要？</a></li>
<li><a href="../zh-CN438270/index.html">在Mail.ru组爱Kubernetes：2月14日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>