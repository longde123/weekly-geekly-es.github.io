<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèº ü§≥üèª üîñ Sistemas Basados ‚Äã‚Äãen Cola üòö ‚ûï üë©üèª‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! 

 Decidimos compartir la traducci√≥n del cap√≠tulo ‚ÄúSistemas basados ‚Äã‚Äãen colas de tareas‚Äù De la pr√≥xima novedad ‚ÄúSistemas distribui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas Basados ‚Äã‚Äãen Cola</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/440444/">  Hola habrozhiteli! <br><br>  Decidimos compartir la traducci√≥n del cap√≠tulo ‚ÄúSistemas basados ‚Äã‚Äãen colas de tareas‚Äù De la pr√≥xima novedad ‚ÄúSistemas distribuidos.  Patrones de dise√±o ‚Äù(ya en la imprenta). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c0/c7/6k/c0c76kbloj9pjb2olgoma345bes.png" alt="imagen"></div><br>  La forma m√°s simple de procesamiento por lotes es la cola de tareas.  En un sistema con una cola de tareas, hay un conjunto de tareas que deben completarse.  Cada tarea es completamente independiente de las dem√°s y se puede procesar sin ninguna interacci√≥n con ellas.  En el caso general, el objetivo de un sistema con una cola de tareas es garantizar que cada etapa del trabajo se complete dentro de un per√≠odo de tiempo determinado.  El n√∫mero de flujos de trabajo aumenta o disminuye de acuerdo con el cambio en la carga.  El diagrama de cola de tareas generalizadas se muestra en la Fig.  10.1 <br><a name="habracut"></a><br><h3>  Un sistema basado en una cola de tareas generalizadas </h3><br>  La l√≠nea de tareas es un ejemplo ideal que demuestra la potencia total de los patrones de dise√±o de sistemas distribuidos.  La mayor parte de la l√≥gica de la cola de tareas no depende del tipo de trabajo realizado.  En muchos casos, lo mismo se aplica a la entrega de las tareas mismas. <br><br>  Perm√≠tanos ilustrar esta declaraci√≥n usando la cola de tareas que se muestra en la Fig.  10.1  Despu√©s de mirarlo nuevamente, determine qu√© funciones puede proporcionar un conjunto compartido de contenedores.  Es evidente que la mayor parte de la implementaci√≥n de una cola de tareas en contenedor puede ser utilizada por una amplia gama de usuarios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8h/b2/qf/8hb2qfylszx_qmk8dicocvnvxtg.png" alt="imagen"></div><br>  La cola de tareas basada en contenedores requiere interfaces coincidentes entre los contenedores de la biblioteca y los contenedores con la l√≥gica del usuario.  Dentro de la cola de tareas en contenedor, se distinguen dos interfaces: la interfaz del contenedor de origen, que proporciona una secuencia de tareas que requieren procesamiento, y la interfaz del contenedor en ejecuci√≥n, que sabe c√≥mo manejarlas. <br><br><h3>  Interfaz de contenedor de origen </h3><br>  Cualquier cola de tareas opera sobre la base de un conjunto de tareas que requieren procesamiento.  Dependiendo de la aplicaci√≥n espec√≠fica implementada sobre la base de la cola de tareas, hay muchas fuentes de tareas que se incluyen en ella.  Pero despu√©s de recibir un conjunto de tareas, el esquema de operaci√≥n de la cola es bastante simple.  Por lo tanto, podemos separar la l√≥gica espec√≠fica de la aplicaci√≥n del origen de la tarea del esquema generalizado de procesamiento de la cola de tareas.  Recordando los patrones discutidos anteriormente de los grupos de contenedores, aqu√≠ puede ver la implementaci√≥n del patr√≥n Ambassador.  El contenedor de la cola de tareas generalizadas es el contenedor principal de la aplicaci√≥n, y el contenedor de origen espec√≠fico de la aplicaci√≥n es un embajador que transmite solicitudes desde el contenedor del gestor de colas a los ejecutores de tareas espec√≠ficos.  Este grupo de contenedores se muestra en la Fig.  10.2 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/7u/pc/bx7upcqfw7gxqus2zqrhbrhqpes.png" alt="imagen"></div><br>  Por cierto, aunque el contenedor embajador es espec√≠fico de la aplicaci√≥n (lo cual es obvio), tambi√©n hay una serie de implementaciones generalizadas de la API de origen de la tarea.  Por ejemplo, la fuente puede ser una lista de fotos ubicadas en alg√∫n almacenamiento en la nube, un conjunto de archivos en una unidad de red o incluso una cola en sistemas que funcionan con un principio de "publicaci√≥n / suscripci√≥n", como Kafka o Redis.  A pesar de que los usuarios pueden elegir los contenedores-embajadores m√°s adecuados para su tarea, deben usar una implementaci√≥n generalizada de "biblioteca" del contenedor.  Esto minimizar√° la cantidad de trabajo y maximizar√° la reutilizaci√≥n del c√≥digo. <br><br>  <b>API de cola de tareas</b>  Dado el mecanismo de interacci√≥n entre la cola de tareas y el contenedor dependiente de la aplicaci√≥n, deber√≠amos formular una definici√≥n formal de la interfaz entre los dos contenedores.  Existen muchos protocolos diferentes, pero las API RESTful de HTTP son f√°ciles de implementar y son el est√°ndar de facto para tales interfaces.  La cola de tareas espera que las siguientes URL se implementen en el contenedor posterior: <br><br><ul><li>  OBTENGA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localhost / api / v1 / items;</a> </li><li>  OBTENGA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localhost / api / v1 / items</a> &lt;item-name&gt;. </li></ul><blockquote>  ¬øPor qu√© agregar v1 a su definici√≥n de API?  ¬øHabr√° alguna vez una segunda versi√≥n de la interfaz?  Parece il√≥gico, pero el costo de versionar la API cuando se define inicialmente es m√≠nimo.  Realizar la refactorizaci√≥n adecuada m√°s adelante ser√° extremadamente costoso.  Establezca una regla para agregar versiones a todas las API, incluso si no est√° seguro de si alguna vez cambiar√°n.  Dios salva la caja fuerte. <br></blockquote>  URL / items / devuelve una lista de todas las tareas: <br><br><pre><code class="plaintext hljs">{ kind: ItemList, apiVersion: v1, items: [ "item-1", "item-2", ‚Ä¶. ] }</code> </pre> <br>  La URL / items / &lt;item-name&gt; proporciona informaci√≥n detallada sobre una tarea espec√≠fica: <br><br><pre> <code class="plaintext hljs">{ kind: Item, apiVersion: v1, data: { "some": "json", "object": "here", } }</code> </pre> <br>  Tenga en cuenta que la API no proporciona ning√∫n mecanismo para corregir el hecho de la tarea.  Se podr√≠a desarrollar una API m√°s compleja y transferir la mayor parte de la implementaci√≥n a un embajador de contenedores.  Sin embargo, recuerde que nuestro objetivo es concentrar la mayor parte de la implementaci√≥n general posible dentro del administrador de colas de tareas.  A este respecto, el gestor de colas de tareas debe supervisar qu√© tareas ya se han procesado y cu√°les a√∫n no se han procesado. <br><br>  De esta API obtenemos informaci√≥n sobre una tarea espec√≠fica y luego pasamos el valor del campo item.data de la interfaz del contenedor del ejecutor. <br><br><h3>  Ejecutar interfaz de contenedor </h3><br>  Tan pronto como el gestor de colas reciba la siguiente tarea, debe confiarla a alg√∫n ejecutor.  Esta es la segunda interfaz en la cola de tareas generalizadas.  El contenedor en s√≠ y su interfaz son ligeramente diferentes de la interfaz del contenedor de origen por varias razones.  En primer lugar, es una API √∫nica.  El trabajo del ejecutor comienza con una sola llamada, y durante el ciclo de vida del contenedor, no se realizan m√°s llamadas.  En segundo lugar, el contenedor de ejecuci√≥n y el gestor de colas de tareas est√°n en diferentes grupos de contenedores.  El ejecutor del contenedor se inicia a trav√©s de la API del orquestador del contenedor en su propio grupo.  Esto significa que el administrador de colas de tareas debe realizar una llamada remota para iniciar el contenedor de ejecuci√≥n.  Tambi√©n significa que debe tener m√°s cuidado con los problemas de seguridad, ya que un usuario malintencionado del cl√∫ster puede cargarlo con trabajo innecesario. <br><br>  En el contenedor de origen, utilizamos una simple llamada HTTP para enviar la lista de tareas al administrador de tareas.  Esto se hizo suponiendo que esta llamada a la API deb√≠a hacerse varias veces, y no se tuvieron en cuenta los problemas de seguridad, ya que todo funcionaba dentro del marco localhost.  La API del contenedor debe llamarse solo una vez y es importante asegurarse de que otros usuarios del sistema no puedan agregar trabajo a los ejecutores, incluso por accidente o por intenci√≥n maliciosa.  Por lo tanto, para el contenedor en ejecuci√≥n, utilizaremos el archivo API.  Tras la creaci√≥n, le pasaremos al contenedor una variable de entorno llamada WORK_ITEM_FILE, cuyo valor se refiere a un archivo en el sistema de archivos interno del contenedor.  Este archivo contiene datos sobre la tarea a completar.  Este tipo de API, como se muestra a continuaci√≥n, puede ser implementado por el objeto ConfigMap Kubernetes.  Se puede montar en un grupo de contenedores como un archivo (Fig. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/p0/zb/jnp0zbiduvl1qsstlwa1mphwrxq.png" alt="imagen"></div><br>  Tal mecanismo de API de archivo es m√°s f√°cil de implementar usando un contenedor.  Un ejecutor dentro de una cola de tareas es a menudo un simple script de shell que accede a varias herramientas.  No es pr√°ctico crear un servidor web completo para la gesti√≥n de tareas; esto lleva a una complicaci√≥n de la arquitectura.  Como en el caso de las fuentes de tareas, la mayor√≠a de los contenedores-ejecutores ser√°n contenedores especializados para ciertas tareas, pero tambi√©n hay ejecutores generalizados aplicables para resolver varias tareas diferentes. <br><br>  Considere el ejemplo de un contenedor en ejecuci√≥n que descarga un archivo del almacenamiento en la nube, ejecuta un script de shell en √©l y luego copia el resultado nuevamente en el almacenamiento en la nube.  Tal contenedor puede ser en su mayor parte general, pero se le puede pasar un escenario espec√≠fico como par√°metro.  Por lo tanto, la mayor√≠a del c√≥digo de manejo de archivos puede ser reutilizado por muchos usuarios / colas de tareas.  El usuario final solo necesita proporcionar un script que contenga los detalles del procesamiento de archivos. <br><br><h3>  Infraestructura com√∫n de colas de tareas </h3><br>  ¬øQu√© queda por implementar en una implementaci√≥n de cola reutilizable si ya tiene implementaciones de las dos interfaces de contenedor descritas anteriormente?  El algoritmo b√°sico de la cola de tareas es bastante simple. <br><br><ol><li>  Descargue las tareas disponibles actualmente del contenedor de origen. </li><li>  Aclare el estado de la cola de tareas para las tareas que ya se han completado o que a√∫n se est√°n realizando. </li><li>  Para cada una de las tareas no resueltas, cree contenedores de contenedores con una interfaz adecuada. </li><li>  Al completar con √©xito el contenedor en ejecuci√≥n, registre que la tarea se ha completado. </li></ol><br>  Este algoritmo es simple en palabras, pero en realidad no es tan f√°cil de implementar.  Afortunadamente, la orquesta de Kubernetes tiene varias caracter√≠sticas que simplifican enormemente su implementaci√≥n.  A saber: Kubernetes tiene un objeto Job que garantiza un funcionamiento confiable de la cola de tareas.  Puede configurar el objeto Trabajo para que inicie el contenedor de ejecuci√≥n correspondiente una sola vez o hasta que la tarea se complete con √©xito.  Si configura el contenedor de ejecuci√≥n para que se ejecute antes de que se complete la tarea, incluso cuando la m√°quina en el cl√∫ster falla, la tarea finalmente se completar√° con √©xito. <br><br>  Por lo tanto, la cola de tareas se simplifica enormemente, ya que la orquesta se responsabiliza de la ejecuci√≥n confiable de las tareas. <br><br>  Adem√°s, Kubernetes le permite anotar tareas, lo que nos permite marcar cada objeto de tarea con el nombre del elemento de la cola de tareas procesadas.  Cada vez es m√°s f√°cil distinguir entre las tareas que se procesan y se completan con √©xito y con un error. <br><br>  Esto significa que podemos implementar la cola de tareas sobre el orquestador de Kubernetes sin usar nuestro propio repositorio.  Todo esto simplifica enormemente la tarea de construir la infraestructura de la cola de tareas. <br><br>  Por lo tanto, un algoritmo detallado para la operaci√≥n del contenedor, el administrador de colas de tareas, es el siguiente. <br><br>  Repite sin cesar. <br><br><ol><li>  Obtenga la lista de tareas a trav√©s de la interfaz del contenedor, la fuente de las tareas. </li><li>  Obtenga una lista de tareas que sirven a esta cola de tareas. </li><li>  Sobre la base de estas listas, seleccione una lista de tareas no procesadas. </li><li>  Para cada tarea no procesada, cree un objeto Job que genere el contenedor de ejecuci√≥n correspondiente. </li></ol><br>  Aqu√≠ hay un script de Python que implementa esta cola: <br><br><pre> <code class="plaintext hljs">import requests import json from kubernetes import client, config import time namespace = "default" def make_container(item, obj): container = client.V1Container() container.image = "my/worker-image" container.name = "worker" return container def make_job(item): response = requests.get("http://localhost:8000/items/{}".format(item)) obj = json.loads(response.text) job = client.V1Job() job.metadata = client.V1ObjectMeta() job.metadata.name = item job.spec = client.V1JobSpec() job.spec.template = client.V1PodTemplate() job.spec.template.spec = client.V1PodTemplateSpec() job.spec.template.spec.restart_policy = "Never" job.spec.template.spec.containers = [ make_container(item, obj) ] return job def update_queue(batch): response = requests.get("http://localhost:8000/items") obj = json.loads(response.text) items = obj['items'] ret = batch.list_namespaced_job(namespace, watch=False) for item in items: found = False for i in ret.items: if i.metadata.name == item: found = True if not found: #    Job,  #   job = make_job(item) batch.create_namespaced_job(namespace, job) config.load_kube_config() batch = client.BatchV1Api() while True: update_queue(batch) time.sleep(10)</code> </pre> <br><h3>  Taller  Implementaci√≥n de un generador de miniaturas para archivos de video </h3><br>  Como ejemplo de uso de la cola de tareas, considere la tarea de generar miniaturas de archivos de video.  Con base en estas miniaturas, los usuarios deciden qu√© videos quieren ver. <br><br>  Para implementar las miniaturas, necesita dos contenedores.  El primero es para la fuente de las tareas.  Ser√° m√°s f√°cil colocar tareas en una unidad de red compartida conectada, por ejemplo, a trav√©s de NFS (Sistema de archivos de red, sistema de archivos de red).  El origen de la tarea recibe una lista de archivos en este directorio y los pasa a la persona que llama. <br><br>  Dar√© un programa simple en NodeJS: <br><br><pre> <code class="plaintext hljs">const http = require('http'); const fs = require('fs'); const port = 8080; const path = process.env.MEDIA_PATH; const requestHandler = (request, response) =&gt; { console.log(request.url); fs.readdir(path + '/*.mp4', (err, items) =&gt; { var msg = { 'kind': 'ItemList', 'apiVersion': 'v1', 'items': [] }; if (!items) { return msg; } for (var i = 0; i &lt; items.length; i++) { msg.items.push(items[i]); } response.end(JSON.stringify(msg)); }); } const server = http.createServer(requestHandler); server.listen(port, (err) =&gt; { if (err) { return console.log('  ', err); } console.log(`    ${port}`) });</code> </pre> <br>  Esta fuente define la lista de pel√≠culas a procesar.  La utilidad ffmpeg se usa para extraer miniaturas. <br><br>  Puede crear un contenedor que ejecute el siguiente comando: <br><br><pre> <code class="plaintext hljs">ffmpeg -i ${INPUT_FILE} -frames:v 100 thumb.png</code> </pre> <br>  El comando extrae uno de cada 100 fotogramas (-frames: v 100 par√°metro) y lo guarda en formato PNG (por ejemplo, thumb1.png, thumb2.png, etc.). <br><br>  Este tipo de procesamiento se puede implementar en funci√≥n de la imagen existente de ffmpeg Docker.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen de jrottenberg / ffmpeg</a> es popular. <br><br>  Al definir un contenedor de origen simple y un ejecutor de contenedor a√∫n m√°s simple, es f√°cil ver los beneficios de un sistema gen√©rico de gesti√≥n de colas orientado a contenedores.  Reduce significativamente el tiempo entre el dise√±o y la implementaci√≥n de la cola de tareas. <br><br><h3>  Escalado din√°mico de artistas. </h3><br>  La cola de tareas considerada anteriormente es adecuada para procesar tareas a medida que est√©n disponibles, pero puede provocar una carga abrupta en los recursos del orquestador del cl√∫ster de contenedores.  Esto es bueno cuando tiene muchos tipos diferentes de tareas que crean picos de carga en diferentes momentos y, por lo tanto, distribuyen uniformemente la carga en el cl√∫ster a lo largo del tiempo. <br><br>  Pero si no tiene suficientes tipos de carga, el enfoque "luego grueso y luego vac√≠o" para escalar la cola de tareas puede requerir reservar recursos adicionales para soportar r√°fagas de carga.  El resto del tiempo, los recursos estar√°n inactivos, vaciando innecesariamente su billetera. <br><br>  Para resolver este problema, puede limitar el n√∫mero total de objetos de trabajo generados por la cola de tareas.  Esto limitar√° naturalmente el n√∫mero de trabajos procesados ‚Äã‚Äãen paralelo y, en consecuencia, reducir√° el uso de recursos durante las cargas m√°ximas.  Por otro lado, la duraci√≥n de cada tarea individual aumentar√° con una carga alta en el cl√∫ster. <br><br>  Si la carga es espasm√≥dica, esto no da miedo, porque los intervalos de tiempo de inactividad se pueden usar para completar las tareas acumuladas.  Sin embargo, si la carga constante es demasiado alta, la cola de tareas no tendr√° tiempo para procesar las tareas entrantes y se dedicar√° cada vez m√°s a su implementaci√≥n. <br><br>  En tal situaci√≥n, deber√° ajustar din√°micamente el n√∫mero m√°ximo de tareas paralelas y, en consecuencia, los recursos inform√°ticos disponibles para mantener el nivel de rendimiento requerido.  Afortunadamente, existen f√≥rmulas matem√°ticas que le permiten determinar cu√°ndo es necesario escalar la cola de tareas para procesar m√°s solicitudes. <br><br>  Considere una cola de tareas en la que una tarea nueva aparece en promedio una vez por minuto, y su finalizaci√≥n demora un promedio de 30 segundos.  Dicha cola puede hacer frente al flujo de tareas que ingresan.  Incluso si llega un gran paquete de tareas a la vez, creando un atasco de tr√°fico, el atasco se eliminar√° con el tiempo, porque antes de que llegue la siguiente tarea, la cola logra procesar un promedio de dos tareas. <br><br>  Si llega una nueva tarea cada minuto y se tarda un promedio de 1 minuto en procesar una tarea, entonces dicho sistema est√° idealmente equilibrado, pero no responde bien a los cambios en la carga.  Es capaz de hacer frente a los estallidos de carga, pero le llevar√° bastante tiempo.  El sistema no estar√° inactivo, pero no habr√° reserva de tiempo de computadora para compensar el aumento a largo plazo en la velocidad de recepci√≥n de nuevas tareas.  Para mantener la estabilidad del sistema, es necesario tener una reserva en caso de crecimiento de la carga a largo plazo o retrasos imprevistos en las tareas de procesamiento. <br><br>  Finalmente, considere un sistema en el que llega una tarea por minuto, y el procesamiento de la tarea lleva dos minutos.  Tal sistema perder√° constantemente rendimiento.  La longitud de la cola de tareas crecer√° junto con el retraso entre la recepci√≥n y el procesamiento de las tareas (y el grado de molestia de los usuarios). <br><br>  Los valores de estos dos indicadores deben ser monitoreados constantemente.  Al promediar el tiempo entre la recepci√≥n de tareas durante un largo per√≠odo de tiempo, por ejemplo, en funci√≥n del n√∫mero de tareas por d√≠a, obtenemos una estimaci√≥n del intervalo entre tareas.  Tambi√©n es necesario monitorear el tiempo promedio de procesamiento de la tarea (excluyendo el tiempo pasado en la cola).  En una cola de tareas estable, el tiempo promedio de procesamiento de tareas debe ser menor que el intervalo entre tareas.  Para garantizar que se cumpla esta condici√≥n, es necesario ajustar din√°micamente el n√∫mero de colas disponibles de recursos inform√°ticos.  Si los trabajos se procesan en paralelo, el tiempo de procesamiento debe dividirse por el n√∫mero de trabajos procesados ‚Äã‚Äãen paralelo.  Por ejemplo, si una tarea se procesa por minuto, pero cuatro tareas se procesan en paralelo, el tiempo de procesamiento efectivo de una tarea es de 15 segundos, lo que significa que el intervalo entre tareas debe ser de al menos 16 segundos. <br><br>  Este enfoque le permite crear f√°cilmente un m√≥dulo para escalar la cola de tareas hacia arriba.  Reducir es algo m√°s problem√°tico.  Sin embargo, es posible utilizar los mismos c√°lculos que antes, adem√°s de la reserva de recursos inform√°ticos determinados por la forma heur√≠stica.  Por ejemplo, puede reducir el n√∫mero de tareas paralelas hasta que el tiempo de procesamiento para una tarea sea del 90% del intervalo entre tareas. <br><br><h3>  Patr√≥n de m√∫ltiples trabajadores </h3><br>  Uno de los temas principales de este libro es el uso de contenedores para encapsular y reutilizar c√≥digo.  Tambi√©n es relevante para los patrones de colas de tareas descritos en este cap√≠tulo.  Adem√°s de los contenedores que administran la cola en s√≠, puede reutilizar grupos de contenedores que conforman la implementaci√≥n de los ejecutantes.  Suponga que necesita procesar cada tarea en una cola de tres maneras diferentes.  Por ejemplo, para detectar rostros en una fotograf√≠a, comb√≠nelos con personas espec√≠ficas y luego difumine las partes correspondientes de la imagen.  Puede poner todo el procesamiento en un contenedor de ejecuci√≥n, pero esta es una soluci√≥n √∫nica que no se puede reutilizar.  Para ocultar algo m√°s, como los autom√≥viles, en la foto, tendr√° que crear un artista contenedor desde cero. <br><br>  La posibilidad de este tipo de reutilizaci√≥n se puede lograr aplicando el patr√≥n Multi-Worker, que en realidad es un caso especial del patr√≥n Adaptador descrito al comienzo del libro.  El patr√≥n Multi-Worker convierte un conjunto de contenedores en un contenedor com√∫n con la interfaz de software del contenedor en ejecuci√≥n.  Este contenedor compartido delega el procesamiento a varios contenedores reutilizables separados.  Este proceso se muestra esquem√°ticamente en la Fig.  10.4 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/wx/zv/eiwxzvdwvre9k_ftflo2xfz_bz4.png" alt="imagen"></div><br>  Al reutilizar el c√≥digo combinando la ejecuci√≥n de contenedores, se reduce el trabajo de las personas que dise√±an sistemas de procesamiento por lotes distribuidos. <br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Para habrozhitelami 20% de descuento en el cup√≥n - <b>Sistemas distribuidos</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440444/">https://habr.com/ru/post/440444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440432/index.html">Friday SciFi sobre las profesiones del futuro: "Real Girls"</a></li>
<li><a href="../440434/index.html">Industria automotriz rusa: el camino hacia las tecnolog√≠as aditivas</a></li>
<li><a href="../440436/index.html">Tareas pr√°cticas de Java: para cursos y otras actividades</a></li>
<li><a href="../440438/index.html">MQTT / UDP pre-roll: configuraci√≥n remota y firma digital</a></li>
<li><a href="../440440/index.html">C√≥mo consegu√≠ un trabajo con un salario de $ 300,000 en Silicon Valley</a></li>
<li><a href="../440446/index.html">Serie de seminarios web de flujo de trabajo justo de TDMS</a></li>
<li><a href="../440448/index.html">Lo que termin√≥ la historia con el programador sin hogar</a></li>
<li><a href="../440450/index.html">Hay un rublo para la entrada, pero no hay salida: c√≥mo entran los archivos de terceros en la cadena de bloques y qu√© hacer al respecto</a></li>
<li><a href="../440454/index.html">Paul Graham: Lo que aprend√≠ de Hacker News</a></li>
<li><a href="../440458/index.html">Predicci√≥n del estado de la red VoIP basada en archivos de registro de texto del servidor de aplicaciones SIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>