<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 🌘 🔕 Bagaimana kriptografi kurva eliptik bekerja di TLS 1.3 ☹️ 🖖🏿 👨🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa peringatan untuk pembaca: 

 Untuk (sebanyak mungkin) menyederhanakan proses penjelasan dan menekan volume publikasi, ada baiknya untuk seger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kriptografi kurva eliptik bekerja di TLS 1.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/474832/"><img src="https://habrastorage.org/getpro/habr/post_images/692/782/b36/692782b3667ff875d91d9d47bfe5195b.png" alt="gambar"><br><br>  Beberapa peringatan untuk pembaca: <br><br>  Untuk (sebanyak mungkin) menyederhanakan proses penjelasan dan menekan volume publikasi, ada baiknya untuk segera melakukan reservasi kunci - semua yang kami tulis tentang sisi praktis masalah sudah benar untuk protokol TLS versi 1.3.  Ini berarti bahwa meskipun sertifikat ECDSA Anda akan, jika diinginkan, bekerja dengan TLS 1.2, deskripsi proses jabat tangan, suite sandi dan tolok ukur dibuat berdasarkan versi terbaru dari protokol TLS - 1.3.  Seperti yang Anda ketahui, ini tidak berlaku untuk deskripsi matematis dari algoritma yang mendasari fondasi sistem kriptografi modern. <br><br>  Bahan ini tidak ditulis oleh ahli matematika atau bahkan insinyur - meskipun mereka membantu membuka jalan melalui hutan matematika.  Terima kasih banyak kepada staf Qrator Labs. <br><br><h3>  ( <b>E</b> lliptic <b>C</b> urve) <b>D</b> iffie- <b>H</b> ellman ( <b>E</b> phemeral) </h3><br>  <b>Warisan Diffie-Hellman Abad 21</b> <br><br>  Tentu saja, topik ini tidak dimulai dengan Whitfield Diffie dan bukan dengan Martin Hellman.  Alan Turing dan Claude Shannon membuat kontribusi besar pada teori algoritma dan teori informasi, serta ke bidang cryptanalysis.  Diffie dan Hellman, pada gilirannya, secara resmi diakui oleh penulis tentang gagasan kriptografi kunci publik (juga disebut asimetris) - meskipun sekarang diketahui bahwa hasil serius di bidang ini juga telah dicapai di Inggris.  Namun, mereka tetap rahasia untuk waktu yang lama - yang membuat kedua pria tersebut disebutkan dalam pelopor terjemahan. <br><br>  Apa tepatnya? <br><a name="habracut"></a><br>  Ini mungkin tampak lucu, tetapi sampai 6 November 1976, tidak ada pengetahuan yang tersedia tentang sistem kriptografi kunci publik.  Whitfield Diffie dan Martin Hellman (dan, pada kenyataannya, Ralph Merkle) - matematikawan, insinyur komputer dan penggemar, serta ahli kriptologi adalah orang pertama yang mengusulkan konsep yang cocok. <br><br>  Selama Perang Dunia Kedua, kriptografi membantu menjaga kerahasiaan informasi, dan analisis kriptografi membantu mengungkapkannya.  Amerika Serikat dan Inggris menganggap diri mereka yang paling maju di bidang kriptografi.  Kedua negara ini memasukkan algoritma kriptografi di bagian senjata dan memveto ekspor mereka.  Pada saat yang sama, enkripsi yang tersedia dan dimaksudkan untuk penggunaan komersial atau rumah telah dilonggarkan di negara-negara ini.  Untuk alasan ini, para peneliti Inggris yang bekerja pada skema distribusi kunci asimetris di Government Communications Center (GCHQ) dan mengembangkan konsep serupa tidak diakui oleh masyarakat sampai tahun 1997, ketika pembatasan yang ada pada algoritma kriptografi dan deskripsi mereka kehilangan semua makna dan, pada umumnya, usang secara moral. <br><br>  Kembali ke pasangan penemu kami - apa yang sebenarnya dilakukan Diffie dan Hellman? <br><br>  Untuk menjelaskan ini, mari kita lihat ilustrasi dari publikasi asli, yang dengan sempurna mencerminkan lompatan raksasa dalam memahami bagaimana kriptografi dapat bekerja - bahkan jika pada awalnya hanya secara teoritis: <br><img src="https://habrastorage.org/webt/tt/rb/ig/ttrbigv4-qiw2ugkittwgox65se.png" alt="gambar"><br>  Dan sekarang untuk yang berikut: <br><img src="https://habrastorage.org/webt/3c/n5/6g/3cn56g2moitap1tsu-dpsnspfc4.png" alt="gambar"><br>  Dua gambar ini menunjukkan inovasi utama Whitfield Diffie dan Martin Hellman setelah berabad-abad pengembangan kriptografi dan kriptanalisis - pembentukan rahasia umum sebagai hasil perhitungan jenis tertentu. <br><br>  Mari kita lihat gambar lain dari Wikipedia, di mana warna yang berbeda digunakan sebagai rahasia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25b/64b/3a2/25b64b3a2bacb8f5f66524f443b789a9.png" alt="gambar"><br><br>  Dia juga menjelaskan dengan baik apa yang terjadi.  Sebelum inovasi Diffie dan Hellman, hanya ada satu kunci bersama dalam bentuk skema pembentukan kunci bersama - digunakan untuk mengenkripsi dan mendekripsi pesan.  Jika Anda ingin mentransfer kunci seperti itu ke sisi kedua, itu harus dikirim melalui saluran yang awalnya dilindungi.  Semua batasan skema semacam itu segera menjadi jelas - Anda memerlukan saluran komunikasi yang aman (dari mendengarkan), Anda tidak dapat menggunakan kunci yang sama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih dari sekali</a> , dan, idealnya, panjang kunci harus sesuai dengan panjang pesan. <br><br>  Claude Shannon, dalam karyanya yang kemudian dideklasifikasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Teori Komunikasi dalam Sistem Rahasia,"</a> membuktikan bahwa semua sandi yang tidak dapat dipecahkan secara teoritis harus memiliki sifat yang sama dengan blok sandi satu kali - yang juga dikenal sebagai sandi Vernam, dengan nama pencipta algoritma enkripsi aliran polyalphabetic tambahan ini. <br><br>  Dan lagi, mari kita lihat publikasi ilmiah asli: <br><img src="https://habrastorage.org/webt/p1/p0/yf/p1p0yfmprijaobfof3kb2lu4bpk.png" alt="gambar"><br><br>  Sebelum kita melangkah lebih jauh, mari kita bertanya pada diri sendiri pertanyaan yang jelas sederhana - bagaimana mungkin dua orang, bahkan sangat berkembang secara intelektual, menghasilkan sesuatu yang begitu terobosan dalam bidang terapan, terutama mengingat keberhasilan besar masa perang?  Kemungkinan besar karena kombinasi dari bidang-bidang berikut yang aktif berkembang saat itu: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori Informasi yang</a> Dirumuskan oleh Claude Shannon; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori algoritma</a> , yang dipengaruhi antara lain oleh Gereja Alonzo, John von Neumann dan Alan Turing; </li><li>  Dan, yang paling penting, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori komputabilitas</a> , terutama didasarkan pada karya Turing. </li></ul><br>  Kita dapat mengatakan bahwa semua area ini telah berkembang dan matang sekitar periode yang sama di abad ke-20.  Diffie dan Hellman juga menyebut Claude Shannon sebagai sosok yang lebih memengaruhi pekerjaan mereka daripada yang lain. <br><br>  Konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Keamanan Universal" oleh</a> Arjen Lenstra menunjukkan berapa banyak energi yang harus dihabiskan untuk "meretas" kriptografi simetris dengan kunci dengan panjang yang berbeda.  Ternyata untuk memecahkan kunci 228-bit ke algoritma berdasarkan pada kurva eliptik, Anda membutuhkan energi sebanyak yang cukup untuk memanaskan semua air di Bumi ke titik didih.  Namun, pernyataan ini benar hanya jika kita mempertimbangkan algoritma yang terkenal dan menggunakan peralatan modern, karena, secara ketat, algoritma atau peralatan yang lebih efisien adalah mungkin, tetapi keberadaannya belum diketahui.  Kunci 228-bit untuk algoritma EC untuk kompleksitas peretasan sebanding dengan kunci 2380-bit di RSA, tetapi lebih banyak tentang itu nanti.  Dalam perbandingan ini, kunci RSA dan EC digunakan dalam kriptosistem asimetris, mereka dapat dianggap setara dengan kunci 128-bit dalam skema simetris. <br><br>  Sangat mudah untuk membayangkan bahwa sesuatu yang “sulit untuk dihitung” akan membutuhkan banyak waktu dan energi untuk menghitung.  Kita cenderung berpikir bahwa komputer dapat "menghitung apa saja," tetapi ternyata ini jauh dari kebenaran. <br><br>  Pertama, ada contoh masalah yang tidak dapat diselesaikan, seperti masalah berhenti.  Namun, di bidang kriptografi tugas seperti itu tidak digunakan. <br><br>  Kedua, jika kita mempertimbangkan runtime yang diperlukan oleh algoritma tertentu, maka itu bisa menjadi besar secara sewenang-wenang.  Inilah yang digunakan kriptografi.  Suatu tugas dianggap “sederhana” secara komputasi jika waktu yang dibutuhkan untuk algoritma yang sesuai untuk bekerja tergantung pada ukuran data input (diukur dalam bit) sebagai polinomial: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">T</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">n</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">O</span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-11" style="vertical-align: 0.5em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.005ex" height="2.901ex" viewBox="0 -935.7 6029.8 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-54" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-28" x="704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6E" x="1094" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-29" x="1694" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-3D" x="2361" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-4F" x="3418" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-28" x="4181" y="0"></use><g transform="translate(4571,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6B" x="849" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-29" x="5640" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> T (n) = O (n ^ k) </script>  untuk beberapa positif <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6B" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> k </script>  .  Dalam teori kompleksitas komputasi, masalah seperti itu membentuk kelas kompleksitas P. Jika waktu berjalan algoritma tumbuh lebih cepat daripada polinomial, misalnya, secara eksponensial, maka tugas seperti itu dianggap komputasi "sulit". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompleksitas kelas P</a> mencakup tugas-tugas yang ada algoritma deterministik yang bekerja dalam waktu polinomial.  Kelas kompleksitas lainnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NP</a> (di mana, mungkin, "sulit" masalah ada), yang merupakan masalah solvabilitas - yaitu, masalah yang membutuhkan jawaban "ya" atau "tidak", kebenaran solusi yang dapat diperiksa - yaitu, untuk memberikan bukti kebenaran solusi - dalam waktu polinomial.  Lihat kata "bukti" di sini?  Ini adalah tempat di mana kita beralih ke fungsi satu sisi yang masalah inversinya milik NP kelas kompleksitas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a00/4bc/140/a004bc14052ddd72b5ea44ed2e9d7c37.png" alt="gambar"><br>  Diposting oleh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xkcd</a> <br><br><h3>  (Fungsi satu arah (dengan input rahasia)) </h3><br>  Menurut definisi, fungsi satu arah adalah fungsi yang mudah untuk menghitung input apa pun, tetapi sulit untuk membalikkan, yaitu, mendapatkan input asli dengan hanya hasilnya.  "Mudah" dan "keras" merujuk pada teori kompleksitas komputasi yang disebutkan di atas.  Sangat menarik bahwa keberadaan fungsi satu arah (secara matematis) belum dibuktikan, karena bukti kuat keberadaan mereka juga akan membuktikan ketidaksetaraan kelas P dan NP, salah satu masalah milenium dan masalah terbuka yang mendesak, yang solusinya menjanjikan terobosan algoritmik.  Karena itu, perlu diingat bahwa hampir semua kriptografi modern didasarkan pada hipotesis yang tidak terbukti. <br><br>  Dalam publikasi aslinya, Diffie dan Hellman memperkenalkan generasi baru fungsi satu arah, menyebut mereka "fungsi satu arah dengan input rahasia" - dalam fungsi pintu jebakan bahasa Inggris.  Bagaimana mereka berbeda dari fungsi satu arah saja? <br><br>  Mari kita lihat penjelasan aslinya: <blockquote>  Dalam cryptosystem dengan kunci publik, enkripsi dan dekripsi dilakukan oleh berbagai kunci - E dan D, masing-masing, sehingga komputasi D dari E praktis tidak mungkin (misalnya, membutuhkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-msubsup" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-18" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-19">100</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.023ex" height="2.419ex" viewBox="0 -935.7 2162.7 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-30" x="500" y="0"></use><g transform="translate(1001,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-30" x="1001" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 10 ^ {100} </script>  instruksi).  Kunci enkripsi E dapat diungkapkan kepada publik tanpa mengurangi kunci D. Ini memungkinkan pengguna sistem untuk mengirim pesan ke pengguna lain, dienkripsi sedemikian rupa sehingga hanya penerima yang diharapkan dapat mendekripsi itu.  &lt;...&gt; Tugas otentikasi, mungkin, adalah masalah telekomunikasi yang lebih serius untuk transaksi bisnis, dibandingkan dengan distribusi kunci, karena itu (otentikasi) terletak di jantung setiap sistem yang bekerja dengan kontrak dan penagihan pembayaran. </blockquote>  Biasanya, karakter kriptografi Alice dan Bob digunakan untuk menjelaskan prinsip-prinsip operasi cryptosystem (mereka berusaha untuk komunikasi yang aman).  Alice dan Bob setuju untuk memilih bilangan prima besar <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> n </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">g</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> g </script>  sedemikian rupa <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25">1</span><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">g</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.87ex" height="2.298ex" viewBox="0 -728.2 4249.6 989.6" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-31" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-3C" x="778" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-67" x="1834" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-3C" x="2592" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6E" x="3649" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> 1 <g <n </script>  .  Pilihan ini memengaruhi keamanan seluruh sirkuit.  Nomor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> n </script>  disebut modul harus sederhana;  apalagi, jumlahnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">n</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-36">1</span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mrow" id="MJXp-Span-38"><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-40">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.532ex" height="2.66ex" viewBox="0 -832 4103.9 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-6E" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-2212" x="1212" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-31" x="2212" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-29" x="2713" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-2F" x="3102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMAIN-32" x="3603" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> (n-1) / 2 </script>  seharusnya juga sederhana, tetapi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-41"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">g</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/qrator/blog/474832/&amp;usg=ALkJrhjhXFJVuAfD-bG4uPHQoa14nsu3tA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> g </script>  harus menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akar primitif</a> dalam kelompok modulo residu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-43"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> n </script>  ;  sebagai tambahan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> n </script>  harus cukup besar - setidaknya 512 bit dalam representasi biner.  Lebih lanjut, protokol Diffie-Hellman dapat dijelaskan dalam lima langkah sederhana: <br><br><ol><li>  Alice mengambil <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-47"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> x </script>  (prime besar) dan menghitung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-49"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">X</span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-52"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53" style="margin-right: 0.05em;">g</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-54" style="vertical-align: 0.5em;">x</span></span><span class="MJXp-mtext" id="MJXp-Span-55">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> X = g ^ x \ bmod n </script></li><li>  Bob mengambil <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> y </script>  (juga prima besar) dan menghitung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">Y</span><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67" style="margin-right: 0.05em;">g</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-68" style="vertical-align: 0.5em;">y</span></span><span class="MJXp-mtext" id="MJXp-Span-69">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> Y = g ^ y \ bmod n </script></li><li>  Alice mengirim <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-75"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">X</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> X </script>  Bob, Bob mengirim <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-77"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">Y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> Y </script>  Alice ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-79"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> x </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> y </script>  masing-masing tetap rahasia) </li><li>  Alice menghitung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">k</span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87" style="margin-right: 0.05em;">Y</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-88" style="vertical-align: 0.5em;">x</span></span><span class="MJXp-mtext" id="MJXp-Span-89">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> k = Y ^ x \ bmod n </script></li><li>  Bob sedang menghitung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-msup" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97" style="margin-right: 0.05em;">k</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-98" style="vertical-align: 0.5em;">′</span></span><span class="MJXp-mo" id="MJXp-Span-99" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101" style="margin-right: 0.05em;">X</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-102" style="vertical-align: 0.5em;">y</span></span><span class="MJXp-mtext" id="MJXp-Span-103">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> k '= X ^ y \ bmod n </script></li></ol><br>  Alhasil, Alice dan Bob mendapatkan hasil yang sama dalam konstruksi. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">k</span><span class="MJXp-mo" id="MJXp-Span-111" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msup" id="MJXp-Span-112"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113" style="margin-right: 0.05em;">k</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-114" style="vertical-align: 0.5em;">′</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> k = k '</script>  - rahasia bersama. <br><br>  Jadi, fungsi satu arah dengan input rahasia adalah fungsi satu arah yang dapat dibalik dengan memiliki informasi khusus yang disebut "input rahasia".  Kedengarannya sederhana, tetapi dalam praktiknya, menemukan fungsi seperti itu ternyata bukan tugas sepele - metode pertama yang layak ternyata adalah nenek moyang dari seluruh keluarga algoritma berdasarkan kunci publik yang disebut RSA dengan nama penciptanya: Ron Rivesta, Adi Shamira dan Leonard Adleman. <br><br><h3>  RSA </h3><br>  Dalam RSA, kompleksitas pembalik suatu fungsi didasarkan pada fakta bahwa faktorisasi (faktorisasi suatu angka) membutuhkan waktu lebih lama daripada perkalian atau, lebih tepatnya, dapat dikatakan bahwa tidak ada metode untuk memfaktorkan jumlah besar dalam waktu polinomial yang ditemukan pada komputer klasik, meskipun tidak Terbukti bahwa algoritma semacam itu tidak ada. <br><br>  Di RSA, seperti dalam sistem kriptografi lainnya dengan kunci publik, ada dua kunci: publik dan pribadi.  Algoritma RSA mengambil pesan input yang diwakili oleh string bit dan menerapkan operasi matematika untuknya (menaikkan ke modulo daya sejumlah besar) untuk mendapatkan hasil yang tidak dapat dibedakan dari acak.  Untuk dekripsi, hasilnya diambil dan operasi serupa dilakukan untuk menerima pesan asli.  Dalam kriptografi asimetris, enkripsi dilakukan dengan kunci publik, dan dekripsi dengan kunci pribadi. <br><br>  Bagaimana ini mungkin?  Karena kenyataan bahwa nilai-nilai yang digunakan milik kelompok siklik terbatas (himpunan bilangan bulat dengan perkalian dalam aritmatika modular).  Komputer tidak bekerja dengan sangat baik dengan jumlah besar yang sewenang-wenang, tetapi properti dari grup siklik adalah "membungkus" - angka yang lebih besar dari maksimum yang diizinkan "dibungkus" ke nilai dari set yang diizinkan.  Ini memungkinkan kita untuk menggunakan kunci dengan panjang "tidak lebih dari" sejumlah bit.  Dalam kriptografi berdasarkan kurva eliptik, kelompok siklik (multiplikatif) juga digunakan, tetapi dikonstruksi sedikit berbeda, seperti yang akan kita lihat nanti. <br><br>  Pada tingkat yang sangat primitif, semua RSA lakukan adalah mengambil dua bilangan prima besar, mengalikannya untuk mendapatkan apa yang disebut modul.  Semua angka lain yang dengannya operasi akan dilakukan harus antara nol dan nilai modul.  Modul itu sendiri akan menjadi bagian dari kunci publik - panjangnya menentukan panjang kunci.  Bagian kedua dari kunci publik adalah angka yang dipilih antara nol dan nilai fungsi Euler (implementasi RSA modern menggunakan fungsi Carmichael alih-alih Euler) dari modul, dengan beberapa batasan tambahan.  Akhirnya, Anda bisa menghitung kunci privat dengan menyelesaikan persamaan modular.  Untuk mengenkripsi pesan, kami mengambil nomor yang mewakili pesan dan hanya menaikkannya ke kekuatan yang sama dengan nilai kunci publik, dan untuk mendekripsi - untuk menerima pesan asli, naikkan ke kekuatan yang sama dengan nilai kunci pribadi.  Karena sifat siklus grup, kami mendapatkan makna yang sama. <br><br>  Saat ini, RSA memiliki dua masalah utama, salah satunya adalah konsekuensi dari yang lain.  Saat panjang kunci tumbuh, kompleksitas tidak tumbuh secepat yang kita inginkan.  Ini karena ada algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">faktorisasi</a> subeksponensial (tetapi masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">superpolinomial</a> ).  Oleh karena itu, untuk mempertahankan tingkat perlindungan yang diperlukan, panjang kunci RSA harus tumbuh agak lebih cepat daripada kunci ECC.  Untuk alasan ini, panjang kunci RSA yang paling umum saat ini cukup besar: 2048 dan 3072 bit. <br><br>  Beberapa saat kemudian kita akan melihat pada angka-angka spesifik bagaimana panjang kunci mempengaruhi kinerja akhir cryptosystem dengan membandingkan sertifikat yang ditandatangani oleh Let's Encrypt RSA dan ECDSA. <br><br><h3>  <b>E</b> lliptic <b>C</b> urve Digital <b>S</b> ignature <b>A</b> lgorithms </h3><br>  Dalam mencari fungsi yang lebih dapat diandalkan dengan input rahasia, pada pertengahan 80-an cryptographers datang untuk menggunakan cabang matematika yang dikhususkan untuk kurva elips. <br><br>  Akan terlalu sulit untuk menggambarkan semua detail kriptografi berdasarkan kurva eliptik dalam satu teks, jadi kami tidak akan melakukan ini.  Sebagai gantinya, mari kita lihat fungsi input rahasia satu arah yang dibangun berdasarkan kurva eliptik dan masalah logaritma diskrit. <br><br>  Ada sejumlah besar bahan ulasan dan pengantar yang lebih rinci untuk bidang kriptografi ini.  Kami ingin menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"ECC: pengantar lembut"</a> oleh Andrea Corbellini, terutama jika Anda tertarik pada perangkat. <br><br>  Kami, dalam materi ini, tertarik pada penjelasan yang “lebih sederhana”. <br>  Kurva elips didefinisikan oleh persamaan yang terlihat seperti ini: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-115"><span class="MJXp-msubsup" id="MJXp-Span-116"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117" style="margin-right: 0.05em;">y</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-118" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-119" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-120"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-122" style="vertical-align: 0.5em;">3</span></span><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">k</span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> y ^ 2 = x ^ 3 + kapak + b </script>  . <br><br>  Objek kedua adalah subkelompok siklik di atas bidang hingga.  Parameter berikut digunakan dalam algoritma ECC: <br><br><ul><li>  <b>Bilangan prima</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-131"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> p </script></b>   , yang menentukan dimensi bidang terakhir; </li><li>  <b>Peluang</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> a </script></b>   <b>dan</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-135"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-136">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> b </script></b>   persamaan kurva eliptik; </li><li>  <b>Titik dasar</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-137"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">G</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> G </script></b>   menghasilkan subkelompok yang telah disebutkan; </li><li>  <b>Memesan</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-139"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n </script></b>   subkelompok; </li><li>  <b>Kofaktor</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-141"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">h</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> h </script></b>   subkelompok. </li></ul><br>  Akibatnya, <b>set parameter</b> untuk algoritma kami diwakili oleh <b>enam</b> <math> </math><b><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-143"><span class="MJXp-mo" id="MJXp-Span-144" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">p</span><span class="MJXp-mo" id="MJXp-Span-146" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">a</span><span class="MJXp-mo" id="MJXp-Span-148" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149">b</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151">G</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">n</span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155">h</span><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> (p, a, b, G, n, h) </script></b>   <b>.</b> <br><br>  Poin dari kurva eliptik milik bidang terbatas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-157"><span class="MJXp-mtext" id="MJXp-Span-158">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-163">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-164">b</span><span class="MJXp-msubsup" id="MJXp-Span-165"><span class="MJXp-mrow" id="MJXp-Span-166" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167">F</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-168" style="vertical-align: -0.4em;">p</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> \ mathbb {F} _p </script>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-169"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> p </script>  ini adalah bilangan prima yang cukup besar.  Jadi, kami memiliki banyak bilangan bulat modulo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-171"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> p </script>  di mana operasi seperti penambahan, pengurangan, penggandaan, mengambil yang sebaliknya adalah mungkin.  Penambahan dan perkalian bekerja dengan cara yang mirip dengan bagaimana kami menggambarkan ini dalam hal aritmatika modular bagian RSA (membungkus). <br><br>  Karena kurva simetris pada sumbu x, untuk setiap titik <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-174">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> P </script>  kita bisa ambil <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-175"><span class="MJXp-mo" id="MJXp-Span-176" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> −P </script>  dan mendapatkan titik yang berlawanan dengannya.  Kami segera menetapkan bahwa intinya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-178"><span class="MJXp-mo" id="MJXp-Span-179" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180">O</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> −O </script>  sesuai dengan nol, yaitu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-181"><span class="MJXp-mo" id="MJXp-Span-182" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-183">O</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> −O </script>  akan sederhana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-184"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185">O</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> O </script>  . <br><br>  Penambahan titik pada suatu kurva didefinisikan sedemikian rupa sehingga, mengetahui titik-titik tersebut <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-186"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> P </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-188"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> Q </script>  , kita bisa menggambar garis melewati kedua titik ini, serta yang ketiga - <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-190"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> R </script>  jadi itu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-192"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-193">P</span><span class="MJXp-mo" id="MJXp-Span-194" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-195">Q</span><span class="MJXp-mo" id="MJXp-Span-196" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-197" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> P + Q = -R </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-199"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200">P</span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202">Q</span><span class="MJXp-mo" id="MJXp-Span-203" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-204">R</span><span class="MJXp-mo" id="MJXp-Span-205" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-206">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> P + Q + R = 0 </script>  . <br><br>  Mari kita lihat ilustrasi ilustrasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mark Hughes</a> : <br><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/96a/0ea/a89/96a0eaa89726179ae4b541f6332f9ff9.jpg" alt="gambar"><br><br>  Kami melihat garis lurus membentang di sepanjang permukaan torus.  Garis memotong dua titik yang dipilih secara acak pada kurva. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f3/ebd/39a/6f3ebd39ab0a42bdcecefa3817ca8aa6.gif" alt="gambar"><br><br>  Untuk menemukan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-207"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> R </script>  , kami menggambar garis dari titik yang dipilih pertama <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-209"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> P </script>  ke yang kedua <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-211"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> Q </script>  melanjutkan garis sampai melintasi kurva pada titik ketiga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-213"><span class="MJXp-mo" id="MJXp-Span-214" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> -R </script>  . <br><br>  Setelah persimpangan, mencerminkan titik relatif terhadap sumbu absis untuk menemukan titik <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-216"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> R </script>  . </blockquote>  Perkalian dengan skalar ditentukan dengan sangat jelas: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219">n</span><span class="MJXp-mtext" id="MJXp-Span-220">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-221">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-224">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-225">P</span><span class="MJXp-mo" id="MJXp-Span-226" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227">P</span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229">P</span><span class="MJXp-mo" id="MJXp-Span-230" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231">P</span><span class="MJXp-mo" id="MJXp-Span-232" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mtext" id="MJXp-Span-233">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-235">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-236">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-237">s</span><span class="MJXp-mo" id="MJXp-Span-238" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-239">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> n \ cdot P = P + P + P + \ dots + P </script>  . <br><br>  Fungsi satu arah dengan input rahasia dalam kasus ini bergantung pada masalah logaritma diskrit untuk kurva eliptik, dan bukan pada faktorisasi, seperti halnya dengan RSA.  Masalah logaritma diskrit dalam hal ini dirumuskan sebagai berikut: jika diketahui <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-240"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-241">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> P </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-242"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-243">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51"> Q </script>  , lalu cara mencari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-244"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-245">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52"> k </script>  sedemikian rupa <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-246"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-247">Q</span><span class="MJXp-mo" id="MJXp-Span-248" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249">k</span><span class="MJXp-mtext" id="MJXp-Span-250">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-251">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-252">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-253">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-254">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-255">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-53-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-53"> Q = k \ cdot P </script>  ? <br><br>  Baik masalah faktorisasi (RSA yang mendasari) maupun logaritma diskrit untuk kurva eliptik (yang merupakan fondasi ECDSA dan ECDH) dianggap sulit - dengan kata lain, tidak ada algoritma untuk menyelesaikan masalah ini dalam waktu polinomial untuk panjang kunci tertentu. <br><br>  Meskipun, biasanya, saya akan dibombardir dengan kain kotor (terbaik) untuk mencampur algoritma distribusi tanda tangan (ECDH) dengan tanda tangan (ECDSA), saya masih harus menjelaskan bagaimana mereka bekerja bersama.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sertifikat TLS modern berisi kunci publik, dalam kasus kami, dari pasangan yang dihasilkan menggunakan algoritma berdasarkan kurva eliptik, biasanya ditandatangani oleh beberapa organisasi yang berwenang. </font><font style="vertical-align: inherit;">Klien memverifikasi tanda tangan server dan menghasilkan rahasia bersama. </font><font style="vertical-align: inherit;">Rahasia ini digunakan dalam algoritma enkripsi simetris seperti AES atau ChaCha20. </font><font style="vertical-align: inherit;">Namun, prinsip-prinsip dasar tetap sama: menyepakati satu set (enam) parameter, dapatkan pasangan kunci, di mana kunci pribadi adalah bilangan bulat yang dipilih secara acak (faktor</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-256"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q </font></font></span><span class="MJXp-mo" id="MJXp-Span-258" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-259"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font></span><span class="MJXp-mo" id="MJXp-Span-260" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⋅ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-261"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), dan kunci publik adalah titik pada kurva. </font><font style="vertical-align: inherit;">Algoritma Tanda Tangan Gunakan Base Point</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-54-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-54">Q=k\cdot P</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-262"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-263"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan generator dari subkelompok pesanan</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-55-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-55">G</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-264"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-56-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-56">n</script>  ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-266"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah bilangan prima besar), jadi</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-57-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-57">n</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-268"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-269"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></span><span class="MJXp-mo" id="MJXp-Span-270" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⋅ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-271"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G </font></font></span><span class="MJXp-mo" id="MJXp-Span-272" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-273"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana 0 adalah elemen netral dari grup. </font><font style="vertical-align: inherit;">Tanda tangan membuktikan bahwa koneksi aman dibuat dengan pihak yang diautentikasi - server yang memiliki sertifikat TLS (kunci publik) yang ditandatangani oleh organisasi yang berwenang untuk nama server yang diberikan.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-58-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-58">n\cdot G=0</script><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (EC) DH (E) + ECDSA = Bentuk jabat tangan modern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam TLS modern versi 1.3, klien dan server menghasilkan pasangan kunci dengan cepat, membuat koneksi. Ini disebut versi "singkat" dari algoritma pertukaran kunci. Perpustakaan TLS paling populer hanya mendukung versi protokol seperti itu. Untuk sebagian besar, hari ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kurva</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eliptik Edwards </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">25519</font></a><font style="vertical-align: inherit;"> , yang diusulkan oleh Daniel Bernstein Jr (djb), yang menyediakan tingkat perlindungan 128-bit, digunakan. Sejak 2014, kurva ini telah tersedia untuk membuat pasangan kunci di pustaka openssh. Namun, pada akhir 2019, browser masih belum membuat sesi TLS dengan server menggunakan kunci publik untuk algoritma tanda tangan EdDSA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat bagaimana semuanya bekerja di TLS 1.3.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam versi terbaru dari protokol, mekanisme distribusi kunci terbatas pada (EC) DH (E) - x25519 adalah fungsi yang paling umum untuk mendapatkan kunci bersama - didukung oleh sebagian besar perpustakaan dan server perpustakaan TLS. Suite sandi hanya terdiri dari tiga entri: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384 dan TLS_CHACHA20_POLY1305_SHA256. Bagi Anda yang akrab dengan bagaimana cipher suites diberi nama dalam versi protokol sebelumnya - TLS 1.2, jelas bahwa indikasi mekanisme pertukaran kunci "terpisah" dari cipher suite selama transisi ke TLS 1.3. Juga, metode pertukaran kunci RSA dan DH statis dikeluarkan dari spesifikasi. Bahkan pemulihan sesi di TLS 1.3 dengan bantuan PSK dan tiket sesi sebelumnya berlangsung sesuai dengan protokol ECDHE, di mana E-ephemerality terakhir sangat penting.Juga, dalam TLS 1.3, tidak mungkin untuk menetapkan nilai Anda sendiri untuk mekanisme Diffie-Hellman - hanya satu set yang telah ditetapkan yang tersisa dalam spesifikasi protokol, ada konsensus mengenai keamanan set ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang menarik adalah fakta bahwa mekanisme enkripsi asimetris modern bekerja secara berbeda. Dalam ECC (khususnya, ketika menggunakan sertifikat ECDSA) kami menggunakan kunci yang relatif pendek dibandingkan dengan RSA untuk mencapai tingkat keamanan yang dapat diterima. Ini memungkinkan Anda untuk menggunakan kriptografi asimetris yang kuat dan skema pertukaran kunci bahkan pada perangkat yang, tampaknya, seharusnya tidak memiliki daya yang cukup untuk operasi yang diperlukan - misalnya, kartu pintar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, perlu untuk mengklarifikasi apa arti istilah "cryptosystem hybrid" sebagaimana berlaku untuk deskripsi TLS 1.3. Hybrid cryptosystem menggunakan skema enkripsi asimetris (dengan kunci publik) untuk membangun rahasia bersama, yang kemudian digunakan sebagai kunci dalam blok simetris atau algoritma enkripsi aliran. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, ada infrastruktur kunci publik (PKI) dan sertifikat (CA). Sangat menarik bahwa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada tahun 2004 Martin Hellman menyebutkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> salah satu dari "pahlawan tanpa tanda jasa" - Lauren Könfelder, yang tesisnya untuk mempertahankan diploma sarjana MIT adalah kemungkinan menciptakan struktur pohon - yang sekarang kita kenal sebagai PKI. Tapi mari kita kembali ke sertifikat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fakta bahwa server benar-benar memiliki kunci pribadi diverifikasi oleh tanda tangannya, yang dapat diverifikasi menggunakan kunci publik. Dan file sertifikat di server menyatakan bahwa kunci publik tertentu milik server tertentu. Ini berarti bahwa Anda membuat koneksi yang aman dengan lawan bicara yang diinginkan, dan bukan penipu - bank Anda, bukan penipuan cyber. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS 1.3 telah secara signifikan meningkatkan skema negosiasi dibandingkan dengan versi protokol sebelumnya. Sekarang server menandatangani semua informasi yang diterima di jabat tangan pada saat tanda tangan dibuat: client halo dan server sendiri halo bersama dengan set cipher yang dipilih untuk digunakan. Mari kita lihat bagian yang sesuai dari deskripsi interaksi dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 8446</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre><code class="plaintext hljs">Client Server Key ^ ClientHello Exch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*} Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data]</code> </pre> <br>  Dalam TLS 1.3, klien mengirimkan bagian kunci (beserta parameter yang diperlukan) dan daftar tanda tangan yang tersedia di pesan pertama (Klien Halo).  Kunci yang diperlukan pada tahap ini dibuat oleh klien saat itu juga - pengguna bahkan tidak menyadari hal ini.  Selanjutnya, klien dan server bertukar informasi ini untuk membuat rahasia bersama - kunci sesi yang dibuat (atau, lebih tepatnya, diturunkan) dari pasangan pra-master yang diterima setelah server merespons klien dengan pesannya (Server Hello). <br>  Di sisi "Server Halo", Anda dapat melihat catatan terkait dengan transfer sertifikat ke klien (Sertifikat *), bersama dengan cek CertificateVerify *, yang mengonfirmasi bahwa pihak tersebut benar-benar memiliki kunci pribadi terkait dengan catatan kunci publik yang sesuai, kemudian membuat pasangan kunci sesi (simetris) di kasus kesuksesan.  Dengan kata lain, pihak yang meminta data (klien) telah berhasil memverifikasi keaslian pihak yang merespons (server) dengan beralih menggunakan rahasia bersama. <br><br>  Dua operasi kriptografi utama dilindungi dalam transfer ini - membuat tanda tangan dan memverifikasi tanda tangan.  Operasi ini biasanya dilakukan di berbagai ujung koneksi, karena paling sering klien memverifikasi keaslian server.  Tanda tangan pada dasarnya adalah konfirmasi kepemilikan kunci pribadi yang sesuai dengan kunci publik.  Yaitu, bahwa kami menerima data dari penandatangan, dan memastikan bahwa pesan itu tidak berubah selama transfer. <br><br>  Saat menggunakan algoritme RSA, karena kami akan menunjukkan sedikit lebih lanjut tentang angka, operasi membuat tanda tangan adalah yang paling mahal.  Karena kami menandatangani dengan kunci 2048 atau 3072-bit, operasi semacam itu secara signifikan memuat server - jauh lebih kuat daripada klien selama verifikasi (tanda tangan). <br><br>  Dalam ECDSA, kami beroperasi dengan kunci yang relatif pendek (dalam contoh benchmark, kita akan melihat ECDSA menggunakan kurva NIST P-256 (atau secp256v1), tetapi kunci ini terlibat dalam operasi yang lebih kompleks. Akibatnya, menggunakan ECC dapat direpresentasikan sebagai RSA “terbalik” dengan sudut pandang kinerja: klien dimuat jauh lebih berat oleh operasi verifikasi penandatanganan, sementara server dengan mudah menangani operasi pembuatan tanda tangan, yang dikonfirmasi oleh pengukuran yang kami berikan di bagian benchmark. <br><br>  Efek ini membantu meningkatkan skala Internet - karena klien modern hampir sama kuatnya dengan server (jika kita hanya mempertimbangkan kecepatan clock dari inti prosesor), mereka dapat secara efektif melakukan operasi yang sulit secara komputasi tanpa masalah.  Server, pada gilirannya, dapat menggunakan daya komputasi yang dibebaskan untuk membuat lebih banyak tanda tangan dan, sebagai hasilnya, membuat lebih banyak sesi. <br><br><h3>  Tanda Tangan Sertifikat di Let's Encrypt </h3><br>  Kami akan memberikan pembaca kami dengan instruksi yang sederhana dan dapat dipahami di mana Anda dapat secara mandiri membuat server yang mampu membangun sesi TLS menggunakan pasangan kunci ECDSA di mana Let's Encrypt ditandatangani secara publik dan termasuk dalam sertifikat rantai perwalian sebagai sertifikat. <br>  Kami memutuskan untuk menunjukkan jalur lengkap dari membuat kunci, membuat permintaan penandatanganan sertifikat (CSR) untuk Let's Encrypt dan mengirimkannya untuk ditandatangani menggunakan utilitas certbot, yang mengembalikan rantai yang diperlukan dan sertifikat ECDSA itu sendiri. <br><br>  Pertama, Anda perlu membuat pasangan kunci.  Untuk ini kita akan menggunakan pustaka OpenSSL.  Panduan Pengguna OpenSSL mengatakan bahwa membuat kunci untuk algoritma berdasarkan kurva eliptik terjadi menggunakan perintah khusus yang didedikasikan untuk keluarga algoritma berdasarkan kurva eliptik. <br><br><pre> <code class="plaintext hljs">openssl ecparam -genkey -name -secp256v1 -out privatekey.pem</code> </pre> <br>  Untuk memverifikasi bahwa tim kami bekerja dengan benar, kami menjalankan perintah ec yang menunjukkan jalur ke file yang baru dibuat yang berisi kunci pribadi. <br><br><pre> <code class="plaintext hljs">openssl ec -in privatekey.pem -noout -text</code> </pre> <br>  Keluaran harus menunjukkan kepada kita kurva yang digunakan, yang dengannya kunci dihasilkan. <br><br>  Langkah selanjutnya cukup penting ketika membuat CSR - agar tidak mengisi kuesioner yang diperlukan untuk menandatangani sertifikat setiap kali, kita memerlukan file konfigurasi.  Untungnya, hampir semua pekerjaan untuk kami dilakukan oleh Mozilla, menciptakan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generator Konfigurasi SSL</a> ".  Di dalamnya, Anda dapat memilih dari berbagai opsi untuk mode server yang dengannya Anda dapat membuat koneksi TLS.  Konfigurasi OpenSSL yang bersih, untuk beberapa alasan hilang dari generator Mozilla, terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">[ req ] prompt = no encrypt_key = no default_md = sha256 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:*.example.com</code> </pre> <br>  <i>Catatan: Anda tidak harus memiliki file konfigurasi - jika tidak ada di sana, Anda akan diminta untuk mengisi semua bidang pada baris perintah.</i>  <i>Dengan file konfigurasi, jalur yang kita tentukan dalam perintah berikutnya, prosesnya disederhanakan.</i> <br><br>  Berikutnya adalah pembuatan permintaan penandatanganan sertifikat (CSR) itu sendiri.  Untuk ini, kami memiliki tim OpenSSL yang nyaman. <br><br><pre> <code class="plaintext hljs">openssl req -new -config -pathtoconfigfile.cnf -key privatekey.pem -out csr.pem</code> </pre> <br>  Kami juga dapat memverifikasi kebenaran CSR yang baru dibuat. <br><br><pre> <code class="plaintext hljs">openssl req -in csr.pem -noout -text -verify</code> </pre> <br>  Akhirnya, kami sampai pada tahap akhir - menggunakan klien ACME, certbot, kami akan mentransfer permintaan kami untuk menandatangani sertifikat organisasi Let's Encrypt. <br><br>  Certbot tidak hanya akan membantu Anda mendapatkan sertifikat, tetapi juga memiliki banyak opsi hebat lainnya.  Kami menambahkan bahwa jika Anda baru mengenal kriptografi dengan kunci publik dan tidak benar-benar memahami infrastruktur kunci publik yang ada saat ini, lebih baik menggunakan opsi <code>--dry-run</code> sebelum mencoba untuk mendapatkan sertifikat nyata untuk setiap domain Anda. <br><br><pre> <code class="plaintext hljs">certbot certonly --dry-run --dns-somednsprovider --domain “example.com” --domain “*.example.com” --csr csr.pem</code> </pre> <br>  Dalam kasus ini, klien certbot memverifikasi bahwa daftar domain wajib yang diminta pada baris perintah cocok dengan daftar dalam permintaan penandatanganan sertifikat (CSR).  Di dalam <code>--dns-somednsprovider</code> kami <code>--dns-somednsprovider</code> sedikit, karena ada banyak cara untuk mengonfirmasi Let's Encrypt bahwa Anda memiliki sebagian lalu lintas Internet.  Tetapi jika Anda menggunakan beberapa jenis penyedia cloud, seperti DigitalOcean, AWS, Azure, Hetzner, apa pun - Anda mungkin sudah memiliki cara yang lebih mudah untuk memberikan informasi yang Anda butuhkan untuk sertifikasi, karena penyedia Anda telah mengurus alat integrasi. <br><br>  Setelah itu, jika Anda yakin bahwa parameter yang diteruskan ke CSR menggunakan certbot ke Let's Encrypt sudah benar, hapus saja <code>--dry-run</code> dari perintah dan lanjutkan. <br><br>  Jika berhasil, klien akan mengembalikan Anda beberapa sertifikat: sertifikat yang ditandatangani itu sendiri, sertifikat perantara dan root, serta kombinasi yang terakhir dalam bentuk rangkaian sertifikat, semua dalam format .pem. <br><br>  OpenSSL memiliki perintah yang kami gunakan untuk melihat ke dalam sertifikat: <br><br><pre> <code class="plaintext hljs">openssl x509 -in chainfilepath.pem -noout -text</code> </pre> <br>  Seharusnya sekarang menjadi jelas bahwa Let's Encrypt menandatangani sertifikat menggunakan algoritma hash SHA256.  Selain itu, Let's Encrypt hanya berencana untuk menambahkan tanda tangan dan perantara ke ECDSA, jadi untuk saat ini tetap puas dengan tanda tangan RSA perantara.  Tapi itu tidak menakutkan, karena bagaimanapun Anda akan menggunakan kunci publik ECDSA. <br><br>  Pada akhir bagian ini, kami ingin menambahkan beberapa informasi tentang membandingkan panjang kunci berbagai algoritma.  Dalam keamanan informasi, biasanya dikatakan bahwa tingkat keamanan adalah 2 ^ x, di mana x adalah panjang bit (RSA adalah pengecualian, karena ia tumbuh agak lebih lambat daripada eksponen).  Untuk memperkirakan bagaimana kunci berbagai algoritma dibandingkan, kami merujuk ke halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki OpenSSL</a> : <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Panjang kunci simetris</b> <br></td><td>  <b>Panjang Kunci RSA</b> <br></td><td>  <b>Panjang Kurva Elliptic</b> <br></td></tr><tr><td>  80 <br></td><td>  1024 <br></td><td>  160 <br></td></tr><tr><td>  112 <br></td><td>  2048 <br></td><td>  224 <br></td></tr><tr><td>  128 <br></td><td>  3072 <br></td><td>  256 <br></td></tr><tr><td>  192 <br></td><td>  7680 <br></td><td>  384 <br></td></tr><tr><td>  256 <br></td><td>  15360 <br></td><td>  512 <br></td></tr></tbody></table></div><br>  Seperti yang Anda lihat, perbedaannya terlihat.  Meskipun untuk saat ini, Let's Encrypt memungkinkan Anda untuk menerima sertifikat yang ditandatangani hanya pada kunci dua kurva elips - 256 (secp256v1) dan 384 (secp384r1). <br><br><h3>  Kesulitan yang dikenal serta NSA </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/930/571/c14/930571c142e5a454827cca64cd0855be.png" alt="gambar"><br>  Diposting oleh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xkcd</a> <br><br>  Mungkin masalah utama dalam menggunakan kriptografi berdasarkan kurva eliptik adalah perlunya generator angka acak yang diimplementasikan dengan sangat rapi, yang diperlukan untuk membuat kunci tingkat keamanan tertentu. <br><br>  Skandal besar dikaitkan dengan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dual_EC_DRBG</a> - butuh bertahun-tahun untuk menyelesaikannya.  Ada ketidakpastian tentang basis paten di sekitar ECC - diketahui bahwa banyak paten milik Certicom, yang diakuisisi oleh Blackberry.  Ada juga beberapa kasus sertifikasi Blackberry ECC yang dikenal.  Akhirnya, ada ketidakpercayaan tertentu terhadap standar NIST, yang dapat dipengaruhi oleh NSA atau badan intelijen AS lainnya. <br><br>  Kesalahan dalam penerapan standar kriptografi adalah topik yang sepenuhnya ortogonal.  Pada tahun 2010, PlayStation 3 mengalami kebocoran kunci pribadi Sony karena implementasi algoritma ECDSA yang salah - Sony tidak dapat mengatasi RNG dan menyediakan nomor acak yang sama, yang memungkinkan untuk menyelesaikan fungsi dengan input rahasia.  OpenSSL menderita pada tahun berikutnya, namun, dengan cepat memperbaiki kerentanan yang memungkinkannya untuk mendapatkan kunci pribadi menggunakan serangan waktu - rincian lebih lanjut dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi penelitian asli</a> . <br><br>  Pada konferensi RSA pada 2013, sekelompok peneliti mempresentasikan makalah penelitian berjudul " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gagal Secara Acak!</a>  ”Didedikasikan untuk kerentanan kelas Java SecureRandom.  Enam bulan kemudian, segalanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimulai</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dompet Bitcoin yang</a> dibuat menggunakan generator nomor acak semu yang tidak aman secara kriptografis. <br><br>  Karena kenyataan bahwa beberapa kerentanan serius ditemukan dalam waktu singkat, pada Agustus 2013 yang sama, IETF merilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 6979</a> , yang menggambarkan generasi deterministik k ketika membuat kunci.  Kami dapat menulis bahwa masalahnya diselesaikan dengan cara ini, tetapi kami tidak akan - setiap saat, peneliti dapat menemukan kesalahan baru dalam implementasi karena penyimpangan yang tidak perlu dari spesifikasi protokol. <br><br>  Dan beberapa kata tentang NSA.  Jika Anda belum mengetahui riwayat Dual_EC_DRBG - luangkan waktu dan membaca materi yang relevan, Anda tidak akan menyesal bahwa Anda telah mengetahui detailnya.  Edward Snowden menjadi bagian dari cerita ini, karena itu karena kebocorannya pada tahun 2013 semua keraguan yang ada dikonfirmasi.  Ini menghasilkan fakta bahwa banyak cryptographers terkemuka kehilangan kepercayaan pada NIST, karena organisasi inilah yang menciptakan dan mendeskripsikan banyak kurva eliptik dan algoritma yang bekerja di ECDSA. <br><br>  Kurva 25519 yang ditulis oleh Daniel Burnshite dan fungsi Diffie-Hellman untuk distribusi kunci adalah jawaban untuk banyak pertanyaan di atas.  Dan, seperti yang sudah kami tulis, ada gerakan stabil menuju EdDSA.  Dalam kasus kurva NIST, belum ada konfirmasi kerentanan mereka telah ditemukan, dan untuk pengalaman dengan angka acak, itu agak menyakitkan dan berkontribusi pada asimilasi cepat. <br><br>  Untuk mengakhiri bagian ini, kami ingin mengutip John von Neumann: "Siapa pun yang memiliki kelemahan untuk metode aritmatika untuk mendapatkan angka acak tidak berdosa tanpa keraguan." <br><br><h3>  Beberapa tolok ukur </h3><br>  Kami menggunakan server NGINX 1.16.0 dengan pustaka OpenSSL versi 1.1.1d untuk melakukan pengujian dengan dua sertifikat.  Seperti yang disebutkan sebelumnya, pada saat ini, Let's Encrypt memungkinkan Anda untuk hanya menggunakan algoritma prime256v1 dan secp384r1 untuk membuat permintaan penandatanganan sertifikat, serta tidak memberikan sertifikat EPCSA root dan perantara dengan tanda tangan, mungkin berurusan dengan fitur ini saat Anda membaca catatan ini. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis tanda tangan</b> </td><td>  <b>Jabat tangan per detik</b> </td></tr><tr><td>  <b>ECDSA (prime256v1 / nistp256)</b> </td><td>  3358.6 </td></tr><tr><td>  <b>RSA 2048</b> </td><td>  972.5 </td></tr></tbody></table></div><br>  Seperti yang Anda lihat, pada satu inti CPU Intel® Xeon® Silver 4114 @ 2.20GHz (dirilis pada kuartal ketiga 17), perbedaan total antara kinerja ECDSA dan RSA yang diterima secara umum dengan panjang kunci 2048 bit adalah 3,5 kali. <br><br>  Mari kita lihat hasil menjalankan perintah openssl -speed untuk ECDSA dan RSA pada prosesor yang sama. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis tanda tangan</b> <br></td><td>  <b>tanda</b> <br></td><td>  <b>verifikasi</b> <br></td><td>  <b>tanda / dtk</b> <br></td><td>  <b>verifikasi / dtk</b> <br></td></tr><tr><td>  <b>RSA 2048 bit</b> <br></td><td>  717 μs <br></td><td>  20,2 μs <br></td><td>  1393.9 <br></td><td>  49458.2 <br></td></tr><tr><td>  <b>256 bit ECDSA (nistp256)</b> <br></td><td>  25,7 μs <br></td><td>  81,8 μs <br></td><td>  38971.6 <br></td><td>  12227.1 <br></td></tr></tbody></table></div><br>  Di sini kita dapat menemukan konfirmasi dari tesis yang ditulis sebelumnya tentang bagaimana operasi komputasi dari tanda tangan dan verifikasi berbeda antara ECC dan RSA.  Saat ini, dipersenjatai dengan TLS 1.3, kriptografi berdasarkan kurva eliptik memberikan peningkatan yang signifikan dalam kinerja server dengan tingkat perlindungan yang lebih tinggi dibandingkan dengan RSA.  Ini adalah alasan utama mengapa kami di Qrator Labs merekomendasikan dan sangat mendorong pelanggan yang siap untuk menggunakan sertifikat ECDSA juga.  Pada CPU modern, peningkatan kinerja yang mendukung ECDSA adalah 5x. <br><br>  Jika Anda tertarik pada bagaimana prosesor (rumah atau server) Anda menangani komputasi kriptografi, jalankan perintah kecepatan openssl.  Opsi <code>-rsa</code> , <code>-ecdsa</code> dan <code>-eddsa</code> memungkinkan Anda menentukan algoritme yang menarik untuk pembandingan. <br><br><h3>  Masa depan (dalam superposisi) </h3><br>  Ironisnya, dalam proses penulisan materi ini, Google mengumumkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"mencapai keunggulan kuantum</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Apakah ini berarti bahwa kita sudah dalam bahaya dan semua kemajuan yang dibuat untuk saat ini tidak lagi dapat memastikan kerahasiaan? <br><br>  Tidak. <br><br>  Seperti Bruce Schneier menulis dalam esai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Kriptografi setelah Pendaratan Asing"</a> untuk IEEE Security and Privacy Circular, komputer kuantum dapat benar-benar memberikan pukulan serius hanya pada kriptografi asimetris dengan kunci publik.  Algoritma simetris akan tetap bertahan. <br><br>  Namun untuk melanjutkan, kami akan memberikan kesempatan kepada Tn. Schneier sendiri: <blockquote>  Ada skenario masa depan lain yang tidak memerlukan komputer kuantum.  Sementara kami sekarang memiliki beberapa teori matematika yang mendasari keberpihakan yang digunakan dalam kriptografi, bukti validitas teori-teori ini sebenarnya adalah salah satu masalah terbuka terbesar dalam ilmu komputer.  Sama seperti kriptografer pintar dapat menemukan trik baru yang memfasilitasi peretasan algoritma tertentu, kita dapat membayangkan alien dengan teori matematika yang cukup untuk memecahkan semua algoritma enkripsi.  Hari ini rasanya konyol.  Kriptografi kunci publik adalah sejumlah teori dan berpotensi rentan terhadap alien yang berpikiran matematika.  Kriptografi simetris begitu non-linier, begitu sederhana untuk dibuat dan rumit, dan juga betapa mudahnya untuk memperpanjang kunci, masa depan yang tak terbayangkan.  Contohnya adalah varian AES dengan ukuran blok dan kunci 512-bit, serta 128 putaran.  Jika matematika secara fundamental tidak berbeda dari pemahaman kita saat ini, maka algoritma seperti itu akan aman sampai komputer terbuat dari sesuatu selain materi dan menempati sesuatu selain ruang. <br><br>  Tetapi jika hal yang tidak dapat dibayangkan terjadi, itu akan meninggalkan kita hanya dengan kriptografi yang hanya didasarkan pada teori informasi: cipher-notes sekali pakai dan variannya. </blockquote><br>  Bruce Schneier dengan sempurna menggambarkan area di mana, selain kesalahan implementasi, kerentanan utama kriptografi modern dapat ditemukan.  Jika di suatu tempat ada sekelompok ahli matematika, cryptanalysts dan cryptographers, bersama dengan insinyur komputer bekerja pada bukti atau sanggahan dari beberapa masalah matematika yang sangat kompleks (seperti P? = NP), yang telah berhasil mencapai beberapa kemajuan dalam kegiatan ini saat ini - posisi kita rentan.  Dengan menolak teori konspirasi, dapat dikatakan bahwa kemajuan semacam itu dalam bidang ilmu komputer, teori informasi, dan teori komputabilitas sulit disembunyikan.  Peristiwa semacam itu akan memasukkan nama-nama pencipta mereka sendiri di halaman Sejarah dan, khususnya, dalam buku-buku Sejarah Internet, yang sangat berharga bagi individu atau kelompok yang sangat cerdas.  Jadi skenario yang sama dapat dibuang sebagai tidak mungkin. <br><br>  Juga tidak jelas apakah keberhasilan dalam komputasi kuantum akan dibuat dalam 5 tahun ke depan - dan sudah ada primitif kriptografi yang cocok untuk digunakan di dunia pasca-kuantum: kisi-kisi, menggunakan isogenisasi supersingular dari kurva eliptik, fungsi hash, kode koreksi kesalahan.  Sekarang, pakar keamanan hanya bereksperimen dengan mereka, tetapi tidak ada keraguan bahwa, jika perlu, umat manusia akan menemukan cara untuk dengan cepat menggunakan algoritma baru pada skala apa pun. <br><br>  Tetap hanya menambahkan bahwa untuk dekade berikutnya, kriptografi berdasarkan kurva elips tampaknya cocok untuk tujuan dan kebutuhan yang sebagian besar penggunanya tetapkan untuk diri mereka sendiri, memberikan keamanan dan kinerja tinggi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474832/">https://habr.com/ru/post/id474832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474816/index.html">Proyek kesayangan - kehidupan kecil</a></li>
<li><a href="../id474818/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474822/index.html">WISE-PaaS - platform cloud untuk berbagai hal industri Internet</a></li>
<li><a href="../id474826/index.html">Tabel normal dalam penurunan harga</a></li>
<li><a href="../id474830/index.html">Pemrograman Berorientasi Protokol, Bagian 3</a></li>
<li><a href="../id474838/index.html">SIBUR Challenge 2019 - Kompetisi Analisis Data Industri</a></li>
<li><a href="../id474840/index.html">Apa yang mereka pelajari dalam kekhususan Ilmu Data di universitas asing</a></li>
<li><a href="../id474842/index.html">Kasus: Layanan mobil. Pengembangan kampanye iklan dan implementasi Bitrix24</a></li>
<li><a href="../id474844/index.html">Dell XPS 13 7390: laptop yang sangat ringkas bagi mereka yang sering bekerja di luar kantor</a></li>
<li><a href="../id474846/index.html">Program membersihkan sungai di dunia dari sampah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>