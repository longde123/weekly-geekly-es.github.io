<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ü™Ô∏è üíá üë®‚Äçüë¶ ASP.NET Core v√°lido üë®‚Äçüè≠ üë®üèΩ‚Äçüåæ üë®üèæ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Especialmente para los amantes de los libros de la serie "C ++ en 24 horas", decid√≠ escribir un art√≠culo sobre ASP.NET Core. 


 Si no se ha desarroll...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ASP.NET Core v√°lido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="ASP.NET Core v√°lido"></a> </p><br><p>  Especialmente para los amantes de los libros de la serie "C ++ en 24 horas", decid√≠ escribir un art√≠culo sobre ASP.NET Core. </p><br><p>  Si no se ha desarrollado en .NET o en una plataforma similar antes, entonces no tiene sentido ir por debajo del corte por usted.  Pero si est√° interesado en aprender qu√© IoC, DI, DIP, Interseptors, Middleware, Filters (es decir, todo lo que difiere de Core de .NET cl√°sico), entonces definitivamente debe hacer clic en "Leer m√°s", a medida que desarrolla Sin entender todo esto, claramente no es correcto. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  Si un teatro comienza con una percha, entonces ASP.NET Core comienza con una inyecci√≥n de dependencia.  Para tratar con DI, debe comprender qu√© es IoC. </p><br><p>  Hablando de IoC, a menudo se recuerda el principio de Hollywood de "No nos llames, te llamaremos".  Lo que significa "No es necesario que nos llame, lo llamaremos nosotros mismos". </p><br><p> Diferentes fuentes dan diferentes patrones a los que se puede aplicar IoC.  Y lo m√°s probable es que est√©n bien y se complementen entre s√≠.  Estos son algunos de estos patrones: f√°brica, localizador de servicios, m√©todo de plantilla, observador, estrategia. </p><br><p>  Veamos IoC usando una aplicaci√≥n de consola simple como ejemplo. </p><br><p>  Supongamos que tenemos dos clases simples que implementan una interfaz con un m√©todo: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Ambos dependen de la abstracci√≥n (en este caso, la interfaz act√∫a como una abstracci√≥n). </p><br><p>  Y digamos que tenemos un objeto de nivel superior usando estas clases: </p><br><pre> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Dependiendo del par√°metro constructor, la variable _instance es inicializada por una clase espec√≠fica.  Bueno y m√°s, al llamar a Write, se completar√° la salida a la consola o a Debug.  Todo parece ser bastante bueno e incluso, parece, corresponde a la primera parte del principio de Inversi√≥n de dependencia </p><br><blockquote>  Los objetos de nivel superior son independientes de los objetos de nivel inferior.  Tanto esos como los que dependen de abstracciones. </blockquote><p>  En nuestro caso, ILayer act√∫a como una abstracci√≥n. </p><br><p>  Pero tambi√©n debemos tener un objeto de un nivel a√∫n m√°s alto.  Uno que usa la clase Logging </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Al inicializar Logging con 1, obtenemos en la clase Logging una instancia de la clase que genera datos en la consola.  Si inicializamos el registro con cualquier otro n√∫mero, entonces log.Write enviar√° datos a Debug.  Parece que todo funciona, pero funciona mal.  Nuestro objeto de nivel superior Main depende de los detalles del c√≥digo del objeto de nivel inferior: la clase Logging.  Si cambiamos algo en esta clase, tendremos que cambiar el c√≥digo de la clase Main.  Para evitar que esto suceda, haremos una inversi√≥n de control: Inversi√≥n de control.  Hagamos que la clase Main controle lo que sucede en la clase Logging.  La clase Logging recibir√°, como par√°metro de constructor, una instancia de una clase que implementa la interfaz ILayer </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Y ahora, nuestra clase principal se ver√° as√≠: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  De hecho, decoramos nuestro objeto Logging con el objeto necesario para nosotros. </p><br><p>  Ahora nuestra aplicaci√≥n cumple con la segunda parte del principio de Inversi√≥n de dependencia: </p><br><blockquote>  Las abstracciones son independientes de los detalles.  Los detalles dependen de las abstracciones.  Es decir  no conocemos los detalles de lo que est√° sucediendo en la clase Logging, simplemente pasamos la clase all√≠ que implementa la abstracci√≥n necesaria. </blockquote><p>  Existe el t√©rmino acoplamiento herm√©tico - conexi√≥n herm√©tica.  Cuanto m√°s d√©bil sea la conexi√≥n entre los componentes de la aplicaci√≥n, mejor.  Me gustar√≠a se√±alar que este ejemplo de una aplicaci√≥n simple no alcanza el ideal un poco.  Por qu√©  S√≠, porque en la clase de nivel m√°s alto en Main, usamos dos veces la creaci√≥n de instancias de clase usando new.  Y existe una frase tan mnemot√©cnica "Lo nuevo es una pista", lo que significa que cuanto menos use nuevos, menos conexiones de componentes en la aplicaci√≥n y mejor.  Idealmente, no deber√≠amos usar el nuevo DebugLayer, sino que deber√≠amos obtener DebugLayer de alguna otra manera.  Cual?  Por ejemplo, desde un contenedor de IoC o usando la reflexi√≥n de un par√°metro pasado a Main. </p><br><p>  Ahora hemos descubierto qu√© es la Inversi√≥n de control (IoC) y qu√© es la Inversi√≥n de dependencia (DIP).  Queda por entender qu√© es la inyecci√≥n de dependencia (DI).  IoC es un paradigma de dise√±o.  La inyecci√≥n de dependencia es un patr√≥n.  Esto es lo que tenemos ahora en el constructor de la clase Logging.  Obtenemos una instancia de una dependencia espec√≠fica.  La clase Logging depende de una instancia de una clase que implementa ILayer.  Y esta instancia se inyecta a trav√©s del constructor. </p><br><h2 id="ioc-container">  Contenedor de IoC </h2><br><p>  Un contenedor de IoC es un objeto que contiene muchas dependencias espec√≠ficas (dependencia).  De lo contrario, la dependencia se puede llamar un servicio; por lo general, es una clase con una cierta funcionalidad.  Si es necesario, la dependencia del tipo requerido se puede obtener del contenedor.  Inyectar dependencia en un contenedor es Inject.  Extracto - Resolver.  Aqu√≠ hay un ejemplo del contenedor de IoC auto-escrito m√°s simple: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Solo una docena de l√≠neas de c√≥digo, pero ya puede usarlo (no para producci√≥n, por supuesto, sino con fines educativos). </p><br><p>  Puede registrar la dependencia (por ejemplo, ConsoleLayer o DebugLayer que utilizamos en el ejemplo anterior) de esta manera: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  Y extr√°igalo del contenedor en el lugar necesario del programa as√≠: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  En contenedores reales, tambi√©n se implementa Dispose (), que le permite destruir recursos que se han vuelto innecesarios. </p><br><p>  Por cierto, el nombre de contenedor IoC no transmite exactamente el significado, ya que el t√©rmino IoC es mucho m√°s amplio en su aplicaci√≥n.  Por lo tanto, recientemente el t√©rmino contenedor DI se ha utilizado cada vez con m√°s frecuencia (ya que la inyecci√≥n de dependencia todav√≠a se aplica). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Duraci√≥n de servicio + varios m√©todos de extensi√≥n en Root de composici√≥n </h2><br><p>  Las aplicaciones ASP.NET Core contienen el archivo Startup.cs, que es el punto de partida de la aplicaci√≥n para configurar DI.  Configura DI en el m√©todo ConfigureServices. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  Este c√≥digo agregar√° la clase SomeRepository al contenedor DI, que implementa la interfaz ISomeRepository.  El hecho de que el servicio se agregue al contenedor mediante AddScoped significa que se crear√° una instancia de la clase cada vez que se solicite una p√°gina. <br>  Puede agregar un servicio a un contenedor sin especificar una interfaz. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  Pero este m√©todo no se recomienda, ya que su aplicaci√≥n pierde su flexibilidad y aparecen conexiones cercanas.  Se recomienda que siempre especifique una interfaz, porque en este caso, en cualquier momento, puede reemplazar una implementaci√≥n de la interfaz por otra.  Y si las implementaciones son compatibles con el principio de sustituci√≥n de Liskov, al cambiar el nombre de la clase de implementaci√≥n con un "movimiento de mu√±eca", cambiar√° la funcionalidad de toda la aplicaci√≥n. </p><br><p>  Hay 2 opciones m√°s para agregar un servicio: AddSingleton y AddTransient. <br>  Cuando se usa AddSingleton, el servicio se crea una vez, y cuando se usa la aplicaci√≥n, la llamada va a la misma instancia.  Utilice este m√©todo con especial cuidado, ya que son posibles p√©rdidas de memoria y problemas de subprocesos m√∫ltiples. </p><br><p>  AddSingleton tiene una peque√±a caracter√≠stica.  Se puede inicializar ya sea en el primer acceso a √©l </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  ya sea inmediatamente cuando se agrega al constructor </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  De la segunda manera, incluso puede agregar un par√°metro al constructor. <br>  Si desea agregar un par√°metro al constructor de un servicio agregado no solo usando AddSingleton, sino tambi√©n usando AddTransient / AddScoped, entonces puede usar la expresi√≥n lambda: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  Y finalmente, cuando se usa AddTransient, se crea un servicio cada vez que accede a √©l.  Ideal para servicios livianos que no consumen memoria y recursos. </p><br><p>  Si con AddSingleton y AddScoped todo deber√≠a ser m√°s o menos claro, entonces AddTransient necesita aclaraci√≥n.  La documentaci√≥n oficial da un ejemplo en el que un determinado servicio se agrega al contenedor DI tanto como un par√°metro del constructor de otro servicio como de forma independiente.  Y en el caso de que se agregue por separado usando AddTransient, crea su instancia 2 veces.  Dar√© un ejemplo muy, muy simplificado.  En la vida real, no se recomienda su uso, porque  Las clases para simplificar no heredan las interfaces.  Digamos que tenemos una clase simple: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  Y hay una segunda clase que contiene la primera como un servicio dependiente y recibe esta dependencia como un par√°metro constructor: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Ahora inyectamos dos servicios: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  Y en alg√∫n controlador en Acci√≥n, agregue el recibo de nuestras dependencias y muestre los valores en la ventana Depuraci√≥n. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  Entonces, como resultado, obtenemos 2 valores Guid diferentes.  Pero si reemplazamos AddTransient con AddScoped, entonces como resultado obtenemos 2 valores id√©nticos. </p><br><p>  El contenedor IoC de la aplicaci√≥n ASP.NET Core contiene algunos servicios de manera predeterminada.  Por ejemplo, IConfiguration es un servicio con el que puede obtener la configuraci√≥n de la aplicaci√≥n de los archivos appsettings.json y appsettings.Development.json.  IHostingEnvironment e ILoggerFactory con el que puede obtener la configuraci√≥n actual y una clase auxiliar que permite el registro. </p><br><p>  Las clases se recuperan del contenedor utilizando la siguiente construcci√≥n t√≠pica (el ejemplo m√°s com√∫n): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  Se crea una variable con modificadores privados de acceso de solo lectura en el √°mbito del controlador.  La dependencia se obtiene del contenedor en el constructor de la clase y se asigna a una variable privada.  Adem√°s, esta variable se puede usar en cualquier m√©todo o controlador de acci√≥n. <br>  A veces no desea crear una variable para usarla en una sola Acci√≥n.  Entonces puede usar el atributo [FromServices].  Un ejemplo: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = ¬´  " + dateTime.Now; return View(); }</code> </pre> <br><p>  Parece extra√±o, pero para no llamar al m√©todo de la clase est√°tica DateTime.Now () en el c√≥digo, a veces se hace para que el valor de tiempo se obtenga del servicio como par√°metro.  Por lo tanto, es posible pasar cualquier momento como par√°metro, lo que significa que es m√°s f√°cil escribir pruebas y, por regla general, se hace m√°s f√°cil realizar cambios en la aplicaci√≥n. <br>  Esto no quiere decir que la est√°tica sea malvada.  Los m√©todos est√°ticos son m√°s r√°pidos.  Y lo m√°s probable es que la est√°tica se pueda usar en alg√∫n lugar del contenedor IoC.  Pero si guardamos nuestra aplicaci√≥n de todo lo est√°tico y nuevo, obtendremos m√°s flexibilidad. </p><br><h2 id="storonnie-di-konteynery">  Contenedores DI de terceros </h2><br><p>  Lo que observamos y lo que el contenedor ASP.NET Core DI realmente implementa por defecto es la inyecci√≥n del constructor.  Todav√≠a existe la oportunidad de inyectar dependencia en la propiedad utilizando la llamada inyecci√≥n de propiedad, pero esta caracter√≠stica no est√° disponible en el contenedor integrado en ASP.NET Core.  Por ejemplo, podemos tener alguna clase que implemente como una dependencia, y esta clase tiene alg√∫n tipo de propiedad p√∫blica.  Ahora imagine que durante o despu√©s de inyectar la dependencia, necesitamos establecer el valor de la propiedad.  Volvamos a un ejemplo similar al ejemplo que examinamos recientemente. <br>  Si tenemos tal clase: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  que podemos introducir como adicci√≥n </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  luego, utilizando el contenedor est√°ndar, no podemos establecer el valor de la propiedad. <br>  Si desea aprovechar esta oportunidad para establecer un valor para la propiedad OperationId, puede usar alg√∫n tipo de contenedor DI de terceros que admita la inyecci√≥n de propiedades.  Por cierto, la inyecci√≥n de propiedades no se recomienda particularmente.  Sin embargo, todav√≠a hay Inyecci√≥n de m√©todo e Inyecci√≥n de m√©todo Setter, que pueden ser √∫tiles para usted y que tampoco son compatibles con el contenedor est√°ndar. </p><br><p>  Los contenedores de terceros pueden tener otras caracter√≠sticas muy √∫tiles.  Por ejemplo, al usar un contenedor de terceros, solo puede agregar dependencia a los controladores que tienen una palabra espec√≠fica en el nombre.  Y muy a menudo se utilizan cajas - contenedores DI, optimizados para el rendimiento. <br>  Aqu√≠ hay una lista de algunos contenedores DI de terceros compatibles con ASP.NET Core: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Si bien utiliza un contenedor DI est√°ndar, no puede usar la inyecci√≥n de propiedades / m√©todos, pero puede implementar un servicio dependiente como par√°metro de constructor implementando el patr√≥n Factory de la siguiente manera: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  En este caso, GetService devolver√° nulo si no se encuentra el servicio dependiente.  Existe una variaci√≥n de GetRequiredService que generar√° una excepci√≥n si no se encuentra el servicio dependiente. <br>  El proceso de obtener un servicio dependiente utilizando GetService en realidad aplica el patr√≥n de localizaci√≥n del Servicio. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Echemos un vistazo a Autofac con un ejemplo pr√°ctico.  Convenientemente, los servicios del contenedor se pueden registrar y recibir, tanto de forma predeterminada como con Autofac. </p><br><p>  Instale el paquete NuGet Autofac.Extensions.DependencyInjection. <br>  Cambie el valor devuelto por el m√©todo ConfigureServices de nulo a IServiceProvider.  Y agregar propiedad </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  Despu√©s de eso, ser√° posible agregar c√≥digo como el siguiente al final del m√©todo ConfigureServices de la clase Startup (esta es solo una de las opciones para registrar servicios): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Aqu√≠ constructor. Poblaci√≥n (servicios);  Agrega servicios de IServiceCollection al contenedor.  Bueno y m√°s, ya es posible registrar servicios con builder.RegisterType.  Oh si  Casi lo olvido.  Debe cambiar de nulo a IServiceProvider el valor de retorno del m√©todo ConfigureServices. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP con ASP.NET Core: intersectores de Autofac </h2><br><p>  Hablando de programaci√≥n orientada a aspectos, mencionan otro t√©rmino: preocupaciones transversales.  La preocupaci√≥n es alguna informaci√≥n que afecta el c√≥digo.  En la versi√≥n rusa usan la palabra responsabilidad.  Bueno, las preocupaciones transversales son responsabilidades que afectan otras responsabilidades.  Pero idealmente, no deber√≠an influenciarse entre s√≠, ¬øverdad?  Cuando se influyen entre s√≠, se hace m√°s dif√≠cil cambiar el programa.  Es m√°s conveniente cuando tenemos todas las operaciones por separado.  El registro, las transacciones, el almacenamiento en cach√© y mucho m√°s se pueden hacer usando AOP sin cambiar el c√≥digo de las clases y los m√©todos mismos. </p><br><p>  En el mundo .NET, a menudo se usa un m√©todo cuando el c√≥digo AOP se incrusta usando un postprocesador en un c√≥digo de aplicaci√≥n ya compilado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostSharp</a> ) o, alternativamente, puede usar interceptores, estos son ganchos de eventos que se pueden agregar al c√≥digo de la aplicaci√≥n.  Estos interceptores, como regla, usan el decorador que ya hemos examinado para su trabajo. </p><br><p>  Creemos su propio interceptor.  El ejemplo m√°s simple y t√≠pico que es m√°s f√°cil de reproducir es el registro. <br>  Adem√°s del paquete Autofac.Extensions.DependencyInjection, tambi√©n instalaremos el paquete Autofac.Extras.DynamicProxy <br>  Instalado?  Agregue una clase de registro simple que se llamar√° al acceder a ciertos servicios. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Agregue a nuestro registro Autofac registro del interceptor: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  Y ahora, con cada llamada a la clase, se llamar√° al m√©todo Intercept de la clase Logger. <br>  Por lo tanto, podemos simplificar nuestra vida y no escribir una entrada de registro al comienzo de cada m√©todo.  Lo tendremos autom√°ticamente.  Y si lo desea, nos ser√° f√°cil cambiarlo o deshabilitarlo para toda la aplicaci√≥n. </p><br><p>  Tambi√©n podemos eliminar .InterceptedBy (typeof (Logger));  y agregue la interceptaci√≥n de llamadas solo para servicios de aplicaciones espec√≠ficos que utilizan el atributo [Intercepci√≥n (typeof (Logger))]; debe especificarlo antes del encabezado de la clase. </p><br><h2 id="middleware">  Middleware </h2><br><p>  ASP.NET tiene una cadena espec√≠fica de llamadas de c√≥digo que se produce en cada solicitud.  Incluso antes de que se cargue la UI / MVC, se realizan ciertas acciones. </p><br><p>  Es decir, por ejemplo, si agregamos al principio del m√©todo Configure de la clase Startup.cs el c√≥digo </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  entonces podemos ver en la consola de depuraci√≥n qu√© archivos solicita nuestra aplicaci√≥n.  De hecho, obtenemos las capacidades de AOP "fuera de la caja" <br>  Un poco in√∫til, pero claro e informativo ejemplo del uso de middleware, te mostrar√© ahora: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  Con cada solicitud, comienza una cadena de llamadas.  Desde cada aplicaci√≥n, use, despu√©s de llamar a next.invoke (), se realiza la transici√≥n a la siguiente llamada.  Y todo termina despu√©s de que la aplicaci√≥n funciona. <br>  Puede ejecutar alg√∫n c√≥digo solo cuando acceda a una ruta espec√≠fica. <br>  Puedes hacer esto usando app.Map: </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Ahora, si solo va a la p√°gina del sitio, puede ver el texto "¬°Hola!", Y si agrega / Adi√≥s a la barra de direcciones, ver√° Adi√≥s. </p><br><p>  Adem√°s de Use and Map, puede usar UseWhen o MapWhen para agregar c√≥digo a la cadena de middleware solo bajo ciertas condiciones espec√≠ficas. </p><br><p>  Hasta ahora ha habido ejemplos in√∫tiles, ¬øverdad?  Aqu√≠ hay un ejemplo normal: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Aqu√≠ agregamos encabezados a cada solicitud para ayudar a proteger la p√°gina de los ataques de hackers. </p><br><p>  O aqu√≠ hay un ejemplo de localizaci√≥n: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Ahora, si agrega el par√°metro? Culture = fr a la direcci√≥n de la p√°gina, puede cambiar el idioma de la aplicaci√≥n al franc√©s (si se agrega la localizaci√≥n a su aplicaci√≥n, entonces todo funcionar√°) </p><br><h2 id="filters">  Filtros </h2><br><p>  Si la cadena de middleware se refiere a procesos anteriores a MVC, los filtros funcionan junto con MVC. <br>  El siguiente diagrama esquem√°tico muestra c√≥mo funcionan los filtros. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filtros"></p><br><p>  Primero, se resuelven los filtros de autorizaci√≥n.  Es decir  puede crear alg√∫n tipo de filtro o varios filtros e ingresar en ellos alg√∫n tipo de c√≥digo de autorizaci√≥n que funcionar√° con las solicitudes. </p><br><p>  Luego cumplen con los filtros de recursos.  Con estos filtros, puede, por ejemplo, devolver cierta informaci√≥n del cach√©. </p><br><p>  Luego se produce el enlace de datos y se ejecutan los filtros de acci√≥n.  Con su ayuda, puede manipular los par√°metros pasados ‚Äã‚Äãa Acci√≥n y el resultado devuelto. </p><br><p>  Los filtros de excepci√≥n como las sugerencias de nombre le permiten agregar alg√∫n tipo de manejo general de errores para la aplicaci√≥n.  Deber√≠a ser bastante conveniente manejar los errores en todas partes de la misma manera.  Una especie de AOP-shny plus. </p><br><p>  Los filtros de resultados le permiten realizar alguna acci√≥n antes de ejecutar el controlador de Acci√≥n o despu√©s.  Son bastante similares a los filtros de acci√≥n, pero se ejecutan solo si no hay errores.  Adecuado para la l√≥gica vinculada a la vista. </p><br><p>       .            : </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p>     DI  (   Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p>      -    Action    </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p>   ‚Äì    middleware    - action   .              Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p>      Action-     </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437002/">https://habr.com/ru/post/437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../436992/index.html">Prueba y error al elegir HTTP Reverse Proxy</a></li>
<li><a href="../436994/index.html">Liquibase y Maven</a></li>
<li><a href="../436996/index.html">Curso final de especializaci√≥n en Python del grupo Mail.ru</a></li>
<li><a href="../436998/index.html">Protecci√≥n de microchips contra ingenier√≠a inversa y entrada no autorizada</a></li>
<li><a href="../437000/index.html">C√≥mo ense√±ar a las personas a usar git</a></li>
<li><a href="../437004/index.html">¬øLos programadores de YML sue√±an con pruebas ansibles?</a></li>
<li><a href="../437006/index.html">Rese√±a de la impresora 3D Wanhao Duplicator 10</a></li>
<li><a href="../437008/index.html">PNL. Lo basico. T√©cnicas Autodesarrollo. Parte 1</a></li>
<li><a href="../437010/index.html">Ecos del pasado: la experiencia de Young en la base del nuevo m√©todo de espectroscop√≠a de rayos X</a></li>
<li><a href="../437014/index.html">La tarea de N cuerpos o c√≥mo volar una galaxia sin salir de la cocina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>