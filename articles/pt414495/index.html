<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•í üëèüèº ü•ô toString: √ìtimo e terr√≠vel üë©üèº‚ÄçüöÄ ü§òüèø üóΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A fun√ß√£o toString em JavaScript √© provavelmente a mais "impl√≠cita" discutida entre os pr√≥prios desenvolvedores js e entre observadores externos. Ela √©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>toString: √ìtimo e terr√≠vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414495/"><p><img src="https://habrastorage.org/webt/on/px/4c/onpx4cu-vxqkdask5tvj3so9va4.jpeg" alt="imagem"></p><br><p>  A fun√ß√£o <em>toString</em> em <strong>JavaScript √©</strong> provavelmente a mais "impl√≠cita" discutida entre os pr√≥prios desenvolvedores js e entre observadores externos.  Ela √© a causa de in√∫meras piadas e memes sobre muitas opera√ß√µes aritm√©ticas suspeitas, transforma√ß√µes que entram em um estupor <em>[objeto Objeto]</em> .  √â concedido, talvez, apenas para surpreender ao trabalhar com float64. </p><br><p>  Casos interessantes que eu tive que observar, usar ou superar, me motivaram a escrever um relat√≥rio real.  Galoparemos sobre a especifica√ß√£o da linguagem e usaremos os exemplos para analisar os recursos n√£o √≥bvios do <em>toString</em> . </p><br><p> Se voc√™ espera orienta√ß√µes √∫teis e suficientes, ent√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse</a> material s√£o mais adequados para voc√™.  Se a sua curiosidade ainda prevalece sobre o pragmatismo, ent√£o por favor, sob gato. </p><a name="habracut"></a><br><h3 id="vse-chto-nuzhno-znat">  Tudo o que voc√™ precisa saber </h3><br><p>  A fun√ß√£o <em>toString</em> √© uma propriedade do objeto de prot√≥tipo Object, em palavras simples, seu m√©todo.  √â usado para a convers√£o de string de um objeto e deve retornar um valor primitivo em um bom caminho.  Os objetos de prot√≥tipo tamb√©m t√™m suas implementa√ß√µes: <em>Fun√ß√£o, Matriz, String, Booleano, N√∫mero, S√≠mbolo, Data, RegExp, Erro</em> .  Se voc√™ implementar seu objeto de prot√≥tipo (classe), o <em>toString</em> ser√° uma boa forma para ele. </p><br><p>  <em>JavaScript</em> √© uma linguagem com um sistema de tipos fraco: o que significa que nos permite misturar tipos diferentes, executa muitas opera√ß√µes implicitamente.  Nas convers√µes, <em>toString</em> √© emparelhado com <em>valueOf</em> para reduzir o objeto ao primitivo necess√°rio para a opera√ß√£o.  Por exemplo, o operador de adi√ß√£o se transforma em concatena√ß√£o se houver pelo menos uma linha entre os operadores.  Algumas fun√ß√µes padr√£o da linguagem antes do trabalho levam a um argumento para a sequ√™ncia: <em>parseInt, decodeURI, JSON.parse, btoa</em> e assim por diante. </p><br><p>  Muito j√° foi dito e ridicularizado sobre elenco impl√≠cito.  Consideraremos implementa√ß√µes de <em>toString de</em> objetos de prot√≥tipo de linguagem-chave. </p><br><h3 id="objectprototypetostring">  Object.prototype.toString </h3><br><p>  Se voltarmos para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se√ß√£o</a> correspondente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da</a> especifica√ß√£o, descobrimos que a principal tarefa do <em>toString</em> padr√£o √© fazer com que a chamada <strong>tag</strong> concatene a string resultante: </p><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"[object "</span></span> + tag + <span class="hljs-string"><span class="hljs-string">"]"</span></span></code> </pre> <br><p>  Para fazer isso: </p><br><ol><li>  Uma chamada para o s√≠mbolo interno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>toStringTag</em></a> (ou a pseudo-propriedade <em>[[Class]]</em> na edi√ß√£o antiga) ocorre: ele possui muitos objetos prot√≥tipos internos ( <em>Mapa, Matem√°tica, JSON</em> e outros). </li><li>  Se estiver faltando ou n√£o uma sequ√™ncia, ela enumera v√°rias outras pseudo-propriedades e m√©todos internos que sinalizam o tipo do objeto: <em>[[Call]]</em> para <em>Function</em> , <em>[[DateValue]]</em> para <em>Date</em> e assim por diante. </li><li>  Bem, se nada, ent√£o a <em>tag</em> √© <em>"Objeto"</em> . </li></ol><br><p>  Aqueles que s√£o afetados pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reflex√£o</a> notar√£o imediatamente a possibilidade de obter o tipo de um objeto com uma opera√ß√£o simples (n√£o recomendada pela especifica√ß√£o, mas poss√≠vel): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getObjT = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(obj).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br><p>  A peculiaridade do <em>toString</em> padr√£o √© que ele funciona com qualquer valor <em>desse tipo</em> .  Se for um primitivo, ser√° convertido para o objeto ( <em>nulo</em> e <em>indefinido</em> s√£o verificados separadamente).  Nenhum <em>TypeError</em> : </p><br><pre> <code class="javascript hljs">[<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}].map(getObjT); &gt; [<span class="hljs-string"><span class="hljs-string">"Number"</span></span>, <span class="hljs-string"><span class="hljs-string">"Null"</span></span>, <span class="hljs-string"><span class="hljs-string">"Function"</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>, <span class="hljs-string"><span class="hljs-string">"GeneratorFunction"</span></span>]</code> </pre> <br><p>  Como isso pode ser √∫til?  Por exemplo, ao desenvolver ferramentas para an√°lise din√¢mica de c√≥digo.  Tendo um conjunto improvisado de vari√°veis ‚Äã‚Äãusado durante o trabalho do aplicativo, voc√™ pode coletar estat√≠sticas homog√™neas √∫teis em tempo de execu√ß√£o. </p><br><p>  Essa abordagem tem uma grande desvantagem: tipos de usu√°rios.  N√£o √© dif√≠cil adivinhar que para as inst√¢ncias deles apenas obtemos <em>"Objeto"</em> . </p><br><h3 id="kastomnyy-symboltostringtag-i-functionname">  Symbol.toStringTag personalizado e Function.name </h3><br><p>  OOP no JavaScript √© baseado em prot√≥tipos, e n√£o em classes (como em Java), e n√£o temos um m√©todo <em>getClass ()</em> pronto.  Uma defini√ß√£o expl√≠cita do caractere <em>toStringTag</em> para um tipo de usu√°rio ajudar√° a resolver o problema: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Cat'</span></span>; } }</code> </pre> <br><p>  ou no estilo de prot√≥tipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} Dog.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>;</code> </pre> <br><p>  Existe uma solu√ß√£o alternativa atrav√©s da propriedade somente leitura <em>Function.name</em> , que ainda n√£o faz parte da especifica√ß√£o, mas √© suportada pela maioria dos navegadores.  Cada inst√¢ncia do objeto / classe do prot√≥tipo possui um link para a fun√ß√£o do construtor com a qual foi criado.  Para que possamos descobrir o nome do tipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Cat'</span></span></code> </pre> <br><p>  ou no estilo de prot√≥tipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Dog'</span></span></code> </pre> <br><p>  Obviamente, esta solu√ß√£o n√£o funciona para objetos criados usando uma fun√ß√£o an√¥nima ( <em>"an√¥nimo"</em> ) ou <em>Object.create (null)</em> , bem como para primitivas sem um objeto de wrapper ( <em>nulo, indefinido</em> ). </p><br><p>  Assim, para manipula√ß√£o confi√°vel de tipos de vari√°veis, vale a pena combinar t√©cnicas conhecidas, baseadas principalmente na tarefa em quest√£o.  Na grande maioria dos casos, <em>typeof</em> e <em>instanceof</em> s√£o suficientes. </p><br><h3 id="functionprototypetostring">  Function.prototype.toString </h3><br><p>  Ficamos um pouco distra√≠dos, mas, como resultado, chegamos a fun√ß√µes que t√™m seu pr√≥prio <em>toString</em> interessante.  Primeiro, d√™ uma olhada no seguinte c√≥digo: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'('</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee.toString() + <span class="hljs-string"><span class="hljs-string">')()'</span></span>); })()</code> </pre> <br><p>  Muitos provavelmente adivinharam que este √© um exemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quine</a> .  Se voc√™ carregar um script com esse conte√∫do no corpo da p√°gina, uma c√≥pia exata do c√≥digo-fonte ser√° exibida no console.  Isso ocorre devido √† chamada <em>toString</em> da fun√ß√£o <em>argumentos.callee</em> . </p><br><p>  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementa√ß√£o</a> usada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> objeto de prot√≥tipo <em>toString do</em> <em>Function</em> retorna uma representa√ß√£o em string do c√≥digo fonte da fun√ß√£o, preservando a sintaxe usada em sua defini√ß√£o: <em>FunctionDeclaration, FunctionExpression, ClassDeclaration, ArrowFunction</em> , etc. </p><br><p>  Por exemplo, temos uma fun√ß√£o de seta: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(ctx, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br><p>  Chamar <em>bind.toString ()</em> nos retornar√° uma representa√ß√£o de string de <em>ArrowFunction</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"(f, ctx) =&gt; function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  E chamar <em>toString</em> de uma fun√ß√£o agrupada j√° √© uma representa√ß√£o de string de <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Esse exemplo de <em>liga√ß√£o</em> n√£o √© acidental, pois temos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solu√ß√£o pronta</a> com a liga√ß√£o de contexto <em>Function.prototype.bind</em> e, em rela√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√†s fun√ß√µes</a> nativas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> existe um recurso de <em>Function.prototype.toString</em> trabalhando com elas.  Dependendo da implementa√ß√£o, √© poss√≠vel obter uma representa√ß√£o da pr√≥pria fun√ß√£o agrupada e da fun√ß√£o de <em>destino</em> .  V8 e SpiderMonkey vers√µes mais recentes do chrome e ff: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } getx.bind({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).toString() &lt; <span class="hljs-string"><span class="hljs-string">"function () { [native code] }"</span></span></code> </pre> <br><p>  Portanto, deve-se ter cuidado com os recursos decorados de forma nativa. </p><br><h3 id="praktika-ispolzovaniya-ftostring">  Pratique usando f.toString </h3><br><p>  H√° muitas op√ß√µes para usar o <em>toString em</em> quest√£o, mas √© urgente apenas como uma ferramenta de metaprograma√ß√£o ou depura√ß√£o.  Ter uma aplica√ß√£o t√≠pica semelhante na l√≥gica de neg√≥cios, mais cedo ou mais tarde, levar√° a uma calha quebrada n√£o suportada. </p><br><p>  A coisa mais simples que vem √† mente √© <strong>determinar o tamanho da fun√ß√£o</strong> : </p><br><pre> <code class="javascript hljs">f.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  A localiza√ß√£o e o n√∫mero de caracteres de espa√ßo em branco do resultado <em>toString</em> s√£o fornecidos pela especifica√ß√£o para a compra de uma implementa√ß√£o espec√≠fica; portanto, para limpeza, primeiro removemos o excesso, levando a uma vis√£o geral.  A prop√≥sito, nas vers√µes mais antigas do mecanismo Gecko, a fun√ß√£o tinha um par√¢metro de <em>indenta√ß√£o</em> especial que ajuda na formata√ß√£o de indenta√ß√µes. </p><br><p>  A <strong>defini√ß√£o de nomes de par√¢metros de fun√ß√£o</strong> vem imediatamente √† mente, o que pode ser √∫til para reflex√£o: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/^function(?:\s+\w+)?\s*\(([^\)]+)/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-regexp"><span class="hljs-regexp">/\s*,\s*/</span></span>)</code> </pre> <br><p>  Essa solu√ß√£o de joelho √© adequada para as sintaxes <em>FunctionDeclaration</em> e <em>FunctionExpression</em> .  Se voc√™ precisar de um mais detalhado e preciso, recomendo que voc√™ procure exemplos do c√≥digo-fonte da sua estrutura favorita, que provavelmente possui algum tipo de inje√ß√£o de depend√™ncia oculta, com base nos nomes dos par√¢metros declarados. </p><br><p>  Uma op√ß√£o perigosa e interessante para <strong>substituir uma fun√ß√£o</strong> atrav√©s de <em>eval</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prod = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(sum.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\+(?=\s*(?:a|b))/gm</span></span>, <span class="hljs-string"><span class="hljs-string">'*'</span></span>)); sum(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">15</span></span> prod(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span></code> </pre> <br><p>  Conhecendo a estrutura da fun√ß√£o original, criamos uma nova substituindo o operador de adi√ß√£o usado em seu corpo por argumentos com multiplica√ß√£o.  No caso de c√≥digo gerado por software ou a falta de uma interface de extens√£o de fun√ß√£o, isso pode ser magicamente √∫til.  Por exemplo, se voc√™ estiver pesquisando um modelo matem√°tico, selecionando uma fun√ß√£o adequada, jogando com operadores e coeficientes. </p><br><p>  Um uso mais pr√°tico √© a <strong>compila√ß√£o e distribui√ß√£o de modelos</strong> .  Muitas implementa√ß√µes de mecanismo de modelo compilam o c√≥digo-fonte de um modelo e fornecem uma fun√ß√£o de dados que j√° forma o HTML final (ou outro).  A seguir, √© apresentado um exemplo da fun√ß√£o <a href="">_.template</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloJst = <span class="hljs-string"><span class="hljs-string">"Hello, &lt;%= user %&gt;"</span></span> _.template(helloJst)({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Mas e se a compila√ß√£o do modelo exigir recursos de hardware ou o cliente for muito fraco?  Nesse caso, podemos compilar o modelo no lado do servidor e fornecer aos clientes n√£o o texto do modelo, mas uma representa√ß√£o em string da fun√ß√£o finalizada.  Al√©m disso, voc√™ n√£o precisa carregar a biblioteca de modelos no cliente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloStr = _.template(helloJst).toString() helloStr &lt; <span class="hljs-string"><span class="hljs-string">"function(obj) { obj || (obj = {}); var __t, __p = ''; with (obj) { __p += 'Hello, ' + ((__t = ( user )) == null ? '' : __t); } return __p }"</span></span></code> </pre> <br><p>  Agora precisamos executar esse c√≥digo no cliente antes do uso.  Que na compila√ß√£o n√£o havia <em>SyntaxError</em> devido √† sintaxe de <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(helloStr.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^function\(obj\)/</span></span>, <span class="hljs-string"><span class="hljs-string">'obj=&gt;'</span></span>));</code> </pre> <br><p>  ou mais: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`const f = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${helloStr}</span></span></span><span class="hljs-string">;f`</span></span>);</code> </pre> <br><p>  Ou como voc√™ gosta mais.  De qualquer forma: </p><br><pre> <code class="javascript hljs">helloFn({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Essa pode n√£o ser a melhor pr√°tica para compilar modelos no lado do servidor e distribu√≠-los aos clientes.  Apenas um exemplo usando um monte de <em>Function.prototype.toString</em> e <em>eval</em> . </p><br><p>  Finalmente, a tarefa antiga de <strong>definir um nome de fun√ß√£o</strong> (antes que a propriedade <em>Function.name</em> apare√ßa) via <em>toString</em> : </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Obviamente, isso funciona bem com a sintaxe <em>FunctionDeclaration</em> .  Uma solu√ß√£o mais inteligente exigir√° express√£o regular astuta ou correspond√™ncia de padr√µes. </p><br><p>  A Internet est√° cheia de solu√ß√µes interessantes baseadas em <em>Function.prototype.toString</em> , basta perguntar.  Compartilhe sua experi√™ncia nos coment√°rios: muito interessante. </p><br><h3 id="arrayprototypetostring">  Array.prototype.toString </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A implementa√ß√£o do</a> <em>toString de</em> um objeto de prot√≥tipo de <em>matriz</em> √© gen√©rica e pode ser chamada para qualquer objeto.  Se o objeto tiver um m√©todo de <em>jun√ß√£o</em> , o resultado de <em>toString</em> ser√° sua chamada, caso contr√°rio, <em>Object.prototype.toString</em> . </p><br><p>  <em>Matriz</em> , logicamente, possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um m√©todo de jun√ß√£o</a> que concatena a representa√ß√£o de string de todos os seus elementos atrav√©s do <em>separador</em> passado como par√¢metro (o padr√£o √© uma v√≠rgula). </p><br><p>  Suponha que precisamos escrever uma fun√ß√£o que serialize uma lista de seus argumentos.  Se todos os par√¢metros s√£o primitivos, em muitos casos, podemos <em>ficar</em> sem o <em>JSON.stringify</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>).toString(); }</code> </pre> <br><p>  ou mais: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seria = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.toString();</code> </pre> <br><p>  Lembre-se de que a sequ√™ncia '10' e o n√∫mero 10 ser√£o serializados da mesma forma.  No problema do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memoizer mais curto</a> em um est√°gio, essa solu√ß√£o foi usada. </p><br><p>  A jun√ß√£o nativa dos elementos da matriz funciona por um ciclo aritm√©tico de 0 a <em>comprimento</em> e n√£o filtra os elementos ausentes ( <em>nulo</em> e <em>indefinido</em> ).  Em vez disso, a concatena√ß√£o ocorre com o <em>separador</em> .  Isso leva ao seguinte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); ar.toString() &lt; <span class="hljs-string"><span class="hljs-string">",,,...,,,"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1000 times</span></span></code> </pre> <br><p>  Portanto, se por um motivo ou outro voc√™ adicionar um elemento com um √≠ndice grande √† matriz (por exemplo, esse √© um ID natural gerado), em nenhum caso, junte-se e, portanto, n√£o leve a uma sequ√™ncia sem prepara√ß√£o preliminar.  Caso contr√°rio, pode haver consequ√™ncias: <em>Comprimento de string inv√°lido, falta de mem√≥ria</em> ou apenas um script pendente.  Use as fun√ß√µes dos <em>valores</em> e <em>chaves</em> do objeto <em>Object</em> para iterar apenas sobre suas pr√≥prias propriedades enumeradas do objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> k = []; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">20</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1,2,3"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1024,1048576,1073741824"</span></span></code> </pre> <br><p>  Mas √© muito melhor evitar esse manuseio da matriz: provavelmente um objeto de valor-chave simples serviria como armazenamento. </p><br><p>  A prop√≥sito, o mesmo perigo existe ao serializar atrav√©s do <em>JSON.stringify</em> .  Apenas mais s√©rio, j√° que os elementos vazios e sem suporte j√° est√£o representados como <em>"nulos"</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(ar); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">]" // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1000</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">times</span></span></span></span></span></span></code> </pre> <br><p>  Concluindo a se√ß√£o, gostaria de lembr√°-lo de que voc√™ pode definir seu m√©todo de <em>jun√ß√£o</em> para o tipo de usu√°rio e chamar <em>Array.prototype.toString.call</em> como uma <em>convers√£o</em> alternativa √† string, mas duvido que ele tenha algum uso pr√°tico. </p><br><h3 id="numberprototypetostring-i-parseint">  Number.prototype.toString e parseInt </h3><br><p>  Uma das minhas tarefas favoritas para os question√°rios js √©: O que retornar√° a pr√≥xima chamada de <em>an√°lise</em> ? </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  A primeira coisa que o <em>parseInt</em> faz √© converter implicitamente um argumento em uma string chamando a fun√ß√£o abstrata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>ToString</em></a> , que, dependendo do tipo de argumento, executa o ramo de convers√£o desejado.  Para o <em>n√∫mero do</em> tipo, √© feito o seguinte: </p><br><ol><li>  Se o valor for <em>NaN, 0</em> ou <em>Infinito</em> , retorne a sequ√™ncia correspondente. </li><li>  Caso contr√°rio, o algoritmo retornar√° o registro mais conveniente para o homem do n√∫mero: na forma decimal ou exponencial. </li></ol><br><p>  N√£o duplicarei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo para</a> determinar a forma preferida aqui, observarei apenas o seguinte: se o n√∫mero de d√≠gitos em uma nota√ß√£o decimal exceder <strong>21</strong> , uma forma exponencial ser√° selecionada.  E isso significa que, no nosso caso, o <em>parseInt</em> n√£o funciona com "100 ... 000", mas com "1e30".  Portanto, a resposta n√£o √© de todo esperada 2 ^ 30.  Quem sabe a natureza desse n√∫mero m√°gico 21 - escreva! </p><br><p>  Em seguida, <em>parseInt</em> examina a base do sistema de n√∫meros de <em>raiz</em> usado (por padr√£o 10, temos 2) e verifica os caracteres da sequ√™ncia recebida quanto √† compatibilidade com ela.  Tendo encontrado 'e', ‚Äã‚Äãcorta toda a cauda, ‚Äã‚Äãdeixando apenas "1".  O resultado ser√° um n√∫mero inteiro obtido pela convers√£o do sistema com a base do radical em decimal - no nosso caso, √© 1. </p><br><p>  Procedimento reverso: </p><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  √â aqui que a fun√ß√£o <em>toString</em> √© chamada do objeto de prot√≥tipo <em>Number</em> , que usa o mesmo algoritmo para converter o <em>n√∫mero</em> em uma string.  Ele tamb√©m possui o par√¢metro <em>radix</em> opcional.  Somente ele lan√ßa um <em>RangeError</em> para um valor inv√°lido (deve ser um n√∫mero inteiro de 2 a 36 inclusive), enquanto <em>parseInt</em> retorna <em>NaN</em> . </p><br><p>  Vale lembrar o limite superior do sistema num√©rico se voc√™ planeja implementar uma fun√ß√£o de hash ex√≥tica: esse <em>toString</em> pode n√£o funcionar para voc√™. </p><br><p>  A tarefa de distrair por um momento: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'3113'</span></span>.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(<span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>)</code> </pre> <br><p>  O que retornar√° e como consertar? </p><br><h3 id="obdelennoe-vnimaniem">  Privado de aten√ß√£o </h3><br><p>  Examinamos <em>toString</em> de maneira alguma mesmo todos os objetos prot√≥tipos nativos.  Em parte porque, pessoalmente, n√£o tive problemas com eles e n√£o h√° muito interesse neles.  Al√©m disso, n√£o tocamos na fun√ß√£o <em>toLocaleString</em> , pois seria bom falar sobre isso separadamente.  Se eu fiz algo em v√£o privado de aten√ß√£o, perdido de vista ou incompreendido - n√£o se esque√ßa de escrever! </p><br><h3 id="prizyv-k-bezdeystviyu">  Chamada para ina√ß√£o </h3><br><p>  Os exemplos que citei n√£o s√£o de modo algum receitas prontas - apenas alimento para reflex√£o.  Al√©m disso, acho in√∫til e meio est√∫pido discutir isso em entrevistas t√©cnicas: para isso, existem t√≥picos eternos sobre fechamento, jun√ß√£o, ciclo de eventos, padr√µes de m√≥dulo / fachada / mediador e perguntas "√© claro" sobre [a estrutura usada]. </p><br><p>  Este artigo acabou se tornando uma miscel√¢nea, e espero que voc√™ tenha encontrado algo interessante para si mesmo.  PS A linguagem JavaScript - incr√≠vel! </p><br><h3 id="bonus">  B√¥nus </h3><br><p>  Ao preparar este material para publica√ß√£o, usei o Google Translate.  E, por acidente, descobri um efeito divertido.  Se voc√™ selecionar uma tradu√ß√£o do russo para o ingl√™s, digite "toString" e comece a apag√°-la usando a tecla Backspace, e observaremos: </p><br><p><img src="https://habrastorage.org/webt/op/yl/g3/opylg3burl5dlqv5ojibfeis0c4.gif" alt="b√¥nus"></p><br><p>  Que ironia!  Acho que estou longe do primeiro, mas apenas para o caso de lhes enviar uma captura de tela com um script de reprodu√ß√£o.  Parece um auto-XSS inofensivo, √© por isso que eu o compartilho. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414495/">https://habr.com/ru/post/pt414495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414483/index.html">Digite SQL Seguro no Kotlin</a></li>
<li><a href="../pt414485/index.html">GNMT, falha √©pica ou sutilezas da tradu√ß√£o autom√°tica</a></li>
<li><a href="../pt414487/index.html">Um raro representante do tipo de for√ßa bruta: a hist√≥ria de um ataque</a></li>
<li><a href="../pt414489/index.html">EUA planejam tratar seriamente da quest√£o de detritos espaciais</a></li>
<li><a href="../pt414493/index.html">Como escrever um contrato inteligente para a ICO em 5 minutos</a></li>
<li><a href="../pt414497/index.html">API da interface do usu√°rio do Consulo da ideia ao prot√≥tipo</a></li>
<li><a href="../pt414499/index.html">Relat√≥rio do Clube de Roma de 2018, cap√≠tulo 1.1.3: ‚ÄúUm mundo vazio versus uma paz total‚Äù</a></li>
<li><a href="../pt414501/index.html">Relat√≥rio do Clube de Roma de 2018, cap√≠tulo 3.11: ‚ÄúReformas do setor financeiro‚Äù</a></li>
<li><a href="../pt414503/index.html">Intel NUC Hades Canyon com gr√°ficos AMD Vega - VR ou n√£o VR?</a></li>
<li><a href="../pt414505/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 2: ‚ÄúControle de ataques de hackers‚Äù, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>