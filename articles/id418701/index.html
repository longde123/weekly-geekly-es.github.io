<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸšµ ğŸš âš½ï¸ Kami mempelajari parser sintaksis untuk bahasa Rusia ğŸ–•ğŸ» ğŸ˜¾ ğŸ¤³ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Denis Kiryanov, saya bekerja di Sberbank dan menangani masalah pemrosesan bahasa alami (NLP). Suatu ketika kami harus memilih parser sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mempelajari parser sintaksis untuk bahasa Rusia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/418701/">  Hai  Nama saya Denis Kiryanov, saya bekerja di Sberbank dan menangani masalah pemrosesan bahasa alami (NLP).  Suatu ketika kami harus memilih parser sintaksis untuk bekerja dengan bahasa Rusia.  Untuk melakukan ini, kami mempelajari belantara morfologi dan tokenisasi, menguji berbagai pilihan dan mengevaluasi penerapannya.  Kami membagikan pengalaman kami di pos ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c87/ec8/f26/c87ec8f26a969cf54915271e24abcba1.png"><br><a name="habracut"></a><br><h2>  Persiapan untuk seleksi </h2><br>  Mari kita mulai dengan dasar-dasarnya: bagaimana cara kerjanya?  Kami mengambil teks, melakukan tokenization dan mendapatkan beberapa pseudo-token.  Tahapan analisis lebih lanjut cocok dengan piramida: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2f/cd9/0aa/b2fcd90aaf42d1eee5ed3ee84fcf27fd.png"><br><br>  Semuanya dimulai dengan morfologi - dengan analisis bentuk kata dan kategori gramatikal (jenis kelamin, kasus, dll.).  Morfologi didasarkan pada sintaksis - hubungan di luar batas satu kata, antar kata.  Parser sintaksis yang akan dibahas, menganalisis teks dan memberikan struktur ketergantungan kata-kata dari satu sama lain. <br><br><h3>  Tata bahasa dependensi dan tata bahasa komponen langsung </h3><br>  Ada dua pendekatan utama untuk penguraian, yang dalam teori linguistik ada pada pijakan yang sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c59/951/f08/c59951f08529e3628f3ad969385e4be9.png"><br><br>  Di baris pertama, kalimat diuraikan sebagai bagian dari tata bahasa dependensi.  Pendekatan ini diajarkan di sekolah.  Setiap kata dalam sebuah kalimat entah bagaimana terhubung dengan yang lain.  â€œSabunâ€ - predikat yang menjadi sandaran subjek â€œibuâ€ (di sini tata bahasa dependensi menyimpang dari sekolah, di mana predikat bergantung pada subjek).  Subjek memiliki definisi tergantung dari "milikku."  Predikat memiliki "bingkai" pelengkap langsung yang tergantung.  Dan penambahan langsung ke "bingkai" - definisi "kotor." <br><br>  Pada baris kedua, analisis sesuai dengan tata bahasa komponen itu sendiri. <br>  Menurutnya, kalimat itu dibagi menjadi kelompok kata (frasa).  Kata-kata dalam satu kelompok lebih terkait erat.  Kata-kata "saya" dan "ibu" lebih terkait erat, "bingkai" dan "kotor" - juga.  Dan masih ada "sabun" yang terpisah. <br><br>  Pendekatan kedua untuk penguraian otomatis bahasa Rusia tidak dapat diterapkan, karena di dalamnya kata-kata yang berkaitan erat (anggota kelompok yang sama) sangat sering tidak berdiri berurutan.  Kita harus menggabungkannya dengan tanda kurung yang aneh - dalam satu atau dua kata.  Oleh karena itu, dalam penguraian otomatis bahasa Rusia, sudah lazim bekerja berdasarkan tata bahasa dependensi.  Ini juga nyaman karena semua orang akrab dengan "kerangka kerja" di sekolah. <br><br><h3>  Pohon ketergantungan </h3><br>  Kita dapat menerjemahkan serangkaian dependensi ke dalam struktur pohon.  Bagian atas adalah kata "sabun," beberapa kata langsung bergantung padanya, sebagian tergantung pada para pecandu.  Berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">definisi</a> pohon ketergantungan dari buku teks Martin dan Zhurafsky: <br><br>  <i>Pohon ketergantungan adalah grafik terarah yang memenuhi batasan berikut:</i> <br><br><ul><li>  <i>Ada simpul root tunggal yang ditunjuk yang tidak memiliki busur masuk.</i> <br></li><li>  <i>Dengan pengecualian dari simpul akar, setiap simpul memiliki tepat satu busur yang masuk.</i> <br></li><li>  <i>Ada jalur unik dari simpul akar ke setiap simpul di V.</i> <br></li></ul><br>  Ada simpul tingkat atas - predikat.  Dari sini Anda dapat mencapai kata apa pun.  Setiap kata tergantung pada yang lain, tetapi hanya pada satu.  Pohon ketergantungan terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b3/b16/19d/4b3b1619db261a71dfd749c28b4fde31.png"><br><br>  Di pohon ini, ujung-ujungnya ditandai dengan beberapa jenis hubungan sintaksis khusus.  Dalam tata bahasa dependensi, tidak hanya fakta koneksi antara kata dianalisis, tetapi juga sifat koneksi ini.  Misalnya, "diambil" hampir merupakan satu bentuk kata kerja, "inventaris" adalah subjek untuk "diambil".  Oleh karena itu, kita memiliki tepi "adalah" di satu arah dan yang lainnya.  Ini bukan koneksi yang sama, mereka memiliki sifat yang berbeda, sehingga harus dibedakan. <br><br>  Selanjutnya, kami mempertimbangkan kasus-kasus sederhana di mana anggota hukuman hadir, tidak tersirat.  Ada struktur dan tanda untuk menangani pass.  Sesuatu muncul di pohon yang tidak memiliki ekspresi dangkal - sepatah kata pun.  Tapi ini adalah subjek penelitian lain, tetapi kita masih perlu fokus pada kita sendiri. <br><br><h3>  Proyek Ketergantungan Universal </h3><br>  Untuk memfasilitasi pilihan parser, kami mengalihkan perhatian kami ke proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketergantungan Universal</a> dan kompetisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas Bersama CoNLL</a> , yang baru-baru ini terjadi dalam kerangka kerjanya. <br><br>  Universal Dependencies adalah proyek untuk menyatukan markup korpus sintaksis (tribanks) dalam kerangka tata bahasa dependensi.  Di Rusia, jumlah jenis tautan sintaksis terbatas - subjek, predikat, dll.  Dalam bahasa Inggris sama, tetapi himpunan sudah berbeda.  Misalnya, sebuah artikel muncul di sana yang juga perlu diberi label entah bagaimana.  Jika kami ingin menulis parser ajaib yang dapat menangani semua bahasa, maka kami akan segera mengalami masalah membandingkan tata bahasa yang berbeda.  Para pencipta heroik Dependensi Universal berhasil menyepakati di antara mereka sendiri dan menandai semua bangunan yang mereka miliki dalam satu format.  Tidak terlalu penting bagaimana mereka setuju, yang terpenting adalah pada output kami mendapatkan format seragam tertentu untuk menyajikan keseluruhan cerita ini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih dari 100 tribank untuk 60 bahasa</a> . <br><br>  Tugas Bersama CoNLL adalah kompetisi antara pengembang algoritma penguraian, yang diadakan sebagai bagian dari proyek Ketergantungan Universal.  Panitia mengambil sejumlah tribank dan memecahnya menjadi tiga bagian - pelatihan, validasi, dan tes.  Bagian pertama diberikan kepada peserta kompetisi sehingga mereka melatih model mereka di atasnya.  Bagian kedua juga digunakan oleh peserta untuk mengevaluasi operasi algoritma setelah pelatihan.  Peserta dapat mengulangi pelatihan dan penilaian secara iteratif.  Kemudian mereka memberikan algoritma terbaik mereka kepada panitia, yang menjalankannya pada bagian uji, tertutup bagi para peserta.  Hasil model pada bagian uji tribank adalah hasil kompetisi. <br><br><h3>  Metrik kualitas </h3><br>  Kami memiliki koneksi antara kata dan tipenya.  Kami dapat mengevaluasi apakah kata atas ditemukan dengan benar - metrik UAS (Skor lampiran tidak berlabel).  Atau untuk mengevaluasi apakah titik dan jenis ketergantungan ditemukan dengan benar - metrik LAS (Labeled attachment score). <br><br><img src="https://habrastorage.org/webt/zb/q5/ic/zbq5icc6mgwabmeryltcbgnp8g4.png"><br><br>  Tampaknya penilaian akurasi memohon sendiri di sini - kami mempertimbangkan berapa kali kami dapatkan dari jumlah total kasus.  Jika kami memiliki 5 kata dan untuk 4 kami menentukan yang benar, kami mendapat 80%. <br><br>  Tetapi sebenarnya mengevaluasi parser dalam bentuk murni itu bermasalah.  Pengembang yang memecahkan masalah parsing otomatis sering mengambil teks mentah sebagai input, yang, sesuai dengan analisis piramida, melewati tahap-tahap tokenization dan analisis morfologis.  Kesalahan dari langkah-langkah sebelumnya ini dapat mempengaruhi kualitas pengurai.  Secara khusus, ini berlaku untuk prosedur tokenization - alokasi kata.  Jika kami telah mengidentifikasi kata unit yang salah, maka kami tidak akan lagi dapat mengevaluasi hubungan sintaksis di antara mereka dengan benar - bagaimanapun, dalam korps berlabel asli kami, unit-unit itu berbeda. <br><br>  Oleh karena itu, rumus evaluasi dalam hal ini adalah ukuran-f, di mana akurasi adalah bagian dari hit akurat relatif terhadap jumlah prediksi, dan kelengkapan adalah share hit akurat relatif terhadap jumlah tautan dalam data mark-up. <br><br>  Ketika kami memberikan taksiran di masa mendatang, kita harus ingat bahwa metrik yang digunakan tidak hanya memengaruhi sintaksis, tetapi juga kualitas tokenization. <br><br><h3>  Bahasa Rusia di Universal Dependencies </h3><br>  Agar parser dapat menandai kalimat yang belum dilihat secara sintaksis, ia perlu memberi makan korpus yang ditandai untuk pelatihan.  Untuk bahasa Rusia, ada beberapa kasus seperti itu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/839/f92/0bf/839f920bffbfaf4efc0d054ee4804f0d.png"><br><br>  Kolom kedua menunjukkan jumlah token - kata.  Semakin banyak token, semakin banyak korps pelatihan dan semakin baik algoritma final (jika ini adalah data yang baik).  Jelas, semua percobaan dilakukan di SynTagRus (dikembangkan oleh IPPI RAS), di mana ada lebih dari satu juta token.  Semua algoritma akan dilatih tentang hal itu, yang akan dibahas nanti. <br><br><h3>  Parser untuk bahasa Rusia dalam Tugas Bersama CoNLL </h3><br>  Menurut hasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompetisi</a> tahun lalu, model yang dilatih pada SynTagRus yang sama mencapai indikator LAS berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ded/ab4/27e/dedab427eef589c4bf8e3c24475632f7.png"><br><br>  Hasil parser untuk Rusia mengesankan - mereka lebih baik daripada parser untuk bahasa Inggris, Prancis, dan bahasa lain yang lebih jarang.  Kami sangat beruntung karena dua alasan sekaligus.  Pertama, algoritma melakukan pekerjaan yang baik dengan bahasa Rusia.  Kedua, kami memiliki SynTagRus - perumahan besar dan bertanda. <br><br>  Ngomong-ngomong, kompetisi tahun 2018 telah berlalu, tetapi kami melakukan penelitian pada musim semi tahun ini, jadi kami mengandalkan hasil trek tahun lalu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ke</a> depan, kami perhatikan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi baru UDPipe</a> (Future) ternyata lebih tinggi tahun ini. <br><br>  Syntaxnet, parser Google, tidak ada dalam daftar.  Apa yang salah dengannya?  Jawabannya sederhana: Sintaksis dimulai hanya dengan tahap analisis morfologis.  Dia mengambil tokenization ideal siap pakai, dan sudah membangun pemrosesan di atasnya.  Oleh karena itu, tidak adil untuk mengevaluasinya setara dengan yang lainnya - sisanya melakukan pemisahan menjadi token dengan algoritma mereka sendiri, dan ini dapat memperburuk hasil pada tahap berikutnya dari sintaks.  Sampel Syntaxnet 2017 memiliki hasil yang lebih baik daripada seluruh daftar di atas, tetapi perbandingan langsung tidak adil. <br><br>  Tabel mendapat dua versi UDPipe, di 12 dan 15 tempat.  Orang yang sama yang mengambil bagian aktif dalam proyek Ketergantungan Universal sedang mengembangkan parser ini. <br><br>  Pembaruan UDPipe secara berkala muncul (agak kurang sering, omong-omong, tata letak casing juga diperbarui).  Jadi, setelah kompetisi tahun lalu, UDPipe diperbarui (ini adalah komitmen untuk versi 2.0 belum dirilis; di masa depan, untuk kesederhanaan, kita akan secara kasar merujuk pada komitmen UDPipe 2.0 yang kami ambil, meskipun sebenarnya tidak demikian);  Tentu saja, tidak ada pembaruan seperti itu di tabel kompetisi.  Hasil dari komit â€œkamiâ€ berada di peringkat ketujuh. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/262/c42/635/262c42635f1f93cdfd690418208f79fe.png"><br><br>  Jadi, kita perlu memilih parser untuk bahasa Rusia.  Sebagai data awal, kami memiliki pelat di atas dengan Syntaxnet terkemuka dan dengan UDPipe 2.0 di suatu tempat di tempat ke-7. <br><br><h2>  Pilih model </h2><br>  Kami membuatnya sederhana: kami mulai dengan parser dengan harga tertinggi.  Jika ada sesuatu yang salah dengannya, pergi ke bawah.  Sesuatu mungkin tidak benar sesuai dengan kriteria berikut - mungkin mereka tidak sempurna, tetapi mereka mendatangi kita: <br><br><ul><li>  <b>Kecepatan kerja</b>  Parser kami harus bekerja cukup cepat.  Sintaksnya, tentu saja, jauh dari satu-satunya modul "di bawah tenda" dari sistem waktu-nyata, jadi Anda tidak boleh menghabiskan lebih dari selusin milidetik untuk itu. <br></li><li>  <b>Kualitas pekerjaan</b> .  Minimal, parser itu sendiri didasarkan pada data bahasa Rusia.  Persyaratannya jelas.  Untuk bahasa Rusia, kami memiliki analisa morfologi yang cukup baik yang dapat diintegrasikan ke dalam piramida kami.  Jika kita dapat memastikan bahwa parser itu berfungsi dengan baik tanpa morfologi, maka ini cocok untuk kita - kita akan menyelipkan morfologi nanti. <br></li><li>  <b>Ketersediaan kode pelatihan dan lebih disukai model dalam domain publik</b> .  Jika kami memiliki kode pelatihan, kami akan dapat mengulangi hasil dari penulis model.  Untuk melakukan ini, mereka harus terbuka.  Dan, di samping itu, kita perlu memantau dengan cermat kondisi distribusi kasus dan model - apakah kita harus membeli lisensi untuk menggunakannya, jika kita menggunakannya sebagai bagian dari algoritme kita? <br></li><li>  <b>Luncurkan tanpa usaha ekstra</b> .  Item ini sangat subjektif, tetapi penting.  Apa artinya ini?  Ini berarti bahwa jika kita duduk selama tiga hari dan memulai sesuatu, tetapi itu tidak dimulai, maka kita tidak akan dapat memilih parser ini, bahkan jika itu akan memiliki kualitas yang sempurna. <br></li></ul><br>  Segala sesuatu yang lebih tinggi dari UDPipe 2.0 pada parser chart tidak cocok untuk kita.  Kami memiliki proyek Python, dan beberapa parser dari daftar tidak ditulis dalam Python.  Untuk mengimplementasikannya dalam proyek Python, perlu untuk menerapkan upaya yang sangat super.  Dalam kasus lain, kami dihadapkan dengan kode sumber tertutup, pengembangan akademis, industri - secara umum, Anda tidak akan sampai ke dasar. <br><br>  Star Syntaxnet layak mendapat cerita terpisah tentang kualitas pekerjaan.  Di sini dia tidak cocok dengan kita untuk kecepatan kerja.  Waktu tanggapannya terhadap beberapa frasa sederhana yang umum dalam obrolan adalah dari 100 milidetik.  Jika kita menghabiskan begitu banyak pada sintaksis, kita tidak punya cukup waktu untuk hal lain.  Pada saat yang sama, UDPipe 2.0 melakukan parsing selama ~ 3ms.  Akibatnya, pilihan jatuh pada UDPipe 2.0. <br><br><h2>  UDPipe 2.0 </h2><br>  UDPipe adalah saluran pipa yang mempelajari tokenization, lemmatization, tagging morfologis, dan penguraian tata bahasa dependensi.  Kita dapat mengajarinya semua ini atau sesuatu secara terpisah.  Misalnya, buatlah penganalisa morfologis lain untuk bahasa Rusia.  Atau latih dan gunakan UDPipe sebagai tokenizer. <br><br>  UDPipe 2.0 didokumentasikan secara rinci.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi arsitektur</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori dengan kode pelatihan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual</a> .  Yang paling menarik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model yang sudah jadi</a> , termasuk untuk bahasa Rusia.  Unduh dan jalankan.  Juga pada sumber daya ini parameter pelatihan yang dipilih untuk setiap corpus bahasa telah dirilis.  Untuk setiap model seperti itu, dibutuhkan sekitar 60 parameter pelatihan, dan dengan bantuan mereka Anda dapat secara mandiri mencapai indikator kualitas yang sama seperti pada tabel.  Mereka mungkin tidak optimal, tetapi setidaknya kita dapat yakin bahwa pipa akan bekerja dengan benar.  Selain itu, keberadaan referensi semacam itu memungkinkan kami untuk bereksperimen dengan tenang dengan model kami sendiri. <br><br><h3>  Cara Kerja UDPipe 2.0 </h3><br>  Pertama, teks dibagi menjadi kalimat, dan kalimat menjadi kata-kata.  UDPipe melakukan semua ini sekaligus dengan bantuan modul bersama - jaringan saraf (GRU dua sisi satu-lapisan), yang untuk setiap karakter memprediksi apakah itu yang terakhir dalam kalimat atau kata. <br><br>  Kemudian tagger mulai bekerja - sesuatu yang memprediksi sifat morfologis token: dalam hal ini kata itu, dalam jumlah apa.  Berdasarkan empat karakter terakhir dari setiap kata, tagger menghasilkan hipotesis tentang bagian dari kata-kata dan tag morfologis kata itu, dan kemudian dengan bantuan perceptron memilih opsi terbaik. <br><br>  UDPipe juga memiliki lemmatizer yang memilih bentuk awal untuk kata-kata.  Dia belajar tentang prinsip yang sama dengan mana seorang penutur asing dapat mencoba untuk menentukan lemma dari kata yang tidak dikenal.  Kami memotong awalan dan akhir kata, menambahkan beberapa "t", yang ada dalam bentuk awal kata kerja, dll.  Jadi kandidat dihasilkan, dari mana perceptron terbaik memilih. <br><br>  Skema penandaan morfologis (menentukan jumlah, kasus, dan segala sesuatu yang lain) dan prediksi lemma sangat mirip.  Mereka dapat diprediksi bersama, tetapi lebih baik secara terpisah - morfologi bahasa Rusia terlalu kaya.  Anda juga dapat menghubungkan daftar lemma Anda. <br><br>  Mari kita beralih ke bagian yang paling menarik - pengurai.  Ada beberapa arsitektur parser ketergantungan.  UDPipe adalah arsitektur berbasis transisi: ia bekerja dengan cepat, melewati semua token sekali dalam waktu linier. <br><br>  Parsing sintaksis dalam arsitektur seperti itu dimulai dengan stack (di mana pada awalnya hanya ada root) dan konfigurasi kosong.  Ada tiga cara standar untuk mengubahnya: <br><br><ul><li>  LeftArc - berlaku jika elemen kedua dari stack tidak di-root.  Itu membuat hubungan antara token di bagian atas tumpukan dan token kedua, dan juga mengeluarkan yang kedua dari tumpukan. <br></li><li>  RightArc adalah sama, tetapi ketergantungan dibangun dengan cara lain, dan ujungnya dibuang. <br></li><li>  Shift - mentransfer kata berikutnya dari buffer ke tumpukan. <br></li></ul><br>  Di bawah ini adalah contoh parser ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ).  Kami memiliki frasa "pesan penerbangan pagi" dan kami terhubung kembali ke sana: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/b17/845/196b17845e524d75a878837b25325a76.png"><br><br>  Inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/686/c78/066/686c780661b296250d53cba054317a18.png"><br><br>  Parser berbasis transisi klasik memiliki tiga operasi yang tercantum di atas: panah satu arah, panah satu arah, dan shift.  Ada juga operasi Swap, dalam arsitektur parser berbasis transisi dasar itu tidak digunakan, tetapi termasuk dalam UDPipe.  Swap mengembalikan elemen kedua stack ke buffer untuk mengambil yang berikutnya dari buffer (jika ada spasi).  Ini membantu melompati beberapa kata dan memulihkan koneksi yang benar. <br><br>  Ada artikel bagus dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> orang yang membuat operasi swap.  Kami akan memilih satu poin: terlepas dari kenyataan bahwa kami berulang kali melewati buffer token awal (mis., Waktu kami tidak lagi linier), operasi ini dapat dioptimalkan sehingga waktu dikembalikan sangat dekat dengan linier.  Artinya, sebelum kita bukan hanya operasi yang bermakna dari sudut pandang bahasa, tetapi juga alat yang tidak terlalu memperlambat kerja parser. <br><br>  Dengan menggunakan contoh di atas, kami menunjukkan operasi, sebagai hasilnya kami mendapatkan beberapa konfigurasi - buffer token dan koneksi di antara mereka.  Kami memberikan konfigurasi ini pada langkah saat ini ke parser berbasis transisi, dan dengan itu, ia harus memprediksi konfigurasi di langkah berikutnya.  Membandingkan vektor input dan konfigurasi di setiap langkah, model dilatih. <br><br>  Jadi, kami memilih parser yang sesuai dengan semua kriteria kami, dan bahkan memahami cara kerjanya.  Kami melanjutkan ke percobaan. <br><br><h3>  Masalah UDPipe </h3><br>  Mari kita tanyakan sebuah kalimat kecil: "Transfer seratus rubel ke ibu".  Hasilnya membuat Anda memegang kepala Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cb/948/1f2/9cb9481f2e06b366fbee26f0835d31b0.png"><br><br>  "Terjemahkan" ternyata menjadi alasan, tapi ini cukup logis.  Kami menentukan tata bahasa bentuk kata oleh empat karakter terakhir.  "Timbal" adalah sesuatu seperti "di tengah", jadi pilihannya relatif logis.  Itu lebih menarik dengan "ibu": "ibu" ada dalam kasus preposisional dan menjadi puncak dari kalimat ini. <br><br>  Jika kita mencoba menafsirkan semuanya berdasarkan hasil parsing, maka kita akan mendapatkan sesuatu seperti "di tengah-tengah seorang ibu (ibu siapa? Siapa ibu ini?) Ratusan rubel."  Tidak seperti di awal.  Kita harus entah bagaimana berurusan dengan ini.  Dan kami datang dengan caranya. <br><br>  Dalam piramida analisis, sintaks dibangun di atas morfologi, berdasarkan tag morfologi.  Berikut adalah contoh buku teks dari ahli bahasa L.V.  Shcherby dalam hal ini: <br><br>  <i>"Gloky cuzdra shteko budlanula bokra dan bocah kecil berambut keriting."</i> <br><br>  Analisis proposal ini tidak menimbulkan masalah.  Mengapa  Karena kita, sebagai pemberi tag UDPipe, melihat bagian akhir kata dan memahami bagian bicara yang dimaksud dan bentuknya.  Cerita dengan "menerjemahkan" sebagai alasan benar-benar bertentangan dengan intuisi kita, tetapi ternyata menjadi logis pada saat kita mencoba melakukan hal yang sama dengan kata-kata yang tidak dikenal.  Seseorang mungkin berpikir dengan cara yang sama. <br><br>  Kami akan mengevaluasi tagger UDPipe secara terpisah.  Jika tidak sesuai dengan kami, kami akan mengambil tagger lain - kemudian membuat penguraian di atas markup morfologis lainnya. <br><br>  <i>Memberi tag dari teks biasa (Skor CoNLL17 F1)</i> <br><br><ul><li>  <i>bentuk emas: 301639</i> , <br></li><li>  <i>upostag: 98,15%</i> , <br></li><li>  <i>xpostag: 99,89%</i> , <br></li><li>  <b><i>prestasi: 93,97%</i></b> , <br></li><li>  <b><i>alltags: 93,44%</i></b> , <br></li><li>  <b><i>lemmas: 96.68%</i></b> <br></li></ul><br>  Kualitas morfologi UDPipe 2.0 tidak buruk.  Tetapi untuk bahasa Rusia lebih baik dicapai.  Alat analisis Mystem ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengembangan Yandex</a> ) mencapai hasil yang lebih baik dalam menentukan bagian pidato daripada UDPipe.  Selain itu, penganalisa lain lebih sulit diimplementasikan dalam proyek python, dan mereka bekerja lebih lambat pada kualitas yang sebanding dengan Mystem. ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br>              UDPipe.   .  ,  Mystem     .  ,    Â«  Â»  Â«Â» â€”   Â«Â»,    Â«Â».    .   ,     Â«Â»,     (),  ,    .   : <br><br><ul><li> Â« Â» â€”     <br></li><li> Â«  Â» â€” ..     <br></li><li> Â« - Â» â€”     (-     ) <br></li></ul><br>  Dalam kasus seperti itu, Mystem jujur â€‹â€‹memberikan seluruh rantai: <br><br> <code>m.analyze(" ") <br> [{'analysis': [{'lex': '', 'gr': 'PART='}], 'text': ''}, <br> {'text': ' '}, <br> {'analysis': [{'lex': '', 'gr': 'S,,=(,|,|,)'}], <br> 'text': ''}, <br> {'text': '\n'}] <br></code> <br>  Tetapi kami tidak dapat mengirim seluruh rantai pipa ke UDPipe, tetapi kami harus menetapkan beberapa tag yang lebih baik.  Bagaimana cara memilihnya?  Jika Anda tidak menyentuh apa pun, saya ingin mengambil yang pertama, mungkin itu akan berhasil.  Tetapi tag diurutkan secara alfabetis sesuai dengan nama bahasa Inggris, sehingga pilihan kami akan hampir acak, dan beberapa pengurai hampir kehilangan kesempatan untuk menjadi yang pertama. <br><br>  Ada penganalisa yang dapat memberikan opsi terbaik - Pymorphy2.  Tetapi dengan analisis morfologi, ia lebih buruk.  Selain itu, ia memberikan kata terbaik di luar konteks.  Pymorphy2 hanya akan memberikan satu analisis untuk "no director", "see director" dan "director".  Ini tidak akan acak, tetapi benar-benar yang terbaik dalam probabilitas, yang dalam pymorphy2 dianggap pada badan teks yang terpisah.  Tetapi persentase tertentu dari analisis yang salah dari teks pertempuran akan dijamin, hanya karena mereka mungkin mengandung frasa dengan bentuk nyata yang berbeda: "Aku melihat direktur" dan "direktur datang ke pertemuan" dan "tidak ada direktur".  Probabilitas penguraian tanpa konteks tidak cocok untuk kita. <br><br>  Bagaimana cara mendapatkan set tag terbaik secara kontekstual?  Menggunakan penganalisis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RNNMorph</a> .  Hanya sedikit orang yang mendengar tentang dia, tetapi tahun lalu dia memenangkan persaingan di antara para penganalisa morfologis, yang diadakan sebagai bagian dari konferensi Dialog. <br><br>  RNNMorph memiliki masalah sendiri: tidak memiliki tokenization.  Jika Mystem dapat menandai teks mentah, maka RNNMorph membutuhkan daftar token pada input.  Untuk sampai ke sintaks, pertama-tama Anda harus menggunakan beberapa tokenizer eksternal, kemudian memberikan hasilnya ke RNNMorph dan baru kemudian memberi makan morfologi yang dihasilkan ke parser sintaks. <br><br>  Berikut adalah opsi yang kami miliki.  Kami tidak akan menolak analisis pymorphy2 tanpa konteks untuk saat ini atas kasus yang dapat diperdebatkan di Mystem - tiba-tiba itu tidak akan tertinggal jauh di belakang RNNMorph.  Meskipun jika kita membandingkannya murni pada tingkat kualitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">marka</a> morfologis (data dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MorphoRuEval-2017</a> ), maka kerugiannya signifikan - sekitar 15%, jika kita mengambil akurasi sesuai dengan kata-kata. <br>  Selanjutnya, kita perlu mengkonversi output Mystem ke format yang dimengerti oleh UDPipe - conllu.  Dan lagi ini adalah masalah, bahkan sebanyak dua.  Murni teknis - garis tidak cocok.  Dan konseptual - tidak selalu sepenuhnya jelas bagaimana membandingkannya.  Dihadapkan dengan dua markup data bahasa yang berbeda, Anda hampir pasti akan mengalami masalah pencocokan tag, lihat contoh di bawah ini.  Jawaban untuk pertanyaan "tag mana yang ada di sini" mungkin berbeda, dan mungkin jawaban yang benar tergantung pada tugasnya.  Karena ketidakkonsistenan ini, sistem markup yang cocok bukanlah tugas yang mudah. <br><br>  Bagaimana cara mengubahnya?  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket</a> _ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Russian_tagsets</a> - paket untuk Python yang dapat mengonversi berbagai format.  Tidak ada terjemahan dari format penerbitan Mystem ke Conllu, yang diterima di Universal Dependencies, tetapi ada terjemahan ke conllu, misalnya, dari format markup dari corpus nasional bahasa Rusia (dan sebaliknya).  Penulis paket (ngomong-ngomong, dia adalah penulis pymorphy2) menulis hal yang luar biasa langsung dalam dokumentasi: "Jika Anda tidak dapat menggunakan paket ini, jangan menggunakannya."  Dia melakukan ini bukan karena programmer krivorukov (dia adalah programmer yang hebat!), Tetapi karena jika Anda perlu mengonversi satu sama lain, maka Anda berisiko mendapat masalah karena ketidakkonsistenan linguistik dari konvensi markup. <br><br>  Berikut ini sebuah contoh.  Sekolah itu diajarkan "kategori kondisi" (dingin, perlu).  Beberapa mengatakan itu kata keterangan, yang lain mengatakan kata sifat.  Anda perlu mengonversi ini, dan Anda menambahkan beberapa aturan, tetapi tetap tidak mencapai korespondensi yang jelas antara satu format dengan yang lainnya. <br><br>  Contoh lain: janji (seseorang melakukan sesuatu atau melakukan sesuatu dengan seseorang).  "Petya membunuh seseorang" atau "Petya terbunuh."  â€œVasya mengambil gambarâ€ - â€œVasya mengambil gambarâ€ (yaitu, sebenarnya, â€œVasya difotoâ€).  Ada juga jaminan medial di SynTagRus - kami bahkan tidak akan menyelidiki apa itu dan mengapa.  Tetapi dalam Mystem tidak.  Jika Anda perlu membawa satu format ke format lain, ini jalan buntu. <br><br>  Kami kurang lebih jujur â€‹â€‹menerima saran dari penulis paket russian_tagsets - tidak menggunakan pengembangannya, karena kami tidak menemukan pasangan yang diperlukan dalam daftar format korespondensi.  Sebagai hasilnya, kami menulis konverter kustom kami dari Mystem ke Conllu dan melanjutkan. <br><br><h3>  Kami menghubungkan tagger pihak ketiga dan pengurai UDPipe </h3><br>  Setelah semua petualangan, kami mengambil tiga algoritma, yang dijelaskan di atas: <br><br><ul><li>  UDPipe dasar <br></li><li>  Mym dengan tag disambiguasi dari pymorphy2 <br></li><li>  RNNMorph <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/6e8/acb/c7a6e8acba5759723b585121d296b4e5.png"><br><br>  Kami kehilangan kualitas karena alasan yang cukup jelas.  Kami mengambil model UDPipe yang dilatih pada satu morfologi, tetapi menyelipkan morfologi lain pada input.  Masalah klasik ketidakcocokan data antara kereta api dan tes adalah hasil dari penurunan kualitas. <br><br>  Kami mencoba menyelaraskan alat penandaan morfologis otomatis kami dengan marka SynTagRus, yang ditandai secara manual.  Kami tidak berhasil, oleh karena itu, dalam kasus pelatihan SynTagRus, kami akan mengganti semua tanda morfologi manual dengan yang diperoleh dari Mystem dan pymorphy2 dalam satu kasus dan dari RNNMorph dalam kasus lain.  Dalam kasus tervalidasi yang ditandai dengan tangan, kita dipaksa untuk mengubah tanda manual menjadi otomatis, karena "dalam pertempuran" kita tidak akan pernah mendapatkan tanda manual. <br><br>  Sebagai hasilnya, kami melatih parser UDPipe (hanya parser) dengan hyperparameter yang sama dengan baseline.  Apa yang bertanggung jawab atas sintaksis - ID vertex, yang bergantung pada jenis koneksi - kami pergi, kami mengubah segalanya. <br><br><h2>  Hasil </h2><br>  Selanjutnya saya akan membandingkan kami dengan Syntaxnet dan algoritma lainnya.  Penyelenggara Tugas Bersama CoNLL telah meluncurkan partisi SynTagRus (train / dev / test 80/10/10).  Kami awalnya mengambil yang lain (kereta / tes 70/30), sehingga data tidak selalu bertepatan dengan kami, meskipun mereka diterima pada kasus yang sama.  Selain itu, kami mengambil rilis terbaru (per Februari-Maret) dari repositori SynTagRus - versi ini sedikit berbeda dari yang ada di kompetisi.  Data untuk apa yang tidak lepas landas diberikan dalam artikel di mana pemisahannya sama dengan di kompetisi - algoritme tersebut ditandai dengan tanda bintang di tabel. <br><br>  Inilah hasil akhirnya: <br><img src="https://habrastorage.org/getpro/habr/post_images/f80/3ac/3ce/f803ac3ce0068974e855a050ebddc61b.png"><br><br>  RNNMorph benar-benar menjadi lebih baik - bukan dalam arti absolut, tetapi dalam peran alat bantu untuk mendapatkan metrik umum sesuai dengan hasil parsing (dibandingkan dengan Mystem + pymorphy2).  Artinya, semakin baik morfologi, semakin baik sintaksisnya, tetapi pemisahan "sintaksis" jauh lebih sedikit daripada yang morfologis.  Perhatikan juga bahwa kami tidak jauh dari model dasar, yang berarti bahwa dalam morfologi benar-benar tidak sebanyak yang kami harapkan. <br><br>  Saya bertanya-tanya berapa banyak terletak pada morfologi sama sekali?  Apakah mungkin untuk mencapai peningkatan mendasar dalam parser sintaksis karena morfologi yang ideal?  Untuk menjawab pertanyaan ini, kami mengendarai UDPipe 2.0 menggunakan tokenization dan morfologi yang dikalibrasi sempurna (menggunakan standar markup manual standar).  Kami mendapat margin tertentu (lihat baris tentang Gold Morph di tabel; ternyata + 1,54% dari RNNMorph_reannotated_syntax) dari apa yang kami miliki, termasuk dari sudut pandang penentuan jenis koneksi dengan benar.  Jika seseorang pernah menulis analisa morfologis yang benar-benar sempurna dari bahasa Rusia, kemungkinan hasil yang kita peroleh dengan menggunakan pengurai sintaksis abstrak juga akan bertambah.  Dan kami kira-kira memahami langit-langit (setidaknya langit-langit untuk arsitektur itu dan untuk kombinasi parameter yang kami gunakan untuk UDPipe - ditunjukkan pada baris ketiga dari tabel di atas). <br><br>  Menariknya, kami hampir mencapai versi Syntaxnet di metrik LAS.  Jelas bahwa kami memiliki data yang sedikit berbeda, tetapi pada prinsipnya masih sebanding.  Token sintaksis adalah "emas", dan bagi kami - dari Mystem.  Kami menulis pembungkus yang disebutkan di atas untuk Mystem, tetapi penguraian masih terjadi secara otomatis;  mungkin Mystem juga salah di suatu tempat.  Dari garis tabel â€œUDPipe 2.0 gold tokâ€, dapat dilihat bahwa jika Anda mengambil tokenization UDPipe dan emas default, maka itu masih sedikit kehilangan Syntaxnet-2017.  Tetapi itu bekerja lebih cepat. <br><br>  Apa yang belum dicapai oleh siapa pun adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengurai Stanford</a> .  Ini dirancang dengan cara yang sama seperti Syntaxnet, jadi ini berfungsi untuk waktu yang lama.  Di UDPipe, kita tinggal menyusuri tumpukan.  Arsitektur parser Stanford dan Syntaxnet memiliki konsep yang berbeda: pertama mereka menghasilkan grafik berorientasi lengkap, dan kemudian algoritma bekerja untuk meninggalkan kerangka (pohon spanning minimal) yang kemungkinan besar akan terjadi.  Untuk melakukan ini, ia melakukan kombinasi, dan pencarian ini tidak lagi linier, karena Anda akan beralih ke satu kata lebih dari sekali.  Terlepas dari kenyataan bahwa untuk waktu yang lama, dari sudut pandang sains murni, setidaknya untuk bahasa Rusia, itu adalah arsitektur yang lebih efisien.  Kami mencoba meningkatkan pengembangan akademik ini selama dua hari - sayangnya, itu tidak berhasil.  Tetapi berdasarkan arsitekturnya, jelas bahwa itu tidak bekerja cepat. <br><br>  Adapun pendekatan kami - meskipun secara formal kami hampir tidak naik dengan metrik, sekarang semuanya baik-baik saja dengan "ibu". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/f71/8b2/423f718b24dbb3c0db517fc13c032647.png"><br><br>  Dalam frasa "menerjemahkan seratus rubel ke ibu", "menerjemahkan" benar-benar kata kerja dalam suasana hati yang penting.  "Mom" mendapatkan kopernya.  Dan yang paling penting bagi kami adalah label kami (iobj), sebuah objek tidak langsung (tujuan).  Meskipun pertumbuhan dalam jumlah dapat diabaikan, kami berhasil mengatasi masalah dengan mana tugas dimulai. <br><br><h2>  Track bonus: tanda baca </h2><br>  Jika kita kembali ke data sebenarnya, ternyata sintaks tergantung pada tanda baca.  Ambillah ungkapan "Anda tidak bisa melakukan belas kasihan."  Apa yang sebenarnya tidak bisa dilakukan - untuk "mengeksekusi" atau "berbelas kasihan" - tergantung di mana koma berada.  Bahkan jika kita menempatkan ahli bahasa untuk menandai data, dia akan membutuhkan tanda baca sebagai semacam alat bantu.  Dia tidak bisa melakukannya tanpa dia. <br><br>  Mari kita ambil frasa "Peter halo" dan "Peter halo" dan lihat analisis mereka dengan model baseline-UDPipe.  Kami mengabaikan masalah itu, menurut model ini, kemudian: <br>  1) "Petya" adalah kata benda feminin; <br>  2) "Petya" adalah (dilihat dari himpunan tag) bentuk awal, tetapi pada saat yang sama, lemanya seharusnya bukan "Petya". <br><br>  Ini adalah bagaimana hasil berubah karena koma, dengan bantuannya kita mendapatkan sesuatu yang mirip dengan kebenaran. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/821/773/46f8217734e6e8c0f31e8f7f47d23d7d.png"><br><br>  Dalam kasus kedua, "Petya" adalah subjek, dan "halo" adalah kata kerja.  Kembali ke prediksi bentuk kata berdasarkan empat karakter terakhir.  Dalam interpretasi algoritma, ini bukan "salam Petya", tetapi "salam Petya".  Ketik "Petya bernyanyi" atau "Petya akan datang."  Analisisnya cukup bisa dimengerti: dalam bahasa Rusia, tidak mungkin ada koma antara subjek dan predikat.  Karena itu, jika koma adalah, ini adalah kata "halo", dan jika tidak ada koma, itu mungkin sesuatu seperti "Petya Privet." <br><br>  Kami akan menjumpai ini dalam produksi cukup sering, karena pemeriksa ejaan akan memperbaiki ejaan, tetapi tidak tanda baca.  Untuk memperburuk keadaan, pengguna dapat menetapkan koma secara salah, dan algoritma kami akan memperhitungkannya dalam memahami bahasa alami.  Apa solusi yang mungkin ada di sini?  Kami melihat dua opsi. <br><br>  Opsi pertama adalah melakukan apa yang terkadang mereka lakukan ketika menerjemahkan ucapan ke dalam teks.  Awalnya, tidak ada tanda baca dalam teks seperti itu, sehingga dipulihkan melalui model.  Outputnya adalah materi yang relatif kompeten dalam hal aturan bahasa Rusia, yang membantu parser sintaksis untuk bekerja dengan benar. <br><br>  Gagasan kedua agak berani dan bertentangan dengan pelajaran sekolah dari bahasa Rusia.  Ini melibatkan bekerja tanpa tanda baca: jika tiba-tiba input tanda baca, kami akan menghapusnya dari sana.  Kami juga akan menghapus sama sekali semua tanda baca dari korps pelatihan.  Kami berasumsi bahwa bahasa Rusia ada tanpa tanda baca.  Hanya poin untuk dibagi menjadi kalimat. <br><br>  Secara teknis, ini sangat sederhana, karena kami tidak mengubah node akhir di pohon sintaksis.  Kami tidak dapat memiliki tanda baca di atas.  Ini selalu merupakan beberapa simpul akhir, kecuali untuk tanda%, yang karena beberapa alasan di SynTagRus adalah simpul untuk angka sebelumnya (50% di SynTagRus ditandai sebagai% - simpul, dan 50 - tergantung). <br><br>  Mari kita uji menggunakan model Mystem (+ pymorphy 2). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e4/578/1de/4e45781de1ac88426d8e6da786903d8b.png"><br><br>  Sangat penting bagi kita untuk tidak memberikan model teks tanda baca tanpa tanda baca.  Tetapi jika kita selalu memberikan teks tanpa tanda baca, maka kita akan berada di baris teratas dan mendapatkan setidaknya hasil yang dapat diterima.  Jika teks tanpa tanda baca dan model berfungsi non-tanda baca, maka sehubungan dengan tanda baca yang ideal dan model tanda baca, penurunan hanya sekitar 3%. <br><br>  Apa yang harus dilakukan?  Kita dapat memikirkan angka-angka ini - diperoleh dengan menggunakan model bebas tanda baca dan pemurnian tanda baca.  Atau buat semacam classifier untuk mengembalikan tanda baca.  Kami tidak akan mencapai angka ideal (angka dengan tanda baca pada model tanda baca), karena algoritme pemulihan tanda baca bekerja dengan beberapa kesalahan, dan angka "ideal" dihitung pada SynTagRus yang benar-benar murni.  Tetapi jika kita akan menulis model yang mengembalikan tanda baca, akankah kemajuan membayar biaya kita?  Jawabannya belum jelas. <br><br>  Kita dapat berpikir lama tentang arsitektur parser, tetapi kita harus ingat bahwa sebenarnya belum ada kumpulan besar teks web yang ditandai secara sintaksis.  Keberadaannya akan membantu memecahkan masalah nyata dengan lebih baik.  Sejauh ini, kami sedang belajar pada korps teks yang benar-benar terpelajar, yang diedit - dan kami kehilangan kualitas dengan mendapatkan teks-teks khusus dalam pertempuran, yang sering ditulis buta huruf. <br><br><h2>  Kesimpulan </h2><br>  Kami memeriksa penggunaan berbagai algoritma parsing sintaksis berdasarkan tata bahasa dependensi, sebagaimana diterapkan pada bahasa Rusia.  Ternyata dalam hal kecepatan, kemudahan dan kualitas pekerjaan, UDPipe ternyata menjadi alat terbaik.  Model dasarnya dapat ditingkatkan jika tahap-tahap tokenisasi dan analisis morfologis ditugaskan untuk analisis pihak ketiga lainnya: trik ini memungkinkan untuk memperbaiki perilaku tagger yang salah dan, sebagai hasilnya, parser dalam kasus-kasus penting untuk analisis. <br><br>  Kami juga menganalisis masalah hubungan antara tanda baca dan parsing dan sampai pada kesimpulan bahwa dalam kasus kami, tanda baca sebelum parsing sintaksis lebih baik untuk dihapus. <br><br>  Kami berharap poin aplikasi yang dibahas dalam artikel kami akan membantu Anda menggunakan parsing sintaksis untuk menyelesaikan masalah Anda seefisien mungkin. <br><br>  <i>Penulis berterima kasih kepada Nikita Kuznetsova dan Natalya Filippova atas bantuannya dalam mempersiapkan artikel;</i>  <i>untuk bantuan dalam penelitian ini - Anton Alekseev, Nikita Kuznetsov, Andrei Kutuzov, Boris Orekhov dan Mikhail Popov.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418701/">https://habr.com/ru/post/id418701/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418689/index.html">Cara membuat pustaka komponen di Figma, menghemat anggaran, menggunakan contoh lelang online</a></li>
<li><a href="../id418691/index.html">Peternak: Kubernet dalam 5 menit dengan logam kosong</a></li>
<li><a href="../id418693/index.html">Mengapa kebahagiaan begitu sulit dideteksi di otak</a></li>
<li><a href="../id418695/index.html">Perang Anti-Pembajakan - The Empire Strikes Back</a></li>
<li><a href="../id418699/index.html">Membuat mesin arcade emulator. Bagian 3</a></li>
<li><a href="../id418705/index.html">Dasar-dasar Futex</a></li>
<li><a href="../id418707/index.html">KDispatcher - eventbus yang ringan dan nyaman untuk penggunaan sehari-hari</a></li>
<li><a href="../id418709/index.html">Perlu memaksa diri Anda: driver dan hambatan antarmuka</a></li>
<li><a href="../id418711/index.html">Register Terkelola Token 1.0</a></li>
<li><a href="../id418713/index.html">Game untuk meningkatkan kualitas Wikipedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>