<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç® ‚úãüèæ üßëüèΩ Winstar gr√°ficos y pantallas de modo de texto ‚úçüèæ ‚ô†Ô∏è üèÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las pantallas gr√°ficas, incluidas las del tipo OLED, m√°s representadas en nuestro mercado por Winstar, tienen una demanda mucho menor en relaci√≥n con ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winstar gr√°ficos y pantallas de modo de texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402517/"> Las pantallas gr√°ficas, incluidas las del tipo OLED, m√°s representadas en nuestro mercado por Winstar, tienen una demanda mucho menor en relaci√≥n con las min√∫sculas y las publicaciones sobre su uso tambi√©n son mucho menores.  Mientras tanto, son las pantallas OLED gr√°ficas las que, debido a la falta de uni√≥n a las tablas de fuentes de un patr√≥n predefinido, proporcionan la mejor manera de obtener dispositivos de visualizaci√≥n ergon√≥micos para una amplia variedad de necesidades.  Adem√°s, result√≥ que el modo gr√°fico en el controlador WS0010 es m√°s f√°cil de iniciar y funciona m√°s estable que el modo de texto. <br><br>  Antes de proceder a la consideraci√≥n de las pantallas gr√°ficas reales, consideraremos el problema perenne con los problemas de encender el modo de texto del controlador WS0010, que recibi√≥ una soluci√≥n inesperada y obvia (¬°oh, d√≥nde estaban mis ojos!). <br><a name="habracut"></a><br><h3>  Resoluci√≥n de problemas con el modo de texto WS0010 </h3><br>  Es bien sabido que las pantallas de la l√≠nea Winstar tienen problemas de estabilidad durante la inicializaci√≥n.  Por cierto, result√≥ que esto no era exclusivo de los "malditos chinos": las muestras de Newhaven Display 16x2, que obtuve con gran dificultad, ubicadas en el otro lado del globo, son externamente una copia completa de Winstar, excepto por la ubicaci√≥n de algunas inscripciones y el nombre de la empresa en la mancha ( la misma forma y fuente): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5c4/0e4/db8/5c40e4db8577cfcdacad5ecdf2652606.jpg" width="600" alt="imagen"><br><br>  Al contener, como est√° escrito en las hojas de datos, un cierto controlador "LCD comparable", estas pantallas se comportan completamente id√©nticas a las chinas y tienen las mismas desventajas.  Obviamente, no debe pasar tiempo revisando otras compa√±√≠as, como Midas: a juzgar por esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> , no podr√≠a prescindir de la cooperaci√≥n internacional.  La econom√≠a globalizada gobierna! <br><br>  Las dificultades del modo de texto se expresan en el hecho de que al iniciar (por ejemplo, al reiniciar o restablecer manualmente el programa del controlador de control), puede aparecer basura en las pantallas, y las l√≠neas 0 y 1 cambian de lugar al azar.  Los experimentos mostraron que no depende del m√©todo de inclusi√≥n (8 bits o 4 bits).  Este problema es especialmente grave cuando se requieren reinicios peri√≥dicos del software, por ejemplo, por Watchdog-timer. <br><br>  Parte del problema es una actitud ordenada hacia el poder (desde una fuente separada, y de ninguna manera desde USB Arduino), y un reinicio por separado apagando y encendiendo la pantalla despu√©s de iniciar el programa de control (ver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n anterior</a> del autor).  Al final result√≥ que, el autor de estas l√≠neas no fue el √∫nico que propuso una soluci√≥n similar al problema: el autor del complemento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LuquidCrystal</a> llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WinstarOLED</a> tambi√©n incluy√≥ un pw_pin especial en √©l, con el cual la potencia de la pantalla se distorsiona en el momento en que comienza el programa. <br><br>  Pero esto es todo, por supuesto, iniciativa y medias medidas.  Alguien SeregaB encontr√≥ una forma radical (vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su publicaci√≥n</a> en easyelectronics.ru, gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tomasina</a> por la informaci√≥n).  De hecho, plante√≥ una tarea completamente diferente: aprender a trabajar solo con modo gr√°fico en lugar de texto.  Intentando cambiar entre modos, descubri√≥ r√°pidamente que " <i>cambiar al modo gr√°fico era normal, y de gr√°fico a" texto ", muy torpe</i> ".  Luego record√≥ que " <i>una vez, hace mucho tiempo, cuando las DSh todav√≠a se imprim√≠an en papel, en algunas de las DSh en el HD44780 le√≠ que los modos de cambio solo deber√≠an hacerse cuando la pantalla est√° apagada</i> ".  Y funcion√≥. <br><br>  De la publicaci√≥n citada, simplemente reproducir√© dos procedimientos de conmutaci√≥n aqu√≠, adapt√°ndolos ligeramente para su uso con LuquidCrystal (la instancia de clase se llama OLED1 aqu√≠). <br><br>  Cambiar al modo gr√°fico: <br><pre><code class="hljs cmake">OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x1F);//   OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08|<span class="hljs-number"><span class="hljs-number">0</span></span>x04);// </code> </pre> <br>  Cambiar al modo de texto: <br><pre> <code class="hljs cmake"> OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x17);//    OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x04 | <span class="hljs-number"><span class="hljs-number">0</span></span>x08);// </code> </pre> <br>  Como veremos m√°s adelante, el primer procedimiento no es realmente necesario: el WS0010 cambia al modo gr√°fico desde media patada, solo env√≠a el comando 0x1F.  Pero la segunda secuencia de comandos fue el caso.  Para la muestra, se incluy√≥ directamente en el boceto usando LuquidCrystal de esta forma: <br><pre> <code class="hljs ruby">void reset_textmode() /<span class="hljs-regexp"><span class="hljs-regexp">/     { OLED1.command(0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  OLED1.command(0x17);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x01);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x04 | 0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  }</span></span></code> </pre> <br>  Luego se llam√≥ a esta funci√≥n en la configuraci√≥n justo despu√©s del inicio de la biblioteca: <br><br><pre> <code class="hljs ruby"> . . . . . OLED1.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  reset_textmode(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  clear() . . . . .</code> </pre> <br>  Si inserta un retraso (500) antes de esto, la demostraci√≥n resulta muy clara: despu√©s de presionar el bot√≥n de reinicio de la placa Arduino, generalmente aparece basura en la pantalla, pero solo por un momento: despu√©s de que se activa la funci√≥n, la pantalla se borra y todas las l√≠neas vuelven a su lugar . <br><br>  La funci√≥n funciona as√≠, pero por conveniencia, reemplac√© el contenido de la funci√≥n LiquidCrystalRus :: clear () en el archivo de la biblioteca mejorada LiquidCrystalRus_OLED.cpp que se discuti√≥ anteriormente con esta secuencia de comandos (le recuerdo que <a href="">puede descargarlo</a> del sitio del autor).  No hay que esperar a que el comando se ejecute en la biblioteca, por lo tanto, para mayor confiabilidad, despu√©s de cada comando hay demoras de 100 Œºs insertadas en el estilo general de la biblioteca.  En los bocetos que utilizan esta variante de LiquidCrystalRus_OLED, al comienzo de la configuraci√≥n, es necesario llamar a la funci√≥n clear () y, al mismo tiempo, borrar√° la pantalla. <br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  Hay un problema con la limpieza de la pantalla: en la hoja de datos de la tabla de comandos se observa que el comando 0x01 puede durar hasta 6,2 ms "cuando fsp o fosc = 250KHz".  Qu√© tipo de "fsp o fosc" se encuentra realmente en controladores espec√≠ficos, eran demasiado flojos para escribir, pero en cualquier caso, incluso si es megahercio, el retraso para este comando deber√≠a ser significativo (y el autor de LiquidCrystal lo menciona).  Sin embargo, en la pr√°ctica, resulta que el equipo de limpieza trabaja por s√≠ mismo si no hay demora en absoluto.  As√≠ que no lo entend√≠, pero actu√© seg√∫n la conocida regla de programaci√≥n: "funciona, ¬°no lo toques!". <br></div></div><br>  Ahora, finalmente, tratemos con el modo gr√°fico. <br><br><h3>  El modo gr√°fico en pantallas de texto WEH001602 </h3><br>  Para empezar, intent√© cambiar la pantalla de texto que ten√≠a WEH001602BG a modo gr√°fico.  Tenga en cuenta que las pantallas gr√°ficas de 100x16 y texto (configuraci√≥n de 20x2, 16x2 solo tienen menos puntos horizontales) tienen matrices id√©nticas, solo las pantallas de texto est√°n separadas por intervalos en familiaridad.  Esto limita severamente el uso del modo gr√°fico en pantallas de texto, e incluso m√°s modo de texto en gr√°ficos.  Pero para probar c√≥mo funciona, puede usar cualquiera de ellos. <br><br>  La pantalla junto con el DS1307 se conect√≥ al Arduino Nano de acuerdo con el siguiente esquema: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/606/8e2/216/6068e2216b082857a72cd76f322628e3.png" width="600" alt="imagen"><br><br>  Seg√∫n el mismo esquema, conectaremos pantallas gr√°ficas en el futuro.  El color gris en el diagrama muestra la conexi√≥n de la segunda pantalla, si es necesario. <br><br>  Para cambiar al modo gr√°fico, puede usar el procedimiento mejorado de la secci√≥n anterior, pero una funci√≥n simple de un solo comando funciona: <br><pre> <code class="hljs cs">. . . . . <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_SETGRAPHICMODE 0x1f LiquidCrystal lcd(9, 4, 8, 7, 6, 5); void setGraphicMode(){ lcd.command(LCD_SETGRAPHICMODE); } . . . . .</span></span></code> </pre> <br>  No necesitamos ninguna tabla rusa aqu√≠, por lo tanto, se utiliza el LiquidCrystal est√°ndar (no enderezado), que funciona perfectamente en modo gr√°fico.  Para no perder el tiempo con la depuraci√≥n de todas las opciones de la biblioteca, en el caso de que el texto y las pantallas gr√°ficas se incluyan en paralelo, entonces para cada uso mi propia biblioteca (para texto actualizado Rus_OLED, para gr√°ficos normales).  En este caso, la conexi√≥n todav√≠a se puede hacer a las mismas patas del controlador, con la excepci√≥n de los pines de salida E, de acuerdo con el diagrama anterior. <br><br>  Adem√°s, utilic√© parcialmente los logros del autor de la biblioteca WinstarOLED mencionada (en s√≠ mismo, este complemento para LuquidCrystal es, en mi opini√≥n, incompleto, y no es pr√°ctico usarlo como).  Introdujo una funci√≥n conveniente para configurar el cursor gr√°fico (aqu√≠ se solucion√≥ el error original con respecto al valor <i>x</i> m√°ximo): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | x); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | y); } }</code> </pre> <br>  La constante LCD_SETDDRAMADDR se define en la biblioteca LiquidCrystal.  Una pantalla de 100x16, como una pantalla de texto, se divide en dos l√≠neas, 0 y 1, porque <i>y</i> solo puede tomar dos valores aqu√≠.  Y la coordenada horizontal <i>x</i> var√≠a de 0 a 99. Se env√≠a un byte con el comando lcd.write (), cuyos bits individuales determinan las posiciones luminosas de la l√≠nea vertical con una longitud de 8 puntos.  La posici√≥n m√°s a la izquierda en la l√≠nea superior tiene coordenadas 0,0, la m√°s a la derecha en la parte inferior - 99,1.  Adem√°s, el punto m√°s bajo corresponder√° al bit menos significativo, y el punto m√°s bajo, el m√°s alto. <br><br>  Para la conveniencia de codificar im√°genes, dibuj√© una placa en la que puede crear r√°pidamente el c√≥digo deseado manualmente.  Para tablas de fuentes completas, por supuesto, es aconsejable usar editores especiales (hay al menos un mill√≥n de grados diferentes de actividad de aficionados), pero 10 d√≠gitos con el orden de bits deseado son m√°s r√°pidos de procesar manualmente, especialmente dado que las fuentes creadas autom√°ticamente a menudo todav√≠a tienen que terminarse a mano.  De acuerdo con lo anterior, un glifo, por ejemplo, la fuente n√∫mero 2 10x16 se codificar√° de la siguiente manera: <br><br><img src="http://revich.lib.ru/AVR/TableCod2.png" width="400" alt="imagen"><br><br>  Todo esto est√° escrito en una matriz bidimensional de la forma: <br><pre> <code class="hljs markdown">const byte Data2[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">10</span></span>]={{0x06,0x07,0x03,0x03,0x03,0x83,0xc3,0x63,0x3f,0x1e}, {0xf0,0xf8,0xcc,0xc6,0xc3,0xc1,0xc0,0xc0,0xc0,0xc0}};</code> </pre> <br>  Para cada d√≠gito 0-9, se crea una matriz de este tipo: Data0, Data1, Data2, etc.  Para los relojes, adem√°s de los n√∫meros, tambi√©n necesitar√° un doble punto.  Se puede acortar: <br><pre> <code class="hljs markdown">const byte DataDP[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x70,0x70}, {0x1c,0x1c}};// </code> </pre> <br>  Como el controlador no sabe c√≥mo "parpadear" en el modo gr√°fico, es necesario parpadear mediante programaci√≥n el colon.  Puede extinguir un punto doble simplemente mostrando ceros en las posiciones correspondientes, pero por uniformidad hice una matriz separada <br><pre> <code class="hljs markdown">const byte DataDPclr[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x00,0x00}, {0x00,0x00}};// . </code> </pre> <br>  Para mostrar cada d√≠gito y por separado para un punto doble, se escribe una funci√≥n separada: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // ‚Äú<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} }</code> </pre> <br>  Todas las funciones son iguales, pero usan diferentes matrices y, para un punto doble, tambi√©n se usan otros l√≠mites del bucle.  Result√≥ no ser demasiado econ√≥mico en t√©rminos de la cantidad de c√≥digo (ver m√°s sobre esto m√°s adelante), pero es claro y f√°cil de corregir errores.  Los espacios entre los caracteres se tienen en cuenta en la etapa de salida, lo que indica la posici√≥n correspondiente (la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca RTClib</a> se usa para leer el reloj): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { DateTime clock = RTC.now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()!=old_second) { uint8_t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()%<span class="hljs-number"><span class="hljs-number">2</span></span>) drawDP(<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drawDPclr(<span class="hljs-number"><span class="hljs-number">24</span></span>); old_second=clock.second(); }//<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clocksecond }</code> </pre> <br>  Diez d√≠gitos de 20 bytes cada uno ocupar√°n 200 bytes en la memoria, aproximadamente el 10% de su volumen (y la fuente ancha es 16x16, como en el ejemplo a continuaci√≥n, y todo el 16%).  Una fuente monoling√ºe completa de este tama√±o, junto con n√∫meros, sin tener en cuenta todo tipo de signos de puntuaci√≥n y especiales.  caracteres, contiene de 62 (ingl√©s) a 74 (ruso sin E) caracteres, el valor ocupar√° casi la mitad de la RAM ATmega328.  Por lo tanto, los trucos con matrices y funciones de salida por separado para cada personaje deber√°n cancelarse y hacer lo que se espera.  Es decir, las fuentes deben dejarse en la memoria del programa y descargarse a trav√©s de PROGMEM, y todos los patrones de glifos deben organizarse como una sola matriz de fuentes y cargarse para la salida por n√∫mero de s√≠mbolo en una sola tabla.  De lo contrario, no habr√° suficiente memoria y el c√≥digo del programa se inflar√° a un volumen incontrolable.  Aqu√≠ no nos detendremos en esto, porque en nuestros ejemplos simples no se requiere todo esto; cada vez nos limitaremos a un peque√±o n√∫mero estrictamente necesario de caracteres. <br><br>  Debido al gran tama√±o del texto completo del boceto GraphicOLED_DC1307, no lo traigo; puedes descargarlo <a href="">aqu√≠</a> .  La funci√≥n resetOLED se guarda en el texto, que distorsiona la potencia de la pantalla cuando el controlador se reinicia (a trav√©s de pwrPin D2), pero nunca se ha necesitado, por lo que se puede quitar de forma segura.  El resultado del programa se muestra en la foto: <br><br><img src="http://revich.lib.ru/AVR/WEH1602_clock.jpg" width="600" alt="imagen"><br><br>  Desafortunadamente, se excluye la permanencia simult√°nea en modo texto y gr√°fico, por lo tanto, si desea utilizar el espacio restante, deber√° dibujar sus propias fuentes (queda espacio para aproximadamente 7 caracteres de fuente 5x7 en cada l√≠nea). <br><br><h3>  Pantalla gr√°fica WEG010016A </h3><br>  Cuando, finalmente, llegaron las pantallas gr√°ficas ordenadas WEG010016AL, comenc√© tratando de ingresarlas en modo de texto para ver qu√© suced√≠a. <br><br>  Para verificar el modo de texto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> se descarg√≥ un programa para simular una pantalla de reloj de calendario con un sensor de temperatura externo, descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en una publicaci√≥n anterior</a> .  El resultado me hizo recordar que diferentes pantallas Winstar pueden orientarse de manera diferente con respecto al conector (en este caso, el WEG010016A tiene un conector en la parte superior, para el texto WEH001602B, que usamos arriba, en la parte inferior, y para el tipo C en el lado): <br><br><img src="http://revich.lib.ru/AVR/WEG10016_test.jpg" width="600" alt="imagen"><br><br>  Nos ocuparemos m√°s de la orientaci√≥n de la pantalla, pero por ahora veremos qu√© sucedi√≥.  Pero no result√≥ nada bueno: el modo de texto (por supuesto, equipado con una muleta, que se discuti√≥ al principio del art√≠culo) funciona a la perfecci√≥n, pero en la pr√°ctica no tiene sentido debido a la falta de espacios entre los caracteres.  Por lo tanto, no nos detendremos en √©l, sino que procederemos a considerar el modo gr√°fico. <br><br>  Los procedimientos de instalaci√≥n en modo gr√°fico en s√≠ son los mismos que los discutidos anteriormente para la versi√≥n de texto.  Queda por tratar con la tapa de la pantalla si tiene un conector en la parte superior de la pantalla.  Por supuesto, puede voltear la pantalla, pero la posici√≥n con el conector hacia abajo me parece m√°s natural y conveniente.  Adem√°s, cuando use un tipo con un conector en el lateral, es posible que deba orientar el conector hacia la derecha en lugar de hacia la izquierda.  Para la orientaci√≥n "al rev√©s", es necesario transformar la imagen, es decir, intercambiar las primeras y √∫ltimas posiciones horizontales, l√≠neas, y tambi√©n invertir el orden de los bits en los bytes que componen la matriz (el bit menos significativo corresponder√° al punto inferior). <br><br>  Como ya hab√≠a pintado diez d√≠gitos para el caso anterior, para la √∫ltima tarea quedaba por introducir el procedimiento de reversi√≥n del programa: <br><pre> <code class="hljs matlab">byte reverse(byte x) { byte result=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)) { result |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">7</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Puede cambiar el orden de las coordenadas horizontales y las l√≠neas verticales haciendo cambios en la funci√≥n setGraphicCursor: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">99</span></span>-x)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | (<span class="hljs-number"><span class="hljs-number">1</span></span>-y)); } }</code> </pre> <br>  Las funciones de salida de la matriz de cada d√≠gito permanecen iguales, solo se agrega la inversi√≥n de bits: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} }</code> </pre> <br>  El boceto completo de la salida del reloj GraphicOLED_DC1307_100x16 se puede descargar <a href="">desde aqu√≠</a> , y el resultado para la pantalla WEG010016AL se muestra en la foto: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_clock.jpg" width="600" alt="imagen"><br><br>  Pero en esta foto, una fuente de un tipo diferente (16x16) en la pantalla WEG010016CG (la pantalla tambi√©n est√° al rev√©s): <br><br><img src="http://revich.lib.ru/AVR/WEG10016CG_clock.jpg" width="600" alt="imagen"><br><br>  Si vuelve a crear la fuente cambiando el orden de los bits manualmente, entonces no hay necesidad de hacer lo contrario y el programa se ejecutar√° m√°s r√°pido (aunque no hay retrasos notables en el ojo).  Pero el procedimiento de cambio de bits dado es √∫til en cualquier caso: para mostrar varias im√°genes.  Por ejemplo, desde una flecha que apunta hacia arriba y hacia la derecha, puede obtener cuatro direcciones a la vez mediante programaci√≥n. <br><div class="spoiler">  <b class="spoiler_title">Dibujo de flecha</b> <div class="spoiler_text">  Imagen y c√≥digo de flecha (las coordenadas y los bits en la tabla se invierten de acuerdo con la posici√≥n inferior del conector para la pantalla WEG010016AL, ver arriba): <br><br><img src="http://revich.lib.ru/AVR/TableCodArray.png" alt="imagen"><br><pre> <code class="hljs markdown">const byte DataATR[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">8</span></span>]={{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x01,0x02,0x04,0x28,0x30,0x78,0x60,0x80}};</code> </pre> <br>  Oportunidades para flechas multidireccionales <br><pre> <code class="hljs powershell">. . . . . void drawSW (byte x) //   (  ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} } void drawNW (byte x) //   (  ) {//   : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} } void drawNE (byte x) //   (  ) {//  ,    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b);} } void drawSE (byte x) //   (  ) {//   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]);} } . . . . .</code> </pre> </div></div><br>  La foto a continuaci√≥n muestra el resultado de un programa en blanco para mostrar el sensor de velocidad y direcci√≥n del viento.  Como puede ver, result√≥ muy simple implementar fuentes de diferentes tama√±os en una l√≠nea junto con im√°genes: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_wind.jpg" width="600" alt="imagen"><br><br>  En conclusi√≥n, agregar√© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> hay una biblioteca muy interesante para trabajar con WS0010 en modos gr√°ficos y de texto usando SPI.  En el texto, copia principalmente Crystal Crystal (¬øy en qu√© m√°s se te ocurre?), Y en el gr√°fico tiene las funciones de dibujar primitivas gr√°ficas, fuentes incorporadas (gruesas, como las m√≠as, y las habituales 5x7) y mucho m√°s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es402517/">https://habr.com/ru/post/es402517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es402505/index.html">La realidad aumentada comenz√≥ a aplicarse masivamente en la industria estadounidense.</a></li>
<li><a href="../es402507/index.html">La gesti√≥n del patrimonio personal como derecho humano fundamental</a></li>
<li><a href="../es402509/index.html">La navegaci√≥n por sat√©lite deshabilita el enrutamiento</a></li>
<li><a href="../es402511/index.html">Como naci√≥ la vida</a></li>
<li><a href="../es402515/index.html">Braun Oral-B Genius 9000: cuando el cepillo da consejos a trav√©s de un tel√©fono inteligente</a></li>
<li><a href="../es402521/index.html">El WiFi infrarrojo es 17 veces m√°s r√°pido de lo normal, pero unidireccional</a></li>
<li><a href="../es402523/index.html">"Mundo delgado". Capitulo 9</a></li>
<li><a href="../es402525/index.html">Por qu√© OneDrive se ralentiz√≥ en Linux</a></li>
<li><a href="../es402527/index.html">Cuatro a treinta y dos</a></li>
<li><a href="../es402529/index.html">¬øPor qu√© es mejor con una camiseta de cardio que sin ella? Algunas palabras sobre la ropa inteligente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>