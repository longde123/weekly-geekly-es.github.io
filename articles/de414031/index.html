<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíä üö£üèΩ üç´ Nach dem Treffen "PostgreSQL 11 New Features" üëêüèΩ üë®üèª ü•ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir √ºber die wichtigsten Funktionen von PostgreSQL 11 sprechen. Warum nur √ºber sie - weil nicht jeder einige Funktionen ben√∂tigt, haben w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nach dem Treffen "PostgreSQL 11 New Features"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/414031/">  Heute werden wir √ºber die wichtigsten Funktionen von PostgreSQL 11 sprechen. Warum nur √ºber sie - weil nicht jeder einige Funktionen ben√∂tigt, haben wir uns f√ºr die beliebtesten entschieden. <br><br><h3>  Inhalt </h3><br><img src="https://habrastorage.org/webt/3l/ef/wk/3lefwko0funvsqwyvgcaqtf7ory.png" align="right" width="300"><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jit-Zusammenstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Partitionierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deckungsindizes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP GiST</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WAL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicherung und Replikation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºr dba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallele Ausf√ºhrung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fensterfunktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√Ñnderungen bei der Volltextsuche</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json (b) und Volltext</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL / * -Verfahren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PSQL-Verbesserungen</a> </li></ul><a name="habracut"></a><br><a name="1"></a><h3>  Jit-Zusammenstellung </h3><br>  PostgreSQL hat endlich die JIT-Kompilierung eingef√ºhrt, dh das Kompilieren von Abfragen in Bin√§rcode.  Kompilieren Sie dazu PostgreSQL mit Unterst√ºtzung f√ºr die JIT-Kompilierung <code>(Compile time 1 (--with-llvm))</code> .  Gleichzeitig muss die Maschine eine LLVM-Version von mindestens 3.9 haben. <br><br>  Was kann JIT beschleunigen? <br><br><ul><li>  Abfragen mit der WHERE-Klausel, dh alles, was nach diesem Schl√ºsselwort steht.  Dies ist nicht immer notwendig, aber die Gelegenheit ist n√ºtzlich. </li><li>  Berechnung der Zielliste: In der PostgreSQL-Terminologie ist dies alles, was zwischen select und from liegt. </li><li>  Aggregate. </li><li>  Konvertieren Sie Datens√§tze von einer Ansicht in eine andere (Projektion).  Wenn Sie beispielsweise Join auf zwei Tabellen anwenden, ist das Ergebnis ein neues Tupel, das Felder aus beiden Tabellen enth√§lt. </li><li>  Tupel verformt sich.  Eines der Probleme einer Datenbank, zumindest in relationalen Kleinbuchstaben, besteht darin, ein Feld aus einem Datensatz auf der Festplatte abzurufen.  Schlie√ülich kann es null geben, sie haben unterschiedliche Datens√§tze und im Allgemeinen ist dies nicht die billigste Operation. </li></ul><br>  <code>Compile time 2</code> bedeutet, dass JIT nicht verwendet wird.  In PostgreSQL gibt es einen Moment der Abfrageplanung, in dem das System entscheidet, was JIT wert ist und was nicht.  Zu diesem Zeitpunkt wird es JITs und dann wird der Executor so ausgef√ºhrt, wie er ist. <br><br>  JIT ist steckbar.  Standardm√§√üig funktioniert es mit LLVM, Sie k√∂nnen jedoch jede andere JIT verbinden. <br><br><img src="https://habrastorage.org/webt/hm/pk/lk/hmpklkbpxsi1qzqyvyx3drcl6_y.png" width="600"><br><br>  Wenn Sie PostgreSQL ohne JIT-Unterst√ºtzung kompiliert haben, funktioniert das allererste Setup nicht.  Implementierte Optionen f√ºr Entwickler, es gibt Einstellungen f√ºr einzelne JIT-Funktionen. <br><br>  Der n√§chste subtile Punkt bezieht sich auf jit_above_cost.  JIT selbst ist nicht kostenlos.  Daher verwendet PostgreSQL standardm√§√üig die JIT-Optimierung, wenn die Kosten einer Abfrage 100.000 bedingte Papageien √ºberschreiten, in denen Erkl√§rungen, Analysen usw. gemessen werden.  Dieser Wert wird zuf√§llig ausgew√§hlt, achten Sie also darauf. <br><br>  Aber nicht immer nach dem Einschalten von JIT funktioniert alles sofort.  Normalerweise experimentiert jeder mit JIT mithilfe der Tabelle select * from, bei der die Abfrage id = 600 ist, und sie schlagen fehl.  Wahrscheinlich ist es notwendig, die Anfrage irgendwie zu komplizieren, und dann generiert jeder eine riesige Datenbank und erstellt die Anfrage.  Infolgedessen beruht PostgreSQL auf den Funktionen der Festplatte, da die Kapazit√§t f√ºr gemeinsam genutzte Puffer und Caches fehlt. <br><br>  Hier ist ein v√∂llig abstraktes Beispiel.  Es gibt 9 Nullfelder mit unterschiedlichen Frequenzen, sodass Sie den Effekt der Tupelverformung feststellen k√∂nnen. <br><br> <code>select i as x1, <br> case when i % 2 = 0 then i else null end as x2, <br> case when i % 3 = 0 then i else null end as x3, <br> case when i % 4 = 0 then i else null end as x4, <br> case when i % 5 = 0 then i else null end as x5, <br> case when i % 6 = 0 then i else null end as x6, <br> case when i % 7 = 0 then i else null end as x7, <br> case when i % 8 = 0 then i else null end as x8, <br> case when i % 9 = 0 then i else null end as x9 <br> into t <br> from generate_series(0, 10000000) i; <br> <br> vacuum t; <br> analyze t;</code> <br> <br>  PostgreSQL bietet viele M√∂glichkeiten. Um die Vorteile von JIT zu erkennen, deaktivieren Sie die ersten beiden Zeilen, um nicht zu st√∂ren, und setzen Sie die Schwellenwerte zur√ºck. <br><br> <code>set max_parallel_workers=0; <br> set max_parallel_workers_per_gather=0; <br> set jit_above_cost=0; <br> set jit_inline_above_cost=0; <br> set jit_optimize_above_cost=0;</code> <br> <br>  Hier ist die Anfrage selbst: <br><br> <code>set jit=off; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000; <br> <br> set jit=on; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000;</code> <br> <br>  Und hier ist das Ergebnis: <br><br> <code>Planning Time: 0.71 ms <br> Execution Time: <b>1986.323</b> ms <br> <br> VS <br> <br> Planning Time: 0.060 ms <br> JIT: <br> Functions: 4 <br> Generation Time: 0.911 ms <br> Inlining: true <br> Inlining Time: 23.876 ms <br> Optimization: true <br> Optimization Time: 41.399 ms <br> Emission Time: 21.856 ms <br> Execution Time: <b>949.112</b> ms</code> <br> <br>  JIT hat dazu beigetragen, die Anfrage um die H√§lfte zu beschleunigen.  Die Planungszeit ist ungef√§hr gleich, aber dies ist h√∂chstwahrscheinlich das Ergebnis des Zwischenspeicherns von PostgreSQL. Ignorieren Sie es also. <br><br>  Zusammenfassend dauerte die JIT-Kompilierung etwa 80 ms.  Warum ist JIT nicht kostenlos?  Bevor Sie die Anforderung ausf√ºhren, m√ºssen Sie sie kompilieren. Dies nimmt auch Zeit in Anspruch.  Und drei Gr√∂√üenordnungen mehr als geplant.  Kein teures Vergn√ºgen, aber es zahlt sich aufgrund der L√§nge der Ausf√ºhrung aus. <br><br>  Auf diese Weise k√∂nnen Sie JIT verwenden, obwohl dies nicht immer von Vorteil ist. <br><br><a name="2"></a><h3>  Partitionierung </h3><br>  Wenn Sie auf die Partitionierung in PostgreSQL geachtet haben, haben Sie wahrscheinlich bemerkt, dass sie dort f√ºr die Show erstellt wurde.  In Version 10 verbesserte sich die Situation geringf√ºgig, als eine deklarative Deklaration von Partitionen (Abschnitten) erschien.  Auf der anderen Seite blieb alles innen gleich und funktionierte ungef√§hr gleich wie in fr√ºheren Versionen, das hei√üt schlecht. <br>  In vielerlei Hinsicht wurde dieses Problem durch das Modul pg_pathman gel√∂st, das es erm√∂glichte, mit Abschnitten zu arbeiten und sie zur Laufzeit optimal genug abzuschneiden. <br><br>  In Version 11 wurde die Partitionierung erheblich verbessert: <br><br><ul><li>  Erstens kann die Partitionstabelle einen Prim√§rschl√ºssel haben, der den Partitionsschl√ºssel enthalten muss.  Tats√§chlich ist dies entweder ein Halbprim√§rschl√ºssel oder ein Prim√§rhalbschl√ºssel.  Leider k√∂nnen Sie keinen Fremdschl√ºssel darauf erstellen.  Ich hoffe, dass dies in Zukunft behoben wird. </li><li>  Auch jetzt ist es m√∂glich, nicht nur nach Bereich, sondern auch nach Liste und Hash zu partitionieren.  Der Hash ist ziemlich primitiv, der Rest des Ausdrucks wird daf√ºr genommen. </li><li>  Beim Aktualisieren wird die Linie zwischen Abschnitten verschoben.  Fr√ºher mussten Sie einen Trigger schreiben, jetzt erfolgt dies automatisch. </li></ul><br>  Die gro√üe Frage ist: Wie viele Abschnitte kann ich haben?  Ehrlich gesagt, mit einer gro√üen Anzahl von Abschnitten (Tausende und Zehntausende) funktioniert die Funktion nicht gut.  Pg_pathman macht es besser. <br><br>  Standardm√§√üig werden auch Abschnitte erstellt.  Auch in pg_pathman k√∂nnen Sie Abschnitte automatisch erstellen, was bequemer ist.  Hier f√§llt alles, was nicht irgendwohin geschoben werden konnte, in den Abschnitt.  Wenn dies in einem realen System standardm√§√üig der Fall ist, dann bekommen Sie nach einiger Zeit ein solches Durcheinander, das Sie dann qu√§len, um zu harken. <br><br>  PostgreSQL 11 kann jetzt die Partitionierung optimieren, wenn zwei Tabellen durch einen Partitionsschl√ºssel verbunden sind und die Partitionierungsschemata √ºbereinstimmen.  Dies wird durch einen speziellen Parameter gesteuert, der standardm√§√üig deaktiviert ist. <br><br>  Sie k√∂nnen Aggregate f√ºr jeden Abschnitt separat berechnen und dann addieren.  Schlie√ülich k√∂nnen Sie einen Index f√ºr die √ºbergeordnete partitionierte Tabelle erstellen. Anschlie√üend werden lokale Indizes f√ºr alle damit verbundenen Tabellen erstellt. <br><br>  Im Abschnitt ‚ÄûWas ist neu?‚Äú Wird eine wunderbare Sache erw√§hnt - die M√∂glichkeit, Abschnitte bei der Ausf√ºhrung einer Anforderung wegzuwerfen.  Lassen Sie uns √ºberpr√ºfen, wie es funktioniert.  Das Ergebnis ist eine solche Tabelle: <br><br><img src="https://habrastorage.org/webt/pd/yq/og/pdyqogkeovn-af_egj5u8wlszne.png" width="500"><br><br>  Wir machen einen Typ und eine Tabelle aus zwei Spalten mit einem Prim√§rschl√ºssel, mit einer Bigserial-Spalte, f√ºgen Sie die Daten ein.  Wir erstellen die zweite Tabelle, die partitioniert wird und eine Kopie der ersten ist.  F√ºgen Sie der partitionierten Tabelle den Prim√§rschl√ºssel hinzu. <br><br><img src="https://habrastorage.org/webt/in/5h/gr/in5hgrummalku8i2gfizbjbt3hm.png" width="500"><br><br>  Die Tabelle besteht aus zwei Arten von Eintr√§gen: "weibliche Kinderm√§dchen" und "m√§nnliche Fahrer".  Und es wird eine Fahrerin geben.  Wir machen zwei Abschnitte, teilen durch Liste, f√ºgen den Prim√§rschl√ºssel hinzu und f√ºgen alle Daten aus der Tabelle ein, in der all dies generiert wird.  Das Ergebnis war v√∂llig uninteressant: <br><br><img src="https://habrastorage.org/webt/r5/st/ax/r5staxao_opewadzu9wavch_w6w.png"><br><br>  Achten Sie auf die Anfrage.  Wir w√§hlen alles aus einer nicht partitionierten Tabelle aus und stellen eine Verbindung zu einer partitionierten Tabelle her.  Wir nehmen ein kleines St√ºck und w√§hlen nur einen Typ, sie gehen durch einen.  Wir geben an, dass die Oss-Spalte einen Wert haben sollte.  Es stellt sich eine Auswahl solider Treiber heraus. <br><br>  Bei der Ausf√ºhrung deaktivieren wir speziell die Parallelisierung, da PostgreSQL 11 standardm√§√üig sehr aktiv mehr oder weniger komplexe Abfragen parallelisiert.  Wenn wir uns den Ausf√ºhrungsplan ansehen (Analyse erkl√§ren), dann ist ersichtlich, dass das System die Daten in beiden Abschnitten hinzugef√ºgt hat: im Kinderm√§dchen und in den Fahrern, obwohl die Kinderm√§dchen nicht da waren.  Es gab keine Aufrufe an den Puffer.  Zeitaufwand, verwendete Bedingung, obwohl PostgreSQL alles herausfinden konnte.  Das hei√üt, die Partitionseliminierungsdeklaration funktioniert nicht sofort.  Vielleicht wird dies in den n√§chsten Builds korrigiert.  In diesem Fall funktioniert das Modul pg_pathman in diesem Fall problemlos. <br><br><a name="3"></a><h3>  Indizes </h3><br><ul><li>  Gebotsoptimierung auf monotone Weise, d. H. B-Baum.  Jeder wei√ü, dass das Einf√ºgen von monoton wachsenden Daten nicht sehr schnell erfolgt.  Jetzt kann PostgreSQL die Endseite auf besondere Weise zwischenspeichern und nicht mehr vom Stamm bis zum Einf√ºgen.  Dies beschleunigt die Arbeit erheblich. </li><li>  PostgreSQL 10 erm√∂glichte die Verwendung eines Hash-Index, da WAL (Write Ahead-Protokoll) verwendet wurde.  Zuvor haben wir den Wert erhalten, die Seite entsperrt und den Wert zur√ºckgegeben.  F√ºr den n√§chsten Wert mussten Sie die Seite erneut blockieren, zur√ºckkehren, entsperren und so weiter.  Jetzt ist der Hash viel schneller geworden.  Sie k√∂nnen jeweils eine Seite blockieren, um einen Datensatz aus einem Hash-Index abzurufen, alle Werte von dort zur√ºckzugeben und ihn zu entsperren.  Jetzt ist es f√ºr HASH, GiST und GIN implementiert.  Dies wird voraussichtlich in Zukunft f√ºr SP-GiST implementiert.  F√ºr BRIN mit seiner Min / Max-Logik ist dies jedoch grunds√§tzlich nicht m√∂glich. </li><li>  Wenn Sie fr√ºher Funktionsindizes erstellt haben, wurde das HOT-Update (Heap Only Tuple) effektiv deaktiviert.  Wenn ein Datensatz in PostgreSQL aktualisiert wird, wird tats√§chlich eine neue Kopie erstellt. Dazu muss in alle Indizes in der Tabelle eingef√ºgt werden, damit der neue Wert auf das neue Tupel verweist.  Eine solche Optimierung ist seit langem implementiert: Wenn das Update keine Felder √§ndert, die nicht in den Indizes enthalten sind, und auf derselben Seite freier Speicherplatz vorhanden ist, werden die Indizes nicht aktualisiert, und in der alten Version von Tupel wird ein Zeiger auf die neue Version gesetzt.  Auf diese Weise k√∂nnen Sie die Schwere des Problems mit Updates etwas verringern.  Eine solche Optimierung funktionierte jedoch √ºberhaupt nicht, wenn Sie Funktionsindizes hatten.  In PostgreSQL 11 begann es zu funktionieren.  Wenn Sie einen Funktionsindex erstellt und ein Tupel aktualisiert haben, das nicht √§ndert, wovon der Funktionsindex abh√§ngt, funktioniert das HOT-Update. </li></ul><br><a name="4"></a><h3>  Deckungsindizes </h3><br>  Diese Funktionalit√§t wurde vor drei Jahren von PostgresPro implementiert, und PostgreSQL hat die ganze Zeit versucht, sie hinzuzuf√ºgen.  Durch das Abdecken von Indizes k√∂nnen Sie dem eindeutigen Index direkt im Indextupel zus√§tzliche Spalten hinzuf√ºgen. <br><br>  Warum?  Jeder liebt den Nur-Index-Scan f√ºr seine schnelle Arbeit.  Hierzu werden bedingt ‚Äûabdeckende‚Äú Indizes erstellt: <br><br><img src="https://habrastorage.org/webt/ep/s7/vf/eps7vfc5hddmnsu6occowc250kw.png" width="600"><br><br>  Gleichzeitig m√ºssen Sie die Einzigartigkeit bewahren.  Daher werden zwei Indizes erstellt, schmal und breit. <br>  Der Nachteil ist, dass Sie beim Anwenden von Vakuum, Einf√ºgen oder Aktualisieren einer Tabelle beide Indizes aktualisieren m√ºssen.  Das Einf√ºgen in einen Index ist also eine langsame Operation.  Mit dem Deckungsindex kann nur ein Index verwaltet werden. <br><br>  Es stimmt, er hat einige Einschr√§nkungen.  Genauer gesagt, die Vorteile, die m√∂glicherweise nicht sofort verstanden werden.  Die Spalten c und d im ersten Erstellungsindex m√ºssen keine Skalartypen sein, f√ºr die ein B-Tree-Index definiert ist.  Das hei√üt, sie haben nicht unbedingt einen mehr-weniger-Vergleich.  Es k√∂nnen Punkte oder Polygone sein.  Das einzige ist, dass das Tupel weniger als 2,7 KB gro√ü sein sollte, da der Index kein Toasten enth√§lt, aber Sie k√∂nnen in das passen, was nicht verglichen werden kann. <br><br>  Innerhalb des Index mit diesen garantierten Spalten werden bei der Suche jedoch keine Berechnungen durchgef√ºhrt.  Dies sollte durch einen Filter erfolgen, der √ºber dem Index steht.  Berechnen Sie es einerseits innerhalb des Index, andererseits ist dies ein zus√§tzlicher Funktionsaufruf.  Aber alles ist nicht so be√§ngstigend, wie es scheint. <br><br>  Au√üerdem k√∂nnen Sie diese abgedeckten Spalten zum Prim√§rschl√ºssel hinzuf√ºgen. <br><br><a name="5"></a><h3>  SP GiST </h3><br>  Nur wenige Leute verwenden diesen Index, weil er ziemlich spezifisch ist.  Trotzdem wurde es m√∂glich, nicht ganz das darin zu speichern, was eingef√ºgt wurde.  Dies bezieht sich auf Verlustindex, Komprimierung.  Nehmen Sie als Beispiel Polygone.  Stattdessen wird ein Begrenzungsrahmen in den Index eingef√ºgt, dh das minimale Rechteck, das das gew√ºnschte Polygon enth√§lt.  In diesem Fall stellen wir das Rechteck als Punkt im vierdimensionalen Raum dar und arbeiten dann mit dem klassischen Quad3 im vierdimensionalen Raum. <br><br>  Auch f√ºr den SP-GiST wurde die Operation "Pr√§fixsuche" eingef√ºhrt.  Es gibt true zur√ºck, wenn eine Zeile ein Pr√§fix einer anderen ist.  Sie haben es nicht nur so eingef√ºhrt, sondern f√ºr eine solche Anfrage mit Unterst√ºtzung f√ºr SP-GiST. <br><br> <code>SELECT * FROM table WHERE c ^@ ‚Äûabc‚Äú</code> <br> <br>  Im B-Tree gibt es eine Grenze von 2,7 Kb pro Zeile, SP-GiST jedoch nicht.  Richtig, PostgreSQL hat eine Einschr√§nkung: Ein einzelner Wert darf 1 GB nicht √ºberschreiten. <br><br><a name="6"></a><h3>  Leistung </h3><br><ul><li>  <b>Es wurde nur ein Bitmap-Index-Scan angezeigt</b> .  Es funktioniert genauso wie der klassische Index-Scan, kann jedoch keine Reihenfolge garantieren.  Daher gilt es nur f√ºr einige Aggregate wie count (*), da Bitmap keine Felder vom Index zum Executor √ºbertragen kann.  Er kann nur die Tatsache einer Aufzeichnung melden, die die Bedingungen erf√ºllt. </li><li>  Die n√§chste Neuerung ist die <b>Aktualisierung der Freiraumkarte w√§hrend der Anwendung von Vakuum</b> .  Leider glaubt keiner der Entwickler von Systemen, die mit PostgreSQL arbeiten, dass es notwendig ist, am Ende der Tabelle zu l√∂schen, da sonst L√∂cher und nicht zugewiesener Speicherplatz angezeigt werden.  Um dies zu verfolgen, haben wir FSM implementiert, mit dem wir die Tabelle nicht vergr√∂√üern, sondern Tupel in Hohlr√§ume einf√ºgen k√∂nnen.  Fr√ºher wurde dies mit Vakuum gemacht, aber am Ende.  Und jetzt kann Vakuum dies in diesem Prozess tun, und in stark belasteten Systemen hilft es, die Tischgr√∂√üe unter Kontrolle zu halten. </li><li>  <b>M√∂glichkeit, den Index-Scan w√§hrend der Vakuumausf√ºhrung zu √ºberspringen</b> .  Tatsache ist, dass alle PostgreSQL-Indizes gem√§√ü der Datenbanktheorie als sekund√§r bezeichnet werden.  Dies bedeutet, dass Indizes au√üerhalb der Tabelle gespeichert werden und Zeiger von dort zu ihr f√ºhren.  Mit dem Nur-Index-Scan k√∂nnen Sie diesen Sprung nicht auf Zeiger ausf√ºhren, sondern direkt aus dem Index entnehmen.  Vakuum, das Datens√§tze l√∂scht, kann sie jedoch nicht im Index anzeigen und entscheiden, ob sie gel√∂scht werden sollen oder nicht, einfach weil der Index keine solchen Daten enth√§lt.  Daher wird das Vakuum immer in zwei Durchg√§ngen durchgef√ºhrt.  Zuerst geht er die Tabelle durch und findet heraus, was er l√∂schen muss.  Dann geht es zu den an diese Tabelle angeh√§ngten Indizes, l√∂scht die Datens√§tze, die sich auf die gefundenen beziehen, kehrt zur Tabelle zur√ºck und l√∂scht, was sie wollte.  Und die Phase des Wechsels zu den Indizes ist nicht immer erforderlich. <br><br>  Wenn seit dem letzten Vakuum kein L√∂schen oder Aktualisieren stattgefunden hat, haben Sie keine toten Datens√§tze, Sie m√ºssen sie nicht l√∂schen.  In diesem Fall k√∂nnen Sie nicht zum Index wechseln.  Es gibt zus√§tzliche Feinheiten, b-tree l√∂scht seine Seiten nicht sofort, sondern in zwei Durchg√§ngen.  Wenn Sie daher viele Daten in der Tabelle gel√∂scht haben, m√ºssen Sie Vakuum erzeugen.  Wenn Sie jedoch Speicherplatz in den Indizes freigeben m√∂chten, saugen Sie zweimal. <br><br>  Jemand wird √ºberrascht sein, in welcher Tabelle gab es kein L√∂schen oder Aktualisieren?  In der Tat besch√§ftigen sich viele damit, denken einfach nicht.  Hierbei handelt es sich nur um Anh√§nge-Tabellen, in denen beispielsweise Protokolle hinzugef√ºgt werden.  In ihnen ist die Entfernung √§u√üerst selten.  Dies spart erheblich die Dauer des Vakuums / Autovakuums, reduziert die Belastung der Festplatte, die Verwendung von Caches usw. </li><li>  <b>Gleichzeitiges Festschreiben wettbewerbsf√§higer Transaktionen</b> .  Dies ist keine Innovation, sondern eine Verbesserung.  Jetzt erkennt PostgreSQL, dass es jetzt festgeschrieben wird, und verz√∂gert das Festschreiben der aktuellen Transaktion und wartet auf den Rest der Festschreibungen.  Bitte beachten Sie, dass diese Funktion nur geringe Auswirkungen hat, wenn Sie einen kleinen Server mit 2 bis 4 Kernen haben. </li><li>  <b>postgres_fdw (Foreign Data Wrappers)</b> .  FDW ist eine M√∂glichkeit, eine externe Datenquelle so zu verbinden, dass sie wie ein echter Postkongress aussieht.  Mit postgres_fdw k√∂nnen Sie eine Tabelle von einer benachbarten Instanz mit Ihrer Instanz verbinden, und sie sieht fast wie eine echte aus.  Jetzt wurde eine der Einschr√§nkungen f√ºr das Aktualisieren und L√∂schen entfernt.  PostgreSQL kann oft erraten, dass Sie Rohdaten senden m√ºssen.  Die Ausf√ºhrung der Join-Anforderung ist recht einfach: Wir f√ºhren sie auf unserem Computer aus, ziehen die Tabelle mit FDW aus der Instanz heraus, ermitteln den ID-Prim√§rschl√ºssel, den wir l√∂schen m√ºssen, und wenden dann die Aktualisierung und / oder L√∂schung an, dh die Daten, die wir hin und her gehen .  Jetzt ist es m√∂glich zu tun.  Wenn sich die Tabellen auf verschiedenen Computern befinden, ist dies nat√ºrlich nicht so einfach, aber mit FDW k√∂nnen Sie die Remote-Maschine dazu bringen, Vorg√§nge auszuf√ºhren, und wir haben nur gewartet. </li><li>  <b>toast_tuple_target</b> .  Es gibt Situationen, in denen die Daten geringf√ºgig √ºber die Grenzen hinausgehen, nach denen ein Toasten erforderlich ist, das gleichzeitige Toasten solcher Werte jedoch nicht immer angenehm ist.  Angenommen, Sie haben ein Limit von 90 Bytes und m√ºssen 100 anpassen. Sie m√ºssen den Toast f√ºr 10 Bytes starten, sie separat hinzuf√ºgen. Wenn Sie dieses Feld ausw√§hlen, m√ºssen Sie zum Toastindex gehen, herausfinden, wo sich die erforderlichen Daten befinden, und zur Toasttabelle gehen. sammeln und geben. </li></ul><br>  Mit Hilfe der Feinabstimmung k√∂nnen Sie dieses Verhalten jetzt f√ºr die gesamte Datenbank oder eine separate Tabelle √§ndern, sodass f√ºr solche kleinen Exits kein Toast erforderlich ist.  Aber Sie m√ºssen verstehen, was Sie tun, ohne das wird nichts funktionieren. <br><br><a name="7"></a><h3>  WAL </h3><br><ul><li>  WAL (Write Ahead Log) ist ein Write Ahead Log.  Die Gr√∂√üe des WAL-Segments wird jetzt in initdb festgelegt.  Gott sei Dank, nicht beim Kompilieren. </li><li>  Die Logik hat sich ebenfalls ge√§ndert.  Zuvor wurde der Satz von WAL-Segmenten ab dem Zeitpunkt des vorletzten Kontrollpunkts und jetzt ab dem letzten gespeichert.  Dies kann die gespeicherte Datenmenge erheblich reduzieren.  Wenn Sie jedoch eine 1-TB-Datenbank haben und TPS = 1, dh eine Anforderung pro Sekunde, werden Sie den Unterschied nicht sehen. </li></ul><br><a name="8"></a><h3>  Sicherung und Replikation </h3><br><ul><li>  <b>Abschneiden wurde in der logischen Replikation angezeigt</b> .  Es war die letzte DML-Operation, die sich nicht in der logischen Replikation widerspiegelte.  Jetzt reflektiert. </li><li>  <b>In der logischen Replikation wurde eine Meldung zur Vorbereitung angezeigt</b> .  Jetzt k√∂nnen Sie die Vorbereitungstransaktion abfangen, eine zweiphasige Festschreibung bei der logischen Replikation.  Dies wird f√ºr die Konstruktion von Clustern implementiert - heterogen, homogen, sharded und nicht schattiert, Multimaster und so weiter. </li><li>  <b>Ausnahme von pg_basebackup tempor√§ren und nicht protokollierten Tabellen</b> .  Viele haben sich beschwert, dass pg_basebackup die aufgelisteten Tabellen enth√§lt.  Und ohne sie reduzieren wir die Gr√∂√üe des Backups.  Vorausgesetzt, Sie verwenden tempor√§re und nicht protokollierte Tabellen, ist diese Option f√ºr Sie ansonsten nutzlos. </li><li>  <b>Pr√ºfsummensteuerung bei der Streaming-Replikation (f√ºr Tabellen)</b> .  Auf diese Weise k√∂nnen Sie nachvollziehen, was mit Ihrem Replikat passiert ist.  Bisher ist die Funktion nur f√ºr Tabellen implementiert. </li><li>  <b>Es gab eine F√∂rderung der Positionen der Replikationssteckpl√§tze</b> .  Wie immer k√∂nnen Sie nur vorw√§rts und r√ºckw√§rts wickeln, wenn es eine WAL gibt.  Au√üerdem m√ºssen Sie sehr gut verstehen, was Sie damit machen und warum.  Meiner Meinung nach ist dies eher eine Entwicklungsoption, aber diejenigen, die f√ºr einige exotische Anwendungen die logische Replikation verwenden, k√∂nnen sie genie√üen. </li></ul><br><a name="9"></a><h3>  F√ºr dba </h3><br><ul><li>  <b>Tabelle √§ndern, Spalte hinzuf√ºgen, nicht Null Standard X</b> , die gesamte Tabelle schreiben.  Hierf√ºr wird eine geringe Geb√ºhr erhoben: Der Standardwert wird separat gespeichert.  Wenn Sie Tupel aufnehmen und diese Spalte ben√∂tigen, muss PostgreSQL einem zus√§tzlichen Codierungspfad folgen, um einen tempor√§ren Wert abzurufen, ihn durch Tupel zu ersetzen und ihn Ihnen zu geben.  Trotzdem kann man damit leben. </li><li>  <b>Vakuum / analysieren</b> .  Bisher konnten Sie nur Vakuum anwenden oder eine gesamte Datenbank oder eine einzelne Tabelle analysieren.  Jetzt ist es m√∂glich, dies mit einem Befehl f√ºr mehrere Tabellen durchzuf√ºhren. </li></ul><br><a name="10"></a><h3>  Parallele Ausf√ºhrung </h3><br><ul><li>  <b>Parallele Konstruktion von B-Tree-Indizes</b> .  In Version 11 wurde es m√∂glich, B-Tree-Indizes in mehrere Worker einzubetten.  Wenn Sie eine wirklich gute Maschine, viele Festplatten und viele Kerne haben, k√∂nnen Sie parallel Indizes erstellen. Dies verspricht eine sp√ºrbare Leistungssteigerung. </li><li>  <b>Parallele Hash-Verbindung unter Verwendung einer gemeinsam genutzten Hash-Tabelle f√ºr Ausf√ºhrende</b> .    ,           -.   ,     .   - ,     .     . </li><li>  , <b>      union, create table as, select  create materialized view!</b> </li><li> - <b>   (limit)   </b> .    . </li></ul><br>    : <br><br> <code>alter table usr reset (parallel_workers) <br> create index on usr(lower((so).occ)) ‚Äî 2  <br> alter table usr set (parallel_workers=2) <br> create index on usr(upper((so).occ)) ‚Äî 1.8 </code> <br> <br>     parallel worker.        .     16    4  (    )      2 .,    ‚Äî 1,8 .     ,   ,     .  ,         . <br><br>     : <br><br> <code>explain analyze <br> select u1.* from usr u, usr1 u1 where <br> u.id=u1.id+0</code> <br> <br>     ,      . , user ‚Äî   ,    .     .    ,      ,   . <br><br>     ,   PostgreSQL 11           . <br><br><img src="https://habrastorage.org/webt/a4/si/tw/a4sitw7cyqsulcovvmv--yueczs.png"><br><br>    1425 ,  1,5 .    1,4 .  2  .  ,   9.6   : 1      ‚Äî  1 .,   2   1 .    ,    10    tuple.    11    .       :      user,   batch,    x-scan      append   . <br><br>    : <br><br><img src="https://habrastorage.org/webt/7f/rx/2h/7frx2hwdbaxaq4asujz7aembelq.png"><br><br>   .         211 ,   702 .   ,    510     1473.    ,      2  . <br><br>     parallel hash join.       .     ‚Äî 4.     ,     . <br><br>   parallel index scan    .     batch  .  Was bedeutet das?        hash join,         .  user    .        ,  parallel hash,   . <br><br>     1 .  ,       OLAP-,  OLTP  .    OLTP  ,      . <br><br><a name="11"></a><h3>  </h3><br>      . <br><br><ul><li>       .   ,            .      ,    ¬´¬ª   ¬´¬ª,     index scan,     .    (highly skewed data),         ,    .      .    ,    ,    . </li><li>       ¬´¬ª,   . </li></ul><br><a name="12"></a><h3> Window- </h3><br>     SQL:2011,      . <br><br><a name="13"></a><h3>     </h3><br>   ,      ,    . ,   ,    ,  ,    ,    . <br><br>   websearch,     .      ,     .        ,   . <br><br> <code># select websearch_to_tsquery('dog or cat'); <br> ---------------------- <br> 'dor' | 'cat' <br> # select websearch_to_tsquery('dog -cat'); <br> ---------------------- <br> 'dor' &amp; !'cat' <br> # select websearch_to_tsquery('or cat'); <br> ---------------------- <br> 'cat'</code> <br> <br>   ‚Äî dog or cat ‚Äî   . Websearch      .     |  ,       .    ‚Äúor cat‚Äù.   ,   .    websearch  ‚Äúor‚Äù  .  ,    -,    . <br><br> Websearch ‚Äî     .       :        ,   .     ,   . <br><br><a name="14"></a><h3> Json(b)   </h3><br>  10-     ,   11-     .    json  json(b),   tsvector.   ( json(b))  -  .      ,    ,   ,  bull, numeric, string, .     . <br><br> <code># select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '"string"'); <br> ------------------- <br> 'text':1 <br> # select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '["string", "numeric"]'); <br> ------------------- <br> '12':3 'text':1</code> <br> <br>     json(b),        .      ,   ,   ,   . <br><br><a name="15"></a><h3> PL/*  </h3><br>     . <br><br> <code>CREATE PROCEDURE transaction_test1() <br> LANGUAGE plpgsql <br> AS $$ <br> BEGIN <br> FOR i IN 0..9 LOOP <br> INSERT INTO test1 (a) VALUES (i); <br> IF i % 2 = 0 THEN <br> COMMIT; <br> ELSE <br> ROLLBACK; <br> END IF; <br> END LOOP; <br> END <br> $$; <br> CALL transaction_test1();</code> <br> <br>      call,       ,         .        .     .      select, insert   . <br><br>    ,    ,   PostgreSQL    .    Perl, Python, TL  PL/pgSQL.    Perl    sp begin,         . <br><br> PL/pgSQL    :    ,    . <br><br><a name="16"></a><h3> pgbench </h3><br>     pgbench  ICSB bench ‚Äî ,   ,       .    if,     ,     .  case,       - .   <code>--init-steps</code> ,    ,   . <br><br>         random-seed.   zipfian- .    / ‚Äî   ,      .   -    ,      ,  - ,  . <br><br> ,  ,    - . <br><br><a name="17"></a><h3>  PSQL </h3><br>  ,    PSQL,        .    exit  quit. <br><br><ul><li>   ‚Äî    copy,      2 <sup>32</sup> .  copy      :      2 <sup>32</sup> - . ,     2 <sup>31</sup>  2 <sup>32</sup> copy     .    64-  ,      2 <sup>64</sup> . </li><li>  POSIX  :   NaN <sup>0</sup> = 1  1 <sup>NaN</sup> = 1. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414031/">https://habr.com/ru/post/de414031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414019/index.html">Universelle L√∂sung f√ºr UITableViewRowAction und UIContextualAction</a></li>
<li><a href="../de414023/index.html">Fragen Sie Ethan: Wie schnell h√§tte das Leben im Universum erscheinen k√∂nnen?</a></li>
<li><a href="../de414025/index.html">Arbeitgeber verfolgen Computer, Toilettenfahrten und jetzt auch Emotionen. Folgt Ihnen Ihr Chef?</a></li>
<li><a href="../de414027/index.html">K√∂nnen meine Freunde als wahre Freunde betrachtet werden?</a></li>
<li><a href="../de414029/index.html">Geheimnisvolles Licht um einen neu gebildeten Stern und was Astronomen dar√ºber denken</a></li>
<li><a href="../de414037/index.html">Einmal bei einer HFT-Firma ...</a></li>
<li><a href="../de414039/index.html">Geschichten von Wolken</a></li>
<li><a href="../de414041/index.html">Im Winter und Sommer in einer Farbe? Suchen Sie nach Saisonalit√§t in Daten</a></li>
<li><a href="../de414049/index.html">Die Hauptspiele der E3 2018: Fallout 76, Metro Exodus, Doom Eternal und andere</a></li>
<li><a href="../de414053/index.html">5 Missverst√§ndnisse √ºber die DSGVO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>