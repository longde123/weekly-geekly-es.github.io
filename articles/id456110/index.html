<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏾 ❄️ 🈁 Seperti apa bentuk teks Anda? 💑 ⏏️ 🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teman-teman, semua bagus Jumat. Kami ingin membagikan terjemahan artikel yang disiapkan khusus untuk siswa kursus “Pengembang Android. Kursus Lanjutan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seperti apa bentuk teks Anda?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/456110/"> Teman-teman, semua bagus Jumat.  Kami ingin membagikan terjemahan artikel yang disiapkan khusus untuk siswa kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Pengembang Android.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus Lanjutan</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Selamat membaca. <br><br><img src="https://habrastorage.org/webt/vd/zx/ym/vdzxymfn0nm1ys_j8zkmlxz3w1m.png"><br><br>  Cara mendeklarasikan teks secara gaya di Android. <br><br><img src="https://habrastorage.org/webt/5e/l9/cw/5el9cwaiwzb5lyueyebodvghtmk.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Virginia Poltrack</a> Illustration</i> <br><br>  <code>TextView</code> dalam aplikasi Android menyediakan beberapa atribut untuk menata teks dan berbagai cara untuk menerapkannya.  Atribut ini dapat diatur secara langsung di tata letak, menerapkan gaya ke tampilan atau tema ke tata letak, atau, jika Anda mau, mengatur tampilan teks.  Tapi apa yang harus digunakan?  Dan apa yang terjadi jika Anda menggabungkannya? <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/dq/uq/he/dquqher19iptbqt1qxilp4ohcyc.png"><br>  <i>Apa dan kapan menggunakannya?</i> <br><br>  Artikel ini menjelaskan berbagai pendekatan untuk stylization teks deklaratif (yaitu, ketika Anda menentukan gaya dalam file XML), membahas ruang lingkup dan prioritas masing-masing metode. <br><br><h2>  tl; dr; </h2><br>  Anda <i>harus</i> membaca seluruh posting, tetapi di sini adalah ringkasannya. <br><br>  Ingat urutan prioritas berbagai metode penataan - jika Anda mencoba menstilisasi beberapa teks dan tidak melihat hasil yang diharapkan, maka kemungkinan besar perubahan Anda akan ditimpa oleh sesuatu dengan prioritas lebih tinggi dalam hierarki ini: <br><br><img src="https://habrastorage.org/webt/f2/zr/lw/f2zrlwisr9g_nupki56f4fcv6g0.png"><br>  <i>Hirarki metode penataan teks</i> <br><br>  Saya akan menyarankan prosedur penataan berikut: <br><br><ol><li>  Setel gaya aplikasi apa pun di <code>textViewStyle</code> sebagai gaya default untuk tema Anda. </li><li>  Pasang set (kecil) <code>TextAppearance</code> yang akan digunakan aplikasi Anda (atau gunakan / wariskan dari <a href="">gaya</a> MaterialComponent), dan rujuk langsung dari pandangan Anda </li><li>  Buat <code>style</code> dengan mengatur atribut yang tidak didukung oleh <code>TextAppearance</code> (yang dengan sendirinya akan menentukan salah satu dari <code>TextAppearance</code> Anda). </li><li>  Lakukan gaya unik apa pun secara langsung di tata letak. </li></ol><br><h2>  Tunjukkan beberapa gaya </h2><br>  Anda bisa langsung mengatur atribut <code>TextView</code> di tata letak, tetapi pendekatan ini bisa lebih membosankan dan tidak aman.  Bayangkan dengan cara ini Anda mencoba memperbarui warna semua TextViews dalam aplikasi.  Seperti semua tampilan lainnya, Anda dapat (dan seharusnya!) Menggunakan gaya untuk memastikan konsistensi, penggunaan kembali, dan kemudahan memperbarui.  Untuk tujuan ini, saya sarankan membuat gaya untuk teks kapan pun Anda mungkin ingin menerapkan gaya yang sama ke beberapa tampilan.  Ini sangat sederhana dan sebagian besar didukung oleh sistem tampilan Android. <br><br>  Apa yang terjadi di bawah tenda saat Anda mengatur tampilan?  Jika Anda pernah menulis tampilan kustom Anda, Anda mungkin melihat panggilan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konteks.obtainStyledAttributes (AttributeSet, int [], int, int)</a> .  Dengan demikian, sistem tampilan di Android beralih ke tampilan atribut yang ditentukan dalam tata letak.  Parameter <code>AttributeSet</code> , pada kenyataannya, dapat dianggap sebagai peta parameter XML yang Anda tentukan dalam tata letak Anda.  Jika AttributeSet menetapkan gaya, <b>gaya dibaca pertama kali</b> , dan kemudian atribut yang ditentukan secara langsung dalam tampilan diterapkan padanya.  Jadi, kita sampai pada aturan prioritas pertama. <br><br>  <b><i>Lihat → Gaya</i></b> <br><br>  Atribut yang didefinisikan secara langsung dalam tampilan selalu "menang" dan mengesampingkan atribut yang didefinisikan dalam gaya.  Perhatikan bahwa <b>kombinasi</b> atribut style dan view diterapkan;  mendefinisikan atribut dalam tampilan, yang juga ditentukan dalam gaya, <b>tidak membatalkan</b> seluruh gaya.  Perlu juga dicatat bahwa dalam pandangan Anda tidak ada cara nyata untuk menentukan dari mana stilisasi berasal;  Ini ditentukan oleh sistem tampilan untuk Anda sekali dalam panggilan yang sama.  Anda tidak bisa mendapatkan kedua opsi dan memilih. <br><br>  Meskipun gaya sangat berguna, mereka memiliki keterbatasan.  Salah satunya adalah bahwa Anda hanya dapat menerapkan satu gaya ke tampilan (berbeda dengan sesuatu seperti CSS, di mana Anda dapat menerapkan beberapa kelas).  <code>TextView</code> , bagaimanapun, memiliki trik, ia menyediakan atribut <code>TextAppearance</code> , yang bekerja mirip dengan <code>style</code> .  Jika Anda <code>TextAppearance</code> teks melalui <code>TextAppearance</code> , biarkan atribut <code>style</code> gratis untuk gaya lain, yang terlihat praktis.  Mari kita lihat lebih dekat apa itu <code>TextAppearance</code> dan bagaimana cara kerjanya. <br><br><h2>  Penampilan teks </h2><br>  Tidak ada yang ajaib di <code>TextAppearance</code> (misalnya, mode rahasia untuk menerapkan beberapa gaya yang seharusnya tidak Anda ketahui !!!!), <code>TextView</code> menyelamatkan Anda dari pekerjaan yang tidak perlu.  Mari kita lihat pada konstruktor <code>TextView</code> untuk memahami apa yang terjadi. <br><br><pre> <code class="kotlin hljs">TypedArray a = theme.obtainStyledAttributes(attrs, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes); TypedArray appearance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; int ap = a.getResourceId(com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextViewAppearance_textAppearance, -<span class="hljs-number"><span class="hljs-number">1</span></span>); a.recycle(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ap != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { appearance = theme.obtainStyledAttributes(ap, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextAppearance); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appearance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { readTextAppearance(context, appearance, attributes, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); appearance.recycle(); } <span class="hljs-comment"><span class="hljs-comment">// a little later a = theme.obtainStyledAttributes(attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes); readTextAppearance(context, a, attributes, true);</span></span></code> </pre> <br>  Jadi apa yang terjadi di sini?  Pada dasarnya, <code>TextView</code> pertama terlihat untuk melihat apakah Anda menentukan <code>android:textAppearance</code> , jika demikian, itu memuat gaya ini dan menerapkan semua properti yang terdaftar di sana.  Kemudian, ia memuat semua atribut dari tampilan (yang ia ingat, termasuk gaya) dan menerapkannya.  Jadi kita sampai pada aturan prioritas kedua: <br><br>  <i><b>Lihat → Gaya → Tampilan Teks</b></i> <br><br>  Karena penampilan teks diperiksa terlebih dahulu, atribut apa pun yang didefinisikan secara langsung dalam tampilan atau gaya akan menimpanya. <br><br>  Dengan <code>TextAppearance</code> , ada <code>TextAppearance</code> lain yang perlu diingat: mendukung <b>subset</b> atribut gaya yang ditawarkan <code>TextView</code> .  Untuk lebih memahami apa yang saya maksud, mari kembali ke baris ini: <br><br> <code>obtainStyledAttributes(ap, android.R.styleable.TextAppearance);</code> <br> <br>  Kami melihat versi <code>receiveStyledAttributes</code> dengan 4 argumen, versi 2-argumen ini sedikit berbeda dari itu.  Dia melihat style yang diberikan (seperti yang didefinisikan oleh <code>id</code> parameter pertama) dan memfilternya hanya sesuai dengan atribut dalam style yang muncul pada parameter kedua, array <code>attrs</code> .  Android.R.styleable.TextAppearance yang sangat bergaya mendefinisikan ruang lingkup <code>TextAppearance</code> .  Melihat definisi ini, kita melihat bahwa <code>TextAppearance</code> <a href="">mendukung</a> banyak, <b>tetapi tidak semua,</b> atribut yang <a href="">didukung</a> <code>TextView</code> . <br><br><pre> <code class="kotlin hljs">&lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColor"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textSize"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textStyle"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"typeface"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"fontFamily"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorHighlight"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorHint"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorLink"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textAllCaps"</span></span> format=<span class="hljs-string"><span class="hljs-string">"boolean"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowColor"</span></span> format=<span class="hljs-string"><span class="hljs-string">"color"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowDx"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowDy"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowRadius"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"elegantTextHeight"</span></span> format=<span class="hljs-string"><span class="hljs-string">"boolean"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"letterSpacing"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"fontFeatureSettings"</span></span> format=<span class="hljs-string"><span class="hljs-string">"string"</span></span> /&gt;</code> </pre> <br>  <i><b>Atribut Styling Didukung oleh <code>TextAppearance</code></b></i> <br><br>  Berikut adalah beberapa atribut <code>TextView</code> yang tidak termasuk dalam <code>TextAppearance</code> : <code>lineHeight[Multiplier|Extra]</code> , <code>lines</code> , <code>breakStrategy</code> dan <code>hyphenationFrequency</code> .  <code>TextAppearance</code> berfungsi pada level karakter, bukan level paragraf, sehingga atribut yang memengaruhi seluruh tata letak tidak didukung. <br><br>  Oleh karena itu, <code>TextAppearance</code> sangat berguna, memungkinkan kita untuk mendefinisikan gaya yang berorientasi pada atribut gaya teks, dan membiarkan <code>style</code> dalam tampilan gratis untuk keperluan lain.  Namun, ini memiliki cakupan terbatas dan berada di bagian bawah rantai prioritas, jadi jangan lupa tentang batasannya. <br><br><h2>  Default yang wajar </h2><br>  Ketika kami melihat bagaimana tampilan Android menyelesaikan atribut ( <code>context.obtainStyledAttributes</code> ), kami sebenarnya menyederhanakannya sedikit.  Dia memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">theme.obtainStyledAttributes</a> (menggunakan <code>Theme Context</code> saat ini 'a).  Saat memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> , urutan prioritas yang kami teliti sebelumnya ditampilkan, dan 2 tempat lagi diindikasikan untuk mencari penyelesaian atribut: gaya default untuk tampilan dan tema. <br><br>  <i>Saat menentukan nilai akhir atribut tertentu, empat parameter input ikut bermain:</i> <i><br><br></i> <ol><li>  <i>Nilai atribut apa pun di AtributSet ini.</i> </li><li>  <i>Sumber daya style yang ditentukan dalam AttributeSet (bernama "style").</i> </li><li>  <i>Gaya default ditentukan oleh defStyleAttr dan defstyleres</i> </li><li>  <i>Nilai dasar di utas ini.</i> </li></ol><br>  <i>Urutan Prioritas Styling dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Tema</a></i> <br><br>  Kami akan kembali ke tema, tapi mari kita lihat gaya default terlebih dahulu.  Apa gaya default ini?  Untuk menjawab pertanyaan ini, saya pikir akan berguna untuk mengambil jalan keluar kecil dari tema <code>TextView</code> dan melihat <code>Button</code> sederhana.  Ketika Anda memasukkan <code><code>&lt;</code> <code>Button</code> <code>&gt;</code></code> ke tata letak Anda, tampilannya seperti ini. <br><br><img src="https://habrastorage.org/webt/qn/da/wn/qndawn5dk_gwfj3h7wki2xzee8u.png"><br>  <i>Tombol standar</i> <br><br>  Mengapa  Jika Anda melihat kode sumber <code>Button</code> , Anda akan melihat bahwa kode itu agak sedikit: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, attrs, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.attr.buttonStyle); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs, int defStyleAttr) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, attrs, defStyleAttr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs, defStyleAttr, defStyleRes); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CharSequence getAccessibilityClassName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Button.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.getName(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getPointerIcon() == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isClickable() &amp;&amp; isEnabled()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PointerIcon.getSystemIcon(getContext(), PointerIcon.TYPE_HAND); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResolvePointerIcon(event, pointerIndex); } }</code> </pre> <br>  Itu saja!  Inilah seluruh kelas (tidak ada komentar).  Anda bisa memeriksanya sendiri di <a href="">sini</a> .  Saya akan menunggu  Jadi dari mana latar belakang, huruf kapital, riak, dll. Berasal?  Anda mungkin telah terjawab, tetapi semuanya akan didefinisikan dalam konstruktor dengan 2 argumen;  yang dipanggil saat tata letak diambil dari XML.  Ini adalah parameter terakhir yang mendefinisikan <code>defaultStyleAttr</code> di <code>com.android.internal.R.attr.buttonStyle</code> .  Ini adalah gaya default, yang pada dasarnya adalah titik referensi tidak langsung, memungkinkan Anda menentukan gaya default.  Itu tidak menunjuk langsung ke gaya, tetapi memungkinkan Anda untuk menunjuk ke salah satu yang ditentukan dalam topik Anda yang akan memeriksa ketika menyelesaikan atribut.  Dan itulah yang biasanya dilakukan oleh semua tema yang Anda warisi untuk memberikan tampilan dan nuansa widget standar.  Misalnya, jika Anda melihat topik Materi, ia mendefinisikan <code>@style/Widget.Material.Light.Button</code> , dan gaya inilah yang menyediakan semua atribut yang <code>theme.obtainStyledAttributes</code> akan <code>theme.obtainStyledAttributes</code> jika Anda tidak menentukan hal lain. <br><br>  Kembali ke <code>TextView</code> , ini juga menawarkan gaya default: <code>textViewStyle</code> .  Ini bisa sangat nyaman jika Anda ingin menerapkan beberapa gaya ke setiap TextView di aplikasi Anda.  Misalkan Anda ingin mengatur jarak garis default ke 1.2.  Anda dapat melakukan ini dengan <code>style/TextAppearance</code> dan mencoba menerapkannya selama peninjauan kode (atau mungkin bahkan dengan aturan kustom yang elegan di Lint), tetapi Anda harus waspada dan memastikan bahwa Anda merekrut anggota tim baru , hati-hati dengan refactoring, dll. <br><br>  Pendekatan yang lebih baik adalah menentukan gaya default Anda sendiri untuk semua <code>TextView</code> dalam aplikasi, mengatur perilaku yang diinginkan.  Anda dapat melakukan ini dengan mengatur gaya Anda sendiri untuk <code>textViewStyle</code> , yang diwarisi dari platform atau dari <code>MaterialComponents/AppCompat</code> secara default. <br><br><pre> <code class="kotlin hljs">&lt;style name=<span class="hljs-string"><span class="hljs-string">"Theme.MyApp"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@style/Theme.MaterialComponents.Light"</span></span>&gt; ... &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:textViewStyle"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@style</span></span>/Widget.MyApp.TextView&lt;/item&gt;&lt;/style&gt; &lt;style name=<span class="hljs-string"><span class="hljs-string">"Widget.MyApp.TextView"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@android:style/Widget.Material.TextView"</span></span>&gt; &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:textAppearance"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@style</span></span>/TextAppearance.MyApp.Body&lt;/item&gt; &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:lineSpacingMultiplier"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@dimen</span></span>/text_line_spacing&lt;/item&gt; &lt;/style&gt;</code> </pre> <br>  Dengan mengingat hal ini, aturan prioritas kami berupa: <br><br>  <i><b>Lihat -&gt; Gaya -&gt; Gaya Default -&gt; TextAppearance</b></i> <br><br>  Sebagai bagian dari resolusi atribut sistem tampilan, slot ini diisi setelah gaya (sehingga segala sesuatu dalam gaya dibatalkan oleh gaya yang diterapkan atau melihat atribut secara default), tetapi masih akan menimpa tampilan teks.  Gaya default bisa sangat nyaman.  Jika Anda pernah memutuskan untuk menulis tampilan kustom Anda sendiri, mereka bisa menjadi cara yang ampuh untuk menerapkan perilaku default, membuatnya mudah untuk dikustomisasi. <br><br>  Jika Anda mewarisi widget dan tidak menentukan gaya default Anda sendiri, maka pastikan untuk menggunakan gaya kelas induk default di konstruktor (jangan hanya lulus 0).  Misalnya, jika Anda mewarisi dari <code>AppCompatTextView</code> dan menulis konstruktor Anda sendiri dengan 2 argumen, pastikan untuk melewati <code>android.R.attr.textViewStyle  defaultStyleAttr</code> ( <a href="">seperti di sini</a> ), jika tidak, Anda akan kehilangan perilaku kelas induk. <br><br><h2>  Tema </h2><br>  Seperti disebutkan sebelumnya, ada cara lain (terakhir, saya berjanji) untuk memberikan informasi gaya.  <code>theme.obtainStyledAttributes</code> tempat <code>theme.obtainStyledAttributes</code> akan melihat langsung ke topik itu sendiri.  Artinya, jika Anda menambahkan atribut gaya ke tema Anda, misalnya <code>android:textColor</code> , sistem tampilan akan memilihnya sebagai pilihan terakhir.  Sebagai aturan, itu adalah ide yang buruk untuk mencampur atribut tema dan atribut gaya, yaitu, apa yang Anda terapkan langsung ke tampilan, sebagai aturan, tidak boleh ditetapkan untuk tema (dan sebaliknya), tetapi ada beberapa pengecualian langka. <br><br>  Salah satu contohnya adalah ketika Anda mencoba mengubah font di seluruh aplikasi.  Anda dapat menggunakan salah satu metode yang dijelaskan di atas, tetapi menyesuaikan secara manual gaya / tampilan teks di mana-mana akan menjadi monoton dan tidak aman, dan gaya default hanya akan bekerja di tingkat widget;  subkelas dapat mengesampingkan perilaku ini, misalnya tombol menentukan <code>android:buttonStyle</code> mereka sendiri <code>android:buttonStyle</code> , yang <code>android:textViewStyle</code> Anda <code>android:textViewStyle</code> tidak akan mengambil.  Sebagai gantinya, Anda dapat menentukan font di tema Anda: <br><br><pre> <code class="kotlin hljs">&lt;style name=<span class="hljs-string"><span class="hljs-string">"Theme.MyApp"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@style/Theme.MaterialComponents.Light"</span></span>&gt; ... &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:fontFamily"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@font</span></span>/space_mono&lt;/item&gt; &lt;/style&gt;</code> </pre> <br>  Sekarang setiap tampilan yang mendukung atribut ini akan mengambilnya jika tidak diganti oleh sesuatu dengan prioritas lebih tinggi: <br><br>  <i><b>Lihat → Gaya → Gaya Default → Tema → TextAppearance</b></i> <br><br>  Sekali lagi, karena ini adalah bagian dari sistem penataan tampilan, itu akan menimpa semua yang disediakan dalam bentuk teks, tetapi akan ditimpa oleh atribut yang lebih spesifik. <br><br>  Ingat prioritas ini.  Dalam contoh kami dengan font untuk seluruh aplikasi, Anda dapat mengharapkan <code>Toolbar</code> mengambil font ini, karena mengandung judul, yang merupakan <code>TextView</code> .  Kelas Toolbar itu sendiri, bagaimanapun, mendefinisikan gaya default yang mengandung <code>titleTextAppearance</code> , yang mendefinisikan <code>android:fontFamily</code> , dan menetapkannya langsung di header <code>TextView</code> , menimpa nilai level tema.  Gaya tingkat topik bisa berguna, tetapi mudah ditimpa, jadi pastikan itu diterapkan dengan benar. <br><br><h2>  Bonus: Masalah yang Tidak Terselesaikan </h2><br>  Seluruh artikel ini dikhususkan untuk desain teks deklaratif di tingkat tampilan, yaitu, bagaimana gaya seluruh <code>TextView</code> selama mengisi.  Gaya apa pun yang diterapkan setelah mengisi (misalnya, <code>textView.setTextColor(…)</code> ) akan menggantikan gaya deklaratif.  <code>TextView</code> juga mendukung gaya yang lebih kecil melalui <code>Span</code> .  Saya tidak akan membahas topik ini, karena dijelaskan secara rinci dalam artikel oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Florina Muntenescu</a> . <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spantastic text styling dengan Spans</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rentang underspanding</a> <br><br>  Saya akan menyebutkan ini untuk kelengkapan, untuk diingat bahwa gaya dan rentang program akan berada di urutan teratas prioritas: <br><br>  <i><b>Rentang → Setter → Tampilan → Gaya → Gaya Default → Tema → TextAppearance</b></i> <br><br><h2>  Pilih gaya Anda </h2><br>  Meskipun ada beberapa cara untuk menata teks Anda, memahami perbedaan antara metode dan keterbatasannya membantu Anda menemukan alat yang tepat untuk tugas tertentu atau memahami mengapa satu metode lebih diutamakan daripada yang lain. <br><br>  Memiliki gaya teks yang bagus! <br><br>  Kami mengundang semua orang ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webinar gratis</a> dalam kerangka yang akan kami kenali dengan kerangka DI Dagger 2: kami akan mempelajari bagaimana Dagger2 menghasilkan kode, kami akan berurusan dengan penjelasan JSR 330 dan konstruksi Dagger2, kami akan belajar cara menggunakan Dagger2 dalam aplikasi multi-modul dan mempertimbangkan Dagger Android Injector. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456110/">https://habr.com/ru/post/id456110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456096/index.html">Apa yang pembaca geektimes rata-rata lakukan sambil melayang di awan</a></li>
<li><a href="../id456100/index.html">Sekarang dalam kemasan baru - Kingston A400 dalam format M.2 bergegas ke pasar</a></li>
<li><a href="../id456102/index.html">Pelaporan mudah dalam C / C ++</a></li>
<li><a href="../id456104/index.html">Ezblock Pi - pemrograman tanpa pemrograman, kali ini untuk penggemar Raspberry Pi</a></li>
<li><a href="../id456108/index.html">Habr Weekly # 5 / Dark topik ada di mana-mana, pabrik-pabrik Cina di Federasi Rusia, di mana bank telah mengalir, Pixel 4, ML mencemari atmosfer</a></li>
<li><a href="../id456112/index.html">Mengatasi Hukum Moore: Cara Mengganti Transistor Planar Tradisional</a></li>
<li><a href="../id456114/index.html">Apa yang Baru dalam Pengembangan Mamba</a></li>
<li><a href="../id456116/index.html">Cara membangun skema basis data yang indah di Editor Grafik yEd</a></li>
<li><a href="../id456118/index.html">“Mesin Emosi” Marvin Minsky: Bab 8.1-2 “Kreativitas”</a></li>
<li><a href="../id456122/index.html">Hackathon Terbesar dari Contour: Menghilangkan Ghoul dan Cinta untuk Lingkungan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>