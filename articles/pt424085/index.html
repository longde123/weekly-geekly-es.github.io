<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì® üë©üèæ‚Äç‚úàÔ∏è üë¥üèΩ Estamos desenvolvendo o m√≥dulo do processador NIOS II para o IDA Pro üë©üèæ‚Äçü§ù‚Äçüë®üèª üò£ üßñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Captura de tela da interface do desmontador do IDA Pro 

 O IDA Pro √© um famoso desmontador que tem sido usado por pesquisadores de seguran√ßa da infor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos desenvolvendo o m√≥dulo do processador NIOS II para o IDA Pro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424085/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/141/008/5b2/1410085b245c7ef6a18074b47dda1b6b.gif" alt="imagem"></a> <br><br>  <i>Captura de tela da interface do desmontador do IDA Pro</i> <br><br>  O IDA Pro √© um famoso desmontador que tem sido usado por pesquisadores de seguran√ßa da informa√ß√£o em todo o mundo h√° muitos anos.  N√≥s da Positive Technologies tamb√©m usamos essa ferramenta.  Al√©m disso, pudemos desenvolver nosso pr√≥prio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulo de processador desmontador para a arquitetura do microprocessador NIOS II</a> , o que aumenta a velocidade e a conveni√™ncia da an√°lise de c√≥digo. <br><br>  Hoje vou contar sobre a hist√≥ria deste projeto e mostrar o que aconteceu no final. <a name="habracut"></a><br><br><h2>  Antecedentes </h2><br>  Tudo come√ßou em 2016, quando tivemos que desenvolver nosso pr√≥prio m√≥dulo de processador para analisar o firmware em uma tarefa.  O desenvolvimento foi conduzido do zero no manual <a href="">Nios II Classic Processor Reference Guide</a> , que era o mais relevante.  No total, esse trabalho levou cerca de duas semanas. <br><br>  O m√≥dulo do processador foi desenvolvido para a vers√£o IDA 6.9.  Por velocidade, o IDA Python foi escolhido.  No local em que os m√≥dulos do processador residem - o subdiret√≥rio procs dentro do diret√≥rio de instala√ß√£o do IDA Pro - existem tr√™s m√≥dulos Python: msp430, ebc, spu.  Neles, voc√™ pode ver como o m√≥dulo est√° organizado e como a funcionalidade b√°sica de desmontagem pode ser implementada: <br><br><ul><li>  analisar instru√ß√µes e operandos, </li><li>  sua simplifica√ß√£o e exibi√ß√£o, </li><li>  criando compensa√ß√µes, refer√™ncias cruzadas, bem como o c√≥digo e os dados aos quais eles se referem </li><li>  processamento de constru√ß√µes de interruptores, </li><li>  manipula√ß√£o de manipula√ß√µes com a pilha e as vari√°veis ‚Äã‚Äãda pilha. </li></ul><br>  Aproximadamente essa funcionalidade foi implementada na √©poca.  Felizmente, a ferramenta foi √∫til no processo de trabalhar em outra tarefa, durante a qual, um ano depois, foi ativamente usada e refinada. <br><br>  Decidi compartilhar a experi√™ncia de criar o m√≥dulo do processador com a comunidade no PHDays 8. A apresenta√ß√£o despertou interesse (o relat√≥rio em v√≠deo foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicado</a> no site do PHDays), at√© o criador do IDA Pro Ilfak Gilfanov.  Uma de suas perguntas era se o suporte √† vers√£o 7 do IDA Pro havia sido implementado. Naquela √©poca, n√£o estava l√°, mas ap√≥s o desempenho prometi fazer um lan√ßamento apropriado do m√≥dulo.  Foi aqui que a divers√£o come√ßou. <br><br>  Agora, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual</a> mais recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da Intel</a> , usado para verificar e verificar se h√° erros.  Revisei significativamente o m√≥dulo, adicionei v√°rios novos recursos, incluindo a solu√ß√£o de problemas que n√£o podiam ser derrotados antes.  Bem, √© claro, eu adicionei suporte para a 7¬™ vers√£o do IDA Pro.  Aqui est√° o que aconteceu. <br><br><h2>  Modelo de software NIOS II </h2><br>  O NIOS II √© um processador de software desenvolvido para os FPGAs da Altera (agora parte da Intel).  Do ponto de vista dos programas, ele possui os seguintes recursos: ordem de bytes do little endian, espa√ßo de endere√ßo de 32 bits, conjunto de instru√ß√µes de 32 bits, ou seja, 4 bytes, 32 registros gerais e 32 de prop√≥sito especial s√£o usados ‚Äã‚Äãpara codificar cada comando. <br><br><h2>  Desmontagem e refer√™ncias de c√≥digo </h2><br>  Ent√£o, abrimos um novo arquivo no IDA Pro, com firmware para o processador NIOS II.  Ap√≥s a instala√ß√£o do m√≥dulo, n√≥s o veremos na lista de processadores IDA Pro.  A escolha do processador √© mostrada na figura. <br><br><img src="https://habrastorage.org/webt/9x/wd/ni/9xwdnil54uqjf3wru4nqcc0fkr8.png"><br><br>  Suponha que o m√≥dulo ainda n√£o tenha implementado uma an√°lise b√°sica de comandos.  Dado que cada comando tem 4 bytes, agrupamos os bytes em quatro, ent√£o tudo ficar√° mais ou menos assim. <br><br><img src="https://habrastorage.org/webt/be/v9/_j/bev9_jokezmrwfxgr5gtscagrma.png"><br><br>  Ap√≥s implementar a funcionalidade b√°sica das instru√ß√µes de decodifica√ß√£o e operandos, exibi-las na tela e analisar as instru√ß√µes de transfer√™ncia de controle, o conjunto de bytes definido no exemplo acima √© convertido no c√≥digo a seguir. <br><br><img src="https://habrastorage.org/webt/w6/zm/5c/w6zm5c7rzp0ee0qec2twmkzdnxe.png"><br><br>  Como pode ser visto no exemplo, refer√™ncias cruzadas tamb√©m s√£o geradas a partir de comandos de transfer√™ncia de controle (nesse caso, voc√™ pode ver o salto condicional e a chamada de procedimento). <br><br>  Uma das propriedades √∫teis que podem ser implementadas nos m√≥dulos do processador s√£o os coment√°rios do comando.  Se voc√™ desabilitar a sa√≠da dos valores de bytes e habilitar a sa√≠da dos coment√°rios, a mesma se√ß√£o de c√≥digo j√° ter√° esta apar√™ncia. <br><br><img src="https://habrastorage.org/webt/gu/ia/u0/guiau0csjjbidgimzewinug4pvq.png"><br><br>  Aqui, se voc√™ encontrou o c√≥digo assembler de uma nova arquitetura pela primeira vez, usando coment√°rios, voc√™ pode entender o que est√° acontecendo.  Al√©m disso, os exemplos de c√≥digo estar√£o na mesma forma - com coment√°rios, para n√£o olhar para o manual do NIOS II, mas para entender imediatamente o que est√° acontecendo na se√ß√£o de c√≥digo, que √© fornecida como exemplo. <br><br><h2>  Pseudo-instru√ß√µes e simplifica√ß√£o de comandos </h2><br>  Alguns comandos do NIOS II s√£o pseudo-instru√ß√µes.  N√£o existem opcodes separados para essas equipes, e eles mesmos s√£o modelados como casos especiais de outras equipes.  No processo de desmontagem, a simplifica√ß√£o das instru√ß√µes √© realizada - a substitui√ß√£o de certas combina√ß√µes por pseudo-instru√ß√µes.  As pseudo-instru√ß√µes no NIOS II geralmente podem ser divididas em quatro tipos: <br><br><ul><li>  quando uma das fontes √© zero (r0) e pode ser removida da considera√ß√£o, </li><li>  quando a equipe tem um valor negativo e a equipe √© substitu√≠da pelo oposto, </li><li>  quando a condi√ß√£o √© revertida, </li><li>  quando o deslocamento de 32 bits √© inserido em duas equipes em partes (a mais nova e a mais antiga) e isso √© substitu√≠do por um comando. </li></ul><br>  Os dois primeiros tipos foram implementados, pois a substitui√ß√£o da condi√ß√£o n√£o oferece nada de especial e as compensa√ß√µes de 32 bits t√™m mais op√ß√µes do que as apresentadas no manual. <br><br>  Por exemplo, para a primeira visualiza√ß√£o, considere o c√≥digo. <br><br><img src="https://habrastorage.org/webt/ix/if/kt/ixifktzau98plchui3ypjf0qn6c.png"><br><br>  √â visto que o uso do registro zero nos c√°lculos √© frequentemente encontrado aqui.  Se voc√™ olhar atentamente para este exemplo, notar√° que todos os comandos, exceto a transfer√™ncia de controle, s√£o op√ß√µes para simplesmente inserir valores em registros espec√≠ficos. <br><br>  Ap√≥s implementar o processamento das pseudo instru√ß√µes, obtemos a mesma se√ß√£o de c√≥digo, mas agora parece mais leg√≠vel e, em vez de varia√ß√µes dos comandos ou e adicionar, obtemos varia√ß√µes do comando mov. <br><br><img src="https://habrastorage.org/webt/ka/4j/_q/ka4j_qwz2elzmsmccfrewbtn9cc.png"><br><br><h2>  Vari√°veis ‚Äã‚Äãde pilha </h2><br>  A arquitetura do NIOS II suporta a pilha e, al√©m do ponteiro sp da pilha, tamb√©m h√° um ponteiro para o quadro da pilha fp.  Considere um exemplo de um pequeno procedimento que usa uma pilha. <br><br><img src="https://habrastorage.org/webt/82/_o/1v/82_o1v_n-ojrlgtveqtfjln2vve.png"><br><br>  Obviamente, o espa√ßo √© reservado para vari√°veis ‚Äã‚Äãlocais na pilha.  Pode-se supor que o registrador ra seja armazenado na vari√°vel da pilha e depois restaurado a partir dele. <br><br>  Depois de adicionar funcionalidade ao m√≥dulo que rastreia altera√ß√µes no ponteiro da pilha e cria vari√°veis ‚Äã‚Äãde pilha, o mesmo exemplo ser√° semelhante a este. <br><br><img src="https://habrastorage.org/webt/zg/pk/fx/zgpkfxblezz4cp78gfqswegbjza.png"><br><br>  Agora, o c√≥digo parece um pouco mais claro e voc√™ j√° pode nomear as vari√°veis ‚Äã‚Äãda pilha e analisar sua finalidade, seguindo as refer√™ncias cruzadas.  A fun√ß√£o no exemplo √© do tipo __fastcall e seus argumentos nos registradores r4 e r5 s√£o empurrados para a pilha para chamar um subprocedimento que √© do tipo _stdcall. <br><br><h2>  N√∫meros e compensa√ß√µes de 32 bits </h2><br>  A peculiaridade do NIOS II √© que em uma opera√ß√£o, ou seja, ao executar um √∫nico comando, √© poss√≠vel registrar no m√°ximo um valor direto de 2 bytes (16 bits) de tamanho.  Por outro lado, os registros do processador e o espa√ßo de endere√ßo s√£o de 32 bits, ou seja, para endere√ßamento, 4 bytes devem ser inseridos no registro. <br><br>  Para resolver esse problema, deslocamentos de duas partes s√£o usados.  Um mecanismo semelhante √© usado nos processadores do PowerPC: o deslocamento consiste em duas partes, a mais antiga e a mais nova, e √© inserido no registro por dois comandos.  No PowerPC, √© o seguinte. <br><br><img src="https://habrastorage.org/webt/n8/qm/5z/n8qm5zedw9ffnckmjclzmhfwkh8.png"><br><br>  Nessa abordagem, os links cruzados s√£o formados pelas duas equipes, embora, na verdade, o endere√ßo esteja configurado no segundo comando.  √Äs vezes, isso pode ser um inc√¥modo ao contar o n√∫mero de refer√™ncias cruzadas. <br><br>  As propriedades de deslocamento da parte antiga usam o tipo n√£o-padr√£o HIGHA16, √†s vezes o tipo HIGH16 √© usado, para a parte mais nova - LOW16. <br><br><img src="https://habrastorage.org/webt/l-/u3/6r/l-u36riq53_ejmry2mwdv7qewp4.png"><br><br>  N√£o h√° nada complicado no c√°lculo de n√∫meros de duas partes de 32 bits.  Dificuldades surgem na forma√ß√£o de operandos como compensa√ß√µes para duas equipes separadas.  Todo esse processamento cai no m√≥dulo do processador.  N√£o h√° exemplos de como implementar isso (especialmente em Python) no IDA SDK. <br><br>  No relat√≥rio sobre PHDays, os vieses permaneceram como um problema n√£o resolvido.  Para resolver o problema, trapaceamos: deslocamento de 32 bits apenas da parte mais jovem - na base.  A base √© calculada como a parte mais antiga, deslocada para a esquerda em 16 bits. <br><br><img src="https://habrastorage.org/webt/ip/lc/60/iplc60jwuylhovnugr8qgyxorbq.png"><br><br>  Com essa abordagem, uma refer√™ncia cruzada √© formada apenas com o comando para inserir a parte inferior do deslocamento de 32 bits. <br><br>  A base √© vis√≠vel nas propriedades de deslocamento e a propriedade √© marcada para consider√°-lo como um n√∫mero, de modo que um grande n√∫mero de refer√™ncias cruzadas para o endere√ßo em si n√£o seja formado, que tomamos como base. <br><br><img src="https://habrastorage.org/webt/_3/ui/wy/_3uiwyr9jt0lpipfsounaz07q3c.png"><br><br>  No c√≥digo do NIOS II, o seguinte mecanismo √© encontrado para inserir n√∫meros de 32 bits no registro.  Primeiro, a parte mais antiga do deslocamento √© inserida no registro com o comando movhi.  Ent√£o a parte mais jovem se junta a ela.  Isso pode ser feito de tr√™s maneiras (por comandos): adicionando addi, subtraindo subi, OR l√≥gico ORi. <br><br>  Por exemplo, na pr√≥xima se√ß√£o do c√≥digo, os registradores s√£o configurados para n√∫meros de 32 bits, que s√£o inseridos nos registradores - argumentos antes de chamar a fun√ß√£o. <br><br><img src="https://habrastorage.org/webt/rs/4l/ms/rs4lmsgotpjsjrb92qh6gkk9s-y.png"><br><br>  Ap√≥s adicionar o c√°lculo do deslocamento, obtemos a seguinte representa√ß√£o desse bloco de c√≥digo. <br><br><img src="https://habrastorage.org/webt/sg/3c/i_/sg3ci__0-wvfkj-5j40xuemubva.png"><br><br>  O deslocamento de 32 bits resultante √© exibido ao lado do comando para inserir sua parte inferior.  Este exemplo √© bastante ilustrativo e poder√≠amos calcular facilmente todos os n√∫meros de 32 bits na mente, simplesmente adicionando as partes menores e as mais altas.  A julgar pelos valores, eles provavelmente n√£o s√£o tendenciosos. <br><br>  Considere o caso em que a subtra√ß√£o √© usada ao entrar na parte mais jovem.  Neste exemplo, n√£o ser√° poss√≠vel determinar os n√∫meros finais de 32 bits (deslocamentos) em movimento. <br><br><img src="https://habrastorage.org/webt/i-/8x/yt/i-8xyto-q5iqeiffz3hua-d29ew.png"><br><br>  Depois de aplicar o c√°lculo dos n√∫meros de 32 bits, obtemos o seguinte formul√°rio. <br><br><img src="https://habrastorage.org/webt/tf/da/8-/tfda8-uw3xkthiqqe930jut8ovs.png"><br><br>  Aqui vemos que agora, se o endere√ßo estiver no espa√ßo de endere√ßos, um deslocamento √© formado nele, e o valor que foi formado como resultado da conex√£o das partes j√∫nior e s√™nior n√£o ser√° mais exibido pr√≥ximo a ele.  Aqui eles foram compensados ‚Äã‚Äãpela linha ‚Äú22/10/08‚Äù.  Para que o restante das compensa√ß√µes aponte para endere√ßos v√°lidos, vamos aumentar um pouco o segmento. <br><br><img src="https://habrastorage.org/webt/0i/qq/fh/0iqqfhcomre0yd3siixym3vt0o8.png"><br><br>  Depois de aumentar o segmento, descobrimos que agora todos os n√∫meros de 32 bits calculados s√£o compensados ‚Äã‚Äãe indicam endere√ßos v√°lidos. <br><br>  Foi mencionado acima que existe outra op√ß√£o para calcular compensa√ß√µes quando um comando OR l√≥gico √© usado.  Aqui est√° um c√≥digo de exemplo no qual duas compensa√ß√µes s√£o calculadas dessa maneira. <br><br><img src="https://habrastorage.org/webt/xr/or/am/xroramzy4_lj_g3po7yxo-m0sxy.png"><br><br>  O que √© avaliado no registro r8 √© ent√£o empurrado para a pilha. <br><br>  Ap√≥s a convers√£o, fica claro que, neste caso, os registradores s√£o configurados para os endere√ßos do in√≠cio dos procedimentos, ou seja, o endere√ßo do procedimento √© empurrado para a pilha. <br><br><img src="https://habrastorage.org/webt/wr/au/qm/wrauqmfpotzlhjdiz4_i8mnghri.png"><br><br><h2>  Leitura e escrita em rela√ß√£o √† base </h2><br>  Antes disso, consideramos casos em que um n√∫mero de 32 bits digitado usando dois comandos poderia ser apenas um n√∫mero e tamb√©m um deslocamento.  No exemplo a seguir, a base √© inserida na parte superior do registro e, em seguida, a leitura ou grava√ß√£o ocorre em rela√ß√£o a ele. <br><br><img src="https://habrastorage.org/webt/ho/2v/ve/ho2vvexmp7367xll5prt5xwpc8m.png"><br><br>  Ap√≥s o processamento de tais situa√ß√µes, obtemos o deslocamento para as vari√°veis ‚Äã‚Äãdos pr√≥prios comandos de leitura e grava√ß√£o.  Al√©m disso, dependendo da dimens√£o da opera√ß√£o, o tamanho da vari√°vel em si √© definido. <br><br><img src="https://habrastorage.org/webt/cl/pi/g-/clpig-mgt5xtsshbvp67wh9rrdg.png"><br><br><h2>  Switch constru√ß√µes </h2><br>  As constru√ß√µes de switch encontradas em arquivos bin√°rios podem facilitar a an√°lise.  Por exemplo, pelo n√∫mero de casos de sele√ß√£o dentro da constru√ß√£o do comutador, voc√™ pode localizar o comutador respons√°vel pelo processamento de um determinado protocolo ou sistema de comando.  Portanto, surge a tarefa de reconhecer o pr√≥prio switch e seus par√¢metros.  Considere a seguinte se√ß√£o de c√≥digo. <br><br><img src="https://habrastorage.org/webt/g9/t7/7u/g9t77ugtkercggcjphfq9xfam_0.png"><br><br>  O encadeamento de execu√ß√£o para na transi√ß√£o do registro jmp r2.  Al√©m disso, existem blocos de c√≥digo para os quais existem links dos dados e, no final de cada bloco, h√° um salto para o mesmo r√≥tulo.  Obviamente, essa √© uma constru√ß√£o de switch e esses blocos individuais lidam com casos espec√≠ficos a partir dela.  Acima, voc√™ tamb√©m pode ver a verifica√ß√£o do n√∫mero de casos e o salto padr√£o. <br><br>  Depois de adicionar o processamento do switch, esse c√≥digo ficar√° assim. <br><br><img src="https://habrastorage.org/webt/rm/qj/hw/rmqjhwhrknmc_cycqu5d57kjpmq.png"><br><br>  Agora o salto em si √© indicado, o endere√ßo da tabela com compensa√ß√µes, o n√∫mero de casos e cada caso com o n√∫mero correspondente. <br><br>  A tabela em si com deslocamentos para as op√ß√µes √© a seguinte.  Para economizar espa√ßo, os cinco primeiros elementos s√£o fornecidos. <br><br><img src="https://habrastorage.org/webt/9b/ke/x9/9bkex9oxlk_vv4nrpdya3nckv3m.png"><br><br>  De fato, o processamento do comutador consiste em voltar ao c√≥digo e procurar todos os seus componentes.  Ou seja, √© descrito algum esquema de organiza√ß√£o do switch.  √Äs vezes, pode haver exce√ß√µes nos esquemas.  Esse pode ser o motivo dos casos em que os comutadores aparentemente limpos n√£o s√£o reconhecidos nos m√≥dulos de processador existentes.  Acontece que o comutador real simplesmente n√£o se enquadra no esquema definido dentro do m√≥dulo do processador.  Ainda existem op√ß√µes poss√≠veis quando o circuito parece estar l√°, mas h√° outras equipes dentro dele que n√£o est√£o envolvidas no circuito, ou as equipes principais s√£o reorganizadas ou s√£o interrompidas pelas transi√ß√µes. <br><br>  O m√≥dulo do processador NIOS II reconhece um switch com essas instru√ß√µes "estranhas" entre os comandos principais, bem como com os locais reorganizados dos comandos principais e com interrup√ß√µes no circuito.  Um caminho de retorno √© usado ao longo do caminho de execu√ß√£o, levando em considera√ß√£o poss√≠veis transi√ß√µes que interrompem o circuito, com a instala√ß√£o de vari√°veis ‚Äã‚Äãinternas que sinalizam diferentes estados do reconhecedor.  Como resultado, s√£o reconhecidas cerca de 10 op√ß√µes diferentes de organiza√ß√£o de switches encontradas no firmware. <br><br><h2>  Instru√ß√£o personalizada </h2><br>  H√° um recurso interessante na arquitetura do NIOS II - a instru√ß√£o personalizada.  D√° acesso a 256 instru√ß√µes definidas pelo usu√°rio que s√£o poss√≠veis na arquitetura NIOS II.  Em seu trabalho, al√©m dos registros de uso geral, a instru√ß√£o personalizada pode acessar um conjunto especial de 32 registros personalizados.  Depois de implementar a l√≥gica para analisar o comando personalizado, obtemos o seguinte formul√°rio. <br><br><img src="https://habrastorage.org/webt/ws/8d/zo/ws8dzozz7aext7buc0g3re8kwno.png"><br><br>  Voc√™ pode perceber que as duas √∫ltimas instru√ß√µes t√™m o mesmo n√∫mero de instru√ß√µes e parecem executar as mesmas a√ß√µes. <br><br>  De acordo com as instru√ß√µes personalizadas, h√° um <a href="">manual separado</a> .  Segundo ele, uma das op√ß√µes mais abrangentes e atualizadas para o conjunto de instru√ß√µes personalizadas √© o conjunto de instru√ß√µes do NIOS II Floating Point Hardware 2 Component (FPH2) para trabalhar com o ponto flutuante.  Ap√≥s implementar a an√°lise dos comandos do FPH2, o exemplo ser√° semelhante a este. <br><br><img src="https://habrastorage.org/webt/ex/-q/1g/ex-q1g9sszau_hhllau3_xrvgdw.png"><br><br>  A partir das mnem√¥nicas das duas √∫ltimas equipes, garantimos que elas realmente executem a mesma a√ß√£o - o comando fadds. <br><br><h2>  Transi√ß√µes por valor do registro </h2><br>  No firmware sob investiga√ß√£o, geralmente √© encontrada uma situa√ß√£o quando um salto √© realizado de acordo com o valor do registro, no qual um deslocamento de 32 bits, que determina o local do salto, √© inserido anteriormente. <br><br>  Considere um peda√ßo de c√≥digo. <br><br><img src="https://habrastorage.org/webt/sj/ej/ys/sjejysq65hywye8w6usdbshkc60.png"><br><br>  Na √∫ltima linha, h√° um salto no valor do registro, enquanto fica claro que o endere√ßo do procedimento que come√ßa na primeira linha do exemplo √© inserido primeiro no registro.  Nesse caso, √© √≥bvio que o salto √© feito desde o in√≠cio. <br><br>  Depois de adicionar a funcionalidade de reconhecimento de saltos, √© obtido o seguinte formul√°rio. <br><br><img src="https://habrastorage.org/webt/ov/tm/j2/ovtmj2lcb_8lrx8qmxvekuul0lw.png"><br><br>  Ao lado do comando jmp r8, o endere√ßo onde o salto ocorre, se foi poss√≠vel calcular, √© exibido.  Tamb√©m √© formada uma refer√™ncia cruzada entre a equipe e o endere√ßo onde o salto ocorre.  Nesse caso, o link √© vis√≠vel na primeira linha, o salto em si √© realizado a partir da √∫ltima linha. <br><br><h2>  Valor do registro Gp (ponteiro global), salvar e carregar </h2><br>  √â comum usar um ponteiro global configurado para algum endere√ßo e as vari√°veis ‚Äã‚Äãs√£o endere√ßadas em rela√ß√£o a ele.  O NIOS II usa o registro gp (ponteiro global) para armazenar o ponteiro global.  Em algum momento, como regra, nos procedimentos de inicializa√ß√£o do firmware, o valor do endere√ßo √© inserido no registro gp.  O m√≥dulo do processador lida com essa situa√ß√£o;  Para ilustrar isso, a seguir est√£o exemplos de c√≥digo e a janela de sa√≠da do IDA Pro quando as mensagens de depura√ß√£o s√£o ativadas no m√≥dulo do processador. <br><br>  Neste exemplo, o m√≥dulo processador encontra e calcula o valor do registro gp no novo banco de dados.  Ao fechar o banco de dados idb, o valor de gp √© armazenado no banco de dados. <br><br><img src="https://habrastorage.org/webt/cx/ll/hk/cxllhko-hugm77k68idqqam4wzm.png"><br><br>  Ao carregar um banco de dados idb existente e se o valor gp j√° foi encontrado, ele √© carregado a partir do banco de dados, conforme mostrado na mensagem de depura√ß√£o no exemplo a seguir. <br><br><img src="https://habrastorage.org/webt/-y/z7/1u/-yz71u_odhytnmobj0dlfb73v-k.png"><br><br><h2>  Leitura e escrita sobre GP </h2><br>  As opera√ß√µes comuns s√£o de leitura e grava√ß√£o com um deslocamento relativo ao registro gp.  Por exemplo, no exemplo a seguir, s√£o realizadas tr√™s leituras e um registro desse tipo. <br><br><img src="https://habrastorage.org/webt/6b/0l/-b/6b0l-bqxv1qiuw5nvh3i08vvstk.png"><br><br>  Como j√° obtivemos o valor do endere√ßo armazenado no registrador gp, podemos resolver esse tipo de leitura e grava√ß√£o. <br><br>  Ap√≥s adicionar o processamento para situa√ß√µes de leitura e grava√ß√£o em rela√ß√£o ao registro gp, obtemos uma imagem mais conveniente. <br><br><img src="https://habrastorage.org/webt/wx/st/c1/wxstc1auiw0z0gvfzwmcooocooq.png"><br><br>  Aqui voc√™ pode ver quais vari√°veis ‚Äã‚Äãest√£o sendo acessadas, rastrear seu uso e identificar sua finalidade. <br><br><h2>  Endere√ßamento relativo ao GP </h2><br>  H√° outro uso do registro gp para endere√ßar vari√°veis. <br><br><img src="https://habrastorage.org/webt/ng/nn/oc/ngnnocz7scbya0x41l7gagf4bew.png"><br><br>  Por exemplo, aqui vemos que os registradores s√£o configurados em rela√ß√£o ao registrador gp para algumas vari√°veis ‚Äã‚Äãou √°reas de dados. <br><br>  Depois de adicionar a funcionalidade que reconhece essas situa√ß√µes, converte em compensa√ß√µes e adiciona refer√™ncias cruzadas, obtemos o seguinte formul√°rio. <br><br><img src="https://habrastorage.org/webt/sm/0d/nd/sm0dndgvrmn2xwivnfux3ol-t1e.png"><br><br>  Aqui voc√™ j√° pode ver quais √°reas relativas aos registros gp est√£o configuradas e fica mais claro o que est√° acontecendo. <br><br><h2>  Endere√ßamento relativo a sp </h2><br>  Da mesma forma, no exemplo a seguir, os registradores s√£o ajustados para algumas √°reas da mem√≥ria, desta vez em rela√ß√£o ao apontador sp do registrador para a pilha. <br><br><img src="https://habrastorage.org/webt/p1/nv/k7/p1nvk7gox_d3cwi1gof80k_oizq.png"><br><br>  Obviamente, os registros s√£o ajustados para algumas vari√°veis ‚Äã‚Äãlocais.  Tais situa√ß√µes - configurando argumentos para buffers locais antes das chamadas de procedimento - s√£o bastante comuns. <br><br>  Ap√≥s adicionar o processamento (converter valores diretos em compensa√ß√µes), obtemos o seguinte formul√°rio. <br><br><img src="https://habrastorage.org/webt/mg/8s/ps/mg8spswm9tq-_zjj-80s0s6lbnk.png"><br><br>  Agora, fica claro que, ap√≥s a chamada do procedimento, os valores s√£o carregados dessas vari√°veis ‚Äã‚Äãcujos endere√ßos foram passados ‚Äã‚Äãcomo par√¢metros antes da chamada da fun√ß√£o. <br><br><h2>  Refer√™ncias cruzadas do c√≥digo para os campos da estrutura </h2><br>  Definir estruturas e us√°-las no IDA Pro pode facilitar a an√°lise de c√≥digo. <br><br><img src="https://habrastorage.org/webt/l6/4u/8u/l64u8ubhx9-ypg1vo914_fa8vta.png"><br><br>  Observando esta parte do c√≥digo, podemos entender que o campo field_8 est√° aumentando e, possivelmente, √© um contador da ocorr√™ncia de um evento.  Se os campos de leitura e grava√ß√£o estiverem separados no c√≥digo a uma grande dist√¢ncia, a refer√™ncia cruzada poder√° ajudar. <br><br>  Considere a pr√≥pria estrutura. <br><br><img src="https://habrastorage.org/webt/px/zf/lt/pxzflte9x7kmxfrnipa_yjerstc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora o acesso aos campos de estruturas seja, como vemos, n√£o h√° refer√™ncias cruzadas do c√≥digo para os elementos das estruturas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois que essas situa√ß√µes s√£o processadas, para o nosso caso, tudo ficar√° da seguinte maneira. </font></font><br><br><img src="https://habrastorage.org/webt/k_/7t/zu/k_7tzupju7tyyje9r-i6ed6ra08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, existem refer√™ncias cruzadas para estruturar campos de equipes espec√≠ficas que trabalham com esses campos. </font><font style="vertical-align: inherit;">As refer√™ncias cruzadas para frente e para tr√°s s√£o criadas e √© poss√≠vel rastrear por diferentes procedimentos onde os valores dos campos da estrutura s√£o lidos e onde s√£o inseridos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Discrep√¢ncias entre manual e realidade </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No manual, ao decodificar alguns comandos, certos bits devem assumir valores estritamente definidos. </font><font style="vertical-align: inherit;">Por exemplo, para um comando de retorno de uma exce√ß√£o eret, os bits 22‚Äì26 devem ser 0x1E. </font></font><br><br><img src="https://habrastorage.org/webt/6r/o4/ys/6ro4ys-mrzuck_-stdnjctilwq8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° um exemplo deste comando de um firmware. </font></font><br><br><img src="https://habrastorage.org/webt/te/lv/at/telvatwfv4tmdjpaurhickredpo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrindo outro firmware em um local com um contexto semelhante, encontramos uma situa√ß√£o diferente. </font></font><br><br><img src="https://habrastorage.org/webt/ss/p3/qg/ssp3qgrbyu4stqyfht6mmzitgmi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses bytes n√£o foram convertidos automaticamente em um comando, embora haja processamento de todos os comandos. </font><font style="vertical-align: inherit;">A julgar pelo ambiente e at√© por um endere√ßo semelhante, deve ser a mesma equipe. </font><font style="vertical-align: inherit;">Vamos olhar atentamente para os bytes. </font><font style="vertical-align: inherit;">Este √© o mesmo comando eret, com a exce√ß√£o de que os bits 22‚Äì26 n√£o s√£o iguais a 0x1E, mas iguais a zero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos que corrigir a an√°lise deste comando um pouco. </font><font style="vertical-align: inherit;">Agora, isso n√£o corresponde exatamente ao manual, mas corresponde √† realidade.</font></font><br><br><img src="https://habrastorage.org/webt/as/fn/nl/asfnnlau91zf6y1aan-f3l__wz0.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suporte da AID 7 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir do IDA 7.0, a API fornecida pelo Python IDA para scripts regulares mudou bastante. Quanto aos m√≥dulos do processador, as mudan√ßas s√£o colossais. Apesar disso, o m√≥dulo do processador NIOS II p√¥de ser refeito para a vers√£o 7 e funcionou com √™xito. </font></font><br><br><img src="https://habrastorage.org/webt/-w/zh/z_/-wzhz_lzuq_ad226tgx_0abl3ke.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √∫nico momento incompreens√≠vel: ao carregar um novo arquivo bin√°rio no NIOS II no IDA 7, a an√°lise autom√°tica inicial presente no IDA 6.9 n√£o ocorre.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m da funcionalidade b√°sica de desmontagem, cujos exemplos est√£o no SDK, o m√≥dulo do processador implementa muitos recursos diferentes que facilitam o trabalho do explorador de c√≥digo. </font><font style="vertical-align: inherit;">Est√° claro que tudo isso pode ser feito manualmente, mas, por exemplo, quando existem milhares e dezenas de milhares de compensa√ß√µes de tipos diferentes em um arquivo bin√°rio com firmware de alguns megabytes, por que gastar tempo com isso? </font><font style="vertical-align: inherit;">Deixe o m√≥dulo do processador fazer isso por n√≥s. </font><font style="vertical-align: inherit;">Afinal, como est√£o os recursos agrad√°veis ‚Äã‚Äãda navega√ß√£o r√°pida pelo c√≥digo estudado usando refer√™ncias cruzadas! </font><font style="vertical-align: inherit;">Isso torna a IDA uma ferramenta conveniente e agrad√°vel como a conhecemos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postado por</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anton Dorfman, Positive Technologies</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424085/">https://habr.com/ru/post/pt424085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424071/index.html">Teoria da felicidade. Termodin√¢mica da desigualdade de classe</a></li>
<li><a href="../pt424073/index.html">Execu√ß√£o remota de c√≥digo no Mecanismo de Banco de Dados Microsoft JET</a></li>
<li><a href="../pt424077/index.html">A Fran√ßa exige tornar global o ‚Äúdireito ao esquecimento‚Äù - o que pode afetar</a></li>
<li><a href="../pt424081/index.html">RESS - Nova arquitetura para aplicativos m√≥veis</a></li>
<li><a href="../pt424083/index.html">Um servi√ßo de negocia√ß√£o na bolsa Robinhood foi acusado de vender dados sobre aplicativos de usu√°rios a traders de alta frequ√™ncia</a></li>
<li><a href="../pt424087/index.html">Dispositivo Android controlado por Bluetooth controlado por Arduino - ciclo completo (parte 1)</a></li>
<li><a href="../pt424089/index.html">Confer√™ncias s√£o m√°s. Ou bom?</a></li>
<li><a href="../pt424091/index.html">WiX.Py: coletamos o pacote MSI "em tr√™s linhas"</a></li>
<li><a href="../pt424093/index.html">Do r√°dio antigo aos alto-falantes DIY: 12 canais do YouTube para um dispositivo ac√∫stico</a></li>
<li><a href="../pt424099/index.html">Determinando a maturidade de uma melancia usando Keras: um ciclo completo, de uma ideia a um programa no Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>