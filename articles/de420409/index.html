<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😌 👌🏼 🌿 Lerne OpenGL. Lektion 5.7 - HDR 👨‍✈️ 🔆 🐥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Schreiben in den Framebuffer werden die Werte für die Helligkeit der Farben auf das Intervall von 0,0 bis 1,0 reduziert. Aus diesem auf den erste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lerne OpenGL. Lektion 5.7 - HDR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420409/"><img src="https://habrastorage.org/getpro/habr/post_images/20f/e6a/5f3/20fe6a5f38cfacad9ea8355ca097e8f4.png" width="200" align="left"><br><p>  Beim Schreiben in den Framebuffer werden die Werte für die Helligkeit der Farben auf das Intervall von 0,0 bis 1,0 reduziert.  Aus diesem auf den ersten Blick harmlosen Merkmal müssen wir immer solche Werte für Beleuchtung und Farben wählen, die in diese Einschränkung passen.  Dieser Ansatz funktioniert und liefert anständige Ergebnisse. Was passiert jedoch, wenn wir auf einen besonders hellen Bereich mit vielen hellen Lichtquellen treffen und die Gesamthelligkeit 1,0 überschreitet?  Infolgedessen werden alle Werte größer als 1.0 in 1.0 konvertiert, was nicht sehr gut aussieht: </p><br><p><img src="https://habrastorage.org/webt/cd/0m/ir/cd0mir8t9qcbakfwldnjibj3ay0.png"></p><br><p>  Da die Farbwerte für eine große Anzahl von Fragmenten auf 1,0 reduziert werden, werden große Bereiche des Bildes mit derselben weißen Farbe ausgefüllt, eine erhebliche Anzahl von Bilddetails geht verloren und das Bild selbst sieht unnatürlich aus. </p><br><p>  Die Lösung für dieses Problem könnte darin bestehen, die Helligkeit von Lichtquellen so zu verringern, dass keine Fragmente auf der Bühne heller als 1,0 sind. Dies ist nicht die beste Lösung, die die Verwendung unrealistischer Beleuchtungswerte erzwingt.  Der beste Ansatz besteht darin, die Helligkeitswerte vorübergehend die Helligkeit von 1,0 überschreiten zu lassen und im letzten Schritt die Farben so zu ändern, dass die Helligkeit in den Bereich von 0,0 bis 1,0 zurückkehrt, jedoch ohne Verlust von Bilddetails. </p><br><p>  Das Computerdisplay kann Farben mit einer Helligkeit im Bereich von 0,0 bis 1,0 anzeigen, aber wir haben keine solche Einschränkung bei der Berechnung der Beleuchtung.  Indem wir zulassen, dass die Farben des Fragments heller als eins sind, erhalten wir einen viel höheren Helligkeitsbereich für die Arbeit - HDR <em>(High Dynamic Range)</em> .  Mit hdr sehen helle Dinge hell aus, dunkle Dinge können wirklich dunkel sein, und dabei werden wir die Details sehen. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><p>  Teil 1. Erste Schritte <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fenstererstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Fenster</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Dreieck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koordinatensysteme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamera</a> </li></ol><br><p>  Teil 2. Grundbeleuchtung <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlagen der Beleuchtung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehrere Lichtquellen</a> </li></ol><br><p>  Teil 3. Laden Sie 3D-Modelle herunter <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assimp-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesh-Polygon-Klasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3D-Modellklasse</a> </li></ol><br><p>  Teil 4. Erweiterte OpenGL-Funktionen <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schablonentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbmischung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesichter schneiden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildpuffer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubische Karten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Datenverarbeitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geometrischer Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instanz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glätten</a> </li></ol><br><p>  Teil 5. Erweiterte Beleuchtung <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Beleuchtung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blinn-Fong-Modell.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gammakorrektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Omnidirektionale Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallaxenabbildung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blüte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgeschobenes Rendern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSAO</a> </li></ol><br><p>  Teil 6. Züchterrechte <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytische Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffuse Bestrahlung.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiegelbelichtung.</a> </li></ol></div></div><br><p>  Anfänglich wurde in der Fotografie ein hoher Dynamikbereich verwendet: Der Fotograf machte mehrere identische Fotos der Szene mit unterschiedlichen Belichtungen und nahm Farben mit nahezu jeder Helligkeit auf.  Die Kombination dieser Fotos bildet ein HDR-Bild, in dem die meisten Details aufgrund der Kombination von Bildern mit unterschiedlichen Belichtungsverlusten sichtbar werden.  Zum Beispiel sind unten links auf dem linken Bild stark beleuchtete Fragmente des Bildes deutlich sichtbar (siehe Fenster), aber diese Details verschwinden, wenn Sie eine hohe Belichtung verwenden.  Durch die hohe Belichtung werden jedoch Details in dunklen Bereichen des Bildes angezeigt, die zuvor nicht sichtbar waren. </p><br><p><img src="https://habrastorage.org/webt/hh/-0/0h/hh-00hpoeday-yolbntasroul14.png"></p><br><p>  Dies ähnelt der Funktionsweise des menschlichen Auges.  Bei Lichtmangel passt sich das Auge an, so dass die dunklen Details deutlich sichtbar werden, ähnlich wie bei hellen Bereichen.  Man kann sagen, dass das menschliche Auge abhängig von der Helligkeit der Szene eine automatische Belichtungssteuerung hat. </p><br><p>  Das HDR-Rendering funktioniert ähnlich.  Beim Rendern erlauben wir die Verwendung eines großen Bereichs von Helligkeitswerten, um Informationen über die hellen und dunklen Details der Szene zu sammeln, und am Ende konvertieren wir die Werte aus dem HDR-Bereich zurück in LDR (niedriger Dynamikbereich, Bereich von 0 bis 1).  Diese Transformation wird als <em>Tonabbildung bezeichnet</em> . Es gibt eine große Anzahl von Algorithmen, die darauf abzielen, die meisten Bilddetails bei der Konvertierung in LDR beizubehalten.  Diese Algorithmen haben häufig eine Belichtungseinstellung, mit der sie helle oder dunkle Bereiche des Bildes besser anzeigen können. </p><br><p>  Durch die Verwendung von HDR beim Rendern können wir nicht nur den LDR-Bereich von 0 bis 1 überschreiten und mehr Bilddetails speichern, sondern auch die tatsächliche Helligkeit der Lichtquellen anzeigen.  Zum Beispiel hat die Sonne eine viel größere Helligkeit als eine Taschenlampe. Warum also nicht die Sonne darauf einstellen (zum Beispiel eine Helligkeit von 10,0)?  Auf diese Weise können wir die Beleuchtung der Szene mit realistischeren Helligkeitsparametern besser anpassen, was mit LDR-Rendering und einem Helligkeitsbereich von 0 bis 1 unmöglich wäre. </p><br><p>  Da das Display nur eine Helligkeit von 0 bis 1 anzeigt, müssen wir den verwendeten HDR-Wertebereich wieder in den Bereich des Monitors konvertieren.  Eine einfache Skalierung des Bereichs ist keine gute Lösung, da helle Bereiche das Bild dominieren.  Wir können jedoch verschiedene Gleichungen oder Kurven verwenden, um die HDR-Werte in LDR umzuwandeln, wodurch wir die volle Kontrolle über die Helligkeit der Szene erhalten.  Diese Transformation wird als <em>Tonzuordnung bezeichnet</em> und ist der letzte Schritt beim HDR-Rendering. </p><br><h3 id="freymbufery-s-plavayuschey-tochkoy">  Gleitkomma-Framebuffer </h3><br><p>  Um das HDR-Rendering zu implementieren, müssen wir verhindern, dass Werte vom Fragment-Shader in einen Bereich von 0 bis 1 gebracht werden.  Wenn der Framebuffer das normalisierte Festkommaformat (GL_RGB) für Farbpuffer verwendet, begrenzt OpenGL die Werte automatisch, bevor sie im Framebuffer gespeichert werden.  Diese Einschränkung gilt für die meisten Framebuffer-Formate mit Ausnahme von Gleitkommaformaten. </p><br><p> Zum Speichern von Werten, die außerhalb des Bereichs [0.0..1.0] liegen, können Sie einen <code>GL_RGB16F, GL_RGBA16F, GL_RGB32F or GL_RGBA32F</code> mit den folgenden Formaten verwenden: <code>GL_RGB16F, GL_RGBA16F, GL_RGB32F or GL_RGBA32F</code> .  Dies ist ideal für das HDR-Rendering.  Ein solcher Puffer wird als Gleitkomma-Framebuffer bezeichnet. </p><br><p>  Das Erstellen eines Gleitkommapuffers unterscheidet sich von einem regulären Puffer nur dadurch, dass ein anderes internes Format verwendet wird: </p><br><pre> <code class="plaintext hljs">glBindTexture(GL_TEXTURE_2D, colorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);</code> </pre> <br><p>  Der OpenGL-Framebuffer verwendet standardmäßig nur 8 Bit zum Speichern jeder Farbe.  Im Gleitkomma-Framebuffer mit den Formaten <code>GL_RGB32F</code> oder <code>GL_RGBA32F</code> werden 32 Bit zum Speichern jeder Farbe verwendet - viermal mehr.  Wenn keine sehr hohe Genauigkeit erforderlich ist, ist das Format <code>GL_RGBA16F</code> völlig ausreichend. </p><br><p>  Wenn für die Farbe ein Gleitkommapuffer an den Framebuffer angehängt ist, können wir die Szene darin rendern, wobei zu berücksichtigen ist, dass die Farbwerte nicht auf den Bereich von 0 bis 1 beschränkt sind. Im Code für diesen Artikel rendern wir die Szene zuerst in den Gleitkomma-Framebuffer und zeigen dann den Inhalt an Farbpuffer auf einem Halbbild-Rechteck.  Es sieht ungefähr so ​​aus: </p><br><pre> <code class="plaintext hljs">glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // [...]    hdr glBindFramebuffer(GL_FRAMEBUFFER, 0); //  hdr    2     hdrShader.use(); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, hdrColorBufferTexture); RenderQuad();</code> </pre> <br><p>  Hier können die im Farbpuffer enthaltenen Farbwerte größer als 1 sein. Für diesen Artikel wurde eine Szene mit einem großen länglichen Würfel erstellt, der wie ein Tunnel mit vier Punktlichtquellen aussieht, von denen sich eine am Ende des Tunnels befindet und eine große Helligkeit aufweist. </p><br><pre> <code class="plaintext hljs">std::vector&lt;glm::vec3&gt; lightColors; lightColors.push_back(glm::vec3(200.0f, 200.0f, 200.0f)); lightColors.push_back(glm::vec3(0.1f, 0.0f, 0.0f)); lightColors.push_back(glm::vec3(0.0f, 0.0f, 0.2f)); lightColors.push_back(glm::vec3(0.0f, 0.1f, 0.0f));</code> </pre> <br><p>  Das Rendern in den Gleitkommapuffer ist genau das gleiche, als würden wir die Szene in einen regulären Framebuffer rendern.  Das einzig Neue ist der fragmentierte HDR-Shader, der sich mit einer einfachen Schattierung eines Vollbild-Rechtecks ​​mit Werten aus einer Textur befasst, die ein Gleitkomma-Farbpuffer ist.  Schreiben wir zunächst einen einfachen Shader, der die Eingabedaten unverändert überträgt: </p><br><pre> <code class="plaintext hljs">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D hdrBuffer; void main() { vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; FragColor = vec4(hdrColor, 1.0); }</code> </pre> <br><p>  Wir nehmen die Eingabe vom Gleitkomma des Farbpuffers und verwenden sie als Ausgabewert des Shaders.  Da das 2D-Rechteck jedoch standardmäßig in den Framebuffer gerendert wird, sind die Ausgabewerte des Shaders auf ein Intervall von 0 bis 1 begrenzt, obwohl die Werte an einigen Stellen größer als 1 sind. </p><br><p><img src="https://habrastorage.org/webt/rw/mb/ds/rwmbdsi_qc8fjdssulhqwwzk3rg.png"></p><br><p>  Es wird deutlich, dass zu große Farbwerte am Ende des Tunnels auf Eins beschränkt sind, da ein erheblicher Teil des Bildes vollständig weiß ist und wir Bilddetails verlieren, die heller als Einheit sind.  Da wir HDR-Werte direkt als LDR verwenden, entspricht dies dem Fehlen von HDR.  Um dies zu beheben, müssen wir die verschiedenen Farbwerte wieder im Bereich von 0 bis 1 anzeigen, ohne dass Details im Bild verloren gehen.  Wenden Sie dazu die Tonkomprimierung an. </p><br><h3 id="tonalnaya-kompressiya">  Tonkomprimierung </h3><br><p>  Die Tonkomprimierung ist die Konvertierung von Farbwerten, um sie in den Bereich von 0 bis 1 anzupassen, ohne Bilddetails zu verlieren, häufig in Kombination mit dem gewünschten Weißabgleich für das Bild. </p><br><p>  Der einfachste <em>Tonabbildungsalgorithmus</em> ist als <em>Reinhard-Tonabbildungsalgorithmus bekannt</em> .  Es werden alle HDR-Werte im LDR-Bereich angezeigt.  Fügen Sie diesen Algorithmus dem vorherigen Fragment-Shader hinzu und wenden Sie auch die Gammakorrektur (und die Verwendung von SRGB-Texturen) an. </p><br><pre> <code class="plaintext hljs">void main() { const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; //   vec3 mapped = hdrColor / (hdrColor + vec3(1.0)); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</code> </pre> <br><blockquote>  Hinweis  trans.  - Für kleine Werte von x verhält sich die Funktion x / (1 + x) ungefähr wie x, für große x tendiert sie zur Einheit.  Funktionsgraph: </blockquote><p><img src="https://habrastorage.org/webt/sz/oq/ao/szoqaojobtfzh5_m5htgu_nh2_y.png"></p><br><p>  Mit der Reinhardt-Tonkomprimierung verlieren wir keine Details mehr in hellen Bereichen des Bildes.  Der Algorithmus bevorzugt helle Bereiche, wodurch dunkle Bereiche weniger deutlich werden. </p><br><p><img src="https://habrastorage.org/webt/jm/um/3c/jmum3cplqvaaqwhh96nzrrlhuc4.png"></p><br><p>  Hier sehen Sie am Ende des Bildes wieder Details wie die Holzstruktur.  Mit diesem relativ einfachen Algorithmus können wir alle Farben aus dem HDR-Bereich klar erkennen und die Beleuchtung der Szene steuern, ohne Bilddetails zu verlieren. </p><br><blockquote>  Es ist erwähnenswert, dass wir die Tonwertkomprimierung direkt am Ende unseres Shaders verwenden können, um die Beleuchtung zu berechnen, und dann benötigen wir überhaupt keinen Gleitkomma-Framebuffer.  In komplexeren Szenen müssen Sie jedoch häufig HDR-Zwischenwerte in Gleitkommapuffern speichern, was sich als nützlich erweist. </blockquote><p>  Ein weiteres interessantes Merkmal der Tonkomprimierung ist die Verwendung eines Belichtungsparameters.  Sie können sich daran erinnern, dass in den Bildern am Anfang des Artikels verschiedene Details bei unterschiedlichen Belichtungswerten sichtbar waren.  Wenn wir eine Szene haben, in der sich Tag und Nacht ändern, ist es sinnvoll, tagsüber eine niedrige Belichtung und nachts eine hohe Belichtung zu verwenden, was der Anpassung des menschlichen Auges ähnelt.  Mit diesem Belichtungsparameter können wir Beleuchtungsparameter konfigurieren, die Tag und Nacht unter verschiedenen Lichtbedingungen funktionieren. </p><br><p>  Ein relativ einfacher Tonkomprimierungsalgorithmus mit Belichtung sieht folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; //     vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</code> </pre> <br><blockquote>  Hinweis  per: Fügen Sie ein Diagramm für diese Funktion mit Belichtung 1 und 2 hinzu: </blockquote><p><img src="https://habrastorage.org/webt/3j/fj/zi/3jfjzibpldumgonxyhin6ydi-ao.png"></p><br><p>  Hier haben wir eine Variable für die Belichtung definiert, die standardmäßig 1 ist und es uns ermöglicht, das Gleichgewicht zwischen der Anzeigequalität von dunklen und hellen Bereichen des Bildes genauer zu wählen.  Bei einer großen Belichtung sehen wir beispielsweise viel mehr Details in den dunklen Bereichen des Bildes.  Umgekehrt macht eine geringe Belichtung dunkle Bereiche nicht unterscheidbar, ermöglicht es Ihnen jedoch, helle Bereiche des Bildes besser zu sehen.  Unten sehen Sie Bilder eines Tunnels mit unterschiedlichen Belichtungsstufen. </p><br><p><img src="https://habrastorage.org/webt/ae/kx/vf/aekxvfxdggv34kzeqcoxy9tjdps.png"></p><br><p>  Diese Bilder zeigen deutlich die Vorteile des HDR-Renderings.  Wenn sich die Belichtungsstufe ändert, sehen wir mehr Details der Szene, die beim normalen Rendern verloren gehen würden.  Nehmen Sie als Beispiel das Ende des Tunnels - bei normaler Belichtung ist die Textur des Baumes kaum sichtbar, bei geringer Belichtung ist die Textur jedoch perfekt sichtbar.  In ähnlicher Weise sind bei hoher Belichtung Details in dunklen Bereichen sehr deutlich sichtbar. </p><br><p>  Der Quellcode für die Demo ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a> </p><br><h3 id="bolshe-hdr">  Mehr HDR </h3><br><p>  Diese beiden gezeigten Tonkomprimierungsalgorithmen sind nur ein kleiner Teil einer großen Anzahl fortgeschrittener Algorithmen, von denen jeder seine eigenen Stärken und Schwächen hat.  Einige Algorithmen betonen bestimmte Farben / Helligkeiten besser, andere Algorithmen zeigen gleichzeitig dunkle und helle Bereiche an und liefern farbenfrohere und detailliertere Bilder.  Es gibt auch viele Methoden, die als <em>automatische Belichtungsanpassung</em> oder <em>Augenanpassung bekannt sind</em> .  Sie bestimmen die Helligkeit der Szene im vorherigen Bild und ändern (langsam) den Belichtungsparameter, so dass die dunkle Szene langsam heller und die hell-dunkler wird: ähnlich der Gewöhnung des menschlichen Auges. </p><br><p>  Die wirklichen Vorteile von HDR lassen sich am besten an großen und komplexen Szenen mit seriösen Beleuchtungsalgorithmen erkennen.  In diesem Artikel wurde zu Schulungszwecken die einfachste Szene verwendet, da das Erstellen einer großen Szene schwierig sein kann.  Trotz der Einfachheit der Szene sind einige Vorteile des HDR-Renderings sichtbar: In den dunklen und hellen Bereichen des Bildes gehen keine Details verloren, da sie mithilfe der Tonkomprimierung gespeichert werden, das Hinzufügen mehrerer Lichtquellen nicht zum Auftreten weißer Bereiche führt und die Werte nicht in LDR passen müssen Reichweite. </p><br><p>  Darüber hinaus macht das HDR-Rendering einige interessante Effekte glaubwürdiger und realistischer.  Einer dieser Effekte ist die Blüte, die wir in einem zukünftigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> diskutieren werden. </p><br><h3 id="dopolnitelnye-resursy">  Zusätzliche Ressourcen: </h3><br><ul><li>  Eine Stapelaustauschfrage mit einer langen Antwort, die einige der Vorteile des HDR-Renderings beschreibt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hat das HDR-Rendering Vorteile, wenn Bloom nicht angewendet wird?</a> </li><li>  Eine weitere interessante Antwort mit guten Bildern als Beispiele für die Tonkomprimierung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist Tonzuordnung?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie hängt es mit HDR zusammen?</a> </li></ul><br><p>  <strong>PS</strong> Wir haben ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm conf</a> für die Koordination von Überweisungen.  Wenn Sie ernsthaft bei der Übersetzung helfen möchten, sind Sie herzlich willkommen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420409/">https://habr.com/ru/post/de420409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420393/index.html">PHP, YII2 und die Bildung großer Excel-Dateien</a></li>
<li><a href="../de420395/index.html">"Kostenlose" Tabletten für Gefangene - überhaupt nicht kostenlos</a></li>
<li><a href="../de420397/index.html">Wissenschaftler haben einen Weg gefunden, den Alterungsprozess von Zellen umzukehren</a></li>
<li><a href="../de420405/index.html">Untersuchung des IT-Verkaufsprozesses</a></li>
<li><a href="../de420407/index.html">C ist keine einfache Sprache</a></li>
<li><a href="../de420413/index.html">SQLite und NW.js - Schritt-für-Schritt-Anleitungen zum Erstellen starker Freundschaften</a></li>
<li><a href="../de420415/index.html">Alles, was Sie über das Testen von Wi-Fi-Adaptern wissen wollten, aber Angst hatten zu fragen</a></li>
<li><a href="../de420419/index.html">Läufer für diejenigen, die Demütigung mögen oder wie wir PixJam verändert und modifiziert haben</a></li>
<li><a href="../de420423/index.html">Probleme mit der Schnittstelle zwischen Bodenkreuzung</a></li>
<li><a href="../de420425/index.html">Theorie und Praxis der Verwendung von HBase</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>