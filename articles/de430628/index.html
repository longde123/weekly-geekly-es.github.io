<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüåæ ü§∫ üôÖüèæ Fortune-Algorithmus, Implementierungsdetails üé∑ üßû üå∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Wochen habe ich an der Implementierung des Fortune-Algorithmus in C ++ gearbeitet. Dieser Algorithmus verwendet viele 2D-Punkte und ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fortune-Algorithmus, Implementierungsdetails</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/"> In den letzten Wochen habe ich an der Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortune-Algorithmus</a> in C ++ gearbeitet.  Dieser Algorithmus verwendet viele 2D-Punkte und erstellt daraus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Voronoi-Diagramm</a> .  Wenn Sie nicht wissen, was ein Voronoi-Diagramm ist, sehen Sie sich die Abbildung an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br>  F√ºr jeden Einstiegspunkt, der als ‚ÄûSite‚Äú bezeichnet wird, m√ºssen wir viele Punkte finden, die n√§her an diesem Ort liegen als an allen anderen.  Solche Punkts√§tze bilden die im obigen Bild gezeigten Zellen. <br><br>  Es ist bemerkenswert in Fortunes Algorithmus, dass er solche Diagramme rechtzeitig erstellt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">O</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">n</span><span class="MJXp-mtext" id="MJXp-Span-5">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">n</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-29" x="3868" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> O (n \ log n) </script>  (was f√ºr einen Vergleichsalgorithmus optimal ist), wobei <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  Ist die Anzahl der Pl√§tze. <br><br>  Ich schreibe diesen Artikel, weil ich die Implementierung dieses Algorithmus f√ºr eine sehr schwierige Aufgabe halte.  Im Moment ist dies der komplizierteste der Algorithmen, die ich implementieren musste.  Daher m√∂chte ich die Probleme, auf die ich gesto√üen bin, und deren L√∂sung teilen. <br><br>  Wie √ºblich wird der Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github ver√∂ffentlicht</a> , und alle von mir verwendeten Referenzmaterialien sind am Ende des Artikels aufgef√ºhrt. <br><a name="habracut"></a><br><h1>  Beschreibung des Fortune-Algorithmus </h1><br>  Ich werde nicht erkl√§ren, wie der Algorithmus funktioniert, weil andere Leute es bereits gut gemacht haben.  Ich kann empfehlen, diese beiden Artikel zu studieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Das zweite ist sehr interessant - der Autor hat eine interaktive Demo in Javascript geschrieben, die zum Verst√§ndnis der Funktionsweise des Algorithmus hilfreich ist.  Wenn Sie einen formelleren Ansatz mit allen Beweisen ben√∂tigen, empfehle ich, Kapitel 7 der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Computational Geometry, 3. Ausgabe, zu</em></a> lesen. <br><br>  Au√üerdem besch√§ftige ich mich lieber mit Implementierungsdetails, die nicht gut dokumentiert sind.  Und sie machen die Implementierung des Algorithmus so komplex.  Insbesondere werde ich mich auf die verwendeten Datenstrukturen konzentrieren. <br><br>  Ich habe gerade einen Pseudocode des Algorithmus geschrieben, damit Sie eine Vorstellung von seiner globalen Struktur bekommen: <br><br><blockquote><pre>  F√ºgen Sie der Ereigniswarteschlange f√ºr jeden Ort ein Ortsereignis hinzu
 bis die Ereigniswarteschlange leer ist
     Rufen Sie das Top-Ereignis ab
     wenn das Ereignis ein Ortsereignis ist
         F√ºgen Sie einen neuen Bogen in die K√ºste ein
         Suchen Sie nach neuen Kreisereignissen
     sonst
         Erstellen Sie einen Scheitelpunkt im Diagramm
         Wir entfernen einen festgezogenen Bogen von der K√ºste
         ung√ºltige Ereignisse l√∂schen
         Suchen Sie nach neuen Kreisereignissen </pre></blockquote><br><h1>  Diagrammdatenstruktur </h1><br>  Das erste Problem, auf das ich stie√ü, war die Wahl der Art und Weise, wie das Voronoi-Diagramm gespeichert werden soll. <br><br>  Ich entschied mich f√ºr eine Datenstruktur, die in der Computergeometrie weit verbreitet ist und als doppelt verbundene Kantenliste (DCEL) bezeichnet wird. <br><br>  Meine <code>VoronoiDiagram</code> Klasse verwendet vier Container als Felder: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br>  Ich werde √ºber jeden von ihnen ausf√ºhrlich sprechen. <br><br>  Die <code>Site</code> Klasse beschreibt den Einstiegspunkt.  Jeder Ort hat einen Index, der n√ºtzlich ist, um ihn in die Warteschlange zu stellen, Koordinaten und einen Zeiger auf die Zelle ( <code>face</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br>  Die Eckpunkte der Zelle werden durch die <code>Vertex</code> Klasse dargestellt, sie haben nur ein Koordinatenfeld: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br>  Hier ist die Implementierung der Halbkanten: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br>  Sie fragen sich vielleicht, was ist eine halbe Rippe?  Eine Kante im Voronoi-Diagramm ist zwei benachbarten Zellen gemeinsam.  In der DCEL-Datenstruktur teilen wir diese Kanten in zwei Halbkanten, eine f√ºr jede Zelle, und sie sind durch einen Doppelzeiger verbunden.  Dar√ºber hinaus hat die Halbkante einen Start- und einen Endpunkt.  Das <code>incidentFace</code> Feld gibt die Fl√§che an, zu der die Halbkante geh√∂rt.  Zellen in DCEL werden als zyklische doppelt verkn√ºpfte Liste von Halbkanten implementiert, in der benachbarte Halbkanten miteinander verbunden sind.  Daher geben die Felder <code>prev</code> und <code>next</code> die vorherige und die n√§chste Halbkante in der Zelle an. <br><br>  Die folgende Abbildung zeigt alle diese Felder f√ºr die rote Halbkante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br>  Schlie√ülich definiert die <code>Face</code> Klasse die Zelle.  Es enth√§lt einfach einen Zeiger auf seinen Platz und einen anderen auf eine seiner Halbrippen.  Es spielt keine Rolle, welche der Halbkanten ausgew√§hlt ist, da die Zelle ein geschlossenes Polygon ist.  Auf diese Weise erhalten wir Zugriff auf alle Halbkanten, w√§hrend wir eine zyklisch verkn√ºpfte Liste durchlaufen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1>  Ereigniswarteschlange </h1><br>  Die Standardmethode zum Implementieren einer Ereigniswarteschlange ist eine Priorit√§tswarteschlange.  Bei der Verarbeitung von Orts- und Kreisereignissen m√ºssen wir m√∂glicherweise Kreisereignisse aus der Warteschlange entfernen, da sie nicht mehr g√ºltig sind.  Bei den meisten Implementierungen von Warteschlangen mit Standardpriorit√§t k√∂nnen Sie jedoch kein Element l√∂schen, das sich nicht oben befindet.  Dies gilt insbesondere f√ºr <code>std::priority_queue</code> . <br><br>  Es gibt zwei M√∂glichkeiten, um dieses Problem zu l√∂sen.  Die erste, einfachere M√∂glichkeit besteht darin, Ereignissen ein <code>valid</code> Flag hinzuzuf√ºgen.  <code>valid</code> wird zun√§chst auf <code>true</code> .  Anstatt das Kreisereignis aus der Warteschlange zu entfernen, k√∂nnen wir sein Flag einfach auf <code>false</code> .  Wenn wir schlie√ülich alle Ereignisse in der Hauptschleife verarbeiten, pr√ºfen wir, ob der <code>valid</code> Flag-Wert des Ereignisses <code>false</code> ist. Wenn ja, √ºberspringen Sie ihn einfach und verarbeiten Sie den n√§chsten. <br><br>  Die zweite Methode, die ich angewendet habe, war, nicht <code>std::priority_queue</code> .  Stattdessen habe ich meine eigene Priorit√§tswarteschlange implementiert, die das Entfernen aller darin enthaltenen Elemente unterst√ºtzt.  Die Implementierung einer solchen Warteschlange ist recht einfach.  Ich habe diese Methode gew√§hlt, weil sie den Algorithmuscode sauberer macht. <br><br><h1>  K√ºste </h1><br>  Die K√ºstenlinien-Datenstruktur ist ein komplexer Teil des Algorithmus.  Bei falscher Implementierung gibt es keine Garantie daf√ºr, dass der Algorithmus in ausgef√ºhrt wird <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">O</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">n</span><span class="MJXp-mtext" id="MJXp-Span-17">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">n</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-29" x="3868" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> O (n \ log n) </script>  .  Der Schl√ºssel, um diese zeitliche Komplexit√§t zu erreichen, ist die Verwendung eines selbstausgleichenden Baums.  Aber es ist leichter gesagt als getan! <br><br>  Den meisten Ressourcen, die ich untersucht habe (die beiden oben genannten Artikel und das Buch <em>Computational Geometry</em> ), wird empfohlen, die K√ºstenlinie als Baum zu implementieren, in dem interne Knoten Bruchpunkte und Bl√§tter B√∂gen anzeigen.  Aber sie sagen nichts dar√ºber, wie man einen Baum balanciert.  Ich denke, dass ein solches Modell nicht das beste ist, und hier ist der Grund: <br><br><ul><li>  Es enth√§lt redundante Informationen: Wir wissen, dass es einen Unterbrechungspunkt zwischen zwei benachbarten B√∂gen gibt, daher ist es nicht erforderlich, diese Punkte als Knoten darzustellen </li><li>  es ist nicht ausreichend f√ºr den Selbstausgleich: Nur der durch Bruchstellen gebildete Teilbaum kann ausgeglichen werden.  Wir k√∂nnen wirklich nicht den gesamten Baum ausbalancieren, da die B√∂gen sonst zu internen Knoten und Bl√§ttern von Haltepunkten werden k√∂nnen.  Das Schreiben eines Algorithmus, um nur den von internen Knoten gebildeten Teilbaum auszugleichen, scheint mir ein Albtraum zu sein. </li></ul><br>  Deshalb habe ich beschlossen, die K√ºste anders darzustellen.  In meiner Implementierung ist die K√ºste auch ein Baum, aber alle Knoten sind B√∂gen.  Ein solches Modell weist keinen der aufgef√ºhrten Nachteile auf. <br><br>  Hier ist die Definition von <code>Arc</code> Arc in meiner Implementierung: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br>  Die ersten drei Felder dienen zur Strukturierung des Baums.  Das Feld <code>leftHalfEdge</code> gibt die Halbkante an, die vom <code>leftHalfEdge</code> linken Punkt des Bogens gezeichnet wird.  Und <code>rightHalfEdge</code> befindet sich an der halben Kante, die vom √§u√üersten rechten Punkt gezeichnet wird.  Zwei Zeiger, <code>prev</code> und <code>next</code> werden verwendet, um direkten Zugriff auf den vorherigen und n√§chsten Bogen der K√ºste zu erhalten.  Dar√ºber hinaus k√∂nnen Sie die K√ºste als doppelt verkn√ºpfte Liste umgehen.  Schlie√ülich hat jeder Bogen eine Farbe, mit der die K√ºstenlinie ausgeglichen wird. <br><br>  Um die K√ºste auszugleichen, entschied ich mich f√ºr ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rot-schwarzes Schema</a> .  Beim Schreiben von Code hat mich das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in Algorithmen</a> inspiriert.  Kapitel 13 beschreibt zwei interessante Algorithmen, <code>insertFixup</code> und <code>deleteFixup</code> , die den Baum nach dem Einf√ºgen oder L√∂schen ausgleichen. <br><br>  Ich kann die im Buch gezeigte <code>insert</code> jedoch nicht verwenden, da die Schl√ºssel verwendet werden, um die Einf√ºgemarke des Knotens zu finden.  Der Fortune-Algorithmus enth√§lt keine Schl√ºssel. Wir wissen nur, dass wir einen Bogen vor oder nach dem anderen in die K√ºste einf√ºgen m√ºssen.  Um dies zu implementieren, habe ich die <code>insertAfter</code> <code>insertBefore</code> und <code>insertAfter</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br>  Das Einf√ºgen von <code>y</code> vor <code>x</code> erfolgt in drei Schritten: <br><br><ol><li>  Suchen Sie einen Platz zum Einf√ºgen eines neuen Knotens.  Zu diesem Zweck habe ich die folgende Beobachtung verwendet: Das linke Kind <code>x</code> oder das rechte Kind <code>x-&gt;prev</code> ist <code>Nil</code> , und dasjenige, das <code>Nil</code> ist, steht vor <code>x</code> und nach <code>x-&gt;prev</code> . </li><li>  Innerhalb der K√ºste behalten wir die Struktur einer doppelt verkn√ºpften Liste bei, daher m√ºssen wir die <code>prev</code> und <code>next</code> Zeiger der Elemente <code>x-&gt;prev</code> , <code>y</code> und <code>x</code> entsprechend aktualisieren. </li><li>  Schlie√ülich rufen wir einfach die im Buch beschriebene Methode <code>insertFixup</code> auf, um den Baum auszugleichen. </li></ol><br>  <code>insertAfter</code> wird √§hnlich implementiert. <br><br>  Die Entfernungsmethode aus dem Buch kann ohne √Ñnderungen implementiert werden. <br><br><h1>  Diagrammlimit </h1><br>  Hier ist die Ausgabe des oben beschriebenen Fortune-Algorithmus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br>  Es gibt ein kleines Problem mit einigen Kanten von Zellen am Rand des Bildes: Sie werden nicht gezeichnet, weil sie unendlich sind. <br><br>  Schlimmer noch, eine Zelle ist m√∂glicherweise kein einzelnes Fragment.  Wenn wir beispielsweise drei Punkte auf derselben Linie nehmen, hat der Mittelpunkt zwei unendliche Halbkanten, die nicht miteinander verbunden sind.  Dies passt nicht sehr gut zu uns, da wir nicht auf eine der halben Kanten zugreifen k√∂nnen, da die Zelle eine verkn√ºpfte Liste von Kanten ist. <br><br>  Um diese Probleme zu l√∂sen, werden wir das Diagramm einschr√§nken.  Damit meine ich, dass wir jede Zelle des Diagramms so einschr√§nken, dass sie keine unendlichen Kanten mehr hat und jede Zelle ein geschlossenes Polygon ist. <br><br>  Gl√ºcklicherweise k√∂nnen wir mit dem Fortune-Algorithmus schnell endlose Kanten finden: Sie entsprechen Halbkanten, die sich am Ende des Algorithmus noch an der K√ºste befinden. <br><br>  Mein Restriktionsalgorithmus erh√§lt eine Box als Eingabe und besteht aus drei Schritten: <br><br><ol><li>  Es erm√∂glicht die Platzierung jedes Scheitelpunkts des Diagramms innerhalb des Rechtecks. </li><li>  Schneiden Sie jede unendliche Kante ab. </li><li>  Schlie√üt Zellen. </li></ol><br>  Stufe 1 ist trivial - wir m√ºssen das Rechteck nur erweitern, wenn es keinen Scheitelpunkt enth√§lt. <br><br>  Stufe 2 ist ebenfalls recht einfach: Sie besteht aus der Berechnung der Schnittpunkte zwischen den Strahlen und dem Rechteck. <br><br>  Stufe 3 ist auch nicht sehr kompliziert, erfordert nur Aufmerksamkeit.  Ich f√ºhre es in zwei Stufen durch.  Zuerst f√ºge ich die Eckpunkte des Rechtecks ‚Äã‚Äãzu den Zellen hinzu, an deren Eckpunkten sie sein sollten.  Dann stelle ich sicher, dass alle Eckpunkte der Zelle durch Halbkanten verbunden sind. <br><br>  Ich empfehle Ihnen, den Code zu studieren und Fragen zu stellen, wenn Sie Details zu diesem Teil ben√∂tigen. <br><br>  Hier ist das Ausgabediagramm des Begrenzungsalgorithmus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br>  Jetzt sehen wir, dass alle Kanten gezeichnet sind.  Und wenn Sie verkleinern, k√∂nnen Sie sicherstellen, dass alle Zellen geschlossen sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1>  Schnittpunkt mit Rechteck </h1><br>  Gro√üartig!  Aber das erste Bild vom Anfang des Artikels ist besser, oder? <br><br>  In vielen Anwendungen ist es n√ºtzlich, den Schnittpunkt zwischen dem Voronoi-Diagramm und dem Rechteck zu haben, wie im ersten Bild gezeigt. <br><br>  Das Gute ist, dass es nach dem Einschr√§nken des Diagramms viel einfacher ist, dies zu tun.  Die schlechte Nachricht ist, dass wir vorsichtig sein m√ºssen, obwohl der Algorithmus nicht sehr kompliziert ist. <br><br>  Die Idee ist folgende: Wir gehen um die halbe Kante jeder Zelle herum und √ºberpr√ºfen den Schnittpunkt zwischen der halben Kante und dem Rechteck.  F√ºnf F√§lle sind m√∂glich: <br><br><ol><li>  Die Halbrippe befindet sich vollst√§ndig innerhalb des Rechtecks: Wir speichern eine solche Halbrippe </li><li>  Die Halbrippe befindet sich vollst√§ndig au√üerhalb des Rechtecks: Wir werfen eine solche Halbrippe weg </li><li>  Die Halbrippe geht au√üerhalb des Rechtecks: Wir schneiden die Halbrippe ab und speichern sie als die <em>letzte Halbrippe, die ausgeht</em> . </li><li>  Die Halbrippe geht in das Rechteck: Wir schneiden die Halbrippe ab, um sie mit der <em>letzten</em> Halbrippe zu verbinden <em>, die ausgegangen ist</em> (wir speichern sie in Fall 3 oder 5). </li><li>  Die Halbrippe kreuzt das Rechteck zweimal: Wir schneiden die Halbrippe ab und f√ºgen eine Halbrippe hinzu, um sie mit der <em>letzten</em> Halbrippe zu verkn√ºpfen <em>, die ausgeht</em> , und speichern sie dann als die neue <em>letzte Halbrippe, die ausgeht</em> . </li></ol><br>  Ja, es gab viele F√§lle.  Ich habe ein Bild erstellt, um sie alle zu zeigen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br>  Das orangefarbene Polygon ist die urspr√ºngliche Zelle und das rote ist die abgeschnittene Zelle.  Abgeschnittene Halbrippen sind rot markiert.  Gr√ºne Rippen wurden hinzugef√ºgt, um die in das Rechteck eintretenden Halbrippen mit den herauskommenden Halbrippen zu verbinden. <br><br>  Wenn wir diesen Algorithmus auf ein begrenztes Diagramm anwenden, erhalten wir das erwartete Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1>  Fazit </h1><br>  Der Artikel erwies sich als ziemlich lang.  Und ich bin sicher, dass Ihnen viele Aspekte immer noch nicht klar sind.  Trotzdem hoffe ich, dass es Ihnen n√ºtzlich sein wird.  Untersuchen Sie den Code auf Details. <br><br>  Um zusammenzufassen und sicherzustellen, dass wir keine Zeit umsonst verschwendeten, habe ich auf meinem (billigen) Laptop die Zeit gemessen, um das Voronoi-Diagramm f√ºr eine andere Anzahl von Orten zu berechnen: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-23"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">n</span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-26">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1501" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  : 2 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">n</span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-30"><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-32">10.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.952ex" height="2.298ex" viewBox="0 -832 4715.6 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1780" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-5"> n = $ 10.00</script>  : 33 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">n</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-36"><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-38">100.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.115ex" height="2.298ex" viewBox="0 -832 5216.1 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="2280" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n = $ 100.00</script>  : 450 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-44">1.000.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.924ex" height="2.298ex" viewBox="0 -832 5995.1 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="2280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="2559" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="3059" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> n = $ 1.000.00</script>  : 6600 ms </li></ul><br>  Ich habe nichts mit diesen Indikatoren zu vergleichen, aber es scheint, dass es unglaublich schnell ist! <br><br><h1>  Referenzen </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel von Stephen Fortune</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Computational Geometry, 3. Auflage</em></a> von Mark de Berg, Otfried Cheong, Marc van Kreveld und Mark Overmars </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortunes-Algorithmus: Eine intuitive Erkl√§rung</a> auf jacquesheunis.com </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortunes Algorithmus und Implementierung</a> auf blog.ivank.net </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Einf√ºhrung in Algorithmen, 3. Auflage</em></a> von Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest und Clifford Stein </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430628/">https://habr.com/ru/post/de430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430616/index.html">Seminar "Testen und √úberwachen", 27. November, Moskau</a></li>
<li><a href="../de430618/index.html">Vue.js SSR & Mobile Safari: Ein nicht offensichtliches Problem mit zu intelligenter Software</a></li>
<li><a href="../de430620/index.html">Funktionales Denken. Teil 4</a></li>
<li><a href="../de430622/index.html">Funktionales Denken. Teil 5</a></li>
<li><a href="../de430626/index.html">Ank√ºndigung des Moscow GraphQL Meetup</a></li>
<li><a href="../de430630/index.html">Vergleich der Two Balls Sneakers aus den 60ern und 2016. Von der Sohle bis zu den Schn√ºrsenkeln</a></li>
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausl√§ndische Einzelh√§ndler schl√ºsselfertige Gesch√§fte in Russland er√∂ffnen</a></li>
<li><a href="../de430634/index.html">Erstellen eines Softwaremoduls f√ºr den Programmierer XELTEK SuperPro 6100</a></li>
<li><a href="../de430636/index.html">Kleinhirn und Basalkerne anstelle der Kristallkugel: Wie das Gehirn die Zukunft vorhersagt</a></li>
<li><a href="../de430640/index.html">Rotes Meer: Warum die Aktien von Apple und anderen Technologieunternehmen fallen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>