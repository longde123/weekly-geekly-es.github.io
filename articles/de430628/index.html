<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🌾 🤺 🙅🏾 Fortune-Algorithmus, Implementierungsdetails 🎷 🧞 🌸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Wochen habe ich an der Implementierung des Fortune-Algorithmus in C ++ gearbeitet. Dieser Algorithmus verwendet viele 2D-Punkte und ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fortune-Algorithmus, Implementierungsdetails</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/"> In den letzten Wochen habe ich an der Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortune-Algorithmus</a> in C ++ gearbeitet.  Dieser Algorithmus verwendet viele 2D-Punkte und erstellt daraus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Voronoi-Diagramm</a> .  Wenn Sie nicht wissen, was ein Voronoi-Diagramm ist, sehen Sie sich die Abbildung an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br>  Für jeden Einstiegspunkt, der als „Site“ bezeichnet wird, müssen wir viele Punkte finden, die näher an diesem Ort liegen als an allen anderen.  Solche Punktsätze bilden die im obigen Bild gezeigten Zellen. <br><br>  Es ist bemerkenswert in Fortunes Algorithmus, dass er solche Diagramme rechtzeitig erstellt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">O</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">n</span><span class="MJXp-mtext" id="MJXp-Span-5">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">n</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-29" x="3868" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> O (n \ log n) </script>  (was für einen Vergleichsalgorithmus optimal ist), wobei <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  Ist die Anzahl der Plätze. <br><br>  Ich schreibe diesen Artikel, weil ich die Implementierung dieses Algorithmus für eine sehr schwierige Aufgabe halte.  Im Moment ist dies der komplizierteste der Algorithmen, die ich implementieren musste.  Daher möchte ich die Probleme, auf die ich gestoßen bin, und deren Lösung teilen. <br><br>  Wie üblich wird der Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github veröffentlicht</a> , und alle von mir verwendeten Referenzmaterialien sind am Ende des Artikels aufgeführt. <br><a name="habracut"></a><br><h1>  Beschreibung des Fortune-Algorithmus </h1><br>  Ich werde nicht erklären, wie der Algorithmus funktioniert, weil andere Leute es bereits gut gemacht haben.  Ich kann empfehlen, diese beiden Artikel zu studieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Das zweite ist sehr interessant - der Autor hat eine interaktive Demo in Javascript geschrieben, die zum Verständnis der Funktionsweise des Algorithmus hilfreich ist.  Wenn Sie einen formelleren Ansatz mit allen Beweisen benötigen, empfehle ich, Kapitel 7 der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Computational Geometry, 3. Ausgabe, zu</em></a> lesen. <br><br>  Außerdem beschäftige ich mich lieber mit Implementierungsdetails, die nicht gut dokumentiert sind.  Und sie machen die Implementierung des Algorithmus so komplex.  Insbesondere werde ich mich auf die verwendeten Datenstrukturen konzentrieren. <br><br>  Ich habe gerade einen Pseudocode des Algorithmus geschrieben, damit Sie eine Vorstellung von seiner globalen Struktur bekommen: <br><br><blockquote><pre>  Fügen Sie der Ereigniswarteschlange für jeden Ort ein Ortsereignis hinzu
 bis die Ereigniswarteschlange leer ist
     Rufen Sie das Top-Ereignis ab
     wenn das Ereignis ein Ortsereignis ist
         Fügen Sie einen neuen Bogen in die Küste ein
         Suchen Sie nach neuen Kreisereignissen
     sonst
         Erstellen Sie einen Scheitelpunkt im Diagramm
         Wir entfernen einen festgezogenen Bogen von der Küste
         ungültige Ereignisse löschen
         Suchen Sie nach neuen Kreisereignissen </pre></blockquote><br><h1>  Diagrammdatenstruktur </h1><br>  Das erste Problem, auf das ich stieß, war die Wahl der Art und Weise, wie das Voronoi-Diagramm gespeichert werden soll. <br><br>  Ich entschied mich für eine Datenstruktur, die in der Computergeometrie weit verbreitet ist und als doppelt verbundene Kantenliste (DCEL) bezeichnet wird. <br><br>  Meine <code>VoronoiDiagram</code> Klasse verwendet vier Container als Felder: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br>  Ich werde über jeden von ihnen ausführlich sprechen. <br><br>  Die <code>Site</code> Klasse beschreibt den Einstiegspunkt.  Jeder Ort hat einen Index, der nützlich ist, um ihn in die Warteschlange zu stellen, Koordinaten und einen Zeiger auf die Zelle ( <code>face</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br>  Die Eckpunkte der Zelle werden durch die <code>Vertex</code> Klasse dargestellt, sie haben nur ein Koordinatenfeld: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br>  Hier ist die Implementierung der Halbkanten: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br>  Sie fragen sich vielleicht, was ist eine halbe Rippe?  Eine Kante im Voronoi-Diagramm ist zwei benachbarten Zellen gemeinsam.  In der DCEL-Datenstruktur teilen wir diese Kanten in zwei Halbkanten, eine für jede Zelle, und sie sind durch einen Doppelzeiger verbunden.  Darüber hinaus hat die Halbkante einen Start- und einen Endpunkt.  Das <code>incidentFace</code> Feld gibt die Fläche an, zu der die Halbkante gehört.  Zellen in DCEL werden als zyklische doppelt verknüpfte Liste von Halbkanten implementiert, in der benachbarte Halbkanten miteinander verbunden sind.  Daher geben die Felder <code>prev</code> und <code>next</code> die vorherige und die nächste Halbkante in der Zelle an. <br><br>  Die folgende Abbildung zeigt alle diese Felder für die rote Halbkante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br>  Schließlich definiert die <code>Face</code> Klasse die Zelle.  Es enthält einfach einen Zeiger auf seinen Platz und einen anderen auf eine seiner Halbrippen.  Es spielt keine Rolle, welche der Halbkanten ausgewählt ist, da die Zelle ein geschlossenes Polygon ist.  Auf diese Weise erhalten wir Zugriff auf alle Halbkanten, während wir eine zyklisch verknüpfte Liste durchlaufen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1>  Ereigniswarteschlange </h1><br>  Die Standardmethode zum Implementieren einer Ereigniswarteschlange ist eine Prioritätswarteschlange.  Bei der Verarbeitung von Orts- und Kreisereignissen müssen wir möglicherweise Kreisereignisse aus der Warteschlange entfernen, da sie nicht mehr gültig sind.  Bei den meisten Implementierungen von Warteschlangen mit Standardpriorität können Sie jedoch kein Element löschen, das sich nicht oben befindet.  Dies gilt insbesondere für <code>std::priority_queue</code> . <br><br>  Es gibt zwei Möglichkeiten, um dieses Problem zu lösen.  Die erste, einfachere Möglichkeit besteht darin, Ereignissen ein <code>valid</code> Flag hinzuzufügen.  <code>valid</code> wird zunächst auf <code>true</code> .  Anstatt das Kreisereignis aus der Warteschlange zu entfernen, können wir sein Flag einfach auf <code>false</code> .  Wenn wir schließlich alle Ereignisse in der Hauptschleife verarbeiten, prüfen wir, ob der <code>valid</code> Flag-Wert des Ereignisses <code>false</code> ist. Wenn ja, überspringen Sie ihn einfach und verarbeiten Sie den nächsten. <br><br>  Die zweite Methode, die ich angewendet habe, war, nicht <code>std::priority_queue</code> .  Stattdessen habe ich meine eigene Prioritätswarteschlange implementiert, die das Entfernen aller darin enthaltenen Elemente unterstützt.  Die Implementierung einer solchen Warteschlange ist recht einfach.  Ich habe diese Methode gewählt, weil sie den Algorithmuscode sauberer macht. <br><br><h1>  Küste </h1><br>  Die Küstenlinien-Datenstruktur ist ein komplexer Teil des Algorithmus.  Bei falscher Implementierung gibt es keine Garantie dafür, dass der Algorithmus in ausgeführt wird <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">O</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">n</span><span class="MJXp-mtext" id="MJXp-Span-17">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">n</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-29" x="3868" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> O (n \ log n) </script>  .  Der Schlüssel, um diese zeitliche Komplexität zu erreichen, ist die Verwendung eines selbstausgleichenden Baums.  Aber es ist leichter gesagt als getan! <br><br>  Den meisten Ressourcen, die ich untersucht habe (die beiden oben genannten Artikel und das Buch <em>Computational Geometry</em> ), wird empfohlen, die Küstenlinie als Baum zu implementieren, in dem interne Knoten Bruchpunkte und Blätter Bögen anzeigen.  Aber sie sagen nichts darüber, wie man einen Baum balanciert.  Ich denke, dass ein solches Modell nicht das beste ist, und hier ist der Grund: <br><br><ul><li>  Es enthält redundante Informationen: Wir wissen, dass es einen Unterbrechungspunkt zwischen zwei benachbarten Bögen gibt, daher ist es nicht erforderlich, diese Punkte als Knoten darzustellen </li><li>  es ist nicht ausreichend für den Selbstausgleich: Nur der durch Bruchstellen gebildete Teilbaum kann ausgeglichen werden.  Wir können wirklich nicht den gesamten Baum ausbalancieren, da die Bögen sonst zu internen Knoten und Blättern von Haltepunkten werden können.  Das Schreiben eines Algorithmus, um nur den von internen Knoten gebildeten Teilbaum auszugleichen, scheint mir ein Albtraum zu sein. </li></ul><br>  Deshalb habe ich beschlossen, die Küste anders darzustellen.  In meiner Implementierung ist die Küste auch ein Baum, aber alle Knoten sind Bögen.  Ein solches Modell weist keinen der aufgeführten Nachteile auf. <br><br>  Hier ist die Definition von <code>Arc</code> Arc in meiner Implementierung: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br>  Die ersten drei Felder dienen zur Strukturierung des Baums.  Das Feld <code>leftHalfEdge</code> gibt die Halbkante an, die vom <code>leftHalfEdge</code> linken Punkt des Bogens gezeichnet wird.  Und <code>rightHalfEdge</code> befindet sich an der halben Kante, die vom äußersten rechten Punkt gezeichnet wird.  Zwei Zeiger, <code>prev</code> und <code>next</code> werden verwendet, um direkten Zugriff auf den vorherigen und nächsten Bogen der Küste zu erhalten.  Darüber hinaus können Sie die Küste als doppelt verknüpfte Liste umgehen.  Schließlich hat jeder Bogen eine Farbe, mit der die Küstenlinie ausgeglichen wird. <br><br>  Um die Küste auszugleichen, entschied ich mich für ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rot-schwarzes Schema</a> .  Beim Schreiben von Code hat mich das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in Algorithmen</a> inspiriert.  Kapitel 13 beschreibt zwei interessante Algorithmen, <code>insertFixup</code> und <code>deleteFixup</code> , die den Baum nach dem Einfügen oder Löschen ausgleichen. <br><br>  Ich kann die im Buch gezeigte <code>insert</code> jedoch nicht verwenden, da die Schlüssel verwendet werden, um die Einfügemarke des Knotens zu finden.  Der Fortune-Algorithmus enthält keine Schlüssel. Wir wissen nur, dass wir einen Bogen vor oder nach dem anderen in die Küste einfügen müssen.  Um dies zu implementieren, habe ich die <code>insertAfter</code> <code>insertBefore</code> und <code>insertAfter</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br>  Das Einfügen von <code>y</code> vor <code>x</code> erfolgt in drei Schritten: <br><br><ol><li>  Suchen Sie einen Platz zum Einfügen eines neuen Knotens.  Zu diesem Zweck habe ich die folgende Beobachtung verwendet: Das linke Kind <code>x</code> oder das rechte Kind <code>x-&gt;prev</code> ist <code>Nil</code> , und dasjenige, das <code>Nil</code> ist, steht vor <code>x</code> und nach <code>x-&gt;prev</code> . </li><li>  Innerhalb der Küste behalten wir die Struktur einer doppelt verknüpften Liste bei, daher müssen wir die <code>prev</code> und <code>next</code> Zeiger der Elemente <code>x-&gt;prev</code> , <code>y</code> und <code>x</code> entsprechend aktualisieren. </li><li>  Schließlich rufen wir einfach die im Buch beschriebene Methode <code>insertFixup</code> auf, um den Baum auszugleichen. </li></ol><br>  <code>insertAfter</code> wird ähnlich implementiert. <br><br>  Die Entfernungsmethode aus dem Buch kann ohne Änderungen implementiert werden. <br><br><h1>  Diagrammlimit </h1><br>  Hier ist die Ausgabe des oben beschriebenen Fortune-Algorithmus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br>  Es gibt ein kleines Problem mit einigen Kanten von Zellen am Rand des Bildes: Sie werden nicht gezeichnet, weil sie unendlich sind. <br><br>  Schlimmer noch, eine Zelle ist möglicherweise kein einzelnes Fragment.  Wenn wir beispielsweise drei Punkte auf derselben Linie nehmen, hat der Mittelpunkt zwei unendliche Halbkanten, die nicht miteinander verbunden sind.  Dies passt nicht sehr gut zu uns, da wir nicht auf eine der halben Kanten zugreifen können, da die Zelle eine verknüpfte Liste von Kanten ist. <br><br>  Um diese Probleme zu lösen, werden wir das Diagramm einschränken.  Damit meine ich, dass wir jede Zelle des Diagramms so einschränken, dass sie keine unendlichen Kanten mehr hat und jede Zelle ein geschlossenes Polygon ist. <br><br>  Glücklicherweise können wir mit dem Fortune-Algorithmus schnell endlose Kanten finden: Sie entsprechen Halbkanten, die sich am Ende des Algorithmus noch an der Küste befinden. <br><br>  Mein Restriktionsalgorithmus erhält eine Box als Eingabe und besteht aus drei Schritten: <br><br><ol><li>  Es ermöglicht die Platzierung jedes Scheitelpunkts des Diagramms innerhalb des Rechtecks. </li><li>  Schneiden Sie jede unendliche Kante ab. </li><li>  Schließt Zellen. </li></ol><br>  Stufe 1 ist trivial - wir müssen das Rechteck nur erweitern, wenn es keinen Scheitelpunkt enthält. <br><br>  Stufe 2 ist ebenfalls recht einfach: Sie besteht aus der Berechnung der Schnittpunkte zwischen den Strahlen und dem Rechteck. <br><br>  Stufe 3 ist auch nicht sehr kompliziert, erfordert nur Aufmerksamkeit.  Ich führe es in zwei Stufen durch.  Zuerst füge ich die Eckpunkte des Rechtecks ​​zu den Zellen hinzu, an deren Eckpunkten sie sein sollten.  Dann stelle ich sicher, dass alle Eckpunkte der Zelle durch Halbkanten verbunden sind. <br><br>  Ich empfehle Ihnen, den Code zu studieren und Fragen zu stellen, wenn Sie Details zu diesem Teil benötigen. <br><br>  Hier ist das Ausgabediagramm des Begrenzungsalgorithmus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br>  Jetzt sehen wir, dass alle Kanten gezeichnet sind.  Und wenn Sie verkleinern, können Sie sicherstellen, dass alle Zellen geschlossen sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1>  Schnittpunkt mit Rechteck </h1><br>  Großartig!  Aber das erste Bild vom Anfang des Artikels ist besser, oder? <br><br>  In vielen Anwendungen ist es nützlich, den Schnittpunkt zwischen dem Voronoi-Diagramm und dem Rechteck zu haben, wie im ersten Bild gezeigt. <br><br>  Das Gute ist, dass es nach dem Einschränken des Diagramms viel einfacher ist, dies zu tun.  Die schlechte Nachricht ist, dass wir vorsichtig sein müssen, obwohl der Algorithmus nicht sehr kompliziert ist. <br><br>  Die Idee ist folgende: Wir gehen um die halbe Kante jeder Zelle herum und überprüfen den Schnittpunkt zwischen der halben Kante und dem Rechteck.  Fünf Fälle sind möglich: <br><br><ol><li>  Die Halbrippe befindet sich vollständig innerhalb des Rechtecks: Wir speichern eine solche Halbrippe </li><li>  Die Halbrippe befindet sich vollständig außerhalb des Rechtecks: Wir werfen eine solche Halbrippe weg </li><li>  Die Halbrippe geht außerhalb des Rechtecks: Wir schneiden die Halbrippe ab und speichern sie als die <em>letzte Halbrippe, die ausgeht</em> . </li><li>  Die Halbrippe geht in das Rechteck: Wir schneiden die Halbrippe ab, um sie mit der <em>letzten</em> Halbrippe zu verbinden <em>, die ausgegangen ist</em> (wir speichern sie in Fall 3 oder 5). </li><li>  Die Halbrippe kreuzt das Rechteck zweimal: Wir schneiden die Halbrippe ab und fügen eine Halbrippe hinzu, um sie mit der <em>letzten</em> Halbrippe zu verknüpfen <em>, die ausgeht</em> , und speichern sie dann als die neue <em>letzte Halbrippe, die ausgeht</em> . </li></ol><br>  Ja, es gab viele Fälle.  Ich habe ein Bild erstellt, um sie alle zu zeigen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br>  Das orangefarbene Polygon ist die ursprüngliche Zelle und das rote ist die abgeschnittene Zelle.  Abgeschnittene Halbrippen sind rot markiert.  Grüne Rippen wurden hinzugefügt, um die in das Rechteck eintretenden Halbrippen mit den herauskommenden Halbrippen zu verbinden. <br><br>  Wenn wir diesen Algorithmus auf ein begrenztes Diagramm anwenden, erhalten wir das erwartete Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1>  Fazit </h1><br>  Der Artikel erwies sich als ziemlich lang.  Und ich bin sicher, dass Ihnen viele Aspekte immer noch nicht klar sind.  Trotzdem hoffe ich, dass es Ihnen nützlich sein wird.  Untersuchen Sie den Code auf Details. <br><br>  Um zusammenzufassen und sicherzustellen, dass wir keine Zeit umsonst verschwendeten, habe ich auf meinem (billigen) Laptop die Zeit gemessen, um das Voronoi-Diagramm für eine andere Anzahl von Orten zu berechnen: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-23"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">n</span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-26">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1501" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  : 2 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">n</span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-30"><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-32">10.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.952ex" height="2.298ex" viewBox="0 -832 4715.6 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1780" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-5"> n = $ 10.00</script>  : 33 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">n</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-36"><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-38">100.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.115ex" height="2.298ex" viewBox="0 -832 5216.1 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="2280" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-6"> n = $ 100.00</script>  : 450 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-44">1.000.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.924ex" height="2.298ex" viewBox="0 -832 5995.1 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-2E" x="2280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="2559" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhhGLr13YJnsUUXPGyHYlZf0gocW3g#MJMAIN-30" x="3059" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> n = $ 1.000.00</script>  : 6600 ms </li></ul><br>  Ich habe nichts mit diesen Indikatoren zu vergleichen, aber es scheint, dass es unglaublich schnell ist! <br><br><h1>  Referenzen </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel von Stephen Fortune</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Computational Geometry, 3. Auflage</em></a> von Mark de Berg, Otfried Cheong, Marc van Kreveld und Mark Overmars </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortunes-Algorithmus: Eine intuitive Erklärung</a> auf jacquesheunis.com </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortunes Algorithmus und Implementierung</a> auf blog.ivank.net </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Einführung in Algorithmen, 3. Auflage</em></a> von Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest und Clifford Stein </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430628/">https://habr.com/ru/post/de430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430616/index.html">Seminar "Testen und Überwachen", 27. November, Moskau</a></li>
<li><a href="../de430618/index.html">Vue.js SSR & Mobile Safari: Ein nicht offensichtliches Problem mit zu intelligenter Software</a></li>
<li><a href="../de430620/index.html">Funktionales Denken. Teil 4</a></li>
<li><a href="../de430622/index.html">Funktionales Denken. Teil 5</a></li>
<li><a href="../de430626/index.html">Ankündigung des Moscow GraphQL Meetup</a></li>
<li><a href="../de430630/index.html">Vergleich der Two Balls Sneakers aus den 60ern und 2016. Von der Sohle bis zu den Schnürsenkeln</a></li>
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausländische Einzelhändler schlüsselfertige Geschäfte in Russland eröffnen</a></li>
<li><a href="../de430634/index.html">Erstellen eines Softwaremoduls für den Programmierer XELTEK SuperPro 6100</a></li>
<li><a href="../de430636/index.html">Kleinhirn und Basalkerne anstelle der Kristallkugel: Wie das Gehirn die Zukunft vorhersagt</a></li>
<li><a href="../de430640/index.html">Rotes Meer: Warum die Aktien von Apple und anderen Technologieunternehmen fallen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>