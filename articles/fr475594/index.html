<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥉 👩🏻‍🤝‍👨🏿 ⬜️ JavaScript divertissant: une équation presque linéaire 🧦 👩🏼‍🤝‍👨🏽 🕳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Et si nous prenions de merveilleuses mathématiques (à savoir, des équations linéaires) et notre JavaScript tout aussi merveilleux, puis nous les super...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript divertissant: une équation presque linéaire</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/475594/">  Et si nous prenions de merveilleuses mathématiques (à savoir, des équations linéaires) et notre <b>JavaScript</b> tout aussi merveilleux, puis nous les superposions?  Dans les conditions de limitations et de spécificités de l'environnement js, un simple problème mathématique peut se transformer en un très curieux et plein d'embûches de pierres js.  Lors de la dernière conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS 19</a> à Moscou, une de ces équations linéaires (parmi d'autres tâches de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SEMrush</a> ) a fait pas mal de bruit. <br><br><img src="https://habrastorage.org/webt/9g/kg/wb/9gkgwb96ttlrqlsnqmqgmnjygyu.jpeg"><br><br>  Et oui, c'est encore le titre de Entertaining JavaScript: je vous demande de couper tout le monde qui s'en soucie. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Tâches précédentes</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jour de neige</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bracket Obfuscation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le mémo le plus court</a> <br></div></div><br>  Bien sûr, tout ce qui est décrit ci-dessous - ce n'est qu'une tentative frivole de symbiose entre deux choses merveilleuses pour s'amuser - ne doit pas être pris au sérieux.  Et ce matériel n'aurait pas existé s'il n'y avait pas eu un vif intérêt de la part des participants à la conférence, pour laquelle un merci spécial à eux! <br><br><h3>  Libellé </h3><br>  1. Trouvez toutes les solutions entières de l'équation: <br><br><pre><code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> = -x / <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  2. Trouvez toutes les solutions entières de l'équation: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> = -x / <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  La deuxième équation ne diffère de la première que par une opération supplémentaire sur le côté droit. <br><br><h3>  Approximation mathématique </h3><br>  Nous passons à la première équation.  Et pour commencer, nous comprendrons les priorités des opérations utilisées, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">selon le tableau</a> : <br><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">9</span></span> +(~ x)) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>) = -x / <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Nous prenons la négation au niveau du bit de <i>x</i> , puis nous l'ajoutons à 9. Le résultat de l'addition est décalé au niveau du bit vers la droite par le nombre de bits égal au résultat de la division de 6 par 3. <br><br>  Évidemment, le problème réside dans l'utilisation d'opérations au niveau du bit sur le <i>x</i> souhaité.  Mais afin de trouver une racine conditionnelle pour un raisonnement plus approfondi, il vaut la peine d'essayer de ramener l'équation à un analogue mathématique approximatif. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les opérations au niveau du bit fonctionnent</a> avec des opérandes en tant qu'entiers 32 bits signés.  Le NOT au niveau du bit peut être remplacé par <b>une</b> négation <b>entière</b> de l'incrément: <br><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">9</span></span> -(x + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>) = -x / <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-number"><span class="hljs-number">8</span></span> - x) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> = -x / <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Le décalage au niveau du bit vers la droite (tout en préservant le signe) peut être remplacé par une division <b>entière</b> par deux au degré égal à l'opérande de droite: <br><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">8</span></span> - x) / <span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span> = -x / <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-number"><span class="hljs-number">8</span></span> - x) / <span class="hljs-number"><span class="hljs-number">4</span></span> = -x / <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Bien sûr, ces remplacements sont très arbitraires, et nous en reparlerons plus tard.  Et maintenant, nous avons l'équation linéaire habituelle, dont la seule racine est -24.  Remplacez la valeur dans les côtés gauche et droit de l'équation d'origine: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">9</span></span> +~ (<span class="hljs-number"><span class="hljs-number">-24</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// = 8 -(-24) / 3; // = 8</span></span></code> </pre><br>  Les deux parties sont égales, ce qui signifie que tout n'est pas si désespéré et -24 est vraiment une solution. <br><br><h3>  Rechercher les paresseux </h3><br>  Si nous dessinons des graphiques des fonctions <i>f1 (x) = (8 -x) / 4</i> et <i>f2 (x) = -x / 3</i> , alors bien sûr, nous trouvons le seul point d'intersection des deux lignes à <i>x = -24</i> . <br><br><img src="https://habrastorage.org/webt/lq/-u/eq/lq-ueqg2tcs4_kuacbct4ry7lee.png"><br><br>  Mais nous avons fait quelques substitutions inégales avec des opérations au niveau du bit dans l'expression de gauche, donc en réalité le graphique de la fonction <i>f1</i> sera légèrement différent.  Pour tout <i>x, la</i> valeur de la fonction sera un entier différent de la valeur sur la ligne continue <i>f1</i> avec un décalage possible dans la plage de -1 à 1. Cela signifie que nous pouvons limiter la zone de recherche de solution à gauche et à droite de -24, où les valeurs des fonctions <i>f1</i> et <i>f2</i> commencer à différer de plus d'un. <br><br>  Pour trouver les limites de la zone de recherche, vous pouvez 1) résoudre l'inégalité avec le module, ou 2) regarder de plus près les graphiques des fonctions.  Nous constaterons que <i>x</i> vaut la peine de regarder le segment [-36, -12]: <br><br><pre> <code class="javascript hljs">| (<span class="hljs-number"><span class="hljs-number">8</span></span> - x) / <span class="hljs-number"><span class="hljs-number">4</span></span> + x / <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/js/cu/zy/jscuzy-3pnej3cnxpbiuor4lzus.png"><br><br>  Pour itérer sur des solutions entières dans une plage fermée <i>[début, fin],</i> nous écrivons la fonction <i>findx</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findx = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, beg, end</span></span></span><span class="hljs-function">) =&gt;</span></span> [...Array(end - beg + <span class="hljs-number"><span class="hljs-number">1</span></span>)].map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) =&gt;</span></span> i + beg).filter(f);</code> </pre><br>  La fonction renvoie un tableau d'entiers pour lesquels la valeur de la fonction passée <i>f</i> est réduite à <i>true</i> .  Pour trouver des solutions, nous représentons l'équation comme une fonction js en utilisant l'opérateur d'égalité: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq1 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> == -x / <span class="hljs-number"><span class="hljs-number">3</span></span>; findx(eq1, <span class="hljs-number"><span class="hljs-number">-36</span></span>, <span class="hljs-number"><span class="hljs-number">-12</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [-24, -21, -18, -15]</span></span></code> </pre><br>  Ainsi, <i>x</i> = [-24, -21, -18, -15] sont les solutions souhaitées pour la première équation. <br><br><h3>  Solution graphique </h3><br>  L'énumération est bien sûr un succès, mais essayons de trouver le graphique de la fonction <i>f1</i> jusqu'à la fin et de résoudre l'équation graphiquement.  De plus, la solution n'implique pas la propriété obligatoire de la console du navigateur. <br><br>  L'opérateur NOT au niveau du bit supprime simplement la partie fractionnaire, ainsi le résultat <i>- (x + 1)</i> sera arrondi vers le bas.  L'opérateur de décalage de bit est un peu plus compliqué.  Nous l'avons remplacé par une division entière, mais selon le signe du nombre de dividendes, cette opération arrondit le résultat vers le bas ou vers le haut: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// = 2 -10 &gt;&gt; 2; // = -3</span></span></code> </pre><br>  Cependant, nous savons que le <i>x</i> souhaité est dans la plage [-36, -12].  Par conséquent, l'opérande gauche de décalage au niveau du bit ( <i>8 -x</i> ) est dans la plage [20, 44], c'est-à-dire qu'il est toujours positif.  Ce qui signifie à son tour une division entière avec arrondi. <br><br>  Après avoir compris la nature des opérations, nous pouvons dessiner le graphique correct de la fonction <i>f1</i> : <br><br><img src="https://habrastorage.org/webt/-z/-e/69/-z-e69kdpamkon9l-tnprrtwvxw.png"><br><br>  Nous trouverons quatre points d'intersection des fonctions dans les mêmes coordonnées <i>x</i> = [-24, -21, -18, -15]. <br><br><h3>  Deuxième équation </h3><br>  Donc, nous sommes arrivés à la deuxième équation: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> = -x / <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Il diffère du premier par l'ajout d'un OU au niveau du bit.  Si l'opérande droit d'une telle opération est nul, alors le résultat est simplement la valeur de l'opérande gauche avec la partie fractionnaire rejetée. <br><br>  Pour commencer, procédons à la même recherche, choisissez simplement la zone de recherche.  Puisque maintenant la fonction <i>f2</i> a un caractère similaire à <i>f1</i> , pour la fiabilité, le décalage possible devrait être résumé et la recherche devrait être limitée lorsque les fonctions diffèrent en valeur absolue de plus de deux unités - c'est [-48, 0]. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> == -x / <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; findx(eq2, <span class="hljs-number"><span class="hljs-number">-48</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [-24, -21, -18, -15]</span></span></code> </pre><br>  Et nous avons eu les mêmes réponses.  On soupçonne qu'après tout, quelque chose ne va pas.  Mais le fait est qu'après avoir représenté l'équation d'origine en tant que telle fonction js, nous avons combiné les deux expressions (gauche et droite) via l'opérateur d'égalité en une seule.  Et l'opérateur d'égalité a sa priorité, qui est supérieure à la priorité de l'opérateur OR au niveau du bit.  La fonction est identique à la suivante: <br><br><pre> <code class="javascript hljs">x =&gt; (<span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> == -x / <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  Dans ce cas, un OR au niveau du bit n'a aucun effet, car <i>true |</i>  <i>0 = 1</i> .  Pour éviter cela, il est nécessaire d'indiquer explicitement dans le corps de la fonction que nous comparons les résultats de deux sous-expressions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-number"><span class="hljs-number">9</span></span> +~ x &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>) == (-x / <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>); findx(eq2, <span class="hljs-number"><span class="hljs-number">-48</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [-32, -29, -28, -26, -25, -24, -23, -22, -21, -19, -18, -15]</span></span></code> </pre><br>  Le nombre de solutions a augmenté.  Examinons maintenant les graphiques de fonction.  Par analogie avec <i>f1</i> , une «échelle à degrés» construit une fonction modifiée <i>f2</i> : <br><br><img src="https://habrastorage.org/webt/fc/gs/lm/fcgslmjdbg0xaigr5mumxtmuyh0.png"><br><br>  Les emplacements des graphiques de fonctions se chevauchent, mais nous ne nous intéressons qu'aux points avec une valeur entière de la coordonnée <i>x</i> : [-32, -29, -28, -26, -25, -24, -23, -22, -21, -19, -18, -15], seulement 12 solutions.  L'intersection de deux "échelles" avec les étapes 3 et 4 peut être trouvée par algorithme, si vous le souhaitez. <br><br><h3>  Question supplémentaire </h3><br>  Dans le problème proposé lors de la conférence, il y avait une question supplémentaire: il était nécessaire de trouver la solution minimale à l'équation 2. Il n'était pas dit que c'était nécessairement un entier, donc la réponse <i>x</i> = -32 - s'est avérée incorrecte. <br><br>  Trouver une solution par force brute ne fonctionnera pas ici, mais la résoudre graphiquement est très simple.  Il s'agit de la valeur la plus proche de <i>x</i> à -33 sur la droite: <br><br><img src="https://habrastorage.org/webt/w9/rq/cy/w9rqcyp4fwmai59369zi9ldjiu8.png"><br><br>  Il semble que <i>x</i> = -32. (9).  Mais ce n'est toujours pas vrai.  Puisque notre environnement est JavaScript, cela signifie que dans la représentation des nombres, nous sommes limités par le type de données utilisé.  Le numéro de type est float64, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un nombre à virgule flottante double précision</a> (IEEE 754).  Pour s'en souvenir et pour nommer une précision approximative, il suffisait d'obtenir un renard en peluche! <br><br><h3>  Le côté obscur des opérations au niveau du bit </h3><br>  Comme mentionné ci-dessus, les opérations au niveau du bit convertissent les opérandes en nombres de 32 bits représentés par la séquence 0 et 1 - c'est la plage [-2147483648, 2147483647].  Si le nombre ne rentre pas dedans, alors les bits les plus significatifs seront rejetés. <br><br>  Dans la première équation, cela ne joue aucun rôle, car il n'y a pas d'opération au niveau du bit sur le côté droit.  Mais dans le second, cette conversion des nombres impose un effet intéressant. <br><br>  Par exemple, le nombre -24 sera représenté par: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">11111111111111111111111111101000</span></span></code> </pre><br>  Une valeur négative du nombre est obtenue en inversant les bits (NOT au niveau du bit) dans l'enregistrement d'un nombre positif avec l'addition d'un. <br><br>  Tout nombre en dehors de la plage, après la fin de la conversion dans cette séquence de 32 bits, sera identique dans les opérations binaires au nombre -24.  Par exemple, ce sont des chiffres: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">4294967272</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// -24 8589934568 | 0; // -24, prepend '1' 12884901864 | 0; // -24, prepend '10' 17179869160 | 0; // -24, prepend '11' 21474836456 | 0; // -24, prepend '100' // ...</span></span></code> </pre><br>  Sur le côté droit de l'équation, avant l'opération au niveau du bit, nous divisons <i>x</i> par 3. Nous trouvons <i>x</i> parmi les "équivalents" -24 qui est divisible par 3. Le nombre le plus proche est 12884901864. Remplacez-le dans l'équation: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">9</span></span> +~ <span class="hljs-number"><span class="hljs-number">12884901864</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">-12884901864</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> +~ <span class="hljs-number"><span class="hljs-number">12884901864</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">-4294967288</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">23</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Le résultat de la division par 3 (-4294967288) ne correspond pas aux 32 chiffres attribués;  lors de l'inversion des bits, le signe est finalement perdu et il ne reste que 8: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">00000000000000000000000000001000</span></span></code> </pre><br>  De plus, vous pouvez vérifier l'exactitude du résultat en appelant la fonction <i>eq2</i> : <br><br><pre> <code class="javascript hljs">eq2(<span class="hljs-number"><span class="hljs-number">12884901864</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  Si vous y réfléchissez, à côté de cette racine, vous pouvez trouver les projections des 11 solutions entières restantes. <br><br>  Ainsi, un grand nombre de nouvelles solutions apparaissent et seul l'équivalent positif le plus proche de -24 est pris en compte.  Néanmoins, ce n'est pas aussi intéressant que la tâche principale, et lors de l'analyse des décisions des participants, ces réponses très rares ont été évaluées séparément.  Afin de ne pas être confus, vous pouvez introduire une restriction sur les entiers souhaités dans la condition de problème en tant que ceux signés sur 32 bits. <br><br>  Et vous ne pouvez pas faire!  Ensuite, pour trouver la plus petite racine, vous devez faire attention au voisinage de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Number.MAX_SAFE_INTEGER</a> avec un signe négatif, car ce nombre est entier et avec une précision extrême float64.  Eh bien, alors tout seul. <br><br><h3>  Conclusion </h3><br>  À la suite de la conférence, la plupart des participants ont résolu le problème par une recherche exhaustive, tandis que la plage de recherche était complètement différente pour diverses raisons.  Mais comme nous l'avons vu, il suffit de s'écouler à ~ 50 entiers.  Beaucoup sont tombés dans des pièges prioritaires opérationnels.  Quelqu'un a également décidé graphiquement qu'il était satisfait.  Unités surpris par la sortie de 32 catégories.  Vous pouvez utiliser la force brute pour avancer davantage dans les tâches.  Mais pour obtenir un prix supplémentaire, il fallait encore effectuer une analyse quasi mathématique. <br><br>  J'espère vraiment que vous avez aimé l'idée d'une tâche aussi atypique que le divertissement pour le format de la conférence.  Au cours de la dernière année, j'ai accumulé plusieurs de ces tâches JavaScript "divertissantes".  J'ai décidé de les rassembler en un seul endroit.  Suivez le lien si vous n'avez pas peur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript contesté inattendu</a> .  Les tâches de <a href="">Look Complex</a> et <a href="">Broken Pipe</a> , qui ont également été proposées lors de la conférence, ont déjà été définies.  Oui, il existe de nombreuses collections de ce type, mais celle-ci est à moi!  Merci encore à tout le monde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475594/">https://habr.com/ru/post/fr475594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475582/index.html">Le problème de la monétisation: pourquoi l'App Store populaire supprime les utilitaires open source</a></li>
<li><a href="../fr475584/index.html">Comment sont les sections d'apprentissage automatique lors des entretiens avec Yandex</a></li>
<li><a href="../fr475586/index.html">L'empreinte sonore de l'ordinateur via l'API AudioContext</a></li>
<li><a href="../fr475588/index.html">Trois paradigmes</a></li>
<li><a href="../fr475590/index.html">Compilation de programmes avec Notepad ++</a></li>
<li><a href="../fr475596/index.html">Des hypothèses de grand nombre premier prouvées pour des systèmes de petit nombre</a></li>
<li><a href="../fr475598/index.html">Organisation d'une architecture simple dans une application Android avec un tas de ViewModel + LiveData, Retrofit + Coroutines</a></li>
<li><a href="../fr475600/index.html">Comment nous avons connecté Prometheus</a></li>
<li><a href="../fr475604/index.html">Configuration du modèle officiel PostgreSQL sur Zabbix 4.4</a></li>
<li><a href="../fr475608/index.html">Google Tag Manager: paramètres de déclenchement non évidents et utiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>