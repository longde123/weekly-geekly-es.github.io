<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌰 🌔 ❤️ Piksel Indentasi Tekstur 👨🏾‍🎓 💊 👍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memperkenalkan artikel keempat dalam seri kami tentang bekerja dengan model 3D di Unity. Artikel sebelumnya: "Fitur bekerja dengan Mesh in Unity" , "U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Piksel Indentasi Tekstur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/451794/">  <i>Memperkenalkan artikel keempat dalam seri kami tentang bekerja dengan model 3D di Unity.</i>  <i>Artikel sebelumnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Fitur bekerja dengan Mesh in Unity"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Unity: editing prosedural Mesh"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Impor model 3D ke dalam Unity and pitfalls"</a> .</i> <br><br>  Pada artikel sebelumnya, kami menyebutkan memeriksa pemindaian tekstur untuk kecukupan indentasi piksel pada resolusi tekstur yang diberikan.  Dalam publikasi ini, kami menjelaskan esensi masalah dengan mengamati indentasi piksel dan algoritma untuk melacaknya.  Ini tidak akan dianggap kode, tetapi merupakan prinsip yang dapat diimplementasikan dalam bahasa apa pun dan dalam lingkungan pengembangan apa pun. <br><br><img src="https://habrastorage.org/webt/u_/fw/mc/u_fwmclibgkemvxya6u_lsd8tqu.jpeg"><a name="habracut"></a><br><br><h3>  Masalah </h3><br>  Pesanan untuk model 3D biasanya disertai dengan persyaratan untuk resolusi tekstur.  Karena sifat diskrit dari gambar raster, artis 3D harus mengamati lekukan dalam piksel antara bagian-bagian pemindaian tekstur.  Tidak adanya lekukan yang diperlukan mengarah pada fakta bahwa piksel yang sama ditampilkan pada model di tempat yang sama sekali berbeda ketika tidak diperlukan. <br><br>  Sangat penting untuk melacak indentasi yang cukup pada tahap awal pekerjaan.  Paling sering, beberapa orang terlibat dalam penciptaan geometri, termasuk pemindaian tekstur, dan yang lain terlibat dalam menggambar tekstur.  Kesalahan yang terdeteksi oleh artis 3D akan menyebabkan lebih sedikit masalah daripada yang akan ditemukan oleh perancang tekstur.  Dalam kasus terakhir, situasinya menjadi lebih rumit jika paket 3D yang digunakan tidak menyediakan alat untuk menggambar geometri (misalnya, kuas). <br><br>  Anda juga harus mempertimbangkan dua nuansa, karena di antara elemen-elemen sapuan mungkin memerlukan lebih banyak ruang.  Yang pertama adalah penurunan resolusi tekstur selama pemetaan.  Yang kedua adalah penggunaan <b>filter pelebaran</b> saat membentuk <b>peta pencahayaan</b> .  Selama tugas membuat <b>UV-</b> scan, artis 3D perlu dipandu oleh persyaratan untuk resolusi tekstur, dan juga mempertimbangkan nuansa yang tercantum di atas.  Namun demikian, banyak kekurangan tidak dapat diketahui tanpa verifikasi otomatis. <br><br><img src="https://habrastorage.org/webt/lv/s4/xf/lvs4xfanesl_qwgtr07wluk595a.jpeg"><br>  <i>Contoh penampilan artefak dengan penurunan detail</i> <br><br>  Untuk model sederhana, pemindaian tekstur dapat dihasilkan menggunakan alat otomatis.  Namun, mereka didasarkan pada metrik internal dan tidak memperhitungkan lekukan piksel, sehingga piksel bersama sering terletak di sepanjang batas diagonal.  Memeriksa dengan tekstur checker tidak menunjukkan semua kesalahan, di samping itu, tekstur ini sering memiliki resolusi lebih tinggi daripada yang akan digunakan dalam proyek. <br><br><img src="https://habrastorage.org/webt/mt/eb/8m/mteb8mngbtpsqlng-3b2l0wcmna.jpeg"><br>  <i>Pixel yang Dibagikan</i> <br><br>  Masalah lekukan piksel yang tidak mencukupi dalam pemindaian <b>UV</b> mirip dengan masalah overlay.  Dalam kedua kasus, apa yang disebut <b>perdarahan</b> dapat terjadi - dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> kami menggambarkan artefak apa yang dihasilkannya. <br><br>  Namun, masalah lekukan piksel tergantung pada persyaratan resolusi tekstur minimum.  Pemeriksaan tunggal sudah cukup untuk menentukan overlay, sedangkan persyaratan untuk resolusi tekstur dapat berubah pada tahap pengembangan selanjutnya.  Situasi menjadi rumit oleh kenyataan bahwa paket 3D yang kami gunakan tidak memiliki alat untuk secara otomatis mendeteksi kesalahan terkait dengan kedekatan bagian-bagian dari pemindaian <b>UV</b> .  Dan jangan lupa bahwa setelah operasi pembentuk otomatis di <b>Unity,</b> Anda masih perlu memeriksa <b>UV2</b> . <br><br>  Kami memutuskan untuk membuat alat yang dapat memeriksa lekukan dalam piksel dan menandai tempat celah potensial dalam model.  Persyaratan indentasi akan ditentukan berdasarkan parameter berikut: <br><br><ol><li>  Resolusi dasar tekstur. </li><li>  Resolusi minimum tekstur tempat aliran tidak diperbolehkan. </li><li>  Lekukan yang diperlukan pada tekstur minimum. </li></ol><br>  Karena ukuran tekstur yang digunakan oleh kami sama dengan kekuatan dua, rumus untuk menghitung lekukan yang diperlukan pada resolusi dasar cukup sederhana: (Resolusi dasar / Resolusi minimum) * indent pada MinTexture. <br><br>  Jelas, solusi untuk masalah ini terkait erat dengan rasterisasi.  Untuk pernyataan persyaratan dan pengembangan algoritma yang lebih jelas, kami memperkenalkan beberapa konsep. <br><br><h3>  Konsep kunci </h3><br>  Pertimbangkan ruang <b>UV</b> dan kisi seragam dimensi NxM dalam kisaran 0,01,0,0.  Lebar sel 1 / N dan tinggi 1 / M membentuk partisi ruang <b>UV</b> . <br><br><img src="https://habrastorage.org/webt/ue/rg/dg/uergdgc7zyh8upqr6g7dylw85r8.jpeg"><br>  <i>NxM membelah ruang <b>UV</b></i> <br><br>  Kami mengambil dua titik sembarang dan menunjukkan Dn sebagai jumlah piksel yang ditempati oleh proyeksi ke sumbu U dari segmen yang menghubungkan titik-titik yang diberikan.  Demikian pula, Dm untuk sumbu V. Kemudian kita menentukan <b>jarak piksel</b> sebagai maksimum antara Dn dan Dm. <br><br><img src="https://habrastorage.org/webt/cp/an/su/cpansumym7jr8f9vw-vi0w6iyj8.jpeg"><br>  <i>Jarak piksel</i> <br><br>  Perlu dicatat bahwa dalam ruang Euclidean, operasi gerakan seperti terjemahan paralel dan rotasi bukanlah gerakan untuk mesh, jika <b>jarak piksel</b> diambil sebagai metrik.  Nuansa ini sedikit mempersulit pengembangan solusi kami. <br><br><img src="https://habrastorage.org/webt/it/j-/ad/itj-adzmk_tujolsfcrwvhd2nqc.jpeg"><br><br>  Kami menyebut sebuah persegi dengan sisi dalam K piksel <b>inti dari K.</b>  Kemudian dua titik dengan <b>jarak piksel</b> kurang dari K dapat dicakup oleh kernel K. <br><br><img src="https://habrastorage.org/webt/gs/gu/jt/gsgujtv5gbm9o07j7itsrsz4dzo.jpeg"><br>  <i>Contoh core dengan ukuran berbeda</i> <br><br>  Dua tepi poligon membentuk <b>cekungan kontur</b> jika titik tengahnya (pusat massa pada empat simpul) terletak di sebelah kiri tepi ini ketika mengelilingi kontur dalam arah searah jarum jam.  Untuk lintasan berlawanan arah jarum jam, syaratnya adalah menemukan titik di sebelah kanan tepi. <br><br><img src="https://habrastorage.org/webt/di/3m/ye/di3myeeyussyylggsz0bnmdosbm.jpeg"><br>  <i>Sepasang tulang rusuk membentuk cekungan kontur</i> <br><br><h3>  Solusi </h3><br>  Sekarang mari kita bicara langsung tentang memeriksa lekukan piksel.  Untuk mengimplementasikannya, kami datang dengan algoritma yang terdiri dari tiga fragmen independen.  Urutan eksekusi tidak penting.  Hasil dari masing-masing fragmen adalah matriks NxM, yang merupakan buffer dari sel-sel partisi, di mana beberapa sel diberi label.  Penambahan ketiga buffer adalah hasil umum. <br><br>  Pertama, pertimbangkan cuplikan paling sederhana.  Ia datang untuk menemukan sel-sel yang bersinggungan dekat dengan segitiga dan tepi yang berdegenerasi, yang panjangnya kurang dari sisi inti dari magnitudo yang diberikan.  Semua sel tersebut ditandai dalam buffer. <br><br><img src="https://habrastorage.org/webt/uv/ru/v7/uvruv7eavepfqrtj-kqtah_wy_4.jpeg"><br>  <i>Hasil pengecekan ukuran elemen</i> <br><br>  Sebelum menjelaskan dua fragmen lainnya, pertimbangkan logika umum pekerjaan mereka.  Keduanya terkait dengan pemrosesan kelompok segitiga yang disebut <b>kerang</b> atau pulau.  Shell untuk artis 3D adalah himpunan poligon yang terhubung, yaitu, setiap poligon dalam himpunan ini memiliki tetangga yang dengannya ia berbagi simpul umum.  Shell juga merupakan tempat pelatihan yang independen.  Lebih lanjut, dengan shell, pulau dan cluster kami maksud hal yang sama. <br><br><img src="https://habrastorage.org/webt/yv/5t/ot/yv5tot5s12wlg7np6lyq6h1196q.jpeg"><br><br>  Untuk menemukan semua cangkang, kami menggunakan algoritme pencarian untuk semua komponen grafik yang terhubung, di mana simpul grafik diwakili oleh poligon dan tepi oleh kehadiran simpul umum dalam sepasang poligon.  Karena satu-satunya poligon dalam <b>Unity</b> adalah segitiga yang ditentukan oleh indeks titik, kami menganggap segitiga berdekatan jika setidaknya satu indeks dari titik pertama bertepatan dengan indeks dari setiap titik kedua.  Dari analogi dengan grafik dan metode untuk menentukan tepi, dapat disimpulkan bahwa himpunan indeks simpul dari satu cluster tidak berpotongan dengan himpunan simpul yang lain. <br><br><img src="https://habrastorage.org/webt/ug/lg/t2/uglgt2foiwbustrkinjapehyu2u.jpeg"><br><br>  Dengan bagian umum selesai.  Fragmen kedua, yang akan kami pertimbangkan, menentukan lokasi kesalahan potensial yang terkait dengan kedekatan atau tumpang tindih cluster yang berbeda. <br><br>  Banyak cluster diumpankan ke input dalam bentuk set segitiga di ruang <b>UV</b> , dimensi pemisahan <b>UV</b> sesuai dengan resolusi tekstur (NxM), dan nilai lekukan P sebagai jumlah piksel.  Untuk partisi yang diberikan, perlu untuk menemukan daerah-daerah di mana jarak dalam piksel antara cluster kurang dari indentasi yang diperlukan.  Sel dalam matriks hasil ditandai jika memasuki setidaknya satu <b>inti dari nilai K = P + 1</b> , yang memotong dua kelompok yang berbeda. <br><br>  Esensi dari fragmen ini hampir diatur dalam deskripsi hasil.  Penting untuk menemukan semua <b>kernel dengan magnitudo K</b> yang bersinggungan dengan segitiga dari cangkang yang berbeda, dan kemudian menandai sel-sel inti ini dalam buffer hasil. <br><br>  Dalam implementasi kami, semua pasangan cluster dipertimbangkan secara bergantian.  Untuk masing-masing pasangan, daerah persimpangan dari set <b>kernel dengan magnitudo K yang</b> tercakup oleh kluster ini ditentukan.  Pilih pasangan dan tunjukkan set seperti Q. <br><br><img src="https://habrastorage.org/webt/rp/ei/vb/rpeivbpedfexfuvbdsusftpuaha.jpeg"><br><br>  Kemudian, semua elemen Q harus diperiksa dengan kriteria berikut: apakah kernel yang diberikan berpotongan setidaknya satu segitiga di setiap cluster dari pasangan yang dipilih.  Jika demikian, maka semua sel dari kernel yang diuji ditandai. <br><br><img src="https://habrastorage.org/webt/vz/2q/gt/vz2qgtc62bl_gk99j3b_id2rmj0.jpeg"><br><br>  Buffer dengan sel yang ditandai untuk semua pasangan cluster merupakan hasilnya. <br><br><img src="https://habrastorage.org/webt/mk/cv/h5/mkcvh5g_tms3lmej2cvpere3410.jpeg"><br>  <i>Hasil Indentasi Cluster</i> <br><br>  Sekarang kita akan berurusan dengan fragmen terakhir.  Di sini Anda perlu memproses satu cluster.  Input adalah seperangkat segitiga dalam ruang <b>UV</b> , dimensi partisi <b>UV yang</b> sesuai dengan resolusi tekstur (NxM), dan nilai lekukan P sebagai jumlah piksel.  Sel dapat ditandai dalam dua kasus: apakah cluster tidak valid atau memiliki lubang, atau jarak dalam piksel antara tepi konkavitas kurang dari indent yang diperlukan. <br><br>  Bagian dalam cluster tidak menarik bagi kami - untuk permulaan kami akan mendapatkan garis besarnya diwakili oleh daftar tepi yang terhubung.  Segitiga yang bertetangga menduplikasi indeks dari simpul, sehingga tepi menjadi bagian dari kontur jika sepasang indeks dari simpulnya unik untuk himpunan tepi cluster.  Setelah mengetahui tepi mana yang membentuk kontur, perlu untuk menyusunnya sehingga daftar tertaut diperoleh. <br><br>  Jika setelah langkah ini tidak semua tepi kontur masuk ke daftar, maka apakah cluster memiliki lubang, atau ada kesalahan dalam data mesh.  Dalam hal ini, perlu untuk menandai semua sel nuklei yang berpotongan dengan gugus dengan tepat. <br><br>  Jika kontur ditemukan, maka pemrosesan berlanjut.  Kami merumuskan persyaratan hasil berikut.  Biarkan pasangan tepi membentuk <b>cekung kontur</b> memotong <b>kernel K = P + 1</b> .  Maka sel-sel nukleus harus ditandai jika kedua bagian kontur antara sisi melampaui nukleus ini. <br><br><img src="https://habrastorage.org/webt/d3/ba/en/d3baeniweyl5_l6uxvougq6__y0.jpeg"><br>  <i>Hasil Uji Fitur Cluster</i> <br><br>  Kami memutuskan untuk menerapkan persyaratan ini melalui perbandingan sisi tepi kontur secara berpasangan.  Kita mulai dengan kondisi cekungan, kemudian untuk setiap pasangan semua kernel yang memotong kedua sisi diperiksa.  Untuk menguji kernel, dilakukan traversal pada setiap bagian dari kontur antara sepasang tepi.  Jika setiap bagian mengandung setidaknya satu titik di luar batas nukleus, maka semua sel nukleus ditandai. <br><br><img src="https://habrastorage.org/webt/sx/qr/8a/sxqr8aizers5pviq4exzz3sips0.jpeg"><br>  <i>Kondisi di mana sel-sel kernel diperiksa ditandai</i> <br><br><h3>  Ringkasan </h3><br>  Algoritma di atas sangat cocok untuk implementasi menggunakan komputasi paralel.  Pemrosesan masing-masing pasangan cluster dan edge terjadi secara independen.  Karena pemeriksaan didasarkan pada rasterisasi, jika Anda mulai memproses bukan dengan pasang sisi, tetapi dengan inti, disarankan untuk menggunakan kemampuan <b>GPU</b> . <br><br>  Kami mengubah hasil algoritme menjadi tekstur.  Untuk resolusi yang diberikan, ini memungkinkan Anda untuk secara grafis menunjukkan tempat-tempat kelemahan potensial dalam pemindaian <b>UV</b> .  Juga, tekstur yang dihasilkan dapat diterapkan pada model untuk melihat tanda langsung pada geometri. <br><br>  Pada contoh di bawah ini, kami khusus memotong kelinci dan Suzanne dengan alat otomatis <b>Blender</b> sehingga kami mendapatkan lebih banyak artefak.  Resolusi tekstur yang diperiksa adalah 256x256, indentasi yang diperlukan adalah 1. <br><br>  Sel-sel ditandai dalam kelompok penutup biru dengan lubang, serta segitiga dan tepi yang terlalu kecil.  Hijau menunjukkan inti sel dengan karakteristik masing-masing kelompok secara individual.  Kernel di mana indentasi antar cluster tidak diamati ditandai dengan warna merah. <br><br><div class="spoiler">  <b class="spoiler_title">Contohnya</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/no/lc/uinolcm0buuwdwuqbsoufhdkjvw.jpeg"><br><br><img src="https://habrastorage.org/webt/po/up/v_/poupv_vzesyw1jeer6voiu4yens.jpeg"><br></div></div><br>  Pada artikel selanjutnya, kami akan mempertimbangkan algoritma untuk mengoptimalkan model 3D dalam sebuah adegan dengan menghapus geometri yang tidak terlihat.  Tetap bersama kami! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451794/">https://habr.com/ru/post/id451794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451782/index.html">Windows Subsystem untuk Linux (WSL) versi 2: bagaimana jadinya? (FAQ)</a></li>
<li><a href="../id451784/index.html">Drive hibrid untuk penyimpanan Enterprise. Pengalaman Menggunakan Seagate EXOS</a></li>
<li><a href="../id451786/index.html">Jalankan tes instrumental di Firebase Test Lab. Bagian 1: proyek iOS</a></li>
<li><a href="../id451790/index.html">Bahaya pengumpulan data dalam game</a></li>
<li><a href="../id451792/index.html">Empat sniffer javascript yang menjebak Anda di toko online</a></li>
<li><a href="../id451796/index.html">Menulis ekstensi browser yang aman</a></li>
<li><a href="../id451798/index.html">Migrasi data dengan mongoDB dan Spring Boot</a></li>
<li><a href="../id451800/index.html">Membuat modem sonar sederhana</a></li>
<li><a href="../id451802/index.html">Komunitas .Net dari Raiffeisenbank mengundang ke Broadcast mitap UPD</a></li>
<li><a href="../id451806/index.html">iOS Digest No. 5 (27 April - 16 Mei)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>