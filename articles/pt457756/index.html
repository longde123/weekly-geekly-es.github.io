<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèø üè¥ ‚õ∏Ô∏è O livro Kafka Streams em a√ß√£o. Aplicativos e microsservi√ßos em tempo real ¬ª üåõ üç∂ üë©üèæ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! Este livro √© adequado para qualquer desenvolvedor que queira entender o processamento de streaming. Compreender a programa√ß√£o distri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O livro Kafka Streams em a√ß√£o. Aplicativos e microsservi√ßos em tempo real ¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457756/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/na/mw/fb/namwfbeornc4ba8jkaodlvjlm68.jpeg" align="left" alt="imagem"></a>  Oi, habrozhiteli!  Este livro √© adequado para qualquer desenvolvedor que queira entender o processamento de streaming.  Compreender a programa√ß√£o distribu√≠da ajudar√° voc√™ a entender melhor o Kafka e o Kafka Streams.  Seria bom conhecer o pr√≥prio framework Kafka, mas isso n√£o √© necess√°rio: vou lhe contar tudo o que voc√™ precisa.  Gra√ßas a este livro, desenvolvedores experientes do Kafka, como novatos, aprender√£o como criar aplicativos interessantes de streaming usando a biblioteca Kafka Streams.  Desenvolvedores Java intermedi√°rios e de alto n√≠vel familiarizados com conceitos como serializa√ß√£o aprender√£o como aplicar suas habilidades para criar aplicativos Kafka Streams.  O c√≥digo-fonte do livro √© escrito em Java 8 e usa essencialmente a sintaxe das express√µes lambda do Java 8, portanto, a capacidade de trabalhar com fun√ß√µes lambda (mesmo em outra linguagem de programa√ß√£o) √© √∫til. <br><a name="habracut"></a><br><h3>  Trecho.  5.3  Agrega√ß√£o e opera√ß√µes de janela </h3><br>  Nesta se√ß√£o, passamos √†s partes mais promissoras do Kafka Streams.  At√© agora, cobrimos os seguintes aspectos do Kafka Streams: <br><br><ul><li>  criando uma topologia de processamento; </li><li>  uso do estado em aplicativos de streaming; </li><li>  fazer conex√µes de fluxo de dados; </li><li>  diferen√ßas entre fluxos de eventos (KStream) e fluxos de atualiza√ß√£o (KTable). </li></ul><br>  Nos exemplos a seguir, colocaremos todos esses elementos juntos.  Al√©m disso, voc√™ ser√° apresentado √†s opera√ß√µes da janela - outro √≥timo recurso dos aplicativos de streaming.  Nosso primeiro exemplo ser√° agrega√ß√£o simples. <br><br><h3>  5.3.1  Agrega√ß√£o de vendas de a√ß√µes por setor </h3><br>  A agrega√ß√£o e o agrupamento s√£o ferramentas vitais para trabalhar com dados de streaming.  Examinar registros individuais com base na admiss√£o geralmente n√£o √© suficiente.  Para extrair informa√ß√µes adicionais dos dados, seu agrupamento e combina√ß√£o s√£o necess√°rios. <br><br>  Neste exemplo, voc√™ deve experimentar o processo de um trader intradi√°rio que precisa acompanhar o volume de vendas de a√ß√µes de empresas de v√°rios setores.  Em particular, voc√™ est√° interessado nas cinco empresas com as maiores vendas de a√ß√µes em cada setor. <br><br>  Para essa agrega√ß√£o, voc√™ precisar√° de v√°rias das etapas a seguir para converter os dados no formato desejado (em termos gerais). <br><br><ol><li>  Crie uma fonte baseada em t√≥picos que publique informa√ß√µes brutas sobre negocia√ß√£o de a√ß√µes.  Teremos que mapear um objeto do tipo StockTransaction para um objeto do tipo ShareVolume.  O fato √© que o objeto StockTransaction cont√©m metadados de vendas e precisamos apenas de dados sobre o n√∫mero de compartilhamentos vendidos. </li><li>  Agrupe os dados do ShareVolume por s√≠mbolos de a√ß√µes.  Ap√≥s o agrupamento por s√≠mbolos, voc√™ pode recolher esses dados em subtotais de vendas de a√ß√µes.  Vale ressaltar que o m√©todo KStream.groupBy retorna uma inst√¢ncia do tipo KGroupedStream.  E voc√™ pode obter uma inst√¢ncia do KTable chamando o m√©todo KGroupedStream.reduce posteriormente. </li></ol><br><blockquote>  <b>O que √© a interface KGroupedStream</b> <br><br>  Os m√©todos KStream.groupBy e KStream.groupByKey retornam uma inst√¢ncia de KGroupedStream.  KGroupedStream √© uma representa√ß√£o intermedi√°ria do fluxo de eventos ap√≥s o agrupamento por chave.  N√£o se destina a trabalhar diretamente com ele.  Em vez disso, o KGroupedStream √© usado para opera√ß√µes de agrega√ß√£o, cujo resultado √© sempre o KTable.  E como o resultado das opera√ß√µes de agrega√ß√£o √© o KTable e elas usam armazenamento de estado, √© poss√≠vel que nem todas as atualiza√ß√µes sejam enviadas mais adiante no pipeline. <br><br>  O m√©todo KTable.groupBy retorna um KGroupedTable semelhante - uma representa√ß√£o intermedi√°ria do fluxo de atualiza√ß√µes reagrupadas por chave. </blockquote><br>  Vamos fazer uma pequena pausa e olhar para a fig.  5.9, que mostra o que alcan√ßamos.  Essa topologia j√° deve ser familiar para voc√™. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9v/p3/ne/9vp3ne2cqpquhvlkmjo6wncqwsm.png" alt="imagem"></div><br>  Agora, vamos dar uma olhada no c√≥digo para esta topologia (ela pode ser encontrada no arquivo src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.java) (Listagem 5.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8w/cz/lz/8wczlzab4gf5y7sjluyyu2f1vdi.png" alt="imagem"></div><br>  O c√≥digo fornecido difere na brevidade e um grande volume de a√ß√µes executadas em v√°rias linhas.  No primeiro par√¢metro do m√©todo builder.stream, √© poss√≠vel observar algo novo para voc√™: o valor do tipo enumerado AutoOffsetReset.EARLIEST (tamb√©m existe LATEST), configurado usando o m√©todo Consumed.withOffsetResetPolicy.  Usando esse tipo enumerado, voc√™ pode especificar uma estrat√©gia para redefinir compensa√ß√µes para cada um dos KStream ou KTable; ela tem prioridade sobre o par√¢metro para redefinir compensa√ß√µes da configura√ß√£o. <br><br><blockquote>  <b>GroupByKey e GroupBy</b> <br><br>  A interface do KStream possui dois m√©todos para agrupar registros: GroupByKey e GroupBy.  Ambos retornam uma KGroupedTable, para que voc√™ possa ter uma pergunta leg√≠tima: qual √© a diferen√ßa entre eles e quando usar qual? <br><br>  O m√©todo GroupByKey √© usado quando as chaves no KStream j√° est√£o vazias.  E o mais importante, o sinalizador "requer re-particionamento" nunca foi definido. <br><br>  O m√©todo GroupBy pressup√µe que voc√™ alterou as chaves de agrupamento, portanto, o sinalizador de particionamento √© definido como verdadeiro.  A realiza√ß√£o de conex√µes, agrega√ß√µes etc. ap√≥s o m√©todo GroupBy levar√° ao particionamento autom√°tico. <br>  Resumo: voc√™ deve usar GroupByKey em vez de GroupBy sempre que poss√≠vel. </blockquote><br>  O que os m√©todos mapValues ‚Äã‚Äãe groupBy fazem √© compreens√≠vel, portanto, d√™ uma olhada no m√©todo sum () (ele pode ser encontrado no arquivo src / main / java / bbejeck / model / ShareVolume.java) (Listagem 5.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/va/bb/e5/vabbe54p2ntwmyk1yllak6s4m4q.png" alt="imagem"></div><br>  O m√©todo ShareVolume.sum retorna o subtotal do volume de vendas de a√ß√µes e o resultado de toda a cadeia de c√°lculo √© um objeto KTable &lt;String, ShareVolume&gt;.  Agora voc√™ entende o papel que o KTable desempenha.  Quando os objetos ShareVolume chegam, a atualiza√ß√£o atual mais recente √© salva na KTable correspondente.  √â importante n√£o esquecer que todas as atualiza√ß√µes s√£o refletidas no shareVolumeKTable anterior, mas nem todas s√£o enviadas mais. <br><br>  Al√©m disso, com a ajuda desta KTable, realizamos agrega√ß√£o (pelo n√∫mero de a√ß√µes vendidas) para obter as cinco empresas com as maiores vendas de a√ß√µes em cada setor.  Nossas a√ß√µes nesse caso ser√£o semelhantes √†s a√ß√µes durante a primeira agrega√ß√£o. <br><br><ol><li>  Execute outra opera√ß√£o groupBy para agrupar objetos individuais do ShareVolume por setor. </li><li>  Continue resumindo os objetos ShareVolume.  Desta vez, o objeto de agrega√ß√£o √© uma fila priorit√°ria de tamanho fixo.  Apenas cinco empresas com o maior n√∫mero de a√ß√µes vendidas s√£o mantidas em uma fila de tamanho fixo. </li><li>  Exiba as linhas do par√°grafo anterior em um valor de sequ√™ncia e retorne as cinco mais vendidas pelo n√∫mero de a√ß√µes por setor. </li><li>  Escreva os resultados em forma de sequ√™ncia no t√≥pico. </li></ol><br>  Na fig.  5.10 mostra um gr√°fico da topologia da movimenta√ß√£o de dados.  Como voc√™ pode ver, a segunda rodada de processamento √© bastante simples. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4q/3p/j5/4q3pj5lkggxqnu6lpcmtgo52dqq.png" alt="imagem"></div><br>  Agora, tendo entendido claramente a estrutura desta segunda rodada de processamento, voc√™ pode consultar o c√≥digo-fonte (voc√™ o encontrar√° no arquivo src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.java) (Listagem 5.4). <br><br>  H√° uma vari√°vel FixedQueue neste inicializador.  Este √© um objeto personalizado - um adaptador para java.util.TreeSet, usado para rastrear N resultados mais altos em ordem decrescente do n√∫mero de compartilhamentos vendidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/03/mn/nm/03mnnmhuvjpivozqptxxzpkdrmu.png" alt="imagem"></div><br>  Voc√™ j√° encontrou chamadas para groupBy e mapValues, por isso n√£o as interromperemos (chamamos o m√©todo KTable.toStream, pois o m√©todo KTable.print foi descontinuado).  Mas voc√™ ainda n√£o viu a vers√£o KTable do m√©todo agregate (), portanto, passaremos algum tempo discutindo isso. <br><br>  Como voc√™ se lembra, o KTable se distingue pelo fato de os registros com as mesmas chaves serem considerados atualiza√ß√µes.  O KTable substitui o registro antigo pelo novo.  A agrega√ß√£o ocorre da mesma maneira: os √∫ltimos registros com uma chave s√£o agregados.  Quando um registro chega, ele √© adicionado a uma inst√¢ncia da classe FixedSizePriorityQueue usando um somador (o segundo par√¢metro na chamada de m√©todo agregado), mas se j√° existir outro registro com a mesma chave, o registro antigo ser√° exclu√≠do usando o subtractor (o terceiro par√¢metro na chamada de m√©todo agregado). <br><br>  Isso tudo significa que nosso agregador, FixedSizePriorityQueue, n√£o agrega todos os valores com uma chave, mas armazena a soma m√≥vel das quantidades N dos tipos de a√ß√µes mais vendidos.  Cada entrada cont√©m o n√∫mero total de a√ß√µes vendidas at√© o momento.  O KTable fornece informa√ß√µes sobre quais a√ß√µes das empresas est√£o sendo mais vendidas no momento; a agrega√ß√£o cont√≠nua de cada atualiza√ß√£o n√£o √© necess√°ria. <br><br>  Aprendemos a fazer duas coisas importantes: <br><br><ul><li>  agrupe valores no KTable por uma chave comum a eles; </li><li>  Execute opera√ß√µes √∫teis, como convolu√ß√£o e agrega√ß√£o, nesses valores agrupados. </li></ul><br>  A capacidade de executar essas opera√ß√µes √© importante para entender o significado dos dados que se deslocam pelo aplicativo Kafka Streams e descobrir quais informa√ß√µes eles carregam. <br><br>  Tamb√©m reunimos alguns dos principais conceitos discutidos anteriormente neste livro.  No Cap√≠tulo 4, falamos sobre a import√¢ncia de um estado local √† prova de falhas para um aplicativo de streaming.  O primeiro exemplo deste cap√≠tulo mostrou por que o estado local √© t√£o importante - possibilita rastrear as informa√ß√µes que voc√™ j√° viu.  O acesso local evita atrasos na rede, tornando o aplicativo mais produtivo e resistente a erros. <br><br>  Ao executar qualquer opera√ß√£o de convolu√ß√£o ou agrega√ß√£o, voc√™ deve especificar o nome do armazenamento de estado.  As opera√ß√µes de convolu√ß√£o e agrega√ß√£o retornam uma inst√¢ncia do KTable, e o KTable usa um armazenamento de estado para substituir resultados antigos por novos.  Como voc√™ viu, nem todas as atualiza√ß√µes s√£o enviadas mais adiante, e isso √© importante, pois as opera√ß√µes de agrega√ß√£o s√£o projetadas para obter as informa√ß√µes finais.  Se o estado local n√£o for aplicado, o KTable enviar√° ainda mais todos os resultados de agrega√ß√£o e convolu√ß√£o. <br><br>  A seguir, examinamos a execu√ß√£o de opera√ß√µes como agrega√ß√£o, dentro de um per√≠odo espec√≠fico de tempo - as chamadas opera√ß√µes de janelas. <br><br><h3>  5.3.2  Opera√ß√µes de janela </h3><br>  Na se√ß√£o anterior, introduzimos a convolu√ß√£o e agrega√ß√£o ‚Äúrolantes‚Äù.  O aplicativo executou uma convolu√ß√£o cont√≠nua das vendas de a√ß√µes com a agrega√ß√£o subsequente das cinco a√ß√µes mais vendidas. <br><br>  √Äs vezes, essa agrega√ß√£o e convolu√ß√£o cont√≠nuas de resultados s√£o necess√°rias.  E √†s vezes voc√™ precisa executar opera√ß√µes apenas em um determinado per√≠odo de tempo.  Por exemplo, calcule quantas transa√ß√µes de bolsa foram feitas com a√ß√µes de uma empresa espec√≠fica nos √∫ltimos 10 minutos.  Ou quantos usu√°rios clicaram em um novo an√∫ncio em banner nos √∫ltimos 15 minutos.  Um aplicativo pode executar essas opera√ß√µes v√°rias vezes, mas com resultados relacionados apenas a intervalos de tempo especificados (janelas de tempo). <br><br><h3>  Contando transa√ß√µes de c√¢mbio por comprador </h3><br>  No exemplo a seguir, participaremos do rastreamento de transa√ß√µes de c√¢mbio para v√°rios traders - grandes organiza√ß√µes ou financiadores inteligentes de uma m√£o. <br><br>  H√° dois motivos poss√≠veis para esse rastreamento.  Uma delas √© a necessidade de saber quais l√≠deres de mercado est√£o comprando / vendendo.  Se esses grandes players e investidores sofisticados v√™em oportunidades para si mesmos, faz sentido seguir sua estrat√©gia.  A segunda raz√£o √© o desejo de observar poss√≠veis sinais de transa√ß√µes ilegais usando informa√ß√µes privilegiadas.  Para fazer isso, voc√™ precisar√° analisar a correla√ß√£o de grandes picos nas vendas com importantes press releases. <br><br>  Esse rastreamento consiste em etapas como: <br><br><ul><li>  criando um fluxo para leitura do t√≥pico de transa√ß√µes de estoque; </li><li>  agrupamento de registros recebidos por ID do cliente e s√≠mbolo do estoque.  Uma chamada para o m√©todo groupBy retorna uma inst√¢ncia da classe KGroupedStream; </li><li>  KGroupedStream.windowedBy retorna um fluxo de dados delimitado por uma janela tempor√°ria, o que permite a agrega√ß√£o de janelas.  Dependendo do tipo de janela, TimeWindowedKStream ou SessionWindowedKStream √© retornado; </li><li>  Contando transa√ß√µes para uma opera√ß√£o de agrega√ß√£o.  O fluxo de dados da janela determina se um registro espec√≠fico √© levado em considera√ß√£o nesse c√°lculo; </li><li>  gravando resultados em um t√≥pico ou enviando-os para o console durante o desenvolvimento. </li></ul><br>  A topologia deste aplicativo √© simples, mas sua imagem visual n√£o faz mal.  D√™ uma olhada na foto.  5.11 <br><br>  Al√©m disso, consideraremos a funcionalidade das opera√ß√µes da janela e o c√≥digo correspondente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/bd/fi/1hbdfi2s0x4x4up8kkcomwg_omq.png" alt="imagem"></div><br><h3>  Tipos de janela </h3><br>  Existem tr√™s tipos de janelas no Kafka Streams: <br><br><ul><li>  sess√£o </li><li>  Cair (tombar); </li><li>  deslizando / "pulando" (deslizando / pulando). </li></ul><br>  Qual escolher depende dos requisitos de neg√≥cios.  As janelas "tombar" e "pular" s√£o limitadas no tempo, enquanto as restri√ß√µes da sess√£o est√£o associadas √†s a√ß√µes do usu√°rio - a dura√ß√£o da (s) sess√£o (s) √© determinada apenas pela forma como o usu√°rio se comporta ativamente.  O principal √© n√£o esquecer que todos os tipos de janelas s√£o baseados em registros de data / hora dos registros e n√£o na hora do sistema. <br><br>  Em seguida, implementamos nossa topologia com cada um dos tipos de janela.  O c√≥digo completo ser√° fornecido apenas no primeiro exemplo, nada ser√° alterado para outros tipos de janelas, exceto para o tipo de opera√ß√£o da janela. <br><br><h3>  Janelas de sess√£o </h3><br>  As janelas de sess√£o s√£o muito diferentes de todos os outros tipos de janelas.  Eles s√£o limitados n√£o tanto pelo tempo como pela atividade do usu√°rio (ou pela atividade da entidade que voc√™ deseja rastrear).  As janelas da sess√£o s√£o delimitadas por per√≠odos de inatividade. <br><br>  A Figura 5.12 ilustra o conceito de janelas de sess√£o.  Uma sess√£o menor ser√° mesclada com a sess√£o √† esquerda.  E a sess√£o √† direita ser√° separada, pois segue um longo per√≠odo de inatividade.  As janelas da sess√£o s√£o baseadas em a√ß√µes do usu√°rio, mas aplicam registros de data / hora dos registros para determinar a qual sess√£o o registro pertence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/c7/z5/jsc7z525p9wrj_tlmrfa5e3vj_u.png" alt="imagem"></div><br><br><h3>  Usando o Windows da sess√£o para rastrear transa√ß√µes do Exchange </h3><br>  Usaremos janelas de sess√£o para capturar informa√ß√µes sobre transa√ß√µes de c√¢mbio.  A implementa√ß√£o das janelas da sess√£o √© mostrada na Listagem 5.5 (que pode ser encontrada em src / main / java / bbejeck / chapter_5 / CountingWindowingAndKTableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/vq/va/vsvqvaqddc3hgy-77fpniuwcbxm.png" alt="imagem"></div><br>  Voc√™ j√° conheceu a maioria das opera√ß√µes desta topologia, portanto n√£o h√° necessidade de consider√°-las aqui novamente.  Mas h√° v√°rios novos elementos que discutiremos agora. <br><br>  Para qualquer opera√ß√£o groupBy, geralmente √© executado algum tipo de opera√ß√£o de agrega√ß√£o (agrega√ß√£o, convolu√ß√£o ou contagem).  Voc√™ pode executar a agrega√ß√£o cumulativa com um total cumulativo ou a agrega√ß√£o de janelas, na qual os registros s√£o levados em considera√ß√£o em uma determinada janela de tempo. <br><br>  O c√≥digo na Listagem 5.5 conta o n√∫mero de transa√ß√µes nas janelas da sess√£o.  Na fig.  5.13 essas a√ß√µes s√£o analisadas passo a passo. <br><br>  Ao chamar windowedBy (SessionWindows.with (twentySeconds) .until (fifteenMinutes)), criamos uma janela de sess√£o com um intervalo ocioso de 20 segundos e um intervalo de reten√ß√£o de 15 minutos.  Um intervalo de inatividade de 20 segundos significa que o aplicativo incluir√° qualquer registro que chegue dentro de 20 segundos a partir do final ou do in√≠cio da sess√£o atual na sess√£o atual (ativa). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/mk/qv/jhmkqvxrrnrd5mxavzltcu-uglq.png" alt="imagem"></div><br>  A seguir, indicamos qual opera√ß√£o de agrega√ß√£o executar na janela da sess√£o - neste caso, conte.  Se o registro recebido estiver fora do intervalo de inatividade (em ambos os lados do registro de data / hora), o aplicativo criar√° uma nova sess√£o.  O intervalo de salvamento significa manter a sess√£o por um certo tempo e permitir dados atrasados ‚Äã‚Äãque v√£o al√©m do per√≠odo de inatividade da sess√£o, mas ainda podem ser anexados.  Al√©m disso, o in√≠cio e o fim de uma nova sess√£o resultante da mesclagem correspondem ao carimbo de data / hora mais antigo e mais recente. <br><br>  Vejamos algumas entradas do m√©todo count para ver como as sess√µes funcionam (Tabela 5.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p-/_f/pn/p-_fpnxaicjsj0ivwzrcxthi77g.png" alt="imagem"></div><br>  Ap√≥s o recebimento dos registros, procuramos sess√µes j√° existentes com a mesma tecla, o hor√°rio final √© menor que o registro de data / hora atual - o intervalo de inatividade e o hor√°rio de in√≠cio √© maior que o registro de data / hora atual + intervalo de inatividade.  Com isso em mente, quatro registros da tabela.  5.1 mesclar em uma √∫nica sess√£o da seguinte maneira. <br><br>  1. O registro 1 vem primeiro, portanto, o hor√°rio de in√≠cio √© igual ao hor√°rio de t√©rmino e √© 00:00:00. <br><br>  2. Em seguida, vem o registro 2, e procuramos sess√µes que terminem antes das 23:59:55 e iniciem at√© 00:00:35.  Localize o registro 1 e combine as sess√µes 1 e 2. Pegue a hora de in√≠cio da sess√£o 1 (anterior) e a hora de t√©rmino da sess√£o 2 (posterior), para que nossa nova sess√£o comece √†s 00:00:00 e termine √†s 00:00:15. <br><br>  3. O registro 3 chega, procuramos sess√µes entre 00:00:30 e 00:01:10 e n√£o encontramos nenhuma.  Adicione uma segunda sess√£o para a chave 123-345-654, FFBE, iniciando e terminando √†s 00:00:50. <br><br>  4. O registro 4 chega e procuramos sess√µes entre 23:59:45 e 00:00:25.  Desta vez, existem duas sess√µes - 1 e 2. Todas as tr√™s sess√µes s√£o combinadas em uma, com um hor√°rio de in√≠cio de 00:00:00 e um hor√°rio de t√©rmino de 00:00:15. <br><br>  Pelo que √© dito nesta se√ß√£o, vale lembrar as seguintes nuances importantes: <br><br><ul><li>  As sess√µes n√£o s√£o janelas de tamanho fixo.  A dura√ß√£o de uma sess√£o √© determinada pela atividade dentro de um determinado per√≠odo de tempo; </li><li>  Os carimbos de data / hora nos dados determinam se um evento cai em uma sess√£o existente ou em um per√≠odo de inatividade. </li></ul><br>  Al√©m disso, discutiremos o seguinte tipo de janela - janela "cambalhota". <br><br><h3>  Janelas em queda </h3><br>  Janelas "ca√≠das" capturam eventos que caem dentro de um determinado per√≠odo de tempo.  Imagine que voc√™ precise capturar todas as transa√ß√µes de c√¢mbio de uma empresa a cada 20 segundos, para coletar todos os eventos desse per√≠odo.  No final do intervalo de 20 segundos, a janela "tomba" e muda para um novo intervalo de observa√ß√£o de 20 segundos.  A Figura 5.14 ilustra essa situa√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sb/jh/gesbjhkrk4wfpsj94edv21lcgzk.png" alt="imagem"></div><br>  Como voc√™ pode ver, todos os eventos recebidos nos √∫ltimos 20 segundos est√£o inclu√≠dos na janela.  No final desse per√≠odo, uma nova janela √© criada. <br><br>  A Listagem 5.6 mostra o c√≥digo que demonstra o uso de janelas alternadas para capturar transa√ß√µes de c√¢mbio a cada 20 segundos (voc√™ pode encontr√°-lo em src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ej/gw/ba/ejgwbaxfd9vzmdok1u6vl7gqjt4.png" alt="imagem"></div><br>  Gra√ßas a essa pequena altera√ß√£o na chamada para o m√©todo TimeWindows.of, voc√™ pode usar a janela de queda.  Neste exemplo, n√£o h√° chamada para o m√©todo till (), como resultado do qual o intervalo de salvamento padr√£o de 24 horas ser√° usado. <br><br>  Finalmente, √© hora de passar para a √∫ltima das op√ß√µes da janela - pulando janelas. <br><br><h3>  Janelas deslizantes ("pulando") </h3><br>  As janelas deslizantes / ‚Äúsaltitantes‚Äù s√£o semelhantes a ‚Äútombar‚Äù, mas com uma pequena diferen√ßa.  As janelas deslizantes n√£o esperam o final do intervalo de tempo antes de criar uma nova janela para manipular eventos recentes.  Eles iniciam novos c√°lculos ap√≥s um intervalo de espera menor que a dura√ß√£o da janela. <br><br>  Para ilustrar as diferen√ßas entre as janelas "cambalhota" e "saltando", voltemos ao exemplo com o c√°lculo das transa√ß√µes de c√¢mbio.  Nosso objetivo, como antes, √© contar o n√∫mero de transa√ß√µes, mas n√£o queremos esperar o tempo todo antes de atualizar o contador.  Em vez disso, atualizaremos o contador em intervalos mais curtos.  Por exemplo, continuaremos contando o n√∫mero de transa√ß√µes a cada 20 segundos, mas atualizando o contador a cada 5 segundos, conforme mostrado na Fig.  5.15  Ao mesmo tempo, temos tr√™s janelas de resultados com dados sobrepostos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/rz/km/f_rzkmhyoxehblurxwysauk3j2k.png" alt="imagem"></div><br>  A Listagem 5.7 mostra o c√≥digo para especificar janelas deslizantes (ele pode ser encontrado em src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/xr/hn/oaxrhnrcxi78qoylbaatcegq__q.png" alt="imagem"></div><br> ¬´¬ª     ¬´¬ª      advanceBy().       15 . <br><br>     ,      .  ,  ,         : <br><br><ul><li>       ,   ; </li><li> ¬´¬ª          ; </li><li>   ¬´¬ª  ,            . </li></ul><br>   ,   KTable   KStream  . <br><br><h3> 5.3.3.   KStream  KTable </h3><br>   4      KStream.      KTable  KStream.       . KStream ‚Äî  ,  KTable ‚Äî   ,                KTable. <br><br>                .    ,        . <br><br><ol><li>   KTable        KStream      ,   ,    . </li><li>   KTable,       .   KTable     . </li><li>            . </li></ol><br>  ,     . <br><br><h3>  KTable  KStream </h3><br>   KTable  KStream   . <br><br><ol><li>   KTable.toStream(). </li><li>     KStream.map     ,      Windowed  TransactionSummary. </li></ol><br>        (     src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/_b/9f/jx_b9frqyde6wj2yvo5nk3palwq.png" alt="imagem"></div><br>     KStream.map,       KStream       . <br><br>    ,      KTable    . <br><br><h3>  KTable    </h3><br>  ,    KTable     (      src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/g5/2w/vbg52wycfxm6ojk2jgpkochuvii.png" alt="imagem"></div><br>  ,    Serde   ,      Serde.     EARLIEST      . <br><br>        ‚Äî . <br><br><h3>         </h3><br>     .      ,         (      src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/8r/zw/nk8rzwzgk7qtaxv0uq3p_sjaipm.png" alt="imagem"></div><br>   leftJoin  .       4,  JoinWindow  ,     KStream-KTable     KTable    .      :     KTable,  .  :    KTable   KStream    . <br><br>           KStream. <br><br><h3> 5.3.4.  GlobalKTable </h3><br>   ,          .   4      KStream,     ‚Äî  KStream  KTable.                 .      ,   Kafka Streams   .   ,          ,     (    4,   ¬´  ¬ª  4.2.4). <br><br><h3>      </h3><br>     ‚Äî       ,       ;            .  ,               ,           . <br><br><h3>       </h3><br>      ,    ,  ,             .     Kafka Streams   GlobalKTable. <br><br>  GlobalKTable ,         .         ,         ,      .    GlobalKTable     .          . <br><br><h3>   KStream   GlobalKTable </h3><br>   5.3.2        .       : <br><br><pre><code class="plaintext hljs">{customerId='074-09-3705', stockTicker='GUTM'}, 17 {customerId='037-34-5184', stockTicker='CORK'}, 16</code> </pre> <br>  Embora esses resultados fossem consistentes com a meta, seria mais conveniente se o nome do cliente e o nome completo da empresa tamb√©m fossem exibidos.  Para adicionar o nome de um cliente e o nome de uma empresa, voc√™ pode realizar conex√µes normais, mas precisar√° fazer dois mapeamentos principais e o particionamento novamente.  Com o GlobalKTable, voc√™ pode evitar o custo de tais opera√ß√µes. <br><br>  Para fazer isso, usaremos o objeto countStream da Listagem 5.11 (o c√≥digo correspondente pode ser encontrado no arquivo src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java), conectando-o a dois objetos GlobalKTable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ds/zj/etdszjjzni9snwmxxbi21xph8e4.png" alt="imagem"></div><br>  J√° discutimos isso antes, ent√£o n√£o vou repetir.  Mas observo que o c√≥digo na fun√ß√£o toStream () .Mapa √© abstra√≠do no objeto de fun√ß√£o para facilitar a legibilidade, em vez da express√£o lambda incorporada. <br><br>  A pr√≥xima etapa √© declarar duas inst√¢ncias do GlobalKTable (o c√≥digo mostrado pode ser encontrado em src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java) (Listagem 5.12). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ca/gd/utcagdf_iab9zjefezaiy2dxt80.png" alt="imagem"></div><br><br>  Observe que os nomes dos t√≥picos s√£o descritos usando tipos enumerados. <br><br>  Agora que preparamos todos os componentes, resta escrever o c√≥digo da conex√£o (que pode ser encontrado no arquivo src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java) (Listagem 5.13). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/yr/oe/avyroeehcpkzq9rzeiqlernoum8.png" alt="imagem"></div><br>  Embora existam dois compostos nesse c√≥digo, eles s√£o organizados em uma cadeia, pois nenhum de seus resultados √© usado separadamente.  Os resultados s√£o exibidos no final de toda a opera√ß√£o. <br><br>  Ao iniciar a opera√ß√£o de conex√£o acima, voc√™ obter√° os seguintes resultados: <br><br><pre> <code class="plaintext hljs">{customer='Barney, Smith' company="Exxon", transactions= 17}</code> </pre> <br>  A ess√™ncia n√£o mudou, mas esses resultados parecem mais claros. <br><br>  Contando o cap√≠tulo 4, voc√™ j√° viu v√°rios tipos de conex√µes em a√ß√£o.  Eles est√£o listados na tabela.  5.2  Esta tabela reflete a conectividade relevante para a vers√£o 1.0.0 do Kafka Streams;  algo mudar√° em vers√µes futuras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_u/ka/gh/_ukaghteoopcpk9i5ljf4cjrwju.png" alt="imagem"></div><br>  Concluindo, lembrarei o principal: voc√™ pode conectar fluxos de eventos (KStream) e atualizar fluxos (KTable) usando o estado local.  Al√©m disso, se o tamanho dos dados de refer√™ncia n√£o for muito grande, voc√™ poder√° usar o objeto GlobalKTable.  O GlobalKTable replica todas as se√ß√µes em cada um dos n√≥s do aplicativo Kafka Streams, garantindo a disponibilidade de todos os dados, independentemente da se√ß√£o √† qual a chave corresponde. <br><br>  A seguir, veremos a possibilidade do Kafka Streams, gra√ßas √† qual √© poss√≠vel observar altera√ß√µes de estado sem consumir dados do t√≥pico Kafka. <br><br><h3>  5.3.5  Status da solicita√ß√£o </h3><br>  J√° realizamos v√°rias opera√ß√µes envolvendo o estado e sempre produzimos os resultados no console (para fins de desenvolvimento) ou escrevemos no t√≥pico (para opera√ß√£o industrial).  Ao gravar resultados em um t√≥pico, voc√™ deve usar o consumidor Kafka para visualiz√°-los. <br><br>  A leitura de dados desses t√≥picos pode ser considerada um tipo de vis√£o materializada.  Para nossas tarefas, podemos usar a defini√ß√£o de uma vis√£o materializada da Wikipedia: ‚Äú... um objeto de banco de dados f√≠sico contendo os resultados de uma consulta.  Por exemplo, pode ser uma c√≥pia local dos dados exclu√≠dos, um subconjunto de linhas e / ou colunas de uma tabela ou resultados de jun√ß√£o ou uma tabela din√¢mica obtida usando agrega√ß√£o ‚Äù(https://en.wikipedia.org/wiki/Materialized_view). <br><br>  O Kafka Streams tamb√©m permite executar consultas interativas em lojas de estado, o que permite ler diretamente essas visualiza√ß√µes materializadas.  √â importante observar que a solicita√ß√£o para o armazenamento de estado √© da natureza de uma opera√ß√£o somente leitura.  Gra√ßas a isso, voc√™ n√£o pode ter medo de tornar acidentalmente o estado um aplicativo inconsistente durante o processamento de dados. <br><br>  A capacidade de consultar diretamente os armazenamentos de estado √© importante.  Isso significa que voc√™ pode criar aplicativos - pain√©is sem precisar primeiro receber dados de um consumidor Kafka.  Aumenta a efici√™ncia do aplicativo, devido ao fato de n√£o ser necess√°rio registrar dados novamente: <br><br><ul><li>  devido √† localidade dos dados, eles podem ser acessados ‚Äã‚Äãrapidamente; </li><li>  A duplica√ß√£o de dados √© exclu√≠da, pois eles n√£o s√£o gravados no armazenamento externo. </li></ul><br>  A principal coisa que eu gostaria que voc√™ se lembrasse: voc√™ pode executar diretamente solicita√ß√µes de estado do aplicativo.  Voc√™ n√£o pode superestimar as oportunidades que isso oferece.  Em vez de consumir dados do Kafka e armazenar registros no banco de dados do aplicativo, voc√™ pode consultar os armazenamentos de estado com o mesmo resultado.  Solicita√ß√µes diretas para lojas de estado significam menos c√≥digo (sem consumidor) e menos software (sem necessidade de uma tabela de banco de dados para armazenar os resultados). <br><br>  Abordamos uma quantidade consider√°vel de informa√ß√µes neste cap√≠tulo; portanto, interromperemos temporariamente nossa discuss√£o de consultas interativas para lojas de estado.  Mas n√£o se preocupe: no cap√≠tulo 9, criaremos um aplicativo simples - um painel de informa√ß√µes com consultas interativas.  Para demonstrar consultas interativas e as possibilidades de adicion√°-las aos aplicativos Kafka Streams, ele utilizar√° alguns dos exemplos deste e dos cap√≠tulos anteriores. <br><br><h3>  Sum√°rio </h3><br><ul><li>  Os objetos KStream representam fluxos de eventos compar√°veis ‚Äã‚Äã√†s inser√ß√µes do banco de dados.  Os objetos KTable representam fluxos de atualiza√ß√£o, s√£o mais semelhantes √†s atualiza√ß√µes no banco de dados.  O tamanho do objeto KTable n√£o aumenta; registros antigos s√£o substitu√≠dos por novos. </li><li>  Os objetos KTable s√£o necess√°rios para opera√ß√µes de agrega√ß√£o. </li><li>  Usando as opera√ß√µes da janela, voc√™ pode dividir os dados agregados em cestas de horas. </li><li>  Gra√ßas aos objetos GlobalKTable, voc√™ pode acessar dados de refer√™ncia em qualquer lugar do aplicativo, independentemente do corte. </li><li>  Conex√µes entre os objetos KStream, KTable e GlobalKTable s√£o poss√≠veis. </li></ul><br>  At√© o momento, focamos na cria√ß√£o de aplicativos Kafka Streams usando o DSL de alto n√≠vel do KStream.  Embora uma abordagem de alto n√≠vel permita a cria√ß√£o de programas puros e concisos, seu uso √© um compromisso definitivo.  Trabalhar com o DSL KStream significa aumentar a concis√£o do c√≥digo, reduzindo o grau de controle.  No pr√≥ximo cap√≠tulo, examinaremos a API de baixo n√≠vel dos n√≥s manipuladores e tentaremos outras compensa√ß√µes.  Os programas ficar√£o mais longos do que eram at√© agora, mas teremos a oportunidade de criar quase todos os n√≥s de processamento que precisarmos. <br><br>  ‚Üí Mais detalhes sobre o livro podem ser encontrados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br><br>  ‚Üí Para Khabrozhiteley 25% de desconto no cupom - <b>Kafka Streams</b> <br><br>  ‚Üí Ap√≥s o pagamento da vers√£o impressa do livro, um livro eletr√¥nico √© enviado por e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457756/">https://habr.com/ru/post/pt457756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457744/index.html">Criando um sistema de extens√£o na biblioteca Qt - parte 2</a></li>
<li><a href="../pt457746/index.html">Meteorologia e voos</a></li>
<li><a href="../pt457750/index.html">Trabalhar com JSON RPC no Symfony 4</a></li>
<li><a href="../pt457752/index.html">Nem vagabundos da lua nem piadistas. O que sabemos sobre rob√¥s em Fukushima</a></li>
<li><a href="../pt457754/index.html">Estado e T-killers</a></li>
<li><a href="../pt457758/index.html">Engenheiros salvam pessoas perdidas na floresta, mas a floresta ainda n√£o se rendeu</a></li>
<li><a href="../pt457760/index.html">Como tornar os cont√™ineres ainda mais isolados: uma revis√£o das tecnologias de sandbox de cont√™ineres</a></li>
<li><a href="../pt457762/index.html">R√©gua do CCD: o que √© comido</a></li>
<li><a href="../pt457764/index.html">10 erros do jovem PO (parte II)</a></li>
<li><a href="../pt457766/index.html">Geramos n√≠veis de ladrilhos e ocultamos quadrados do jogador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>