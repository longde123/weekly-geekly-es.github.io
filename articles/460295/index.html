<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   驴Qu茅 significa inseguro en Rust?   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Te presento la traducci贸n del art铆culo "驴Qu茅 es inseguro de Rust?" autora Nora Codes. 


 He visto muchos malentendidos sobre lo que signif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>驴Qu茅 significa inseguro en Rust?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460295/"><p> Hola Habr!  Te presento la traducci贸n del art铆culo "驴Qu茅 es inseguro de Rust?"  autora Nora Codes. </p><br><p>  He visto muchos malentendidos sobre lo que significa la palabra clave insegura para la utilidad y correcci贸n del lenguaje Rust y su promoci贸n como un "lenguaje de programaci贸n de sistema seguro".  La verdad es mucho m谩s complicada de lo que se puede describir en un breve tuit, desafortunadamente.  As铆 es como la veo. </p><br><p>  En general, la <strong>palabra clave insegura no desactiva el sistema de tipos que mantiene el c贸digo Rust correcto</strong> .  Solo hace posible utilizar algunos "superpoderes", como desreferenciar punteros.  inseguro se usa para implementar abstracciones seguras basadas en un mundo fundamentalmente inseguro para que la mayor铆a del c贸digo Rust pueda usar estas abstracciones y evitar el acceso inseguro a la memoria. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Garant铆a de seguridad </h1><br><p>  El 贸xido garantiza la seguridad como uno de sus principios fundamentales.  Podemos decir que este es el <em>significado de la existencia del</em> lenguaje.  Sin embargo, no proporciona seguridad en el sentido tradicional, durante la ejecuci贸n del programa y el uso del recolector de basura.  En cambio, Rust utiliza un sistema de tipos muy avanzado para realizar un seguimiento de cu谩ndo y a qu茅 valores se puede acceder.  Luego, el compilador analiza est谩ticamente cada programa Rust para asegurarse de que siempre est茅 en el estado correcto. </p><br><h2 id="bezopasnost-v-python">  Python Security </h2><br><p>  Tomemos Python como ejemplo.  El c贸digo puro de Python no puede da帽ar la memoria.  El acceso a los elementos de la lista tiene controles para ir m谩s all谩 de las fronteras;  los enlaces devueltos por funciones se cuentan para evitar la aparici贸n de enlaces colgantes;  No hay forma de hacer aritm茅tica arbitraria con punteros. </p><br><p>  Esto tiene dos consecuencias.  Primero, muchos tipos deben ser "especiales".  Por ejemplo, no es posible implementar una lista o diccionario efectivo en Python puro.  En cambio, el int茅rprete de CPython tiene su implementaci贸n interna.  En segundo lugar, el acceso a funciones externas (funciones no implementadas en Python), llamado interfaz de una funci贸n externa, requiere el uso de un m贸dulo de tipos especiales y viola las garant铆as de seguridad del lenguaje. </p><br><p>  En cierto sentido, esto significa que todo lo escrito en Python no garantiza un acceso seguro a la memoria. </p><br><h2 id="bezopasnost-v-rust">  Seguridad en 贸xido </h2><br><p>  Rust tambi茅n proporciona seguridad, pero en lugar de implementar estructuras inseguras en C, proporciona un truco: la palabra clave insegura.  Esto significa que las estructuras de datos fundamentales en Rust, como Vec, VecDeque, BTreeMap y String, se implementan en Rust. </p><br><p>  Puede preguntar: "Pero, si Rust ofrece un truco contra las garant铆as de seguridad de su c贸digo, y la biblioteca est谩ndar se implementa utilizando este truco, 驴no se considerar谩 que todo en Rust es inseguro?" </p><br><p>  En una palabra, querido lector, <strong>s铆</strong> , exactamente como era en Python.  Miremos con m谩s detalle. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  驴Qu茅 est谩 prohibido en Rust seguro? </h1><br><p>  La seguridad en Rust est谩 bien definida: pensamos mucho en ello.  En resumen, los programas Rust seguros no pueden: </p><br><ul><li>  <strong>Desreferenciar un puntero que apunta a un tipo diferente del que conoce el compilador</strong> .  Esto significa que no hay punteros para anular (porque no apuntan a ning煤n lado), no hay errores de salirse de los l铆mites y / o errores de segmentaci贸n (fallas de segmentaci贸n), ni desbordamientos de b煤fer.  Pero tambi茅n significa que no hay usos despu茅s de liberar la memoria o volver a liberar la memoria (porque liberar la memoria se considera desreferenciar el puntero) y ning煤n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juego de palabras destinado a escribir</a> . </li><li>  <strong>Tener m煤ltiples referencias mutables a un objeto o simult谩neamente referencias mutables e inmutables a un objeto</strong> .  Es decir, si tiene una referencia mutable a un objeto, solo puede tenerlo, y si tiene una referencia inmutable al objeto, no cambiar谩 hasta que lo conserve.  Esto significa que no puede forzar una carrera de datos en Safe Rust, que es una garant铆a que la mayor铆a de los otros idiomas seguros no pueden proporcionar. </li></ul><br><p>  Rust codifica esta informaci贸n en un sistema de tipos o usando <strong>tipos de datos algebraicos</strong> , como la opci贸n para indicar la existencia / ausencia de un valor y el resultado &lt;T, E&gt; para indicar error / 茅xito, o <strong>referencias y su vida 煤til</strong> , por ejemplo, &amp; T vs &amp; mut T para indicar un enlace com煤n (inmutable) y un enlace exclusivo (mutable) y 'a T vs' b T para distinguir los enlaces que son correctos en diferentes contextos (esto generalmente se omite ya que el compilador es lo suficientemente inteligente como para descubrirlo usted mismo) . <br></p><br><h2 id="primery">  Ejemplos </h2><br><p>  Por ejemplo, el siguiente c贸digo no se compilar谩 ya que contiene un enlace colgante.  M谩s espec铆ficamente, <em>my_struct no vive lo suficiente</em> .  En otras palabras, la funci贸n devolver谩 un enlace a algo que ya no existe y, por lo tanto, el compilador no puede (y, de hecho, ni siquiera sabe) compilar esto. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  Este c贸digo hace lo mismo, pero intenta solucionar este problema colocando el valor en el mont贸n (Box es el nombre del puntero inteligente base en Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  El c贸digo correcto lo devuelve Box en lugar de una referencia a 茅l.  Esto codifica la transferencia de propiedad, la responsabilidad de liberar memoria, en la firma de la funci贸n.  Al mirar la firma, queda claro que el c贸digo de llamada es responsable de lo que sucede con Box y, de hecho, el compilador lo procesa autom谩ticamente. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Algunas cosas malas no est谩n prohibidas en Safe Rust.  Por ejemplo, est谩 permitido desde el punto de vista del compilador: <br><ul><li>  causar un punto muerto en el programa </li><li>  perder una cantidad arbitrariamente grande de memoria </li><li>  no cierra los identificadores de archivo, las conexiones de la base de datos o las cubiertas del eje de misiles </li></ul><br><br>  La fortaleza del ecosistema Rust es que muchos proyectos eligen usar un sistema de tipos para garantizar que el c贸digo sea lo m谩s preciso posible, pero el compilador no requiere tal coerci贸n, excepto en los casos en que se proporciona acceso seguro a la memoria. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  驴Qu茅 est谩 permitido en Rust inseguro? </h1><br><p>  El c贸digo Rust inseguro es un c贸digo Rust con la palabra clave insegura.  inseguro se puede aplicar a una funci贸n o bloque de c贸digo.  Cuando se aplica a una funci贸n, significa "esta funci贸n requiere que el c贸digo llamado proporcione manualmente el invariante que generalmente proporciona el compilador".  Cuando se aplica a un bloque de c贸digo, significa que "este bloque de c贸digo proporciona manualmente la invariante necesaria para evitar el acceso inseguro a la memoria y, por lo tanto, est谩 permitido hacer cosas inseguras". </p><br><p>  <strong>En otras palabras, inseguro para la funci贸n significa "necesita verificar todo", y en el bloque de c贸digo - "Ya verifiqu茅 todo".</strong> </p><br><p>  Como se se帽al贸 en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Rust Programming Language</a> , el c贸digo en un bloque marcado con la palabra clave insegura puede: </p><br><ul><li>  <strong>Desreferenciar un puntero.</strong>  Esta es una "superpotencia" clave que le permite implementar listas doblemente vinculadas, hashmap y otras estructuras de datos fundamentales. </li><li>  <strong>Llamar a una funci贸n o m茅todo inseguro.</strong>  M谩s sobre esto a continuaci贸n. </li><li>  <strong>Acceda o modifique una variable est谩tica mutable.</strong>  Las variables est谩ticas cuyo alcance no est谩 controlado no se pueden verificar est谩ticamente, por lo tanto, su uso no es seguro. </li><li>  <strong>Implementar rasgo inseguro.</strong>  Los rasgos inseguros se utilizan para indicar si determinados tipos garantizan ciertos invariantes.  Por ejemplo, Enviar y Sincronizar determinan si un tipo puede enviarse entre los l铆mites del hilo o si puede ser usado por varios hilos al mismo tiempo. </li></ul><br><p>  驴Recuerdas los punteros colgantes de arriba?  Agregue la palabra inseguro, y el compilador jurar谩 el doble porque no le gusta usar inseguro donde no es necesario. </p><br><p>  En cambio, la palabra clave insegura se usa para implementar abstracciones seguras basadas en operaciones de puntero arbitrarias.  Por ejemplo, el tipo Vec se implementa usando inseguro, pero es seguro usarlo, ya que verifica los intentos de acceder a elementos y no permite desbordamientos.  Aunque proporciona operaciones como set_len, que <em>pueden</em> causar acceso inseguro a la memoria, est谩n marcadas como inseguras. </p><br><p>  Por ejemplo, podr铆amos hacer lo mismo que en el ejemplo no_dangling_reference, pero con un uso irrazonable de inseguro: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Observe la falta de la palabra insegura.  Crear punteros es absolutamente seguro.  Como se escribi贸, esto es un riesgo de p茅rdida de memoria, pero nada m谩s, y las p茅rdidas de memoria son seguras.  Llamar a esta funci贸n tambi茅n es seguro.  inseguro solo se requiere cuando algo intenta <strong>desreferenciar un</strong> puntero.  Como una ventaja adicional, la desreferenciaci贸n liberar谩 autom谩ticamente la memoria asignada. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  Despu茅s de la optimizaci贸n, este c贸digo es equivalente a simplemente devolver un Box.  Box es una abstracci贸n segura basada en punteros porque evita la distribuci贸n de punteros en todas partes.  Por ejemplo, la pr贸xima versi贸n de main <strong>dar谩 lugar</strong> a una memoria doble libre (doble libre). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  Entonces, 驴qu茅 es la abstracci贸n segura? </h2><br><p>  La abstracci贸n segura es una abstracci贸n que utiliza un sistema de tipos para proporcionar una API que no se puede utilizar para violar las garant铆as de seguridad que se mencionaron anteriormente.  Box es m谩s seguro * mut T, ya que no puede conducir a una doble desasignaci贸n de memoria, como se ilustra arriba. </p><br><p>  Otro ejemplo es el tipo Rc en Rust.  Este es un puntero de recuento de referencias: una referencia no modificable a los datos en el mont贸n.  Dado que permite el acceso simult谩neo m煤ltiple a un 谩rea de memoria, <em>debe</em> evitar cambios para ser considerado seguro. </p><br><p>  Adem谩s de esto, no es seguro para subprocesos.  Si necesita seguridad de subprocesos, tendr谩 que usar el tipo Arc (Recuento de referencia at贸mica), que tiene una penalizaci贸n de rendimiento debido al uso de valores at贸micos para el recuento de enlaces y para evitar posibles carreras de datos en entornos de subprocesos m煤ltiples. </p><br><p>  El compilador no le permitir谩 usar Rc donde deber铆a usar Arc, porque los creadores como Rc no lo marcaron como seguro para subprocesos.  Si lo hicieran, no ser铆a razonable: una falsa promesa de seguridad. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  驴Cu谩ndo se necesita 贸xido inseguro? </h2><br><p>  El 贸xido inseguro siempre es necesario cuando es necesario realizar una operaci贸n que viole una de las dos reglas descritas anteriormente.  Por ejemplo, en una lista doblemente vinculada, la ausencia de enlaces mutables a los mismos datos (para el siguiente elemento y el elemento anterior) lo priva completamente de beneficios.  Con inseguro, un implementador de lista doblemente enlazado puede escribir c贸digo usando punteros de nodo * mut y luego encapsularlo en una abstracci贸n segura. <br></p><p>  Otro ejemplo es trabajar con sistemas embebidos.  A menudo, los microcontroladores usan un conjunto de registros cuyos valores est谩n determinados por el estado f铆sico del dispositivo.  El mundo no puede detenerse mientras toma &amp; mut u8 de dicho registro, por lo tanto, se requiere inseguro para trabajar con cajas de soporte de dispositivos.  T铆picamente, tales cajas encapsulan el estado en envoltorios transparentes y seguros que copian datos siempre que sea posible, o usan otras t茅cnicas que brindan garant铆as del compilador. </p><br><p>  A veces es necesario llevar a cabo una operaci贸n que puede conducir a la lectura y escritura simult谩neas, o al acceso inseguro a la memoria, y aqu铆 es donde se necesita inseguridad.  Pero mientras exista la oportunidad de asegurarse de que los invariantes seguros se mantengan antes de que un usuario toque algo (es decir, inseguro, inseguro), todo est谩 bien. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  驴En los hombros de qui茅n descansa esta responsabilidad? </h1><br><p>  Llegamos a una declaraci贸n hecha anteriormente: <strong>s铆</strong> , la utilidad del c贸digo Rust se basa en un c贸digo inseguro.  A pesar de que esto se hace de una manera ligeramente diferente a la implementaci贸n insegura de estructuras de datos b谩sicas en Python, la implementaci贸n de Vec, Hashmap, etc., <strong>deber铆a</strong> utilizar manipulaciones de puntero en cierta medida. </p><br><p>  Decimos que Rust es seguro, con la suposici贸n fundamental de que el c贸digo inseguro que usamos a trav茅s de nuestras dependencias en la biblioteca est谩ndar o en el c贸digo de otras bibliotecas est谩 correctamente escrito y encapsulado.  La ventaja fundamental de Rust es que el c贸digo inseguro se convierte en bloques inseguros que deben ser revisados cuidadosamente por sus autores. </p><br><p>  En Python, la carga de verificar la seguridad de las manipulaciones de memoria recae solo en los desarrolladores de los int茅rpretes y usuarios de las interfaces de funciones externas.  En C, esta carga recae en cada programador. </p><br><p>  En Rust, se encuentra con los usuarios de la palabra clave insegura.  Esto es obvio, ya que los invariantes deben mantenerse manualmente dentro de dicho c贸digo y, por lo tanto, es necesario esforzarse por obtener la menor cantidad de dicho c贸digo en la biblioteca o en el c贸digo de la aplicaci贸n.  La inseguridad se detecta, resalta e indica.  Por lo tanto, si se producen fallas seguras en su c贸digo Rust, entonces encontrar谩 un error en el compilador o un error en varias l铆neas de su c贸digo inseguro. </p><br><p>  Este no es un sistema perfecto, pero si necesita velocidad, seguridad y multihilo al mismo tiempo, entonces esta es la 煤nica opci贸n. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460295/">https://habr.com/ru/post/460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460281/index.html">C贸mo UX Writer ayuda a mejorar el producto</a></li>
<li><a href="../460283/index.html">Nuevo lenguaje de programaci贸n h谩galo usted mismo</a></li>
<li><a href="../460285/index.html">Estamos preparando PHP. 驴C贸mo son while, foreach, array_walk y algunas otras palabras de miedo</a></li>
<li><a href="../460287/index.html">Visualizaci贸n de noticias runet</a></li>
<li><a href="../460291/index.html">Problemas de procesamiento por lotes de solicitudes y sus soluciones (parte 1)</a></li>
<li><a href="../460297/index.html">WeakRef - propuesta para agregar al est谩ndar ECMAScript</a></li>
<li><a href="../460301/index.html">L谩mparas LED de alta potencia de nueva generaci贸n.</a></li>
<li><a href="../460305/index.html">AERODISCO Motor: catastr贸fico. Parte 2. Metrocluster</a></li>
<li><a href="../460307/index.html">Experiencia de modelado del equipo de Computer Vision Mail.ru</a></li>
<li><a href="../460311/index.html">Hora de una nueva teor铆a del dinero.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>