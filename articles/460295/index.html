<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîù üè¨ üêÑ ¬øQu√© significa inseguro en Rust? üê∞ üçï üëäüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Te presento la traducci√≥n del art√≠culo "¬øQu√© es inseguro de Rust?" autora Nora Codes. 


 He visto muchos malentendidos sobre lo que signif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© significa inseguro en Rust?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460295/"><p> Hola Habr!  Te presento la traducci√≥n del art√≠culo "¬øQu√© es inseguro de Rust?"  autora Nora Codes. </p><br><p>  He visto muchos malentendidos sobre lo que significa la palabra clave insegura para la utilidad y correcci√≥n del lenguaje Rust y su promoci√≥n como un "lenguaje de programaci√≥n de sistema seguro".  La verdad es mucho m√°s complicada de lo que se puede describir en un breve tuit, desafortunadamente.  As√≠ es como la veo. </p><br><p>  En general, la <strong>palabra clave insegura no desactiva el sistema de tipos que mantiene el c√≥digo Rust correcto</strong> .  Solo hace posible utilizar algunos "superpoderes", como desreferenciar punteros.  inseguro se usa para implementar abstracciones seguras basadas en un mundo fundamentalmente inseguro para que la mayor√≠a del c√≥digo Rust pueda usar estas abstracciones y evitar el acceso inseguro a la memoria. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Garant√≠a de seguridad </h1><br><p>  El √≥xido garantiza la seguridad como uno de sus principios fundamentales.  Podemos decir que este es el <em>significado de la existencia del</em> lenguaje.  Sin embargo, no proporciona seguridad en el sentido tradicional, durante la ejecuci√≥n del programa y el uso del recolector de basura.  En cambio, Rust utiliza un sistema de tipos muy avanzado para realizar un seguimiento de cu√°ndo y a qu√© valores se puede acceder.  Luego, el compilador analiza est√°ticamente cada programa Rust para asegurarse de que siempre est√© en el estado correcto. </p><br><h2 id="bezopasnost-v-python">  Python Security </h2><br><p>  Tomemos Python como ejemplo.  El c√≥digo puro de Python no puede da√±ar la memoria.  El acceso a los elementos de la lista tiene controles para ir m√°s all√° de las fronteras;  los enlaces devueltos por funciones se cuentan para evitar la aparici√≥n de enlaces colgantes;  No hay forma de hacer aritm√©tica arbitraria con punteros. </p><br><p>  Esto tiene dos consecuencias.  Primero, muchos tipos deben ser "especiales".  Por ejemplo, no es posible implementar una lista o diccionario efectivo en Python puro.  En cambio, el int√©rprete de CPython tiene su implementaci√≥n interna.  En segundo lugar, el acceso a funciones externas (funciones no implementadas en Python), llamado interfaz de una funci√≥n externa, requiere el uso de un m√≥dulo de tipos especiales y viola las garant√≠as de seguridad del lenguaje. </p><br><p>  En cierto sentido, esto significa que todo lo escrito en Python no garantiza un acceso seguro a la memoria. </p><br><h2 id="bezopasnost-v-rust">  Seguridad en √≥xido </h2><br><p>  Rust tambi√©n proporciona seguridad, pero en lugar de implementar estructuras inseguras en C, proporciona un truco: la palabra clave insegura.  Esto significa que las estructuras de datos fundamentales en Rust, como Vec, VecDeque, BTreeMap y String, se implementan en Rust. </p><br><p>  Puede preguntar: "Pero, si Rust ofrece un truco contra las garant√≠as de seguridad de su c√≥digo, y la biblioteca est√°ndar se implementa utilizando este truco, ¬øno se considerar√° que todo en Rust es inseguro?" </p><br><p>  En una palabra, querido lector, <strong>s√≠</strong> , exactamente como era en Python.  Miremos con m√°s detalle. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  ¬øQu√© est√° prohibido en Rust seguro? </h1><br><p>  La seguridad en Rust est√° bien definida: pensamos mucho en ello.  En resumen, los programas Rust seguros no pueden: </p><br><ul><li>  <strong>Desreferenciar un puntero que apunta a un tipo diferente del que conoce el compilador</strong> .  Esto significa que no hay punteros para anular (porque no apuntan a ning√∫n lado), no hay errores de salirse de los l√≠mites y / o errores de segmentaci√≥n (fallas de segmentaci√≥n), ni desbordamientos de b√∫fer.  Pero tambi√©n significa que no hay usos despu√©s de liberar la memoria o volver a liberar la memoria (porque liberar la memoria se considera desreferenciar el puntero) y ning√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juego de palabras destinado a escribir</a> . </li><li>  <strong>Tener m√∫ltiples referencias mutables a un objeto o simult√°neamente referencias mutables e inmutables a un objeto</strong> .  Es decir, si tiene una referencia mutable a un objeto, solo puede tenerlo, y si tiene una referencia inmutable al objeto, no cambiar√° hasta que lo conserve.  Esto significa que no puede forzar una carrera de datos en Safe Rust, que es una garant√≠a que la mayor√≠a de los otros idiomas seguros no pueden proporcionar. </li></ul><br><p>  Rust codifica esta informaci√≥n en un sistema de tipos o usando <strong>tipos de datos algebraicos</strong> , como la opci√≥n para indicar la existencia / ausencia de un valor y el resultado &lt;T, E&gt; para indicar error / √©xito, o <strong>referencias y su vida √∫til</strong> , por ejemplo, &amp; T vs &amp; mut T para indicar un enlace com√∫n (inmutable) y un enlace exclusivo (mutable) y 'a T vs' b T para distinguir los enlaces que son correctos en diferentes contextos (esto generalmente se omite ya que el compilador es lo suficientemente inteligente como para descubrirlo usted mismo) . <br></p><br><h2 id="primery">  Ejemplos </h2><br><p>  Por ejemplo, el siguiente c√≥digo no se compilar√° ya que contiene un enlace colgante.  M√°s espec√≠ficamente, <em>my_struct no vive lo suficiente</em> .  En otras palabras, la funci√≥n devolver√° un enlace a algo que ya no existe y, por lo tanto, el compilador no puede (y, de hecho, ni siquiera sabe) compilar esto. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  Este c√≥digo hace lo mismo, pero intenta solucionar este problema colocando el valor en el mont√≥n (Box es el nombre del puntero inteligente base en Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  El c√≥digo correcto lo devuelve Box en lugar de una referencia a √©l.  Esto codifica la transferencia de propiedad, la responsabilidad de liberar memoria, en la firma de la funci√≥n.  Al mirar la firma, queda claro que el c√≥digo de llamada es responsable de lo que sucede con Box y, de hecho, el compilador lo procesa autom√°ticamente. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Algunas cosas malas no est√°n prohibidas en Safe Rust.  Por ejemplo, est√° permitido desde el punto de vista del compilador: <br><ul><li>  causar un punto muerto en el programa </li><li>  perder una cantidad arbitrariamente grande de memoria </li><li>  no cierra los identificadores de archivo, las conexiones de la base de datos o las cubiertas del eje de misiles </li></ul><br><br>  La fortaleza del ecosistema Rust es que muchos proyectos eligen usar un sistema de tipos para garantizar que el c√≥digo sea lo m√°s preciso posible, pero el compilador no requiere tal coerci√≥n, excepto en los casos en que se proporciona acceso seguro a la memoria. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  ¬øQu√© est√° permitido en Rust inseguro? </h1><br><p>  El c√≥digo Rust inseguro es un c√≥digo Rust con la palabra clave insegura.  inseguro se puede aplicar a una funci√≥n o bloque de c√≥digo.  Cuando se aplica a una funci√≥n, significa "esta funci√≥n requiere que el c√≥digo llamado proporcione manualmente el invariante que generalmente proporciona el compilador".  Cuando se aplica a un bloque de c√≥digo, significa que "este bloque de c√≥digo proporciona manualmente la invariante necesaria para evitar el acceso inseguro a la memoria y, por lo tanto, est√° permitido hacer cosas inseguras". </p><br><p>  <strong>En otras palabras, inseguro para la funci√≥n significa "necesita verificar todo", y en el bloque de c√≥digo - "Ya verifiqu√© todo".</strong> </p><br><p>  Como se se√±al√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Rust Programming Language</a> , el c√≥digo en un bloque marcado con la palabra clave insegura puede: </p><br><ul><li>  <strong>Desreferenciar un puntero.</strong>  Esta es una "superpotencia" clave que le permite implementar listas doblemente vinculadas, hashmap y otras estructuras de datos fundamentales. </li><li>  <strong>Llamar a una funci√≥n o m√©todo inseguro.</strong>  M√°s sobre esto a continuaci√≥n. </li><li>  <strong>Acceda o modifique una variable est√°tica mutable.</strong>  Las variables est√°ticas cuyo alcance no est√° controlado no se pueden verificar est√°ticamente, por lo tanto, su uso no es seguro. </li><li>  <strong>Implementar rasgo inseguro.</strong>  Los rasgos inseguros se utilizan para indicar si determinados tipos garantizan ciertos invariantes.  Por ejemplo, Enviar y Sincronizar determinan si un tipo puede enviarse entre los l√≠mites del hilo o si puede ser usado por varios hilos al mismo tiempo. </li></ul><br><p>  ¬øRecuerdas los punteros colgantes de arriba?  Agregue la palabra inseguro, y el compilador jurar√° el doble porque no le gusta usar inseguro donde no es necesario. </p><br><p>  En cambio, la palabra clave insegura se usa para implementar abstracciones seguras basadas en operaciones de puntero arbitrarias.  Por ejemplo, el tipo Vec se implementa usando inseguro, pero es seguro usarlo, ya que verifica los intentos de acceder a elementos y no permite desbordamientos.  Aunque proporciona operaciones como set_len, que <em>pueden</em> causar acceso inseguro a la memoria, est√°n marcadas como inseguras. </p><br><p>  Por ejemplo, podr√≠amos hacer lo mismo que en el ejemplo no_dangling_reference, pero con un uso irrazonable de inseguro: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Observe la falta de la palabra insegura.  Crear punteros es absolutamente seguro.  Como se escribi√≥, esto es un riesgo de p√©rdida de memoria, pero nada m√°s, y las p√©rdidas de memoria son seguras.  Llamar a esta funci√≥n tambi√©n es seguro.  inseguro solo se requiere cuando algo intenta <strong>desreferenciar un</strong> puntero.  Como una ventaja adicional, la desreferenciaci√≥n liberar√° autom√°ticamente la memoria asignada. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  Despu√©s de la optimizaci√≥n, este c√≥digo es equivalente a simplemente devolver un Box.  Box es una abstracci√≥n segura basada en punteros porque evita la distribuci√≥n de punteros en todas partes.  Por ejemplo, la pr√≥xima versi√≥n de main <strong>dar√° lugar</strong> a una memoria doble libre (doble libre). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  Entonces, ¬øqu√© es la abstracci√≥n segura? </h2><br><p>  La abstracci√≥n segura es una abstracci√≥n que utiliza un sistema de tipos para proporcionar una API que no se puede utilizar para violar las garant√≠as de seguridad que se mencionaron anteriormente.  Box es m√°s seguro * mut T, ya que no puede conducir a una doble desasignaci√≥n de memoria, como se ilustra arriba. </p><br><p>  Otro ejemplo es el tipo Rc en Rust.  Este es un puntero de recuento de referencias: una referencia no modificable a los datos en el mont√≥n.  Dado que permite el acceso simult√°neo m√∫ltiple a un √°rea de memoria, <em>debe</em> evitar cambios para ser considerado seguro. </p><br><p>  Adem√°s de esto, no es seguro para subprocesos.  Si necesita seguridad de subprocesos, tendr√° que usar el tipo Arc (Recuento de referencia at√≥mica), que tiene una penalizaci√≥n de rendimiento debido al uso de valores at√≥micos para el recuento de enlaces y para evitar posibles carreras de datos en entornos de subprocesos m√∫ltiples. </p><br><p>  El compilador no le permitir√° usar Rc donde deber√≠a usar Arc, porque los creadores como Rc no lo marcaron como seguro para subprocesos.  Si lo hicieran, no ser√≠a razonable: una falsa promesa de seguridad. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  ¬øCu√°ndo se necesita √≥xido inseguro? </h2><br><p>  El √≥xido inseguro siempre es necesario cuando es necesario realizar una operaci√≥n que viole una de las dos reglas descritas anteriormente.  Por ejemplo, en una lista doblemente vinculada, la ausencia de enlaces mutables a los mismos datos (para el siguiente elemento y el elemento anterior) lo priva completamente de beneficios.  Con inseguro, un implementador de lista doblemente enlazado puede escribir c√≥digo usando punteros de nodo * mut y luego encapsularlo en una abstracci√≥n segura. <br></p><p>  Otro ejemplo es trabajar con sistemas embebidos.  A menudo, los microcontroladores usan un conjunto de registros cuyos valores est√°n determinados por el estado f√≠sico del dispositivo.  El mundo no puede detenerse mientras toma &amp; mut u8 de dicho registro, por lo tanto, se requiere inseguro para trabajar con cajas de soporte de dispositivos.  T√≠picamente, tales cajas encapsulan el estado en envoltorios transparentes y seguros que copian datos siempre que sea posible, o usan otras t√©cnicas que brindan garant√≠as del compilador. </p><br><p>  A veces es necesario llevar a cabo una operaci√≥n que puede conducir a la lectura y escritura simult√°neas, o al acceso inseguro a la memoria, y aqu√≠ es donde se necesita inseguridad.  Pero mientras exista la oportunidad de asegurarse de que los invariantes seguros se mantengan antes de que un usuario toque algo (es decir, inseguro, inseguro), todo est√° bien. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  ¬øEn los hombros de qui√©n descansa esta responsabilidad? </h1><br><p>  Llegamos a una declaraci√≥n hecha anteriormente: <strong>s√≠</strong> , la utilidad del c√≥digo Rust se basa en un c√≥digo inseguro.  A pesar de que esto se hace de una manera ligeramente diferente a la implementaci√≥n insegura de estructuras de datos b√°sicas en Python, la implementaci√≥n de Vec, Hashmap, etc., <strong>deber√≠a</strong> utilizar manipulaciones de puntero en cierta medida. </p><br><p>  Decimos que Rust es seguro, con la suposici√≥n fundamental de que el c√≥digo inseguro que usamos a trav√©s de nuestras dependencias en la biblioteca est√°ndar o en el c√≥digo de otras bibliotecas est√° correctamente escrito y encapsulado.  La ventaja fundamental de Rust es que el c√≥digo inseguro se convierte en bloques inseguros que deben ser revisados ‚Äã‚Äãcuidadosamente por sus autores. </p><br><p>  En Python, la carga de verificar la seguridad de las manipulaciones de memoria recae solo en los desarrolladores de los int√©rpretes y usuarios de las interfaces de funciones externas.  En C, esta carga recae en cada programador. </p><br><p>  En Rust, se encuentra con los usuarios de la palabra clave insegura.  Esto es obvio, ya que los invariantes deben mantenerse manualmente dentro de dicho c√≥digo y, por lo tanto, es necesario esforzarse por obtener la menor cantidad de dicho c√≥digo en la biblioteca o en el c√≥digo de la aplicaci√≥n.  La inseguridad se detecta, resalta e indica.  Por lo tanto, si se producen fallas seguras en su c√≥digo Rust, entonces encontrar√° un error en el compilador o un error en varias l√≠neas de su c√≥digo inseguro. </p><br><p>  Este no es un sistema perfecto, pero si necesita velocidad, seguridad y multihilo al mismo tiempo, entonces esta es la √∫nica opci√≥n. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460295/">https://habr.com/ru/post/460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460281/index.html">C√≥mo UX Writer ayuda a mejorar el producto</a></li>
<li><a href="../460283/index.html">Nuevo lenguaje de programaci√≥n h√°galo usted mismo</a></li>
<li><a href="../460285/index.html">Estamos preparando PHP. ¬øC√≥mo son while, foreach, array_walk y algunas otras palabras de miedo</a></li>
<li><a href="../460287/index.html">Visualizaci√≥n de noticias runet</a></li>
<li><a href="../460291/index.html">Problemas de procesamiento por lotes de solicitudes y sus soluciones (parte 1)</a></li>
<li><a href="../460297/index.html">WeakRef - propuesta para agregar al est√°ndar ECMAScript</a></li>
<li><a href="../460301/index.html">L√°mparas LED de alta potencia de nueva generaci√≥n.</a></li>
<li><a href="../460305/index.html">AERODISCO Motor: catastr√≥fico. Parte 2. Metrocluster</a></li>
<li><a href="../460307/index.html">Experiencia de modelado del equipo de Computer Vision Mail.ru</a></li>
<li><a href="../460311/index.html">Hora de una nueva teor√≠a del dinero.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>