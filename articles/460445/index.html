<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔻 🦍 👺 Conferencia "Fundamentos del procesamiento de señales digitales" 🤟🏽 🔜 🍆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 A menudo las personas recurren a mí con preguntas sobre tareas del campo del procesamiento de señales digitales (DSP). Cuento en deta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conferencia "Fundamentos del procesamiento de señales digitales"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460445/">  Hola a todos! <br><br>  A menudo las personas recurren a mí con preguntas sobre tareas del campo del procesamiento de señales digitales (DSP).  Cuento en detalle los matices, sugiero las fuentes de información necesarias.  Pero todos los oyentes, como lo ha demostrado el tiempo, carecen de tareas prácticas y ejemplos en el proceso de aprendizaje de esta área.  En este sentido, decidí escribir un breve curso interactivo sobre procesamiento de señales digitales y ponerlo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dominio público</a> . <br><br>  La mayor parte del material de capacitación para la presentación visual e interactiva se implementa utilizando el <i>Jupyter Notebook</i> .  Se supone que el lector tiene un conocimiento básico del campo de las matemáticas superiores, así como un pequeño dominio del lenguaje de programación Python. <br><br><img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2>  Lista de conferencias </h2><br>  Este curso contiene materiales en forma de conferencias terminadas sobre diversos temas del campo del procesamiento de señales digitales.  Los materiales se presentan utilizando bibliotecas de Python (paquetes numpy, scipy, matplotlib, etc.).  La información básica para este curso fue tomada de mis conferencias, que yo, como estudiante graduado, les di a los estudiantes del Instituto de Energía de Moscú (NRU MEI).  Parte de la información de estas conferencias se usó en seminarios de capacitación en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Centro de Electrónica Contemporánea</a> , donde actué como profesor.  Además, este material incluye la traducción de varios artículos científicos, compilación de información de fuentes confiables y literatura sobre procesamiento de señales digitales, así como documentación oficial sobre paquetes de aplicaciones y funciones integradas de las bibliotecas scipy y numpy de Python. <br><br>  Para los usuarios de MATLAB (GNU Octave), dominar el material desde el punto de vista del código del programa no es difícil, ya que las funciones principales y sus atributos son en gran medida idénticos y similares a los métodos de las bibliotecas de Python. <br><br>  Todos los materiales están agrupados por los principales temas del procesamiento de señales digitales: <br><br><ol><li>  Señales: analógicas, discretas, digitales.  Conversión Z </li><li>  Transformada de Fourier: señal de amplitud y fase, DFT y FFT, </li><li>  Convolución y correlación.  Convolución lineal y cíclica.  Convolución rápida </li><li>  Procesos aleatorios.  Ruido blanco  Función de densidad de probabilidad </li><li>  Señales deterministas.  Modulación: AM, FM, FM, LFM.  Manipulación </li><li>  Filtrado de señal: IIR, filtros FIR </li><li>  Funciones de ventana en tareas de filtrado.  Detección de señales débiles. </li><li>  Muestreo: diezmado e interpolación.  Filtros CIC, filtros de media móvil </li></ol><br><br>  La lista de conferencias es suficiente <s>pero, por supuesto, incompleta</s> para un conocimiento introductorio del campo de DSP.  Con tiempo libre, planeo apoyar y desarrollar este proyecto. <br><br><h3>  Donde encontrar </h3><br>  Todos los materiales son <b>absolutamente gratuitos</b> y están disponibles como repositorio abierto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi github como un proyecto de código abierto</a> .  Los materiales se presentan en dos formatos: en forma de cuadernos Jupyter para trabajo interactivo, estudio y edición, y en forma de archivos HTML compilados a partir de estos cuadernos (después de descargarlos de Github tienen un formato bastante adecuado para leer e imprimir). <br><br>  La siguiente es una descripción muy <u>breve</u> de las secciones del curso con explicaciones breves, términos y definiciones.  La información básica está disponible en las conferencias iniciales, ¡aquí hay solo una breve descripción! <br><br><h3>  Señales  Conversión Z </h3><br>  Sección introductoria, que contiene información básica sobre los tipos de señales.  Se introduce el concepto de secuencia discreta, función delta y función Heaviside (salto de unidad). <br><br>  Todas las señales de acuerdo con el método de presentación en el conjunto se pueden dividir en cuatro grupos: <br><ul><li>  analógico: se describen mediante funciones continuas en el tiempo, </li><li>  discreto: se interrumpe a tiempo con un paso especificado por muestreo, </li><li>  cuantizado: tener un conjunto de niveles finitos (generalmente en amplitud), </li><li>  digital: una combinación de las propiedades de las señales discretas y cuantificadas. </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="Señales"><br><br>  Para la reconstrucción correcta de una señal analógica de una señal digital sin distorsión y pérdida, se utiliza el teorema de muestreo conocido como el teorema de <b>Kotelnikov (Nyquist-Shannon)</b> . <br><blockquote>  Cualquier señal continua con un espectro limitado puede restaurarse de manera única y sin pérdida por sus muestras discretas tomadas con una frecuencia estrictamente mayor que el doble de la frecuencia superior del espectro de una señal continua. </blockquote><br>  Tal interpretación es válida siempre que la función continua del tiempo ocupe una banda de frecuencia de 0 al valor de la frecuencia superior.  Si los pasos de cuantización y discretización se eligen incorrectamente, la señal se distorsionará de analógica a discreta. <br><br>  También en esta sección, se describe la <b>transformación Z</b> y sus propiedades, y se muestra la representación de secuencias discretas en la forma Z. <br><br>  Ejemplo de una secuencia discreta finita: <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  . <br>  Un ejemplo de la misma secuencia en forma de Z: <br><br>  X (z) = 2 + z <sup>-1</sup> - 2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3>  Transformada de Fourier.  Propiedades  DFT y FFT </h3><br>  Esta sección describe el concepto del dominio de tiempo y frecuencia de una señal.  Se introduce la definición de la transformada discreta de Fourier (DFT).  Se consideran los DFT directos e inversos y sus propiedades principales.  Se muestra la transición del DFT al algoritmo de transformación rápida de Fourier (FFT) en la base 2 (algoritmos de diezmado en frecuencia y tiempo).  Reflejó la efectividad de FFT en comparación con DFT. <br><br>  En particular, esta sección describe el paquete de Python scipy.ffpack para calcular varias transformadas de Fourier (seno, coseno, directo, inverso, multidimensional, real). <br><br>  ¡La transformación de Fourier le permite representar cualquier función como un conjunto de señales armónicas!  La transformación de Fourier es la base de los métodos de convolución y el diseño de correlacionadores digitales, se usa activamente en el análisis espectral y se usa cuando se trabaja con números largos. <br><br>  Características de los espectros de señales discretas: <br>  1. La densidad espectral de una señal discreta es una función periódica con un período igual a la frecuencia de muestreo. <br>  2. Si la secuencia discreta es <i>real</i> , entonces el módulo de densidad espectral de dicha secuencia es una función <i>par</i> , y el argumento es <i>una</i> función de frecuencia <i>impar</i> . <br><br>  Espectro de señal armónica: <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="FFT para coseno"><br><br><h4>  Comparación de la eficacia de DFT y FFT </h4><br>  La eficiencia del algoritmo FFT y el número de operaciones realizadas linealmente depende de la longitud de secuencia N: <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  N </th><th colspan="2">  DFT </th><th colspan="2">  FFT </th><th rowspan="2">  La relación del número de adiciones complejas </th><th rowspan="2">  La razón del número de multiplicaciones complejas. </th></tr><tr><th>  El número de operaciones de multiplicación. </th><th>  Número de operaciones de suma </th><th>  El número de operaciones de multiplicación. </th><th>  Número de operaciones de suma </th></tr></thead><tbody><tr><td>  2 </td><td>  4 4 </td><td>  2 </td><td>  1 </td><td>  2 </td><td>  4 4 </td><td>  1 </td></tr><tr><td>  4 4 </td><td>  16 </td><td>  12 </td><td>  4 4 </td><td>  8 </td><td>  4 4 </td><td>  1,5 </td></tr><tr><td>  8 </td><td>  64 </td><td>  56 </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  16 </td><td>  256 </td><td>  240 </td><td>  32 </td><td>  64 </td><td>  8 </td><td>  3.75 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12,8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21,3 </td><td>  10,5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36,6 </td><td>  18,1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br>  Como puede ver, cuanto mayor sea la duración de la conversión, mayores serán los ahorros en recursos informáticos (en términos de velocidad de procesamiento o la cantidad de unidades de hardware). <br><br>  Cualquier forma de onda arbitraria puede representarse como un conjunto de señales armónicas de diferentes frecuencias.  En otras palabras, una señal de forma compleja en el dominio del tiempo tiene un conjunto de muestras complejas en el dominio de la frecuencia, que se denominan * armónicos *.  Estas muestras expresan la amplitud y la fase del efecto armónico a una frecuencia específica.  Cuanto mayor es el conjunto de armónicos en el dominio de la frecuencia, más exactamente aparece la forma de onda compleja. <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT Gibbs"><br><br><h3>  Convolución y correlación </h3><br>  Esta sección presenta el concepto de correlación y convolución para secuencias discretas aleatorias y deterministas.  Se muestra la relación entre las funciones de autocorrelación y correlación cruzada con convolución.  Se describen las propiedades de convolución, en particular, se consideran los métodos de convolución lineal y cíclica de una señal discreta con análisis detallado sobre el ejemplo de una secuencia discreta.  Además, se muestra un método para calcular la convolución "rápida" utilizando algoritmos FFT. <br><br>  En problemas reales, a menudo se plantea la cuestión sobre el grado de similitud de un proceso con otro o sobre la independencia de un proceso de otro.  En otras palabras, se requiere determinar la relación entre las señales, es decir, encontrar una <i>correlación</i> .  Los métodos de correlación se utilizan en una amplia gama de tareas: búsqueda de señales, visión por computadora y procesamiento de imágenes, en problemas de radar para determinar las características de los objetivos y determinar la distancia a un objeto.  Además, la correlación se usa para buscar señales débiles en el ruido. <br><br>  <b>La convolución</b> describe la interacción de las señales entre sí.  Si una de las señales es la respuesta al impulso del filtro, entonces la convolución de la secuencia de entrada con la respuesta al impulso no es más que una reacción del circuito a la acción de entrada.  En otras palabras, la señal resultante refleja el paso de la señal a través del filtro. <br><br>  <i>La función de autocorrelación</i> (ACF) se utiliza en la codificación de información.  La elección de la secuencia de codificación de acuerdo con los parámetros de longitud, frecuencia y forma se debe en gran medida a las propiedades de correlación de esta secuencia.  La mejor secuencia de código tiene la menor probabilidad de detección u operación falsa (para detectar señales, para dispositivos de umbral) o sincronización falsa (para transmitir y recibir secuencias de código). <br><br>  Esta sección presenta una tabla que compara la efectividad de la convolución rápida y la convolución calculada por la fórmula directa (por el número de multiplicaciones reales). <br><br>  Como puede ver, para longitudes de FFT de hasta 64, la convolución rápida <u>pierde</u> con el método directo.  Sin embargo, con un aumento en la longitud de FFT, los resultados cambian en la dirección opuesta: una convolución rápida comienza a superar al método directo.  Obviamente, cuanto más larga sea la FFT, mejor será la ganancia en el método de frecuencia. <br><br><div class="scrollable-table"><table><thead><tr><th>  N </th><th>  Convolución </th><th>  Convolución rápida </th><th>  Actitud </th></tr></thead><tbody><tr><td>  8 </td><td>  64 </td><td>  448 </td><td>  0,14 </td></tr><tr><td>  16 </td><td>  256 </td><td>  1088 </td><td>  0.24 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  2560 </td><td>  0.4 0.4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0.7 </td></tr><tr><td>  128 </td><td>  16K </td><td>  13312 </td><td>  1,23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4 millones </td><td>  311296 </td><td>  <b>13,5</b> </td></tr></tbody></table></div><br><h3>  Señales aleatorias y ruido </h3><br>  En esta sección, se introduce el concepto de señales aleatorias, densidad de probabilidad, ley de distribución aleatoria.  Se consideran los momentos matemáticos: media (expectativa matemática) y varianza (o la raíz de esta cantidad es la desviación estándar).  También en esta sección, la distribución normal y el concepto relacionado de <i>ruido blanco</i> se consideran la principal fuente de ruido (interferencia) durante el procesamiento de la señal. <br><br>  <i>Una señal aleatoria</i> es una función del tiempo cuyos valores no se conocen de antemano y solo pueden predecirse con cierta <i>probabilidad</i> .  Las características principales de las señales aleatorias incluyen: <br><br><ul><li>  ley de distribución (el tiempo de residencia relativo del valor de la señal en un cierto intervalo), </li><li>  distribución espectral de potencia de señal. </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="Ruido AWGN"><br><br>  En las tareas DSP, las señales aleatorias se dividen en dos clases: <br><br><ul><li>  ruido: fluctuaciones aleatorias que consisten en un conjunto de diferentes frecuencias y amplitudes, </li><li>  señales que transportan información, para cuyo procesamiento es necesario recurrir a métodos probabilísticos. </li></ul><br><br>  Usando variables aleatorias, podemos simular el efecto de un medio real en el paso de una señal desde una fuente a un receptor de datos.  Cuando una señal pasa a través de algún enlace ruidoso, el llamado ruido blanco se agrega a la señal.  Como regla general, la densidad espectral de dicho ruido se distribuye uniformemente (por igual) en todas las frecuencias, y los valores de ruido en el dominio del tiempo se distribuyen normalmente (ley de distribución gaussiana).  Dado que el ruido blanco se agrega físicamente a las amplitudes de la señal en las muestras de tiempo seleccionadas, se denomina ruido gaussiano blanco aditivo (AWGN). <br><br><h3>  Señales, Modulación y Manipulación </h3><br>  Esta sección muestra los métodos básicos para cambiar uno o más parámetros de una señal armónica.  Se introducen los conceptos de amplitud, frecuencia y modulación de fase.  En particular, se destaca la modulación de frecuencia lineal utilizada en problemas de radar.  Se muestran las principales características de las señales, los espectros de las señales moduladas dependiendo de los parámetros de modulación. <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="Modulación de frecuencia"><br><br>  Por conveniencia, se ha creado un conjunto de funciones en Python que implementa los tipos de modulación anteriores.  Ejemplo de implementación de señal chirp: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="Modulación de chirrido"><br><br>  También en esta sección de la teoría de la transmisión de mensajes discretos se describen tipos de modulación digital: se describen manipulaciones.  Como en el caso de las señales analógicas, las secuencias armónicas digitales se pueden manipular en amplitud, fase y frecuencia (o varios parámetros a la vez). <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="Manipulación de frecuencia"><br><br><h3>  Filtros digitales - IIR y FIR </h3><br>  Una sección suficientemente grande dedicada al filtrado digital de secuencias discretas.  En las tareas de procesamiento de señal digital, los datos fluyen a través de circuitos llamados <b>filtros</b> .  Los filtros digitales, como los analógicos, tienen diferentes características: frecuencia: respuesta de frecuencia, respuesta de fase, tiempo: respuesta de impulso, así como la característica de transferencia del filtro.  Los filtros digitales se utilizan principalmente para mejorar la calidad de la señal, para aislar una señal de una secuencia de datos o para degradar señales no deseadas, para suprimir ciertas señales en las secuencias de muestras entrantes. <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="Señales FIR IIR"><br><br>  La sección enumera las principales ventajas y desventajas de los filtros digitales (en comparación con los analógicos).  Se introduce el concepto de impulso y características de transferencia del filtro.  Se consideran dos clases de filtros: con una respuesta de impulso infinita (IIR) y una respuesta de impulso finita (FIR).  Se muestra un método para diseñar filtros en forma <b>canónica</b> y <b>directa</b> .  Para los filtros FIR, se considera la cuestión de cómo cambiar a una forma recursiva. <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="Esquema IIR FIR"><br><br>  Para los filtros FIR, el proceso de diseño del filtro se muestra desde la etapa de desarrollo de las especificaciones técnicas (con los parámetros principales indicados), hasta la implementación de software y hardware: busque los coeficientes del filtro (teniendo en cuenta la forma de representación del número, profundidad de bits, etc.).  Se introducen las definiciones de filtros FIR simétricos, la respuesta de fase lineal y su relación con el concepto de retraso grupal. <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="FIR camino completo"><br><br><h3>  Funciones de ventana en tareas de filtrado </h3><br>  En las tareas de procesamiento de señal digital, se utilizan funciones de ventana de varias formas que, cuando se superponen a una señal en el dominio del tiempo, pueden mejorar cualitativamente sus características espectrales.  Una gran cantidad de varias ventanas se debe principalmente a una de las características principales de cualquier superposición de ventanas.  Esta característica se expresa en la relación entre el nivel de los lóbulos laterales y el ancho del lóbulo central.  Regla: <br><blockquote>  Cuanto más fuerte es la supresión de los lóbulos laterales del espectro, más ancho es el lóbulo principal del espectro y viceversa. </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="Victorias (tiempo)"><br><br>  Una de las aplicaciones de las funciones de ventana: detección de señales débiles en el contexto de las más fuertes al suprimir el nivel de los lóbulos laterales.  Las funciones de la ventana principal en las tareas de DSP son ** triangular, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, ventana Blackman-Harris, ventana plana, ventana Natall, Gauss, Kaiser ** y muchas otras.  La mayoría de ellos se expresan a través de una serie finita sumando señales armónicas con pesos específicos.  Dichas señales se implementan perfectamente en la práctica en cualquier dispositivo de hardware (circuitos lógicos programables o procesadores de señal). <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="Victorias (frecuencia)"><br><br><h3>  Muestreo  Decimación e interpolación </h3><br>  En esta sección se analizan los problemas del procesamiento de señales de varias velocidades: cambios en la frecuencia de muestreo.  El procesamiento de señales a múltiples velocidades (procesamiento de múltiples velocidades) sugiere que en el proceso de conversión lineal de señales digitales, es posible cambiar la frecuencia de muestreo en la dirección de disminución o aumento, o en un número fraccionario de veces.  Esto conduce a un procesamiento de señal más eficiente, ya que abre la posibilidad de utilizar las frecuencias de muestreo mínimas permitidas y, como resultado, una reducción significativa en el rendimiento informático requerido del sistema digital diseñado. <br><br>  <i>Decimación</i> (decimación): disminución de la resolución.  <i>Interpolación</i> : aumento de la frecuencia de muestreo. <br><br>  La sección también considera la clase de filtros FIR homogéneos, que se denominan filtros de peine integral (CIC, integrador en cascada - peine).  Se muestran la implementación, las propiedades básicas y las características de los filtros CIC.  Debido a la linealidad de las operaciones matemáticas que ocurren en el filtro CIC, es posible conectar en cascada varios filtros en una fila, lo que da una disminución proporcional en el nivel de los lóbulos laterales, pero también aumenta el "bloqueo" del lóbulo principal de la característica de amplitud-frecuencia. <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="Filtro cic en cascada"><br><br>  Gráfico de la respuesta de frecuencia del filtro según el coeficiente de diezmado: <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="Respuesta de frecuencia de CIC"><br><br>  También en esta sección discutimos el problema de aumentar la profundidad de bits de los datos en la salida del filtro CIC, dependiendo de sus parámetros.  Esto es especialmente importante en las tareas de implementación de software, en particular en FPGA. <br><br>  Para la implementación práctica de filtros CIC en Python, <b>se ha desarrollado</b> una clase separada <b>CicFilter</b> que implementa métodos de diezmado e interpolación.  También se muestran cambios en la frecuencia de muestreo utilizando los métodos integrados del paquete scipy Python. <br><br><div class="spoiler">  <b class="spoiler_title">Clase Python CicFilter para procesamiento de señal digital</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="Decimación / Interpolación CIC"><br><br>  Finalmente, esta sección proporciona una clase especial de filtros: el promedio móvil.  Se muestran tres métodos de implementación: mediante convolución de señales, utilizando un filtro FIR y un filtro IIR. <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF, filtro de media móvil"><br><br><h3>  Conclusión </h3><br>  Espero que este curso en conjunto con mis artículos anteriores sobre el procesamiento digital de señales FPGA brinde beneficios prácticos y ayude al lector a comprender mejor los conceptos básicos del procesamiento digital de señales.  Este proyecto será mejorado y complementado con nuevo material útil y no menos interesante.  Sigue el desarrollo! <br><br>  Además de este material, apoyo y desarrollo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi proyecto</a> en los principales módulos DSP (en Python).  Contiene un paquete para generar varias señales, una clase de filtros CIC para problemas de decimación e interpolación, un algoritmo para calcular los coeficientes de un filtro FIR corrector, un filtro de promedio móvil, un algoritmo para calcular una FFT ultra larga a través de métodos de conversión bidimensionales (este último fue muy útil cuando se trabajaba con implementación de hardware en FPGA) . <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460445/">https://habr.com/ru/post/460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460451/index.html">El hombre hizo su tercer oído para que lo use todo el mundo, por el bien del arte</a></li>
<li><a href="../460453/index.html">Impresora inteligente Mejorando Octoprint</a></li>
<li><a href="../460457/index.html">Estación de energía solar de bricolaje 200 m2</a></li>
<li><a href="../460459/index.html">Archivo de configuración htaccess</a></li>
<li><a href="../460461/index.html">Simulación de ataques dirigidos como una evaluación de seguridad. Instrucciones cibernéticas de Teaming rojo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>