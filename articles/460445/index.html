<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游댵 游붌 游놐 Conferencia "Fundamentos del procesamiento de se침ales digitales" 游游낗 游댚 游꼕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 A menudo las personas recurren a m칤 con preguntas sobre tareas del campo del procesamiento de se침ales digitales (DSP). Cuento en deta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conferencia "Fundamentos del procesamiento de se침ales digitales"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460445/">  Hola a todos! <br><br>  A menudo las personas recurren a m칤 con preguntas sobre tareas del campo del procesamiento de se침ales digitales (DSP).  Cuento en detalle los matices, sugiero las fuentes de informaci칩n necesarias.  Pero todos los oyentes, como lo ha demostrado el tiempo, carecen de tareas pr치cticas y ejemplos en el proceso de aprendizaje de esta 치rea.  En este sentido, decid칤 escribir un breve curso interactivo sobre procesamiento de se침ales digitales y ponerlo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dominio p칰blico</a> . <br><br>  La mayor parte del material de capacitaci칩n para la presentaci칩n visual e interactiva se implementa utilizando el <i>Jupyter Notebook</i> .  Se supone que el lector tiene un conocimiento b치sico del campo de las matem치ticas superiores, as칤 como un peque침o dominio del lenguaje de programaci칩n Python. <br><br><img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2>  Lista de conferencias </h2><br>  Este curso contiene materiales en forma de conferencias terminadas sobre diversos temas del campo del procesamiento de se침ales digitales.  Los materiales se presentan utilizando bibliotecas de Python (paquetes numpy, scipy, matplotlib, etc.).  La informaci칩n b치sica para este curso fue tomada de mis conferencias, que yo, como estudiante graduado, les di a los estudiantes del Instituto de Energ칤a de Mosc칰 (NRU MEI).  Parte de la informaci칩n de estas conferencias se us칩 en seminarios de capacitaci칩n en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Centro de Electr칩nica Contempor치nea</a> , donde actu칠 como profesor.  Adem치s, este material incluye la traducci칩n de varios art칤culos cient칤ficos, compilaci칩n de informaci칩n de fuentes confiables y literatura sobre procesamiento de se침ales digitales, as칤 como documentaci칩n oficial sobre paquetes de aplicaciones y funciones integradas de las bibliotecas scipy y numpy de Python. <br><br>  Para los usuarios de MATLAB (GNU Octave), dominar el material desde el punto de vista del c칩digo del programa no es dif칤cil, ya que las funciones principales y sus atributos son en gran medida id칠nticos y similares a los m칠todos de las bibliotecas de Python. <br><br>  Todos los materiales est치n agrupados por los principales temas del procesamiento de se침ales digitales: <br><br><ol><li>  Se침ales: anal칩gicas, discretas, digitales.  Conversi칩n Z </li><li>  Transformada de Fourier: se침al de amplitud y fase, DFT y FFT, </li><li>  Convoluci칩n y correlaci칩n.  Convoluci칩n lineal y c칤clica.  Convoluci칩n r치pida </li><li>  Procesos aleatorios.  Ruido blanco  Funci칩n de densidad de probabilidad </li><li>  Se침ales deterministas.  Modulaci칩n: AM, FM, FM, LFM.  Manipulaci칩n </li><li>  Filtrado de se침al: IIR, filtros FIR </li><li>  Funciones de ventana en tareas de filtrado.  Detecci칩n de se침ales d칠biles. </li><li>  Muestreo: diezmado e interpolaci칩n.  Filtros CIC, filtros de media m칩vil </li></ol><br><br>  La lista de conferencias es suficiente <s>pero, por supuesto, incompleta</s> para un conocimiento introductorio del campo de DSP.  Con tiempo libre, planeo apoyar y desarrollar este proyecto. <br><br><h3>  Donde encontrar </h3><br>  Todos los materiales son <b>absolutamente gratuitos</b> y est치n disponibles como repositorio abierto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi github como un proyecto de c칩digo abierto</a> .  Los materiales se presentan en dos formatos: en forma de cuadernos Jupyter para trabajo interactivo, estudio y edici칩n, y en forma de archivos HTML compilados a partir de estos cuadernos (despu칠s de descargarlos de Github tienen un formato bastante adecuado para leer e imprimir). <br><br>  La siguiente es una descripci칩n muy <u>breve</u> de las secciones del curso con explicaciones breves, t칠rminos y definiciones.  La informaci칩n b치sica est치 disponible en las conferencias iniciales, 춰aqu칤 hay solo una breve descripci칩n! <br><br><h3>  Se침ales  Conversi칩n Z </h3><br>  Secci칩n introductoria, que contiene informaci칩n b치sica sobre los tipos de se침ales.  Se introduce el concepto de secuencia discreta, funci칩n delta y funci칩n Heaviside (salto de unidad). <br><br>  Todas las se침ales de acuerdo con el m칠todo de presentaci칩n en el conjunto se pueden dividir en cuatro grupos: <br><ul><li>  anal칩gico: se describen mediante funciones continuas en el tiempo, </li><li>  discreto: se interrumpe a tiempo con un paso especificado por muestreo, </li><li>  cuantizado: tener un conjunto de niveles finitos (generalmente en amplitud), </li><li>  digital: una combinaci칩n de las propiedades de las se침ales discretas y cuantificadas. </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="Se침ales"><br><br>  Para la reconstrucci칩n correcta de una se침al anal칩gica de una se침al digital sin distorsi칩n y p칠rdida, se utiliza el teorema de muestreo conocido como el teorema de <b>Kotelnikov (Nyquist-Shannon)</b> . <br><blockquote>  Cualquier se침al continua con un espectro limitado puede restaurarse de manera 칰nica y sin p칠rdida por sus muestras discretas tomadas con una frecuencia estrictamente mayor que el doble de la frecuencia superior del espectro de una se침al continua. </blockquote><br>  Tal interpretaci칩n es v치lida siempre que la funci칩n continua del tiempo ocupe una banda de frecuencia de 0 al valor de la frecuencia superior.  Si los pasos de cuantizaci칩n y discretizaci칩n se eligen incorrectamente, la se침al se distorsionar치 de anal칩gica a discreta. <br><br>  Tambi칠n en esta secci칩n, se describe la <b>transformaci칩n Z</b> y sus propiedades, y se muestra la representaci칩n de secuencias discretas en la forma Z. <br><br>  Ejemplo de una secuencia discreta finita: <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  . <br>  Un ejemplo de la misma secuencia en forma de Z: <br><br>  X (z) = 2 + z <sup>-1</sup> - 2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3>  Transformada de Fourier.  Propiedades  DFT y FFT </h3><br>  Esta secci칩n describe el concepto del dominio de tiempo y frecuencia de una se침al.  Se introduce la definici칩n de la transformada discreta de Fourier (DFT).  Se consideran los DFT directos e inversos y sus propiedades principales.  Se muestra la transici칩n del DFT al algoritmo de transformaci칩n r치pida de Fourier (FFT) en la base 2 (algoritmos de diezmado en frecuencia y tiempo).  Reflej칩 la efectividad de FFT en comparaci칩n con DFT. <br><br>  En particular, esta secci칩n describe el paquete de Python scipy.ffpack para calcular varias transformadas de Fourier (seno, coseno, directo, inverso, multidimensional, real). <br><br>  춰La transformaci칩n de Fourier le permite representar cualquier funci칩n como un conjunto de se침ales arm칩nicas!  La transformaci칩n de Fourier es la base de los m칠todos de convoluci칩n y el dise침o de correlacionadores digitales, se usa activamente en el an치lisis espectral y se usa cuando se trabaja con n칰meros largos. <br><br>  Caracter칤sticas de los espectros de se침ales discretas: <br>  1. La densidad espectral de una se침al discreta es una funci칩n peri칩dica con un per칤odo igual a la frecuencia de muestreo. <br>  2. Si la secuencia discreta es <i>real</i> , entonces el m칩dulo de densidad espectral de dicha secuencia es una funci칩n <i>par</i> , y el argumento es <i>una</i> funci칩n de frecuencia <i>impar</i> . <br><br>  Espectro de se침al arm칩nica: <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="FFT para coseno"><br><br><h4>  Comparaci칩n de la eficacia de DFT y FFT </h4><br>  La eficiencia del algoritmo FFT y el n칰mero de operaciones realizadas linealmente depende de la longitud de secuencia N: <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  N </th><th colspan="2">  DFT </th><th colspan="2">  FFT </th><th rowspan="2">  La relaci칩n del n칰mero de adiciones complejas </th><th rowspan="2">  La raz칩n del n칰mero de multiplicaciones complejas. </th></tr><tr><th>  El n칰mero de operaciones de multiplicaci칩n. </th><th>  N칰mero de operaciones de suma </th><th>  El n칰mero de operaciones de multiplicaci칩n. </th><th>  N칰mero de operaciones de suma </th></tr></thead><tbody><tr><td>  2 </td><td>  4 4 </td><td>  2 </td><td>  1 </td><td>  2 </td><td>  4 4 </td><td>  1 </td></tr><tr><td>  4 4 </td><td>  16 </td><td>  12 </td><td>  4 4 </td><td>  8 </td><td>  4 4 </td><td>  1,5 </td></tr><tr><td>  8 </td><td>  64 </td><td>  56 </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  16 </td><td>  256 </td><td>  240 </td><td>  32 </td><td>  64 </td><td>  8 </td><td>  3.75 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12,8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21,3 </td><td>  10,5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36,6 </td><td>  18,1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br>  Como puede ver, cuanto mayor sea la duraci칩n de la conversi칩n, mayores ser치n los ahorros en recursos inform치ticos (en t칠rminos de velocidad de procesamiento o la cantidad de unidades de hardware). <br><br>  Cualquier forma de onda arbitraria puede representarse como un conjunto de se침ales arm칩nicas de diferentes frecuencias.  En otras palabras, una se침al de forma compleja en el dominio del tiempo tiene un conjunto de muestras complejas en el dominio de la frecuencia, que se denominan * arm칩nicos *.  Estas muestras expresan la amplitud y la fase del efecto arm칩nico a una frecuencia espec칤fica.  Cuanto mayor es el conjunto de arm칩nicos en el dominio de la frecuencia, m치s exactamente aparece la forma de onda compleja. <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT Gibbs"><br><br><h3>  Convoluci칩n y correlaci칩n </h3><br>  Esta secci칩n presenta el concepto de correlaci칩n y convoluci칩n para secuencias discretas aleatorias y deterministas.  Se muestra la relaci칩n entre las funciones de autocorrelaci칩n y correlaci칩n cruzada con convoluci칩n.  Se describen las propiedades de convoluci칩n, en particular, se consideran los m칠todos de convoluci칩n lineal y c칤clica de una se침al discreta con an치lisis detallado sobre el ejemplo de una secuencia discreta.  Adem치s, se muestra un m칠todo para calcular la convoluci칩n "r치pida" utilizando algoritmos FFT. <br><br>  En problemas reales, a menudo se plantea la cuesti칩n sobre el grado de similitud de un proceso con otro o sobre la independencia de un proceso de otro.  En otras palabras, se requiere determinar la relaci칩n entre las se침ales, es decir, encontrar una <i>correlaci칩n</i> .  Los m칠todos de correlaci칩n se utilizan en una amplia gama de tareas: b칰squeda de se침ales, visi칩n por computadora y procesamiento de im치genes, en problemas de radar para determinar las caracter칤sticas de los objetivos y determinar la distancia a un objeto.  Adem치s, la correlaci칩n se usa para buscar se침ales d칠biles en el ruido. <br><br>  <b>La convoluci칩n</b> describe la interacci칩n de las se침ales entre s칤.  Si una de las se침ales es la respuesta al impulso del filtro, entonces la convoluci칩n de la secuencia de entrada con la respuesta al impulso no es m치s que una reacci칩n del circuito a la acci칩n de entrada.  En otras palabras, la se침al resultante refleja el paso de la se침al a trav칠s del filtro. <br><br>  <i>La funci칩n de autocorrelaci칩n</i> (ACF) se utiliza en la codificaci칩n de informaci칩n.  La elecci칩n de la secuencia de codificaci칩n de acuerdo con los par치metros de longitud, frecuencia y forma se debe en gran medida a las propiedades de correlaci칩n de esta secuencia.  La mejor secuencia de c칩digo tiene la menor probabilidad de detecci칩n u operaci칩n falsa (para detectar se침ales, para dispositivos de umbral) o sincronizaci칩n falsa (para transmitir y recibir secuencias de c칩digo). <br><br>  Esta secci칩n presenta una tabla que compara la efectividad de la convoluci칩n r치pida y la convoluci칩n calculada por la f칩rmula directa (por el n칰mero de multiplicaciones reales). <br><br>  Como puede ver, para longitudes de FFT de hasta 64, la convoluci칩n r치pida <u>pierde</u> con el m칠todo directo.  Sin embargo, con un aumento en la longitud de FFT, los resultados cambian en la direcci칩n opuesta: una convoluci칩n r치pida comienza a superar al m칠todo directo.  Obviamente, cuanto m치s larga sea la FFT, mejor ser치 la ganancia en el m칠todo de frecuencia. <br><br><div class="scrollable-table"><table><thead><tr><th>  N </th><th>  Convoluci칩n </th><th>  Convoluci칩n r치pida </th><th>  Actitud </th></tr></thead><tbody><tr><td>  8 </td><td>  64 </td><td>  448 </td><td>  0,14 </td></tr><tr><td>  16 </td><td>  256 </td><td>  1088 </td><td>  0.24 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  2560 </td><td>  0.4 0.4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0.7 </td></tr><tr><td>  128 </td><td>  16K </td><td>  13312 </td><td>  1,23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4 millones </td><td>  311296 </td><td>  <b>13,5</b> </td></tr></tbody></table></div><br><h3>  Se침ales aleatorias y ruido </h3><br>  En esta secci칩n, se introduce el concepto de se침ales aleatorias, densidad de probabilidad, ley de distribuci칩n aleatoria.  Se consideran los momentos matem치ticos: media (expectativa matem치tica) y varianza (o la ra칤z de esta cantidad es la desviaci칩n est치ndar).  Tambi칠n en esta secci칩n, la distribuci칩n normal y el concepto relacionado de <i>ruido blanco</i> se consideran la principal fuente de ruido (interferencia) durante el procesamiento de la se침al. <br><br>  <i>Una se침al aleatoria</i> es una funci칩n del tiempo cuyos valores no se conocen de antemano y solo pueden predecirse con cierta <i>probabilidad</i> .  Las caracter칤sticas principales de las se침ales aleatorias incluyen: <br><br><ul><li>  ley de distribuci칩n (el tiempo de residencia relativo del valor de la se침al en un cierto intervalo), </li><li>  distribuci칩n espectral de potencia de se침al. </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="Ruido AWGN"><br><br>  En las tareas DSP, las se침ales aleatorias se dividen en dos clases: <br><br><ul><li>  ruido: fluctuaciones aleatorias que consisten en un conjunto de diferentes frecuencias y amplitudes, </li><li>  se침ales que transportan informaci칩n, para cuyo procesamiento es necesario recurrir a m칠todos probabil칤sticos. </li></ul><br><br>  Usando variables aleatorias, podemos simular el efecto de un medio real en el paso de una se침al desde una fuente a un receptor de datos.  Cuando una se침al pasa a trav칠s de alg칰n enlace ruidoso, el llamado ruido blanco se agrega a la se침al.  Como regla general, la densidad espectral de dicho ruido se distribuye uniformemente (por igual) en todas las frecuencias, y los valores de ruido en el dominio del tiempo se distribuyen normalmente (ley de distribuci칩n gaussiana).  Dado que el ruido blanco se agrega f칤sicamente a las amplitudes de la se침al en las muestras de tiempo seleccionadas, se denomina ruido gaussiano blanco aditivo (AWGN). <br><br><h3>  Se침ales, Modulaci칩n y Manipulaci칩n </h3><br>  Esta secci칩n muestra los m칠todos b치sicos para cambiar uno o m치s par치metros de una se침al arm칩nica.  Se introducen los conceptos de amplitud, frecuencia y modulaci칩n de fase.  En particular, se destaca la modulaci칩n de frecuencia lineal utilizada en problemas de radar.  Se muestran las principales caracter칤sticas de las se침ales, los espectros de las se침ales moduladas dependiendo de los par치metros de modulaci칩n. <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="Modulaci칩n de frecuencia"><br><br>  Por conveniencia, se ha creado un conjunto de funciones en Python que implementa los tipos de modulaci칩n anteriores.  Ejemplo de implementaci칩n de se침al chirp: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="Modulaci칩n de chirrido"><br><br>  Tambi칠n en esta secci칩n de la teor칤a de la transmisi칩n de mensajes discretos se describen tipos de modulaci칩n digital: se describen manipulaciones.  Como en el caso de las se침ales anal칩gicas, las secuencias arm칩nicas digitales se pueden manipular en amplitud, fase y frecuencia (o varios par치metros a la vez). <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="Manipulaci칩n de frecuencia"><br><br><h3>  Filtros digitales - IIR y FIR </h3><br>  Una secci칩n suficientemente grande dedicada al filtrado digital de secuencias discretas.  En las tareas de procesamiento de se침al digital, los datos fluyen a trav칠s de circuitos llamados <b>filtros</b> .  Los filtros digitales, como los anal칩gicos, tienen diferentes caracter칤sticas: frecuencia: respuesta de frecuencia, respuesta de fase, tiempo: respuesta de impulso, as칤 como la caracter칤stica de transferencia del filtro.  Los filtros digitales se utilizan principalmente para mejorar la calidad de la se침al, para aislar una se침al de una secuencia de datos o para degradar se침ales no deseadas, para suprimir ciertas se침ales en las secuencias de muestras entrantes. <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="Se침ales FIR IIR"><br><br>  La secci칩n enumera las principales ventajas y desventajas de los filtros digitales (en comparaci칩n con los anal칩gicos).  Se introduce el concepto de impulso y caracter칤sticas de transferencia del filtro.  Se consideran dos clases de filtros: con una respuesta de impulso infinita (IIR) y una respuesta de impulso finita (FIR).  Se muestra un m칠todo para dise침ar filtros en forma <b>can칩nica</b> y <b>directa</b> .  Para los filtros FIR, se considera la cuesti칩n de c칩mo cambiar a una forma recursiva. <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="Esquema IIR FIR"><br><br>  Para los filtros FIR, el proceso de dise침o del filtro se muestra desde la etapa de desarrollo de las especificaciones t칠cnicas (con los par치metros principales indicados), hasta la implementaci칩n de software y hardware: busque los coeficientes del filtro (teniendo en cuenta la forma de representaci칩n del n칰mero, profundidad de bits, etc.).  Se introducen las definiciones de filtros FIR sim칠tricos, la respuesta de fase lineal y su relaci칩n con el concepto de retraso grupal. <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="FIR camino completo"><br><br><h3>  Funciones de ventana en tareas de filtrado </h3><br>  En las tareas de procesamiento de se침al digital, se utilizan funciones de ventana de varias formas que, cuando se superponen a una se침al en el dominio del tiempo, pueden mejorar cualitativamente sus caracter칤sticas espectrales.  Una gran cantidad de varias ventanas se debe principalmente a una de las caracter칤sticas principales de cualquier superposici칩n de ventanas.  Esta caracter칤stica se expresa en la relaci칩n entre el nivel de los l칩bulos laterales y el ancho del l칩bulo central.  Regla: <br><blockquote>  Cuanto m치s fuerte es la supresi칩n de los l칩bulos laterales del espectro, m치s ancho es el l칩bulo principal del espectro y viceversa. </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="Victorias (tiempo)"><br><br>  Una de las aplicaciones de las funciones de ventana: detecci칩n de se침ales d칠biles en el contexto de las m치s fuertes al suprimir el nivel de los l칩bulos laterales.  Las funciones de la ventana principal en las tareas de DSP son ** triangular, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, ventana Blackman-Harris, ventana plana, ventana Natall, Gauss, Kaiser ** y muchas otras.  La mayor칤a de ellos se expresan a trav칠s de una serie finita sumando se침ales arm칩nicas con pesos espec칤ficos.  Dichas se침ales se implementan perfectamente en la pr치ctica en cualquier dispositivo de hardware (circuitos l칩gicos programables o procesadores de se침al). <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="Victorias (frecuencia)"><br><br><h3>  Muestreo  Decimaci칩n e interpolaci칩n </h3><br>  En esta secci칩n se analizan los problemas del procesamiento de se침ales de varias velocidades: cambios en la frecuencia de muestreo.  El procesamiento de se침ales a m칰ltiples velocidades (procesamiento de m칰ltiples velocidades) sugiere que en el proceso de conversi칩n lineal de se침ales digitales, es posible cambiar la frecuencia de muestreo en la direcci칩n de disminuci칩n o aumento, o en un n칰mero fraccionario de veces.  Esto conduce a un procesamiento de se침al m치s eficiente, ya que abre la posibilidad de utilizar las frecuencias de muestreo m칤nimas permitidas y, como resultado, una reducci칩n significativa en el rendimiento inform치tico requerido del sistema digital dise침ado. <br><br>  <i>Decimaci칩n</i> (decimaci칩n): disminuci칩n de la resoluci칩n.  <i>Interpolaci칩n</i> : aumento de la frecuencia de muestreo. <br><br>  La secci칩n tambi칠n considera la clase de filtros FIR homog칠neos, que se denominan filtros de peine integral (CIC, integrador en cascada - peine).  Se muestran la implementaci칩n, las propiedades b치sicas y las caracter칤sticas de los filtros CIC.  Debido a la linealidad de las operaciones matem치ticas que ocurren en el filtro CIC, es posible conectar en cascada varios filtros en una fila, lo que da una disminuci칩n proporcional en el nivel de los l칩bulos laterales, pero tambi칠n aumenta el "bloqueo" del l칩bulo principal de la caracter칤stica de amplitud-frecuencia. <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="Filtro cic en cascada"><br><br>  Gr치fico de la respuesta de frecuencia del filtro seg칰n el coeficiente de diezmado: <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="Respuesta de frecuencia de CIC"><br><br>  Tambi칠n en esta secci칩n discutimos el problema de aumentar la profundidad de bits de los datos en la salida del filtro CIC, dependiendo de sus par치metros.  Esto es especialmente importante en las tareas de implementaci칩n de software, en particular en FPGA. <br><br>  Para la implementaci칩n pr치ctica de filtros CIC en Python, <b>se ha desarrollado</b> una clase separada <b>CicFilter</b> que implementa m칠todos de diezmado e interpolaci칩n.  Tambi칠n se muestran cambios en la frecuencia de muestreo utilizando los m칠todos integrados del paquete scipy Python. <br><br><div class="spoiler">  <b class="spoiler_title">Clase Python CicFilter para procesamiento de se침al digital</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="Decimaci칩n / Interpolaci칩n CIC"><br><br>  Finalmente, esta secci칩n proporciona una clase especial de filtros: el promedio m칩vil.  Se muestran tres m칠todos de implementaci칩n: mediante convoluci칩n de se침ales, utilizando un filtro FIR y un filtro IIR. <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF, filtro de media m칩vil"><br><br><h3>  Conclusi칩n </h3><br>  Espero que este curso en conjunto con mis art칤culos anteriores sobre el procesamiento digital de se침ales FPGA brinde beneficios pr치cticos y ayude al lector a comprender mejor los conceptos b치sicos del procesamiento digital de se침ales.  Este proyecto ser치 mejorado y complementado con nuevo material 칰til y no menos interesante.  Sigue el desarrollo! <br><br>  Adem치s de este material, apoyo y desarrollo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi proyecto</a> en los principales m칩dulos DSP (en Python).  Contiene un paquete para generar varias se침ales, una clase de filtros CIC para problemas de decimaci칩n e interpolaci칩n, un algoritmo para calcular los coeficientes de un filtro FIR corrector, un filtro de promedio m칩vil, un algoritmo para calcular una FFT ultra larga a trav칠s de m칠todos de conversi칩n bidimensionales (este 칰ltimo fue muy 칰til cuando se trabajaba con implementaci칩n de hardware en FPGA) . <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460445/">https://habr.com/ru/post/460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460451/index.html">El hombre hizo su tercer o칤do para que lo use todo el mundo, por el bien del arte</a></li>
<li><a href="../460453/index.html">Impresora inteligente Mejorando Octoprint</a></li>
<li><a href="../460457/index.html">Estaci칩n de energ칤a solar de bricolaje 200 m2</a></li>
<li><a href="../460459/index.html">Archivo de configuraci칩n htaccess</a></li>
<li><a href="../460461/index.html">Simulaci칩n de ataques dirigidos como una evaluaci칩n de seguridad. Instrucciones cibern칠ticas de Teaming rojo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>