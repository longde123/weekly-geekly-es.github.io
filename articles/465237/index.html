<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêë üî¨ üèåÔ∏è Conversi√≥n s√≥lida de malla poligonal a B-Rep: detalles de algoritmo y muestras de c√≥digo C ++ ü•á üöå üöâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La representaci√≥n de l√≠mites (B-rep) es el m√©todo principal para representar objetos modelados en la mayor√≠a de los n√∫cleos geom√©tricos, incluido nues...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conversi√≥n s√≥lida de malla poligonal a B-Rep: detalles de algoritmo y muestras de c√≥digo C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465237/"> La representaci√≥n de l√≠mites (B-rep) es el m√©todo principal para representar objetos modelados en la mayor√≠a de los n√∫cleos geom√©tricos, incluido nuestro n√∫cleo C3D Modeler.  Los algoritmos centrales que editan modelos, como la aplicaci√≥n de operaciones de filete, la realizaci√≥n de operaciones de corte y la obtenci√≥n de proyecciones planas requieren la precisi√≥n de las representaciones B-rep.  La creciente variedad de datos 3D en formatos poligonales hace que la tarea de transformaci√≥n de modelos de pol√≠gonos en representaci√≥n de l√≠mites sea cada vez m√°s relevante.  Como resultado, desarrollamos un nuevo SDK, C3D B-Shaper, que forma parte de nuestro kit de herramientas C3D. <br><br><img src="https://habrastorage.org/webt/jt/2y/jv/jt2yjvnxfahxck-a1poawxfx8vc.png" alt="imagen"><br><a name="habracut"></a><br>  Usar un algoritmo de triangulaci√≥n (conocido como teselaci√≥n) en la representaci√≥n de l√≠mites de un modelo es relativamente f√°cil.  Construir representaciones poligonales (teseladas) es √∫til para fines de visualizaci√≥n y para hacer c√°lculos geom√©tricos. <br><br>  La transformaci√≥n inversa, desde la representaci√≥n poligonal hasta la repetici√≥n B, enfrenta, sin embargo, una serie de problemas relacionados con la complejidad en el reconocimiento de diferentes tipos de superficies, incluidas las de forma libre.  Adem√°s, existe el problema del ruido en los modelos poligonales que aparecen t√≠picamente como resultado del escaneo 3D. <br><br>  El proceso general mediante el cual C3D B-Shaper transforma modelos de formatos poligonales a B-rep consta de tres etapas: segmentaci√≥n, reconstrucci√≥n de superficies y construcci√≥n del modelo b-rep.  El proceso de transformaci√≥n es iterativo: si los usuarios no est√°n contentos con los resultados, se pueden hacer correcciones durante las etapas de segmentaci√≥n y reconstrucci√≥n de la superficie. <br><br><img src="https://habrastorage.org/webt/qx/wf/jp/qxwfjpqgfavnukkhjusspnjdzjg.png" alt="imagen"><br>  <i>Transformando una representaci√≥n poligonal en una B-rep</i> <br><br>  Sin embargo, antes de iniciar el proceso de transformaci√≥n b-rep, mejoramos la calidad de la malla poligonal fuente mediante la aplicaci√≥n de las siguientes soluciones: coordinar las direcciones de las normales en los pol√≠gonos adyacentes;  eliminar agujeros;  y aplique algoritmos de suavizado a fuentes de malla ruidosas, si las hay. <br><br><h1>  <font color="#00B2FF">Segmentaci√≥n del modelo poligonal.</font> </h1><br>  La primera etapa de transformaci√≥n es segmentar el modelo poligonal.  Clasificamos el pol√≠gono de malla en subconjuntos (segmentos).  La informaci√≥n sobre las normales en cada v√©rtice de malla permite realizar una segmentaci√≥n de primer orden y luego realizar la divisi√≥n de malla inicial, as√≠ como clasificar √°reas como planas o altamente curvas.  La divisi√≥n inicial de la malla se basa en la definici√≥n de bordes "afilados".  Estos son los bordes entre dos pol√≠gonos triangulares donde el √°ngulo entre sus normales promedio excede un valor predefinido. <br><br>  Una segmentaci√≥n de segundo orden analiza la malla en funci√≥n de su curvatura principal, que es suficiente para clasificar las superficies elementales.  Al calcular las curvaturas en los v√©rtices de malla, utilizamos los resultados del trabajo de Meyer (Mark Meyer, Mathieu Desbrun, Peter Schroder y Alan H. Barr, "Operadores discretos de geometr√≠a diferencial para m√∫ltiples colectores triangulados", Visualizaci√≥n y Matem√°ticas III, 2003) Al definir un operador diferencial discreto para regiones trianguladas: se considera un conjunto de v√©rtices adyacentes (relacionados con un v√©rtice dado a trav√©s de un borde) para cada v√©rtice de malla inicial.  A continuaci√≥n, se calcula un operador discreto <i>K</i> para el v√©rtice.  Seg√∫n el operador, las curvaturas promedio normal, media <i>K <sub>H</sub></i> y gaussiana <i>K <sub>G</sub></i> se definen en el v√©rtice de la malla. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="imagen"><br>  <i>Definici√≥n de operadores diferenciales discretos para regiones trianguladas</i> <br><br>  De esta manera, el tensor de curvatura se calcula para cada v√©rtice de malla, del cual se extraen los valores de curvatura principal <i>K <sub>1</sub></i> y <i>K <sub>2</sub></i> y las direcciones de curvatura principal. <br><br>  Los v√©rtices de malla se clasifican por los valores de sus curvaturas principales <i>K <sub>1</sub></i> y <i>K <sub>2</sub></i> , y luego se calculan para ellos.  El algoritmo de clasificaci√≥n de v√©rtices se basa en k-medias, es decir, minimiza la desviaci√≥n cuadr√°tica total de los puntos del grupo desde los centros de los grupos.  El resultado resultante del algoritmo contiene un v√©rtice de malla asociado con un cl√∫ster <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhhZ2c3f-ZY1DuYO3nMu5tEXog_lPA#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhhZ2c3f-ZY1DuYO3nMu5tEXog_lPA#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  y un par de curvaturas (cluster-center - L. Guillaume, "Segmentaci√≥n de malla triangular basada en tensor de curvatura con rectificaci√≥n de l√≠mites", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="imagen"><br>  <i>Clasificaci√≥n de v√©rtices de malla poligonal en el espacio de curvatura</i> <br><br>  Una vez que terminamos de clasificar los v√©rtices de la malla poligonal, pasamos a clasificar los pol√≠gonos.  Para comenzar este procedimiento, elegimos un pol√≠gono triangular cuya curvatura puede considerarse completamente definida.  Este es uno cuyos tres v√©rtices est√°n dentro de un solo grupo, o tiene dos v√©rtices en un borde afilado.  El pol√≠gono se etiqueta como un nuevo segmento y se convierte en el punto de partida para un procedimiento recursivo que expande el segmento: para cada pol√≠gono triangular, los pol√≠gonos adyacentes se consideran siempre que el borde entre ellos no est√© "afilado".  Cuando un v√©rtice de pol√≠gono adyacente, que es opuesto a un borde com√∫n, est√° en un borde afilado o pertenece al mismo grupo, el pol√≠gono se agrega al segmento.  El proceso se repite hasta que todos los pol√≠gonos que forman la malla desaparecieron. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="imagen"><br>  <i>Segmentaci√≥n de malla poligonal</i> <br><br>  Una vez que se completa el procedimiento de creaci√≥n de segmentos, otro algoritmo une los segmentos adyacentes para eliminar la segmentaci√≥n excesiva de la malla. <br><br><h1>  <font color="#00B2FF">Reconocimiento de tipo de superficie</font> </h1><br>  La segunda etapa es el reconocimiento de superficie.  Cada segmento debe aproximarse por una superficie con una precisi√≥n determinada por el sistema o por los usuarios. <br><br>  En primer lugar, los valores de curvatura principal de los segmentos se utilizan para determinar si es posible describir la forma del segmento mediante una de las siguientes superficies elementales: <br><br><ul><li>  Plano: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  Esfera: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  Cilindro: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  Cono: <i>k <sub>1</sub></i> ‚àà [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  Toroide: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ‚àà [ <i>a</i> , <i>b</i> ] </li></ul><br>  Para crear superficies elementales, ajustamos objetos geom√©tricos simples en conjuntos de puntos usando el algoritmo apropiado.  Por ejemplo, para ajustar un c√≠rculo y una esfera en un conjunto de puntos, se utiliza el m√©todo de m√≠nimos cuadrados;  Para ajustar un plano, se utiliza el an√°lisis de componentes principales.  El sistema garantiza que cada superficie reconstruida est√© relacionada con un segmento dentro de una precisi√≥n de reconocimiento predefinida. <br><br>  La siguiente figura ilustra las superficies reconocidas por color: los planos se muestran en azul, los cilindros en rojo, las esferas en verde, los conos amarillos y los toroides violetas. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="imagen"><br>  <i>Malla poligonal de origen (izquierda) y malla segmentada (derecha) con segmentos de superficie reconocidos</i> <br><br>  Si ninguna superficie elemental puede describir el segmento, entonces el sistema intenta reconocer una superficie de extrusi√≥n o una superficie de revoluci√≥n. <br><br>  Cuando el sistema finalmente no puede encontrar una superficie anal√≠tica para describir la forma del segmento, se crea una superficie NURBS para ello. <br><br><h1>  <font color="#00B2FF">Creaci√≥n de modelo B-rep</font> </h1><br>  La etapa final de la transformaci√≥n es crear el modelo B-rep basado en la segmentaci√≥n y los datos de superficie reconstruidos.  Se crea un gr√°fico de adyacencia a partir de las regiones segmentadas para representar la topolog√≠a del modelo y forma la base para crear el modelo B-rep resultante.  Los modelos B-rep se ensamblan en un modo totalmente autom√°tico, en contraste con las etapas anteriores: <br><br><ul><li>  Los bordes B-rep se crean a partir de curvas de intersecci√≥n de superficies reconstruidas adyacentes </li><li>  Las caras B-rep est√°n construidas por superficies reconocidas acotadas y bordes B-rep </li></ul><br>  Sin embargo, no siempre es posible crear un shell con la topolog√≠a correcta.  Por ejemplo, tome dos superficies como un cilindro y un plano que sean casi tangentes entre s√≠ en el espacio.  Debido a la tolerancia especificada para las superficies reconstruidas, es posible que no se crucen en absoluto.  Como resultado, el shell creado puede tener defectos.  Los usuarios pueden eliminar defectos corrigiendo los par√°metros de la superficie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UPasZTasOps" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Tipos de modelos poligonales</font> </h1><br>  Existen numerosas fuentes de modelos poligonales disponibles en l√≠nea: <br><br><ul><li>  Los cat√°logos y bases de datos en l√≠nea ofrecen modelos 3D en formatos poligonales como STL, VRML y OBJ de 3D Warehouse, Cults 3D, etc. </li><li>  Archivos que resultan del escaneo 3D </li><li>  Salida de la optimizaci√≥n topol√≥gica de modelos usando algoritmos CAE </li></ul><br>  Los modelos poligonales de estas fuentes se pueden dividir en dos grupos: modelos triangulados (mallados) a partir de objetos B-rep, y todos los dem√°s modelos.  Un par de caracter√≠sticas espec√≠ficas del primer grupo es la ausencia de ruido de malla poligonal y el dominio de las superficies anal√≠ticas.  Esto significa que los modelos del primer grupo se pueden transformar f√°cilmente en repeticiones b en modo totalmente automatizado o con un esfuerzo m√≠nimo del usuario. <br><br>  Las mallas poligonales de los modelos en el segundo grupo tienen ruido, contienen superficies org√°nicas y, por lo tanto, es m√°s probable que requieran la participaci√≥n interactiva de los usuarios. <br><br>  Por lo tanto, ofrecemos dos modos para operar C3D B-Shape, totalmente autom√°tico e interactivo.  Los usuarios pueden cambiar entre los modos de reconocimiento y administrar los tipos de superficie durante el proceso de reconstrucci√≥n.  La selecci√≥n de un modo puede depender del prop√≥sito de realizar la transformaci√≥n: los usuarios a veces pueden desear ignorar la conectividad topol√≥gica del shell resultante, o su correcci√≥n general.  Este suele ser el caso cuando se optimiza la visualizaci√≥n en aplicaciones BIM, en las que los usuarios agregan elementos interiores personalizados al modelo arquitect√≥nico. <br><br>  Por otro lado, las tareas de ingenier√≠a inversa requieren la copia m√°s precisa posible de los modelos fuente para que el modelo resultante tenga una topolog√≠a correcta.  Por lo tanto, es necesario predefinir la precisi√≥n de, por ejemplo, la coaxialidad de los cilindros o la tangencia de dos superficies.  En este tipo de casos, la participaci√≥n de los usuarios en el proceso de transformaci√≥n es crucial. <br><br>  La transformaci√≥n autom√°tica de C3D B-Shaper emplea las siguientes funciones que utilizan como datos de entrada la malla de origen y la configuraci√≥n de transformaci√≥n: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br>  Una de las configuraciones de transformaci√≥n es un valor de precisi√≥n de reconocimiento que establece la tolerancia m√°xima para distancias entre v√©rtices de segmento y superficies reconocidas.  La precisi√≥n puede ser absoluta o relativa.  Cuando se usa una precisi√≥n relativa, las desviaciones de las caras de los cuerpos de malla se miden en relaci√≥n con el tama√±o del modelo. <br><br>  La clase de interfaz del procesador MbMesh ofrece opciones avanzadas para gestionar la segmentaci√≥n y el reconocimiento de superficies: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Mesh rectification. void SetUseMeshSmoothing( bool useSmoothing ); // Mesh segmentation management. const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); // Surface recognition management. void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; // B-rep shell construction. MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br>  Para, por ejemplo, corregir los resultados de la segmentaci√≥n autom√°tica, C3D B-Shaper ofrece herramientas para fusionar y dividir segmentos, etc.  Los usuarios pueden ajustar superficies de tipos dados en el segmento seleccionado, as√≠ como modificar los par√°metros de superficies reconocidas. <br><br><h1>  <font color="#00B2FF">Resumen</font> </h1><br>  El resultado de los algoritmos de transformaci√≥n de C3D B-Shaper se ilustra en las siguientes figuras, en las que un modelo 3D complejo se transforma con √©xito de su representaci√≥n de malla poligonal a un s√≥lido de representaci√≥n de l√≠mites. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="imagen"><br>  <i>Malla poligonal (izquierda) y modelo B-rep (derecha) convertidos con C3D B-Shaper</i> <br><br>  Nuestro objetivo es crear un SDK potente para transformar modelos de poligonal a B-rep, y as√≠ contin√∫a el desarrollo de C3D B-Shaper.  Algunas de las cosas en las que estamos trabajando incluyen el avance de los algoritmos de segmentaci√≥n autom√°tica, el desarrollo de herramientas para la edici√≥n de segmentaci√≥n, la mejora de la construcci√≥n de superficies NURBS de forma libre y la mejora de la calidad de los ensamblajes de shell B-rep. <br><br>  Los clientes que usan el n√∫cleo geom√©trico C3D tambi√©n son un factor para impulsar el desarrollo de C3D B-Shaper. <br><br>  Los desarrolladores pueden probar C3D B-Shaper como parte del C3D Toolkit o como un componente independiente. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Por Andrey Tumanin, l√≠der de desarrollo de software en C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465237/">https://habr.com/ru/post/465237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465217/index.html">Acronis True Image 2020: nuevos esquemas de replicaci√≥n y protecci√≥n mejorada</a></li>
<li><a href="../465221/index.html">Lo que los registros en 1C podr√≠an verse en presencia de OOP</a></li>
<li><a href="../465223/index.html">C√≥mo hacer un uso pr√°ctico de la seguridad del papel, o por qu√© necesitamos cumplir con 152-–§–ó y PCI DSS en una nube</a></li>
<li><a href="../465227/index.html">Realidad aumentada en el comercio minorista en l√≠nea</a></li>
<li><a href="../465229/index.html">‚ÄúConsultor +‚Äù: cambio en el flujo de material. Fuentes, estilos, alineaci√≥n de texto con python</a></li>
<li><a href="../465239/index.html">Ven y recoge libros en ingl√©s</a></li>
<li><a href="../465241/index.html">Mi s√©ptimo d√≠a con Haiku: listado, escaneo, red</a></li>
<li><a href="../465245/index.html">Vea la interfaz "a trav√©s de los ojos del dise√±ador": sobre la interacci√≥n del front-end con el dise√±ador</a></li>
<li><a href="../465247/index.html">Angular Comprender @Input, @Output y EventEmitter</a></li>
<li><a href="../465249/index.html">Conferencia de Richard Stallman en el Polit√©cnico de Mosc√∫. Agosto 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>