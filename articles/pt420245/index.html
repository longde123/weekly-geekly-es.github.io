<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ω üè£ #‚É£ Como evitar a satura√ß√£o de mem√≥ria ao usar cole√ß√µes Java ü§ê üò† üç£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Nossa experi√™ncia com as etapas do curso Java Developer continua e, por incr√≠vel que pare√ßa, at√© com bastante sucesso (mais ou menos):...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como evitar a satura√ß√£o de mem√≥ria ao usar cole√ß√µes Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/420245/"> Ol√° pessoal! <br><br>  Nossa experi√™ncia com as etapas do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Developer</a> continua e, por incr√≠vel que pare√ßa, at√© com bastante sucesso (mais ou menos): como se viu, alavancar o planejamento de alguns meses com a pr√≥xima transi√ß√£o para uma nova etapa a qualquer momento conveniente √© muito mais conveniente do que se Aloque quase seis meses para um curso t√£o dif√≠cil.  Portanto, suspeita-se que s√£o precisamente os cursos complexos que em breve come√ßaremos a transferir lentamente para esse sistema. <br><br>  Mas sou eu sobre a nossa, sobre otusovsky, me desculpe.  Como sempre, continuamos a estudar t√≥picos interessantes que, embora n√£o sejam abordados em nosso programa, mas que s√£o discutidos conosco, preparamos uma tradu√ß√£o do artigo mais interessante em nossa opini√£o sobre uma das perguntas que nossos professores fizeram. <br><br>  Vamos l√°! <br><br><img src="https://habrastorage.org/webt/gg/pb/_w/ggpb_wvr4ihy5kk_wj9wm0awrea.png"><a name="habracut"></a><br><br>  Cole√ß√µes no JDK s√£o as implementa√ß√µes da biblioteca padr√£o de listas e mapas.  Se voc√™ observar um instant√¢neo de um aplicativo Java grande e t√≠pico, ver√° milhares ou at√© milh√µes de inst√¢ncias de <code>java.util.ArrayList</code> , <code>java.util.HashMap</code> etc. As cole√ß√µes s√£o indispens√°veis ‚Äã‚Äãpara armazenar e manipular dados.  Mas voc√™ j√° pensou se todas as cole√ß√µes do seu aplicativo fazem um uso otimizado da mem√≥ria?  Em outras palavras, se o aplicativo travar com o vergonhoso <code>OutOfMemoryError</code> ou causar longas pausas no coletor de lixo, voc√™ j√° verificou as cole√ß√µes usadas quanto a vazamentos. <br><br>  Em primeiro lugar, deve-se notar que as cole√ß√µes internas do JDK n√£o s√£o algum tipo de m√°gica.  Eles s√£o escritos em Java.  O c√≥digo fonte deles vem com o JDK, para que voc√™ possa abri-lo no seu IDE.  Seu c√≥digo tamb√©m pode ser facilmente encontrado na Internet.  E, como se v√™, a maioria das cole√ß√µes n√£o √© muito elegante em termos de otimiza√ß√£o da quantidade de mem√≥ria consumida. <br><br>  Considere, por exemplo, uma das cole√ß√µes mais simples e populares - a classe <code>java.util.ArrayList</code> .  Internamente, cada <code>ArrayList</code> opera com uma matriz de <code>Object[] elementData</code> .  √â aqui que os itens da lista s√£o armazenados.  Vamos ver como esse array √© processado. <br><br>  Quando voc√™ cria um <code>ArrayList</code> com o construtor padr√£o, ou seja, chama <code>new ArrayList()</code> , <code>elementData</code> aponta para uma matriz gen√©rica de tamanho zero ( <code>elementData</code> tamb√©m pode ser definido como <code>null</code> , mas a matriz fornece alguns pequenos benef√≠cios de implementa√ß√£o).  Quando voc√™ adiciona o primeiro elemento √† lista, uma matriz √∫nica e real de <code>elementData</code> e o objeto fornecido √© inserido nela.  Para evitar alterar o tamanho da matriz a cada vez, ao adicionar um novo elemento, ele √© criado com um comprimento igual a 10 ("capacidade padr√£o").  Acontece que: se voc√™ n√£o adicionar mais elementos a este <code>ArrayList</code> , 9 dos 10 slots no array <code>elementData</code> permanecer√£o vazios.  E mesmo que voc√™ limpe a lista, o tamanho da matriz interna n√£o ser√° reduzido.  A seguir, √© apresentado um diagrama desse ciclo de vida: <br><br><img src="https://habrastorage.org/webt/mu/3n/hd/mu3nhdbrmajrdvphqi1kyj6nhii.png"><br><br>  Quanta mem√≥ria √© desperdi√ßada aqui?  Em termos absolutos, √© calculado como (o tamanho do ponteiro do objeto).  Se voc√™ usar o JVM HotSpot (que acompanha o Oracle JDK), o tamanho do ponteiro depender√° do tamanho m√°ximo do heap (para obter mais detalhes, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://blog.codecentric.de/en/2014/02/35gb-heap-less- 32gb-java-jvm-memory-estranhezas /</a> ).  Normalmente, se voc√™ especificar <code>-Xmx</code> menor que 32 gigabytes, o tamanho do ponteiro ser√° 4 bytes;  para mont√µes grandes - 8 bytes.  Assim, um <code>ArrayList</code> , inicializado pelo construtor padr√£o, com a adi√ß√£o de apenas um elemento, desperdi√ßa 36 ou 72 bytes. <br><br>  De fato, um <code>ArrayList</code> vazio tamb√©m <code>ArrayList</code> desperdi√ßando mem√≥ria porque n√£o carrega nenhuma carga de trabalho, mas o tamanho do <code>ArrayList</code> si n√£o √© zero e maior do que voc√™ provavelmente pensa.  Isso ocorre porque, por um lado, todo objeto gerenciado pela JVM do HotSpot possui um cabe√ßalho de 12 ou 16 bytes, que √© usado pela JVM para fins internos.  Al√©m disso, a maioria dos objetos na cole√ß√£o cont√©m um campo de <code>size</code> , um ponteiro para uma matriz interna ou outro objeto de "m√≠dia de carga de trabalho", um campo <code>modCount</code> para rastrear altera√ß√µes no conte√∫do etc. Assim, mesmo o menor objeto poss√≠vel que representa uma cole√ß√£o vazia provavelmente precisar√° de pelo menos 32 bytes de mem√≥ria.  Alguns, como <code>ConcurrentHashMap</code> , ocupam muito mais. <br><br>  Considere outra cole√ß√£o comum - a classe <code>java.util.HashMap</code> .  Seu ciclo de vida √© semelhante ao ciclo de vida <code>ArrayList</code> : <br><br><img src="https://habrastorage.org/webt/qu/ov/lm/quovlmld5clm9w8f0x3v7a_kor8.png"><br><br>  Como voc√™ pode ver, um <code>HashMap</code> contendo apenas um par de valores-chave gasta 15 c√©lulas internas da matriz, o que corresponde a 60 ou 120 bytes.  Esses n√∫meros s√£o pequenos, mas a extens√£o da perda de mem√≥ria √© importante para todas as cole√ß√µes no seu aplicativo.  E acontece que alguns aplicativos podem gastar bastante mem√≥ria dessa maneira.  Por exemplo, alguns dos componentes populares do Hadoop de c√≥digo aberto que o autor analisou perdem cerca de 20% de sua pilha em alguns casos!  Para produtos desenvolvidos por engenheiros menos experientes que n√£o passam por an√°lises regulares de desempenho, a perda de mem√≥ria pode ser ainda maior.  Existem casos suficientes em que, por exemplo, 90% dos n√≥s em uma √°rvore enorme cont√™m apenas um ou dois descendentes (ou nada) e outras situa√ß√µes em que o heap est√° entupido com cole√ß√µes de 0, 1 ou 2 elementos. <br><br>  Se voc√™ encontrar cole√ß√µes n√£o utilizadas ou subutilizadas em seu aplicativo, como corrigi-las?  Abaixo est√£o algumas receitas comuns.  Aqui, sup√µe-se que nossa cole√ß√£o problem√°tica seja um <code>ArrayList</code> referenciado pelo campo de dados <code>Foo.list</code> . <br><br>  Se a maioria das inst√¢ncias da lista nunca for usada, tente inicializ√°-la lentamente.  Ent√£o, o c√≥digo que parecia anteriormente ... <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ list.add(x); }</code> </pre> <br>  ... deve ser refeito em algo como <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ getOrCreateList().add(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> list </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,         if (list == null) list = new ArrayList(); return list; }</span></span></code> </pre> <br>  Lembre-se de que algumas vezes voc√™ precisar√° tomar medidas adicionais para lidar com a concorr√™ncia em potencial.  Por exemplo, se voc√™ oferecer suporte ao <code>ConcurrentHashMap</code> , que pode ser atualizado por v√°rios segmentos simultaneamente, o c√≥digo que o inicializa n√£o deve permitir que dois segmentos criem duas c√≥pias desse mapa aleatoriamente: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//,       synchronized (this) { if (map == null) map = new ConcurrentHashMap(); } } return map; }</span></span></code> </pre> <br>  Se a maioria das inst√¢ncias da sua lista ou mapa contiver apenas alguns itens, tente inicializ√°-los com uma capacidade inicial mais adequada, por exemplo. <br><br><pre> <code class="java hljs">list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       4</span></span></code> </pre> <br>  Se suas cole√ß√µes estiverem vazias ou contiverem apenas um elemento (ou um par de valores-chave) na maioria dos casos, voc√™ poder√° considerar uma forma extrema de otimiza√ß√£o.  Funciona apenas se a cole√ß√£o for totalmente gerenciada na classe atual, ou seja, outro c√≥digo n√£o poder√° acess√°-la diretamente.  A id√©ia √© que voc√™ altere o tipo do seu campo de dados, por exemplo, de Lista para um Objeto mais geral, para que agora possa apontar para uma lista real ou diretamente para um √∫nico item da lista.  Aqui est√° um breve esbo√ßo: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ***   *** private List&lt;Foo&gt; list = new ArrayList&lt;&gt;(); void addToList(Foo foo) { list.add(foo); } // ***   *** //   ,    null.      , //      .       //   ArrayList. private Object listOrSingleEl; void addToList(Foo foo) { if (listOrSingleEl == null) { //   listOrSingleEl = foo; } else if (listOrSingleEl instanceof Foo) { //  Foo firstEl = (Foo) listOrSingleEl; ArrayList&lt;Foo&gt; list = new ArrayList&lt;&gt;(); listOrSingleEl = list; list.add(firstEl); list.add(foo); } else { //      ((ArrayList&lt;Foo&gt;) listOrSingleEl).add(foo); } }</span></span></code> </pre> <br>  Obviamente, o c√≥digo com essa otimiza√ß√£o √© menos claro e mais dif√≠cil de manter.  Mas isso pode ser √∫til se voc√™ tiver certeza de que isso economizar√° muita mem√≥ria ou se livrar√° de longas pausas no coletor de lixo. <br><br>  Voc√™ provavelmente j√° se perguntou: como descubro quais cole√ß√µes no meu aplicativo consomem mem√≥ria e quanto? <br><br>  Resumindo: √© dif√≠cil descobrir sem as ferramentas certas.  Tentar adivinhar a quantidade de mem√≥ria usada ou gasta pelas estruturas de dados em um aplicativo grande e complexo quase nunca leva a nada.  E, sem saber exatamente para onde vai a mem√≥ria, voc√™ pode gastar muito tempo perseguindo os objetivos errados, enquanto o aplicativo continua teimosamente <code>OutOfMemoryError</code> com o <code>OutOfMemoryError</code> . <br><br>  Portanto, voc√™ deve verificar v√°rios aplicativos usando uma ferramenta especial.  Por experi√™ncia, a maneira mais ideal de analisar a mem√≥ria da JVM (medida como a quantidade de informa√ß√µes dispon√≠veis em compara√ß√£o com o efeito dessa ferramenta no desempenho do aplicativo) √© obter um despejo de heap e visualiz√°-lo offline.  Um despejo de heap √© essencialmente um instant√¢neo completo do heap.  Voc√™ pode obt√™-lo a qualquer momento chamando o utilit√°rio jmap ou pode configurar a JVM para despejar automaticamente se o aplicativo travar com <code>OutOfMemoryError</code> .  Se voc√™ pesquisar no Google "Dump de heap da JVM", ver√° imediatamente um grande n√∫mero de artigos que explicam em detalhes como obter um dump. <br><br>  Um dump de heap √© um arquivo bin√°rio do tamanho de um heap da JVM, portanto, ele s√≥ pode ser lido e analisado usando ferramentas especiais.  Existem v√°rias ferramentas, tanto de c√≥digo aberto quanto comerciais.  A ferramenta de c√≥digo aberto mais popular √© o Eclipse MAT;  tamb√©m h√° o VisualVM e algumas ferramentas menos poderosas e menos conhecidas.  As ferramentas comerciais incluem criadores de perfil Java de uso geral: JProfiler e YourKit, bem como uma ferramenta projetada especificamente para an√°lise de heap dump - JXRay (aviso: √∫ltimo desenvolvido pelo autor). <br><br>  Diferentemente de outras ferramentas, o JXRay analisa imediatamente o despejo de heap em busca de um grande n√∫mero de problemas comuns, como linhas repetidas e outros objetos, al√©m de estruturas de dados insuficientemente eficientes.  Problemas com as cole√ß√µes descritas acima se enquadram nesta √∫ltima categoria.  A ferramenta gera um relat√≥rio com todas as informa√ß√µes coletadas no formato HTML.  A vantagem dessa abordagem √© que voc√™ pode visualizar os resultados da an√°lise em qualquer lugar a qualquer momento e compartilh√°-los facilmente com outras pessoas.  Voc√™ tamb√©m pode executar a ferramenta em qualquer m√°quina, incluindo m√°quinas grandes e poderosas, mas "sem cabe√ßa" no data center. <br><br>  O JXRay calcula a sobrecarga (quanta mem√≥ria voc√™ economizar√° se se livrar de um problema espec√≠fico) em bytes e como uma porcentagem da pilha usada.  Combina cole√ß√µes da mesma classe que t√™m o mesmo problema ... <br><br><img src="https://habrastorage.org/webt/qm/_n/44/qm_n44hqttg315sv5h8wv3ujefc.png"><br><br>  ... e agrupa as cole√ß√µes problem√°ticas acess√≠veis a partir de alguma raiz do coletor de lixo atrav√©s da mesma cadeia de links, como no exemplo abaixo <br><br><img src="https://habrastorage.org/webt/4o/is/ib/4oisibqplc6cj55ojwossuycohs.png"><br><br>  Saber quais cadeias de links e / ou campos de dados individuais (por exemplo, <code>INodeDirectory.children</code> acima) indicam cole√ß√µes que gastam a maior parte de sua mem√≥ria permite identificar com rapidez e precis√£o o c√≥digo respons√°vel pelo problema e, em seguida, fazer as altera√ß√µes necess√°rias. <br><br>  Portanto, cole√ß√µes Java insuficientemente configuradas podem desperdi√ßar muita mem√≥ria.  Em muitas situa√ß√µes, esse problema √© f√°cil de resolver, mas √†s vezes voc√™ pode precisar modificar seu c√≥digo de maneiras n√£o triviais para obter melhorias significativas.  √â muito dif√≠cil adivinhar quais cole√ß√µes precisam ser otimizadas para ter o maior impacto.  Para n√£o perder tempo otimizando as partes incorretas do c√≥digo, voc√™ precisa obter um dump de heap da JVM e analis√°-lo usando a ferramenta apropriada. <br><br>  O FIM <br><br>  Como sempre, estamos interessados ‚Äã‚Äãem suas opini√µes e perguntas, que voc√™ pode deixar aqui ou deixar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma aula aberta</a> e perguntar aos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">professores</a> l√°. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420245/">https://habr.com/ru/post/pt420245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420233/index.html">UE4 Equipamento para Multiplayer # 5 | Transfer√™ncia de informa√ß√µes entre servidor e cliente</a></li>
<li><a href="../pt420235/index.html">Zenject: Como um cont√™iner de IoC pode matar a inje√ß√£o de depend√™ncia em seu projeto</a></li>
<li><a href="../pt420237/index.html">Wrapper Qt em torno da estrutura gRPC em C ++</a></li>
<li><a href="../pt420239/index.html">Desenvolvimento m√≥vel. Swift: o mist√©rio dos protocolos</a></li>
<li><a href="../pt420243/index.html">Filantropia inovadora: Projetos de inova√ß√£o humanit√°ria</a></li>
<li><a href="../pt420251/index.html">Apple afirma que o complexo da sede da empresa custa apenas US $ 200</a></li>
<li><a href="../pt420253/index.html">Como as APIs de bancos abertos est√£o mudando o mundo financeiro</a></li>
<li><a href="../pt420257/index.html">Voc√™ ainda instala o Windows 2008? Eu tamb√©m, e √© por isso</a></li>
<li><a href="../pt420259/index.html">Painel de diagn√≥stico de envelhecimento em Cingapura</a></li>
<li><a href="../pt420261/index.html">O que vamos medir? Como escolher as m√©tricas corretas de ML para tarefas de neg√≥cios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>