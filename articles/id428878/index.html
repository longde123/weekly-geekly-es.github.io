<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥖 👨🏼‍🎤 ✍️ Penerbangan Babi, atau Optimalisasi Penerjemah Bytecode 🔄 🦈 🐩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Tidak peduli seberapa keras Anda mencoba, Anda tidak dapat membuat kuda pacu keluar dari babi. Namun, Anda dapat membuat babi lebih cepat" (komentar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penerbangan Babi, atau Optimalisasi Penerjemah Bytecode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/428878/"><p><img src="https://habrastorage.org/webt/bg/lp/cz/bglpczwnjg-u0usatiwfxggd-zi.jpeg"></p><br><blockquote>  "Tidak peduli seberapa keras Anda mencoba, Anda tidak dapat membuat kuda pacu keluar dari babi. Namun, Anda dapat membuat babi lebih cepat" (komentar dalam kode sumber Emax) </blockquote><p>  Semua orang tahu fakta bahwa babi tidak bisa terbang.  Yang tidak kalah populer adalah pendapat bahwa penerjemah bytecode sebagai teknik untuk mengeksekusi bahasa tingkat tinggi tidak dapat dipercepat tanpa menggunakan kompilasi dinamis yang memakan waktu. </p><br><p>  Pada bagian kedua dari serangkaian artikel tentang penerjemah bytecode, saya akan mencoba menunjukkan dengan contoh mesin virtual FDA kecil (Pig Virtual Machine) bahwa tidak semuanya hilang untuk anak babi pekerja keras dengan ambisi dan bahwa sangat mungkin untuk mempercepat dalam kerangka (kebanyakan) standar C pekerjaan penerjemah semacam itu setidaknya satu setengah kali. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Satu, Pengantar</a> <br>  Bagian dua, mengoptimalkan (saat ini) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Tiga, Diterapkan</a> </p><br><h1 id="porosenokvm">  Piglet </h1><br><p>  Mari berkenalan. </p><br><p>  <a href="">Piglet</a> VM adalah mesin bertumpuk biasa berdasarkan <a href="">contoh</a> dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari</a> serangkaian artikel.  Babi kami hanya tahu satu tipe data - kata mesin 64-bit, dan semua perhitungan (bilangan bulat) dilakukan pada tumpukan dengan kedalaman maksimum 256 kata mesin.  Selain tumpukan, anak babi ini memiliki memori kerja 65.536 kata mesin.  Hasil eksekusi program - satu kata mesin - dapat ditempatkan dalam register hasil, atau cukup output ke output standar (stdout). </p><br><p>  Seluruh status dalam mesin Piglet VM disimpan dalam satu struktur: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Current instruction pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-comment"><span class="hljs-comment">/* Fixed-size stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[STACK_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> *stack_top; <span class="hljs-comment"><span class="hljs-comment">/* Operational memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> memory[MEMORY_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* A single register containing the result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> result; } vm;</code> </pre> <br><p>  Di atas memungkinkan kita untuk menghubungkan mesin ini ke mesin virtual level rendah, hampir semua overhead yang jatuh pada pemeliharaan siklus program utama: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(bytecode); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_PUSHI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: { <span class="hljs-comment"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * ... * Lots of other instruction handlers here * ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_END_OF_STREAM; }</code> </pre> <br><p>  Kode menunjukkan bahwa untuk setiap opcode, piggy harus: </p><br><ol><li>  Ambil opcode dari aliran instruksi. </li><li>  Pastikan opcode berada dalam kisaran nilai opcode yang valid (logika ini ditambahkan oleh kompiler C saat membuat kode switch). </li><li>  Pergi ke instruksi tubuh. </li><li>  Ekstrak argumen instruksi dari stack atau decode argumen instruksi yang terletak langsung di bytecode. </li><li>  Lakukan operasi. </li><li>  Jika ada hasil perhitungan, letakkan di tumpukan. </li><li>  Pindahkan penunjuk dari instruksi saat ini ke yang berikutnya. </li></ol><br><p>  Payload di sini hanya di paragraf kelima, sisanya di atas kepala: mendekode atau mengambil argumen instruksi dari stack (klausa 4), memeriksa nilai opcode (klausa 2), berulang kali kembali ke awal loop utama dan transisi kondisional berikutnya yang sulit diprediksi (klausul 3). </p><br><p>  Singkatnya, babi jelas telah melebihi indeks massa tubuh yang direkomendasikan, dan jika kita ingin membuatnya menjadi sempurna, maka kita harus berurusan dengan semua ekses ini. </p><br><h1 id="svinskiy-yazyk-assemblera-i-resheto-eratosfena">  Bahasa perakitan babi dan ayakan Eratosthenes </h1><br><p>  Pertama, mari kita putuskan aturan mainnya. </p><br><p>  Menulis program untuk mesin virtual langsung di C adalah ide yang buruk, tetapi membuat bahasa pemrograman adalah waktu yang lama, jadi kami memutuskan untuk membatasi diri pada bahasa rakitan celengan. </p><br><p>  Program yang menghitung jumlah angka dari 1 hingga 65.536 di assembler ini terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"># sum numbers from 1 to 65535 # init the current sum and the index PUSHI 1 PUSHI 1 # stack s=1, i=1 STOREI 0 # stack: s=1 # routine: increment the counter, add it to the current sum incrementandadd: # check if index is too big LOADI 0 # stack: s, i ADDI 1 # stack: s, i+1 DUP # stack: s, i+1, i+1 GREATER_OR_EQUALI 65535 # stack: s, i+1, 1 or 0 JUMP_IF_TRUE done # stack: s, i+1 DUP # stack: s, i+1, i+1 STOREI 0 # stack: s, i+1 ADD # stack: s+i+1 JUMP incrementandadd done: DISCARD PRINT DONE</code> </pre> <br><p>  Bukan Python, tentu saja, tetapi ada semua yang Anda butuhkan untuk kebahagiaan babi: komentar, tag, lompatan bersyarat dan tanpa syarat kepada mereka, mnemonik untuk instruksi, dan kemampuan untuk menentukan argumen langsung ke instruksi. </p><br><p>  Lengkap dengan mesin "Piglet VM" yang assembler dan disassembler, yang berani dalam semangat dan memiliki banyak waktu luang, pembaca dapat menguji secara mandiri dalam pertempuran. </p><br><p>  Jumlahnya bertambah dengan sangat cepat, jadi untuk menguji kinerja saya menulis program lain - implementasi naif dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saringan Eratosthenes</a> . </p><br><p>  Bahkan, anak babi berjalan cukup cepat pula (instruksinya dekat dengan yang mesin), oleh karena itu, untuk mendapatkan hasil yang jelas, saya akan melakukan pengukuran masing-masing untuk seratus awal program. </p><br><p>  Versi pertama dari babi kami yang tidak dioptimalkan berjalan seperti ini: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null PROFILE: switch code finished took 545ms</code> </pre> <br><p>  Setengah detik!  Perbandingannya tentu saja tidak jujur, tetapi algoritma Python yang sama membuat seratus berjalan sedikit lebih lambat: </p><br><pre> <code class="plaintext hljs">&gt; python test/sieve.py &gt; /dev/null 4.66692185402</code> </pre> <br><p>  4,5 detik, atau sembilan kali lebih lambat.  Kita harus membayar upeti kepada anak babi - dia memiliki kemampuan!  Nah, sekarang mari kita lihat apakah babi kita dapat memompa pers. <br><img src="https://habrastorage.org/webt/ce/eq/ni/ceeqnik6-41cuvd3rwvkkuquoes.jpeg"></p><br><h1 id="uprazhnenie-pervoe-staticheskie-superinstrukcii">  Latihan Satu: Superinstructions statis </h1><br><p>  Aturan pertama kode cepat adalah jangan melakukan terlalu banyak pekerjaan.  Aturan kedua dari kode cepat adalah jangan pernah melakukan terlalu banyak pekerjaan.  Jadi, jenis pekerjaan ekstra apa yang dilakukan Piglet VM? </p><br><p>  Pengamatan satu: membuat profil program kami menunjukkan bahwa ada urutan instruksi yang lebih umum daripada yang lain.  Kami tidak akan banyak menyiksa babi kami dan membatasi diri hanya pada beberapa instruksi: </p><br><ol><li>  LOADI 0, ADD - letakkan di tumpukan nomor dari memori di alamat 0 dan tambahkan ke nomor di atas tumpukan. </li><li>  PUSHI 65536, GREATER_OR_EQUAL - taruh nomor di tumpukan dan bandingkan dengan nomor yang sebelumnya di atas tumpukan, masukkan hasil perbandingan (0 atau 1) kembali ke tumpukan. </li><li>  PUSHI 1, ADD - letakkan angka di tumpukan, tambahkan ke nomor yang sebelumnya di atas tumpukan, dan masukkan kembali hasil penambahan ke tumpukan. </li></ol><br><p>  Ada lebih dari 20 instruksi dalam mesin Piglet VM, dan seluruh byte digunakan untuk encoding - 256 nilai.  Memperkenalkan instruksi baru bukanlah masalah.  Apa yang akan kita lakukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LOADADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get immediate argument as an memory address , add it to value from the address to the top * of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> addr = NEXT_ARG(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> val = vm.memory[addr]; *TOS_PTR() += val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_GREATER_OR_EQUALI:{ <span class="hljs-comment"><span class="hljs-comment">/* get the immediate argument, compare it with the value from the address to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() = PEEK() &gt;= arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* Add immediate value to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> }</code> </pre><br><p>  Tidak ada yang rumit.  Mari kita lihat apa yang terjadi: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 410ms</code> </pre> <br><p>  Wow!  Kode ini hanya untuk tiga instruksi baru, dan kami memenangkan satu setengah ratus milidetik! </p><br><p>  Keuntungan di sini tercapai karena fakta bahwa piggy kami tidak melakukan gerakan yang tidak perlu ketika mengeksekusi instruksi tersebut: utas eksekusi tidak jatuh ke loop utama, tidak ada yang diterjemahkan, dan argumen instruksi tidak melewati stack sekali lagi. </p><br><p>  Ini disebut superinstructions statis, karena instruksi tambahan didefinisikan secara statis, yaitu, oleh programmer mesin virtual pada tahap pengembangan.  Ini adalah teknik sederhana dan efektif yang digunakan semua mesin virtual bahasa pemrograman dalam satu bentuk atau lainnya. </p><br><p>  Masalah utama dengan superinstructions statis adalah bahwa tanpa program tertentu tidak mungkin untuk menentukan instruksi mana yang harus digabungkan.  Program yang berbeda menggunakan urutan instruksi yang berbeda, dan Anda dapat mengetahui urutan ini hanya pada tahap peluncuran kode tertentu. </p><br><p>  Langkah selanjutnya adalah kompilasi dinamis dari superinstructions dalam konteks program tertentu, yaitu superinstructions dinamis (di tahun 90-an dan awal 2000-an, teknik ini memainkan peran kompilasi JIT primitif). </p><br><p>  Tidak mungkin membuat instruksi dengan cepat dalam kerangka C biasa, dan anak babi kami dengan benar tidak menganggap ini sebagai kompetisi yang jujur.  Untungnya, saya punya beberapa latihan yang lebih baik untuknya. </p><br><h1 id="uprazhnenie-vtoroe-proverka-intervala-znacheniy-opkodov">  Latihan dua: memeriksa rentang nilai opcode </h1><br><p>  Mengikuti aturan kode cepat kami, sekali lagi kami bertanya pada diri sendiri pertanyaan abadi: apa yang tidak bisa Anda lakukan? </p><br><p>  Ketika kami berkenalan dengan perangkat mesin Piglet VM, saya mencantumkan semua tindakan yang dilakukan mesin virtual untuk setiap opcode.  Dan poin 2 (memeriksa nilai opcode agar sesuai dengan rentang nilai sakelar yang valid) adalah yang paling mencurigakan. </p><br><p>  Mari kita lihat bagaimana GCC mengkompilasi switch switch: </p><br><ol><li>  Tabel transisi dibangun, yaitu, tabel yang menampilkan nilai opcode ke alamat kode yang mengeksekusi tubuh instruksi. </li><li>  Kode dimasukkan yang memeriksa apakah opcode yang diterima berada dalam kisaran semua kemungkinan nilai sakelar dan mengirimkannya ke label default jika tidak ada penangan untuk opcode tersebut. </li><li>  Kode yang masuk ke pawang dimasukkan. </li></ol><br><p>  Tetapi mengapa memeriksa interval nilai untuk setiap instruksi?  Kami percaya bahwa opcode adalah benar - mengakhiri eksekusi dengan instruksi OP_DONE, atau salah - melampaui bytecode.  Ekor aliran opcode ditandai dengan nol, dan nol adalah opcode dari instruksi OP_ABORT, yang menyelesaikan eksekusi bytecode dengan kesalahan. </p><br><p>  Ternyata pemeriksaan ini tidak diperlukan sama sekali!  Dan anak babi harus bisa menyampaikan ide ini ke kompiler.  Mari kita coba sedikit memperbaiki saklar utama: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-comment"><span class="hljs-comment">/* Let the compiler know that opcodes are always between 0 and 31 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* All the instructions here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span> ... <span class="hljs-number"><span class="hljs-number">0x1f</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*Handle the remaining 5 non-existing opcodes*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } }</code> </pre> <br><p>  Mengetahui bahwa kami hanya memiliki 26 instruksi, kami mengenakan bit mask (nilai oktal 0x1f adalah biner 0b11111 yang mencakup rentang nilai dari 0 hingga 31) pada opcode dan menambahkan penangan ke nilai yang tidak digunakan dalam rentang dari 26 hingga 31. </p><br><p>  Instruksi bit adalah beberapa yang termurah dalam arsitektur x86, dan mereka tentu lebih murah daripada cabang kondisional bermasalah seperti yang menggunakan pengecekan interval.  Secara teoritis, kita harus memenangkan beberapa siklus pada setiap instruksi yang dapat dieksekusi jika kompiler memahami petunjuk kita. </p><br><p>  By the way, cara untuk menentukan rentang nilai dalam kasus ini bukan standar C, tetapi ekstensi GCC.  Tetapi untuk tujuan kita, kode ini cocok, terutama karena tidak sulit untuk membuatnya kembali menjadi beberapa penangan untuk masing-masing nilai yang tidak perlu. </p><br><p>  Kami mencoba: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 437ms PROFILE: switch code (no range check) finished took 383ms</code> </pre> <br><p>  50 milidetik lagi!  Piglet, seolah-olah Anda mendengar diri Anda di pundak Anda! .. </p><br><h1 id="uprazhnenie-trete-trassy">  Latihan Tiga: Lintasan </h1><br><p>  Latihan apa lagi yang bisa membantu anak babi kita?  Penghematan waktu terbesar yang kami dapatkan berkat instruksi super.  Dan mereka mengurangi jumlah jalan keluar ke siklus utama dan memungkinkan Anda untuk menyingkirkan overhead yang sesuai. </p><br><p>  Saklar sentral adalah titik masalah utama untuk setiap prosesor dengan eksekusi instruksi yang luar biasa.  Prediktor cabang modern telah belajar memprediksikan bahkan transisi tidak langsung yang rumit seperti itu dengan baik, tetapi “mengolesi” titik-titik cabang di sepanjang kode dapat membantu prosesor dengan cepat beralih dari instruksi ke instruksi. </p><br><p>  Masalah lain adalah pembacaan byte-by-byte dari opcodes instruksi dan argumen langsung dari bytecode.  Mesin fisik beroperasi dengan kata mesin 64-bit dan tidak benar-benar menyukainya ketika kode beroperasi dengan nilai yang lebih rendah. </p><br><p>  Compiler sering beroperasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blok-blok dasar</a> , yaitu urutan instruksi tanpa cabang dan label di dalamnya.  Blok dasar dimulai baik dari awal program atau dari label, dan berakhir dengan akhir program, percabangan bersyarat atau lompatan langsung ke label yang memulai blok dasar berikutnya. </p><br><p>  Ada banyak keuntungan untuk bekerja dengan unit dasar, tetapi babi kami tertarik dengan fitur utamanya: instruksi dalam unit dasar dijalankan secara berurutan.  Akan sangat bagus untuk mengisolasi blok-blok dasar ini dan mengikuti instruksi di dalamnya tanpa membuang waktu untuk masuk ke loop utama. </p><br><p>  Dalam kasus kami, Anda bahkan dapat memperluas definisi unit dasar ke trek.  Track dalam hal mesin Piglet VM akan mencakup semua blok dasar yang terhubung secara berurutan (yaitu, menggunakan lompatan tanpa syarat). </p><br><p>  Selain eksekusi berurutan dari instruksi, alangkah baiknya untuk memecahkan kode argumen langsung dari instruksi di muka. </p><br><p>  Semuanya terdengar sangat menakutkan dan menyerupai kompilasi dinamis, yang kami putuskan untuk tidak digunakan.  Babi bahkan sedikit meragukan kekuatannya, tetapi dalam praktiknya ternyata tidak terlalu buruk. </p><br><p>  Pertama-tama mari kita pikirkan bagaimana Anda bisa membayangkan instruksi yang termasuk dalam trek: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg; trace_op_handler *handler; };</code> </pre> <br><p>  Di sini arg adalah argumen pra-dekode instruksi, dan handler adalah pointer ke fungsi yang mengeksekusi logika instruksi. </p><br><p>  Sekarang tampilan setiap jejak terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> scode trace[MAX_TRACE_LEN];</code> </pre> <br><p>  Artinya, jejak adalah urutan kode-s dengan panjang terbatas.  Cache jejak itu sendiri di dalam mesin virtual terlihat seperti ini: </p><br><pre> <code class="cpp hljs">trace trace_cache[MAX_CODE_LEN];</code> </pre> <br><p>  Ini hanya array jejak dengan panjang tidak melebihi panjang bytecode yang mungkin.  Solusinya malas, untuk menghemat memori masuk akal untuk menggunakan tabel hash. </p><br><p>  Di awal penerjemah, penangan pertama dari setiap jejak akan mengkompilasi dirinya sendiri: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> trace_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; trace_i &lt; MAX_CODE_LEN; trace_i++ ) vm_trace.trace_cache[trace_i][<span class="hljs-number"><span class="hljs-number">0</span></span>].handler = trace_compile_handler;</code> </pre> <br><p>  Lingkaran juru bahasa utama sekarang terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(vm_trace.is_running) { scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][<span class="hljs-number"><span class="hljs-number">0</span></span>]; code-&gt;handler(code); }</code> </pre> <br><p>  Sebuah kompiler jejak sedikit lebih rumit, dan selain membangun jejak mulai dari instruksi saat ini, ia melakukan hal berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_compile_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *trace_head)</span></span></span><span class="hljs-function"> </span></span>{ scode *trace_tail = trace_head; <span class="hljs-comment"><span class="hljs-comment">/* * Trace building here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* now, run the chain that has a trace_compile_handler replaced with proper instruction handler * function pointer */</span></span> trace_head-&gt;handler(trace_head); }</code> </pre><br><p>  Penangan instruksi normal: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_add_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-comment"><span class="hljs-comment">/* * Call the next trace handler * */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */</span></span> code++; code-&gt;handler(code); }</code> </pre> <br><p>  Pawang yang tidak melakukan panggilan apa pun di ujung fungsi mengakhiri setiap jejak: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) code; vm_trace.is_running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vm_trace.error = SUCCESS; }</code> </pre> <br><p>  Semua ini, tentu saja, lebih rumit daripada menambahkan superinstructions, tetapi mari kita lihat apakah itu memberi kita sesuatu: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 427ms PROFILE: switch code (no range check) finished took 395ms PROFILE: trace code finished took 367ms</code> </pre> <br><p>  Hore, 30 milidetik lagi! </p><br><p>  Bagaimana bisa begitu?  Alih-alih hanya menavigasi melalui label, kami membuat rantai panggilan penangan instruksi, menghabiskan waktu untuk panggilan dan melewati argumen, tapi celengan kami masih berjalan di sepanjang trek lebih cepat daripada saklar sederhana dengan labelnya. </p><br><p>  Keuntungan dalam kinerja trek ini dicapai karena tiga faktor: </p><br><ol><li>  Memprediksi cabang yang tersebar di berbagai tempat dalam kode itu mudah. </li><li>  Argumen penangan selalu disandikan ke dalam kata mesin lengkap, dan ini dilakukan hanya sekali - selama kompilasi jejak. </li><li>  Kompiler mengubah rantai fungsi menjadi satu panggilan ke fungsi penangan pertama, yang dimungkinkan karena optimalisasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panggilan ekor</a> . </li></ol><br><p>  Sebelum merangkum hasil pelatihan kami, anak babi itu dan saya memutuskan untuk mencoba teknik kuno lain untuk menafsirkan program - kode dijahit. </p><br><h1 id="uprazhnenie-chetvertoe-shityy-kod">  Latihan Empat: kode "dijahit" </h1><br><p>  Setiap babi yang tertarik dengan sejarah penerjemah mendengar kode ulir.  Ada banyak opsi untuk teknik ini, tetapi semuanya mendidih alih-alih melalui array opcode, misalnya, pointer ke fungsi atau label, mengikuti secara langsung tanpa opcode perantara. </p><br><p>  Fungsi panggilan adalah bisnis yang mahal dan tidak berarti akhir-akhir ini;  sebagian besar versi lain dari kode dijahit tidak dapat diwujudkan dalam kerangka standar C. Bahkan teknik, yang akan dibahas di bawah ini, menggunakan ekstensi C - pointer ekstensi yang tidak standar untuk label. </p><br><p>  Dalam versi kode dijahit (kode token berbahasa Inggris) yang saya pilih untuk mencapai tujuan babi kami, kami menyimpan bytecode, tetapi sebelum memulai interpretasi, kami membuat tabel yang menampilkan opcodes instruksi ke alamat label penangan instruksi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *labels[] = { [OP_PUSHI] = &amp;&amp;op_pushi, [OP_LOADI] = &amp;&amp;op_loadi, [OP_LOADADDI] = &amp;&amp;op_loadaddi, [OP_STORE] = &amp;&amp;op_store, [OP_STOREI] = &amp;&amp;op_storei, [OP_LOAD] = &amp;&amp;op_load, [OP_DUP] = &amp;&amp;op_dup, [OP_DISCARD] = &amp;&amp;op_discard, [OP_ADD] = &amp;&amp;op_add, [OP_ADDI] = &amp;&amp;op_addi, [OP_SUB] = &amp;&amp;op_sub, [OP_DIV] = &amp;&amp;op_div, [OP_MUL] = &amp;&amp;op_mul, [OP_JUMP] = &amp;&amp;op_jump, [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true, [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false, [OP_EQUAL] = &amp;&amp;op_equal, [OP_LESS] = &amp;&amp;op_less, [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal, [OP_GREATER] = &amp;&amp;op_greater, [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal, [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali, [OP_POP_RES] = &amp;&amp;op_pop_res, [OP_DONE] = &amp;&amp;op_done, [OP_PRINT] = &amp;&amp;op_print, [OP_ABORT] = &amp;&amp;op_abort, };</code> </pre> <br><p>  Perhatikan simbol &amp;&amp; - ini adalah petunjuk ke label dengan isi instruksi, ekstensi paling tidak standar dari GCC. </p><br><p>  Untuk mulai mengeksekusi kode, cukup klik pada pointer yang sesuai dengan opcode pertama program: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()];</code> </pre> <br><p>  Tidak ada siklus di sini dan tidak akan ada, masing-masing instruksi itu sendiri membuat lompatan ke penangan berikut: </p><br><pre> <code class="cpp hljs">op_pushi: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-comment"><span class="hljs-comment">/* jump to the next instruction*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()]; }</code> </pre> <br><p>  Tidak adanya saklar “menyebar” menunjukkan titik-titik di sepanjang badan-badan instruksi, yang secara teori harus membantu prediktor cabang dalam hal pelaksanaan instruksi yang luar biasa.  Seolah-olah kami membuat saklar langsung ke dalam instruksi dan secara manual membentuk tabel transisi. </p><br><p>  Itulah keseluruhan tekniknya.  Dia menyukai anak babi karena kesederhanaannya.  Mari kita lihat apa yang terjadi dalam praktik: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 443ms PROFILE: switch code (no range check) finished took 389ms PROFILE: threaded code finished took 477ms PROFILE: trace code finished took 364ms</code> </pre> <br><p>  Ups!  Ini adalah yang paling lambat dari semua teknik kami!  Apa yang terjadi  Mari kita jalankan tes yang sama, matikan semua optimasi GCC: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 969ms PROFILE: switch code (no range check) finished took 940ms PROFILE: threaded code finished took 824ms PROFILE: trace code finished took 1169ms</code> </pre> <br><p>  Di sini, kode yang dijahit berkinerja lebih baik. </p><br><p>  Tiga faktor berperan di sini: </p><br><ol><li>  Kompilator pengoptimal itu sendiri akan membuat tabel konversi tidak lebih buruk dari plat label manual kami. </li><li>  Kompiler modern sangat menyingkirkan panggilan fungsi tambahan. </li><li>  Mulai sekitar generasi prosesor Intel Haswell, prediktor cabang telah belajar untuk memprediksi transisi secara akurat di satu titik cabang. </li></ol><br><p>  Menurut memori lama, teknik ini masih digunakan dalam kode, misalnya, interpreter Python VM, tetapi, terus terang, hari ini sudah arkaisme. </p><br><p>  Mari kita meringkas dan mengevaluasi keberhasilan yang dicapai oleh babi kita. </p><br><h1 id="razbor-porosyachih-poletov">  Tanya jawab </h1><br><p><img src="https://habrastorage.org/webt/co/vy/6k/covy6k28ts8__ozuzuswtqpcora.jpeg"><br>  Saya tidak yakin apa ini bisa disebut penerbangan, tapi mari kita hadapi itu, babi kami telah menempuh perjalanan jauh dari 550 milidetik selama seratus kali berjalan di atas "saringan" hingga 370 milidetik terakhir.  Kami menggunakan teknik yang berbeda: instruksi super, menghilangkan interval waktu nilai, mekanisme rumit jejak dan, akhirnya, bahkan kode dijahit.  Pada saat yang sama, kami, secara umum, bertindak dalam kerangka hal-hal yang diterapkan dalam semua kompiler populer C. Akselerasi sebanyak satu setengah kali, seperti yang menurut saya, adalah hasil yang baik, dan anak babi itu layak mendapat porsi ekstra dedak di bak. </p><br><p>  Salah satu kondisi implisit yang kami tetapkan untuk diri sendiri dengan babi adalah untuk melestarikan arsitektur tumpukan mesin VM Piglet.  Transisi untuk mendaftarkan arsitektur, sebagai suatu peraturan, mengurangi jumlah instruksi yang diperlukan untuk logika program dan, dengan demikian, dapat membantu menyingkirkan pintu keluar yang tidak perlu ke manajer instruksi.  Saya pikir 10-20% lagi dari waktu ini dapat terputus. </p><br><p>  Kondisi utama kami - kurangnya kompilasi dinamis - juga bukan hukum alam.  Memompa babi dengan steroid dalam bentuk kompilasi JIT sangat mudah akhir-akhir ini: di perpustakaan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU Lightning</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LibJIT,</a> semua pekerjaan kotor telah dilakukan.  Tetapi waktu pengembangan dan jumlah total kode bahkan menggunakan perpustakaan tumbuh sangat pesat. </p><br><p>  Tentu saja ada trik-trik lain yang tidak dapat dicapai oleh babi kecil kita.    ,     —       - —    - .         ,       . </p><br><p> <strong>PS</strong>    ,  ,   ,   ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.instagram.com/vovazomb/</a> ),   . </p><br><p> <strong>PPS</strong>       ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">true-grue</a> -           — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PigletC</a> .     ! </p><br><p> <strong>PPPS</strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">iliazeus</a>    :      .            ;             .      <a href=""></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428878/">https://habr.com/ru/post/id428878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428866/index.html">7 prinsip desain, sikap terhadap tren desain, portofolio desainer-UX, ...</a></li>
<li><a href="../id428868/index.html">JAR multi-rilis - Buruk atau Bagus?</a></li>
<li><a href="../id428870/index.html">Mrr: Total FRP untuk React</a></li>
<li><a href="../id428872/index.html">Kisah tentang satu mata dan 20 operasi (tidak dapat dibaca) atau dia ingin menjadi pilot, tetapi dia tidak diizinkan masuk ke langit.</a></li>
<li><a href="../id428876/index.html">Tidak ada jalan untuk kembali: pengalaman pribadi penguji</a></li>
<li><a href="../id428880/index.html">Metode otentikasi baru - ancaman terhadap privasi?</a></li>
<li><a href="../id428882/index.html">Ponsel Yandex. Blitz: kami menganalisis tugas</a></li>
<li><a href="../id428888/index.html">qml: kekuatan dan kesederhanaan</a></li>
<li><a href="../id428890/index.html">Seluruh kebenaran tentang RTOS. Artikel # 18. Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a></li>
<li><a href="../id428892/index.html">Cara membuat game AI: panduan untuk pemula</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>