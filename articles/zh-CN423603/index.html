<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🧓🏽 🔅 RxSwift第1部分 👨🏼‍🎨 🌄 👨🏿‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="早上好，哈布罗夫斯克。 在本系列文章中，我想谈谈反应式编程，即框架 
 RxSwift 。 在Habré和网络上有关于RxSwift的文章，但我认为，对于初学者来说，这些文章太难了。 因此，如果您开始了解iOS中的反应式编程，那么我会要求猫。 


 让我们从定义什么是反应式编程开始。 
 响应式编...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxSwift第1部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423603/"><p><img src="https://habrastorage.org/getpro/habr/post_images/ef0/3cf/97f/ef03cf97fa0f28bc4204634d7742d6af.jpg" alt="ReactiveX logo" title="反应性"></p><br><p> 早上好，哈布罗夫斯克。 在本系列文章中，我想谈谈反应式编程，即框架 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxSwift</a> 。 在Habré和网络上有关于RxSwift的文章，但我认为，对于初学者来说，这些文章太难了。 因此，如果您开始了解iOS中的反应式编程，那么我会要求猫。 </p><a name="habracut"></a><br><p> 让我们从定义什么是反应式编程开始。 </p><br><blockquote> 响应式编程是一种编程范例，专注于数据流和变更的传播。 </blockquote><p> 那就是伟大的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基百科</a>告诉我们的。 </p><br><p>换句话说，当我们以命令式编程时，我们在代码中编写了必须顺序执行的一组命令。 反应式编程风格遵循其他几个概念。 通过反应式编程风格，我们的程序是观察对象中状态变化的“侦听器”。 听起来很复杂，但事实并非如此，仅此一个概念就足够了，一切将变得非常容易和清晰， <del> 尚无错误 </del>  。 </p><br><p> 我不会画出如何安装框架，只需单击<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接即可</a>轻松完成。 让我们开始练习。 </p><br><h2 id="observable"> 可观察的 </h2><br><p> 让我们从简单但重要的可观察或可观察开始。 可观察的是将为我们提供数据的东西，它是生成数据流所必需的。 </p><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observable = Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;.just(<span class="hljs-string"><span class="hljs-string">" observable"</span></span>)</code> </pre> <br><p>  <strong>宾果</strong> ！ 我们创建了第一个可观察的。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/750/94a/4b0/75094a4b0a1e2744a89382727fde51bb.jpg" alt="那又怎样"></p><br><p> 由于创建了观察对象，因此逻辑上需要创建一个将观察的对象。 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observable = Observable&lt;String&gt;.just(<span class="hljs-string"><span class="hljs-string">" observable"</span></span>) _ = observable.subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">) }</span></span></code> </pre> <br><p> 我们在日志中得到以下内容： </p><br><pre> <code class="hljs lisp">next( observable) completed</code> </pre> <br><p><img src="https://habrastorage.org/webt/6d/8y/mo/6d8ymogkm6b0yvgdmvryssbv4ha.jpeg" alt="完成了吗"></p><br><p>  Observable向我们发送有关其事件的信息，只有3种类型： </p><br><ul><li> 下一个 </li><li> 错误 </li><li> 已完成 </li></ul><br><p> 我们发送的元素以及我们发送的所有事件与<em>下一个</em>元素一起出现，在发生<em>错误的</em>情况下， <em>错误</em>将按照名称的含义发送，在可观察对象发送所有数据并结束操作的情况下，错误将<em>完成</em> 。 </p><br><p> 我们可以创建更详细的 <del> 观察者 </del>  Subscriber'a，并获得更方便的视图来处理所有事件。 </p><br><pre> <code class="hljs mel">_ = observable.subscribe(onNext: { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) }, onError: { (<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>) }, onCompleted: { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-string"><span class="hljs-string">"finish"</span></span>) }) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-string"><span class="hljs-string">"disposed"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,          }</span></span></code> </pre> <br><pre> <code class="hljs">  finish disposed</code> </pre> <br><p> 可以观察到，您不仅可以从一行创建一个序列，而且不仅可以从一行创建一个序列，还可以在其中放置任何数据类型。 </p><br><pre> <code class="hljs pgsql">let <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) _ = <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>.subscribe { (event) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(event) }</code> </pre> <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... completed</code> </pre> <br><p> 可以从值数组创建Observable。 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observable = Observable&lt;Int&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(array) _ = observable.subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">) }</span></span></code> </pre> <br><pre> <code class="hljs lisp">next(<span class="hljs-number"><span class="hljs-number">1</span></span>) next(<span class="hljs-number"><span class="hljs-number">2</span></span>) next(<span class="hljs-number"><span class="hljs-number">3</span></span>) completed</code> </pre> <br><p> 一个<em>可观察对象</em>可以具有任意数量的<em>Subscriber'ov</em> 。 现在术语，什么是可观察的？ </p><br><p>  <strong>可观察</strong>是所有Rx的基础，Rx异步生成一系列不可变数据，并允许其他人订阅它。 </p><br><h2 id="disposing"> 处置 </h2><br><p> 既然我们知道如何创建序列并订阅它们，我们就需要处理<em>dispose</em> 。 </p><br><p> 重要的是要记住， <em>Observable</em>是“冷”类型，也就是说，我们的<em>Observable</em>在订阅之前不会“发出”任何事件。 在发送错误消息或<em>错误</em>消息（ <em>complete</em> ）之前，observable存在。 如果要显式取消订阅，则可以执行以下操作。 </p><br><pre> <code class="hljs pgsql">// №<span class="hljs-number"><span class="hljs-number">1</span></span> //   let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] // observable    let observable = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) //   observable let <span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span> = observable.subscribe { (event) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(event) } //dispos<span class="hljs-string"><span class="hljs-string">'    subscription.dispose()</span></span></code> </pre> <br><p> 还有更多 <del> 美丽的 </del> 正确的选择。 </p><br><pre> <code class="hljs pgsql">//  "" let bag = DisposeBag() //   let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] // observable    let observable = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) //   observable _ = observable.subscribe { (event) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(event) }.disposed(<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: bag)</code> </pre> <br><p> 因此，我们将订阅添加到回收袋或<em>DisposeBag中</em> 。 <br> 这是为了什么 如果使用订阅未将其添加到包中或未明确调用<em>dispose</em> ，或者在极端情况下，未以任何方式使<em>Observable</em>完成，那么很可能会发生内存泄漏。 在RxSwift中，您将经常使用DisposeBag。 </p><br><h2 id="operators"> 经营者 </h2><br><p> 功能反应式编程（以下为FRP）具有许多内置运算符，用于转换可观察元素。 那里有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rxmarbles</a>站点，您可以看到所有操作员的工作和效果，但是，我们仍然会看看其中的一些。 </p><br><h3 id="map"> 地图 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><strong>map</strong></em></a>运算符经常使用，我认为许多人都很熟悉它，借助它，我们可以转换收到的所有元素。 <br>  <em>一个例子：</em> </p><br><pre> <code class="hljs pgsql">let bag = DisposeBag() let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] let observable = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>).map { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> } _ = observable.subscribe { (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(e) }.disponsed(<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: bag)</code> </pre> <br><p> 我们在控制台中得到什么： </p><br><pre> <code class="hljs lisp">next(<span class="hljs-number"><span class="hljs-number">2</span></span>) next(<span class="hljs-number"><span class="hljs-number">4</span></span>) next(<span class="hljs-number"><span class="hljs-number">6</span></span>) completed</code> </pre> <br><p> 我们采用序列的每个元素，并创建一个新的结果序列。 为了使事情更清楚，最好写下更多。 </p><br><pre> <code class="hljs pgsql">let bag = DisposeBag() let observable = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) //  observable let transformObservable = observable.map { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> } _ = transformObservable.subscribe { (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(e) }.disposed(<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: bag)</code> </pre> <br><h4 id="chto-takoe-0"> 什么是$ 0？ </h4><br><p>  $ 0是元素的名称，默认情况下，我们可以在方法中使用缩写记录和完整记录，最常见的是我们使用缩写记录。 </p><br><pre> <code class="hljs bash">//  <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> transformObservable = observable.map { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> * 2 } //  <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> transformObservable = observable.map { (element) -&gt; Int <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> element * 2 }</code> </pre> <br><p> 同意简写形式要简单得多，对吗？ </p><br><h3 id="filter"> 筛选条件 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过滤</a>运算符允许我们过滤掉可观察对象发出的数据，也就是说，在订阅时，我们不会为我们收到不必要的值。 <br>  <strong>一个例子：</strong> </p><br><pre> <code class="hljs pgsql">let bag = DisposeBag() let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>] // observable   let observable = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) //  <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>,     observable let filteredObservable = observable.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> } // _ = filteredObservable.subscribe { (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(e) }.disposed(<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: bag)</code> </pre> <br><p> 我们在控制台中得到什么？ </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) ... completed</code> </pre> <br><p> 如我们所见，在控制台中，只有那些满足我们条件的值。 </p><br><p> 顺便说一下，可以将运算符组合在一起，这就是如果我们要立即应用过滤运算符和<em>地图</em>运算符时的外观。 </p><br><pre> <code class="hljs pgsql">let bag = DisposeBag() let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>] let observable = Observable&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) let filteredAndMappedObservable = observable .<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> } .map { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> } _ = filteredAndMappedObservable.subscribe { (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(e) }.disposed(<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: bag)</code> </pre> <br><p>  <strong>控制台：</strong> </p><br><pre> <code class="hljs lisp">next(<span class="hljs-number"><span class="hljs-number">6</span></span>) next(<span class="hljs-number"><span class="hljs-number">8</span></span>) next(<span class="hljs-number"><span class="hljs-number">10</span></span>) next(<span class="hljs-number"><span class="hljs-number">12</span></span>) next(<span class="hljs-number"><span class="hljs-number">14</span></span>) completed</code> </pre> <br><h3 id="distinct"> 独特的 </h3><br><p> 与过滤相关的另一个出色的运算符， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">disctinct</a>运算符允许<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您</a>仅跳过更改的数据，最好立即查看示例，一切都会变得清楚。 </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bag = DisposeBag() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observable = Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;.from(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> filteredObservable = observable.distinctUntilChanged() _ = filteredObservable.subscribe { (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(e) }.disposed(by: bag)</code> </pre> <br><p> 在控制台中，我们得到以下信息： </p><br><pre> <code class="hljs lisp">next(<span class="hljs-number"><span class="hljs-number">1</span></span>) next(<span class="hljs-number"><span class="hljs-number">2</span></span>) next(<span class="hljs-number"><span class="hljs-number">3</span></span>) next(<span class="hljs-number"><span class="hljs-number">5</span></span>) next(<span class="hljs-number"><span class="hljs-number">6</span></span>) completed</code> </pre> <br><p> 也就是说，如果序列中的当前元素与前一个元素相同，则将其跳过，依此类推，直到出现与前一个元素不同的元素，这在处理UI（即表）时非常方便，以防我们收到数据与我们现在的相同，则不应该<em>重新加载</em>表。 </p><br><h3 id="takelast">  Takelast </h3><br><p> 一个非常简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">takeLast</a>运算符，我们从末尾开始获取第n个元素。 </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bag = DisposeBag() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observable = Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;.from(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> takeLastObservable = observable.takeLast(<span class="hljs-number"><span class="hljs-number">1</span></span>) _ = takeLastObservable.subscribe { (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(e) }.disposed(by: bag)</code> </pre> <br><p> 在控制台中，我们得到以下信息： </p><br><pre> <code class="hljs lisp">next(<span class="hljs-number"><span class="hljs-number">6</span></span>) completed</code> </pre> <br><h3 id="throttle-i-interval"> 节气门和间隔 </h3><br><p> 然后，我决定一次雇用2位操作员，这是因为在第二个操作员的帮助下，很容易显示第一个操作员的工作。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">节流</a>运算符使您可以在捕获传输的值之间稍作休息，这是一个非常简单的示例，您编写了一个响应式应用程序，使用搜索栏，并且不想每次输入数据时都重新加载表或访问服务器，因此您使用了<em>节流阀</em> ，因此说您是否想每2秒获取一次用户数据（例如，您可以设置任何时间间隔）并减少不必要的处理资源消耗，它如何工作并在代码中进行了描述？ 请参阅下面的示例。 </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> bag = DisposeBag() //observable     0.5    1   0 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> throttleObservable = observable.throttle(1.0, scheduler: MainScheduler.instance) _ = takeLastObservable.subscribe { (event) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"throttle \(event)"</span></span>) }.disposed(by: bag)</code> </pre> <br><p> 在控制台中将是： </p><br><pre> <code class="hljs perl">throttle <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) throttle <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) throttle <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) throttle <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) ...</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">间隔</a>运算符使Observable可以从0.5开始每0.5秒以1为增量生成值，这是Rx的简单计时器。 事实证明，每隔0.5秒生成一次值，然后每秒即可生成2个值（简单的算法），节气门运算符将等待一秒钟并获取最后一个值。 </p><br><h3 id="debounce"> 去抖 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Debounce</a>与先前的声明非常相似，但在我看来有点聪明。 防反跳操作符等待第n个时间，如果它的计时器开始没有变化，它将采用最后一个值，如果我们发送该值，计时器将重新启动。 这对于上一个示例中描述的情况非常有用，用户输入数据，我们等待他完成操作（如果用户不活动一到两个半），然后我们开始执行一些操作。 因此，如果仅更改上一个代码中的运算符，则将无法在控制台中获取值，因为反跳将等待一秒钟，但是每0.5秒它将收到一个新值并重新启动其计时器，因此我们将一无所获。 让我们来看一个例子。 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observable = <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.interval(<span class="hljs-number"><span class="hljs-number">1.5</span></span>, scheduler: <span class="hljs-type"><span class="hljs-type">MainScheduler</span></span>.instance) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> debounceObservable = observable.debounce(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, scheduler: <span class="hljs-type"><span class="hljs-type">MainScheduler</span></span>.instance) <span class="hljs-number"><span class="hljs-number">_</span></span> = debounceObservable.subscribe({ (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"debounce \(e)"</span></span>) }).disposed(by: bag)</code> </pre> <br><p> 在这个阶段，我建议结束操作员，在RxSwift框架中有很多操作员，不能说它们在日常生活中都是非常必要的，但是您仍然需要了解它们的存在，因此建议您熟悉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rxmarbles</a>网站上的操作员的完整列表。 </p><br><h2 id="scheduler"> 排程器 </h2><br><p> 我想在本文中谈到的一个非常重要的主题是调度程序。 调度程序，允许我们在某些线程上运行可观察的对象，它们具有自己的精妙之处。 首先，设置可观察的调度程序有2种类型-[observeOn]（）和[subscribeOn]（）。 </p><br><h3 id="subscribeon"> 订阅 </h3><br><p>  SubscribeOn负责整个观察过程将在其中运行的线程，直到其事件到达处理程序（订阅者）为止。 </p><br><h3 id="observeon"> 观察 </h3><br><p> 您可能会猜到，observeOn负责在哪个流中处理订阅者收到的事件。 </p><br><p> 这是一件很酷的事情，因为我们可以很容易地将网络上的内容下载到后台流中，并在接收到结果后转到主流并以某种方式在UI上进行操作。 </p><br><p> 让我们来看一个例子： </p><br><pre> <code class="hljs lua">let observable = Observable&lt;Int&gt;.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span> { (observer) -&gt; Disposable <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"thread observable -&gt; \(Thread.current)"</span></span>) observer.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>) observer.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Disposables.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>() }.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background)) _ = observable .observeOn(MainScheduler.instance) .subscribe({ (e) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"thread -&gt; \(Thread.current)"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(e) })</code> </pre> <br><p> 在控制台中，我们得到： </p><br><pre> <code class="hljs pgsql">thread observable -&gt; &lt;NSThread: <span class="hljs-number"><span class="hljs-number">0x604000465040</span></span>&gt;{number = <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)} thread -&gt; &lt;NSThread: <span class="hljs-number"><span class="hljs-number">0x60000006f6c0</span></span>&gt;{number = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = main} next(<span class="hljs-number"><span class="hljs-number">1</span></span>) thread -&gt; &lt;NSThread: <span class="hljs-number"><span class="hljs-number">0x60000006f6c0</span></span>&gt;{number = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = main} next(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p> 我们看到在后台线程中创建了observable，并且在主线程中处理了数据。 在使用网络时，这很有用，例如： </p><br><pre> <code class="hljs mel">let rxRequest = URLSession.shared.rx.data(request: URLRequest(url: URL(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-string"><span class="hljs-string">"http://jsonplaceholder.typicode.com/posts/1"</span></span>)!)).subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background)) _ = rxRequest .observeOn(MainScheduler.<span class="hljs-keyword"><span class="hljs-keyword">instance</span></span>) .subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-string"><span class="hljs-string">" \(event)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-string"><span class="hljs-string">"thread \(Thread.current)"</span></span>) }</code> </pre> <br><p> 因此，该请求将在后台线程中执行，并且所有响应处理都将在主线程中进行。 在这个阶段，现在说出什么<em>样的</em> <em>rx</em>方法<em>URLSession</em>突然<em>产生</em>还<em>为时过早</em> ，这将在后面讨论，该代码作为使用<em>Scheduler</em>的示例给出，顺便说一下，我们将对控制台获得以下响应。 </p><br><pre> <code class="hljs pgsql">curl -X <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> "http://jsonplaceholder.typicode.com/posts/1" -i -v Success (<span class="hljs-number"><span class="hljs-number">305</span></span>ms): Status <span class="hljs-number"><span class="hljs-number">200</span></span> ** next(<span class="hljs-number"><span class="hljs-number">292</span></span> bytes)** thread -&gt; &lt;NSThread: <span class="hljs-number"><span class="hljs-number">0x600000072580</span></span>&gt;{number = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = main}  completed thread -&gt; &lt;NSThread: <span class="hljs-number"><span class="hljs-number">0x600000072580</span></span>&gt;{number = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = main}</code> </pre> <br><p> 在结局中，让我们看看收到了什么<em>样的数据</em> ，为此，我们将必须执行检查，以免意外地分析完成的消息。 </p><br><pre> <code class="hljs mel">_ = rxRequest .observeOn(MainScheduler.<span class="hljs-keyword"><span class="hljs-keyword">instance</span></span>) .subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.isCompleted &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">error</span></span> == nil) { let json = try? JSONSerialization.jsonObject(with: <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.element!, options: []) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(json!) } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-string"><span class="hljs-string">"data -&gt; \(event)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-string"><span class="hljs-string">"thread -&gt; \(Thread.current)"</span></span>) }</code> </pre> <br><p> 尽管可以实现不同的订阅方法并单独处理所有这些类型的事件，但我们检查该事件不是可观察到的关闭消息或来自它的错误，但是您可以自己执行此操作，我们将在控制台中提供以下内容。 </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> -X GET <span class="hljs-string"><span class="hljs-string">"http://jsonplaceholder.typicode.com/posts/1"</span></span> -i -v Success (<span class="hljs-number"><span class="hljs-number">182ms</span></span>): Status <span class="hljs-number"><span class="hljs-number">200</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">body</span></span> = <span class="hljs-string"><span class="hljs-string">"quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">title</span></span> = <span class="hljs-string"><span class="hljs-string">"sunt aut facere repellat provident occaecati excepturi optio reprehenderit"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">userId</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">data</span></span> -&gt; next(<span class="hljs-number"><span class="hljs-number">292</span></span> bytes) thread -&gt; &lt;NSThread: 0x60400006c6c0&gt;{<span class="hljs-attribute"><span class="hljs-attribute">number</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = main} data -&gt; completed thread -&gt; &lt;NSThread: 0x60400006c6c0&gt;{<span class="hljs-attribute"><span class="hljs-attribute">number</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = main}</code> </pre> <br><p> 收到的数据:-) </p><br><h2 id="subjects"> 科目 </h2><br><p> 我们转向热点，即从可观察到的“冷”或“被动”到可观察到的“热点”或“主动”，这被称为主体。 如果在此之前，我们的观察员只有在订阅他们之后才开始工作，而您的脑子里有一个问题，“为什么我需要所有这些？”，那么主题总是工作，并且总是发送接收到的数据。 </p><br><p> 怎么了 在可观察的情况下，我们去了诊所，去了邪恶的奶奶 <del> 接待处 </del> 到接待处，他们走近，问我们应该去哪个办公室，然后颗粒剂回答了我们。如果是受试者，颗粒剂会站立并听取医生在医院的时间表和状况，并在收到有关任何医生活动的信息后立即说，问某些东西对于制粒是无用的，我们可以上来，听她的话，离开，然后她会继续说，通过比较，有些东西被带走了，让我们开始编写代码。 </p><br><p> 让我们创建一个主题和2个订阅者，在主题之后创建第一个主题，将值发送给主题，然后创建第二个主题并发送另外两个值。 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = PublishSubject&lt;Int&gt;() subject.subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) _</span></span> = subject.subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">) subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">) subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p> 我们将在控制台中看到什么？ 是的，第一个设法获得了第一个事件，但是第二个却没有。 </p><br><pre> <code class="hljs perl">  <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><p> 已经更适合您的反应式编程想法了吗？ <br> 主题有几种形式；它们在发送值的方式上都不同。 </p><br><p>  PublishSubject是最简单的一个，它对所有内容都无关紧要，它只是向所有订阅者发送所收到的信息，而忘记了它。 </p><br><p>  ReplaySubject-这是最重要的，在创建时，我们告诉它缓冲区的大小（将记住多少个值），结果，它将最后n个值存储在内存中，并将它们立即发送给新的订户。 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = ReplaySubject&lt;Int&gt;.create(bufferSize: <span class="hljs-number"><span class="hljs-number">3</span></span>) subject.subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) subject.subscribe</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">) subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">) subject.subscribe</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p> 我们看一下控制台 </p><br><pre> <code class="hljs perl">  <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><p>  BehaviorSubject不是上一个废话，它有一个起始值，它会记住最后一个值，并在订阅者订阅后立即发送。 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = BehaviorSubject&lt;Int&gt;(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>) subject.subscribe { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) subject.subscribe</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">) subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">) subject.subscribe</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"  \(event)"</span></span></span></span></span><span class="hljs-function">) } subject.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p> 主控台 </p><br><pre> <code class="hljs perl">  <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 这是一篇介绍性文章，以便您了解基础知识并随后可以在其基础上进行构建。 在以下文章中，我们将研究如何通过iOS UI组件使用RxSwift，并为UI组件创建扩展。 </p><br><h3 id="ne-rxswiftom-ediny"> 不RxSwift'om团结 </h3><br><p> 响应式编程不仅在RxSwift库中实现，还有几种实现，其中最流行的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReacktiveKit / Bond</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReactiveSwift / ReactiveCocoa</a> 。 它们在幕后的实现方式上都有细微的差别，但是我认为最好使用RxSwift来开始对reactivism的了解，因为它是其中最受欢迎的一种，并且在出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google中</a>会有更多的答案，但是在您之后了解此概念的本质后，您可以根据自己的喜好和颜色选择资料库。 <br>  <em>文章作者：Pavel Grechikhin</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423603/">https://habr.com/ru/post/zh-CN423603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423591/index.html">关于主要内容的旧歌。 Java和外发请求</a></li>
<li><a href="../zh-CN423593/index.html">Google宣布一项针对机器视觉算法的攻击竞赛</a></li>
<li><a href="../zh-CN423595/index.html">Frango Anomaly，交汇处</a></li>
<li><a href="../zh-CN423597/index.html">如何以及在客户群中分配哪些集群</a></li>
<li><a href="../zh-CN423601/index.html">工作系统和搜索路径</a></li>
<li><a href="../zh-CN423607/index.html">莱纳斯·托瓦尔兹（Linus Torvalds）放弃了硬派风格并抽出时间</a></li>
<li><a href="../zh-CN423609/index.html">网站死后该去哪里？ 个人经历</a></li>
<li><a href="../zh-CN423611/index.html">一键式付款-好还是坏？</a></li>
<li><a href="../zh-CN423615/index.html">用户体验专家要求的专业技能（2018年切片）</a></li>
<li><a href="../zh-CN423617/index.html">使用iPhone电池设计可穿戴电子设备</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>