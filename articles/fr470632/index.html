<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏿 🤟🏿 🧗 Arend - Langage de type dépendant basé sur HoTT (partie 2) 👁‍🗨 🎀 🐑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la première partie de l'article sur le langage Arend, nous avons examiné les types inductifs les plus simples, les fonctions récursives, les clas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - Langage de type dépendant basé sur HoTT (partie 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans la première partie de l'article</a> sur le langage Arend, nous avons examiné les types inductifs les plus simples, les fonctions récursives, les classes et les ensembles. <br><br><h2>  2. Listes de tri à Arend </h2><br><h3>  2.1 Listes ordonnées à Arend </h3><br>  Nous définissons le type de listes ordonnées comme une paire composée d'une liste et d'une preuve de son ordre.  Comme nous l'avons déjà dit, dans Arend, les paires dépendantes sont définies à l'aide du mot clé <code>\Sigma</code> .  Nous donnons la définition du type <code>Sorted</code> par comparaison avec l'échantillon, inspiré de la définition de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> déjà mentionné <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur les listes ordonnées.</a> <br><br><pre> <code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l) \data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs | nil =&gt; nilSorted | :-: x nil =&gt; singletonSorted | :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code> </pre> <br>  Remarque: Arend a pu déduire automatiquement que le type <code>Sorted</code> est contenu dans l'univers <code>\Prop</code> .  Cela s'est produit parce que les trois modèles de la définition <code>consSorted</code> s'excluent mutuellement et que le constructeur <code>consSorted</code> a deux paramètres, qui appartiennent tous deux à <code>\Prop</code> . <br>  Prouvons une propriété évidente du prédicat <code>Sorted</code> , disons que la queue d'une liste ordonnée est elle-même une liste ordonnée (cette propriété nous sera utile à l'avenir). <br><a name="habracut"></a><br><pre> <code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A | nil, _ =&gt; nilSorted | :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code> </pre> <br>  Dans l' <code>tail-sorted</code> la <code>tail-sorted</code> nous avons utilisé la correspondance de modèles sur la liste <code>xs</code> et le prédicat <code>tail-sorted</code> même temps, en outre, nous avons utilisé le <i>caractère de saut</i> «_», qui peut être substitué aux variables inutilisées. <br><br>  On peut se demander s'il est possible à Arend de prouver la propriété des listes ordonnées, mentionnées dans la section 1.3 comme exemple d'un fait qui ne peut être prouvé dans Agda sans annotations d'immatérialité.  Rappelons que cette propriété prétend que pour prouver l'égalité des listes ordonnées définies par des paires dépendantes, il suffit de vérifier l'égalité des premiers composants des paires. <br><br>  On fait valoir que dans Arend cette propriété est facilement obtenue en conséquence de la construction <code>inProp</code> mentionnée ci-dessus et de la propriété d'extensionnalité pour les paires <code>SigmaExt</code> dépendantes. <br><br><pre> <code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 =&gt; SigmaPropExt Sorted l1 l2 P</code> </pre> <br>  La propriété <code>SigmaPropExt</code> prouvée dans le module <a href="">Paths</a> de la bibliothèque standard, et de nombreux autres faits du deuxième chapitre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du livre HoTT</a> , y compris la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propriété de l'extensionnalité fonctionnelle</a> , y sont également prouvés. <br><br>  L'opérateur <code>.n</code> utilisé dans Arend pour accéder au projecteur de type sigma avec le numéro n (dans notre cas, le type sigma est <code>SortedList A</code> , et l'expression <code>l1.1</code> signifie que le premier composant de ce type est une expression de type <code>List A</code> ). <br><br><h3>  2.2 Implémentation de la propriété «be permutation» </h3><br>  Essayons maintenant d'implémenter la fonction de tri de liste sur Arend.  Naturellement, nous voulons avoir non pas une simple implémentation de l'algorithme de tri, mais une implémentation avec une preuve de certaines propriétés. <br><br>  En clair, cet algorithme doit avoir au moins 2 propriétés: <br>  1. Le résultat de l'algorithme doit être une liste ordonnée. <br>  2. La liste résultante doit être une permutation de la liste d'origine. <br><br>  Tout d'abord, essayons d'implémenter la propriété "be permutation" des listes sur Arend.  Pour ce faire, nous adaptons la définition prise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> pour Arend. <br><br><pre> <code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys | xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys) | :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys) \truncated \data Perm {A : \Set} (xs ys : List A) : \Prop | permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys) | permTrivial (xs = ys)</code> </pre> <br>  Le prédicat <code>InsertSpec</code> introduit par nous a la signification intuitive suivante: <code>InsertSpec xs a ys</code> signifie exactement que la liste <code>ys</code> est le résultat de l'insertion de l'élément a à l'intérieur de la liste <code>xs</code> (à n'importe quelle position).  Ainsi, <code>InsertSpec</code> peut être considéré comme une spécification de la fonction d'insertion. <br><br>  De toute évidence, le type de données <code>Perm</code> définit vraiment la relation «be permutation»: le constructeur <code>permInsert</code> exactement que <code>xs</code> et <code>ys</code> sont mutuellement permutables si <code>xs</code> et <code>ys</code> sont obtenus en insérant le même élément a dans certaines listes <code>xs'</code> et <code>ys'</code> des longueurs plus courtes, qui sont déjà permutations les unes des autres. <br><br>  Pour notre définition de la propriété «be permutation», il est facile de vérifier la propriété de symétrie. <br><br><pre> <code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P | permTrivial xs=ys =&gt; permTrivial (inv xs=ys) | permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code> </pre> <br>  La propriété de transitivité est également satisfaite pour <code>Perm</code> , mais sa vérification est beaucoup plus compliquée.  Cette propriété ne jouant aucun rôle dans l'implémentation de notre algorithme de tri, nous laissons le lecteur s'exercer. <br><br><pre> <code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code> </pre> <br><h3>  2.3 Changement des niveaux d'homotopie par rapport à l'échantillon </h3><br>  Essayons maintenant d'implémenter une fonction qui insère un élément dans une liste ordonnée afin que la liste résultante reste ordonnée.  Commençons par l'implémentation naïve suivante. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case LinearOrder.trichotomy xy \with {  | byLeft x=y =&gt; x :-: insert xs' y  | byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y  | byRight (byRight y&lt;x) =&gt; y :-: x :-: xs' }</code> </pre> <br>  La construction <code>\case</code> permet la correspondance avec un échantillon d'une expression arbitraire ( <code>\elim</code> ne peut être utilisé qu'au plus haut niveau d'une définition de fonction et uniquement pour ses paramètres).  Si vous demandez à Arend de vérifier le type d' <code>insert</code> , le message d'erreur suivant s'affiche. <br><br><pre> <code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop  which does not fit in the universe of the eliminator type: List OE In: | byLeft x-leq-y =&gt; x :-: insert xs' y While processing: insert</code> </pre> <br>  Le problème est que dans la classe <code>LinearOrder.Dec</code> définition de la <code>trichotomy</code> donnée en utilisant l'opérateur <code>||</code>  , qui, à son tour, est déterminée à l'aide de la troncature propositionnelle.  Comme déjà mentionné, pour les types appartenant à l'univers <code>\Prop</code> , la correspondance avec un modèle dans Arend n'est autorisée que si le type de l'expression résultante est lui-même une assertion (pour la fonction ci-dessus, le résultat est de type <code>List OE</code> et ce type est un ensemble). <br><br>  Existe-t-il un moyen de contourner ce problème?  La manière la plus simple de résoudre ce problème consiste à modifier la définition de la propriété de la trichotomie.  Considérez la définition suivante de la trichotomie, en utilisant le type non tronqué <code>Or</code> au lieu du tronqué <code>||</code>  : <br><br><pre> <code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (xy : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code> </pre> <br>  Cette définition <code>trichotomy</code> t-elle en quoi que ce soit de la définition originale de <code>trichotomy</code> par <code>||</code>  ?  Pourquoi avons-nous même utilisé un type propositionnellement tronqué si cela ne fait que compliquer notre vie et nous empêche d'utiliser la correspondance de modèles? <br><br>  Essayons de répondre à la première question pour commencer: pour les ordres <code>StrictPoset</code> stricts <code>StrictPoset</code> différence entre <code>trichotomy</code> et <code>set-trichotomy</code> n'est en fait pas du tout.  Notez que le type <code>set-trichotomy</code> est une déclaration.  Ce fait découle du fait que les trois alternatives dans la définition de la trichotomie s'excluent mutuellement en raison des axiomes d'ordre, et chacun des trois types <code>x = y, x &lt; y, y &lt; x</code> est lui-même une déclaration ( <code>x = y</code> est une déclaration, donc comme dans la définition de la classe <code>BaseSet</code> nous avons exigé que le média <code>E</code> un ensemble!). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (xy : A) (l1 l2 : set-trichotomy xy): l1 = l2 \elim l1, l2 | inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2) | inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2) | inr l1, inr l2 =&gt; pmap inr (Path.inProp l1 l2) | inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2) | inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1) | inl (inl l1), inr l2 =&gt; absurd (lt-eq-false (inv l1) l2) | inr l1, inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1) | inl (inr l1), inr l2 =&gt; absurd (lt-lt-false l1 l2) | inr l1, inl (inr l2) =&gt; absurd (lt-lt-false l2 l1) \where {  \func lt-eq-false {A : StrictPoset} {xy : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;    A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)  \func lt-lt-false {A : StrictPoset} {xy : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;   A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2) }</code> </pre> <br>  Dans la liste ci-dessus, <code>absurd</code> est la désignation du principe ex falso quodlibet, qui est défini dans le module <a href="">Logic</a> .  Le type <code>Empty</code> n'ayant pas de constructeur dans la définition (voir section 1.2), il n'est pas nécessaire de passer par des cas dans la définition d' <code>absurd</code> : <br><br><pre> <code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code> </pre> <br>  Puisque nous savons maintenant que <code>set-trichotomy</code> est une déclaration, nous pouvons dériver la propriété <code>set-trichotomy</code> propriété de <code>trichotomy</code> habituelle des ordres décidables.  Pour ce faire, nous pouvons utiliser la construction <code>\return \level</code> , qui indique au temporisateur Arend qu'à ce stade, la correspondance avec le modèle est une opération autorisée (dans ce cas, nous devons montrer la preuve que le résultat de la fonction <code>set-trichotomy-property</code> est une instruction). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (xy : A) : set-trichotomy xy =&gt; \case A.trichotomy xy \return \level (set-trichotomy xy) (set-trichotomy-isProp xy) \with {  | byLeft x=y =&gt; inl (inl x=y)  | byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)  | byRight (byRight y&lt;x) =&gt; inr (y&lt;x) }</code> </pre> <br>  Essayons maintenant de répondre à la deuxième question, à savoir pourquoi il est préférable d'utiliser des constructions non ordinaires, mais propositionnellement tronquées lors de la formulation des propriétés des objets mathématiques.  Considérez pour cela un fragment de la définition des ordres linéaires non linéaires (les définitions complètes de <code>Lattice</code> et <code>TotalOrder</code> peuvent être trouvées dans le module <a href="">LinearOrder</a> ): <br><br><pre> <code class="plaintext hljs">\class TotalOrder \extends Lattice { | totality (xy : E) : x &lt;= y || y &lt;= x }</code> </pre> <br>  Essayons maintenant d’imaginer comment la signification de la classe <code>TotalOrder</code> changerait si nous écrivions la définition du champ de totalité par la construction <code>Or</code> non tronquée. <br><br><pre> <code class="plaintext hljs">\class BadTotalOrder \extends Lattice { | badTotality (xy : E) : (x &lt;= y) `Or` (y &lt;= x) }</code> </pre> <br>  Dans ce cas, le type <code>(x &lt;= y) `Or` (y &lt;= x)</code> n'est plus une instruction, car  en cas de valeurs égales de <code>x</code> et <code>y</code> deux alternatives dans la définition de <code>badTotality</code> peuvent être mises en œuvre, et le choix de la branche gauche ou droite dans la preuve de <code>badTotality</code> absolument arbitraire et reste à la discrétion de l'utilisateur - il n'y a aucune raison de préférer un constructeur <code>Or</code> à un autre. <br><br>  Maintenant, il est clair quelle est la différence entre <code>TotalOrder</code> et <code>BadTotalOrder</code> .  Deux ensembles ordonnés <code>O1 O2</code> : <code>TotalOrder</code> sont toujours égaux lorsqu'il est possible de prouver l'égalité des ensembles <code>O1.E, O2.E</code> et des ordres <code>O1.&lt;, O2.&lt;</code> Étant donné sur eux (c'est la propriété souhaitée).  En revanche, pour <code>O1 O2</code> : <code>BadTotalOrder</code> il est <code>BadTotalOrder</code> de prouver l'égalité de <code>O1</code> et <code>O2</code> uniquement lorsque, en plus de tous les éléments <code>x</code> de <code>E</code> égalité <code>O1.badTotality xx</code> et <code>O2.badTotality xx</code> . <br><br>  Ainsi, il s'avère que la classe <code>BadTotalOrder</code> doit intuitivement être considérée non pas comme un "ensemble ordonné linéairement", mais comme un "ensemble ordonné linéairement avec le choix pour chaque élément <code>x</code> champ <code>E</code> branche gauche ou droite <code>Or</code> dans l'implémentation de <code>badTotality xx</code> ". <br><br><h3>  2.4 Algorithme de tri </h3><br>  Nous allons maintenant mettre en œuvre l'algorithme de tri.  Essayons de corriger l'implémentation naïve de la fonction d' <code>insert</code> de la section précédente en utilisant la <code>set-trichotomy-property</code> éprouvée (dans ce cas, en raison de la disposition plus réussie des crochets dans la définition de la <code>set-trichotomy</code> , nous avons réduit le nombre de cas considérés). <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; y :-: x :-: xs'  | inl x&lt;=y =&gt; x :-: insert xs' y }</code> </pre> <br>  Essayons maintenant d'implémenter un analogue de cette définition pour les listes ordonnées.  Nous utiliserons la construction spéciale <code>\let … \in</code> , qui nous permet d'ajouter de nouvelles variables locales au contexte. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs | (nil, _) =&gt; (y :-: nil, singletonSorted) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)  | inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y         \in (x :-: result, {?})</code> </pre> <br>  Nous avons laissé dans la preuve un fragment incomplet (indiqué par l'expression <code>{?}</code> ) À l'endroit où vous souhaitez montrer que la liste <code>x :-: result</code> ordonnée.  Bien qu'il existe des preuves dans le contexte de l'ordre de la liste de <code>result</code> , il reste à vérifier que <code>x</code> ne dépasse pas la valeur du premier élément de la liste de <code>result</code> , ce qui n'est pas si facile à suivre depuis les locaux dans le contexte (pour voir tous les locaux dans la cible actuelle - c'est ce que nous appelons branche actuelle des calculs - vous devez demander une vérification de type à la fonction d' <code>insert</code> ). <br><br>  Il s'avère que l' <code>insert</code> beaucoup plus facile à implémenter si nous prouvons l'ordre de la liste résultante en parallèle avec la preuve de la spécification de l' <code>insert</code> .  Modifiez la signature de l' <code>insert</code> et écrivez la preuve de cette spécification dans les cas les plus simples: <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)  | inl x&lt;=y =&gt;   \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y   \in ((x :-: result, {?}), insertedThere idp result-spec)</code> </pre> <br>  Pour un seul fragment laissé sans preuve, Arend affichera la valeur de contexte suivante: <br><br><pre> <code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1) Context:  result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1  xs-sorted : Sorted (x :-: xs')  x : O  x&lt;=y : Or (x = y) (O.&lt; xy)  O : Dec  result : List O  y : O  xs' : List O  result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code> </pre> <br>  Pour compléter la preuve, nous devrons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">toute la puissance de</a> l'opérateur <code>\case</code> : nous utiliserons la correspondance de modèles avec 5 variables différentes, et puisque les types de certaines variables peuvent dépendre des valeurs d'autres variables, nous utiliserons la correspondance de modèles dépendants. <br><br>  La construction des deux points indique explicitement comment le type de certaines variables à comparer dépend de la valeur des autres variables (ainsi, dans le type de variables <code>xs-sorted, result-spec</code> <code>result-sorted</code> par <code>result-sorted</code> dans chacun des <code>\case</code> au lieu de <code>xs'</code> et <code>result</code> correspondra aux échantillons correspondants). <br><br>  La construction <code>\return</code> associe les variables utilisées pour faire correspondre le modèle avec le type de résultat attendu.  En d'autres termes, dans la cible actuelle, dans chacune des clauses <code>\case</code> , l'échantillon correspondant sera substitué à la variable de <code>result</code> .  Sans cette construction, un tel remplacement ne serait pas effectué et l'objectif de toutes les clauses <code>\case</code> coïnciderait avec la cible à la place de l'expression <code>\case</code> elle-même. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs  | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)  | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {   | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)   | inl x&lt;=y =&gt;     \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y     \in ((x :-: result,       \case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'), result-spec : InsertSpec xs' y result, result-sorted : Sorted result       \return Sorted (x :-: result) \with {        | nil, _, _, _, _ =&gt; singletonSorted        | :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted        | :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted }), insertedThere idp result-spec)</code> </pre> <br>  Dans le bloc de code ci-dessus, les premiers arguments complexes du constructeur <code>consSorted</code> dans les deux derniers paragraphes de la comparaison de modèles méritent des commentaires supplémentaires.  Pour comprendre ce que ces deux expressions signifient, nous les remplaçons par l'expression <code>{?}</code> Et demandons au temporisateur Arend de déterminer les cibles aux deux positions. <br><br>  Vous pouvez voir que là et là la cible actuelle est le type <code>(x = r) || O.&lt; xr</code>  <code>(x = r) || O.&lt; xr</code> .  De plus, dans le cadre du premier objectif, il existe des prémisses <br><br><pre> <code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; xy) y=r : y = r</code> </pre> <br>  et dans le cadre du second - locaux <br><br><pre> <code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; xx' x2=r : x' = r.</code> </pre> <br>  Intuitivement clair: pour prouver le premier objectif, il suffit de substituer la variable <code>r</code> dans la déclaration correcte <code>Or (x = y) (O.&lt; xy)</code> , puis de passer au type propositionnellement tronqué <code>||</code>  en utilisant la fonction <code>Or-to-||</code> définie dans la section 1.3  .  Pour prouver le deuxième objectif, il suffit de remplacer par <code>(x = x') || O.&lt; x x'</code>  <code>(x = x') || O.&lt; x x'</code> au lieu de la variable <code>x'</code> variable <code>r</code> . <br><br>  Pour formaliser l'opération de substitution d'expression décrite, une fonction de <code>transport</code> spéciale existe dans la bibliothèque Arend standard.  Considérez sa signature: <br><br><pre> <code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {aa' : A} (p : a = a') (b : B a) : B a'</code> </pre> <br>  Dans notre cas, au lieu de la variable <code>A</code> nous devons remplacer le type <code>OE</code> (il peut être omis explicitement si les autres arguments de <code>transport</code> sont spécifiés), et au lieu de <code>B</code> , l'expression <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code>  <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code> . <br><br>  La mise en œuvre de l'algorithme de tri par insertion avec la spécification ne pose plus de difficultés particulières: pour trier la liste <code>x :-: xs'</code> , nous trions d'abord la queue de la liste <code>xs'</code> aide d'un appel récursif à <code>insertSort</code> , puis insérons l'élément <code>x</code> dans cette liste tout en préservant l'ordre lorsque aider à accéder à la fonction d' <code>insert</code> déjà implémentée. <br><br><pre> <code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : \Sigma (result : SortedList O) (Perm xs result.1) \elim xs | nil =&gt; ((nil, nilSorted), permTrivial idp) | :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'                      | (zs, zs-spec) =&gt; insert ys x                  \in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code> </pre> <br>  Nous avons atteint l'objectif initial et mis en œuvre le tri des listes sur Arend.  Le code Arend complet donné dans ce paragraphe peut être téléchargé dans un fichier à <a href="">partir d'ici</a> . <br><br>  On pourrait se demander comment il faudrait changer l'implémentation de la fonction d' <code>insert</code> si au lieu des ordres <code>LinearOrder.Dec</code> stricts, nous <code>LinearOrder.Dec</code> ordres <code>LinearOrder.Dec</code> non stricts?  Comme nous le rappelons, dans la définition de la fonction de totalité, l'utilisation de l'opération tronquée <code>||</code>  était assez significatif, c'est-à-dire que cette définition n'est pas équivalente à une définition dans laquelle au lieu de <code>||</code>  utilisé par <code>Or</code> . <br><br>  La réponse à cette question est la suivante: il est toujours possible de construire un analogue d' <code>insert</code> pour <code>TotalOrder</code> , cependant, pour cela, nous devons prouver que le type de la fonction d' <code>insert</code> est une instruction (cela nous permettrait dans la définition d' <code>insert</code> de faire une comparaison avec l'échantillon en fonction de la déclaration de <code>totality xy</code> ). <br><br>  Autrement dit, il faudrait prouver qu'il n'y a qu'une seule liste ordonnée jusqu'à égalité, ce qui résulte de l'insertion de l'élément <code>y</code> dans la liste ordonnée <code>xs</code> .  Il est facile de voir que c'est un fait réel, mais sa preuve formelle n'est plus si triviale.  Nous laissons la vérification de ce fait comme exercice au lecteur intéressé. <br><br><h2>  3. Observations finales </h2><br>  Dans cette introduction, nous nous sommes familiarisés avec les principales constructions du langage Arend et avons également appris à utiliser le mécanisme de classe.  Nous avons réussi à implémenter l'algorithme le plus simple avec la preuve de sa spécification.  Ainsi, nous avons montré qu'Arend est tout à fait adapté à la résolution de problèmes "quotidiens", comme par exemple la vérification de programme. <br><br>  Nous avons mentionné loin de toutes les fonctionnalités et fonctionnalités d'Arend.  Par exemple, nous n'avons presque rien dit sur les <i>types avec des conditions</i> qui vous permettent de «coller» divers constructeurs de types avec des valeurs de paramètre spéciales pour ces constructeurs.  Par exemple, une implémentation du type entier dans Arend est donnée en utilisant des types avec des conditions comme suit: <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero }</code> </pre> <br>  Cette définition dit que les entiers sont constitués de deux copies du type de nombres naturels, dans lesquels des zéros "positifs" et "négatifs" sont identifiés.  Une telle définition est beaucoup plus pratique que la définition de la bibliothèque Coq standard, où la «copie négative» des nombres naturels doit être «décalée d'une» afin que ces copies ne se recoupent pas (c'est beaucoup plus pratique lorsque la notation <code>neg 1</code> signifie le nombre -1, pas -2) . <br><br>  Nous n'avons rien dit sur l'algorithme de dérivation des niveaux de prédiction et d'homotopie dans les classes et leurs instances.  Nous avons également à peine mentionné le type d'intervalle <code>I</code> , bien qu'il joue un rôle clé dans la théorie des types avec intervalles, qui sont la base logique d'Arend.  Pour comprendre l'importance de ce type, il suffit de mentionner que dans le type Arend, l'égalité est définie par le concept d'un intervalle.     ,   ,     ,           (..    ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470632/">https://habr.com/ru/post/fr470632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470616/index.html">Une nouvelle solution au paradoxe de Fermi (pourquoi nous sommes seuls dans l'univers)</a></li>
<li><a href="../fr470618/index.html">Modélisation thématique de l'actualité à l'aide de l'analyse factorielle</a></li>
<li><a href="../fr470620/index.html">Infrastructure en tant que code: comment surmonter les problèmes avec XP</a></li>
<li><a href="../fr470622/index.html">Présentation des méthodes de sélection des fonctionnalités</a></li>
<li><a href="../fr470628/index.html">Construction navale de simulateur de vaisseau spatial</a></li>
<li><a href="../fr470634/index.html">Identifiez la communauté intercommunautaire sur Instagram pour identifier les intérêts des utilisateurs</a></li>
<li><a href="../fr470638/index.html">Méthodes quasi-newtoniennes ou quand il y a trop de dérivées secondes pour Athos</a></li>
<li><a href="../fr470640/index.html">Dimensionnement d'Elasticsearch</a></li>
<li><a href="../fr470642/index.html">Découvrez Yandex.Station Mini. Grande histoire d'un petit appareil</a></li>
<li><a href="../fr470644/index.html">Pourquoi les blogs d'entreprise sont parfois aigris: quelques observations et conseils</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>