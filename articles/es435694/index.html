<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç• üë®‚Äçüëß‚Äçüë¶ üëêüèª C√≥mo y por qu√© optimizamos el algoritmo para limpiar cach√©s SLAB en el kernel de Linux üë®üèº‚Äçüé® üë®üèª‚Äç‚öñÔ∏è üó°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La creciente popularidad de los contenedores y su uso en conjunto con los grupos de control revelaron un serio problema de escalabilidad, que conduce ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo y por qu√© optimizamos el algoritmo para limpiar cach√©s SLAB en el kernel de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/435694/">  La creciente popularidad de los contenedores y su uso en conjunto con los grupos de control revelaron un serio problema de escalabilidad, que conduce a una ca√≠da significativa en el rendimiento en m√°quinas grandes.  El problema es que el tiempo de derivaci√≥n de las memorias cach√© SLAB depende de forma cuadr√°tica de la cantidad de contenedores, y el consumo activo de grandes cantidades de memoria en un per√≠odo corto puede hacer que el sistema entre en un bucle ocupado, consumiendo el 100% del tiempo del procesador.  Hoy me gustar√≠a contarles c√≥mo resolvimos este problema cambiando el algoritmo de contabilidad para usar el grupo de control memcg para usar objetos de cach√© SLAB y optimizar la funci√≥n shrink_slab (). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99b/7f3/83b/99b7f383beadeec2c814a6792e507b6c.jpg" alt="Limpieza de la memoria"><br><a name="habracut"></a><br>  ¬øPor qu√© surgi√≥ la cuesti√≥n de la optimizaci√≥n de procesos en el n√∫cleo?  Todo comenz√≥ con el hecho de que uno de nuestros clientes, utilizando activamente contenedores y grupos de control de memoria (memcg), llam√≥ la atenci√≥n sobre los picos extra√±os del consumo de recursos del procesador que ocurren de vez en cuando.  La carga normal del sistema fue de aproximadamente el 50%, y en las horas pico se tom√≥ el 100% del tiempo del procesador, y el n√∫cleo consumi√≥ casi todo (tiempo sys). <br>  El nodo en s√≠ era multiusuario, y se lanzaron alrededor de 200 contenedores OpenVZ.  El an√°lisis mostr√≥ que un gran n√∫mero de usuarios cre√≥ contenedores Docker anidados y jerarqu√≠as de niveles m√∫ltiples de grupos de control de memoria.  Cada contenedor de nivel superior de nivel de usuario conten√≠a aproximadamente 20 puntos de montaje y 20 grupos de memoria de control (memcg) creados por systemd.  Adem√°s, hab√≠a puntos de montaje y grupos de control creados por el mencionado Docker.  En pocas palabras, el nodo estaba muy cargado y la carga en √©l era mucho m√°s fuerte que el promedio de todos nuestros otros clientes.  Est√°bamos interesados ‚Äã‚Äãen encontrar la raz√≥n de la aparici√≥n de estos picos, ya que el mismo problema podr√≠a aparecer en m√°quinas menos ocupadas, donde apenas era notable (por ejemplo, dar picos a + 5% del tiempo del sistema, lo que degrada el rendimiento). <br><br>  Al manipular el rendimiento, logr√© alcanzar el pico y eliminar el rastro.  Result√≥ que la mayor parte del tiempo del procesador se dedica a borrar cach√©s SLAB, a saber, cach√©s de superbloque: <br><br><pre><code class="markdown hljs"><span class="hljs-bullet"><span class="hljs-bullet">- </span></span>100,00% 0,00% kswapd0 [kernel.vmlinux] [k] kthread - 99,31% balance<span class="hljs-emphasis"><span class="hljs-emphasis">_pgdat - 82,11% shrink_</span></span>zone - 61,69% shrink<span class="hljs-emphasis"><span class="hljs-emphasis">_slab - 58,29% super_</span></span>cache<span class="hljs-emphasis"><span class="hljs-emphasis">_count + 54,56% list_</span></span>lru<span class="hljs-emphasis"><span class="hljs-emphasis">_count_</span></span>one</code> </pre> <br><br>  Aqu√≠ vale la pena hacer una explicaci√≥n y reflexionar sobre este tema con m√°s detalle.  Todos saben que el kernel almacena en cach√© los datos no utilizados durante un tiempo antes de finalmente liberar memoria.  El n√∫cleo hace un amplio uso de este principio.  Por ejemplo, la memoria cach√© de la p√°gina contiene p√°ginas de datos relacionados con el archivo, lo que acelera en gran medida el acceso repetido a ellas durante la lectura (porque no es necesario volver a acceder al disco).  En nuestro caso, el problema surgi√≥ con el cach√© de metadatos de superbloque contenido en dos listas de LRU: s_dentry_lru y s_inode_lru. <br><br>  <b>LRU (menos utilizado recientemente)</b> <b><br></b> <br>  struct lru_list apunta a una matriz de listas vinculadas, y cada memcg activo corresponde a un elemento (list_lru_one) en esta matriz.  Cuando el kernel ya no usa un determinado objeto SLAB, el kernel lo agrega a una de las listas vinculadas de la matriz (dependiendo de a qu√© miembro pertenece el objeto o, m√°s o menos, a qu√© memcg utiliz√≥ el proceso cuando cre√≥ este objeto).  La matriz en s√≠ se describe de la siguiente manera (lru_list :: node :: memcg_lrus): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_memcg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* array of per cgroup lists, indexed by memcg_cache_id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lru</span></span></span><span class="hljs-class">[0];</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* may become negative during memcg reparenting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_items; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> };</code> </pre><br>  lru [0] indica una lista de objetos relacionados con memcg con ID 0; <br>  lru [1] indica una lista de objetos relacionados con memcg con ID 1; <br>  ... <br>  lru [n] indica una lista de objetos relacionados con memcg con ID n; <br><br>  Las listas de LRU s_dentry_lru y s_inode_lru aparecen en nuestro problema y, como su nombre lo indica, contienen objetos de sistema de archivos de inodos y dentry no utilizados. <br>  En el futuro, si no hay suficiente memoria en el sistema o una memoria espec√≠fica, algunos de los elementos de la lista finalmente se liberan, y un mecanismo especial llamado reductor lo hace. <br><br>  <b>Encogedor</b> <b><br></b> <br>  Cuando el n√∫cleo necesita asignar p√°ginas de memoria, pero no hay memoria libre en el nodo NUMA o en el sistema, se inicia el mecanismo para limpiarlo.  Est√° tratando de tirar o descartar una cierta cantidad de disco: 1) p√°ginas del contenido de los archivos del cach√© de la p√°gina;  2) p√°ginas relacionadas con memoria an√≥nima en un intercambio, y 3) objetos SLAB en cach√© (el problema que encontramos est√° relacionado con ellos). <br><br>  Tirar parte de los objetos SLAB en cach√© no afecta directamente la liberaci√≥n de las p√°ginas: su tama√±o, como regla, es significativamente menor que el tama√±o de la p√°gina, y una p√°gina contiene cientos de objetos.  Cuando se libera parte de los objetos, aparecen espacios de memoria libre en las p√°ginas SLAB, que se pueden usar para crear otros objetos SLAB.  Este algoritmo es aceptado en el n√∫cleo intencionalmente: es simple y bastante eficiente.  Un lector interesado puede ver la f√≥rmula para seleccionar una parte de los objetos para limpiar en la funci√≥n do_shrink_slab (). <br><br>  Esta funci√≥n realiza la limpieza real de parte de los objetos, guiada por la descripci√≥n que se le pasa en el reductor de estructura: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrink_control *shrinkctl, struct shrinker *shrinker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> freeable = shrinker-&gt;count_objects(shrinker, shrinkctl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeable == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; total_scan = _(freeable); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (total_scan &gt;= batch_size) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = shrinker-&gt;scan_objects(shrinker, shrinkctl); total_scan -= shrinkctl-&gt;nr_scanned; } ... }</code> </pre> <br>  En relaci√≥n con el superbloque retr√°ctil, estas funciones se implementan de la siguiente manera.  Cada superbloque mantiene sus propias listas s_dentry_lru y s_inode_lru de objetos no utilizados relacionados con √©l: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrinker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_shrink</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* per-sb shrinker handle */</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_dentry_lru</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_inode_lru</span></span></span><span class="hljs-class">;</span></span> ‚Ä¶ };</code> </pre> <br><br>  El m√©todo .count_objects devuelve el n√∫mero de objetos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ total_objects += list_lru_shrink_count(&amp;sb-&gt;s_dentry_lru, sc); total_objects += list_lru_shrink_count(&amp;sb-&gt;s_inode_lru, sc); <span class="hljs-comment"><span class="hljs-comment">/*     ) */</span></span> total_objects = vfs_pressure_ratio(total_objects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_objects; }</code> </pre> <br><br>  El m√©todo .scan_objects en realidad libera objetos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     s_dentry_lru */</span></span> prune_dcache_sb(sb, sc); <span class="hljs-comment"><span class="hljs-comment">/*     s_inode_lru */</span></span> prune_icache_sb(sb, sc); }</code> </pre> <br>  El n√∫mero de objetos a liberar se pasa en el par√°metro sc.  Adem√°s, memcg se indica all√≠, cuyos objetos deben arrojarse fuera de la LRU: <br><br><pre> <b><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nid; <span class="hljs-comment"><span class="hljs-comment">/* ID NUMA  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_to_scan; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* memcg */</span></span> };</code></b> </pre><br>  Por lo tanto, prune_dcache_sb () selecciona una lista vinculada de la matriz struct list_lru_memcg :: lru [] y trabaja con ella.  Prune_icache_sb () hace lo mismo. <br><br>  <b>Antiguo algoritmo de derivaci√≥n de contracci√≥n</b> <b><br></b> <br>  Con el enfoque est√°ndar, "expulsar" objetos de SLAB sin memoria en <br>  sc-&gt; target_mem_cgroup ocurre de la siguiente manera: <br><br><pre> <code class="cpp hljs">shrink_node() { ‚Ä¶ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target_mem_cgroup</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      sc-&gt;target_mem_cgroup  */</span></span> memcg = mem_cgroup_iter(root, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;reclaim); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ‚Ä¶ shrink_slab(memcg, ...); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((memcg = mem_cgroup_iter(root, memcg, &amp;reclaim))); ... }</code> </pre><br>  Revisamos todos los elementos secundarios y llamamos a shrink_slab () para cada uno de ellos.  A continuaci√≥n, en la funci√≥n shrink_slab (), revisamos todos los encogedores y para cada uno de ellos llamamos a do_shrink_slab (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gfp_mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nid, struct mem_cgroup *memcg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ list_for_each_entry(shrinker, &amp;shrinker_list, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> = {</span></span> .nid = nid, .memcg = memcg, }; ret = do_shrink_slab(&amp;sc, shrinker, ...); } }</code> </pre><br>  Recuerde que para cada superbloque, se agrega su propio reductor a esta lista.  Vamos a contar cu√°ntas veces se llamar√° a do_shrink_slab () para el caso con 200 contenedores de 20 memcg y 20 puntos de montaje en cada uno.  En total, tenemos 200 * 20 puntos de montaje y 200 * 20 grupos de control.  Si no hay suficiente memoria en la memoria superior, nos veremos obligados a omitir todas sus memorias secundarias (es decir, generalmente todo), y para cada una de ellas, llame a cada uno de los encogedores de la lista shrinker_list.  Por lo tanto, el n√∫cleo realizar√° 200 * 20 * 200 * 20 = 16000000 llamadas a la funci√≥n do_shrink_slab (). <br><br>  Al mismo tiempo, la abrumadora cantidad de llamadas a esta funci√≥n ser√° in√∫til: los contenedores generalmente est√°n aislados entre s√≠, y la probabilidad de que CT1 use super_block2 creado en CT2 es generalmente baja.  O, lo que es lo mismo, si memcg1 es un grupo de control de CT1, entonces el elemento correspondiente de la matriz super_block2-&gt; s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg1_id] ser√° una lista vac√≠a, y no tiene sentido llamar a do_shrink_slab () para ello. <br><br>  Este problema se puede modelar usando un script bash simple (aqu√≠ se usan los datos del conjunto de parches, que posteriormente se pasaron al kernel): <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchy <span class="hljs-variable"><span class="hljs-variable">$mkdir</span></span> /sys/fs/cgroup/memory/ct <span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 4000M &gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 0 4000`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mkdir /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/cgroup.procs; mkdir -ps/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; mount -t tmpfs <span class="hljs-variable"><span class="hljs-variable">$is</span></span>/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; touch s/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/file; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Veamos qu√© sucede si llama al procedimiento de reinicio de cach√© 5 veces seguidas: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  La primera iteraci√≥n dura 14 segundos, porque los objetos en cach√© realmente est√°n en la memoria: <i>0.00 usuario 13.78 sistema <b>0: 13.78 transcurri√≥</b> 99% CPU.</i> <br>  La segunda iteraci√≥n lleva 5 segundos, aunque no hay m√°s objetos: <i>0.00usuario 5.59sistema <b>0: 05.60epsed</b> 99% CPU.</i> <br>  La tercera iteraci√≥n tarda 5 segundos: <i>0.00usuario 5.48sistema <b>0: 05.48elapsado</b> 99% CPU</i> <br>  La cuarta iteraci√≥n tarda 8 segundos: <i>0.00usuario 8.35sistema <b>0: 08.35elapsado</b> 99% CPU</i> <br>  La quinta iteraci√≥n tarda 8 segundos: <i>0.00usuario 8.34sistema <b>0: 08.35epsado</b> 99% CPU</i> <br><br>  Se hizo evidente que el algoritmo de derivaci√≥n de contracci√≥n utilizado por el n√∫cleo de vainilla no es √≥ptimo, y debemos cambiarlo para mejorarlo en t√©rminos de escalabilidad. <br><br>  <b>Nuevo algoritmo de derivaci√≥n de contracci√≥n</b> <b><br></b> <br>  Desde el nuevo algoritmo quer√≠a lograr lo siguiente: <br><br><ol><li>  liberarlo de los defectos de lo viejo y </li><li>  No agregue nuevas cerraduras.  Llame a do_shrink_slab () solo cuando tenga sentido (es decir, la lista vinculada correspondiente de la matriz s_dentry_lru o de la matriz s_inode_lru no est√° vac√≠a), pero no acceda directamente a la memoria de la lista vinculada. </li></ol><br>  Estaba claro que esto solo pod√≠a proporcionarse mediante una nueva estructura de datos adem√°s de los reductores heterog√©neos (hay reductores no solo del superbloque, sino tambi√©n de otros objetos de datos no descritos en este art√≠culo. El lector puede familiarizarse con ellos buscando la palabra clave prealloc_shrinker () en el c√≥digo del n√∫cleo).  La nueva estructura de datos deber√≠a permitir la codificaci√≥n de dos estados: "tiene sentido llamar a do_shrink_slab ()" y "no tiene sentido llamar a do_shrink_slab ()". <br><br>  Las estructuras de datos de tipo IDA fueron rechazadas porque  usan cerraduras dentro de ellos mismos.  La estructura de datos del campo de bits es totalmente adecuada para este rol: permite la modificaci√≥n at√≥mica de bits individuales y, en combinaci√≥n con las barreras de memoria, le permite construir un algoritmo eficiente sin el uso de bloqueos. <br><br>  Cada reductor obtiene su propia identificaci√≥n √∫nica (shrinker :: id), y cada memcg obtiene un mapa de bits capaz de contener la identificaci√≥n m√°s grande de las registradas actualmente.  Cuando el primer elemento se agrega a la lista s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg_id], el mapa de bits de memcg correspondiente se establece en 1 bit con el encogedor de n√∫meros-&gt; id.  Lo mismo con s_inode_id. <br><br>  Ahora el bucle en shrink_slab () se puede optimizar para omitir solo los encogedores necesarios: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ for_each_set_bit(i, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, shrinker_nr_max) { ‚Ä¶ shrinker = idr_find(&amp;shrinker_idr, i); ‚Ä¶ do_shrink_slab(&amp;sc, shrinker, priority); ‚Ä¶ } }</code> </pre><br>  (La limpieza de bits tambi√©n se implementa cuando el reductor entra en el estado "no tiene sentido llamar a do_shrink_slab (). Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compromiso de</a> Github para obtener m√°s detalles". <br><br>  Si repite la prueba de restablecimiento de la memoria cach√©, entonces, utilizando el nuevo algoritmo, muestra resultados significativamente mejores: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Primera iteraci√≥n: <i>0.00user 1.10system <b>0: 01.10elapsed</b> 99% CPU</i> <i><br></i>  Segunda iteraci√≥n: <i>0.00usuario 0.00sistema <b>0: 00.01</b> CPU 64% <b>transcurrida</b></i> <i><br></i>  Tercera iteraci√≥n: <i>0.00usuario 0.01 sistema <b>0: 00.01 transcurrido</b> 82% CPU</i> <i><br></i>  Cuarta iteraci√≥n: <i>0.00usuario 0.00sistema <b>0: 00.01epidi√≥</b> 64% CPU</i> <i><br></i>  Quinta iteraci√≥n: <i>0.00usuario 0.01 sistema <b>0: 00.01 transcurrido</b> 82% CPU</i> <br>  La duraci√≥n de la segunda a la quinta iteraci√≥n es 0.01 segundos, <b>548 veces m√°s r√°pido que antes.</b> <br><br>  Dado que se producen acciones similares para restablecer los cach√©s con cada falta de memoria en la m√°quina, esta optimizaci√≥n mejora significativamente el funcionamiento de las m√°quinas con una gran cantidad de contenedores y grupos de control de memoria.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se</a> ha aceptado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un conjunto de parches</a> (17 piezas) en el n√∫cleo de vainilla, y puede encontrarlo a partir de la versi√≥n 4.19. <br><br>  En el proceso de revisi√≥n de los parches, apareci√≥ un empleado de Google, y result√≥ que ten√≠an el mismo problema.  Por lo tanto, los parches se probaron en un tipo diferente de carga. <br>  Como resultado, el conjunto de parches se adopt√≥ a partir de la novena iteraci√≥n;  y su entrada en el n√∫cleo de vainilla tom√≥ alrededor de 4 meses.  Tambi√©n hoy, el parche est√° incluido en nuestro propio n√∫cleo Virtuozzo 7, comenzando con la versi√≥n vz7.71.9 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435694/">https://habr.com/ru/post/es435694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435684/index.html">El Laboratorio Nacional de Oak Ridge ha resuelto el principal problema de los desarrolladores de dispositivos espaciales: la deficiencia de plutonio-238</a></li>
<li><a href="../es435686/index.html">Pavel Durov liquida Telegram Messenger LLP</a></li>
<li><a href="../es435688/index.html">Ejemplo de aplicaci√≥n del servidor cliente Flutter</a></li>
<li><a href="../es435690/index.html">[¬øQu√© hay de malo con GraphQL] ... y c√≥mo lidiar con eso</a></li>
<li><a href="../es435692/index.html">Y Combinator: "Al principio, algunas de las compa√±√≠as tecnol√≥gicas m√°s grandes parecen juguetes"</a></li>
<li><a href="../es435696/index.html">Antig√ºedades: 1997 Computer Advertising</a></li>
<li><a href="../es435698/index.html">Escribiendo tu propio buen administrador de memoria</a></li>
<li><a href="../es435700/index.html">8 peores preguntas de la entrevista de Vue.js</a></li>
<li><a href="../es435702/index.html">Los trolls de patentes comienzan y ganan: c√≥mo me qued√© sin un juego</a></li>
<li><a href="../es435704/index.html">Soluciones arquitect√≥nicas para un juego m√≥vil. Parte 2: Comando y sus colas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>