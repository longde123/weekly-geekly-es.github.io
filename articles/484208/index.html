<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìª üßÄ üç≠ Uso del aprendizaje autom√°tico en el an√°lisis est√°tico del c√≥digo fuente del programa üê™ ü§ê üóª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El aprendizaje autom√°tico est√° profundamente arraigado en varias √°reas de la actividad humana: desde el reconocimiento del habla hasta el diagn√≥stico ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso del aprendizaje autom√°tico en el an√°lisis est√°tico del c√≥digo fuente del programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Uso del aprendizaje autom√°tico en el an√°lisis est√°tico del c√≥digo fuente del programa"></div><br>  El aprendizaje autom√°tico est√° profundamente arraigado en varias √°reas de la actividad humana: desde el reconocimiento del habla hasta el diagn√≥stico m√©dico.  La popularidad de este enfoque es tan grande que intentan usarlo siempre que sea posible.  Algunos intentos de reemplazar los enfoques cl√°sicos con redes neuronales no tienen tanto √©xito.  Echemos un vistazo al aprendizaje autom√°tico desde el punto de vista de la creaci√≥n de analizadores de c√≥digo est√°tico eficaces para encontrar errores y vulnerabilidades potenciales. <br><a name="habracut"></a><br>  A menudo se pregunta al equipo de PVS-Studio si queremos comenzar a utilizar el aprendizaje autom√°tico para encontrar errores en el c√≥digo fuente de los programas.  Respuesta corta: s√≠, pero muy limitada.  Creemos que con el uso del aprendizaje autom√°tico en los problemas de an√°lisis de c√≥digo, existen muchas dificultades.  En la segunda parte del art√≠culo hablaremos sobre ellos.  Comencemos con una revisi√≥n de nuevas soluciones e ideas. <br><br><h2>  Nuevos enfoques </h2><br>  Actualmente, ya hay muchas implementaciones de analizadores est√°ticos basados ‚Äã‚Äãen el aprendizaje autom√°tico o que lo utilizan, incluido el aprendizaje profundo y la PNL para la detecci√≥n de errores.  No solo los entusiastas, sino tambi√©n las grandes empresas, como Facebook, Amazon o Mozilla, llamaron la atenci√≥n sobre el potencial del aprendizaje autom√°tico al buscar errores.  Algunos proyectos no son analizadores est√°ticos completos, pero solo en el medio encuentran algunos errores espec√≠ficos durante las confirmaciones. <br><br>  Curiosamente, casi todos se posicionan como productos que cambian el juego que, con la ayuda de la inteligencia artificial, cambiar√°n el proceso de desarrollo. <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br>  Considere algunos ejemplos bien conocidos: <br><br><ol><li>  Deepcode </li><li>  Inferir, Sapienz, SapFix </li><li>  Embold </li><li>  Fuente {d} </li><li>  Compromiso inteligente, asistente de compromiso </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code es una herramienta de b√∫squeda de vulnerabilidades en el c√≥digo de programas escritos en Java, JavaScript, TypeScript y Python, en los que el aprendizaje autom√°tico est√° presente como componente.  Seg√∫n Boris Paskalev, m√°s de 250 mil reglas ya funcionan.  Esta herramienta est√° capacitada en funci√≥n de los cambios realizados por los desarrolladores en el c√≥digo fuente de los proyectos abiertos (un mill√≥n de repositorios).  La propia empresa dice que su proyecto es Grammarly para desarrolladores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  En esencia, este analizador compara su soluci√≥n con su base de datos de proyectos y le ofrece la mejor soluci√≥n estimada de la experiencia de otros desarrolladores. <br><br>  En mayo de 2018, los desarrolladores escribieron que se estaba preparando el soporte para el lenguaje C ++, sin embargo, este lenguaje a√∫n no es compatible.  Aunque se indica en el sitio mismo que se puede agregar un nuevo idioma en cuesti√≥n de semanas, debido al hecho de que solo un paso depende del an√°lisis del idioma. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Tambi√©n se publica en el sitio un grupo de publicaciones sobre los m√©todos en los que se basa el analizador. <br><br><h3>  Inferir </h3><br>  Facebook est√° intentando ampliamente introducir nuevos enfoques en sus productos.  No pasaron por alto su atenci√≥n y el aprendizaje autom√°tico.  En 2013, compraron una startup que estaba desarrollando un analizador est√°tico basado en m√°quina.  Y en 2015, el c√≥digo fuente del proyecto <a href="https://github.com/facebook/infer">se abri√≥</a> . <br><br>  Infer es un analizador est√°tico para proyectos escritos en Java, C, C ++ y Objective-C, desarrollado por Facebook.  Seg√∫n el sitio, tambi√©n se usa en Amazon Web Services, Oculus, Uber y otros proyectos populares. <br><br>  Infer actualmente es capaz de detectar errores relacionados con la eliminaci√≥n de referencias de un puntero nulo, p√©rdidas de memoria.  Infer se basa en la l√≥gica de Hoar, la l√≥gica de separaci√≥n y la bi-abducci√≥n, as√≠ como en la teor√≠a de la interpretaci√≥n abstracta.  El uso de estos enfoques permite al analizador dividir el programa en peque√±os bloques (fragmentos) y analizarlos independientemente uno del otro. <br><br>  Puede intentar usar Infer en sus proyectos, sin embargo, los desarrolladores advierten que aunque en los proyectos de Facebook los resultados √∫tiles representan el 80% de los resultados, en otros proyectos no se garantiza un bajo n√∫mero de falsos positivos.  Algunos de los errores que Infer a√∫n no puede encontrar, pero los desarrolladores est√°n trabajando para introducir dichos desencadenantes: <br><br><ul><li>  saliendo de la matriz; </li><li>  excepciones de tipograf√≠a; </li><li>  fuga de datos no verificados; </li><li>  carrera condici√≥n de carrera. </li></ul><br><h3>  Sapfix </h3><br>  SapFix es una herramienta de edici√≥n automatizada.  Recibe informaci√≥n de Sapienz, una herramienta de automatizaci√≥n de pruebas y del analizador est√°tico Infer, y bas√°ndose en los √∫ltimos cambios y mensajes, Infer elige una de varias estrategias para corregir errores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  En algunos casos, SapFix revierte todos o parte de los cambios.  En otros casos, intenta resolver el problema generando un parche a partir de su conjunto de patrones de arreglos.  Este conjunto se forma a partir de las plantillas de edici√≥n compiladas por los propios programadores a partir del conjunto de ediciones ya realizadas una vez.  Si dicha plantilla no corrige el error, SapFix intenta ajustar la plantilla a la situaci√≥n, haciendo peque√±as modificaciones en el √°rbol de sintaxis abstracta hasta que se encuentre una posible soluci√≥n. <br><br>  Pero una soluci√≥n potencial no es suficiente, por lo que SapFix recopila varias soluciones que se seleccionan en base a tres preguntas: ¬øhay alg√∫n error de compilaci√≥n, hay un bloqueo, la edici√≥n introduce nuevos bloqueos?  Una vez que las ediciones se prueban por completo, los parches se env√≠an para su revisi√≥n al programador que decide cu√°l de las ediciones resuelve mejor el problema. <br><br><h3>  Embold </h3><br>  Embold es una plataforma de inicio para el an√°lisis est√°tico del c√≥digo fuente de los programas, que antes del cambio de nombre se llamaba Gamma.  El an√°lisis est√°tico se realiza sobre la base de nuestros propios diagn√≥sticos, as√≠ como sobre la base de analizadores integrados como Cppheck, SpotBugs, SQL Check y otros. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Adem√°s de los diagn√≥sticos en s√≠, el √©nfasis est√° en la capacidad de mostrar visualmente las infograf√≠as por la carga de la base del c√≥digo y ver convenientemente los errores encontrados, as√≠ como buscar la posibilidad de refactorizar.  Adem√°s, este analizador tiene un conjunto de antipatrones que le permiten detectar problemas en la estructura del c√≥digo a nivel de clases y m√©todos, y varias m√©tricas para calcular la calidad del sistema. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Una de las principales ventajas es la soluci√≥n inteligente y el sistema de sugerencia de revisi√≥n, que, adem√°s de los diagn√≥sticos habituales, verifica las revisiones basadas en informaci√≥n sobre cambios anteriores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Utilizando NLP, Embold divide el c√≥digo en partes y busca interconexiones y dependencias entre funciones y m√©todos entre ellas, lo que ahorra tiempo de refactorizaci√≥n. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Por lo tanto, Embold ofrece principalmente una visualizaci√≥n conveniente de los resultados de an√°lisis de su c√≥digo fuente por varios analizadores, as√≠ como sus propios diagn√≥sticos, algunos de los cuales se basan en el aprendizaje autom√°tico. <br><br><h3>  Fuente {d} </h3><br>  La fuente {d} es la m√°s abierta en t√©rminos de c√≥mo implementarla de los analizadores que examinamos.  Tambi√©n es una <a href="https://github.com/src-d/sourced-ce">soluci√≥n de c√≥digo abierto</a> .  En su sitio web puede (a cambio de su direcci√≥n de correo electr√≥nico) obtener un folleto con una descripci√≥n de las tecnolog√≠as que utilizan.  Adem√°s, contiene un <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">enlace</a> a la base de publicaciones que han recopilado en relaci√≥n con el uso del aprendizaje autom√°tico para el an√°lisis de c√≥digo, as√≠ como un <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">repositorio</a> con un conjunto de datos para la capacitaci√≥n en c√≥digo.  El producto en s√≠ es una plataforma completa para analizar el c√≥digo fuente y el producto de software, y se centra, m√°s bien, no en los desarrolladores, sino en los administradores de enlaces.  Entre sus capacidades hay una funci√≥n para identificar el volumen de la deuda t√©cnica, los cuellos de botella en el proceso de desarrollo y otras estad√≠sticas globales sobre el proyecto. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Basan su enfoque del an√°lisis de c√≥digo asistido por m√°quina en la hip√≥tesis natural, formulada en el art√≠culo " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sobre la naturalidad del software</a> ". <br><br>  <i>"Los lenguajes de programaci√≥n, en teor√≠a, son complejos, flexibles y potentes, pero los programas que las personas reales escriben en realidad son en su mayor√≠a simples y bastante repetitivos, y por lo tanto contienen propiedades estad√≠sticas √∫tiles y predecibles que pueden expresarse en estad√≠stica modelos de lenguaje y uso para tareas de desarrollo de software ".</i> <br><br>  Seg√∫n esta hip√≥tesis, cuanto mayor sea la base del c√≥digo para entrenar el analizador, m√°s propiedades estad√≠sticas destacar√°n y m√°s precisas ser√°n las m√©tricas obtenidas a trav√©s del entrenamiento. <br><br>  Para analizar el c√≥digo, source {d} utiliza el servicio Babelfish, que puede analizar un archivo de c√≥digo en cualquiera de los idiomas disponibles, obtener un √°rbol de sintaxis abstracta y convertirlo en un √°rbol de sintaxis universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Sin embargo, la fuente {d} no busca errores en el c√≥digo.  Basado en el √°rbol, usando el aprendizaje autom√°tico sobre la base de todo el proyecto, la fuente {d} revela c√≥mo se formatea el c√≥digo, qu√© estilo de codificaci√≥n se usa en el proyecto y al confirmar, y si el nuevo c√≥digo no coincide con el estilo del c√≥digo del proyecto, realiza los cambios apropiados. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  La capacitaci√≥n se gu√≠a por varios elementos b√°sicos: espacios, tabulaciones, saltos de l√≠nea, etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Puede leer m√°s sobre esto en su publicaci√≥n: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: arreglando inconsistencias de estilo de c√≥digo con algoritmos interpretables no supervisados</a> ". <br><br>  En general, source {d} es una plataforma amplia para recopilar una amplia variedad de estad√≠sticas sobre el c√≥digo fuente y el proceso de desarrollo del proyecto, desde calcular la efectividad de los desarrolladores hasta identificar los costos de tiempo para las revisiones de c√≥digo. <br><br><h3>  Compromiso inteligente </h3><br>  Clever-Commit es un analizador creado por Mozilla en colaboraci√≥n con Ubisoft.  Se basa en el estudio <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> (combinaci√≥n de niveles de prevenci√≥n de errores y t√©cnicas de resoluci√≥n) de Ubisoft, y su asistente de compromiso basado en el producto, que identifica los compromisos sospechosos que probablemente contengan un error.  Debido a que CLEVER se basa en la comparaci√≥n de c√≥digos, no solo indica un c√≥digo peligroso, sino que tambi√©n hace sugerencias sobre posibles correcciones.  Seg√∫n la descripci√≥n, en 60-70% de los casos Clever-Commit encuentra √°reas problem√°ticas y con la misma frecuencia ofrece correcciones correctas para ellas.  En general, hay poca informaci√≥n sobre este proyecto y sobre los errores que puede encontrar. <br><br><h3>  CodeGuru </h3><br>  Y m√°s recientemente, la lista de analizadores que utilizan el aprendizaje autom√°tico se ha rellenado con un producto de Amazon llamado CodeGuru.  Este servicio se basa en el aprendizaje autom√°tico, que le permite encontrar errores en el c√≥digo, as√≠ como identificar secciones costosas en √©l.  Hasta ahora, el an√°lisis es solo para c√≥digo Java, pero escriben sobre el soporte para otros idiomas en el futuro.  Aunque se anunci√≥ recientemente, el CEO de AWS (Amazon Web Services), Andy Jassi, dice que lo ha estado utilizando durante mucho tiempo en la propia Amazon√≠a. <br><br>  El sitio dice que la capacitaci√≥n se realiz√≥ en la base de c√≥digo de Amazon, as√≠ como en m√°s de 10,000 proyectos de c√≥digo abierto. <br><br>  En esencia, el servicio se divide en dos partes: CodeGuru Reviewer, capacitado buscando reglas asociativas y buscando errores en el c√≥digo, y CodeGuru Profiler, que monitorea el rendimiento de la aplicaci√≥n. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  En general, no se ha publicado mucha informaci√≥n sobre este proyecto.  El sitio dice que para aprender c√≥mo detectar las desviaciones de las "mejores pr√°cticas", Reviewer analiza las bases de c√≥digo de Amazon y busca solicitudes de extracci√≥n que contengan llamadas de la API de AWS en ellas.  Luego observa los cambios realizados y los compara con los datos de la documentaci√≥n, que se analiza en paralelo.  El resultado es un modelo de "mejores pr√°cticas". <br><br>  Tambi√©n se dice que las recomendaciones para el c√≥digo personalizado mejoran despu√©s de recibir comentarios sobre las recomendaciones. <br><br>  La lista de errores a la que responde Reviewer es bastante borrosa, ya que no se ha publicado documentaci√≥n espec√≠fica para errores: <ul><li>  Mejores pr√°cticas de AWS </li><li>  Concurrencia </li><li>  Fugas de recursos </li><li>  Fuga de informaci√≥n confidencial </li><li>  "Mejores pr√°cticas" comunes para la codificaci√≥n </li></ul><br><h2>  Nuestro escepticismo </h2><br>  Ahora veamos el problema de encontrar errores a trav√©s de los ojos de nuestro equipo, que ha estado desarrollando analizadores est√°ticos durante muchos a√±os.  Vemos una serie de problemas de alto nivel de la aplicaci√≥n de la capacitaci√≥n, de los que queremos hablar.  Pero al principio dividimos aproximadamente todos los enfoques de ML en dos tipos: <br><br><ol><li>  Entrene manualmente un analizador est√°tico para buscar varios problemas utilizando ejemplos de c√≥digo sint√©tico y real; </li><li>  Entrene los algoritmos en una gran cantidad de c√≥digo fuente abierto (GitHub) y cambie el historial, despu√©s de lo cual el analizador comenzar√° a detectar errores e incluso sugerir√° correcciones. </li></ol><br>  Hablaremos de cada direcci√≥n por separado, ya que tendr√°n varias deficiencias inherentes.  Despu√©s de lo cual, creo, quedar√° claro para los lectores por qu√© no negamos la posibilidad de aprendizaje autom√°tico, sino que tampoco compartimos entusiasmo. <br><br>  <b>Nota</b>  Miramos desde la perspectiva del desarrollo de un analizador est√°tico universal de uso general.  Estamos enfocados en el desarrollo de un analizador que no se centre en una base de c√≥digo espec√≠fica, sino que cualquier equipo pueda usar en cualquier proyecto. <br><br><h3>  Manual de entrenamiento analizador est√°tico </h3><br>  Supongamos que queremos usar ML para que el analizador comience a buscar anomal√≠as de la siguiente forma en el c√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Es extra√±o comparar una variable consigo misma.  Podemos escribir muchos ejemplos de c√≥digo correcto e incorrecto y capacitar al analizador para que busque dichos errores.  Adem√°s, es posible agregar ejemplos reales de errores ya encontrados a las pruebas.  La pregunta, por supuesto, es d√≥nde obtener estos ejemplos.  Pero consideraremos que es posible.  Por ejemplo, hemos acumulado una serie de ejemplos de tales errores: <a href="https://www.viva64.com/ru/examples/v501/">V501</a> , <a href="https://www.viva64.com/ru/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/ru/examples/v6001/">V6001</a> . <br><br>  Entonces, ¬øes posible buscar tales defectos en el c√≥digo utilizando algoritmos de aprendizaje autom√°tico?  Usted puede  ¬°Pero no est√° claro por qu√© hacer esto! <br><br>  Vea, para capacitar al analizador, debemos dedicar mucho esfuerzo a preparar ejemplos para la capacitaci√≥n.  O marque el c√≥digo de aplicaciones reales, indicando d√≥nde jurar y d√≥nde no.  En cualquier caso, habr√° que hacer mucho trabajo, ya que debe haber miles de ejemplos de capacitaci√≥n.  O decenas de miles. <br><br>  Despu√©s de todo, queremos buscar no solo casos (A == A), sino tambi√©n: <br><br><ul><li>  si (X &amp;&amp; A == A) </li><li>  si (A + 1 == A + 1) </li><li>  si (A [i] == A [i]) </li><li>  si ((A) == (A)) </li><li>  Y as√≠ sucesivamente. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br><br>  Ahora veamos c√≥mo se implementar√≠a un diagn√≥stico tan simple en PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">" , !"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Y eso es todo.  ¬°No se necesita una base de entrenamiento de muestra! <br><br>  En el futuro, se debe ense√±ar a los diagn√≥sticos a tener en cuenta una serie de excepciones y comprender que debe jurar en (A [0] == A [1-1]).  Sin embargo, todo esto es muy f√°cil de programar.  Pero solo con la base de ejemplos para el entrenamiento, todo ser√° malo. <br><br>  Tenga en cuenta que en ambos casos a√∫n se requerir√° un sistema de prueba, documentaci√≥n escrita, etc.  Sin embargo, el esfuerzo por crear un nuevo diagn√≥stico est√° claramente del lado del enfoque cl√°sico, donde la regla simplemente est√° codificada en c√≥digo. <br><br>  Veamos ahora alguna otra regla.  Por ejemplo, que se debe utilizar el resultado de algunas funciones.  No tiene sentido llamarlos sin usar su resultado.  Estas son algunas de estas caracter√≠sticas: <ul><li>  malloc </li><li>  memcmp </li><li>  cadena :: vac√≠o </li></ul><br>  En general, esto es lo que hacen los diagn√≥sticos de <a href="https://www.viva64.com/ru/w/v530/">V530</a> implementados en PVS-Studio. <br><br>  Por lo tanto, queremos buscar llamadas a tales funciones donde no se utiliza el resultado de su trabajo.  Para hacer esto, puede generar muchas pruebas.  Y creemos que todo funcionar√° bien.  Pero nuevamente, no est√° claro por qu√© esto es necesario. <br><br>  La implementaci√≥n del diagn√≥stico V530 con todas las excepciones en el analizador PVS-Studio es de 258 l√≠neas de c√≥digo, de las cuales 64 l√≠neas son comentarios.  Adem√°s, hay una tabla con anotaciones de funciones, donde se observa que se debe usar su resultado.  Reponer esta tabla es mucho m√°s f√°cil que crear ejemplos sint√©ticos. <br><br>  La situaci√≥n ser√° a√∫n peor con diagn√≥sticos que utilizan an√°lisis de flujo de datos.  Por ejemplo, el analizador PVS-Studio puede rastrear el valor de los punteros, lo que permite encontrar una p√©rdida de memoria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Se toma un ejemplo del art√≠culo " <a href="https://www.viva64.com/ru/b/0555/">Cromo: p√©rdidas de memoria</a> ".  Si <i>se cumple</i> la condici√≥n <i>(pkey.n0inv == 0)</i> , la funci√≥n sale sin liberar el b√∫fer, cuyo puntero se almacena en la variable <i>n</i> . <br><br>  Desde el punto de vista de PVS-Studio, no hay nada complicado.  El analizador estudi√≥ la funci√≥n <i>BnNew</i> y record√≥ que devuelve un puntero a un bloque de memoria asignada.  En otra funci√≥n, not√≥ que es posible una situaci√≥n en la que el b√∫fer no se libera, y el puntero hacia √©l se pierde cuando la funci√≥n sale. <br><br>  Un algoritmo de seguimiento de valor general funciona.  No importa c√≥mo se escriba el c√≥digo.  No importa qu√© m√°s hay en la funci√≥n que no est√© relacionada con el trabajo con punteros.  El algoritmo es universal y el diagn√≥stico V773 encuentra muchos errores en varios proyectos.  ¬°Vea cu√°n diferentes son los <a href="https://www.viva64.com/ru/examples/v773/">fragmentos de c√≥digo</a> donde se detectan los errores! <br><br>  No somos expertos en aprendizaje autom√°tico, pero parece que habr√° grandes problemas.  Hay una incre√≠ble cantidad de formas en que puede escribir c√≥digo con p√©rdidas de memoria.  Incluso si la m√°quina est√° entrenada para rastrear el valor de las variables, ser√° necesario entrenarla para comprender que hay llamadas a funciones. <br><br>  Existe la sospecha de que se necesitar√°n tantos ejemplos para la capacitaci√≥n que la tarea se vuelve desalentadora.  No decimos que sea irrealizable.  Dudamos de que los costos de crear un analizador valgan la pena. <br><br>  <b>Analogia</b>  Una analog√≠a viene a la mente con una calculadora, donde en lugar de diagn√≥sticos es necesario programar operaciones aritm√©ticas.  Estamos seguros de que puede ense√±arle a una calculadora basada en ML a sumar n√∫meros bien introduciendo una base de conocimiento sobre el resultado de las operaciones 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300, y as√≠ sucesivamente.  Como saben, la conveniencia de desarrollar una calculadora de este tipo es una gran pregunta (si no se asigna una subvenci√≥n para ello :).  Se puede escribir una calculadora mucho m√°s simple, m√°s r√°pida, m√°s precisa y confiable utilizando la operaci√≥n ordinaria "+" en el c√≥digo. <br><br>  <b>Conclusi√≥n</b>  El m√©todo funcionar√°.  Pero usarlo, en nuestra opini√≥n, no tiene sentido pr√°ctico.  El desarrollo llevar√° m√°s tiempo y el resultado es menos confiable y preciso, especialmente si se trata de la implementaci√≥n de diagn√≥sticos complejos basados ‚Äã‚Äãen el an√°lisis del flujo de datos. <br><br><h3>  Aprendiendo de mucha fuente abierta </h3><br>  Bueno, descubrimos ejemplos sint√©ticos manuales, pero hay GitHub.  Puede realizar un seguimiento del historial de confirmaciones y derivar patrones de cambios / correcciones de c√≥digo.  Luego puede se√±alar no solo secciones del c√≥digo sospechoso, sino incluso sugerir una forma de solucionarlo. <br><br>  Si se detiene en este nivel de detalle, entonces todo se ve bien.  El diablo, como siempre, est√° en los detalles.  Hablemos de estos detalles. <br><br>  <b>El primer matiz.</b>  <b>Fuente de datos</b> <br><br>  Las ediciones en GitHub son bastante ca√≥ticas y variadas.  Las personas a menudo son demasiado flojas para realizar confirmaciones at√≥micas y hacer varios cambios al c√≥digo a la vez.  Usted mismo sabe c√≥mo sucede: corrigieron el error y, al mismo tiempo, reestructuraron un poco ("Y aqu√≠ agregar√© el procesamiento de tal caso al mismo tiempo ...").  Incluso entonces, puede no estar claro para una persona si estos cambios est√°n relacionados entre s√≠ o no. <br><br>  El problema es c√≥mo distinguir los errores reales de agregar nueva funcionalidad u otra cosa.  Por supuesto, puede plantar 1,000 personas manualmente para marcar confirmaciones.  La gente tendr√° que indicar que corrigi√≥ el error aqu√≠, refactorizando aqu√≠, nueva funcionalidad aqu√≠, requisitos modificados aqu√≠, etc. <br><br>  ¬øEs posible este marcado?  Posible  Pero preste atenci√≥n a qu√© tan r√°pido ocurre el cambio.  En lugar de "aprender el algoritmo en s√≠ mismo sobre la base de GitHub", ya estamos discutiendo c√≥mo confundir a cientos de personas durante mucho tiempo.  Los costos laborales y el costo de crear una herramienta aumentan considerablemente. <br><br>  Puede intentar identificar autom√°ticamente d√≥nde se solucionaron exactamente los errores.  Para hacer esto, debe analizar los comentarios sobre las confirmaciones, prestar atenci√≥n a las peque√±as ediciones locales, que, muy probablemente, son exactamente la revisi√≥n del error.  Es dif√≠cil decir qu√© tan bien puede buscar autom√°ticamente correcciones de errores.  En cualquier caso, esta es una gran tarea que requiere investigaci√≥n y programaci√≥n por separado. <br><br>  Entonces, todav√≠a no hemos llegado a la capacitaci√≥n, pero ya hay matices :). <br><br>  <b>El segundo matiz.</b>  <b>Retraso en el desarrollo.</b> <br><br>  Los analizadores que se entrenar√°n sobre la base de bases de datos como GitHub siempre estar√°n sujetos a un s√≠ndrome como "retraso mental".  Esto se debe a que los lenguajes de programaci√≥n cambian con el tiempo. <br><br>  C # 8.0 <a href="https://www.viva64.com/ru/b/0631/">introdujo los</a> tipos de referencia anulables para ayudar a lidiar con las excepciones de referencia nula (NRE).  JDK 12 presenta una nueva declaraci√≥n de cambio ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  En C ++ 17, se hizo posible ejecutar construcciones condicionales en la etapa de compilaci√≥n ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr si</a> ).  Y as√≠ sucesivamente. <br><br>  Los lenguajes de programaci√≥n est√°n evolucionando.  Adem√°s, como C ++ son muy r√°pidos y activos.  En ellos aparecen nuevos dise√±os, se a√±aden nuevas funciones est√°ndar, etc.  Junto con las nuevas caracter√≠sticas, tambi√©n aparecen nuevos patrones de error que tambi√©n nos gustar√≠a identificar mediante el an√°lisis de c√≥digo est√°tico. <br><br>  Y aqu√≠ el m√©todo de ense√±anza en consideraci√≥n tiene un problema: el patr√≥n de error ya puede ser conocido, hay un deseo de identificarlo, pero no hay nada de qu√© aprender. <br><br>  Veamos este problema con un ejemplo espec√≠fico.  El rango basado en el rango apareci√≥ en C ++ 11.  Y puede escribir el siguiente c√≥digo, iterando sobre todos los elementos en el contenedor: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  El nuevo ciclo trajo consigo un nuevo patr√≥n de error.  Si el contenedor se cambia dentro del bucle, esto conducir√° a la invalidaci√≥n de los iteradores de "sombra". <br><br>  Considere el siguiente c√≥digo incorrecto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  El compilador lo convertir√° en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Durante la operaci√≥n <i>push_back</i> , puede producirse la <i>invalidaci√≥n de los</i> iteradores <i>__begin</i> y <i>__end</i> si se produce una asignaci√≥n de memoria dentro del vector.  El resultado ser√° un comportamiento indefinido del programa. <br><br>  Por lo tanto, el patr√≥n de error se conoce y describe desde hace tiempo en la literatura.  El analizador PVS-Studio lo diagnostica utilizando los diagn√≥sticos <a href="https://www.viva64.com/ru/w/v789/">V789</a> y ya ha encontrado <a href="https://www.viva64.com/ru/examples/v789/">errores reales</a> en proyectos abiertos. <br><br>  ¬øCu√°ndo habr√° suficiente c√≥digo nuevo en GitHub para notar este patr√≥n?  Buena pregunta ... Debe comprender que si apareci√≥ el bucle for basado en rango, esto no significa que todos los programadores inmediatamente comenzaron a usarlo de forma masiva.  Pueden pasar a√±os antes de que aparezca mucho c√≥digo utilizando un nuevo bucle.  Adem√°s, deben cometerse muchos errores, y luego deben corregirse para que el algoritmo pueda notar el patr√≥n en los cambios. <br><br>  ¬øCu√°ntos a√±os deber√≠an pasar?  Cinco?  Diez? <br><br>  Diez es demasiado, ¬øy somos pesimistas?  En absoluto  Han pasado ocho a√±os cuando se escribi√≥ este art√≠culo, ya que el rango para loop apareci√≥ en C ++ 11.  Pero hasta ahora, solo <a href="https://www.viva64.com/ru/examples/v789/">tres casos de</a> tal error se han escrito en nuestra base de datos.  Tres errores no son mucho ni poco.  No se debe sacar ninguna conclusi√≥n de su n√∫mero.  Lo principal es que puede confirmar que dicho patr√≥n de error es real y tiene sentido detectarlo. <br><br>  Ahora compare esta cantidad, por ejemplo, con este patr√≥n de error: el <a href="https://www.viva64.com/ru/examples/v595/">puntero se desreferencia antes de la verificaci√≥n</a> .  En total, al verificar proyectos de c√≥digo abierto, ya identificamos 1716 casos de este tipo. <br><br>  ¬øQuiz√°s no deber√≠a buscar errores de bucle basados ‚Äã‚Äãen el rango?  No  Solo los programadores son inerciales, y este operador est√° ganando popularidad muy lentamente.  Gradualmente, habr√° una gran cantidad de c√≥digo con su participaci√≥n y, en consecuencia, tambi√©n habr√° m√°s errores. <br><br>  Lo m√°s probable es que esto suceda solo despu√©s de 10-15 a√±os desde el momento en que apareci√≥ C ++ 11.  Y ahora una pregunta filos√≥fica.  ¬øYa conociendo el patr√≥n de error, solo esperaremos muchos a√±os hasta que se acumulen muchos errores en los proyectos abiertos? <br><br>  Si la respuesta es "s√≠", entonces es posible diagnosticar razonablemente a todos los analizadores basados ‚Äã‚Äãen ML el diagn√≥stico de "retraso mental". <br><br>  Si la respuesta es no, ¬øqu√© debo hacer?  No hay ejemplos  ¬øPara escribirlos manualmente?  Pero luego volvemos al cap√≠tulo anterior, donde consideramos escribirle a una persona muchos ejemplos para aprender. <br><br>  Esto se puede hacer, pero nuevamente surge la cuesti√≥n de la conveniencia.  La implementaci√≥n del diagn√≥stico V789 con todas las excepciones en el analizador PVS-Studio es de solo 118 l√≠neas de c√≥digo, de las cuales 13 l√≠neas son comentarios.  Es decir  Este es un diagn√≥stico muy simple que se puede tomar y programar f√°cilmente de una manera cl√°sica. <br><br>  Una situaci√≥n similar ser√° con cualquier otra innovaci√≥n que aparezca en cualquier otro idioma.  Como dicen, hay algo en qu√© pensar. <br><br>  <b>El tercer matiz.</b>  <b>Documentaci√≥n</b> <br><br>  Un componente importante de cualquier analizador est√°tico es la documentaci√≥n que describe cada diagn√≥stico.  Sin √©l, usar el analizador ser√° extremadamente dif√≠cil o incluso imposible.  En la <a href="https://www.viva64.com/ru/w/">documentaci√≥n</a> de PVS-Studio, tenemos una descripci√≥n de cada diagn√≥stico, que proporciona un ejemplo de un c√≥digo err√≥neo y c√≥mo solucionarlo.  Tambi√©n hay un enlace a <a href="https://cwe.mitre.org/">CWE</a> donde puede leer una descripci√≥n alternativa del problema.  Y de todos modos, a veces algo es incomprensible para los usuarios y nos hacen preguntas aclaratorias. <br><br>  En el caso de los analizadores est√°ticos, que se basan en algoritmos de aprendizaje autom√°tico, el problema de la documentaci√≥n se oculta de alguna manera.  Se supone que el analizador simplemente indica un lugar que le parece sospechoso y, tal vez, incluso sugiere c√≥mo solucionarlo.  La decisi√≥n de hacer un cambio o no permanece con la persona.  Y aqu√≠ ... ejem ... No es f√°cil tomar una decisi√≥n, no poder leer, sobre la base de lo cual el analizador parece sospechar de uno u otro lugar en el c√≥digo. <br><br>  Por supuesto, en algunos casos todo ser√° obvio.  Supongamos que el analizador apunta a este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Y ofrecer√° reemplazarlo con: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Est√° claro de inmediato que el programador sell√≥ y agreg√≥ 1 en el lugar equivocado.  Como resultado, se asignar√° menos memoria. <br><br>  Aqu√≠, sin documentaci√≥n, todo est√° claro.  Sin embargo, este no siempre ser√° el caso. <br><br>  Imagine que el analizador se√±ala silenciosamente este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Y sugiere cambiar el tipo del valor de retorno de char a int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  No hay documentaci√≥n para la advertencia.  Y aparentemente, el texto de la advertencia en s√≠, tal como lo entendemos, tampoco lo ser√°, si estamos hablando de un analizador completamente independiente. <br><br>  Que hacer  Cual es la diferencia  ¬øDebo hacer tal reemplazo? <br><br>  En principio, aqu√≠ puede arriesgarse y aceptar arreglar el c√≥digo.  Aunque acepta ediciones sin entenderlas, esta es una pr√°ctica <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>regular</i></a> ... :) Puede ver la descripci√≥n de la funci√≥n <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> y leer que la funci√≥n devuelve valores <i>int</i> : 0 que son mayores que cero y menores que cero.  Pero de todos modos, puede que no est√© claro por qu√© hacer cambios si el c√≥digo ya funciona correctamente. <br><br>  Ahora, si no sabe cu√°l es el objetivo de dicha edici√≥n, lea la descripci√≥n de los diagn√≥sticos <a href="https://www.viva64.com/ru/w/v642/">V642</a> .  De inmediato queda claro que esto es un verdadero error.  Adem√°s, puede causar vulnerabilidad. <br><br>  Quiz√°s el ejemplo parec√≠a poco convincente.  Despu√©s de todo, el analizador propuso un c√≥digo que probablemente sea mejor.  Ok  Veamos otro ejemplo de pseudoc√≥digo, esta vez, para variar, en Java. <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Hay alg√∫n tipo de objeto.  Est√° serializado.  Luego, el estado del objeto cambia y se serializa nuevamente.  Todo parece estar bien.  Ahora imagine que al analizador, de repente, no le gusta este c√≥digo, y sugiere reemplazarlo con: <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">//    obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  En lugar de cambiar el objeto y volver a grabarlo, se crea un nuevo objeto y ya est√° serializado. <br><br>  No hay una descripci√≥n del problema.  Sin documentaci√≥n  El c√≥digo se ha vuelto m√°s largo.  Por alguna raz√≥n, se agreg√≥ la creaci√≥n de un nuevo objeto.  ¬øEst√°s listo para hacer tal edici√≥n en tu c√≥digo? <br><br>  Dir√°s que no est√° claro.  De hecho, no est√° claro.  Y ser√° incomprensible todo el tiempo.  Trabajar con un analizador "silencioso" ser√° un estudio interminable en un intento por comprender por qu√© al analizador no le gusta algo. <br><br>  Si hay documentaci√≥n, entonces todo se vuelve transparente.  La clase <i>java.io.ObjectOuputStream</i> , que se utiliza para la serializaci√≥n, almacena en cach√© los objetos que se pueden escribir.  Esto significa que el mismo objeto no se serializar√° dos veces.  Una vez que la clase serializa el objeto, y la segunda vez, simplemente escribe un enlace al mismo primer objeto en la secuencia.  Leer m√°s: <a href="https://www.viva64.com/ru/w/v6076/">V6076</a> : la serializaci√≥n recurrente utilizar√° el estado del objeto en cach√© desde la primera serializaci√≥n. <br><br>  Esperamos haber podido explicar la importancia de tener documentaci√≥n.  Y ahora la pregunta.  ¬øC√≥mo aparecer√° la documentaci√≥n para un analizador basado en ML? <br><br>  Cuando se desarrolla un analizador de c√≥digo cl√°sico, todo es simple y claro.  Hay un cierto patr√≥n de errores.  Lo describimos en la documentaci√≥n e implementamos los diagn√≥sticos. <br><br>  En el caso de ML, lo contrario es cierto.  S√≠, el analizador puede notar una anomal√≠a en el c√≥digo y se√±alarlo.  Pero √©l no sabe nada sobre la esencia del defecto.  √âl no entiende y no dir√° por qu√© el c√≥digo no se puede escribir as√≠.  Estas son abstracciones de alto nivel.  Luego, el analizador tambi√©n debe aprender a leer y <b>comprender la</b> documentaci√≥n de las funciones. <br><br>  Como dije, dado que el tema de la documentaci√≥n est√° cubierto en art√≠culos sobre aprendizaje autom√°tico, no estamos listos para hablar m√°s.  Solo otro gran matiz que sacamos para su revisi√≥n. <br><br>  <b>Nota</b>  Se puede argumentar que la documentaci√≥n es opcional.  El analizador puede conducir a muchos ejemplos de soluciones en GitHub y la persona, observando los compromisos y comentarios sobre ellos, descubrir√° qu√© es qu√©.  Si lo es  Pero la idea no parece atractiva.  En lugar de un asistente, el analizador act√∫a como una herramienta que confundir√° a√∫n m√°s al programador. <br><br>  <b>El cuarto matiz.</b>  <b>Idiomas altamente especializados.</b> <br><br>  El enfoque descrito no es aplicable para lenguajes altamente especializados para los que el an√°lisis est√°tico tambi√©n puede ser extremadamente √∫til.  La raz√≥n es que GitHub y otras fuentes simplemente no tienen una base de c√≥digo fuente lo suficientemente grande como para proporcionar una capacitaci√≥n efectiva. <br><br>  Considere esto con un ejemplo espec√≠fico.  Para comenzar, vaya a GitHub y busque repositorios para el popular lenguaje Java. <br><br>  Resultado: lenguaje: "Java": <b>3.128.884</b> resultados de repositorio disponibles <br><br>  Ahora tomemos el lenguaje especializado "1C Enterprise" utilizado en aplicaciones de contabilidad emitidas por la compa√±√≠a rusa <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Resultado: idioma: "1C Enterprise": <b>551</b> resultados de repositorio disponibles <br><br>  ¬øQuiz√°s no se necesitan analizadores para este idioma?  Son necesarios  Existe una necesidad pr√°ctica para el an√°lisis de tales programas, y los analizadores correspondientes ya existen.  Por ejemplo, hay un complemento SonarQube 1C (BSL) fabricado por <a href="https://silverbulleters.org/">Silver Bullet</a> . <br><br> , -    ,          . <br><br> <b> . C, C++, #include</b> . <br><br> ,          ML,    ,  Java, JavaScript, Python.     .    C  C++ -  ,      . <br><br>    ,     /,   ,    C  C++  .    ¬´¬ª     . <br><br>  c/cpp-    .   ,      GitHub,  - cpp-    .   ,       ML. <br><br> ,    .    GitHub .     ,    .  ,         .  ,    .cpp-     . <br><br>     .    .    .     ,     ,        .       <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"></a> . <br><br>  .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>        ,      <i>(x == ¬´y¬ª)</i>  strcmp(x, ¬´y¬ª)? <br><br>      ,  ,    <i>m_name</i>  .  , ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>      ,      .     ,          (  <i>std::string</i> ). <br><br>  ,  ,    .h .        ,     .  ,    C  C++. <br><br>  - ,     ,    ,       C  C++. <br><br>     ,    .    ,      ,      .    ,    cpp-. <br><br>     .       (,   ,     ).  ,    .      ,      ,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br><br>  ,     GitHub  .     ,    ,   .    -        .   -   ,    .     .           ¬´ ¬ª.    ,    ,     .cpp    (.i) .      . <br><br>  , ,     ,   .      ,   .       .      ,    -  , ,   . <br><br>  ,     .          .   C  C++  ,   GitHub,      .    ,     . <br><br>  <b>Nota</b>      ,      .   GitHub   C++       ,     .cpp    .         :). <br><br>       ,   C  C++   . <br><br> <b> .    .</b> <br><br>            ,    . <br><br>       <a href="https://www.viva64.com/ru/w/v789/">V789</a> ,     Range-based for loop. ,       ,      .  ,     ,      ,     .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// , , return } }</span></span></code> </pre> <br> ,  .         .  PVS-Studio      26  . <br><br>       ,      . ,   ,      ,    . <br><br>      ,   .  ,      ,   ,      ML.  Es decir           . <br><br> <b> .      .</b> <br><br>     ,         .       (, WinAPI,     ..). <br><br>        C,  <i>strcmp</i> ,      . GitHub, available code results: <br><br><ul><li> strcmp ‚Äî 40,462,158 </li><li> stricmp ‚Äî 1,256,053 </li></ul><br> ,   . ,   , ,  : <ul><li> ,     .  . </li><li> ,     NULL.  . </li><li> ,       .  . </li><li>  Y as√≠ sucesivamente. </li></ul><br>  ?  No     ¬´ ¬ª.    ¬´ ¬ª  .       Top50      . ,     , ,  100  ,      .       , ,  ,   . , - Amazon.com      ,     130  ¬´  ¬ª. <br><br>      .  ,   . ,        : <br><br><ul><li> g_ascii_strncasecmp ‚Äî 35,695 </li><li> lstrcmpiA ‚Äî 27,512 </li><li> _wcsicmp_l ‚Äî 5,737 </li><li> _strnicmp_l ‚Äî 5,848 </li><li> _mbscmp_l ‚Äî 2,458 </li><li>  etc. </li></ul><br>  ,    ,          .      .      .     ,         ,   .       ¬´ ¬ª. <br><br>  PVS-Studio    . ,  C  ++      7200 .  : <br><br><ul><li> WinAPI </li><li>   C, </li><li>    (STL), </li><li> glibc (GNU C Library) </li><li> Qt </li><li> MFC </li><li> zlib </li><li> libpng </li><li> OpenSSL </li><li>  etc. </li></ul><br>   ,    .   .   ,  . <br><br>  .     ML?    ,   . <br><br>  ,  ,   ML,            . ,  .         ,  <i>strcmp</i>  <i>malloc</i> . <br><br> C     .  ,   .       ,  ,        ,     . <br><br>     ,  <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> . ,   ,  <i>fread</i> .          . ,     .      ,       .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>        PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>        , ,   ,    ,   .   ,   write-only .   .   . <br><br>         ML. GitHub   .   15000   .     .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>   ? <br><br><ol><li>   .    . </li><li>  ,        ,          . ,   ,    .    . </li><li>   ,  ,       . ,  .   ML       :).        . </li></ol><br>  , ML         . <br><br>  ,    ML,    ,     ,       ,   . , ,     ,     . <br><br>     . ,    ,   WinAPI.     ,    ,   ?   ,        Google,   ,   <b> </b> .  ,      .   <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a>        ,    .       ,        ,    C++. ,            20. <br><br>     ,       .   ,  <i>memmove</i> .    - : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>    <i>__builtin___memmove_chk</i> ?  intrinsic ,     .      . <br><br>  <i>memmove</i>   - : <a href="">    </a> .         ,  -   . <br><br> Ok,     .  ,        .  ,    ML   ,     ,     . <br><br>        .    .      . ,        ,   .    ,        AI? ,  AI    ,    .       ,               . ,      20   . <br><br> <b> </b> <br><br>    ,      ,       .     .      ,     . <ul><li> <b> </b> .   ,  ,      .           ,    -     . .  C++         <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> .          <i>unique_ptr</i> . </li><li> <b> </b> .  ,   C  C++   ,  <a href="https://www.viva64.com/ru/t/0012/"> </a> .  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li><li> <b> </b> .     ML,   ,  ,    .  Es decir     ,   ‚Äî ,    ,   .     ,       .    ,     ,   ‚Äî ,  .          .      ,    /  , ,   ,       .        .   : " <a href="https://www.viva64.com/ru/b/0612/">   PVS-Studio:    </a> ".       ,   , . </li></ul><br><h2>  Conclusiones </h2><br>       ,   ,     .    ML    ,    ,    (   )     .       ,   ,  ML    . <br><br>      ,    ,     ML.           ,  ,            . <br><br>  ,     ML      . ,   .  ML    ¬´¬ª               . <br><br>    ,       ,    ,     ,     . <br><br>         ML,       . <br><br><h2>  PS </h2><br>       ,  -  ,       <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%2583%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D1%258B"></a>   ML,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Unicornios luditas"></div><br><br> ,   .               PVS-Studio.          ML.  ,         .          ,     ,   ,     if- :).      ,     :). <br><br>      ,            -,     . <br><br>   .      " <a href="https://www.viva64.com/ru/b/0687/">        PVS-Studio</a> ". <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484202/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>        ,      : Andrey Karpov, Victoria Khanieva. <a href="https://habr.com/en/company/pvs-studio/blog/484202/">Machine Learning in Static Analysis of Program Source Code</a> . </div></div><p>Source: <a href="https://habr.com/ru/post/484208/">https://habr.com/ru/post/484208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484198/index.html">Reverso de la moneda: qui√©n gan√≥ y perdi√≥ con el crecimiento de las acciones de Tesla</a></li>
<li><a href="../484200/index.html">C√≥mo establecer objetivos para alcanzarlos</a></li>
<li><a href="../484202/index.html">Aprendizaje autom√°tico en an√°lisis est√°tico del c√≥digo fuente del programa</a></li>
<li><a href="../484204/index.html">El ransomware sin archivos FTCODE ahora roba cuentas</a></li>
<li><a href="../484206/index.html">Uso de mixins en Dart</a></li>
<li><a href="../484212/index.html">Cosas gratis para el karma: la historia de una startup bielorrusa que cambia el principio de consumo</a></li>
<li><a href="../484214/index.html">Tensores en TensorFlow</a></li>
<li><a href="../484216/index.html">Segunda conferencia de Zabbix en Rusia: inscripci√≥n y fechas importantes</a></li>
<li><a href="../484218/index.html">Optimizamos la automatizaci√≥n: c√≥mo aceleramos las pruebas autom√°ticas de 3 a 4 veces, preservando los desarrollos antiguos</a></li>
<li><a href="../484220/index.html">¬øHas ordenado la entrega? C√≥mo Crossroads entrega 6,000 pedidos por d√≠a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>