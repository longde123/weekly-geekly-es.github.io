<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Uso del aprendizaje autom谩tico en el an谩lisis est谩tico del c贸digo fuente del programa   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El aprendizaje autom谩tico est谩 profundamente arraigado en varias 谩reas de la actividad humana: desde el reconocimiento del habla hasta el diagn贸stico ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso del aprendizaje autom谩tico en el an谩lisis est谩tico del c贸digo fuente del programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Uso del aprendizaje autom谩tico en el an谩lisis est谩tico del c贸digo fuente del programa"></div><br>  El aprendizaje autom谩tico est谩 profundamente arraigado en varias 谩reas de la actividad humana: desde el reconocimiento del habla hasta el diagn贸stico m茅dico.  La popularidad de este enfoque es tan grande que intentan usarlo siempre que sea posible.  Algunos intentos de reemplazar los enfoques cl谩sicos con redes neuronales no tienen tanto 茅xito.  Echemos un vistazo al aprendizaje autom谩tico desde el punto de vista de la creaci贸n de analizadores de c贸digo est谩tico eficaces para encontrar errores y vulnerabilidades potenciales. <br><a name="habracut"></a><br>  A menudo se pregunta al equipo de PVS-Studio si queremos comenzar a utilizar el aprendizaje autom谩tico para encontrar errores en el c贸digo fuente de los programas.  Respuesta corta: s铆, pero muy limitada.  Creemos que con el uso del aprendizaje autom谩tico en los problemas de an谩lisis de c贸digo, existen muchas dificultades.  En la segunda parte del art铆culo hablaremos sobre ellos.  Comencemos con una revisi贸n de nuevas soluciones e ideas. <br><br><h2>  Nuevos enfoques </h2><br>  Actualmente, ya hay muchas implementaciones de analizadores est谩ticos basados en el aprendizaje autom谩tico o que lo utilizan, incluido el aprendizaje profundo y la PNL para la detecci贸n de errores.  No solo los entusiastas, sino tambi茅n las grandes empresas, como Facebook, Amazon o Mozilla, llamaron la atenci贸n sobre el potencial del aprendizaje autom谩tico al buscar errores.  Algunos proyectos no son analizadores est谩ticos completos, pero solo en el medio encuentran algunos errores espec铆ficos durante las confirmaciones. <br><br>  Curiosamente, casi todos se posicionan como productos que cambian el juego que, con la ayuda de la inteligencia artificial, cambiar谩n el proceso de desarrollo. <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br>  Considere algunos ejemplos bien conocidos: <br><br><ol><li>  Deepcode </li><li>  Inferir, Sapienz, SapFix </li><li>  Embold </li><li>  Fuente {d} </li><li>  Compromiso inteligente, asistente de compromiso </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code es una herramienta de b煤squeda de vulnerabilidades en el c贸digo de programas escritos en Java, JavaScript, TypeScript y Python, en los que el aprendizaje autom谩tico est谩 presente como componente.  Seg煤n Boris Paskalev, m谩s de 250 mil reglas ya funcionan.  Esta herramienta est谩 capacitada en funci贸n de los cambios realizados por los desarrolladores en el c贸digo fuente de los proyectos abiertos (un mill贸n de repositorios).  La propia empresa dice que su proyecto es Grammarly para desarrolladores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  En esencia, este analizador compara su soluci贸n con su base de datos de proyectos y le ofrece la mejor soluci贸n estimada de la experiencia de otros desarrolladores. <br><br>  En mayo de 2018, los desarrolladores escribieron que se estaba preparando el soporte para el lenguaje C ++, sin embargo, este lenguaje a煤n no es compatible.  Aunque se indica en el sitio mismo que se puede agregar un nuevo idioma en cuesti贸n de semanas, debido al hecho de que solo un paso depende del an谩lisis del idioma. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Tambi茅n se publica en el sitio un grupo de publicaciones sobre los m茅todos en los que se basa el analizador. <br><br><h3>  Inferir </h3><br>  Facebook est谩 intentando ampliamente introducir nuevos enfoques en sus productos.  No pasaron por alto su atenci贸n y el aprendizaje autom谩tico.  En 2013, compraron una startup que estaba desarrollando un analizador est谩tico basado en m谩quina.  Y en 2015, el c贸digo fuente del proyecto <a href="https://github.com/facebook/infer">se abri贸</a> . <br><br>  Infer es un analizador est谩tico para proyectos escritos en Java, C, C ++ y Objective-C, desarrollado por Facebook.  Seg煤n el sitio, tambi茅n se usa en Amazon Web Services, Oculus, Uber y otros proyectos populares. <br><br>  Infer actualmente es capaz de detectar errores relacionados con la eliminaci贸n de referencias de un puntero nulo, p茅rdidas de memoria.  Infer se basa en la l贸gica de Hoar, la l贸gica de separaci贸n y la bi-abducci贸n, as铆 como en la teor铆a de la interpretaci贸n abstracta.  El uso de estos enfoques permite al analizador dividir el programa en peque帽os bloques (fragmentos) y analizarlos independientemente uno del otro. <br><br>  Puede intentar usar Infer en sus proyectos, sin embargo, los desarrolladores advierten que aunque en los proyectos de Facebook los resultados 煤tiles representan el 80% de los resultados, en otros proyectos no se garantiza un bajo n煤mero de falsos positivos.  Algunos de los errores que Infer a煤n no puede encontrar, pero los desarrolladores est谩n trabajando para introducir dichos desencadenantes: <br><br><ul><li>  saliendo de la matriz; </li><li>  excepciones de tipograf铆a; </li><li>  fuga de datos no verificados; </li><li>  carrera condici贸n de carrera. </li></ul><br><h3>  Sapfix </h3><br>  SapFix es una herramienta de edici贸n automatizada.  Recibe informaci贸n de Sapienz, una herramienta de automatizaci贸n de pruebas y del analizador est谩tico Infer, y bas谩ndose en los 煤ltimos cambios y mensajes, Infer elige una de varias estrategias para corregir errores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  En algunos casos, SapFix revierte todos o parte de los cambios.  En otros casos, intenta resolver el problema generando un parche a partir de su conjunto de patrones de arreglos.  Este conjunto se forma a partir de las plantillas de edici贸n compiladas por los propios programadores a partir del conjunto de ediciones ya realizadas una vez.  Si dicha plantilla no corrige el error, SapFix intenta ajustar la plantilla a la situaci贸n, haciendo peque帽as modificaciones en el 谩rbol de sintaxis abstracta hasta que se encuentre una posible soluci贸n. <br><br>  Pero una soluci贸n potencial no es suficiente, por lo que SapFix recopila varias soluciones que se seleccionan en base a tres preguntas: 驴hay alg煤n error de compilaci贸n, hay un bloqueo, la edici贸n introduce nuevos bloqueos?  Una vez que las ediciones se prueban por completo, los parches se env铆an para su revisi贸n al programador que decide cu谩l de las ediciones resuelve mejor el problema. <br><br><h3>  Embold </h3><br>  Embold es una plataforma de inicio para el an谩lisis est谩tico del c贸digo fuente de los programas, que antes del cambio de nombre se llamaba Gamma.  El an谩lisis est谩tico se realiza sobre la base de nuestros propios diagn贸sticos, as铆 como sobre la base de analizadores integrados como Cppheck, SpotBugs, SQL Check y otros. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Adem谩s de los diagn贸sticos en s铆, el 茅nfasis est谩 en la capacidad de mostrar visualmente las infograf铆as por la carga de la base del c贸digo y ver convenientemente los errores encontrados, as铆 como buscar la posibilidad de refactorizar.  Adem谩s, este analizador tiene un conjunto de antipatrones que le permiten detectar problemas en la estructura del c贸digo a nivel de clases y m茅todos, y varias m茅tricas para calcular la calidad del sistema. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Una de las principales ventajas es la soluci贸n inteligente y el sistema de sugerencia de revisi贸n, que, adem谩s de los diagn贸sticos habituales, verifica las revisiones basadas en informaci贸n sobre cambios anteriores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Utilizando NLP, Embold divide el c贸digo en partes y busca interconexiones y dependencias entre funciones y m茅todos entre ellas, lo que ahorra tiempo de refactorizaci贸n. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Por lo tanto, Embold ofrece principalmente una visualizaci贸n conveniente de los resultados de an谩lisis de su c贸digo fuente por varios analizadores, as铆 como sus propios diagn贸sticos, algunos de los cuales se basan en el aprendizaje autom谩tico. <br><br><h3>  Fuente {d} </h3><br>  La fuente {d} es la m谩s abierta en t茅rminos de c贸mo implementarla de los analizadores que examinamos.  Tambi茅n es una <a href="https://github.com/src-d/sourced-ce">soluci贸n de c贸digo abierto</a> .  En su sitio web puede (a cambio de su direcci贸n de correo electr贸nico) obtener un folleto con una descripci贸n de las tecnolog铆as que utilizan.  Adem谩s, contiene un <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">enlace</a> a la base de publicaciones que han recopilado en relaci贸n con el uso del aprendizaje autom谩tico para el an谩lisis de c贸digo, as铆 como un <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">repositorio</a> con un conjunto de datos para la capacitaci贸n en c贸digo.  El producto en s铆 es una plataforma completa para analizar el c贸digo fuente y el producto de software, y se centra, m谩s bien, no en los desarrolladores, sino en los administradores de enlaces.  Entre sus capacidades hay una funci贸n para identificar el volumen de la deuda t茅cnica, los cuellos de botella en el proceso de desarrollo y otras estad铆sticas globales sobre el proyecto. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Basan su enfoque del an谩lisis de c贸digo asistido por m谩quina en la hip贸tesis natural, formulada en el art铆culo " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sobre la naturalidad del software</a> ". <br><br>  <i>"Los lenguajes de programaci贸n, en teor铆a, son complejos, flexibles y potentes, pero los programas que las personas reales escriben en realidad son en su mayor铆a simples y bastante repetitivos, y por lo tanto contienen propiedades estad铆sticas 煤tiles y predecibles que pueden expresarse en estad铆stica modelos de lenguaje y uso para tareas de desarrollo de software ".</i> <br><br>  Seg煤n esta hip贸tesis, cuanto mayor sea la base del c贸digo para entrenar el analizador, m谩s propiedades estad铆sticas destacar谩n y m谩s precisas ser谩n las m茅tricas obtenidas a trav茅s del entrenamiento. <br><br>  Para analizar el c贸digo, source {d} utiliza el servicio Babelfish, que puede analizar un archivo de c贸digo en cualquiera de los idiomas disponibles, obtener un 谩rbol de sintaxis abstracta y convertirlo en un 谩rbol de sintaxis universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Sin embargo, la fuente {d} no busca errores en el c贸digo.  Basado en el 谩rbol, usando el aprendizaje autom谩tico sobre la base de todo el proyecto, la fuente {d} revela c贸mo se formatea el c贸digo, qu茅 estilo de codificaci贸n se usa en el proyecto y al confirmar, y si el nuevo c贸digo no coincide con el estilo del c贸digo del proyecto, realiza los cambios apropiados. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  La capacitaci贸n se gu铆a por varios elementos b谩sicos: espacios, tabulaciones, saltos de l铆nea, etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Puede leer m谩s sobre esto en su publicaci贸n: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: arreglando inconsistencias de estilo de c贸digo con algoritmos interpretables no supervisados</a> ". <br><br>  En general, source {d} es una plataforma amplia para recopilar una amplia variedad de estad铆sticas sobre el c贸digo fuente y el proceso de desarrollo del proyecto, desde calcular la efectividad de los desarrolladores hasta identificar los costos de tiempo para las revisiones de c贸digo. <br><br><h3>  Compromiso inteligente </h3><br>  Clever-Commit es un analizador creado por Mozilla en colaboraci贸n con Ubisoft.  Se basa en el estudio <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> (combinaci贸n de niveles de prevenci贸n de errores y t茅cnicas de resoluci贸n) de Ubisoft, y su asistente de compromiso basado en el producto, que identifica los compromisos sospechosos que probablemente contengan un error.  Debido a que CLEVER se basa en la comparaci贸n de c贸digos, no solo indica un c贸digo peligroso, sino que tambi茅n hace sugerencias sobre posibles correcciones.  Seg煤n la descripci贸n, en 60-70% de los casos Clever-Commit encuentra 谩reas problem谩ticas y con la misma frecuencia ofrece correcciones correctas para ellas.  En general, hay poca informaci贸n sobre este proyecto y sobre los errores que puede encontrar. <br><br><h3>  CodeGuru </h3><br>  Y m谩s recientemente, la lista de analizadores que utilizan el aprendizaje autom谩tico se ha rellenado con un producto de Amazon llamado CodeGuru.  Este servicio se basa en el aprendizaje autom谩tico, que le permite encontrar errores en el c贸digo, as铆 como identificar secciones costosas en 茅l.  Hasta ahora, el an谩lisis es solo para c贸digo Java, pero escriben sobre el soporte para otros idiomas en el futuro.  Aunque se anunci贸 recientemente, el CEO de AWS (Amazon Web Services), Andy Jassi, dice que lo ha estado utilizando durante mucho tiempo en la propia Amazon铆a. <br><br>  El sitio dice que la capacitaci贸n se realiz贸 en la base de c贸digo de Amazon, as铆 como en m谩s de 10,000 proyectos de c贸digo abierto. <br><br>  En esencia, el servicio se divide en dos partes: CodeGuru Reviewer, capacitado buscando reglas asociativas y buscando errores en el c贸digo, y CodeGuru Profiler, que monitorea el rendimiento de la aplicaci贸n. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  En general, no se ha publicado mucha informaci贸n sobre este proyecto.  El sitio dice que para aprender c贸mo detectar las desviaciones de las "mejores pr谩cticas", Reviewer analiza las bases de c贸digo de Amazon y busca solicitudes de extracci贸n que contengan llamadas de la API de AWS en ellas.  Luego observa los cambios realizados y los compara con los datos de la documentaci贸n, que se analiza en paralelo.  El resultado es un modelo de "mejores pr谩cticas". <br><br>  Tambi茅n se dice que las recomendaciones para el c贸digo personalizado mejoran despu茅s de recibir comentarios sobre las recomendaciones. <br><br>  La lista de errores a la que responde Reviewer es bastante borrosa, ya que no se ha publicado documentaci贸n espec铆fica para errores: <ul><li>  Mejores pr谩cticas de AWS </li><li>  Concurrencia </li><li>  Fugas de recursos </li><li>  Fuga de informaci贸n confidencial </li><li>  "Mejores pr谩cticas" comunes para la codificaci贸n </li></ul><br><h2>  Nuestro escepticismo </h2><br>  Ahora veamos el problema de encontrar errores a trav茅s de los ojos de nuestro equipo, que ha estado desarrollando analizadores est谩ticos durante muchos a帽os.  Vemos una serie de problemas de alto nivel de la aplicaci贸n de la capacitaci贸n, de los que queremos hablar.  Pero al principio dividimos aproximadamente todos los enfoques de ML en dos tipos: <br><br><ol><li>  Entrene manualmente un analizador est谩tico para buscar varios problemas utilizando ejemplos de c贸digo sint茅tico y real; </li><li>  Entrene los algoritmos en una gran cantidad de c贸digo fuente abierto (GitHub) y cambie el historial, despu茅s de lo cual el analizador comenzar谩 a detectar errores e incluso sugerir谩 correcciones. </li></ol><br>  Hablaremos de cada direcci贸n por separado, ya que tendr谩n varias deficiencias inherentes.  Despu茅s de lo cual, creo, quedar谩 claro para los lectores por qu茅 no negamos la posibilidad de aprendizaje autom谩tico, sino que tampoco compartimos entusiasmo. <br><br>  <b>Nota</b>  Miramos desde la perspectiva del desarrollo de un analizador est谩tico universal de uso general.  Estamos enfocados en el desarrollo de un analizador que no se centre en una base de c贸digo espec铆fica, sino que cualquier equipo pueda usar en cualquier proyecto. <br><br><h3>  Manual de entrenamiento analizador est谩tico </h3><br>  Supongamos que queremos usar ML para que el analizador comience a buscar anomal铆as de la siguiente forma en el c贸digo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Es extra帽o comparar una variable consigo misma.  Podemos escribir muchos ejemplos de c贸digo correcto e incorrecto y capacitar al analizador para que busque dichos errores.  Adem谩s, es posible agregar ejemplos reales de errores ya encontrados a las pruebas.  La pregunta, por supuesto, es d贸nde obtener estos ejemplos.  Pero consideraremos que es posible.  Por ejemplo, hemos acumulado una serie de ejemplos de tales errores: <a href="https://www.viva64.com/ru/examples/v501/">V501</a> , <a href="https://www.viva64.com/ru/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/ru/examples/v6001/">V6001</a> . <br><br>  Entonces, 驴es posible buscar tales defectos en el c贸digo utilizando algoritmos de aprendizaje autom谩tico?  Usted puede  隆Pero no est谩 claro por qu茅 hacer esto! <br><br>  Vea, para capacitar al analizador, debemos dedicar mucho esfuerzo a preparar ejemplos para la capacitaci贸n.  O marque el c贸digo de aplicaciones reales, indicando d贸nde jurar y d贸nde no.  En cualquier caso, habr谩 que hacer mucho trabajo, ya que debe haber miles de ejemplos de capacitaci贸n.  O decenas de miles. <br><br>  Despu茅s de todo, queremos buscar no solo casos (A == A), sino tambi茅n: <br><br><ul><li>  si (X &amp;&amp; A == A) </li><li>  si (A + 1 == A + 1) </li><li>  si (A [i] == A [i]) </li><li>  si ((A) == (A)) </li><li>  Y as铆 sucesivamente. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br><br>  Ahora veamos c贸mo se implementar铆a un diagn贸stico tan simple en PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">" , !"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Y eso es todo.  隆No se necesita una base de entrenamiento de muestra! <br><br>  En el futuro, se debe ense帽ar a los diagn贸sticos a tener en cuenta una serie de excepciones y comprender que debe jurar en (A [0] == A [1-1]).  Sin embargo, todo esto es muy f谩cil de programar.  Pero solo con la base de ejemplos para el entrenamiento, todo ser谩 malo. <br><br>  Tenga en cuenta que en ambos casos a煤n se requerir谩 un sistema de prueba, documentaci贸n escrita, etc.  Sin embargo, el esfuerzo por crear un nuevo diagn贸stico est谩 claramente del lado del enfoque cl谩sico, donde la regla simplemente est谩 codificada en c贸digo. <br><br>  Veamos ahora alguna otra regla.  Por ejemplo, que se debe utilizar el resultado de algunas funciones.  No tiene sentido llamarlos sin usar su resultado.  Estas son algunas de estas caracter铆sticas: <ul><li>  malloc </li><li>  memcmp </li><li>  cadena :: vac铆o </li></ul><br>  En general, esto es lo que hacen los diagn贸sticos de <a href="https://www.viva64.com/ru/w/v530/">V530</a> implementados en PVS-Studio. <br><br>  Por lo tanto, queremos buscar llamadas a tales funciones donde no se utiliza el resultado de su trabajo.  Para hacer esto, puede generar muchas pruebas.  Y creemos que todo funcionar谩 bien.  Pero nuevamente, no est谩 claro por qu茅 esto es necesario. <br><br>  La implementaci贸n del diagn贸stico V530 con todas las excepciones en el analizador PVS-Studio es de 258 l铆neas de c贸digo, de las cuales 64 l铆neas son comentarios.  Adem谩s, hay una tabla con anotaciones de funciones, donde se observa que se debe usar su resultado.  Reponer esta tabla es mucho m谩s f谩cil que crear ejemplos sint茅ticos. <br><br>  La situaci贸n ser谩 a煤n peor con diagn贸sticos que utilizan an谩lisis de flujo de datos.  Por ejemplo, el analizador PVS-Studio puede rastrear el valor de los punteros, lo que permite encontrar una p茅rdida de memoria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Se toma un ejemplo del art铆culo " <a href="https://www.viva64.com/ru/b/0555/">Cromo: p茅rdidas de memoria</a> ".  Si <i>se cumple</i> la condici贸n <i>(pkey.n0inv == 0)</i> , la funci贸n sale sin liberar el b煤fer, cuyo puntero se almacena en la variable <i>n</i> . <br><br>  Desde el punto de vista de PVS-Studio, no hay nada complicado.  El analizador estudi贸 la funci贸n <i>BnNew</i> y record贸 que devuelve un puntero a un bloque de memoria asignada.  En otra funci贸n, not贸 que es posible una situaci贸n en la que el b煤fer no se libera, y el puntero hacia 茅l se pierde cuando la funci贸n sale. <br><br>  Un algoritmo de seguimiento de valor general funciona.  No importa c贸mo se escriba el c贸digo.  No importa qu茅 m谩s hay en la funci贸n que no est茅 relacionada con el trabajo con punteros.  El algoritmo es universal y el diagn贸stico V773 encuentra muchos errores en varios proyectos.  隆Vea cu谩n diferentes son los <a href="https://www.viva64.com/ru/examples/v773/">fragmentos de c贸digo</a> donde se detectan los errores! <br><br>  No somos expertos en aprendizaje autom谩tico, pero parece que habr谩 grandes problemas.  Hay una incre铆ble cantidad de formas en que puede escribir c贸digo con p茅rdidas de memoria.  Incluso si la m谩quina est谩 entrenada para rastrear el valor de las variables, ser谩 necesario entrenarla para comprender que hay llamadas a funciones. <br><br>  Existe la sospecha de que se necesitar谩n tantos ejemplos para la capacitaci贸n que la tarea se vuelve desalentadora.  No decimos que sea irrealizable.  Dudamos de que los costos de crear un analizador valgan la pena. <br><br>  <b>Analogia</b>  Una analog铆a viene a la mente con una calculadora, donde en lugar de diagn贸sticos es necesario programar operaciones aritm茅ticas.  Estamos seguros de que puede ense帽arle a una calculadora basada en ML a sumar n煤meros bien introduciendo una base de conocimiento sobre el resultado de las operaciones 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300, y as铆 sucesivamente.  Como saben, la conveniencia de desarrollar una calculadora de este tipo es una gran pregunta (si no se asigna una subvenci贸n para ello :).  Se puede escribir una calculadora mucho m谩s simple, m谩s r谩pida, m谩s precisa y confiable utilizando la operaci贸n ordinaria "+" en el c贸digo. <br><br>  <b>Conclusi贸n</b>  El m茅todo funcionar谩.  Pero usarlo, en nuestra opini贸n, no tiene sentido pr谩ctico.  El desarrollo llevar谩 m谩s tiempo y el resultado es menos confiable y preciso, especialmente si se trata de la implementaci贸n de diagn贸sticos complejos basados en el an谩lisis del flujo de datos. <br><br><h3>  Aprendiendo de mucha fuente abierta </h3><br>  Bueno, descubrimos ejemplos sint茅ticos manuales, pero hay GitHub.  Puede realizar un seguimiento del historial de confirmaciones y derivar patrones de cambios / correcciones de c贸digo.  Luego puede se帽alar no solo secciones del c贸digo sospechoso, sino incluso sugerir una forma de solucionarlo. <br><br>  Si se detiene en este nivel de detalle, entonces todo se ve bien.  El diablo, como siempre, est谩 en los detalles.  Hablemos de estos detalles. <br><br>  <b>El primer matiz.</b>  <b>Fuente de datos</b> <br><br>  Las ediciones en GitHub son bastante ca贸ticas y variadas.  Las personas a menudo son demasiado flojas para realizar confirmaciones at贸micas y hacer varios cambios al c贸digo a la vez.  Usted mismo sabe c贸mo sucede: corrigieron el error y, al mismo tiempo, reestructuraron un poco ("Y aqu铆 agregar茅 el procesamiento de tal caso al mismo tiempo ...").  Incluso entonces, puede no estar claro para una persona si estos cambios est谩n relacionados entre s铆 o no. <br><br>  El problema es c贸mo distinguir los errores reales de agregar nueva funcionalidad u otra cosa.  Por supuesto, puede plantar 1,000 personas manualmente para marcar confirmaciones.  La gente tendr谩 que indicar que corrigi贸 el error aqu铆, refactorizando aqu铆, nueva funcionalidad aqu铆, requisitos modificados aqu铆, etc. <br><br>  驴Es posible este marcado?  Posible  Pero preste atenci贸n a qu茅 tan r谩pido ocurre el cambio.  En lugar de "aprender el algoritmo en s铆 mismo sobre la base de GitHub", ya estamos discutiendo c贸mo confundir a cientos de personas durante mucho tiempo.  Los costos laborales y el costo de crear una herramienta aumentan considerablemente. <br><br>  Puede intentar identificar autom谩ticamente d贸nde se solucionaron exactamente los errores.  Para hacer esto, debe analizar los comentarios sobre las confirmaciones, prestar atenci贸n a las peque帽as ediciones locales, que, muy probablemente, son exactamente la revisi贸n del error.  Es dif铆cil decir qu茅 tan bien puede buscar autom谩ticamente correcciones de errores.  En cualquier caso, esta es una gran tarea que requiere investigaci贸n y programaci贸n por separado. <br><br>  Entonces, todav铆a no hemos llegado a la capacitaci贸n, pero ya hay matices :). <br><br>  <b>El segundo matiz.</b>  <b>Retraso en el desarrollo.</b> <br><br>  Los analizadores que se entrenar谩n sobre la base de bases de datos como GitHub siempre estar谩n sujetos a un s铆ndrome como "retraso mental".  Esto se debe a que los lenguajes de programaci贸n cambian con el tiempo. <br><br>  C # 8.0 <a href="https://www.viva64.com/ru/b/0631/">introdujo los</a> tipos de referencia anulables para ayudar a lidiar con las excepciones de referencia nula (NRE).  JDK 12 presenta una nueva declaraci贸n de cambio ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  En C ++ 17, se hizo posible ejecutar construcciones condicionales en la etapa de compilaci贸n ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr si</a> ).  Y as铆 sucesivamente. <br><br>  Los lenguajes de programaci贸n est谩n evolucionando.  Adem谩s, como C ++ son muy r谩pidos y activos.  En ellos aparecen nuevos dise帽os, se a帽aden nuevas funciones est谩ndar, etc.  Junto con las nuevas caracter铆sticas, tambi茅n aparecen nuevos patrones de error que tambi茅n nos gustar铆a identificar mediante el an谩lisis de c贸digo est谩tico. <br><br>  Y aqu铆 el m茅todo de ense帽anza en consideraci贸n tiene un problema: el patr贸n de error ya puede ser conocido, hay un deseo de identificarlo, pero no hay nada de qu茅 aprender. <br><br>  Veamos este problema con un ejemplo espec铆fico.  El rango basado en el rango apareci贸 en C ++ 11.  Y puede escribir el siguiente c贸digo, iterando sobre todos los elementos en el contenedor: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  El nuevo ciclo trajo consigo un nuevo patr贸n de error.  Si el contenedor se cambia dentro del bucle, esto conducir谩 a la invalidaci贸n de los iteradores de "sombra". <br><br>  Considere el siguiente c贸digo incorrecto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  El compilador lo convertir谩 en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Durante la operaci贸n <i>push_back</i> , puede producirse la <i>invalidaci贸n de los</i> iteradores <i>__begin</i> y <i>__end</i> si se produce una asignaci贸n de memoria dentro del vector.  El resultado ser谩 un comportamiento indefinido del programa. <br><br>  Por lo tanto, el patr贸n de error se conoce y describe desde hace tiempo en la literatura.  El analizador PVS-Studio lo diagnostica utilizando los diagn贸sticos <a href="https://www.viva64.com/ru/w/v789/">V789</a> y ya ha encontrado <a href="https://www.viva64.com/ru/examples/v789/">errores reales</a> en proyectos abiertos. <br><br>  驴Cu谩ndo habr谩 suficiente c贸digo nuevo en GitHub para notar este patr贸n?  Buena pregunta ... Debe comprender que si apareci贸 el bucle for basado en rango, esto no significa que todos los programadores inmediatamente comenzaron a usarlo de forma masiva.  Pueden pasar a帽os antes de que aparezca mucho c贸digo utilizando un nuevo bucle.  Adem谩s, deben cometerse muchos errores, y luego deben corregirse para que el algoritmo pueda notar el patr贸n en los cambios. <br><br>  驴Cu谩ntos a帽os deber铆an pasar?  Cinco?  Diez? <br><br>  Diez es demasiado, 驴y somos pesimistas?  En absoluto  Han pasado ocho a帽os cuando se escribi贸 este art铆culo, ya que el rango para loop apareci贸 en C ++ 11.  Pero hasta ahora, solo <a href="https://www.viva64.com/ru/examples/v789/">tres casos de</a> tal error se han escrito en nuestra base de datos.  Tres errores no son mucho ni poco.  No se debe sacar ninguna conclusi贸n de su n煤mero.  Lo principal es que puede confirmar que dicho patr贸n de error es real y tiene sentido detectarlo. <br><br>  Ahora compare esta cantidad, por ejemplo, con este patr贸n de error: el <a href="https://www.viva64.com/ru/examples/v595/">puntero se desreferencia antes de la verificaci贸n</a> .  En total, al verificar proyectos de c贸digo abierto, ya identificamos 1716 casos de este tipo. <br><br>  驴Quiz谩s no deber铆a buscar errores de bucle basados en el rango?  No  Solo los programadores son inerciales, y este operador est谩 ganando popularidad muy lentamente.  Gradualmente, habr谩 una gran cantidad de c贸digo con su participaci贸n y, en consecuencia, tambi茅n habr谩 m谩s errores. <br><br>  Lo m谩s probable es que esto suceda solo despu茅s de 10-15 a帽os desde el momento en que apareci贸 C ++ 11.  Y ahora una pregunta filos贸fica.  驴Ya conociendo el patr贸n de error, solo esperaremos muchos a帽os hasta que se acumulen muchos errores en los proyectos abiertos? <br><br>  Si la respuesta es "s铆", entonces es posible diagnosticar razonablemente a todos los analizadores basados en ML el diagn贸stico de "retraso mental". <br><br>  Si la respuesta es no, 驴qu茅 debo hacer?  No hay ejemplos  驴Para escribirlos manualmente?  Pero luego volvemos al cap铆tulo anterior, donde consideramos escribirle a una persona muchos ejemplos para aprender. <br><br>  Esto se puede hacer, pero nuevamente surge la cuesti贸n de la conveniencia.  La implementaci贸n del diagn贸stico V789 con todas las excepciones en el analizador PVS-Studio es de solo 118 l铆neas de c贸digo, de las cuales 13 l铆neas son comentarios.  Es decir  Este es un diagn贸stico muy simple que se puede tomar y programar f谩cilmente de una manera cl谩sica. <br><br>  Una situaci贸n similar ser谩 con cualquier otra innovaci贸n que aparezca en cualquier otro idioma.  Como dicen, hay algo en qu茅 pensar. <br><br>  <b>El tercer matiz.</b>  <b>Documentaci贸n</b> <br><br>  Un componente importante de cualquier analizador est谩tico es la documentaci贸n que describe cada diagn贸stico.  Sin 茅l, usar el analizador ser谩 extremadamente dif铆cil o incluso imposible.  En la <a href="https://www.viva64.com/ru/w/">documentaci贸n</a> de PVS-Studio, tenemos una descripci贸n de cada diagn贸stico, que proporciona un ejemplo de un c贸digo err贸neo y c贸mo solucionarlo.  Tambi茅n hay un enlace a <a href="https://cwe.mitre.org/">CWE</a> donde puede leer una descripci贸n alternativa del problema.  Y de todos modos, a veces algo es incomprensible para los usuarios y nos hacen preguntas aclaratorias. <br><br>  En el caso de los analizadores est谩ticos, que se basan en algoritmos de aprendizaje autom谩tico, el problema de la documentaci贸n se oculta de alguna manera.  Se supone que el analizador simplemente indica un lugar que le parece sospechoso y, tal vez, incluso sugiere c贸mo solucionarlo.  La decisi贸n de hacer un cambio o no permanece con la persona.  Y aqu铆 ... ejem ... No es f谩cil tomar una decisi贸n, no poder leer, sobre la base de lo cual el analizador parece sospechar de uno u otro lugar en el c贸digo. <br><br>  Por supuesto, en algunos casos todo ser谩 obvio.  Supongamos que el analizador apunta a este c贸digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Y ofrecer谩 reemplazarlo con: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Est谩 claro de inmediato que el programador sell贸 y agreg贸 1 en el lugar equivocado.  Como resultado, se asignar谩 menos memoria. <br><br>  Aqu铆, sin documentaci贸n, todo est谩 claro.  Sin embargo, este no siempre ser谩 el caso. <br><br>  Imagine que el analizador se帽ala silenciosamente este c贸digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Y sugiere cambiar el tipo del valor de retorno de char a int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  No hay documentaci贸n para la advertencia.  Y aparentemente, el texto de la advertencia en s铆, tal como lo entendemos, tampoco lo ser谩, si estamos hablando de un analizador completamente independiente. <br><br>  Que hacer  Cual es la diferencia  驴Debo hacer tal reemplazo? <br><br>  En principio, aqu铆 puede arriesgarse y aceptar arreglar el c贸digo.  Aunque acepta ediciones sin entenderlas, esta es una pr谩ctica <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>regular</i></a> ... :) Puede ver la descripci贸n de la funci贸n <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> y leer que la funci贸n devuelve valores <i>int</i> : 0 que son mayores que cero y menores que cero.  Pero de todos modos, puede que no est茅 claro por qu茅 hacer cambios si el c贸digo ya funciona correctamente. <br><br>  Ahora, si no sabe cu谩l es el objetivo de dicha edici贸n, lea la descripci贸n de los diagn贸sticos <a href="https://www.viva64.com/ru/w/v642/">V642</a> .  De inmediato queda claro que esto es un verdadero error.  Adem谩s, puede causar vulnerabilidad. <br><br>  Quiz谩s el ejemplo parec铆a poco convincente.  Despu茅s de todo, el analizador propuso un c贸digo que probablemente sea mejor.  Ok  Veamos otro ejemplo de pseudoc贸digo, esta vez, para variar, en Java. <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Hay alg煤n tipo de objeto.  Est谩 serializado.  Luego, el estado del objeto cambia y se serializa nuevamente.  Todo parece estar bien.  Ahora imagine que al analizador, de repente, no le gusta este c贸digo, y sugiere reemplazarlo con: <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">//    obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  En lugar de cambiar el objeto y volver a grabarlo, se crea un nuevo objeto y ya est谩 serializado. <br><br>  No hay una descripci贸n del problema.  Sin documentaci贸n  El c贸digo se ha vuelto m谩s largo.  Por alguna raz贸n, se agreg贸 la creaci贸n de un nuevo objeto.  驴Est谩s listo para hacer tal edici贸n en tu c贸digo? <br><br>  Dir谩s que no est谩 claro.  De hecho, no est谩 claro.  Y ser谩 incomprensible todo el tiempo.  Trabajar con un analizador "silencioso" ser谩 un estudio interminable en un intento por comprender por qu茅 al analizador no le gusta algo. <br><br>  Si hay documentaci贸n, entonces todo se vuelve transparente.  La clase <i>java.io.ObjectOuputStream</i> , que se utiliza para la serializaci贸n, almacena en cach茅 los objetos que se pueden escribir.  Esto significa que el mismo objeto no se serializar谩 dos veces.  Una vez que la clase serializa el objeto, y la segunda vez, simplemente escribe un enlace al mismo primer objeto en la secuencia.  Leer m谩s: <a href="https://www.viva64.com/ru/w/v6076/">V6076</a> : la serializaci贸n recurrente utilizar谩 el estado del objeto en cach茅 desde la primera serializaci贸n. <br><br>  Esperamos haber podido explicar la importancia de tener documentaci贸n.  Y ahora la pregunta.  驴C贸mo aparecer谩 la documentaci贸n para un analizador basado en ML? <br><br>  Cuando se desarrolla un analizador de c贸digo cl谩sico, todo es simple y claro.  Hay un cierto patr贸n de errores.  Lo describimos en la documentaci贸n e implementamos los diagn贸sticos. <br><br>  En el caso de ML, lo contrario es cierto.  S铆, el analizador puede notar una anomal铆a en el c贸digo y se帽alarlo.  Pero 茅l no sabe nada sobre la esencia del defecto.  l no entiende y no dir谩 por qu茅 el c贸digo no se puede escribir as铆.  Estas son abstracciones de alto nivel.  Luego, el analizador tambi茅n debe aprender a leer y <b>comprender la</b> documentaci贸n de las funciones. <br><br>  Como dije, dado que el tema de la documentaci贸n est谩 cubierto en art铆culos sobre aprendizaje autom谩tico, no estamos listos para hablar m谩s.  Solo otro gran matiz que sacamos para su revisi贸n. <br><br>  <b>Nota</b>  Se puede argumentar que la documentaci贸n es opcional.  El analizador puede conducir a muchos ejemplos de soluciones en GitHub y la persona, observando los compromisos y comentarios sobre ellos, descubrir谩 qu茅 es qu茅.  Si lo es  Pero la idea no parece atractiva.  En lugar de un asistente, el analizador act煤a como una herramienta que confundir谩 a煤n m谩s al programador. <br><br>  <b>El cuarto matiz.</b>  <b>Idiomas altamente especializados.</b> <br><br>  El enfoque descrito no es aplicable para lenguajes altamente especializados para los que el an谩lisis est谩tico tambi茅n puede ser extremadamente 煤til.  La raz贸n es que GitHub y otras fuentes simplemente no tienen una base de c贸digo fuente lo suficientemente grande como para proporcionar una capacitaci贸n efectiva. <br><br>  Considere esto con un ejemplo espec铆fico.  Para comenzar, vaya a GitHub y busque repositorios para el popular lenguaje Java. <br><br>  Resultado: lenguaje: "Java": <b>3.128.884</b> resultados de repositorio disponibles <br><br>  Ahora tomemos el lenguaje especializado "1C Enterprise" utilizado en aplicaciones de contabilidad emitidas por la compa帽铆a rusa <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Resultado: idioma: "1C Enterprise": <b>551</b> resultados de repositorio disponibles <br><br>  驴Quiz谩s no se necesitan analizadores para este idioma?  Son necesarios  Existe una necesidad pr谩ctica para el an谩lisis de tales programas, y los analizadores correspondientes ya existen.  Por ejemplo, hay un complemento SonarQube 1C (BSL) fabricado por <a href="https://silverbulleters.org/">Silver Bullet</a> . <br><br> , -    ,          . <br><br> <b> . C, C++, #include</b> . <br><br> ,          ML,    ,  Java, JavaScript, Python.     .    C  C++ -  ,      . <br><br>    ,     /,   ,    C  C++  .    芦禄     . <br><br>  c/cpp-    .   ,      GitHub,  - cpp-    .   ,       ML. <br><br> ,    .    GitHub .     ,    .  ,         .  ,    .cpp-     . <br><br>     .    .    .     ,     ,        .       <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"></a> . <br><br>  .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>        ,      <i>(x == 芦y禄)</i>  strcmp(x, 芦y禄)? <br><br>      ,  ,    <i>m_name</i>  .  , ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>      ,      .     ,          (  <i>std::string</i> ). <br><br>  ,  ,    .h .        ,     .  ,    C  C++. <br><br>  - ,     ,    ,       C  C++. <br><br>     ,    .    ,      ,      .    ,    cpp-. <br><br>     .       (,   ,     ).  ,    .      ,      ,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br><br>  ,     GitHub  .     ,    ,   .    -        .   -   ,    .     .           芦 禄.    ,    ,     .cpp    (.i) .      . <br><br>  , ,     ,   .      ,   .       .      ,    -  , ,   . <br><br>  ,     .          .   C  C++  ,   GitHub,      .    ,     . <br><br>  <b>Nota</b>      ,      .   GitHub   C++       ,     .cpp    .         :). <br><br>       ,   C  C++   . <br><br> <b> .    .</b> <br><br>            ,    . <br><br>       <a href="https://www.viva64.com/ru/w/v789/">V789</a> ,     Range-based for loop. ,       ,      .  ,     ,      ,     .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// , , return } }</span></span></code> </pre> <br> ,  .         .  PVS-Studio      26  . <br><br>       ,      . ,   ,      ,    . <br><br>      ,   .  ,      ,   ,      ML.  Es decir           . <br><br> <b> .      .</b> <br><br>     ,         .       (, WinAPI,     ..). <br><br>        C,  <i>strcmp</i> ,      . GitHub, available code results: <br><br><ul><li> strcmp  40,462,158 </li><li> stricmp  1,256,053 </li></ul><br> ,   . ,   , ,  : <ul><li> ,     .  . </li><li> ,     NULL.  . </li><li> ,       .  . </li><li>  Y as铆 sucesivamente. </li></ul><br>  ?  No     芦 禄.    芦 禄  .       Top50      . ,     , ,  100  ,      .       , ,  ,   . , - Amazon.com      ,     130  芦  禄. <br><br>      .  ,   . ,        : <br><br><ul><li> g_ascii_strncasecmp  35,695 </li><li> lstrcmpiA  27,512 </li><li> _wcsicmp_l  5,737 </li><li> _strnicmp_l  5,848 </li><li> _mbscmp_l  2,458 </li><li>  etc. </li></ul><br>  ,    ,          .      .      .     ,         ,   .       芦 禄. <br><br>  PVS-Studio    . ,  C  ++      7200 .  : <br><br><ul><li> WinAPI </li><li>   C, </li><li>    (STL), </li><li> glibc (GNU C Library) </li><li> Qt </li><li> MFC </li><li> zlib </li><li> libpng </li><li> OpenSSL </li><li>  etc. </li></ul><br>   ,    .   .   ,  . <br><br>  .     ML?    ,   . <br><br>  ,  ,   ML,            . ,  .         ,  <i>strcmp</i>  <i>malloc</i> . <br><br> C     .  ,   .       ,  ,        ,     . <br><br>     ,  <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> . ,   ,  <i>fread</i> .          . ,     .      ,       .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>        PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>        , ,   ,    ,   .   ,   write-only .   .   . <br><br>         ML. GitHub   .   15000   .     .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>   ? <br><br><ol><li>   .    . </li><li>  ,        ,          . ,   ,    .    . </li><li>   ,  ,       . ,  .   ML       :).        . </li></ol><br>  , ML         . <br><br>  ,    ML,    ,     ,       ,   . , ,     ,     . <br><br>     . ,    ,   WinAPI.     ,    ,   ?   ,        Google,   ,   <b> </b> .  ,      .   <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a>        ,    .       ,        ,    C++. ,            20. <br><br>     ,       .   ,  <i>memmove</i> .    - : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>    <i>__builtin___memmove_chk</i> ?  intrinsic ,     .      . <br><br>  <i>memmove</i>   - : <a href="">    </a> .         ,  -   . <br><br> Ok,     .  ,        .  ,    ML   ,     ,     . <br><br>        .    .      . ,        ,   .    ,        AI? ,  AI    ,    .       ,               . ,      20   . <br><br> <b> </b> <br><br>    ,      ,       .     .      ,     . <ul><li> <b> </b> .   ,  ,      .           ,    -     . .  C++         <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> .          <i>unique_ptr</i> . </li><li> <b> </b> .  ,   C  C++   ,  <a href="https://www.viva64.com/ru/t/0012/"> </a> .  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li><li> <b> </b> .     ML,   ,  ,    .  Es decir     ,    ,    ,   .     ,       .    ,     ,    ,  .          .      ,    /  , ,   ,       .        .   : " <a href="https://www.viva64.com/ru/b/0612/">   PVS-Studio:    </a> ".       ,   , . </li></ul><br><h2>  Conclusiones </h2><br>       ,   ,     .    ML    ,    ,    (   )     .       ,   ,  ML    . <br><br>      ,    ,     ML.           ,  ,            . <br><br>  ,     ML      . ,   .  ML    芦禄               . <br><br>    ,       ,    ,     ,     . <br><br>         ML,       . <br><br><h2>  PS </h2><br>       ,  -  ,       <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%2583%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D1%258B"></a>   ML,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Unicornios luditas"></div><br><br> ,   .               PVS-Studio.          ML.  ,         .          ,     ,   ,     if- :).      ,     :). <br><br>      ,            -,     . <br><br>   .      " <a href="https://www.viva64.com/ru/b/0687/">        PVS-Studio</a> ". <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484202/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>        ,      : Andrey Karpov, Victoria Khanieva. <a href="https://habr.com/en/company/pvs-studio/blog/484202/">Machine Learning in Static Analysis of Program Source Code</a> . </div></div><p>Source: <a href="https://habr.com/ru/post/484208/">https://habr.com/ru/post/484208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484198/index.html">Reverso de la moneda: qui茅n gan贸 y perdi贸 con el crecimiento de las acciones de Tesla</a></li>
<li><a href="../484200/index.html">C贸mo establecer objetivos para alcanzarlos</a></li>
<li><a href="../484202/index.html">Aprendizaje autom谩tico en an谩lisis est谩tico del c贸digo fuente del programa</a></li>
<li><a href="../484204/index.html">El ransomware sin archivos FTCODE ahora roba cuentas</a></li>
<li><a href="../484206/index.html">Uso de mixins en Dart</a></li>
<li><a href="../484212/index.html">Cosas gratis para el karma: la historia de una startup bielorrusa que cambia el principio de consumo</a></li>
<li><a href="../484214/index.html">Tensores en TensorFlow</a></li>
<li><a href="../484216/index.html">Segunda conferencia de Zabbix en Rusia: inscripci贸n y fechas importantes</a></li>
<li><a href="../484218/index.html">Optimizamos la automatizaci贸n: c贸mo aceleramos las pruebas autom谩ticas de 3 a 4 veces, preservando los desarrollos antiguos</a></li>
<li><a href="../484220/index.html">驴Has ordenado la entrega? C贸mo Crossroads entrega 6,000 pedidos por d铆a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>