<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◀️ 👩🏿‍🤝‍👨🏼 ✋🏿 Apa ini di sini? Operasi Batin Objek JavaScript 🌁 ℹ️ ↖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foto: Curious Liliana Saeb (CC BY 2.0) 


 JavaScript adalah bahasa multi-paradigma yang mendukung pemrograman berorientasi objek dan tautan dinamis. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa ini di sini? Operasi Batin Objek JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452192/"><p><img src="https://habrastorage.org/getpro/habr/post_images/e7b/99c/5ab/e7b99c5ab4652dbe38cb0e5b6fa0da90.jpg"><br>  <em>Foto: Curious Liliana Saeb (CC BY 2.0)</em> </p><br><p> JavaScript adalah bahasa multi-paradigma yang mendukung pemrograman berorientasi objek dan tautan dinamis.  Tautan dinamis adalah konsep yang kuat yang memungkinkan Anda mengubah struktur kode JavaScript saat runtime, tetapi daya tambahan dan fleksibilitas ini diperoleh dengan mengorbankan beberapa kebingungan, yang sebagian besar terkait dengan perilaku <code>this</code> dalam JavaScript. </p><br><h1 id="dinamicheskoe-svyazyvanie">  Tautan dinamis </h1><br><p>  Dengan pengikatan dinamis, definisi metode untuk memanggil terjadi pada waktu berjalan, dan bukan pada waktu kompilasi.  JavaScript melakukan ini dengan <code>this</code> dan rantai prototipe.  Secara khusus, di dalam metode, <code>this</code> ditentukan selama panggilan, dan nilai <code>this</code> akan berbeda tergantung pada bagaimana metode itu didefinisikan. </p><br><p>  Ayo main game.  Saya memanggilnya "Apa <code>this</code> sini?" <a name="habracut"></a></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">'a'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">getThis</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, getThis2 () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; obj.getThis3 = obj.getThis.bind(obj); obj.getThis4 = obj.getThis2.bind(obj); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> answers = [ obj.getThis(), obj.getThis.call(a), obj.getThis2(), obj.getThis2.call(a), obj.getThis3(), obj.getThis3.call(a), obj.getThis4(), obj.getThis4.call(a) ];</code> </pre> <br><p>  Pikirkan tentang apa nilai dalam array <code>answers</code> dan periksa jawaban Anda dengan <code>console.log()</code> .  Tertebak? </p><br><p>  Mari kita mulai dengan kasing pertama dan melanjutkan secara berurutan.  <code>obj.getThis()</code> mengembalikan <code>undefined</code> , tetapi mengapa?  Fungsi panah tidak pernah memiliki <code>this</code> sendiri.  Sebagai gantinya, mereka selalu mengambil <code>this</code> dari ruang lingkup leksikal ( <em>kira-kira <a href="">Leksikal ini</a></em> ).  Untuk root dari modul ES6, wilayah leksikal akan memiliki nilai yang <code>undefined</code> .  <code>obj.getThis.call(a)</code> juga tidak didefinisikan untuk alasan yang sama.  Untuk fungsi panah, <code>this</code> tidak dapat diganti, bahkan dengan <code>.call()</code> atau <code>.bind()</code> .  <code>this</code> akan selalu diambil dari domain leksikal. </p><br><p>  <code>obj.getThis2()</code> mendapatkan pengikatan selama pemanggilan metode.  Jika tidak ada pengikatan ini untuk fungsi ini sebelumnya, maka ini dapat terikat <code>this</code> (karena ini bukan fungsi panah).  Dalam hal ini, <code>this</code> adalah objek <code>obj</code> yang terikat pada saat metode dipanggil <code>.</code>  atau sintaks akses properti <code>[squareBracket]</code> .  ( <em>perhatikan <a href="">penjilidan implisit</a></em> ) </p><br><p>  <code>obj.getThis2.call(a)</code> sedikit lebih rumit.  Metode <code>call()</code> memanggil fungsi dengan nilai yang diberikan ini dan argumen opsional.  Dengan kata lain, metode mendapat pengikatan <code>this</code> dari parameter <code>.call()</code> , jadi <code>obj.getThis2.call(a)</code> mengembalikan objek <code>a</code> .  ( <em>perhatikan <a href="">penjilidan eksplisit</a></em> ) </p><br><p>  Dalam kasus <code>obj.getThis3 = obj.getThis.bind(obj);</code>  kami mencoba untuk mendapatkan fungsi panah dengan ikatan <code>this</code> , yang, seperti yang telah kami ketahui, tidak akan berfungsi, jadi kami mendapatkan <code>undefined</code> untuk <code>obj.getThis3()</code> dan <code>obj.getThis3.call(a)</code> masing-masing. </p><br><p>  Untuk metode reguler, Anda dapat mengikat, jadi <code>obj.getThis4()</code> mengembalikan <code>obj</code> , seperti yang diharapkan.  Dia sudah mendapatkan ikatannya di sini <code>obj.getThis4 = obj.getThis2.bind(obj);</code>  , dan <code>obj.getThis4.call(a)</code> memperhitungkan binding pertama dan mengembalikan <code>obj</code> bukan <code>a</code> . </p><br><h1 id="kruchenyy-myach">  Bola bengkok </h1><br><p>  Kami akan memecahkan masalah yang sama, tetapi kali ini kami menggunakan <code>class</code> dengan bidang publik untuk menjelaskan objek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inovasi Tahap 3</a> pada saat penulisan ini tersedia di Chrome secara default dan dengan properti <code>@babel/plugin-offer-class-properties</code> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obj</span></span></span><span class="hljs-class"> </span></span>{ getThis = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> getThis2 () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Obj(); obj2.getThis3 = obj2.getThis.bind(obj2); obj2.getThis4 = obj2.getThis2.bind(obj2); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> answers2 = [ obj2.getThis(), obj2.getThis.call(a), obj2.getThis2(), obj2.getThis2.call(a), obj2.getThis3(), obj2.getThis3.call(a), obj2.getThis4(), obj2.getThis4.call(a) ];</code> </pre> <br><p>  Pikirkan jawaban sebelum melanjutkan. </p><br><p>  Apakah kamu siap </p><br><p>  Semua panggilan kecuali <code>obj2.getThis2.call(a)</code> mengembalikan instance objek.  <code>obj2.getThis2.call(a)</code> mengembalikan <code>a</code> .  Fungsi panah masih mendapatkan <code>this</code> dari lingkungan leksikal mereka.  Ada perbedaan dalam bagaimana <code>this</code> dari lingkungan leksikal didefinisikan untuk properti kelas.  Di dalam, inisialisasi properti kelas terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getThis = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ...</code> </pre> <br><p>  Dengan kata lain, fungsi panah didefinisikan dalam konteks konstruktor.  Karena ini adalah kelas, satu-satunya cara untuk membuat turunan adalah dengan menggunakan kata kunci <code>new</code> (menghilangkan yang <code>new</code> akan menghasilkan kesalahan).  Salah satu hal terpenting yang dilakukan kata kunci <code>new</code> adalah membuat instance objek baru dan mengikatnya ke konstruktor.  Perilaku ini, dikombinasikan dengan perilaku lain yang kami sebutkan di atas, harus menjelaskan sisanya. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Apakah kamu berhasil?  Pemahaman yang baik tentang bagaimana <code>this</code> berlaku dalam JavaScript akan menghemat banyak waktu untuk debugging masalah yang kompleks.  Jika Anda membuat kesalahan dalam jawaban, ini berarti Anda perlu sedikit berlatih.  Berlatihlah dengan contoh, lalu kembali dan uji diri Anda lagi sampai Anda dapat menjalankan tes dan menjelaskan kepada orang lain mengapa metode mengembalikan apa yang mereka kembalikan. </p><br><p>  Jika itu lebih sulit dari yang Anda harapkan, maka Anda tidak sendirian.  Saya bertanya banyak pengembang tentang topik ini dan saya pikir sejauh ini hanya satu dari mereka yang berhasil mengatasi tugas ini. </p><br><p>  Apa yang dimulai sebagai pencarian metode dinamis yang dapat Anda redirect dengan <code>.call()</code> , <code>.bind()</code> atau <code>.apply()</code> telah menjadi jauh lebih rumit dengan penambahan metode kelas dan fungsi panah.  Mungkin Anda harus sekali lagi fokus pada ini.  Ingat bahwa fungsi panah selalu mengambil <code>this</code> dari lingkup leksikal, dan <code>class</code> <code>this</code> sebenarnya dibatasi secara leksikal oleh konstruktor kelas di bawah tenda.  Jika Anda meragukan <code>this</code> , ingatlah bahwa Anda dapat menggunakan debugger untuk memeriksa nilainya. </p><br><p>  Ingatlah bahwa dalam menyelesaikan banyak tugas JavaScript Anda dapat melakukannya tanpa <code>this</code> .  Dalam pengalaman saya, hampir semuanya dapat didefinisikan ulang dalam hal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi murni</a> yang mengambil semua argumen yang digunakan sebagai parameter eksplisit ( <code>this</code> dapat dianggap sebagai variabel implisit).  Logika yang dijelaskan melalui fungsi murni bersifat deterministik, yang membuatnya lebih dapat diuji.  Juga, dengan pendekatan ini, tidak ada efek samping, oleh karena itu, tidak seperti saat memanipulasi <code>this</code> , Anda tidak mungkin memecahkan apa pun.  Setiap kali <code>this</code> diatur, sesuatu yang tergantung pada nilainya mungkin rusak. </p><br><p>  Namun, terkadang <code>this</code> berguna.  Misalnya, untuk bertukar metode antara sejumlah besar objek.  Bahkan dalam pemrograman fungsional, <code>this</code> dapat digunakan untuk mengakses metode objek lain untuk mengimplementasikan transformasi aljabar yang diperlukan untuk membangun aljabar baru di atas yang sudah ada.  Jadi, universal <code>.flatMap()</code> dapat diperoleh dengan menggunakan <code>this.map()</code> dan <code>this.constructor.of()</code> . </p><br><hr><br><p>  Terima kasih atas bantuannya menerjemahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">wksmirnowa</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">VIBaH_dev</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452192/">https://habr.com/ru/post/id452192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452182/index.html">Survei karyawan. Kesalahan utama</a></li>
<li><a href="../id452184/index.html">Tentang anonimitas di blokir berbasis akun</a></li>
<li><a href="../id452186/index.html">Bahasa pemrograman yang paling langka dan paling mahal</a></li>
<li><a href="../id452188/index.html">Unit pengujian serialisasi Json di Spring Boot</a></li>
<li><a href="../id452190/index.html">Menggunakan WebAssembly 20x Aplikasi Web Dipercepat</a></li>
<li><a href="../id452198/index.html">Apa yang harus diketahui oleh setiap insinyur QA tentang Selenium 4?</a></li>
<li><a href="../id452200/index.html">GOSTIM: P2P F2F E2EE IM dalam satu malam dengan kriptografi GOST</a></li>
<li><a href="../id452202/index.html">Ulasan Sprint: Bawah - Bawah</a></li>
<li><a href="../id452204/index.html">Saat saya menulis AI pertama saya</a></li>
<li><a href="../id452206/index.html">E - Eksperimen. Atau bagaimana sains membantu mendesain antarmuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>