<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍⚕️ 🛌🏿 ♂️ Detectando em C ++ se um tipo está definido: pré-declarando as coisas que você deseja investigar ⬇️ 💘 🧑🏽‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na última vez , usamos o SFINAE para detectar se um tipo tinha uma definição, e o usamos em combinação com if constexpr e lambdas genéricas, para que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detectando em C ++ se um tipo está definido: pré-declarando as coisas que você deseja investigar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/459834/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na última vez</a> , usamos o SFINAE para detectar se um tipo tinha uma definição, e o usamos em combinação com <code>if constexpr</code> e lambdas genéricas, para que o código possa usar o tipo se for definido, enquanto continua sendo aceito pelo compilador (e sendo descartado ) se o tipo não estiver definido. <br><br>  No entanto, nosso uso teve alguns problemas, alguns pequenos aborrecimentos, outros mais frustrantes. <br><br><ul><li>  Você tinha que dizer <code>struct</code> o tempo todo. </li><li>  Se o tipo não existir, o ato de nomeá-lo fará com que o tipo seja injetado no espaço para nome <i>atual</i> , não no espaço para nome em que você esperava que o tipo estivesse. </li><li>  Você deve usar a técnica <code>struct</code> com um nome não qualificado.  Você não pode usá-lo para analisar um tipo que não importou para o espaço para nome atual. </li></ul><br>  Podemos resolver todos os três problemas com uma única solução: Pré-declare o tipo no espaço para nome desejado. <br><br><img src="https://habrastorage.org/webt/pn/ng/uf/pnngufu06qzz6g2xqdripu_mfws.jpeg"><a name="habracut"></a><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// awesome.h namespace awesome { // might or might not contain struct special { ... }; } // your code namespace awesome { // ensure declarations for types we // conditionalize on. struct special; }</span></span></code> </pre><br>  Depois de fazer isso, você não precisa dizer <code>struct</code> porque a estrutura foi definitivamente declarada.  Seu uso como um parâmetro do tipo de modelo em <code>call_if_defined</code> não criará uma nova declaração, porque ela já foi declarada.  E como foi declarado, você pode acessá-lo por meio de seu nome não qualificado, seu nome completo do espaço para nome ou qualquer outra coisa.  Também um alias de tipo ou tipo dependente.  (Desculpe, esses não estão no meio.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> app { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ call_if_defined&lt;awesome::special&gt;([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* p) { <span class="hljs-comment"><span class="hljs-comment">// this code is compiled only if "awesome::special" // is defined. Create a local name for "special" // by inferring it from the dummy parameter. using special = std::decay_t&lt;decltype(*p)&gt;; // You can now use the local name "special" to access // the features of "awesome::special". special::do_something(); }); } }</span></span></code> </pre><br>  Para aqueles que seguem a série desde o início, você deve ter notado que o método <code>call_if_defined</code> não é exatamente o mesmo que a versão que escrevemos anteriormente.  A nova versão suporta vários parâmetros de tipo e chama o lambda apenas se todos os tipos estiverem definidos. <br><br>  Vamos dar uma olhada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TLambda&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_if_defined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TLambda&amp;&amp; lambda)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((... &amp;&amp; is_complete_type_v&lt;T&gt;))</span></span></span><span class="hljs-function"> </span></span>{ lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)...); } }</code> </pre><br>  Os parênteses duplos no if constexpr ((...)) parecem estranhos, mas são necessários.  Os parênteses externos são requeridos pela instrução <code>if constexpr</code> e os parênteses internos são requeridos pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expressão fold</a> .  A expressão da dobra se expande para <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( (is_complete_type_v&lt;T1&gt; &amp;&amp; is_complete_type_v&lt;T2&gt; &amp;&amp; ... is_complete_type_v&lt;Tn&gt;))</span></span></span></span></code> </pre><br>  A chamada do lambda usa uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expansão do pacote de parâmetros</a> : <br><br><pre> <code class="cpp hljs"> lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)...);</code> </pre><br>  Isso se expande para <br><br><pre> <code class="cpp hljs"> lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T1*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T2*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), ..., <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Tn*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>));</code> </pre><br>  onde o <code>static_cast&lt;T*&gt;(nullptr)</code> é repetido uma vez para cada tipo. <br><br>  Como observei anteriormente, podemos usar esta função para chamar um lambda se <i>todos</i> os tipos estiverem definidos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Source </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; source)</span></span></span><span class="hljs-function"> </span></span>{ call_if_defined&lt;special, magic&gt;( [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* p1, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* p2) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> special = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(*p1)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> magic = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(*p2)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = source.try_get&lt;special&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s) magic::add_magic(s); }); }</code> </pre><br>  O C ++ 20 permite que você escreva isso como <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Source </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; source)</span></span></span><span class="hljs-function"> </span></span>{ call_if_defined&lt;special, magic&gt;( [&amp;]&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> special, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> magic&gt; (special*, magic*) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = source.try_get&lt;special&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s) magic::add_magic(s); }); }</code> </pre><br>  que permite que você nomeie o tipo de modelo, poupando assim o trabalho de ter que derivá-lo novamente jogando <code>std::decay_t</code> games. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Da próxima vez</a> , usaremos isso como trampolim e estenderemos o padrão. <br><br><hr><br>  <b>Nota para aqueles que chegaram aqui por meio de um mecanismo de pesquisa</b> : esta é a última parte da parte principal da série, mas ainda há outras por vir.  Para os impacientes, aqui estão as coisas para copiar e colar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_type_complete_v = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_type_complete_v &lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">void_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T))&gt;&gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TLambda&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_if_defined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TLambda&amp;&amp; lambda)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((... &amp;&amp; is_complete_type_v&lt;T&gt;))</span></span></span><span class="hljs-function"> </span></span>{ lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)...); } }</code> </pre> <br><h2>  A propósito, temos uma vaga legal [Dublin] </h2><br>  A Havok está na vanguarda da inovação em desenvolvimento de jogos e 3D interativo há mais de uma década.  Como parte da Cognition, a equipe responsável pelo HoloLens, agora estamos combinando esse conhecimento com o poder da Nuvem do Azure para desenvolver muitos novos serviços interessantes que impulsionam experiências de Realidade Mista, como o recentemente anunciado serviço de Renderização Remota do Azure.  Somos apaixonados pela convergência das tecnologias de AR, VR e nuvem para permitir a criação de experiências inovadoras de realidade mista. <br><br>  <b>Trabalhando em Havok:</b> <br><br><ul><li>  Você trabalhará em pequenas equipes focadas com desenvolvedores talentosos </li><li>  Você terá a oportunidade de trabalhar com novas tecnologias em uma ampla gama de plataformas e dispositivos de hardware de ponta </li><li>  Você trabalhará na solução de problemas técnicos desafiadores com amplo escopo </li><li>  Você colaborará com equipes talentosas em todo o mundo </li></ul><br><h4>  Responsabilidades </h4><br><ul><li>  Projete, desenvolva, teste e forneça código C ++ multiplataforma eficiente, limpo e de alta qualidade </li><li>  Desenvolver serviços do Azure altamente escalonáveis </li><li>  Trabalhe diretamente com clientes internos e externos para impulsionar o desenvolvimento de produtos </li></ul><br><h4>  Qualificações </h4><br><ul><li>  Habilidades de codificação e depuração em C ++ </li><li>  Capacidade de trabalhar em um ambiente de equipe em uma base de código compartilhada </li><li>  Experiência com tecnologias de nuvem e serviços distribuídos (por exemplo, Lote do Azure, Armazenamento de Blob do Azure, Docker, Telemetria) </li></ul><br><h4>  Pontos de bônus </h4><br>  Existem muitas outras habilidades que não são necessárias, mas são valiosas para toda a equipe e incluem: <br><br><ul><li>  C #, ASP.Net, JavaScript, TypeScript, React </li><li>  Unity, motores de jogo irreais ou relacionados </li><li>  Experiência em 3D interativo, AR ou VR </li><li>  Serviços de rede e back-end </li><li>  Otimização de desempenho </li></ul><br>  Você pode obter mais informações e enviar seu currículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459834/">https://habr.com/ru/post/pt459834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459822/index.html">Um exemplo de uma rede neural simples, como resultado, descobre o que é o que</a></li>
<li><a href="../pt459824/index.html">Lista de verificação para escrever ótimas extensões do Visual Studio</a></li>
<li><a href="../pt459828/index.html">Notícias semanais: preço do bilhete Hyperloop na Rússia, mineração convencional de computadores Apollo, bot de IA no StarCraft II</a></li>
<li><a href="../pt459830/index.html">Claro, eles deram poder e uma linha de uma metralhadora. Câncer e mais ... experiência com medicina</a></li>
<li><a href="../pt459832/index.html">9 regras legais de extensão para o Visual Studio</a></li>
<li><a href="../pt459836/index.html">Anunciando o XAML Hot Reload para Xamarin.Forms</a></li>
<li><a href="../pt459838/index.html">Escreva um código melhor com mais rapidez com os analisadores Roslyn</a></li>
<li><a href="../pt459840/index.html">Lançamento de XAML Hot Reload para Xamarin.Forms</a></li>
<li><a href="../pt459842/index.html">Luxor</a></li>
<li><a href="../pt459844/index.html">Pinguim na janela: sobre o potencial e as perspectivas do WSL2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>