<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèæ üóæ ü•Ä C√≥mo funciona Chrome sin cabeza ü§òüèª üë©üèæ‚Äç‚öñÔ∏è üíí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya est√° claro por el nombre que un navegador sin cabeza es algo sin cabeza. En el contexto de una interfaz de usuario, es una herramienta indispensabl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona Chrome sin cabeza</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421137/">  Ya est√° claro por el nombre que un navegador sin cabeza es algo sin cabeza.  En el contexto de una interfaz de usuario, es una herramienta indispensable para un desarrollador, con la que puede probar el c√≥digo, verificar la calidad y el cumplimiento del dise√±o.  Vitaliy Slobodin en Frontend Conf decidi√≥ que era necesario conocer m√°s de cerca el dispositivo de esta herramienta. <br><br>  Bajo los componentes y caracter√≠sticas de corte de Headless Chrome, escenarios interesantes para usar Headless Chrome.  La segunda parte sobre Puppeteer es una conveniente biblioteca Node.js para administrar el modo Headless en Google Chrome y Chromium. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Vitaliy Slobodin, un antiguo desarrollador de PhantomJS, quien lo cerr√≥ y lo enterr√≥.  A veces ayuda a Konstantin Tokarev ( <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">annulen</a></u> ) en la versi√≥n "resucitada" de QtWebKit, el mismo QtWebKit, donde hay soporte para ES6, Flexbox y muchos otros est√°ndares modernos. <br><br>  A Vitaliy le encanta explorar navegadores, explorar WebKit, Chrome, etc. en su tiempo libre y m√°s.  Hoy hablaremos sobre los navegadores, es decir, sobre los navegadores sin cabeza y toda su familia de fantasmas. <a name="habracut"></a><br><br><h2>  <strong>¬øQu√© es un navegador sin cabeza?</strong> <br></h2><br>  Ya por el nombre est√° claro que esto es algo sin cabeza.  En un contexto de navegador, esto significa lo siguiente. <br><br><ol><li>  No <strong>tiene una representaci√≥n real del contenido</strong> , es decir, <strong>dibuja</strong> todo en la memoria. </li><li> Debido a esto, <strong>consume menos memoria</strong> , ya que no hay necesidad de dibujar im√°genes o PNG de gigabytes que las personas intentan poner en el backend usando una bomba. </li><li>  <strong>Funciona m√°s r√°pido</strong> porque no necesita renderizar nada en la pantalla real. </li><li>  Tiene una <strong>interfaz de programaci√≥n para la gesti√≥n</strong> .  Usted pregunta: ¬øno tiene una interfaz, botones, ventanas?  ¬øC√≥mo gestionarlo?  Por lo tanto, por supuesto, tiene una interfaz para la administraci√≥n. </li><li>  Una propiedad importante es la <strong>capacidad de instalar en un servidor Linux desnudo</strong> .  Esto es necesario para que si tiene un Ubuntu o Red Hat reci√©n instalado, simplemente puede soltar el binario o colocar el paquete all√≠, y el navegador funcionar√° de inmediato.  No se necesita chamanismo ni magia vud√∫. </li></ol><br>  Este es un navegador t√≠pico basado en WebKit.  No puede obtener una idea de los componentes, esto es solo una imagen visual. <br><br><img src="https://habrastorage.org/webt/un/7p/zj/un7pzjwjsn1a3psu2augn59jmj0.jpeg"><br><br>  Solo estamos interesados ‚Äã‚Äãen el componente superior de la interfaz de usuario del navegador.  Esta es la misma interfaz de usuario: ventanas, men√∫s, notificaciones emergentes y todo lo dem√°s. <br><br><img src="https://habrastorage.org/webt/14/ds/oa/14dsoabrnydhu5hb6iovu_gd2m8.jpeg"><br><br>  As√≠ es como se ve el navegador sin cabeza.  ¬øNota la diferencia?  Eliminamos completamente la interfaz de usuario.  El ya no existe.  <strong>Solo queda el navegador</strong> . <br><br>  Hoy hablaremos de Headless Chrome ().  ¬øCu√°l es la diferencia entre ellos?  De hecho, Chrome es una versi√≥n de marca de Chromium, que tiene c√≥decs patentados, el mismo H.264, integraci√≥n con los servicios de Google y todo lo dem√°s.  Chromium es solo una implementaci√≥n de c√≥digo abierto. <br><br><img src="https://habrastorage.org/webt/ti/14/-e/ti14-etgpuf8lm5euapnu1qk3rs.jpeg"><br><br>  Fecha de nacimiento de Chrome sin cabeza: 2016.  Si se encuentra con √©l, puede hacerme una pregunta dif√≠cil: "¬øC√≥mo es eso, recuerdo las noticias de 2017?"  El hecho es que un equipo de ingenieros de Google contact√≥ a los desarrolladores de PhantomJS en 2016, cuando reci√©n comenzaban a implementar el modo Headless en Chrome.  Escribimos Google Docks completo, c√≥mo implementaremos la interfaz, etc.  Entonces Google quer√≠a hacer una interfaz totalmente compatible con PhantomJS.  Fue solo entonces que el equipo de ingenieros tom√≥ la decisi√≥n de no hacer tal compatibilidad. <br><br>  Hablaremos sobre la interfaz de administraci√≥n (API), que es el protocolo Chrome DevTools, m√°s adelante y veremos qu√© puede hacer con √©l. <br><br>  Este art√≠culo se basar√° en el principio de la pir√°mide del titiritero (del titiritero ingl√©s).  Se elige un buen nombre: ¬°el titiritero es el que controla a todos los dem√°s! <br><br><img src="https://habrastorage.org/webt/4y/2i/lq/4y2ilqrqu3fxx8lrinrjp90zgfq.jpeg"><br><br>  En la base de la pir√°mide se encuentra Chrome sin cabeza - Chrome sin cabeza, ¬øqu√© es? <br><br><h2>  <strong>Cromo sin cabeza</strong> <br></h2><br><img src="https://habrastorage.org/webt/tx/id/ql/txidqlimkcdam_vcyah-fu4vlk0.jpeg"><br><br>  En el centro, navegador sin cabeza, el mismo cromo o cromo (generalmente cromo).  Tiene los llamados renderizadores (RENDERER): procesos que dibujan el contenido de la p√°gina (su ventana).  Adem√°s, cada pesta√±a necesita su propio procesador, por lo que si abre muchas pesta√±as, Chrome iniciar√° tantos procesos para la representaci√≥n. <br><br>  Adem√°s de todo esto es su aplicaci√≥n.  Si tomamos Chromium o Chrome sin cabeza, entonces Chrome estar√° encima, o alguna aplicaci√≥n en la que puedas incrustarlo.  El an√°logo m√°s cercano se puede llamar Steam.  Todo el mundo sabe que, en esencia, Steam es solo un navegador del sitio web de Steam.  √âl, por supuesto, no es decapitado, sino similar a este esquema. <br><br>  Hay 2 formas de incrustar Chrome sin cabeza en su aplicaci√≥n (o usarla): <br><br><ol><li>  Est√°ndar cuando tomas <strong>Puppeteer</strong> y usas Headless Chrome. <br></li><li>  Cuando toma el componente de <strong>biblioteca sin cabeza</strong> , es decir, una biblioteca que implementa el modo sin cabeza y lo integra en su aplicaci√≥n, por ejemplo, en C ++. <br></li></ol><br>  Usted puede preguntar, ¬øpor qu√© C ++ est√° en la parte frontal?  La respuesta es la API DevTools C ++.  Puede implementar y usar las funciones de Chrome sin cabeza de diferentes maneras.  Si utiliza Puppeteer, la comunicaci√≥n con un navegador sin cabeza se realizar√° a trav√©s de sockets web.  Si incrusta la biblioteca Headless en una aplicaci√≥n de escritorio, utilizar√° la interfaz nativa, que est√° escrita en C ++. <br><br>  Pero adem√°s de todo esto, todav√≠a tiene cosas adicionales, que incluyen: <br><br><ul><li>  <strong>Redes</strong> personalizadas: implementaci√≥n personalizada de interacci√≥n con la red.  Supongamos que trabaja en un banco o en una agencia gubernamental, que consta de tres letras y comienza con "F", y utiliza un protocolo de autenticaci√≥n o autorizaci√≥n muy complicado que no es compatible con los navegadores.  Por lo tanto, es posible que necesite un controlador personalizado para su red.  Simplemente puede tomar su biblioteca ya implementada y usarla en Chrome. </li><li>  <strong>M√≥dulos Mojo</strong> .  El an√°logo m√°s cercano de Mojo son las carpetas nativas en Node.js a sus bibliotecas nativas escritas en C ++.  Mojo hace lo mismo: toma su biblioteca nativa, escribe una interfaz Mojo para ella y luego puede llamar a los m√©todos de su biblioteca nativa en su navegador. </li></ul><br><h3>  Componentes de cromo <br></h3><br><img src="https://habrastorage.org/webt/zh/-x/jf/zh-xjfbpq4mjz2ntcwr_tjriuhe.jpeg"><br><br>  Nuevamente escucho una pregunta dif√≠cil: ‚Äú¬øPor qu√© necesito este terrible esquema?  Escribo debajo (inserte el nombre de su marco favorito) ". <br><br><blockquote>  Creo que un desarrollador debe saber c√≥mo funciona su herramienta.  Si escribe debajo de React, debe saber c√≥mo funciona React.  Si escribe debajo de Angular, debe saber qu√© tiene Angular debajo del cap√≥. <br></blockquote><br>  Porque en el caso de algo, por ejemplo, un error fatal o un error muy grave en la producci√≥n, tienes que lidiar con las "agallas", y simplemente puedes perderte all√≠: d√≥nde, qu√© y c√≥mo.  Si, por ejemplo, escribe pruebas o usa Headless Chrome, tambi√©n puede encontrar algunos de sus comportamientos extra√±os y errores.  Por lo tanto, te dir√© brevemente qu√© cromo tiene componentes.  Cuando vea un seguimiento de pila grande, ya sabr√° qu√© forma de excavar y c√≥mo solucionarlo. <br><br>  El nivel m√°s bajo de la <strong>capa de Plataforma</strong> .  Sus componentes: <br><br><ul><li>  <strong>Ozone</strong> , el administrador de ventanas abstracto en Chrome, es con lo que interact√∫a el administrador de ventanas del sistema operativo.  En Linux, es un servidor X o Wayland.  En Windows, es un administrador de ventanas de Windows. </li><li>  <strong>Scheduler</strong> es el mismo planificador sin el cual no estamos en ninguna parte, porque todos sabemos que Chrome es una aplicaci√≥n multiproceso, y necesitamos resolver de alguna manera todos los hilos, procesos y todo lo dem√°s. </li><li>  <strong>Net</strong> : el navegador siempre debe tener un componente para trabajar con la red, por ejemplo, analizar HTTP, crear encabezados, editar, etc. </li></ul><br>  La <strong>capa de contenido</strong> es el componente m√°s grande que tiene Chrome.  Incluye: <br><br><ul><li>  <strong>Blink</strong> es un motor web basado en WebCore de WebKit.  Puede tomar HTML como una cadena, analizar, ejecutar JavaScript, y eso es todo.  Ya no sabe c√≥mo hacer nada: ni trabajar con la red ni dibujar: todo esto sucede adem√°s de Blink. <br>  Blink incluye: una versi√≥n altamente modificada de WebCore, un motor web para trabajar con HTML y CSS;  V8 (motor de JavaScript);  as√≠ como una API para todas las extensiones que utilizamos en Chrome, como un bloqueador de anuncios.  Tambi√©n incluye el protocolo DevTools. <br></li><li>  <strong>Content API</strong> es una interfaz con la que puede usar f√°cilmente todas las funciones del motor web.  Dado que hay tantas cosas dentro de Blink (probablemente m√°s de un mill√≥n de interfaces), para no perderse en todos estos m√©todos y funciones, necesita una API de contenido.  Ingresa HTML, el motor lo procesar√° autom√°ticamente, analizar√° el DOM, crear√° CSS OM, ejecutar√° JavaScript, ejecutar√° temporizadores, controladores y todo lo dem√°s. <br></li></ul><br>  Nivel de <strong>capa sin</strong> cabeza - nivel de navegador sin cabeza: <br><br><ul><li>  <strong>Biblioteca sin cabeza</strong> . </li><li>  <strong>Interfaz API</strong> de incrustaci√≥n para incrustar la biblioteca sin cabeza en la aplicaci√≥n. </li><li>  <strong>Client API</strong> es una interfaz que utiliza Puppeteer. </li></ul><br>  <strong>Capa de aplicaci√≥n Capa de aplicaci√≥n</strong> : <br><br><ul><li>  Su aplicaci√≥n (aplicaci√≥n de <strong>incrustaci√≥n</strong> ); </li><li>  Gadgets, por ejemplo, <strong>Shell sin cabeza</strong> . </li></ul><br>  Ahora, lev√°ntese un poco m√°s de las profundidades, act√≠velo, ahora la interfaz se ir√°. <br><br><img src="https://habrastorage.org/webt/_p/p6/10/_pp610df2doffm9nfysj-62ioea.jpeg"><br><br><h3>  Protocolo de Chrome DevTools <br></h3><br>  Todos nos encontramos con el protocolo Chrome DevTools, porque utilizamos el panel de desarrollador en Chrome o el depurador remoto, las mismas herramientas de desarrollo.  Si ejecuta las herramientas de desarrollador de forma remota, la comunicaci√≥n con el navegador se realiza utilizando el protocolo DevTools.  Cuando instale el depurador, vea la cobertura del c√≥digo, use la geolocalizaci√≥n u otra cosa; todo esto se controla mediante DevTools. <br><br><img src="https://habrastorage.org/webt/qe/wy/2b/qewy2b3vwphvwanus0zqqnnxeq4.jpeg"><br><br>  De hecho, el protocolo DevTools tiene una gran cantidad de m√©todos.  Su herramienta de desarrollador no tiene acceso, probablemente al 80% de ellos.  Realmente, ¬°puedes hacer todo all√≠! <br><br>  Veamos de qu√© se trata este protocolo.  De hecho, es muy simple.  Tiene 2 componentes: <br><br><ol><li>  Objetivo DevTools: la pesta√±a que est√° inspeccionando; <br></li><li>  Cliente DevTools: digamos que este es un panel de desarrollador que se inicia de forma remota. <br></li></ol><br><img src="https://habrastorage.org/webt/-a/t8/ch/-at8chx2k1wsarzbzqhxtftflay.jpeg"><br><br>  Se comunican usando JSON simple: <br><br><ul><li>  Hay un identificador para el comando, el nombre del m√©todo a ejecutar y algunos par√°metros. </li><li>  Enviamos una solicitud y obtenemos una respuesta que tambi√©n parece muy simple: un identificador que se necesita porque todos los comandos que se ejecutan utilizando el protocolo son as√≠ncronos.  Para que podamos comparar siempre qu√© respuesta con qu√© equipo recibimos, necesitamos un identificador. </li><li>  Hay un resultado  En nuestro caso, es un objeto de resultado con los siguientes atributos: <strong>tipo:</strong> <strong>"n√∫mero",</strong> <strong>valor:</strong> <strong>2,</strong> <strong>descripci√≥n:</strong> <strong>"2"</strong> , no se produjo ninguna excepci√≥n: <strong>wasThrown:</strong> <strong>false.</strong> <br></li></ul><br>  Pero entre otras cosas, su pesta√±a puede enviarle eventos.  Suponga que cuando ocurre un evento en una p√°gina, o si hay una excepci√≥n en una p√°gina, recibir√° una notificaci√≥n a trav√©s de este protocolo. <br><br><img src="https://habrastorage.org/webt/-f/nc/8g/-fnc8gvu6h9dy5p5ovh3wf0v6ua.jpeg"><br><br><img src="https://habrastorage.org/webt/h0/tx/ud/h0txudupxhjb8brbckihbe7wzum.jpeg"><br><br><h2>  <strong>Titiritero</strong> <br></h2><br>  Puede instalar Puppeteer usando su administrador de paquetes favorito, ya sea hilo, npm o cualquier otro. <br><br>  Usarlo tambi√©n es f√°cil: solo solic√≠telo en su script Node.js, y ya puede usarlo. <br><br><img src="https://habrastorage.org/webt/pi/ia/or/piiaoriro3hvbrm_yhvd1h-scq4.jpeg"><br><br>  Usando el enlace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://try-puppeteer.appspot.com,</a> puede escribir un script directamente en el sitio, ejecutarlo y obtener el resultado directamente en el navegador.  Todo esto se implementar√° utilizando Headless Chrome. <br><br>  Considere el script m√°s simple en Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch() ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'http://devconf.ru/'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.emulateMedia(<span class="hljs-string"><span class="hljs-string">'screen'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.pdf({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'./devconf.pdf, printBackground: true }); await browser.close() ; })();</span></span></code> </pre> <br>  Aqu√≠ simplemente abrimos la p√°gina e imprimimos en PDF.  Veamos el funcionamiento de este script en tiempo real: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Todo estar√° bien, pero no est√° claro qu√© hay dentro.  Por supuesto, tenemos un navegador sin cabeza, pero no vemos nada.  Por lo tanto, Titiritero tiene una bandera especial llamada sin cabeza: falso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({ <span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre><br>  Es necesario para iniciar el navegador sin cabeza en modo headful, cuando puede ver alguna ventana y ver qu√© sucede con su p√°gina en tiempo real, es decir, c√≥mo interact√∫a su script con su p√°gina. <br><br><img src="https://habrastorage.org/webt/qz/oo/ie/qzooiejebek5gqaww2gw9tv0sgc.jpeg"><br><br>  Esto se ver√° el mismo script cuando agreguemos esta bandera.  Aparece una ventana del navegador a la izquierda, m√°s claramente. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Ventajas del titiritero:</strong> <br><br>  + Esta es la biblioteca Node.js para Chrome sin cabeza. <br>  + Soporte para versiones heredadas de Node.js&gt; = 6. <br>  + F√°cil instalaci√≥n. <br>  + API de alto nivel para administrar toda esta m√°quina gigante. <br><br>  Chrome sin cabeza se instala f√°cilmente y sin intervenci√≥n del sistema.  En la primera instalaci√≥n, Puppeteer descarga la versi√≥n de Chromium y la instala directamente en la carpeta node_modules espec√≠ficamente para su arquitectura y sistema operativo.  No necesita descargar nada extra, lo hace autom√°ticamente.  Tambi√©n puede usar su versi√≥n favorita de Chrome, que est√° instalada en su sistema.  Usted tambi√©n puede hacer esto: Puppeteer le proporciona dicha API. <br><br>  Desafortunadamente, tambi√©n hay desventajas, si tomamos solo la instalaci√≥n b√°sica. <br><br>  <strong>Contra titiriteros</strong> : <br><br>  - <strong>Sin funciones de nivel superior</strong> : sincronizaci√≥n de marcadores y contrase√±as;  soporte de perfil;  aceleraci√≥n de hardware, etc. <br>  - <strong>La representaci√≥n del software</strong> es el menos m√°s significativo.  Todos los c√°lculos y la representaci√≥n tienen lugar en su CPU.  Pero aqu√≠, los ingenieros de Google pronto nos sorprender√°n: ya se est√° trabajando en la implementaci√≥n de la aceleraci√≥n de hardware.  Ya puedes intentar usarlo si eres valiente y valiente. <br>  - Hasta hace poco, no hab√≠a soporte para extensiones, ¬°ahora s√≠ lo hay!  Si es un desarrollador astuto, puede tomar su AdBlock favorito, especificar c√≥mo lo usar√° Puppeteer y se bloquear√°n todos los anuncios. <br>  - <strong>No hay soporte de audio / video</strong> .  Porque, bueno, por qu√© el audio y el video del navegador sin cabeza. <br><br>  <strong>¬øQu√© puede titiritero:</strong> <br><br><ul><li>  Sesiones de aislamiento. </li><li>  Temporizadores virtuales. </li><li>  Intercepci√≥n de solicitudes de red. </li></ul><br>  Y un par de cosas geniales que mostrar√© un poco m√°s. <br><br><h4>  Aislamiento de sesi√≥n <br></h4><br>  ¬øQu√© es, con qu√© se come y no nos asfixiamos?  - ¬°No te ahogues! <br><br>  El aislamiento de la sesi√≥n es un <strong>"repositorio" separado para cada pesta√±a</strong> .  Cuando inicia Puppeteer, puede crear una nueva p√°gina, y cada nueva p√°gina puede tener su propio repositorio, que incluye: <br><br><ul><li>  cocineros <br></li><li>  almacenamiento local; <br></li><li>  cach√© <br></li></ul><br>  Todas las p√°ginas vivir√°n independientemente unas de otras.  Esto es necesario, por ejemplo, para mantener la atomicidad de las pruebas. <br><br>  El aislamiento de la sesi√≥n <strong>ahorra recursos y tiempo al iniciar sesiones paralelas</strong> .  Suponga que est√° probando un sitio que se est√° creando en modo de desarrollo, es decir, el paquete no est√° minimizado y pesa 20 MB.  Si solo desea almacenarlo en cach√©, puede decirle a Puppeteer que use un cach√© com√∫n a todas las p√°ginas que se crean, y este paquete se almacenar√° en cach√©. <br><br>  Puede <strong>serializar sesiones para su uso posterior</strong> .  Escribe una prueba que verifica una determinada acci√≥n en su sitio.  Pero tiene un problema: el sitio requiere autorizaci√≥n.  No agregar√° constantemente antes en cada prueba para obtener autorizaci√≥n en el sitio.  Puppeteer le permite iniciar sesi√≥n en el sitio una vez y luego reutilizar esta sesi√≥n en el futuro. <br><br><h4>  Temporizadores virtuales <br></h4><br>  Es posible que ya est√© utilizando temporizadores virtuales.  Si movi√≥ el control deslizante en una herramienta de desarrollador que acelera o ralentiza la animaci√≥n (¬°y se lav√≥ las manos despu√©s de eso, por supuesto!), Entonces en ese momento us√≥ temporizadores virtuales en el navegador. <br><br>  El navegador puede usar temporizadores virtuales en lugar de reales para <strong>"desplazarse" hacia adelante</strong> para acelerar la carga de la p√°gina o completar la animaci√≥n.  Supongamos que tienes la misma prueba, vas a la p√°gina principal y all√≠ la animaci√≥n durante 30 segundos.  No es beneficioso para nadie que la prueba espere todo este tiempo.  Por lo tanto, simplemente puede acelerar la animaci√≥n para que se complete instant√°neamente cuando se cargue la p√°gina y su prueba contin√∫e. <br><br>  Puede <strong>detener el tiempo mientras se ejecuta la solicitud de red</strong> .  Por ejemplo, prueba la reacci√≥n de su aplicaci√≥n cuando una solicitud que se ha enviado al backend tarda mucho tiempo en ejecutarse o regresa con un error.  Puedes detener el tiempo: Titiritero lo permite. <br><br>  En la siguiente diapositiva, hay otra opci√≥n: <strong>detener y continuar con el</strong> renderizador.  En el modo experimental, fue posible decirle al navegador que no se procesara y luego, si es necesario, solicitar una captura de pantalla.  Luego, Chrome sin cabeza renderizar√≠a r√°pidamente todo, har√≠a una captura de pantalla y nuevamente dejar√≠a de dibujar cualquier cosa.  Desafortunadamente, los desarrolladores ya han logrado cambiar el principio de funcionamiento de esta API y ya no existe tal funci√≥n. <br><br>  Una vista esquem√°tica de los temporizadores virtuales a continuaci√≥n. <br><br><img src="https://habrastorage.org/webt/dy/zm/bu/dyzmbucfttmfjlbsdkpmlk6bypq.jpeg"><br><br>  La l√≠nea superior tiene dos temporizadores regulares: el primero comienza en la primera unidad de tiempo y se ejecuta en una unidad de tiempo, el segundo comienza en la tercera unidad de tiempo y se ejecuta en tres unidades de tiempo. <br><br>  Acelerando los temporizadores: comienzan uno tras otro.  Cuando los detenemos, tenemos un per√≠odo de tiempo despu√©s del cual comienzan todos los temporizadores. <br><br>  Considera esto como un ejemplo.  A continuaci√≥n se muestra un fragmento de c√≥digo que esencialmente carga la p√°gina de animaci√≥n de codepen.io y espera: <br><br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https ://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page.goto(url, { waitUnitl: 'load' }); // # 2 })();</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esta</a> demostraci√≥n de implementaci√≥n durante la presentaci√≥n es solo animaci√≥n. <br><br>  Ahora, usando el protocolo Chrome DevTools, enviaremos un m√©todo llamado Animation.setPlaybackRate, pasaremos una tasa de reproducci√≥n con un valor de 12 como par√°metros: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page._client.send('Animation.setPlaybackRate', { playbackRate: 12 }); // # 3 await page.goto(url, { waitUntil: 'load' }); // # 2</span></span></code> </pre><br>  Cargamos el mismo enlace, y el animashka comenz√≥ a funcionar mucho m√°s r√°pido.  Esto se debe al hecho de que usamos un temporizador virtual y aceleramos la reproducci√≥n de la animaci√≥n 12 veces. <br><br>  Hagamos un experimento ahora, pase el √≠ndice de reproducci√≥n: 0, y vea qu√© sucede.  Y aqu√≠ estar√° esto: no hay animaci√≥n en absoluto, no se reproduce.  Los valores cero y negativos simplemente detienen la animaci√≥n completa por completo. <br><br><h4>  Trabajar con solicitudes de red. <br></h4><br>  Puede <strong>interceptar solicitudes de red</strong> configurando el siguiente indicador: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.setRequestlnterception(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  En este modo, aparece un evento adicional que se activa cuando se env√≠a o recibe una solicitud de red. <br><br>  Puede <strong>cambiar la solicitud sobre la marcha</strong> .  Esto significa que puede cambiar completamente todos sus contenidos (cuerpo) y sus encabezados, inspeccionar, incluso cancelar la solicitud. <br><br>  Esto es necesario para <strong>procesar la autorizaci√≥n o autenticaci√≥n</strong> , incluida la autenticaci√≥n b√°sica a trav√©s de HTTP. <br><br>  Tambi√©n puede hacer <strong>cobertura de c√≥digo (JS / CSS)</strong> .  Con Puppeteer, puede automatizar todo esto.  Todos conocemos utilidades que pueden cargar una p√°gina, mostrar qu√© clases se usan en ella, etc.  ¬øPero estamos satisfechos con ellos?  Creo que no <br><br><blockquote>  El navegador sabe mejor qu√© selectores y clases se utilizan: ¬°es un navegador!  √âl siempre sabe qu√© JavaScript se ejecut√≥, qu√© no, qu√© CSS se usa, cu√°l no. <br></blockquote><br>  El protocolo Chrome DevTools viene al rescate: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all ( [ page.coverage.startJSCoverage(), page.coverage.startCSSCoverage() ]); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [jsCoverage, cssCoverage] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>,all([ page.coverage.stopJSCoverage(), page.coverage.stopCSSCoverage() ]):</code> </pre><br>  En las dos primeras l√≠neas, lanzamos una caracter√≠stica relativamente nueva que le permite conocer la cobertura del c√≥digo.  Ejecute JS y CSS, vaya a alguna p√°gina, luego diga, det√©ngase, y podremos ver los resultados.  Y estos no son algunos resultados imaginarios, sino aquellos que el navegador ve debido al motor. <br><br>  Entre otras cosas, ya hay un complemento que para Puppeteer lo exporta todo a Estambul. <br><br>  En la parte superior de la pir√°mide del Titiritero hay un gui√≥n que escribiste en Node.js, es como el padrino en todos los puntos inferiores. <br><br><img src="https://habrastorage.org/webt/gx/j6/xl/gxj6xlxcpfwiuekgcszpnijrzf8.jpeg"><br><br>  Pero ... "no todo est√° tranquilo en el reino dan√©s ...", como escribi√≥ William Shakespeare. <br><br><h2>  <strong>¬øQu√© hay de malo con los navegadores sin cabeza?</strong> <br></h2><br>  Los navegadores sin cabeza tienen problemas a pesar de que todas sus caracter√≠sticas interesantes pueden hacer mucho. <br><br><h4>  Diferencia en el renderizado de p√°ginas en diferentes plataformas. <br></h4><br>  Realmente amo este art√≠culo y constantemente hablo sobre ello.  Miremos esta foto. <br><br><img src="https://habrastorage.org/webt/62/r2/rj/62r2rjsc0ggbgpedb5lhp_tceki.jpeg"><br><br>  Aqu√≠ hay una p√°gina normal con texto plano: a la derecha, renderizado en Chrome en Linux, a la izquierda, en Windows.  Aquellos que prueban con capturas de pantalla saben que siempre se establece un valor, llamado "margen de error", que determina cu√°ndo la captura de pantalla se considera id√©ntica y cu√°ndo no. <br><br>  De hecho, el problema es que no importa c√≥mo intente establecer este umbral, el error siempre ir√° m√°s all√° de esta l√≠nea y a√∫n recibir√° resultados falsos positivos.  Esto se debe al hecho de que todas las p√°ginas, e incluso las fuentes web, se representan de manera diferente en las tres plataformas: en Windows de acuerdo con un algoritmo, en MacOS de manera diferente, en Linux en general en un zool√≥gico.  <strong>No puede simplemente tomar y probar con capturas de pantalla</strong> . <br><br>  Dir√°: "Solo necesito una m√°quina de referencia donde ejecutar√© todas estas pruebas y comparar√© capturas de pantalla".  Pero, de hecho, esto es muy inconveniente, ya que debe esperar a CI y desea verificar aqu√≠ localmente en su m√°quina si ha roto algo.  Si tiene capturas de pantalla de referencia en una m√°quina Linux y tiene una Mac, entonces habr√° resultados falsos. <br><br><blockquote>  Por lo tanto, digo que no pruebes con capturas de pantalla, olv√≠dalo. <br></blockquote><br>  Por cierto, si todav√≠a quieres probar con capturas de pantalla, hay un maravilloso art√≠culo de Roman Dvornov, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pruebas unitarias con capturas de pantalla: romper la barrera del sonido</a> ".  Esto es pura ficci√≥n de detectives. <br><br><h4>  Cerraduras <br></h4><br>  A muchos proveedores de contenido grande no les gusta cuando raspa o obtiene su contenido de manera ilegal.  Imagina que soy un importante proveedor de contenido y quiero jugar el mismo juego contigo.  Hay dos solicitudes GET en dos navegadores diferentes. <br><img src="https://habrastorage.org/webt/ku/ys/5e/kuys5eq81wzsqfci9kpddrd-ahm.jpeg"><br><br>  ¬øPuedes adivinar d√≥nde est√° Chrome aqu√≠?  La opci√≥n "ambos" no se acepta: Chrome es solo una.  Lo m√°s probable es que no pueda responder esta pregunta, y yo, como proveedor de contenido principal, puedo: a la derecha - PhantomJS, y a la izquierda - Chrome. <br><img src="https://habrastorage.org/webt/l8/vc/lt/l8vcltt3bh-ccdysbg3azvqjxxe.jpeg"><br><br>  Puedo llegar al punto en el que detectar√© sus navegadores (qu√© es exactamente Chrome o Firefox) haciendo coincidir el orden de los encabezados HTTP en sus solicitudes.  Si el host va primero, lo s√© claramente, este es Chrome.  Entonces no puedo comparar.  S√≠, por supuesto, hay algoritmos m√°s complejos: verificamos no solo el orden, sino tambi√©n los valores, etc.  etc.  Pero es importante que pueda emitir sus t√≠tulos, verificar qui√©n es usted y luego simplemente bloquearlo o no bloquearlo. <br><br><h4>  No se pueden implementar algunas funciones (Flash) <br></h4><br>  ¬øAlguna vez has estudiado en profundidad, directamente hardcore, Flash en los navegadores?  De alguna manera mir√©, luego no dorm√≠ durante seis meses. <br><br>  Todos recordamos c√≥mo sol√≠amos ver YouTube cuando todav√≠a hab√≠a Flash: el video gira, todo est√° bien.  Pero en el momento en que se crea un objeto incrustado en una p√°gina como Flash, siempre solicita una ventana real de su sistema operativo.  Es decir, adem√°s de la ventana de su navegador, hab√≠a otra ventana de su sistema operativo dentro de la ventana Flash de YouTube.  Flash no puede funcionar a menos que le d√© una ventana real, no solo una ventana real, sino una ventana visible en su pantalla.  Por lo tanto, algunas funciones no se pueden implementar en navegadores sin cabeza, incluido Flash. <br><br><h4>  Automatizaci√≥n completa y bots <br></h4><br>  Como dije antes, los grandes proveedores de contenido tienen mucho miedo cuando escribes ara√±as o acaparamientos que simplemente roban informaci√≥n que se proporciona por una tarifa. <br><br>  Se utilizan varios trucos.  Hay art√≠culos sobre c√≥mo detectar navegadores sin cabeza.  Puedo decir que <strong>no podr√° detectar navegadores sin cabeza</strong> .  Todos los m√©todos descritos all√≠ est√°n anulados.  Por ejemplo, hubo m√©todos de detecci√≥n usando Canvas.  Recuerdo que incluso hubo una secuencia de comandos que vio al rat√≥n moverse por la pantalla y llen√≥ el lienzo.  Somos personas y movemos el mouse lentamente, y Headless Chrome es mucho m√°s r√°pido.  El script entendi√≥ que Canvas se llena demasiado r√°pido, lo que significa que es muy probable que Chrome no tenga cabeza.  Tambi√©n evitamos esto, solo ralentizar el navegador no es un problema. <br><br><h4>  No hay una API est√°ndar (√∫nica) <br></h4><br>  Si observ√≥ implementaciones sin cabeza en otros navegadores, ya sea Safari o Firefox, all√≠ se implementa todo utilizando la API webdriver.  Chrome tiene el protocolo Chrome DevTools.  En Edge, nada est√° claro en absoluto: qu√© hay all√≠, qu√© no. <br><br><h4>  WebGL? <br></h4><br>  La gente tambi√©n pide WebGL en modo sin cabeza.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace le permite</a> acceder al rastreador de errores de Google Chrome.  All√≠, los desarrolladores votan activamente por la implementaci√≥n del modo sin cabeza para WebGL, y ya puede dibujar algo.  Ahora est√°n simplemente restringidos por el renderizado de hardware.  Tan pronto como se complete la implementaci√≥n del renderizado de hardware, WebGL estar√° autom√°ticamente disponible, es decir, se puede hacer algo en segundo plano. <br><br>  ¬°Pero no todo es tan malo! <br><br>  Tenemos un segundo jugador en el mercado: el 11 de mayo de 2018 hubo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">noticias de</a> que Microsoft en su navegador Edge decidi√≥ implementar casi el mismo protocolo que se utiliza en Google Chrome.  Crearon especialmente un consorcio donde est√°n discutiendo un protocolo que quieren llevar a un est√°ndar de la industria para que pueda tomar su script y ejecutarlo en Edge, Chrome y FireFox. <br><br>  Pero hay un "pero": desafortunadamente, Microsoft Edge no tiene un modo sin cabeza.  Tienen una boleta de votaci√≥n donde la gente escribe: "¬°Danos un modo sin cabeza!"  - Pero est√°n en silencio.  Probablemente aserrando algo en secreto. <br><br><h2>  <strong>TODO (conclusi√≥n)</strong> <br></h2><br>  Le dije todo esto para que pueda acudir a su gerente o, si es gerente, al desarrollador y decirle: ‚Äú¬°Eso es!  <strong>Ya no queremos Selenium, ¬°danos Titiritero!</strong>  Lo probaremos en √©l ".  Si esto sucede, me alegrar√©. <br><br>  Pero si puede aprender, como yo, los navegadores que utilizan Puppeteer, publicar errores activamente o enviar una solicitud de extracci√≥n, me alegrar√© a√∫n m√°s.  Esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta</a> en OpenSource se encuentra en GitHub, est√° escrita en Node.js, puede pedirla prestada y contribuir a ella. <br><br>  El caso de Puppeteer es √∫nico en el sentido de que hay dos equipos trabajando en Google: uno trata espec√≠ficamente con Puppeteer y el otro con el modo sin cabeza.  Si un usuario encuentra un error y escribe sobre √©l en GitHub, entonces si este error no est√° en Puppeteer, sino en Headless Chrome, el error va al comando Headless Chrome.  Si lo arreglan all√≠, Puppeteer se actualiza muy r√°pidamente.  Esto da como resultado un √∫nico ecosistema cuando la comunidad ayuda a mejorar el navegador. <br><br>  Por lo tanto, le insto a que ayude a mejorar la herramienta, que no solo utiliza usted, sino tambi√©n otros desarrolladores y evaluadores. <br><br>  Datos de contacto: <br><br><ul><li>  github.com/vitallium </li><li>  vk.com/vitallium </li><li>  twitter.com/vitalliumm </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frontend Conf Moscow</a> : una conferencia especializada de desarrolladores front-end se llevar√° a cabo los <strong>d√≠as 4 y 5 de octubre en Mosc√∫</strong> , en Infospace.  Ya se ha publicado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una lista de</a> informes aceptados en el sitio web de la conferencia. <br><br>  En nuestro bolet√≠n hacemos revisiones tem√°ticas de discursos, hablamos de las transcripciones que se han publicado y de los eventos futuros. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reg√≠strese</a> para recibir las noticias primero. <br><br>  Y este es un enlace a nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de Youtube</a> en la parte frontal, contiene todos los discursos relacionados con el desarrollo de la parte cliente de los proyectos. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421137/">https://habr.com/ru/post/es421137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421127/index.html">Seminarios web de Skillbox Friday: dise√±o y desarrolladores</a></li>
<li><a href="../es421129/index.html">C√≥mo reducir la revisi√≥n de c√≥digo de dos semanas a varias horas. La experiencia del equipo Yandex.Market</a></li>
<li><a href="../es421131/index.html">Vulnerabilidad cr√≠tica de los servidores 1Cloud</a></li>
<li><a href="../es421133/index.html">LINKa. Teclado de papel Botones extra grandes</a></li>
<li><a href="../es421135/index.html">Au / Ni / MgO: transferencia de calor a nanoescala</a></li>
<li><a href="../es421139/index.html">Frontend Conf - cuidando al usuario</a></li>
<li><a href="../es421141/index.html">An√°lisis de mutaciones o c√≥mo evaluar las pruebas.</a></li>
<li><a href="../es421143/index.html">Aurora Labs S-Titanium Pro Mini impresora 3D de metal</a></li>
<li><a href="../es421147/index.html">Monstruos despu√©s de las vacaciones: AMD Threadripper 2990WX 32-Core y 2950X 16-Core</a></li>
<li><a href="../es421149/index.html">Algunas palabras sobre gradientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>