<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 🙎🏿 🕹️ Pola Arsitektur Iterator di Swift Universe 🐧 🌹 👨🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Iterator" adalah salah satu pola desain yang paling sering tidak diperhatikan oleh programer, karena implementasinya, sebagai suatu peraturan, dibang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pola Arsitektur Iterator di Swift Universe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437614/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Iterator"</a> adalah salah satu pola desain yang paling sering tidak diperhatikan oleh programer, karena implementasinya, sebagai suatu peraturan, dibangun langsung ke dalam alat standar bahasa pemrograman.  Namun, ini juga merupakan salah satu pola perilaku yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku "Geng Empat", "GoF", "Pola Desain: Elemen Perangkat Lunak Berorientasi Objek Reusable"</a> , dan memahami perangkatnya tidak pernah sakit, dan kadang-kadang bahkan dapat membantu dalam sesuatu. <br><a name="habracut"></a><br>  <i>"Iterator" adalah metode akses sekuensial ke semua elemen objek komposit (khususnya, tipe wadah, seperti array atau set).</i> <br><br><h3>  Alat bahasa standar </h3><br>  Buat beberapa jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> : <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbersArray = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br>  ... dan kemudian "berjalan" melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">siklus</a> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbersArray { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(number) }</code> </pre><br>  ... sepertinya tindakan yang sangat alami, terutama untuk bahasa pemrograman modern seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swift</a> .  Namun, di balik layar tindakan sederhana ini adalah kode yang menerapkan prinsip-prinsip pola Iterator. <br><br>  Dalam "Swift", untuk dapat "beralih" variabel menggunakan <code>for</code> sepeda, tipe variabel harus menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Sequence</code></a> .  Antara lain, protokol ini mensyaratkan tipe untuk memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Iterator</code></a> tipe <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">associatedtype</a></code> , yang pada gilirannya harus menerapkan persyaratan protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>IteratorProtocol</code></a> Protokol, serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode pabrik</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>makeIterator()</code></a> , yang mengembalikan "iterator" spesifik untuk tipe ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Iterator</span></span> : <span class="hljs-type"><span class="hljs-type">IteratorProtocol</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> <span class="hljs-comment"><span class="hljs-comment">// Another requirements go here… }</span></span></code> </pre><br>  Protokol <code>IteratorProtocol</code> , pada gilirannya, hanya berisi satu metode - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>next()</code></a> , yang mengembalikan elemen berikutnya dalam urutan: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Element</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span>.<span class="hljs-type"><span class="hljs-type">Element?</span></span> }</code> </pre><br>  Kedengarannya seperti "banyak kode rumit," tetapi sebenarnya tidak.  Di bawah ini kita akan melihat ini. <br><br>  Tipe <code>Array</code> mengimplementasikan protokol <code>Sequence</code> (meskipun tidak secara langsung, tetapi melalui rantai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inheritance protokol</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MutableCollection</code></a> mewarisi persyaratan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Collection</code></a> , dan yang terakhir mewarisi persyaratan <code>Sequence</code> ), jadi instance-nya, khususnya, dapat "diiterasi" menggunakan -sepeda. <br><br><h3>  Jenis khusus </h3><br>  Apa yang perlu dilakukan untuk bisa mengulang tipe Anda sendiri?  Seperti yang sering terjadi, paling mudah untuk menunjukkan contoh. <br><br>  Misalkan ada tipe yang mewakili rak buku yang menyimpan sekumpulan instance kelas tertentu, yang pada gilirannya mewakili sebuah buku: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> author: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shelf</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>] }</code> </pre><br>  Untuk dapat "mengulang" instance kelas <code>Shelf</code> , kelas ini harus memenuhi persyaratan protokol <code>Sequence</code> .  Untuk contoh ini, cukup dengan mengimplementasikan metode <code>makeIterator()</code> , terutama karena persyaratan protokol lainnya memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi standar</a> .  Metode ini harus mengembalikan instance dari jenis yang mengimplementasikan protokol <code>IteratorProtocol</code> .  Untungnya, dalam kasus Swift, ini adalah kode yang sangat sederhana: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShelfIterator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.books = books } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Book?</span></span> { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Return next underlying Book element. } } extension Shelf: Sequence { func makeIterator() -&gt; ShelfIterator { return ShelfIterator(books: books) } }</span></span></code> </pre><br>  Metode <code>next()</code> dari tipe <code>ShelfIterator</code> dinyatakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>mutating</code></a> , karena instance type harus menyimpan keadaan yang terkait dengan iterasi saat ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Book?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !books.isEmpty { books.removeFirst() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.first }</code> </pre><br>  Opsi implementasi ini selalu mengembalikan elemen pertama dalam urutan, atau <code>nil</code> jika urutan kosong.  Blok <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>defer</code></a> "dibungkus" dengan kode untuk mengubah koleksi iterated, yang menghilangkan elemen dari langkah iterasi terakhir segera setelah metode kembali. <br><br>  Contoh penggunaan: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book1 = <span class="hljs-type"><span class="hljs-type">Book</span></span>(author: <span class="hljs-string"><span class="hljs-string">". "</span></span>, title: <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book2 = <span class="hljs-type"><span class="hljs-type">Book</span></span>(author: <span class="hljs-string"><span class="hljs-string">". "</span></span>, title: <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book3 = <span class="hljs-type"><span class="hljs-type">Book</span></span>(author: <span class="hljs-string"><span class="hljs-string">". "</span></span>, title: <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shelf = <span class="hljs-type"><span class="hljs-type">Shelf</span></span>(books: [book1, book2, book3]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shelf { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(book.author) – \(book.title)"</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/* .  –  .  –   .  –   */</span></span></code> </pre><br>  Karena  semua tipe yang digunakan (termasuk <code>Array</code> mendasari <code>Shelf</code> ) didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semantik nilai (sebagai lawan dari referensi)</a> , Anda tidak perlu khawatir tentang nilai variabel asli yang diubah selama iterasi.  Saat menangani jenis berdasarkan semantik tautan, titik ini harus diingat dan diperhitungkan saat membuat iterator Anda sendiri. <br><br><h3>  Fungsionalitas klasik </h3><br>  "Iterator" klasik yang dijelaskan dalam buku "Gangs of Four", selain mengembalikan elemen berikutnya dari urutan iterable, juga dapat setiap saat mengembalikan elemen saat ini dalam proses iterasi, elemen pertama dari urutan iterable dan nilai "flag" yang menunjukkan apakah masih ada elemen dalam urutan berulang relatif terhadap langkah iterasi saat ini. <br><br>  Tentu saja, akan mudah untuk mendeklarasikan protokol sehingga memperluas kemampuan standar <code>IteratorProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassicIteratorProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentItem: <span class="hljs-type"><span class="hljs-type">Element?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Element?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDone: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre><br>  Elemen pertama dan saat ini dikembalikan opsional sejak  urutan sumber mungkin kosong. <br><br>  Opsi implementasi sederhana: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShelfIterator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassicIteratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentItem: <span class="hljs-type"><span class="hljs-type">Book?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Book?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDone: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(books: [<span class="hljs-type"><span class="hljs-type">Book</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.books = books first = books.first currentItem = books.first } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Book?</span></span> { currentItem = books.first books.removeFirst() isDone = books.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.first } }</code> </pre><br>  Dalam uraian asli pola, metode <code>next()</code> mengubah keadaan internal iterator untuk pergi ke elemen berikutnya dan bertipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Void</code></a> , dan elemen saat ini dikembalikan oleh metode <code>currentElement()</code> .  Dalam protokol <code>IteratorProtocol</code> , kedua fungsi ini seolah-olah digabungkan menjadi satu. <br><br>  Kebutuhan akan metode <code>first()</code> juga diragukan, karena  iterator tidak mengubah urutan asli, dan kami selalu memiliki kesempatan untuk mengakses elemen pertamanya (jika ada, tentu saja). <br><br>  Dan, karena metode <code>next()</code> mengembalikan <code>nil</code> ketika iterasi selesai, metode <code>isDone()</code> juga menjadi tidak berguna. <br><br>  Namun, untuk tujuan akademik, sangat mungkin untuk membuat fungsi yang dapat menggunakan fungsionalitas penuh: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printShelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with iterator: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ShelfIterator)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bookIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> !iterator.isDone { bookIndex += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(bookIndex). \(iterator.currentItem!.author) – \(iterator.currentItem!.title)"</span></span>) <span class="hljs-number"><span class="hljs-number">_</span></span> = iterator.next() } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = <span class="hljs-type"><span class="hljs-type">ShelfIterator</span></span>(books: shelf.books) printShelf(with: &amp;iterator) <span class="hljs-comment"><span class="hljs-comment">/* 1. .  –  2. .  –   3. .  –   */</span></span></code> </pre><br>  Parameter <code>iterator</code> dinyatakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>inout</code></a> karena  keadaan internal berubah selama eksekusi fungsi.  Dan ketika fungsi dipanggil, instance iterator ditransmisikan tidak secara langsung oleh nilainya sendiri, tetapi dengan referensi. <br><br>  Hasil pemanggilan metode <code>next()</code> tidak digunakan, mensimulasikan tidak adanya nilai kembali implementasi buku teks. <br><br><h3>  Alih-alih sebuah kesimpulan </h3><br>  Sepertinya ini yang ingin saya katakan kali ini.  Semua kode indah dan sengaja menulisnya! <br><br>  <b>Artikel saya yang lain tentang pola desain:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Templat arsitektur" Pengunjung "(" Pengunjung ") di semesta" iOS "dan" Swift "</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode Pabrik dan Pabrik Abstrak di Swift dan iOS Universe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pola arsitektur" Builder "di alam semesta" Swift "dan" iOS "/" macOS "</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437614/">https://habr.com/ru/post/id437614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437602/index.html">Profil proyek Persatuan dengan Android Studio</a></li>
<li><a href="../id437604/index.html">Runtuhnya fungsi gelombang: algoritma yang terinspirasi oleh mekanika kuantum</a></li>
<li><a href="../id437606/index.html">Siapa yang memakan memori iPhone kita? Mengupas apel</a></li>
<li><a href="../id437610/index.html">[longrid] 20 tahun karir pemrograman di kota kecil besar</a></li>
<li><a href="../id437612/index.html">Raksasa IT itu akan berurusan dengan silikon fotonik - bagaimana hal itu akan mempengaruhi pasar peralatan jaringan</a></li>
<li><a href="../id437616/index.html">Enam bulan tanpa penurunan penjualan CEO dan iPhone: mengapa saham Intel jatuh</a></li>
<li><a href="../id437618/index.html">42 Google Pencarian Lanjutan Operator (daftar lengkap)</a></li>
<li><a href="../id437620/index.html">Bagaimana teknologi cloud mengubah cara kita memperlakukan</a></li>
<li><a href="../id437622/index.html">Memulai dengan layanan Belajar Mesin Azure</a></li>
<li><a href="../id437624/index.html">OpenSceneGraph: Dasar-dasar Tekstur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>