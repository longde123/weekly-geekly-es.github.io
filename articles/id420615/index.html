<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçæ üíÉ üõï JavaScript: menjelajahi objek üë®‚Äçüë©‚Äçüëß‚Äçüëß üí° üèè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahan, terjemahan yang kami terbitkan hari ini, dikhususkan untuk studi objek - salah satu esensi utama dari JavaScript. Ini dirancang terutama untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: menjelajahi objek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  Bahan, terjemahan yang kami terbitkan hari ini, dikhususkan untuk studi objek - salah satu esensi utama dari JavaScript.  Ini dirancang terutama untuk pengembang pemula yang ingin merampingkan pengetahuan mereka tentang objek. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Objek dalam JavaScript adalah koleksi dinamis properti yang, di samping itu, berisi properti "tersembunyi" yang merupakan prototipe objek.  Properti objek ditandai oleh kunci dan nilai.  Mari kita mulai percakapan tentang objek JS dengan kunci. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Kunci properti objek</font> </h2><br>  Kunci properti objek adalah string unik.  Anda dapat menggunakan dua metode untuk mengakses properti: mengaksesnya melalui suatu periode dan menentukan kunci objek dalam tanda kurung.  Saat mengakses properti melalui titik, kuncinya harus berupa pengidentifikasi JavaScript yang valid.  Pertimbangkan sebuah contoh: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Saat mencoba mengakses properti objek yang tidak ada, pesan kesalahan tidak akan muncul, tetapi nilai yang <code>undefined</code> akan dikembalikan: <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Saat menggunakan tanda kurung siku untuk mengakses properti, Anda dapat menggunakan kunci yang bukan pengidentifikasi JavaScript yang valid (misalnya, kunci tersebut dapat berupa string yang berisi spasi).  Mereka dapat memiliki nilai apa pun yang dapat dilemparkan ke string: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Jika nilai-nilai non-string digunakan sebagai kunci, mereka secara otomatis dikonversi ke string (menggunakan, jika mungkin, metode <code>toString()</code> ): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  Dalam contoh ini, objek <code>number1</code> digunakan sebagai kunci.  Saat mencoba mengakses properti, properti itu dikonversi ke baris <code>1</code> , dan hasil konversi ini digunakan sebagai kunci. <br><br><h2>  <font color="#3AC1EF">Nilai Properti Obyek</font> </h2><br>  Properti objek dapat berupa nilai, objek, atau fungsi primitif. <br><br><h3>  <font color="#3AC1EF">‚ñçObject sebagai nilai properti objek</font> </h3><br>  Objek dapat ditempatkan di objek lain.  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Pendekatan serupa dapat digunakan untuk membuat ruang nama: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Berfungsi sebagai nilai properti objek</font> </h3><br>  Ketika fungsi digunakan sebagai nilai properti objek, biasanya menjadi metode objek.  Di dalam metode, untuk mengakses objek saat ini, gunakan <code>this</code> . <br><br>  Namun kata kunci ini, mungkin memiliki arti yang berbeda, tergantung pada bagaimana fungsinya dipanggil.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca tentang situasi di mana <code>this</code> kehilangan konteks. <br><br><h2>  <font color="#3AC1EF">Sifat dinamis dari objek</font> </h2><br>  Objek dalam JavaScript, pada dasarnya, adalah entitas yang dinamis.  Anda dapat menambahkan properti ke mereka kapan saja, hal yang sama berlaku untuk menghapus properti: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objek sebagai array asosiatif</font> </h2><br>  Objek dapat dianggap sebagai array asosiatif.  Kunci array asosiatif adalah nama properti objek.  Untuk mengakses kunci, Anda tidak perlu melihat semua properti, yaitu operasi mengakses kunci array asosiatif berdasarkan objek dilakukan dalam O (1) waktu. <br><br><h2>  <font color="#3AC1EF">Prototipe objek</font> </h2><br>  Objek memiliki tautan "tersembunyi", <code>__proto__</code> , menunjuk ke objek prototipe dari mana objek mewarisi properti. <br><br>  Misalnya, objek yang dibuat menggunakan objek literal memiliki tautan ke <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Objek kosong</font> </h3><br>  Seperti yang baru saja kita lihat, objek "kosong", <code>{}</code> , sebenarnya tidak begitu kosong, karena berisi referensi ke <code>Object.prototype</code> .  Untuk membuat objek yang benar-benar kosong, Anda perlu menggunakan konstruksi berikut: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Berkat ini, sebuah objek tanpa prototipe akan dibuat.  Objek seperti itu biasanya digunakan untuk membuat array asosiatif. <br><br><h3>  <font color="#3AC1EF">‚ñç Rantai Prototipe</font> </h3><br>  Objek prototipe dapat memiliki prototipe sendiri.  Jika Anda mencoba mengakses properti dari objek yang tidak ada di dalamnya, JavaScript akan mencoba menemukan properti ini dalam prototipe objek ini, dan jika properti yang diinginkan tidak ada di sana, upaya akan dilakukan untuk menemukannya di prototipe prototipe.  Ini akan berlanjut sampai properti yang diinginkan ditemukan, atau sampai akhir rantai prototipe tercapai. <br><br><h2>  <font color="#3AC1EF">Nilai Jenis Primitif dan Pembungkus Objek</font> </h2><br>  JavaScript memungkinkan Anda untuk bekerja dengan nilai tipe primitif sebagai objek, dalam arti bahwa bahasa tersebut memungkinkan Anda untuk mengakses properti dan metode mereka. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Apalagi, tentu saja, nilai tipe primitif bukanlah objek. <br><br>  Untuk mengatur akses ke "properti" nilai-nilai tipe primitif, JavaScript, jika perlu, membuat objek wrapper, yang, setelah mereka menjadi tidak perlu, dihancurkan.  Proses membuat dan menghancurkan objek pembungkus dioptimalkan oleh mesin JS. <br><br>  Pembungkus objek memiliki nilai numerik, string, dan tipe logis.  Objek dari tipe yang sesuai diwakili oleh fungsi konstruktor <code>Number</code> , <code>String</code> , dan <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Prototipe Tertanam</font> </h2><br>  Objek Number mewarisi properti dan metode dari prototipe <code>Number.prototype</code> , yang merupakan turunan dari <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Prototipe objek string adalah <code>String.prototype</code> .  Prototipe objek boolean adalah <code>Boolean.prototype</code> .  Prototipe array (yang juga objek) adalah <code>Array.prototype</code> . <br><br>  Fungsi dalam JavaScript juga objek yang memiliki prototipe <code>Function.prototype</code> .  Fungsi memiliki metode seperti <code>bind()</code> , <code>apply()</code> dan <code>call()</code> . <br><br>  Semua objek, fungsi, dan objek yang mewakili nilai tipe primitif (kecuali untuk nilai <code>null</code> dan <code>undefined</code> ) mewarisi properti dan metode dari <code>Object.prototype</code> .  Ini mengarah pada fakta bahwa, misalnya, mereka semua memiliki metode <code>toString()</code> . <br><br><h2>  <font color="#3AC1EF">Memperluas objek tertanam dengan polyfill</font> </h2><br>  JavaScript memudahkan untuk memperluas objek yang disematkan dengan fitur baru menggunakan apa yang disebut polyfill.  Polyfill adalah potongan kode yang mengimplementasikan fitur yang tidak didukung oleh browser apa pun. <br><br><h3>  <font color="#3AC1EF">‚ñçGunakan polyfill</font> </h3><br>  Misalnya, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polyfill</a> untuk metode <code>Object.assign()</code> .  Ini memungkinkan Anda untuk menambahkan fungsi baru ke <code>Object</code> jika tidak tersedia di dalamnya. <br><br>  Hal yang sama berlaku untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polyfill</a> <code>Array.from()</code> , yang, jika metode <code>from()</code> tidak ada di objek <code>Array</code> , lengkapi dengan metode ini. <br><br><h3>  <font color="#3AC1EF">‚ñç Polyfill dan prototipe</font> </h3><br>  Dengan bantuan polyfill, metode baru dapat ditambahkan ke prototipe objek.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polyfill</a> untuk <code>String.prototype.trim()</code> memungkinkan Anda untuk melengkapi semua objek string dengan metode <code>trim()</code> : <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <code>Array.prototype.find()</code> untuk <code>Array.prototype.find()</code> memungkinkan Anda untuk melengkapi semua array dengan metode <code>find()</code> .  <code>Array.prototype.findIndex()</code> untuk <code>Array.prototype.findIndex()</code> bekerja dengan cara yang sama: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Warisan tunggal</font> </h2><br>  Perintah <code>Object.create()</code> memungkinkan Anda membuat objek baru dengan objek prototipe yang diberikan.  Perintah ini digunakan dalam JavaScript untuk menerapkan mekanisme pewarisan tunggal.  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Warisan berganda</font> </h2><br>  Perintah <code>Object.assign()</code> menyalin properti dari satu atau lebih objek ke objek target.  Ini dapat digunakan untuk mengimplementasikan beberapa skema pewarisan.  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Objek yang Tidak Berubah</font> </h2><br>  Perintah <code>Object.freeze()</code> memungkinkan Anda untuk "membekukan" suatu objek.  Anda tidak dapat menambahkan properti baru ke objek seperti itu.  Properti tidak dapat dihapus, juga nilainya tidak dapat diubah.  Dengan menggunakan perintah ini, suatu objek menjadi tidak berubah atau tidak berubah: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  Perintah <code>Object.freeze()</code> melakukan apa yang disebut "pembekuan dangkal" objek.  Ini berarti bahwa objek yang bersarang di objek "beku" dapat dimodifikasi.  Untuk melakukan "pembekuan yang dalam" dari suatu objek, Anda perlu "membekukan" secara rekursif semua propertinya. <br><br><h2>  <font color="#3AC1EF">Objek Kloning</font> </h2><br>  Untuk membuat klon (salinan) objek, Anda bisa menggunakan perintah <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allong√©", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Perintah ini melakukan penyalinan objek yang dangkal, yaitu hanya menyalin properti tingkat atas.  Objek bersarang ternyata umum untuk objek asli dan salinannya. <br><br><h2>  <font color="#3AC1EF">Objek literal</font> </h2><br>  Literal objek memberi pengembang cara sederhana dan mudah untuk membuat objek: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  Namun, metode membuat objek ini memiliki kelemahan.  Secara khusus, dengan pendekatan ini, semua properti objek tersedia untuk umum, metode objek dapat didefinisikan ulang, mereka tidak dapat digunakan untuk membuat instance baru dari objek yang sama: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Metode Object.create ()</font> </h2><br>  Dua masalah yang disebutkan di atas dapat diselesaikan melalui penggunaan bersama metode <code>Object.create()</code> dan <code>Object.freeze()</code> . <br><br>  Kami menerapkan teknik ini pada contoh kami sebelumnya.  Pertama, buat prototipe <code>timerPrototype</code> beku yang berisi semua metode yang dibutuhkan oleh berbagai instance objek.  Setelah itu, buat objek yang merupakan penerus <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Jika prototipe dilindungi dari perubahan, objek yang pewarisnya tidak akan dapat mengubah properti yang ditentukan dalam prototipe.  Sekarang metode <code>start()</code> dan <code>stop()</code> tidak dapat diganti: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  <code>Object.create(timerPrototype)</code> dapat digunakan untuk membuat beberapa objek dengan prototipe yang sama. <br><br><h2>  <font color="#3AC1EF">Fungsi konstruktor</font> </h2><br>  JavaScript memiliki apa yang disebut fungsi konstruktor, yang merupakan "gula sintaksis" untuk melakukan langkah-langkah di atas untuk membuat objek baru.  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Anda dapat menggunakan fungsi apa pun sebagai konstruktor.  Konstruktor disebut menggunakan kata kunci <code>new</code> .  Objek yang dibuat menggunakan fungsi konstruktor bernama <code>FunctionConstructor</code> akan menerima prototipe <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Di sini, untuk mencegah perubahan prototipe, sekali lagi, Anda dapat membekukan prototipe: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Kata kunci baru</font> </h3><br>  Ketika perintah dari bentuk <code>new Timer()</code> dijalankan, tindakan yang sama dilakukan ketika fungsi <code>newTimer()</code> melakukan di bawah ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Objek baru dibuat di sini, prototipe di antaranya adalah <code>Timer.prototype</code> .  Kemudian fungsi <code>Timer</code> disebut, mengatur bidang untuk objek baru. <br><br><h2>  <font color="#3AC1EF">Kata kunci kelas</font> </h2><br>  ECMAScript 2015 memperkenalkan cara baru untuk melakukan tindakan di atas, yang merupakan kumpulan ‚Äúgula sintaksis‚Äù lainnya.  Kita berbicara tentang kata kunci <code>class</code> dan konstruksi terkait yang terkait dengannya.  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Objek yang dibuat menggunakan kata kunci <code>class</code> berdasarkan kelas bernama <code>ClassName</code> akan memiliki prototipe <code>ClassName.prototype</code> .  Saat membuat objek berdasarkan kelas, gunakan kata kunci <code>new</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Menggunakan kelas tidak membuat prototipe tidak dapat diubah.  Jika perlu, mereka harus "dibekukan" dengan cara yang sama seperti yang sudah kita lakukan: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Warisan Berbasis Prototipe</font> </h2><br>  Dalam JavaScript, objek mewarisi properti dan metode dari objek lain.  Fungsi dan kelas konstruktor adalah "gula sintaksis" untuk membuat objek prototipe yang berisi semua metode yang diperlukan.  Menggunakannya, objek baru dibuat yang merupakan pewaris prototipe, sifat-sifatnya, khusus untuk contoh tertentu, diatur menggunakan fungsi konstruktor atau menggunakan mekanisme kelas. <br><br>  Akan lebih baik jika fungsi dan kelas konstruktor secara otomatis dapat membuat prototipe tidak berubah. <br><br>  Kekuatan warisan prototipe adalah penghematan memori.  Faktanya adalah bahwa prototipe dibuat hanya sekali, setelah semua objek dibuat atas dasar menggunakannya. <br><br><h3>  <font color="#3AC1EF">‚ñç Masalah kurangnya mekanisme enkapsulasi bawaan</font> </h3><br>  Templat pewarisan prototipe tidak menggunakan pemisahan sifat-sifat objek menjadi pribadi dan publik.  Semua properti objek tersedia untuk umum. <br><br>  Sebagai contoh, perintah <code>Object.keys()</code> mengembalikan array yang berisi semua kunci properti objek.  Itu dapat digunakan untuk beralih pada semua properti dari suatu objek: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  Ada satu pola yang meniru properti pribadi, bergantung pada kenyataan bahwa pengembang tidak akan mengakses properti yang namanya dimulai dengan garis bawah ( <code>_</code> ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Fitur Pabrik</font> </h2><br>  Objek yang dienkapsulasi dalam JavaScript dapat dibuat menggunakan fungsi pabrik.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Di sini variabel <code>fn</code> bersifat pribadi.  Hanya metode <code>start()</code> dan <code>stop()</code> yang tersedia untuk umum.  Metode-metode ini tidak dapat dimodifikasi secara eksternal.  Kata kunci ini tidak digunakan di sini, oleh karena itu, ketika menggunakan metode ini membuat objek, masalah kehilangan konteks ini tidak relevan. <br><br>  Perintah <code>return</code> menggunakan objek literal yang hanya berisi fungsi.  Selain itu, fungsi-fungsi ini dinyatakan tertutup, mereka berbagi keadaan umum.  Untuk membekukan API publik dari suatu objek, perintah <code>Object.freeze()</code> sudah dikenal <code>Object.freeze()</code> . <br><br>  Di sini, dalam contoh, kami menggunakan objek <code>Timer</code> .  Dalam materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> Anda dapat menemukan implementasi penuhnya. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dalam JavaScript, nilai tipe primitif, objek biasa, dan fungsi diperlakukan sebagai objek.  Objek memiliki sifat yang dinamis, mereka dapat digunakan sebagai array asosiatif.  Objek adalah pewaris objek lain.  Fungsi dan kelas konstruktor adalah "gula sintaksis", yang memungkinkan Anda membuat objek berdasarkan prototipe.  Anda bisa menggunakan metode <code>Object.create()</code> untuk mengatur pewarisan tunggal, dan <code>Object.create()</code> untuk mengatur beberapa pewarisan.  Anda dapat menggunakan fungsi pabrik untuk membuat objek yang dienkapsulasi. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda datang ke JavaScript dari bahasa lain, beri tahu kami apa yang Anda suka atau tidak suka tentang objek JS, dibandingkan dengan implementasi objek dalam bahasa yang sudah Anda ketahui. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420615/">https://habr.com/ru/post/id420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420605/index.html">Ikhtisar Algoritma Wawancara Kerja - Mengatur Generasi</a></li>
<li><a href="../id420607/index.html">Acara digital di Moskow dari 20 hingga 26 Agustus</a></li>
<li><a href="../id420609/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 327 (13 - 19 Agustus 2018)</a></li>
<li><a href="../id420611/index.html">Pemodelan keterikatan kuantum dalam C #</a></li>
<li><a href="../id420613/index.html">11 pustaka (kumpulan komponen) untuk React Native yang harus Anda ketahui di 2018</a></li>
<li><a href="../id420617/index.html">Panduan Desain Web untuk Pengembang</a></li>
<li><a href="../id420619/index.html">Gambar Responsif: Trik CSS Yang Menghemat Waktu</a></li>
<li><a href="../id420623/index.html">Aplikasi C ++ terdistribusi dengan upaya minimal</a></li>
<li><a href="../id420625/index.html">KDD 2018, Hari Pertama, tutorial</a></li>
<li><a href="../id420627/index.html">C # Asynchronous Programming: Bagaimana kinerja Anda?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>