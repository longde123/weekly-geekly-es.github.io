<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÅ üíÖüèΩ üåü C #: compatibilidade com vers√µes anteriores e sobrecarga üôèüèª ‚ñ´Ô∏è ‚ú®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° colegas! 

 Lembramos a todos que temos um √≥timo livro da Mark Price, " C # 7 e .NET Core. Desenvolvimento de plataforma cruzada para profissionai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C #: compatibilidade com vers√µes anteriores e sobrecarga</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/414223/">  Ol√° colegas! <br><br>  Lembramos a todos que temos um √≥timo livro da Mark Price, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C # 7 e .NET Core. Desenvolvimento de plataforma cruzada para profissionais</a> ".  Observe: esta √© a terceira edi√ß√£o, a primeira edi√ß√£o foi escrita na vers√£o 6.0 e n√£o apareceu em russo, e a terceira edi√ß√£o foi lan√ßada no original em novembro de 2017 e cobre a vers√£o 7.1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qu/3r/yz/qu3ryzosqkh7hbufbfvfjcukuf8.jpeg"></div><br>  Ap√≥s o lan√ßamento desse comp√™ndio, que passou por uma edi√ß√£o cient√≠fica separada para verificar a compatibilidade com vers√µes anteriores e outra corre√ß√£o do material apresentado, decidimos traduzir um artigo interessante de John Skeet sobre quais dificuldades conhecidas e pouco conhecidas com a compatibilidade com vers√µes anteriores podem surgir em C #.  Boa leitura. <br><a name="habracut"></a><br>  Em julho de 2017, comecei a escrever um artigo sobre versionamento.  Logo o abandonou, porque o t√≥pico era extenso demais para ser abordado em apenas um post.  Nesse t√≥pico, faz mais sentido destacar um site / wiki / reposit√≥rio inteiro.  Espero voltar a esse t√≥pico um dia, porque o considero extremamente importante e acho que ele recebe muito menos aten√ß√£o do que merece. <br><br>  Portanto, no ecossistema .NET, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controle de vers√£o sem√¢ntico</a> geralmente √© bem-vindo - parece √≥timo, mas exige que todos compreendam igualmente o que √© considerado uma "mudan√ßa fundamental".  √â isso que venho pensando h√° muito tempo.  Um dos aspectos que mais recentemente me impressionou √© a dificuldade de evitar mudan√ßas fundamentais ao sobrecarregar os m√©todos.  √â sobre isso (principalmente) que discutiremos o post que voc√™ est√° lendo;  Afinal, este t√≥pico √© muito interessante. <br>  Para come√ßar - uma breve defini√ß√£o ... <br><br>  <b>Fontes e compatibilidade bin√°ria</b> <br><br>  Se eu puder recompilar meu c√≥digo de cliente com a nova vers√£o da biblioteca, e tudo funcionar bem, isso √© compatibilidade no n√≠vel do c√≥digo-fonte.  Se eu puder reimplementar o bin√°rio do meu cliente com a nova vers√£o da biblioteca sem recompilar, ele ser√° compat√≠vel com o bin√°rio.  Nada disso √© um superconjunto do outro: <br><br><ul><li>  Algumas altera√ß√µes podem ser incompat√≠veis com o c√≥digo-fonte e o c√≥digo bin√°rio ao mesmo tempo - por exemplo, voc√™ n√£o pode excluir um tipo p√∫blico inteiro do qual depende completamente. </li><li>  Algumas altera√ß√µes s√£o compat√≠veis com o c√≥digo fonte, mas incompat√≠veis com o c√≥digo bin√°rio - por exemplo, se voc√™ converter um campo est√°tico p√∫blico somente leitura em uma propriedade. </li><li>  Algumas altera√ß√µes s√£o compat√≠veis com o bin√°rio, mas n√£o s√£o compat√≠veis com a fonte - por exemplo, adicionando uma sobrecarga que pode causar ambiguidade durante a compila√ß√£o. </li><li>  Algumas altera√ß√µes s√£o compat√≠veis com o c√≥digo-fonte e o c√≥digo bin√°rio - por exemplo, uma nova implementa√ß√£o do corpo do m√©todo. </li></ul><br>  <b>Ent√£o, do que estamos falando?</b> <br><br>  Suponha que tenhamos uma biblioteca p√∫blica da vers√£o 1.0 e queremos adicionar v√°rias sobrecargas para finalizar a vers√£o 1.1.  Aderimos ao controle de vers√£o sem√¢ntico, portanto, precisamos de compatibilidade com vers√µes anteriores.  O que isso significa que podemos e n√£o podemos fazer, e todas as perguntas aqui podem ser respondidas "sim" ou "n√£o"? <br><br>  Em exemplos diferentes, mostrarei o c√≥digo nas vers√µes 1.0 e 1.1 e, em seguida, o c√≥digo "cliente" (ou seja, c√≥digo que usa a biblioteca), que pode ser interrompido como resultado de altera√ß√µes.  N√£o haver√° corpos de m√©todos nem declara√ß√µes de classe, pois eles n√£o s√£o, em ess√™ncia, importantes - prestamos a aten√ß√£o principal √†s assinaturas.  No entanto, se voc√™ estiver interessado, todas essas classes e m√©todos podem ser facilmente reproduzidos.  Suponha que todos os m√©todos descritos aqui estejam na classe <code>Library</code> . <br><br>  A mudan√ßa mais simples conceb√≠vel, adornada com a transforma√ß√£o de um grupo de m√©todos em um delegado <br>  O exemplo mais simples que me vem √† cabe√ßa √© adicionar um m√©todo parametrizado, onde j√° existe um m√©todo n√£o parametrizado: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//   1.0 public void Foo() //   1.1 public void Foo() public void Foo(int x)</span></span></code> </pre> <br><br>  Mesmo aqui, a compatibilidade √© incompleta.  Considere o seguinte c√≥digo do cliente: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); HandleAction(library.Foo); } static void HandleAction(Action action) {} static void HandleAction(Action&lt;int&gt; action) {}</span></span></code> </pre> <br>  Na primeira vers√£o da biblioteca, est√° tudo bem.  Chamar o m√©todo <code>HandleAction</code> converte o grupo de m√©todos na <code>library.Foo</code> delegado e, como resultado, uma <code>Action</code> √© criada.  Na vers√£o 1.1, a situa√ß√£o se torna amb√≠gua: um grupo de m√©todos pode ser convertido em A√ß√£o ou A√ß√£o.  Ou seja, estritamente falando, essa altera√ß√£o √© incompat√≠vel com o c√≥digo fonte. <br><br>  Nesse est√°gio, √© tentador desistir e prometer a si mesmo simplesmente nunca mais adicionar sobrecargas.  Ou podemos dizer que tal caso √© improv√°vel o suficiente para n√£o ter medo de tal falha.  Vamos chamar as transforma√ß√µes de um grupo de m√©todos fora de escopo por enquanto. <br><br>  <b>Tipos de refer√™ncia n√£o relacionados</b> <br><br>  Considere outro contexto em que voc√™ deve usar sobrecargas com o mesmo n√∫mero de par√¢metros.  Pode-se supor que essa altera√ß√£o na biblioteca seja n√£o destrutiva: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x) //  1.1 public void Foo(string x) public void Foo(FileStream x)</span></span></code> </pre> <br>  √Ä primeira vista, tudo √© l√≥gico.  Mantemos o m√©todo original, para n√£o quebrar a compatibilidade bin√°ria.  A maneira mais simples de quebrar isso √© escrever uma chamada que funcione na v1.0, mas que n√£o funcione na v1.1, ou que funcione nas duas vers√µes, mas de maneiras diferentes. <br>  Que incompatibilidade entre a v1.0 e a v1.1 pode ser chamada?  N√≥s devemos ter um argumento compat√≠vel com a <code>string</code> e o <code>FileStream</code> .  Mas estes s√£o tipos de refer√™ncia n√£o relacionados entre si ... <br><br>  A primeira falha √© poss√≠vel se fizermos uma convers√£o impl√≠cita definida pelo usu√°rio para a <code>string</code> e o <code>FileStream</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  class OddlyConvertible { public static implicit operator string(OddlyConvertible c) =&gt; null; public static implicit operator FileStream(OddlyConvertible c) =&gt; null; } static void Method() { var library = new Library(); var convertible = new OddlyConvertible(); library.Foo(convertible); }</span></span></code> </pre> <br>  Espero que o problema seja √≥bvio: o c√≥digo que anteriormente n√£o era amb√≠guo e trabalhava com <code>string</code> agora √© amb√≠guo, pois o tipo <code>OddlyConvertible</code> pode ser implicitamente convertido em <code>string</code> e <code>FileStream</code> (ambas as sobrecargas s√£o aplic√°veis, nenhuma delas √© melhor que a outra). <br><br>  Talvez neste caso seja razo√°vel proibir convers√µes definidas pelo usu√°rio ... mas esse c√≥digo pode ser reduzido e muito mais f√°cil: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(null); }</span></span></code> </pre> <br>  Podemos converter implicitamente um literal nulo em qualquer tipo de refer√™ncia ou em qualquer tipo significativo anul√°vel ... portanto, novamente, a situa√ß√£o na vers√£o 1.1 √© amb√≠gua.  Vamos tentar de novo ... <br><br>  <b>Par√¢metros de tipos de refer√™ncia e tipos significativos n√£o anul√°veis</b> <br><br>  Suponha que n√£o nos importemos com transforma√ß√µes definidas pelo usu√°rio, mas n√£o gostamos de literais nulos problem√°ticos.  Como, neste caso, adicionar sobrecarga com tipo significativo n√£o nulo? <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x) //  1.1 public void Foo(string x) public void Foo(int x)</span></span></code> </pre> <br>  √Ä primeira vista, √© bom - <code>library.Foo(null)</code> funcionar√° bem na v1.1.  Ent√£o ele est√° seguro?  N√£o, apenas n√£o no C # 7.1 ... <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(default); }</span></span></code> </pre> <br>  O literal padr√£o √© exatamente nulo, mas se aplica a qualquer tipo.  Isso √© muito conveniente - e uma verdadeira dor de cabe√ßa quando se trata de sobrecarga e compatibilidade :( <br><br>  <b>Par√¢metros opcionais</b> <br><br>  Par√¢metros opcionais s√£o outro problema.  Suponha que tenhamos um par√¢metro opcional e desejemos adicionar um segundo.  Temos tr√™s op√ß√µes, identificadas abaixo como 1.1a, 1.1be 1.1c. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x = "") //  1.1a //   ,         public void Foo(string x = "") public void Foo(string x = "", string y = "") //  1.1b //          public void Foo(string x = "", string y = "") //  1.1c //   ,    ,   //  ,     . public void Foo(string x) public void Foo(string x = "", string y = "")</span></span></code> </pre> <br><br>  Mas e se o cliente fizer duas chamadas: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(); library.Foo("xyz"); }</span></span></code> </pre><br>  A biblioteca 1.1a mant√©m a compatibilidade no n√≠vel bin√°rio, mas viola no n√≠vel do c√≥digo fonte: agora <code>library.Foo()</code> amb√≠guo.  De acordo com as regras de sobrecarga em C #, s√£o preferidos m√©todos que n√£o exigem que o compilador ‚Äúpreencha‚Äù todos os par√¢metros opcionais dispon√≠veis; no entanto, ele n√£o regula quantos par√¢metros opcionais podem ser preenchidos. <br><br>  A biblioteca 1.1b mant√©m a compatibilidade no n√≠vel da fonte, mas viola a compatibilidade bin√°ria.  O c√≥digo compilado existente foi projetado para chamar um m√©todo com um √∫nico par√¢metro - e esse m√©todo n√£o existe mais. <br><br>  A biblioteca 1.1c mant√©m a compatibilidade bin√°ria, mas est√° repleta de poss√≠veis surpresas no n√≠vel do c√≥digo-fonte.  Agora, a chamada <code>library.Foo()</code> √© resolvida em um m√©todo com dois par√¢metros, enquanto <code>library.Foo("xyz")</code> resolvida em um m√©todo com um par√¢metro (do ponto de vista do compilador, √© prefer√≠vel a um m√©todo com dois par√¢metros, principalmente porque n√£o h√° par√¢metros opcionais n√£o √© necess√°rio preenchimento).  Isso pode ser aceit√°vel se uma vers√£o com um par√¢metro simplesmente delegar vers√µes com dois par√¢metros e, em ambos os casos, o mesmo valor padr√£o for usado.  No entanto, parece estranho que o valor da primeira chamada seja alterado se o m√©todo para o qual ela foi resolvida anteriormente ainda existir. <br><br>  A situa√ß√£o com par√¢metros opcionais se torna ainda mais confusa se voc√™ deseja adicionar um novo par√¢metro n√£o no final, mas no meio - por exemplo, tente aderir ao contrato e mantenha o par√¢metro CancellationToken opcional no final.  Eu n√£o vou entrar nisso ... <br><br>  <b>M√©todos Generalizados</b> <br><br>  A conclus√£o dos tipos nos melhores tempos n√£o foi uma tarefa f√°cil.  Quando se trata de resolver sobrecargas, esse trabalho se transforma em um pesadelo uniforme. <br><br>  Suponha que temos apenas um m√©todo n√£o generalizado na v1.0 e na v1.1 adicionamos outro m√©todo generalizado. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(object x) //  1.1 public void Foo(object x) public void Foo&lt;T&gt;(T x)</span></span></code> </pre> <br>  √Ä primeira vista, n√£o √© t√£o assustador ... mas vamos ver o que acontece no c√≥digo do cliente: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(new object()); library.Foo("xyz"); }</span></span></code> </pre> <br>  Na biblioteca v1.0, as duas chamadas s√£o resolvidas no <code>Foo(object)</code> - o √∫nico m√©todo dispon√≠vel. <br><br>  A biblioteca v1.1 √© compat√≠vel com vers√µes anteriores: se voc√™ pegar o arquivo execut√°vel do cliente compilado para a v1.1, as duas chamadas ainda usar√£o <code>Foo(object)</code> .  Mas, no caso de recompila√ß√£o, a segunda chamada (e somente a segunda) mudar√° para trabalhar com o m√©todo generalizado.  Ambos os m√©todos se aplicam a ambas as chamadas. <br><br>  Na primeira chamada, a infer√™ncia de tipo mostrar√° que <code>T</code> √© um <code>object</code> , portanto, a convers√£o do argumento no tipo de par√¢metro nos dois casos ser√° reduzida para <code>object</code> no <code>object</code> .  √ìtimo.  O compilador aplicar√° a regra de que m√©todos n√£o gen√©ricos s√£o sempre prefer√≠veis a m√©todos gen√©ricos. <br><br>  Na segunda chamada, a infer√™ncia de tipo mostrar√° que <code>T</code> sempre ser√° <code>string</code> , portanto, ao converter um argumento em um par√¢metro de tipo, obtemos <code>string</code> em <code>object</code> para o m√©todo original ou <code>string</code> em <code>string</code> para o m√©todo generalizado.  A segunda transforma√ß√£o √© "melhor", ent√£o o segundo m√©todo √© escolhido. <br><br>  Se os dois m√©todos funcionarem da mesma maneira, tudo bem.  Caso contr√°rio, voc√™ quebrar√° a compatibilidade de uma maneira muito √≥bvia. <br><br>  <b>Heran√ßa e digita√ß√£o din√¢mica</b> <br><br>  Desculpe, eu j√° estou sem f√¥lego.  Tanto a heran√ßa quanto a digita√ß√£o din√¢mica ao resolver sobrecargas podem se manifestar da maneira mais "legal" e misteriosa. <br>  Se adicionarmos esse m√©todo em um n√≠vel da hierarquia de heran√ßa que sobrecarregar√° o m√©todo da classe base, o novo m√©todo ser√° processado primeiro e ser√° preferido ao m√©todo da classe base, mesmo que o m√©todo da classe base seja mais preciso ao converter um argumento em um par√¢metro de tipo.  H√° espa√ßo suficiente para misturar tudo. <br><br>  O mesmo vale para digita√ß√£o din√¢mica (no c√≥digo do cliente);  at√© certo ponto, a situa√ß√£o se torna imprevis√≠vel.  Voc√™ j√° sacrificou seriamente a seguran√ßa durante a compila√ß√£o ... portanto, n√£o se surpreenda se algo quebrar. <br><br>  <b>Sum√°rio</b> <br><br>  Tentei simplificar os exemplos deste artigo.  Tudo se torna muito complicado, e muito rapidamente, quando voc√™ tem muitos par√¢metros opcionais.  O controle de vers√£o √© uma quest√£o complicada, minha cabe√ßa incha com isso. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414223/">https://habr.com/ru/post/pt414223/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414213/index.html">Um, dois, tr√™s! Chatbot do Planilhas Google usando o exemplo de um jogo PvP para Alice</a></li>
<li><a href="../pt414215/index.html">Blocos personalizados em chips (Silicon IP): como funciona</a></li>
<li><a href="../pt414217/index.html">Smartphones locais da Vertex: primeiro em qualidade, primeiro em chips, primeiro em design</a></li>
<li><a href="../pt414219/index.html">A experi√™ncia de usar energia solar na regi√£o de Moscou: a favor, contra e quem precisa</a></li>
<li><a href="../pt414221/index.html">Analisando e trabalhando com Codable no Swift 4</a></li>
<li><a href="../pt414225/index.html">Criando sua pr√≥pria rede de dispositivos caseiros com base no Arduino (Parte 1)</a></li>
<li><a href="../pt414227/index.html">Um novo estudo dos indicadores de telegrama ap√≥s o bloqueio: os assinantes est√£o crescendo, a cobertura est√° caindo</a></li>
<li><a href="../pt414229/index.html">An√°lise de v√°rios m√©todos de treinamento de TI</a></li>
<li><a href="../pt414231/index.html">Como fiz um computador completamente silencioso</a></li>
<li><a href="../pt414233/index.html">1. Baseado em Meyers ‚Äúc ++ efetivo e moderno‚Äù - infer√™ncia de tipo de modelo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>