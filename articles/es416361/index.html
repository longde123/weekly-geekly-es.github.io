<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíØ üíÄ üçû C√≥mo organizar el estado general en aplicaciones de reacci√≥n sin usar bibliotecas (y por qu√© se necesita mobx) üë©‚Äçüëß‚Äçüëß üë®‚Äç‚úàÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inmediatamente un peque√±o spoiler: organizar un estado en mobx no es diferente de organizar un estado general sin usar mobx en una reacci√≥n pura. La r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo organizar el estado general en aplicaciones de reacci√≥n sin usar bibliotecas (y por qu√© se necesita mobx)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Inmediatamente un peque√±o spoiler: organizar un estado en mobx no es diferente de organizar un estado general sin usar mobx en una reacci√≥n pura.  La respuesta a la pregunta natural es por qu√©, de hecho, ¬øse necesita este mobx? Lo encontrar√° al final del art√≠culo, pero por ahora, el art√≠culo se dedicar√° al tema de la organizaci√≥n estatal en una aplicaci√≥n de reacci√≥n limpia sin bibliotecas externas. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  La reacci√≥n proporciona una forma de almacenar y actualizar el estado de los componentes utilizando la propiedad de estado en una instancia de un componente de clase y el m√©todo setState.  Sin embargo, entre la comunidad de reacci√≥n, se utilizan un mont√≥n de bibliotecas y enfoques adicionales para trabajar con el estado (flux, redux, redux-ations, efector, mobx, cerebral, un mont√≥n de ellos).  Pero, ¬øes posible construir una aplicaci√≥n suficientemente grande con un mont√≥n de l√≥gica de negocios con una gran cantidad de entidades y complejas relaciones de datos entre componentes usando solo setState?  ¬øExiste la necesidad de bibliotecas adicionales para trabajar con el estado?  Vamos a resolverlo. <a name="habracut"></a><br><p>  As√≠ que tenemos setState y que actualiza el estado y llama al procesador del componente.  Pero, ¬øqu√© sucede si muchos componentes que no est√°n interconectados requieren los mismos datos?  En el muelle oficial de la reacci√≥n hay una secci√≥n "levantando el estado" con una descripci√≥n detallada: simplemente elevamos el estado al ancestro com√∫n a estos componentes, pasando a trav√©s de accesorios (y a trav√©s de componentes intermedios, si es necesario) datos y funciones para cambiarlo.  Para ejemplos peque√±os, esto parece razonable, pero la realidad es que en aplicaciones complejas puede haber muchas dependencias entre componentes y la tendencia a transferir estados a un componente com√∫n del antepasado lleva al hecho de que todo el estado ser√° m√°s y m√°s alto y terminar√° en el componente ra√≠z de la aplicaci√≥n junto con La l√≥gica para actualizar este estado para todos los componentes.  Como resultado, setState solo ocurrir√° para actualizar el componente de datos local o en el componente ra√≠z de la aplicaci√≥n, en el que se concentrar√° toda la l√≥gica. </p><br><p>  Pero, ¬øes posible almacenar el proceso y el estado de representaci√≥n en una aplicaci√≥n de reacci√≥n sin usar setState o ninguna biblioteca adicional y proporcionar acceso general a estos datos desde cualquier componente? </p><br><p>  Los objetos javascript m√°s comunes y ciertas reglas para organizarlos nos ayudan. </p><br><p>  Pero primero debe aprender a descomponer las aplicaciones en tipos de entidad y sus relaciones. </p><br><p>  Para comenzar, presentamos un objeto que almacenar√° datos globales que se aplican a toda la aplicaci√≥n como un todo (esto puede ser la configuraci√≥n de estilos, localizaci√≥n, tama√±os de ventana, etc.) en un solo objeto AppState y simplemente coloca este objeto en un archivo separado. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Ahora en cualquier componente puede importar y usar los datos de nuestra tienda. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Vamos m√°s all√°: casi todas las aplicaciones tienen la esencia del usuario actual (no importa c√≥mo se crea o proviene del servidor, etc.), por lo que el objeto singleton de nuestro usuario tambi√©n estar√° en el estado de la aplicaci√≥n.  Tambi√©n se puede mover a un archivo separado y tambi√©n importarse, o se puede almacenar inmediatamente dentro del objeto AppState.  Y ahora lo principal: debe determinar el diagrama de las entidades que componen la aplicaci√≥n.  En t√©rminos de una base de datos, estas ser√°n tablas con relaciones uno a muchos o muchos a muchos, y toda esta cadena de relaciones comienza desde la esencia principal del usuario.  Bueno, en nuestro caso, el objeto del usuario simplemente almacenar√° una matriz de otros objetos-entidades-tiendas, donde cada objeto-tienda, a su vez, almacenar√° matrices de otras entidades-tiendas. </p><br><p>  Aqu√≠ hay un ejemplo: hay una l√≥gica de negocios que se expresa como "el usuario puede crear / editar / eliminar carpetas, proyectos en cada carpeta, en cada proyecto de tarea y en cada tarea de subtarea" (resulta algo as√≠ como un administrador de tareas) y se ver√° en el diagrama de estado algo como esto: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Ahora, el componente ra√≠z de la aplicaci√≥n puede simplemente importar este objeto y presentar informaci√≥n sobre el usuario, y luego puede transferir el objeto del usuario al componente del tablero </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  y √©l puede representar la lista de carpetas </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  y cada componente de la carpeta mostrar√° una lista de proyectos </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  y cada componente del proyecto puede enumerar tareas </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  y finalmente, cada componente de la tarea puede representar una lista de subtareas pasando el objeto deseado al componente de subtarea </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Naturalmente, en una p√°gina nadie mostrar√° todas las tareas de todos los proyectos de todas las carpetas, se dividir√°n por paneles laterales (por ejemplo, una lista de carpetas), por p√°ginas, etc., pero la estructura general es aproximadamente la misma: el componente principal representa el componente incrustado pasando un objeto con accesorios. datos  Cabe se√±alar un punto importante: cualquier objeto (por ejemplo, un objeto de una carpeta, proyecto, tarea) no se almacena dentro del estado de ning√∫n componente; el componente simplemente lo recibe a trav√©s de accesorios como parte de un objeto m√°s general.  Y, por ejemplo, cuando el componente del proyecto pasa el objeto de tarea ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) al componente hijo de Task, debido al hecho de que los objetos se almacenan dentro de un solo objeto siempre puede cambiar este objeto de tarea desde el exterior, por ejemplo, AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "tarea editada" y luego hacer que el componente ra√≠z se actualice (ReactDOM.render (&lt;App /&gt; ) y de esta forma obtenemos el estado actual de la aplicaci√≥n. </p><br><p>  Supongamos adem√°s que queremos crear una nueva subtarea al hacer clic en el bot√≥n "+" en el componente Tarea.  Todo es simple </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  dado que el componente Tarea recibe como apuntalamiento el objeto de tarea y este objeto no se almacena dentro de su estado sino que es parte del almac√©n global de AppState (es decir, el objeto de tarea se almacena dentro de la matriz de tareas del objeto de proyecto m√°s general, y eso a su vez es parte del objeto de usuario y el usuario ya est√° almacenado dentro de AppState ) y gracias a esta conectividad, despu√©s de agregar un nuevo objeto de tarea a la matriz de subtareas, puede llamar a la actualizaci√≥n del componente ra√≠z y, por lo tanto, actualizar y actualizar la casa para todos los cambios de datos (sin importar d√≥nde ocurrieron) simplemente llamando a la funci√≥n upd  ateDOM, que a su vez simplemente actualiza el componente ra√≠z. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  Y no importa qu√© datos de qu√© partes de AppState y desde qu√© lugares cambiemos (por ejemplo, puede reenviar un objeto de carpeta a trav√©s de accesorios a trav√©s de componentes intermedios de proyectos y tareas al componente Subtarea, y solo puede actualizar el nombre de la carpeta (this.props.folder.name = "nombre nuevo "): debido a que los componentes reciben datos a trav√©s de accesorios, la actualizaci√≥n del componente ra√≠z actualizar√° todos los componentes anidados y actualizar√° toda la aplicaci√≥n. </p><br><p>  Ahora intentemos agregar algo de conveniencia para trabajar con el lateral.  En el ejemplo anterior, puede observar que al crear un nuevo objeto de entidad cada vez (por ejemplo, <code>project.tasks.push({text: "", subtasks: [], ...})</code> si el objeto tiene muchas propiedades con par√°metros predeterminados, cada vez para enumerarlos y cometer un error y olvidar algo, etc. Lo primero que viene a la mente es poner la creaci√≥n de un objeto en una funci√≥n donde se asignar√°n los campos predeterminados y, al mismo tiempo, redefinirlos con nuevos datos. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  pero si miras desde el otro lado, esta funci√≥n es el constructor de una determinada entidad y las clases de JavaScript son excelentes para este rol </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  y luego crear el objeto simplemente crear√° una instancia de la clase con la capacidad de anular algunos campos predeterminados </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  Adem√°s, puede notar que de la misma manera, al crear clases para objetos de proyecto, usuarios, subtareas, obtenemos duplicaci√≥n de c√≥digo dentro del constructor </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  pero podemos aprovechar la herencia y extraer este c√≥digo en el constructor de la clase base. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  Adem√°s, notar√° que cada vez que actualizamos alg√∫n estado, cambiamos manualmente los campos del objeto </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  y se hace dif√≠cil rastrear, negociar y comprender lo que est√° sucediendo en el componente y, por lo tanto, es necesario determinar un canal com√∫n a trav√©s del cual pasar√°n las actualizaciones de cualquier informaci√≥n y luego podemos agregar el registro y todo tipo de otras comodidades.  Para hacer esto, la soluci√≥n es crear un m√©todo de actualizaci√≥n en la clase que tome un objeto temporal con nuevos datos y se actualice a s√≠ mismo y establezca la regla de que los objetos se pueden actualizar solo a trav√©s del m√©todo de actualizaci√≥n y no mediante asignaci√≥n directa </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Bueno, para no duplicar el c√≥digo en cada clase, tambi√©n movemos este m√©todo de actualizaci√≥n a la clase base. </p><br><p>  Ahora puede ver que cuando actualizamos algunos datos, tenemos que llamar manualmente al m√©todo updateDOM ().  Pero es conveniente realizar esta actualizaci√≥n autom√°ticamente cada vez que se realiza una llamada al m√©todo de actualizaci√≥n ({...}) de la clase base. <br>  Resulta que la clase base se ver√° as√≠ </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Bueno, para que durante la llamada sucesiva del m√©todo update () no haya actualizaciones innecesarias, puede retrasar la actualizaci√≥n del componente al siguiente bucle de eventos </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  Adem√°s, puede aumentar gradualmente la funcionalidad de la clase base, por ejemplo, para no tener que enviar manualmente una solicitud al servidor cada vez, adem√°s de actualizar el estado, puede enviar una solicitud al m√©todo de actualizaci√≥n ({..}) en segundo plano.  Puede organizar un canal de actualizaci√≥n en vivo para sockets web agregando una cuenta de cada objeto creado en el mapa global de hash sin cambiar los componentes y trabajar con datos de ninguna manera. </p><br><p>  Todav√≠a queda mucho por hacer, pero quiero mencionar un tema interesante: muy a menudo pasar un objeto con datos al componente necesario (por ejemplo, cuando un componente del proyecto representa un componente de tarea) </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  El componente mismo de la tarea puede necesitar cierta informaci√≥n que no se almacena directamente dentro de la tarea, sino que se encuentra en el objeto principal. </p><br><p>  Suponga que desea colorear todas las tareas en un color que est√© almacenado en el proyecto y que sea com√∫n a todas las tareas.  Para hacer esto, adem√°s de los accesorios de la tarea, el componente del proyecto tambi√©n debe transmitir sus accesorios del proyecto <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  Y si de repente necesita colorear la tarea en un color com√∫n a todas las tareas en una carpeta, tendr√° que transferir el objeto de carpeta actual del componente Carpeta al componente Tarea envi√°ndolo a trav√©s del componente Proyecto intermedio. <br>  Parece una dependencia fr√°gil que el componente debe saber lo que requieren sus componentes anidados.  Adem√°s, la posibilidad de un contexto de reacci√≥n, aunque simplificar√° la transferencia a trav√©s de componentes intermedios, a√∫n requerir√° una descripci√≥n del proveedor y el conocimiento de qu√© datos se necesitan para los componentes secundarios. </p><br><p>  Pero el problema principal es que cada vez que edita un dise√±o o cambia la lista de deseos de un cliente cuando un componente necesita nueva informaci√≥n, tendr√° que cambiar los componentes superiores, ya sea reenviando accesorios o creando proveedores de contexto.  Me gustar√≠a que el componente reciba a trav√©s de accesorios un objeto con datos para acceder de alguna manera a cualquier parte del estado de nuestra aplicaci√≥n.  Y aqu√≠, javascript es una buena opci√≥n (a diferencia de cualquier lenguaje funcional como elm o enfoques inmutables como redux), para que los objetos puedan almacenar enlaces circulares entre s√≠.  En este caso, el objeto de tarea debe tener un campo task.project con un enlace al objeto del proyecto principal en el que est√° almacenado, y el objeto del proyecto a su vez debe tener un enlace al objeto de carpeta, etc., al objeto ra√≠z de AppState.  Por lo tanto, el componente, no importa cu√°n profundo sea, siempre puede atravesar los objetos principales a trav√©s del enlace y obtener toda la informaci√≥n necesaria y no es necesario lanzarlo a trav√©s de un grupo de componentes intermedios.  Por lo tanto, presentamos una regla: cada vez que cree un objeto, debe agregar un enlace al objeto principal.  Por ejemplo, ahora crear una nueva tarea se ver√° as√≠ </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  Adem√°s, con un aumento en la l√≥gica empresarial, puede notar que la placa de identificaci√≥n est√° asociada con el soporte de v√≠nculo de retroceso (por ejemplo, al asignar un enlace al objeto principal al crear un nuevo objeto o, por ejemplo, al transferir un proyecto de una carpeta a otra, no solo necesitar√° actualizar la propiedad project.folder = newFolder y eliminarla). usted mismo desde la matriz del proyecto de la carpeta anterior y agregando una nueva carpeta a la matriz del proyecto) comienza a repetirse y tambi√©n se puede mover a la clase base para que cuando cree el objeto sea suficiente para especificar la <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> y la clase base agregar√≠a autom√°ticamente un nuevo objeto a la matriz <code>project.tasks</code> y tambi√©n al transferir la tarea a otro proyecto bastar√≠a con actualizar el campo <code>task.update({project: newProject})</code> y la clase base eliminar√≠a autom√°ticamente la tarea de un conjunto de tareas del proyecto anterior y agregado a uno nuevo.  Pero esto ya requerir√° la declaraci√≥n de relaciones (por ejemplo, en propiedades o m√©todos est√°ticos) para que la clase base sepa qu√© campos actualizar. </p><br><p>  <strong>Conclusi√≥n</strong> </p><br><p>  De una manera tan simple, usando solo objetos js, llegamos a la conclusi√≥n de que puede obtener toda la conveniencia de trabajar con el estado general de la aplicaci√≥n sin introducir en la aplicaci√≥n la dependencia de una biblioteca externa para trabajar con el estado. </p><br><p>  La pregunta es, ¬øpor qu√© entonces necesitamos bibliotecas para administrar el estado y, en particular, mobx? </p><br><p>  El hecho es que en el enfoque descrito para la organizaci√≥n del estado general, cuando se usan objetos js "vainilla" nativos ordinarios (u objetos de clase) hay un gran inconveniente: cuando una peque√±a parte del estado o incluso un campo cambia, los componentes se actualizar√°n o "renderizar√°n" y no estar√°n conectados de ninguna manera y no dependen de esta parte del estado. <br>  Y en aplicaciones grandes con interfaz de usuario en negrita, esto conducir√° a frenos porque la reacci√≥n simplemente no tiene tiempo para comparar recursivamente la casa virtual de toda la aplicaci√≥n, dado que adem√°s de comparar cada renderizador, se generar√° un nuevo √°rbol de objetos cada vez que describa el dise√±o de absolutamente todos los componentes. </p><br><p>  Pero este problema, a pesar de la importancia, es puramente t√©cnico: hay bibliotecas similares a la reacci√≥n de vitual dom que optimizan mejor el renderizador y pueden aumentar el l√≠mite del componente. </p><br><p>  Existen t√©cnicas de renovaci√≥n del hogar m√°s efectivas que la creaci√≥n de un nuevo √°rbol de inicio virtual y la posterior comparaci√≥n recursiva con el √°rbol anterior. </p><br><p>  Y finalmente, hay bibliotecas que intentan resolver el problema de las actualizaciones lentas a trav√©s de un enfoque diferente, es decir, rastrear qu√© partes del estado est√°n conectadas a qu√© componentes y al cambiar algunos datos, calcular y actualizar solo aquellos componentes que dependen de estos datos y no tocan los componentes restantes.  Redux tambi√©n es una biblioteca de este tipo, pero requiere un enfoque completamente diferente de la organizaci√≥n estatal.  Pero la biblioteca mobx, por el contrario, no trae nada nuevo y podemos acelerar el renderizador pr√°cticamente sin cambiar nada en la aplicaci√≥n: simplemente agregue el decorador <code>@observable</code> a los campos de la clase y el decorador <code>@observable</code> a los componentes que representan estos campos y permanece. para cortar solo el c√≥digo de actualizaci√≥n innecesario para el componente ra√≠z en el m√©todo update () de nuestra clase base y obtendremos una aplicaci√≥n completamente funcional, pero ahora cambiando una parte del estado o incluso un campo actualizar√° solo esos componentes  que vencieron firmado (girando m√©todo dentro render ()) para un campo particular de un estado particular del objeto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416361/">https://habr.com/ru/post/es416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416349/index.html">Ver la onda</a></li>
<li><a href="../es416351/index.html">Enfoque de arriba hacia abajo. Econom√≠a del producto. Beneficio bruto</a></li>
<li><a href="../es416353/index.html">Audio Digest: 20 materiales sobre la historia de los sistemas ac√∫sticos y la m√∫sica en la cultura sovi√©tica.</a></li>
<li><a href="../es416355/index.html">Entrevista con Gary Hudson, CEO de Oisin Biotechnologies</a></li>
<li><a href="../es416359/index.html">Entorno de trabajo r√°pido para desarrolladores web (Vagrant y PHPStorm)</a></li>
<li><a href="../es416363/index.html">Taobao abri√≥ oficialmente en Rusia</a></li>
<li><a href="../es416365/index.html">Colecci√≥n de deseos y votaci√≥n para nuevas funciones del navegador Vivaldi</a></li>
<li><a href="../es416367/index.html">Comenzamos ReactOS con BTRFS de la secci√≥n</a></li>
<li><a href="../es416369/index.html">Casi complicado. Parte 2, crear una "casa inteligente" inal√°mbrica. Basado en tecnolog√≠a Linux, software Z-Wave y MajorDoMo</a></li>
<li><a href="../es416371/index.html">Luz de camping anal√≥gica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>