<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèæ üôÖüèΩ üíº Logique d'entreprise asynchrone de nos jours ‚úãüèª üï¥üèø ü•¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En bref: 


- La preuve est d√©j√† impl√©ment√©e en C ++ , JS et PHP , adapt√©e √† Java . 
- Plus rapide que Coroutine et Promise, plus de fonctionnalit√©s. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logique d'entreprise asynchrone de nos jours</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424311/"><p>  En bref: </p><br><blockquote><ul><li>  La preuve est d√©j√† impl√©ment√©e en <strong>C ++</strong> , <strong>JS</strong> et <strong>PHP</strong> , adapt√©e √† <strong>Java</strong> . </li><li> <strong>Plus rapide</strong> que Coroutine et Promise, plus de fonctionnalit√©s. </li><li>  Il ne n√©cessite pas de pile logicielle distincte. </li><li>  Se lie d'amiti√© avec tous les outils de s√©curit√© et de d√©bogage. </li><li>  Il fonctionne sur n'importe quelle architecture et ne n√©cessite pas de drapeaux de compilation sp√©ciaux. </li></ul><br></blockquote><a name="habracut"></a><br><hr><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Regarder en arri√®re</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FutoIn AsyncSteps - une alternative aux coroutines</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aux chiffres</a> </li></ul><br><h2 id="vzglyad-nazad">  Regarder en arri√®re </h2><br><p>  √Ä l'aube de l'ordinateur, il y avait un seul flux de contr√¥le avec blocage sur entr√©e-sortie.  Puis des interruptions de fer y ont √©t√© ajout√©es.  Vous pouvez d√©sormais utiliser efficacement des appareils lents et impr√©visibles. </p><br><p>  Avec la croissance des capacit√©s de fer et sa faible disponibilit√©, il est devenu n√©cessaire d'effectuer plusieurs t√¢ches simultan√©ment, ce qui a fourni un support mat√©riel.  Il y avait donc des processus isol√©s avec des interruptions abstraites du fer sous forme de signaux. </p><br><p>  L'√©tape √©volutive suivante a √©t√© le multithreading, qui a √©t√© mis en ≈ìuvre sur la base des m√™mes processus, mais avec un acc√®s partag√© √† la m√©moire et √† d'autres ressources.  Cette approche a ses limites et ses frais g√©n√©raux importants pour passer √† un syst√®me d'exploitation s√©curis√©. </p><br><p>  Pour la communication entre processus et m√™me diff√©rentes machines, l'abstraction Promise / Future a √©t√© propos√©e il y a plus de 40 ans. </p><br><p>  Les interfaces utilisateur et le probl√®me maintenant ridicule du client 10K ont conduit √† l'apog√©e des approches Event Loop, Reactor et Proactor, qui sont plus orient√©es √©v√©nements qu'une logique m√©tier claire et coh√©rente. </p><br><p>  Enfin, nous sommes arriv√©s √† la coroutine moderne (coroutine), qui est essentiellement une √©mulation de flux au-dessus des abstractions d√©crites ci-dessus avec les limitations techniques correspondantes et le transfert d√©terministe de contr√¥le. </p><br><p>  Pour transmettre des √©v√©nements, des r√©sultats et des exceptions, ils sont tous revenus au m√™me concept de promesse / avenir.  Certains bureaux ont d√©cid√© de nommer un peu diff√©remment "T√¢che". </p><br><p> En fin de compte, ils ont tout cach√© dans un beau paquet <code>async/await</code> , qui n√©cessite le support du compilateur ou du traducteur selon la technologie. </p><br><h3 id="problemy-s-tekuschiy-situaciy-asinhronnoy-biznes-logiki">  Probl√®mes avec les situations de logique m√©tier asynchrones actuelles </h3><br><p>  Consid√©rez uniquement les coroutines et Promise, d√©cor√©es d‚Äô <code>async/await</code>  l'existence de probl√®mes dans les anciennes approches confirme le processus d'√©volution lui-m√™me. </p><br><p>  Ces deux termes ne sont pas identiques.  Par exemple, dans ECMAScript, il n'y a pas de coroutines, mais il existe un soulagement syntaxique pour l'utilisation de <code>Promise</code> , qui √† son tour organise uniquement le travail avec l'enfer de rappel.  En fait, les moteurs de script comme V8 vont plus loin et font des optimisations sp√©ciales pour les fonctions et les appels <code>async/await</code> purs. </p><br><p>  Les experts <code>co_async/co_await</code> qui n'est pas tomb√© dans C ++ 17 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici sur la ressource</a> , mais la pression des coroutines g√©antes du logiciel peut appara√Ætre dans la norme exactement sous leur forme.  En attendant, la solution traditionnellement reconnue est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Context</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Fiber</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Coroutine2</a> . </p><br><p>  En Java, il n'y a toujours pas d' <code>async/await</code> au niveau du langage, mais il existe des solutions comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EA Async</a> , qui, comme Boost.Context, doivent √™tre personnalis√©es pour chaque version de la JVM et de l'octet de code. </p><br><p>  Go a ses propres coroutines, mais si vous regardez attentivement les articles et les rapports de bogues des projets ouverts, il s'av√®re qu'ici tout n'est pas si fluide.  Peut-√™tre que perdre l'interface coroutine en tant qu'entit√© g√©r√©e n'est pas une bonne id√©e. </p><br><h4 id="mnenie-avtora-soprogrammy-na-golom-zheleze-opasny">  Opinion de l'auteur: les coroutines en m√©tal nu sont dangereuses </h4><br><p>  Personnellement, l'auteur a peu contre les coroutines dans les langages dynamiques, mais il se m√©fie extr√™mement de tout flirt avec la pile au niveau du code machine. </p><br><p>  Quelques points: </p><br><ol><li>  Pile requise: <br><ul><li>  la pile sur le tas pr√©sente un certain nombre d'inconv√©nients: probl√®mes de d√©termination rapide du d√©bordement, dommages caus√©s par les voisins et autres probl√®mes de fiabilit√© / s√©curit√©, </li><li>  une pile s√©curis√©e n√©cessite au moins une page de m√©moire physique, une page conditionnelle et une surcharge suppl√©mentaire pour chaque appel aux fonctions <code>async</code> : 4 + Ko (minimum) + augmentation des limites du syst√®me, </li><li>  en fin de compte, il se peut qu'une partie importante de la m√©moire allou√©e aux piles ne soit pas utilis√©e pendant le temps d'arr√™t de la coroutine. </li></ul></li><li>  Il est n√©cessaire de mettre en ≈ìuvre une logique complexe pour enregistrer, restaurer et supprimer l'√©tat de la coroutine: <br><ul><li>  pour chaque cas d'architecture de processeur (m√™me les mod√®les) et d'interface binaire (ABI): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , </li><li>  des fonctionnalit√©s d'architecture nouvelles ou optionnelles introduisent des probl√®mes potentiellement latents (par exemple, Intel TSX, co-processeurs ARM ou MIPS), </li><li>  d'autres probl√®mes potentiels dus √† la documentation ferm√©e des syst√®mes propri√©taires (la documentation Boost s'y r√©f√®re). </li></ul></li><li>  Probl√®mes potentiels avec les outils d'analyse dynamique et avec la s√©curit√© en g√©n√©ral: <br><ul><li>  par exemple, l'int√©gration avec Valgrind est requise en raison des m√™mes piles de sauts, </li><li>  il est difficile de parler pour les antivirus, mais probablement ils n'aiment pas vraiment √ßa sur l'exemple des probl√®mes avec la JVM dans le pass√©, </li><li>  Je suis s√ªr que de nouveaux types d'attaques appara√Ætront et que les vuln√©rabilit√©s associ√©es √† la mise en ≈ìuvre des coroutines seront r√©v√©l√©es. </li></ul></li></ol><br><h4 id="mnenie-avtora-generatory-i-yield-principialnoe-zlo">  Opinion de l'auteur: g√©n√©rateurs et <code>yield</code> mal fondamental </h4><br><p>  Ce th√®me apparemment tiers est directement li√© au concept de coroutines et √† la propri√©t√© "continue". </p><br><p>  En bref, un it√©rateur complet doit exister pour toute collection.  Pourquoi cr√©er un probl√®me d'it√©rateur-g√©n√©rateur recadr√© n'est pas clair.  Par exemple, un cas avec <code>range()</code> en Python est plus une d√©monstration exclusive qu'une excuse pour une complication technique. </p><br><p>  Si le cas est un g√©n√©rateur infini, alors la logique de sa mise en ≈ìuvre est √©l√©mentaire.  Pourquoi cr√©er des difficult√©s techniques suppl√©mentaires afin de pousser un cycle continu sans fin. </p><br><p>  La seule justification raisonnable qui a √©merg√© plus tard que les partisans des coroutines donnent est toutes sortes d'analyseurs de flux avec un contr√¥le invers√©.  En fait, il s'agit d'un cas sp√©cialis√© √©troit pour la r√©solution de probl√®mes uniques au niveau de la biblioth√®que, et non de la logique m√©tier des applications.  En m√™me temps, il existe une solution √©l√©gante, simple et plus descriptive √† travers les machines √† √©tats finis.  Le domaine de ces probl√®mes techniques est beaucoup plus petit que le domaine de la logique commerciale courante. </p><br><p>  En fait, le probl√®me √† r√©soudre est obtenu d'un doigt et n√©cessite des efforts relativement s√©rieux pour la mise en ≈ìuvre initiale et le support √† long terme.  √Ä tel point que certains projets peuvent introduire une interdiction de l'utilisation des coroutines au niveau du code machine √† l'instar de l'interdiction de <code>goto</code> ou de l'utilisation de l'allocation dynamique de m√©moire dans des industries individuelles. </p><br><h4 id="mnenie-avtora-model-asyncawait-na-promise-iz-ecmascript-bolee-nadyozhna-no-trebuet-adaptacii">  Opinion des auteurs: Le mod√®le <code>async/await</code> Promise d'ECMAScript est plus fiable, mais n√©cessite une adaptation </h4><br><p>  Contrairement aux coroutines continues, dans ce mod√®le, les morceaux de code sont secr√®tement divis√©s en blocs non interruptibles con√ßus comme des fonctions anonymes.  En C ++, cela ne convient pas enti√®rement en raison des particularit√©s de la gestion de la m√©moire, un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcPromise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolved(value_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; &amp;&amp;cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ somehow_call_later(cb); } Value value_; }; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([&amp;](SomeObject::value &amp;&amp;val){ return Promise([&amp;](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback(resolve, val); }); }); }</span></span></code> </pre> <br><p>  Premi√®rement, <code>some_obj</code> sera d√©truit en quittant <code>example()</code> et avant d'appeler des fonctions lambda. </p><br><p>  Deuxi√®mement, les fonctions lambda avec des variables ou des r√©f√©rences de capture sont des objets et ajoutent secr√®tement un copier / d√©placer, ce qui peut affecter n√©gativement les performances avec un grand nombre de captures et la n√©cessit√© d'allouer de la m√©moire sur le tas pendant l'effacement de type dans la <code>std::function</code> habituelle. </p><br><p>  Troisi√®mement, l'interface <code>Promise</code> elle-m√™me a √©t√© con√ßue sur le concept de ¬´promesse¬ª du r√©sultat, plut√¥t que sur l'ex√©cution coh√©rente de la logique m√©tier. </p><br><p>  Une solution sch√©matique NON optimale pourrait ressembler √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalContext</span></span></span><span class="hljs-class"> {</span></span> SomeObject some_obj; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;LocalContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([ctx](SomeObject::Value &amp;&amp;val){ struct LocalContext2 { LocalContext2(std::shared_ptr&lt;LocalContext&gt; &amp;&amp;ctx, SomeObject::Value &amp;&amp;val) : ctx(ctx), val(val) {} std::shared_ptr&lt;LocalContext&gt; ctx; SomeObject::Value val; }; auto ctx2 = std::make_shared&lt;LocalContext2&gt;( std::move(ctx), std::forward&lt;SomeObject::Value&gt;(val) ); return Promise([ctx2](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ ctx2-&gt;ctx-&gt;some_obj.funcCallback([ctx2, resolve](){ resolve(); }, val); }); }); }</span></span></code> </pre> <br><p>  <em>Remarque: <code>std::move</code> au lieu de <code>std::shared_ptr</code> ne convient pas en raison de l'impossibilit√© de transf√©rer vers plusieurs lambdas √† la fois et de la croissance de leur taille.</em> </p><br><p>  Avec l'ajout de <code>async/await</code> les horreurs asynchrones se pr√©sentent dans un √©tat digestible: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeObject::Value val = await some_obj.func(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) ( <span class="hljs-comment"><span class="hljs-comment">// ... } // Capture "async context" return Promise([async](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback([async](){ resolve(); }, val); }); }</span></span></code> </pre> <br><h4 id="mnenie-avtora-planirovschik-soprogramm---eto-perebor">  Opinion de l'auteur: le planificateur coroutine est un buste </h4><br><p>  Certains critiques consid√®rent le manque d'un planificateur et l'utilisation "malhonn√™te" des ressources du processeur un probl√®me.  Un probl√®me plus grave est peut-√™tre la localisation des donn√©es et l'utilisation efficace du cache du processeur. </p><br><p>  Sur le premier probl√®me: la hi√©rarchisation au niveau des coroutines individuelles ressemble √† un gros frais g√©n√©raux.  Au lieu de cela, ils peuvent √™tre utilis√©s en commun pour une t√¢che unifi√©e sp√©cifique.  C'est ce que font les flux de trafic. </p><br><p>  Cela est possible en cr√©ant des instances distinctes de boucle d'√©v√©nement avec leurs propres threads ¬´de fer¬ª et en planifiant au niveau du syst√®me d'exploitation.  La deuxi√®me option consiste √† synchroniser les coroutines avec une primitive relativement primitive (Mutex, Throttle) en termes de comp√©tition et / ou de performance. </p><br><p>  La programmation asynchrone ne rend pas les ressources du processeur caoutchouteuses et n√©cessite des restrictions absolument normales sur le nombre de t√¢ches trait√©es simultan√©ment et des limites sur le temps d'ex√©cution total. </p><br><p>  La protection contre le blocage long sur une coroutine n√©cessite les m√™mes mesures que pour les rappels - pour √©viter de bloquer les appels syst√®me et les longs cycles de traitement des donn√©es. </p><br><p>  Le deuxi√®me probl√®me n√©cessite des recherches, mais au moins la coroutine s'empile et les d√©tails de la mise en ≈ìuvre de Future / Promise violent d√©j√† la localit√© des donn√©es.  Il est possible d'essayer de poursuivre l'ex√©cution de la m√™me coroutine si l'avenir compte d√©j√†.  Un certain m√©canisme est n√©cessaire pour calculer le temps d'ex√©cution ou le nombre de telles continuations afin d'emp√™cher une coroutine de capturer tout le temps du processeur.  Cela peut ne pas donner de r√©sultat, ou donner un r√©sultat tr√®s double, selon la taille du cache du processeur et le nombre de threads. </p><br><p>  Il y a aussi un troisi√®me point - de nombreuses impl√©mentations de planificateurs de coroutine leur permettent d'√™tre ex√©cut√©es sur diff√©rents c≈ìurs de processeur, ce qui au contraire ajoute des probl√®mes en raison de la synchronisation obligatoire lors de l'acc√®s aux ressources partag√©es.  Dans le cas d'un seul flux de boucle d'√©v√©nements, une telle synchronisation n'est requise qu'au niveau logique, car  Chaque bloc de rappel synchrone est garanti de fonctionner sans course avec les autres. </p><br><h4 id="mnenie-avtora-vsyo-horosho-v-meru">  L'avis de l'auteur: tout va bien avec mod√©ration </h4><br><p>  La pr√©sence de threads dans les syst√®mes d'exploitation modernes ne nie pas l'utilisation de processus individuels.  En outre, le traitement d'un grand nombre de clients dans la boucle d'√©v√©nements n'annule pas l'utilisation de threads ¬´de fer¬ª isol√©s pour d'autres besoins. </p><br><p>  Dans tous les cas, les coroutines et les diff√©rentes variantes de boucles d'√©v√©nements compliquent le processus de d√©bogage sans le soutien n√©cessaire dans les outils, et avec les variables locales sur la pile de coroutines, tout devient encore plus difficile - il n'y a pratiquement aucun moyen d'y acc√©der. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/pp/lb/2ppplbzrvm8c0yvbasdwrojknss.png" width="326" height="326"></div><br><h2 id="futoin-asyncsteps---alternativa-soprogrammam">  FutoIn AsyncSteps - une alternative aux coroutines </h2><br><p>  Nous prenons comme base le mod√®le de boucle d'√©v√©nement d√©j√† bien √©tabli et l'organisation des sch√©mas de rappel selon le type de promesse ECMAScript (JavaScript). </p><br><p>  En termes de planification d'ex√©cution, nous nous int√©ressons aux activit√©s suivantes d'Event Loop: </p><br><ol><li>  <code>Handle immediate(callack)</code> n√©cessitant une pile d'appels propre. </li><li>  Rappel diff√©r√© Traitement <code>Handle deferred(delay, callback)</code> . </li><li>  Annuler le callback <code>handle.cancel()</code> . </li></ol><br><p>  Nous obtenons donc une interface appel√©e <code>AsyncTool</code> , qui peut √™tre impl√©ment√©e de nombreuses fa√ßons, y compris en plus des d√©veloppements √©prouv√©s existants.  Il n'a aucun lien direct avec l'√©criture de la logique m√©tier, nous n'entrerons donc pas dans les d√©tails. </p><br><h3 id="derevo-shagov">  Arbre des √©tapes: </h3><br><p>  Dans le concept AsyncSteps, un arbre abstrait d'√©tapes synchrones est align√© et ex√©cut√© en approfondissant la s√©quence de cr√©ation.  Les √©tapes de chaque niveau plus profond sont d√©finies dynamiquement √† mesure qu'un tel passage est termin√©. </p><br><p>  Toutes les interactions ont lieu via une seule interface <code>AsyncSteps</code> , qui, par convention, est transmise comme premier param√®tre √† chaque √©tape.  Par convention, le nom du param√®tre est <code>asi</code> ou obsol√®te.  Cette approche vous permet de rompre presque compl√®tement le lien entre une impl√©mentation sp√©cifique et l'√©criture de la logique m√©tier dans les plugins et les biblioth√®ques. </p><br><p>  Dans les impl√©mentations canoniques, chaque √©tape re√ßoit sa propre instance d'un objet qui impl√©mente <code>AsyncSteps</code> , ce qui permet un suivi rapide des erreurs logiques lors de l'utilisation de l'interface. </p><br><p>  Exemple abstrait: </p><br><pre> <code class="hljs lua"> asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func"</span></span> ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func"</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) } ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { asi.success( <span class="hljs-string"><span class="hljs-string">"Prm"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> func( asi, str_param, int_param, array_param ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func2: "</span></span> + param ) } )</code> </pre> <br><p>  R√©sultat d'ex√©cution: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: MyError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: NewError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">2</span></span>: Prm</code> </pre> <br><p>  En synchronisation, cela ressemblerait √† ceci: </p><br><pre> <code class="hljs coffeescript"> str_res, int_res, array_res, bool_res <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( error strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { str_res = <span class="hljs-string"><span class="hljs-string">"Prm"</span></span> int_res = <span class="hljs-number"><span class="hljs-number">123</span></span> array_res = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] bool_res = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { re-<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> } } { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 2: "</span></span> + str_res ) }</code> </pre> <br><p>  Le mim√©tisme maximal du code synchrone traditionnel est imm√©diatement visible, ce qui devrait aider √† la lisibilit√©. </p><br><p>  Du point de vue de la logique m√©tier, un ensemble <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">important d'exigences</a> cro√Æt avec le temps, mais nous pouvons le diviser en parties faciles √† comprendre.  D√©crit ci-dessous, le r√©sultat d'un fonctionnement en pratique de quatre ans. </p><br><h3 id="bazovye-api-vremeni-vypolneniya">  API Core Runtime: </h3><br><ol><li>  <code>add(func[, onerror])</code> - imitation de <code>try-catch</code> . </li><li>  <code>success([args...])</code> - une indication explicite de r√©ussite: <br><ul><li>  implicite par d√©faut </li><li>  peut passer les r√©sultats √† l'√©tape suivante. </li></ul></li><li>  <code>error(code[, reason)</code> - interruption de l'ex√©cution avec une erreur: <br><ul><li>  <code>code</code> - a un type de cha√Æne pour mieux s'int√©grer aux protocoles r√©seau dans l'architecture de microservice, </li><li>  <code>reason</code> - une explication arbitraire pour une personne. </li></ul></li><li>  <code>state()</code> - un analogue de Thread Local Storage.  Cl√©s associatives pr√©d√©finies: <br><ul><li>  <code>error_info</code> - explication de la derni√®re erreur pour une personne, </li><li>  <code>last_exception</code> - pointeur vers l'objet de la derni√®re exception, </li><li>  <code>async_stack</code> - une pile d'appels asynchrones dans la <code>async_stack</code> o√π la technologie le permet, </li><li>  le reste est d√©fini par l'utilisateur. </li></ul></li></ol><br><p>  L'exemple pr√©c√©dent est d√©j√† avec du vrai code C ++ et quelques fonctionnalit√©s suppl√©mentaires: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/iasyncsteps.hpp&gt; using namespace futoin; void some_api(IAsyncSteps&amp; asi) { asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 0 func 1" &lt;&lt; std::endl; asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 1 func 1" &lt;&lt; std::endl; asi.error("MyError"); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 1 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; asi.error("NewError", "Human-readable description"); } ); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 0 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; if (code == "NewError") { // Human-readable error info assert(asi.state().error_info == "Human-readable description"); // Last exception thrown is also available in state std::exception_ptr e = asi.state().last_exception; // NOTE: smart conversion of "const char*" asi.success("Prm", 123, std::vector&lt;int&gt;({1, 2, 3}, true)); } } ); asi.add( [](IAsyncSteps&amp; asi, const futoin::string&amp; str_res, int int_res, std::vector&lt;int&gt;&amp;&amp; arr_res) { std::cout &lt;&lt; "Level 0 func 2: " &lt;&lt; str_res &lt;&lt; std::endl; } ); }</span></span></span></span></code> </pre> <br><h3 id="api-dlya-sozdaniya-ciklov">  API pour cr√©er des boucles: </h3><br><ol><li>  <code>loop( func, [, label] )</code> - √©tape avec un corps infiniment r√©p√©table. </li><li>  <code>forEach( map|list, func [, label] )</code> - √©tape-it√©ration de l'objet de collection. </li><li>  <code>repeat( count, func [, label] )</code> - √©tape-it√©ration nombre de fois sp√©cifi√©. </li><li>  <code>break( [label] )</code> est un analogue de l'interruption de boucle traditionnelle. </li><li>  <code>continue( [label] )</code> est un analogue de la continuation de boucle traditionnelle avec une nouvelle it√©ration. </li></ol><br><p>  <em>La sp√©cification propose des noms alternatifs <code>breakLoop</code> , <code>continueLoop</code> et autres en cas de conflit avec des mots r√©serv√©s.</em> </p><br><p>  Exemple C ++: </p><br><pre> <code class="cpp hljs"> asi.loop([](IAsyncSteps&amp; asi) { <span class="hljs-comment"><span class="hljs-comment">// infinite loop asi.breakLoop(); }); asi.repeat(10, [](IAsyncSteps&amp; asi, size_t i) { // range loop from i=0 till i=9 (inclusive) asi.continueLoop(); }); asi.forEach( std::vector&lt;int&gt;{1, 2, 3}, [](IAsyncSteps&amp; asi, size_t i, int v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::list&lt;futoin::string&gt;{"1", "2", "3"}, [](IAsyncSteps&amp; asi, size_t i, const futoin::string&amp; v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::map&lt;futoin::string, futoin::string&gt;(), [](IAsyncSteps&amp; asi, const futoin::string&amp; key, const futoin::string&amp; v) { // Iteration of map-like objects }); std::map&lt;std::string, futoin::string&gt; non_const_map; asi.forEach( non_const_map, [](IAsyncSteps&amp; asi, const std::string&amp; key, futoin::string&amp; v) { // Iteration of map-like objects, note the value reference type });</span></span></code> </pre> <br><h3 id="api-integracii-s-vneshnimi-sobytiyami">  API pour l'int√©gration avec des √©v√©nements externes: </h3><br><ol><li>  <code>setTimeout( timeout_ms )</code> - renvoie une erreur de <code>Timeout</code> apr√®s un timeout si l'√©tape et sa sous-arborescence n'ont pas termin√© leur ex√©cution. </li><li>  <code>setCancel( handler )</code> - d√©finit le gestionnaire d'annulation, qui est appel√© lorsque le thread est compl√®tement annul√© et lorsque la pile d'√©tapes asynchrones est d√©velopp√©e pendant le traitement des erreurs. </li><li>  <code>waitExternal()</code> - une simple attente pour un √©v√©nement externe. <br><ul><li>  <em>Remarque: Il est s√ªr de l'utiliser uniquement dans les technologies avec un garbage collector.</em> </li></ul></li></ol><br><p>  Un appel √† l'une de ces fonctions rend un appel explicite √† <code>success()</code> n√©cessaire. </p><br><p>  Exemple C ++: </p><br><pre> <code class="cpp hljs"> asi.add([](IAsyncSteps&amp; asi) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = schedule_external_callback([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asi.error(<span class="hljs-string"><span class="hljs-string">"ExternalError"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// pass } } else { asi.success(); } }); asi.setCancel([=](IAsyncSteps&amp; asi) { external_cancel(handle); }); }); asi.add( [](IAsyncSteps&amp; asi) { // Raises Timeout error after specified period asi.setTimeout(std::chrono::seconds{10}); asi.loop([](IAsyncSteps&amp; asi) { // infinite loop }); }, [](IAsyncSteps&amp; asi, ErrorCode code) { if (code == futoin::errors::Timeout) { asi(); } });</span></span></code> </pre> <br><p>  Exemple ECMAScript: </p><br><pre> <code class="javascript hljs">asi.add( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">asi</span></span></span><span class="hljs-function">) =&gt;</span></span> { asi.waitExternal(); <span class="hljs-comment"><span class="hljs-comment">// disable implicit success() some_obj.read( (err, data) =&gt; { if (!asi.state) { // ignore as AsyncSteps execution got canceled } else if (err) { try { asi.error( 'IOError', err ); } catch (_) { // ignore error thrown as there are no // AsyncSteps frames on stack. } } else { asi.success( data ); } } ); } );</span></span></code> </pre> <br><h3 id="api-integracii-s-futurepromise">  API d'int√©gration Future / Promise: </h3><br><ol><li>  <code>await(promise_future[, on_error])</code> - en attendant Future / Promise comme √©tape. </li><li>  <code>promise()</code> - transforme l'ensemble du flux d'ex√©cution en Future / Promise, utilis√© au lieu de <code>execute()</code> . </li></ol><br><p>  Exemple C ++: </p><br><pre> <code class="hljs pgsql"> [](IAsyncSteps&amp; asi) { // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AsyncSteps instances // <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> hard dependency <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> implementation. auto new_steps = asi.newInstance(); new_steps-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([](IAsyncSteps&amp; asi) {}); // Can be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AsyncSteps event <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> // new_steps.promise().wait(); // <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> // new_steps.promise&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> standard std::future asi.await(new_steps-&gt;promise()); // Ensure instance lifetime asi.state()["some_obj"] = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(new_steps); };</code> </pre> <br><h3 id="api-kontrolya-potoka-vypolneniya-biznes-logiki">  API Business Logic Flow Control: </h3><br><ol><li>  <code>AsyncSteps(AsyncTool&amp;)</code> est un constructeur qui lie un thread d'ex√©cution √† une boucle d'√©v√©nement sp√©cifique. </li><li>  <code>execute()</code> - d√©marre le thread d'ex√©cution. </li><li>  <code>cancel()</code> - annule le thread d'ex√©cution. </li></ol><br><p>  Une impl√©mentation d'interface sp√©cifique est d√©j√† requise ici. </p><br><p>  Exemple C ++: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/asyncsteps.hpp&gt; #include &lt;futoin/ri/asynctool.hpp&gt; void example() { futoin::ri::AsyncTool at; futoin::ri::AsyncSteps asi{at}; asi.loop([&amp;](futoin::IAsyncSteps &amp;asi){ // Some infinite loop logic }); asi.execute(); std::this_thread::sleep_for(std::chrono::seconds{10}); asi.cancel(); // called in d-tor by fact }</span></span></span></span></code> </pre> <br><h3 id="prochie-api">  autres API: </h3><br><ol><li>  <code>newInstance()</code> - vous permet de cr√©er un nouveau thread d'ex√©cution sans d√©pendance directe sur l'impl√©mentation. </li><li>  <code>sync(object, func, onerror)</code> - la m√™me chose, mais avec une synchronisation relative √† un objet qui impl√©mente l'interface correspondante. </li><li>  <code>parallel([on_error])</code> - sp√©cial <code>add()</code> , dont les sous-√©tapes sont des flux AsyncSteps distincts: <br><ul><li>  tous les threads ont un <code>state()</code> commun <code>state()</code> , </li><li>  le thread parent continue son ex√©cution √† la fin de tous les enfants </li><li>  une erreur non d√©tect√©e dans un enfant annule imm√©diatement tous les autres threads enfants. </li></ul></li></ol><br><p>  Exemples C ++: </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/mutex.hpp&gt; using namespace futoin; ri::Mutex mtx_a; void sync_example(IAsyncSteps&amp; asi) { asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { // synchronized section asi.add([](IAsyncSteps&amp; asi) { // inner step in the section // This synchronization is NOOP for already // acquired Mutex. asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { }); }); }); } void parallel_example(IAsyncSteps&amp; asi) { using OrderVector = std::vector&lt;int&gt;; asi.state("order", OrderVector{}); auto&amp; p = asi.parallel([](IAsyncSteps&amp; asi, ErrorCode) { // Overall error handler asi.success(); }); p.add([](IAsyncSteps&amp; asi) { // regular flow asi.state&lt;OrderVector&gt;("order").push_back(1); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(4); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(2); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(5); asi.error("SomeError"); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(3); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(6); }); }); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order"); // 1, 2, 3, 4, 5 }); };</span></span></span></span></code> </pre> <br><h3 id="standartnye-primitivy-dlya-sinhronizacii">  Primitives standard pour la synchronisation </h3><br><ol><li>  <code>Mutex</code> - restreint l'ex√©cution simultan√©e de <code>N</code> threads avec une file d'attente dans <code>Q</code> , par d√©faut <code>N=1, Q=unlimited</code> . </li><li>  <code>Throttle</code> - limite le nombre d'entr√©es <code>N</code> dans la p√©riode <code>P</code> avec une file d'attente dans <code>Q</code> , par d√©faut <code>N=1, P=1s, Q=0</code> . </li><li>  <code>Limiter</code> est une combinaison de <code>Mutex</code> et <code>Throttle</code> , qui est g√©n√©ralement utilis√©e √† l'entr√©e du traitement des requ√™tes externes et lors de l'appel de syst√®mes externes dans le but d'un fonctionnement stable sous charge. </li></ol><br><p>  En cas de <code>DefenseRejected</code> limites de file d'attente, une erreur <code>DefenseRejected</code> est <code>DefenseRejected</code> , dont la signification ressort clairement de la description du <code>Limiter</code> . </p><br><h3 id="klyuchevye-preimuschestva">  Avantages cl√©s </h3><br><p>  Le concept d'AsyncSteps n'√©tait pas une fin en soi, mais est n√© du besoin d'une ex√©cution asynchrone plus contr√¥l√©e des programmes en termes de d√©lai, d'annulation et de connectivit√© globale des rappels individuels.  Aucune des solutions universelles √† l'√©poque et n'offre d√©sormais les m√™mes fonctionnalit√©s.  Par cons√©quent: </p><br><p> <strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> FTN12</a>   </strong> ‚Äî           . </p><br><p> <strong>  <code>setCancel()</code></strong> ‚Äî                    .       ,     .   RAII  <code>atexit()</code>   . </p><br><p> <strong>   <code>cancel()</code></strong> ‚Äî     ,         .   <code>SIGTERM</code>  <code>pthread_cancel()</code> ,       . </p><br><p> <strong>   <code>setTimeout()</code></strong> ‚Äî                 .    ,    "Timeout". </p><br><p> <strong>     </strong> ‚Äî  FutoIn AsyncSteps             . </p><br><p> <strong>      </strong> ‚Äî          ABI     ,    .    Embedded     MMU. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8x/wv/yj8xwvibm7tjsj30qhojwbleige.jpeg"></div><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em> </em></a> </p><br><h2 id="k-cifram">   </h2><br><p>    Intel Xeon E3-1245v2/DDR1333  Debian Stretch    . </p><br><p>   : </p><br><ol><li> Boost.Fiber  <code>protected_fixedsize_stack</code> . </li><li> Boost.Fiber  <code>pooled_fixedsize_stack</code>     . </li><li> FutoIn AsyncSteps   . </li><li> FutoIn AsyncSteps      ( <code>FUTOIN_USE_MEMPOOL=false</code> ). <br><ul><li>      <code>futoin::IMemPool</code> . </li></ul></li><li> FutoIn NitroSteps&lt;&gt; ‚Äî           . <br><ul><li>         . </li></ul></li></ol><br><p>    Boost.Fiber    : </p><br><ol><li>     1 . . </li><li>       30 .   1 . . <br><ul><li>   30 .     <code>mmap()/mprotect()</code>  <code>boost::fiber::protected_fixedsize_stack</code> . </li><li>          . </li></ul></li><li>   30 .   10 .     . <br><ul><li>    ""          . </li></ul></li></ol><br><p>      "" , ..     ,       .        .   . </p><br><p>    GCC 6.3.0.   lang  tcmalloc  ,     . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitLab</a> . </p><br><h3 id="1-posledovatelnoe-sozdanie"> 1.   </h3><br><table><thead><tr><th>  La technologie </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 4.8s </td><td> 208333.333Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 0.23s </td><td> 4347826.086Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>0.21s</strong> </td><td> <strong>4761904.761Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 0.31s </td><td> 3225806.451Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 0.255s </td><td> 3921568.627Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/ur/y6/qmury65-mbkth_om8smkfi7vamq.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>     Boost.Fiber -      ,     <code>pooled_fixedsize_stack</code>   ,    AsyncSteps. </p><br><h3 id="2-parallelnoe-sozdanie-i-ispolnenie"> 2.     </h3><br><table><thead><tr><th>  La technologie </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 6.31s </td><td> 158478.605Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 1.558s </td><td> 641848.523Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1.13s</strong> </td><td> <strong>884955.752Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 1.353s </td><td> 739098.300Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 1.43s </td><td> 699300.699Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0s/gz/lu/0sgzlur2xsrlf-wo4mrcynvzhxi.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>    ,          .    ,        ‚Äî            . </p><br><h3 id="3-parallelnye-cikly"> 3.   </h3><br><table><thead><tr><th>  La technologie </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 5.096s </td><td> 1962323.390Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 5.077s </td><td> 1969667.126Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> 5.361s </td><td> 1865323.633Hz </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 8.288s </td><td> 1206563.706Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> <strong>3.68s</strong> </td><td> <strong>2717391.304Hz</strong> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/c1/17/pbc117djqds0d4twh5fzcklsmfc.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>   ,        Boost.Fiber      AsyncSteps,    NitroSteps. </p><br><h3 id="ispolzovanie-pamyati-po-rss">   ( RSS) </h3><br><table><thead><tr><th>  La technologie </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 124M </td></tr><tr><td> Boost.Fiber pooled </td><td> 505M </td></tr><tr><td> FutoIn AsyncSteps </td><td> 124M </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> <strong>84M</strong> </td></tr><tr><td> FutoIn NitroSteps </td><td> 115M </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/w0/6n/olw06nef5wj3ah1lo9u-pby9sfg.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>  , Boost.Fiber  . </p><br><h3 id="bonus-testy-na-nodejs"> :   Node.js </h3><br><p>      -  <code>Promise</code> : +    10 . .   10 .          JIT  <code>NODE_ENV=production</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>@futoin/optihelp</code></a> . </p><br><p>      <a href="">GitHub</a>  <a href="">GitLab</a> .   Node.js v8.12.0  v10.11.0,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FutoIn CID</a> . </p><br><table><thead><tr><th> Tech </th><th> Simple </th><th> Loop </th></tr></thead><tbody><tr><td> <strong>Node.js v10</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1342899.520Hz</strong> </td><td> 587.777Hz </td></tr><tr><td> async/await </td><td> 524983.234Hz </td><td> <strong>630.863Hz</strong> </td></tr><tr><td> <strong>Node.js v8</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>682420.735Hz</strong> </td><td> <strong>588.336Hz</strong> </td></tr><tr><td> async/await </td><td> 365050.395Hz </td><td> 400.575Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x7/-n/b5/x7-nb5v9dfkwn1lttyg67w2b_tk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/yj/9p/ghyj9pczw0smbfksq-aad_tltay.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>   <code>async/await</code> ? ,   V8  Node.js v10       . </p><br><p>  ,   Promise  <code>async/await</code> <strong></strong> Node.js Event Loop.          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ),   FutoIn AsyncSteps   . </p><br><p> <em>   AsyncSteps  Node.js Event Loop      <code>async/await</code>  -  Node.js v10.</em> </p><br><p> <em>,      ++   ‚Äî    .  ,    Node.js    10 .</em> </p><br><h3 id="vyvody">  Conclusions </h3><br><p>   C++, FutoIn AsyncSteps  Boost.Fiber       ,     Boost.Fiber         <code>mmap()/mprotect</code> . </p><br><p>       ,      -      ,   .     . </p><br><p> FutoIn AsyncSteps  JavaScript  <code>async/await</code>       Node.js v10. </p><br><p>   ,       -,       .        . </p><br><p>   -                        ""  .     ‚Äî   API. </p><br><hr><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> ,  FutoIn AsyncSteps ,          "" <code>async/await</code> . ,         .      <code>Promise</code>  ECMAScript, AsyncSteps    ""           . </p><br><p>               .        AsyncSteps  NitroSteps   . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,    - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p>       Java/JVM         ‚Äî    .    . </p><br><p>      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitLab</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424311/">https://habr.com/ru/post/fr424311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424297/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 9: S√©curit√© des applications Web, partie 3</a></li>
<li><a href="../fr424301/index.html">Algorithme de filtre d'image de r√©seau neuronal adaptatif</a></li>
<li><a href="../fr424305/index.html">RIB pour architecture mobile multiplateforme Uber</a></li>
<li><a href="../fr424307/index.html">GitLab 11.3 publi√© avec le r√©f√©rentiel Maven et les environnements s√©curis√©s</a></li>
<li><a href="../fr424309/index.html">DevCore: partie logicielle du projet DevBoy</a></li>
<li><a href="../fr424313/index.html">EveryLang est un programme qui peut faire presque tout</a></li>
<li><a href="../fr424315/index.html">Un nouveau cycle de substitution des importations. O√π courir et que faire?</a></li>
<li><a href="../fr424319/index.html">La structure de la boutique en ligne. 2e partie</a></li>
<li><a href="../fr424321/index.html">Mettre NetFlow bon march√© et en col√®re</a></li>
<li><a href="../fr424323/index.html">Un exemple de travail avec la m√©thode ICE du chef de produit de Google et Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>