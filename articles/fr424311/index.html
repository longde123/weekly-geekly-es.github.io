<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏾 🙅🏽 💼 Logique d'entreprise asynchrone de nos jours ✋🏻 🕴🏿 🥢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En bref: 


- La preuve est déjà implémentée en C ++ , JS et PHP , adaptée à Java . 
- Plus rapide que Coroutine et Promise, plus de fonctionnalités. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logique d'entreprise asynchrone de nos jours</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424311/"><p>  En bref: </p><br><blockquote><ul><li>  La preuve est déjà implémentée en <strong>C ++</strong> , <strong>JS</strong> et <strong>PHP</strong> , adaptée à <strong>Java</strong> . </li><li> <strong>Plus rapide</strong> que Coroutine et Promise, plus de fonctionnalités. </li><li>  Il ne nécessite pas de pile logicielle distincte. </li><li>  Se lie d'amitié avec tous les outils de sécurité et de débogage. </li><li>  Il fonctionne sur n'importe quelle architecture et ne nécessite pas de drapeaux de compilation spéciaux. </li></ul><br></blockquote><a name="habracut"></a><br><hr><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Regarder en arrière</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FutoIn AsyncSteps - une alternative aux coroutines</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aux chiffres</a> </li></ul><br><h2 id="vzglyad-nazad">  Regarder en arrière </h2><br><p>  À l'aube de l'ordinateur, il y avait un seul flux de contrôle avec blocage sur entrée-sortie.  Puis des interruptions de fer y ont été ajoutées.  Vous pouvez désormais utiliser efficacement des appareils lents et imprévisibles. </p><br><p>  Avec la croissance des capacités de fer et sa faible disponibilité, il est devenu nécessaire d'effectuer plusieurs tâches simultanément, ce qui a fourni un support matériel.  Il y avait donc des processus isolés avec des interruptions abstraites du fer sous forme de signaux. </p><br><p>  L'étape évolutive suivante a été le multithreading, qui a été mis en œuvre sur la base des mêmes processus, mais avec un accès partagé à la mémoire et à d'autres ressources.  Cette approche a ses limites et ses frais généraux importants pour passer à un système d'exploitation sécurisé. </p><br><p>  Pour la communication entre processus et même différentes machines, l'abstraction Promise / Future a été proposée il y a plus de 40 ans. </p><br><p>  Les interfaces utilisateur et le problème maintenant ridicule du client 10K ont conduit à l'apogée des approches Event Loop, Reactor et Proactor, qui sont plus orientées événements qu'une logique métier claire et cohérente. </p><br><p>  Enfin, nous sommes arrivés à la coroutine moderne (coroutine), qui est essentiellement une émulation de flux au-dessus des abstractions décrites ci-dessus avec les limitations techniques correspondantes et le transfert déterministe de contrôle. </p><br><p>  Pour transmettre des événements, des résultats et des exceptions, ils sont tous revenus au même concept de promesse / avenir.  Certains bureaux ont décidé de nommer un peu différemment "Tâche". </p><br><p> En fin de compte, ils ont tout caché dans un beau paquet <code>async/await</code> , qui nécessite le support du compilateur ou du traducteur selon la technologie. </p><br><h3 id="problemy-s-tekuschiy-situaciy-asinhronnoy-biznes-logiki">  Problèmes avec les situations de logique métier asynchrones actuelles </h3><br><p>  Considérez uniquement les coroutines et Promise, décorées d’ <code>async/await</code>  l'existence de problèmes dans les anciennes approches confirme le processus d'évolution lui-même. </p><br><p>  Ces deux termes ne sont pas identiques.  Par exemple, dans ECMAScript, il n'y a pas de coroutines, mais il existe un soulagement syntaxique pour l'utilisation de <code>Promise</code> , qui à son tour organise uniquement le travail avec l'enfer de rappel.  En fait, les moteurs de script comme V8 vont plus loin et font des optimisations spéciales pour les fonctions et les appels <code>async/await</code> purs. </p><br><p>  Les experts <code>co_async/co_await</code> qui n'est pas tombé dans C ++ 17 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici sur la ressource</a> , mais la pression des coroutines géantes du logiciel peut apparaître dans la norme exactement sous leur forme.  En attendant, la solution traditionnellement reconnue est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Context</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Fiber</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Coroutine2</a> . </p><br><p>  En Java, il n'y a toujours pas d' <code>async/await</code> au niveau du langage, mais il existe des solutions comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EA Async</a> , qui, comme Boost.Context, doivent être personnalisées pour chaque version de la JVM et de l'octet de code. </p><br><p>  Go a ses propres coroutines, mais si vous regardez attentivement les articles et les rapports de bogues des projets ouverts, il s'avère qu'ici tout n'est pas si fluide.  Peut-être que perdre l'interface coroutine en tant qu'entité gérée n'est pas une bonne idée. </p><br><h4 id="mnenie-avtora-soprogrammy-na-golom-zheleze-opasny">  Opinion de l'auteur: les coroutines en métal nu sont dangereuses </h4><br><p>  Personnellement, l'auteur a peu contre les coroutines dans les langages dynamiques, mais il se méfie extrêmement de tout flirt avec la pile au niveau du code machine. </p><br><p>  Quelques points: </p><br><ol><li>  Pile requise: <br><ul><li>  la pile sur le tas présente un certain nombre d'inconvénients: problèmes de détermination rapide du débordement, dommages causés par les voisins et autres problèmes de fiabilité / sécurité, </li><li>  une pile sécurisée nécessite au moins une page de mémoire physique, une page conditionnelle et une surcharge supplémentaire pour chaque appel aux fonctions <code>async</code> : 4 + Ko (minimum) + augmentation des limites du système, </li><li>  en fin de compte, il se peut qu'une partie importante de la mémoire allouée aux piles ne soit pas utilisée pendant le temps d'arrêt de la coroutine. </li></ul></li><li>  Il est nécessaire de mettre en œuvre une logique complexe pour enregistrer, restaurer et supprimer l'état de la coroutine: <br><ul><li>  pour chaque cas d'architecture de processeur (même les modèles) et d'interface binaire (ABI): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , </li><li>  des fonctionnalités d'architecture nouvelles ou optionnelles introduisent des problèmes potentiellement latents (par exemple, Intel TSX, co-processeurs ARM ou MIPS), </li><li>  d'autres problèmes potentiels dus à la documentation fermée des systèmes propriétaires (la documentation Boost s'y réfère). </li></ul></li><li>  Problèmes potentiels avec les outils d'analyse dynamique et avec la sécurité en général: <br><ul><li>  par exemple, l'intégration avec Valgrind est requise en raison des mêmes piles de sauts, </li><li>  il est difficile de parler pour les antivirus, mais probablement ils n'aiment pas vraiment ça sur l'exemple des problèmes avec la JVM dans le passé, </li><li>  Je suis sûr que de nouveaux types d'attaques apparaîtront et que les vulnérabilités associées à la mise en œuvre des coroutines seront révélées. </li></ul></li></ol><br><h4 id="mnenie-avtora-generatory-i-yield-principialnoe-zlo">  Opinion de l'auteur: générateurs et <code>yield</code> mal fondamental </h4><br><p>  Ce thème apparemment tiers est directement lié au concept de coroutines et à la propriété "continue". </p><br><p>  En bref, un itérateur complet doit exister pour toute collection.  Pourquoi créer un problème d'itérateur-générateur recadré n'est pas clair.  Par exemple, un cas avec <code>range()</code> en Python est plus une démonstration exclusive qu'une excuse pour une complication technique. </p><br><p>  Si le cas est un générateur infini, alors la logique de sa mise en œuvre est élémentaire.  Pourquoi créer des difficultés techniques supplémentaires afin de pousser un cycle continu sans fin. </p><br><p>  La seule justification raisonnable qui a émergé plus tard que les partisans des coroutines donnent est toutes sortes d'analyseurs de flux avec un contrôle inversé.  En fait, il s'agit d'un cas spécialisé étroit pour la résolution de problèmes uniques au niveau de la bibliothèque, et non de la logique métier des applications.  En même temps, il existe une solution élégante, simple et plus descriptive à travers les machines à états finis.  Le domaine de ces problèmes techniques est beaucoup plus petit que le domaine de la logique commerciale courante. </p><br><p>  En fait, le problème à résoudre est obtenu d'un doigt et nécessite des efforts relativement sérieux pour la mise en œuvre initiale et le support à long terme.  À tel point que certains projets peuvent introduire une interdiction de l'utilisation des coroutines au niveau du code machine à l'instar de l'interdiction de <code>goto</code> ou de l'utilisation de l'allocation dynamique de mémoire dans des industries individuelles. </p><br><h4 id="mnenie-avtora-model-asyncawait-na-promise-iz-ecmascript-bolee-nadyozhna-no-trebuet-adaptacii">  Opinion des auteurs: Le modèle <code>async/await</code> Promise d'ECMAScript est plus fiable, mais nécessite une adaptation </h4><br><p>  Contrairement aux coroutines continues, dans ce modèle, les morceaux de code sont secrètement divisés en blocs non interruptibles conçus comme des fonctions anonymes.  En C ++, cela ne convient pas entièrement en raison des particularités de la gestion de la mémoire, un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcPromise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolved(value_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; &amp;&amp;cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ somehow_call_later(cb); } Value value_; }; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([&amp;](SomeObject::value &amp;&amp;val){ return Promise([&amp;](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback(resolve, val); }); }); }</span></span></code> </pre> <br><p>  Premièrement, <code>some_obj</code> sera détruit en quittant <code>example()</code> et avant d'appeler des fonctions lambda. </p><br><p>  Deuxièmement, les fonctions lambda avec des variables ou des références de capture sont des objets et ajoutent secrètement un copier / déplacer, ce qui peut affecter négativement les performances avec un grand nombre de captures et la nécessité d'allouer de la mémoire sur le tas pendant l'effacement de type dans la <code>std::function</code> habituelle. </p><br><p>  Troisièmement, l'interface <code>Promise</code> elle-même a été conçue sur le concept de «promesse» du résultat, plutôt que sur l'exécution cohérente de la logique métier. </p><br><p>  Une solution schématique NON optimale pourrait ressembler à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalContext</span></span></span><span class="hljs-class"> {</span></span> SomeObject some_obj; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;LocalContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([ctx](SomeObject::Value &amp;&amp;val){ struct LocalContext2 { LocalContext2(std::shared_ptr&lt;LocalContext&gt; &amp;&amp;ctx, SomeObject::Value &amp;&amp;val) : ctx(ctx), val(val) {} std::shared_ptr&lt;LocalContext&gt; ctx; SomeObject::Value val; }; auto ctx2 = std::make_shared&lt;LocalContext2&gt;( std::move(ctx), std::forward&lt;SomeObject::Value&gt;(val) ); return Promise([ctx2](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ ctx2-&gt;ctx-&gt;some_obj.funcCallback([ctx2, resolve](){ resolve(); }, val); }); }); }</span></span></code> </pre> <br><p>  <em>Remarque: <code>std::move</code> au lieu de <code>std::shared_ptr</code> ne convient pas en raison de l'impossibilité de transférer vers plusieurs lambdas à la fois et de la croissance de leur taille.</em> </p><br><p>  Avec l'ajout de <code>async/await</code> les horreurs asynchrones se présentent dans un état digestible: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeObject::Value val = await some_obj.func(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) ( <span class="hljs-comment"><span class="hljs-comment">// ... } // Capture "async context" return Promise([async](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback([async](){ resolve(); }, val); }); }</span></span></code> </pre> <br><h4 id="mnenie-avtora-planirovschik-soprogramm---eto-perebor">  Opinion de l'auteur: le planificateur coroutine est un buste </h4><br><p>  Certains critiques considèrent le manque d'un planificateur et l'utilisation "malhonnête" des ressources du processeur un problème.  Un problème plus grave est peut-être la localisation des données et l'utilisation efficace du cache du processeur. </p><br><p>  Sur le premier problème: la hiérarchisation au niveau des coroutines individuelles ressemble à un gros frais généraux.  Au lieu de cela, ils peuvent être utilisés en commun pour une tâche unifiée spécifique.  C'est ce que font les flux de trafic. </p><br><p>  Cela est possible en créant des instances distinctes de boucle d'événement avec leurs propres threads «de fer» et en planifiant au niveau du système d'exploitation.  La deuxième option consiste à synchroniser les coroutines avec une primitive relativement primitive (Mutex, Throttle) en termes de compétition et / ou de performance. </p><br><p>  La programmation asynchrone ne rend pas les ressources du processeur caoutchouteuses et nécessite des restrictions absolument normales sur le nombre de tâches traitées simultanément et des limites sur le temps d'exécution total. </p><br><p>  La protection contre le blocage long sur une coroutine nécessite les mêmes mesures que pour les rappels - pour éviter de bloquer les appels système et les longs cycles de traitement des données. </p><br><p>  Le deuxième problème nécessite des recherches, mais au moins la coroutine s'empile et les détails de la mise en œuvre de Future / Promise violent déjà la localité des données.  Il est possible d'essayer de poursuivre l'exécution de la même coroutine si l'avenir compte déjà.  Un certain mécanisme est nécessaire pour calculer le temps d'exécution ou le nombre de telles continuations afin d'empêcher une coroutine de capturer tout le temps du processeur.  Cela peut ne pas donner de résultat, ou donner un résultat très double, selon la taille du cache du processeur et le nombre de threads. </p><br><p>  Il y a aussi un troisième point - de nombreuses implémentations de planificateurs de coroutine leur permettent d'être exécutées sur différents cœurs de processeur, ce qui au contraire ajoute des problèmes en raison de la synchronisation obligatoire lors de l'accès aux ressources partagées.  Dans le cas d'un seul flux de boucle d'événements, une telle synchronisation n'est requise qu'au niveau logique, car  Chaque bloc de rappel synchrone est garanti de fonctionner sans course avec les autres. </p><br><h4 id="mnenie-avtora-vsyo-horosho-v-meru">  L'avis de l'auteur: tout va bien avec modération </h4><br><p>  La présence de threads dans les systèmes d'exploitation modernes ne nie pas l'utilisation de processus individuels.  En outre, le traitement d'un grand nombre de clients dans la boucle d'événements n'annule pas l'utilisation de threads «de fer» isolés pour d'autres besoins. </p><br><p>  Dans tous les cas, les coroutines et les différentes variantes de boucles d'événements compliquent le processus de débogage sans le soutien nécessaire dans les outils, et avec les variables locales sur la pile de coroutines, tout devient encore plus difficile - il n'y a pratiquement aucun moyen d'y accéder. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/pp/lb/2ppplbzrvm8c0yvbasdwrojknss.png" width="326" height="326"></div><br><h2 id="futoin-asyncsteps---alternativa-soprogrammam">  FutoIn AsyncSteps - une alternative aux coroutines </h2><br><p>  Nous prenons comme base le modèle de boucle d'événement déjà bien établi et l'organisation des schémas de rappel selon le type de promesse ECMAScript (JavaScript). </p><br><p>  En termes de planification d'exécution, nous nous intéressons aux activités suivantes d'Event Loop: </p><br><ol><li>  <code>Handle immediate(callack)</code> nécessitant une pile d'appels propre. </li><li>  Rappel différé Traitement <code>Handle deferred(delay, callback)</code> . </li><li>  Annuler le callback <code>handle.cancel()</code> . </li></ol><br><p>  Nous obtenons donc une interface appelée <code>AsyncTool</code> , qui peut être implémentée de nombreuses façons, y compris en plus des développements éprouvés existants.  Il n'a aucun lien direct avec l'écriture de la logique métier, nous n'entrerons donc pas dans les détails. </p><br><h3 id="derevo-shagov">  Arbre des étapes: </h3><br><p>  Dans le concept AsyncSteps, un arbre abstrait d'étapes synchrones est aligné et exécuté en approfondissant la séquence de création.  Les étapes de chaque niveau plus profond sont définies dynamiquement à mesure qu'un tel passage est terminé. </p><br><p>  Toutes les interactions ont lieu via une seule interface <code>AsyncSteps</code> , qui, par convention, est transmise comme premier paramètre à chaque étape.  Par convention, le nom du paramètre est <code>asi</code> ou obsolète.  Cette approche vous permet de rompre presque complètement le lien entre une implémentation spécifique et l'écriture de la logique métier dans les plugins et les bibliothèques. </p><br><p>  Dans les implémentations canoniques, chaque étape reçoit sa propre instance d'un objet qui implémente <code>AsyncSteps</code> , ce qui permet un suivi rapide des erreurs logiques lors de l'utilisation de l'interface. </p><br><p>  Exemple abstrait: </p><br><pre> <code class="hljs lua"> asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func"</span></span> ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func"</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) } ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { asi.success( <span class="hljs-string"><span class="hljs-string">"Prm"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> func( asi, str_param, int_param, array_param ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func2: "</span></span> + param ) } )</code> </pre> <br><p>  Résultat d'exécution: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: MyError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: NewError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">2</span></span>: Prm</code> </pre> <br><p>  En synchronisation, cela ressemblerait à ceci: </p><br><pre> <code class="hljs coffeescript"> str_res, int_res, array_res, bool_res <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( error strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { str_res = <span class="hljs-string"><span class="hljs-string">"Prm"</span></span> int_res = <span class="hljs-number"><span class="hljs-number">123</span></span> array_res = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] bool_res = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { re-<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> } } { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 2: "</span></span> + str_res ) }</code> </pre> <br><p>  Le mimétisme maximal du code synchrone traditionnel est immédiatement visible, ce qui devrait aider à la lisibilité. </p><br><p>  Du point de vue de la logique métier, un ensemble <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">important d'exigences</a> croît avec le temps, mais nous pouvons le diviser en parties faciles à comprendre.  Décrit ci-dessous, le résultat d'un fonctionnement en pratique de quatre ans. </p><br><h3 id="bazovye-api-vremeni-vypolneniya">  API Core Runtime: </h3><br><ol><li>  <code>add(func[, onerror])</code> - imitation de <code>try-catch</code> . </li><li>  <code>success([args...])</code> - une indication explicite de réussite: <br><ul><li>  implicite par défaut </li><li>  peut passer les résultats à l'étape suivante. </li></ul></li><li>  <code>error(code[, reason)</code> - interruption de l'exécution avec une erreur: <br><ul><li>  <code>code</code> - a un type de chaîne pour mieux s'intégrer aux protocoles réseau dans l'architecture de microservice, </li><li>  <code>reason</code> - une explication arbitraire pour une personne. </li></ul></li><li>  <code>state()</code> - un analogue de Thread Local Storage.  Clés associatives prédéfinies: <br><ul><li>  <code>error_info</code> - explication de la dernière erreur pour une personne, </li><li>  <code>last_exception</code> - pointeur vers l'objet de la dernière exception, </li><li>  <code>async_stack</code> - une pile d'appels asynchrones dans la <code>async_stack</code> où la technologie le permet, </li><li>  le reste est défini par l'utilisateur. </li></ul></li></ol><br><p>  L'exemple précédent est déjà avec du vrai code C ++ et quelques fonctionnalités supplémentaires: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/iasyncsteps.hpp&gt; using namespace futoin; void some_api(IAsyncSteps&amp; asi) { asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 0 func 1" &lt;&lt; std::endl; asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 1 func 1" &lt;&lt; std::endl; asi.error("MyError"); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 1 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; asi.error("NewError", "Human-readable description"); } ); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 0 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; if (code == "NewError") { // Human-readable error info assert(asi.state().error_info == "Human-readable description"); // Last exception thrown is also available in state std::exception_ptr e = asi.state().last_exception; // NOTE: smart conversion of "const char*" asi.success("Prm", 123, std::vector&lt;int&gt;({1, 2, 3}, true)); } } ); asi.add( [](IAsyncSteps&amp; asi, const futoin::string&amp; str_res, int int_res, std::vector&lt;int&gt;&amp;&amp; arr_res) { std::cout &lt;&lt; "Level 0 func 2: " &lt;&lt; str_res &lt;&lt; std::endl; } ); }</span></span></span></span></code> </pre> <br><h3 id="api-dlya-sozdaniya-ciklov">  API pour créer des boucles: </h3><br><ol><li>  <code>loop( func, [, label] )</code> - étape avec un corps infiniment répétable. </li><li>  <code>forEach( map|list, func [, label] )</code> - étape-itération de l'objet de collection. </li><li>  <code>repeat( count, func [, label] )</code> - étape-itération nombre de fois spécifié. </li><li>  <code>break( [label] )</code> est un analogue de l'interruption de boucle traditionnelle. </li><li>  <code>continue( [label] )</code> est un analogue de la continuation de boucle traditionnelle avec une nouvelle itération. </li></ol><br><p>  <em>La spécification propose des noms alternatifs <code>breakLoop</code> , <code>continueLoop</code> et autres en cas de conflit avec des mots réservés.</em> </p><br><p>  Exemple C ++: </p><br><pre> <code class="cpp hljs"> asi.loop([](IAsyncSteps&amp; asi) { <span class="hljs-comment"><span class="hljs-comment">// infinite loop asi.breakLoop(); }); asi.repeat(10, [](IAsyncSteps&amp; asi, size_t i) { // range loop from i=0 till i=9 (inclusive) asi.continueLoop(); }); asi.forEach( std::vector&lt;int&gt;{1, 2, 3}, [](IAsyncSteps&amp; asi, size_t i, int v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::list&lt;futoin::string&gt;{"1", "2", "3"}, [](IAsyncSteps&amp; asi, size_t i, const futoin::string&amp; v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::map&lt;futoin::string, futoin::string&gt;(), [](IAsyncSteps&amp; asi, const futoin::string&amp; key, const futoin::string&amp; v) { // Iteration of map-like objects }); std::map&lt;std::string, futoin::string&gt; non_const_map; asi.forEach( non_const_map, [](IAsyncSteps&amp; asi, const std::string&amp; key, futoin::string&amp; v) { // Iteration of map-like objects, note the value reference type });</span></span></code> </pre> <br><h3 id="api-integracii-s-vneshnimi-sobytiyami">  API pour l'intégration avec des événements externes: </h3><br><ol><li>  <code>setTimeout( timeout_ms )</code> - renvoie une erreur de <code>Timeout</code> après un timeout si l'étape et sa sous-arborescence n'ont pas terminé leur exécution. </li><li>  <code>setCancel( handler )</code> - définit le gestionnaire d'annulation, qui est appelé lorsque le thread est complètement annulé et lorsque la pile d'étapes asynchrones est développée pendant le traitement des erreurs. </li><li>  <code>waitExternal()</code> - une simple attente pour un événement externe. <br><ul><li>  <em>Remarque: Il est sûr de l'utiliser uniquement dans les technologies avec un garbage collector.</em> </li></ul></li></ol><br><p>  Un appel à l'une de ces fonctions rend un appel explicite à <code>success()</code> nécessaire. </p><br><p>  Exemple C ++: </p><br><pre> <code class="cpp hljs"> asi.add([](IAsyncSteps&amp; asi) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = schedule_external_callback([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asi.error(<span class="hljs-string"><span class="hljs-string">"ExternalError"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// pass } } else { asi.success(); } }); asi.setCancel([=](IAsyncSteps&amp; asi) { external_cancel(handle); }); }); asi.add( [](IAsyncSteps&amp; asi) { // Raises Timeout error after specified period asi.setTimeout(std::chrono::seconds{10}); asi.loop([](IAsyncSteps&amp; asi) { // infinite loop }); }, [](IAsyncSteps&amp; asi, ErrorCode code) { if (code == futoin::errors::Timeout) { asi(); } });</span></span></code> </pre> <br><p>  Exemple ECMAScript: </p><br><pre> <code class="javascript hljs">asi.add( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">asi</span></span></span><span class="hljs-function">) =&gt;</span></span> { asi.waitExternal(); <span class="hljs-comment"><span class="hljs-comment">// disable implicit success() some_obj.read( (err, data) =&gt; { if (!asi.state) { // ignore as AsyncSteps execution got canceled } else if (err) { try { asi.error( 'IOError', err ); } catch (_) { // ignore error thrown as there are no // AsyncSteps frames on stack. } } else { asi.success( data ); } } ); } );</span></span></code> </pre> <br><h3 id="api-integracii-s-futurepromise">  API d'intégration Future / Promise: </h3><br><ol><li>  <code>await(promise_future[, on_error])</code> - en attendant Future / Promise comme étape. </li><li>  <code>promise()</code> - transforme l'ensemble du flux d'exécution en Future / Promise, utilisé au lieu de <code>execute()</code> . </li></ol><br><p>  Exemple C ++: </p><br><pre> <code class="hljs pgsql"> [](IAsyncSteps&amp; asi) { // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AsyncSteps instances // <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> hard dependency <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> implementation. auto new_steps = asi.newInstance(); new_steps-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([](IAsyncSteps&amp; asi) {}); // Can be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AsyncSteps event <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> // new_steps.promise().wait(); // <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> // new_steps.promise&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> standard std::future asi.await(new_steps-&gt;promise()); // Ensure instance lifetime asi.state()["some_obj"] = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(new_steps); };</code> </pre> <br><h3 id="api-kontrolya-potoka-vypolneniya-biznes-logiki">  API Business Logic Flow Control: </h3><br><ol><li>  <code>AsyncSteps(AsyncTool&amp;)</code> est un constructeur qui lie un thread d'exécution à une boucle d'événement spécifique. </li><li>  <code>execute()</code> - démarre le thread d'exécution. </li><li>  <code>cancel()</code> - annule le thread d'exécution. </li></ol><br><p>  Une implémentation d'interface spécifique est déjà requise ici. </p><br><p>  Exemple C ++: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/asyncsteps.hpp&gt; #include &lt;futoin/ri/asynctool.hpp&gt; void example() { futoin::ri::AsyncTool at; futoin::ri::AsyncSteps asi{at}; asi.loop([&amp;](futoin::IAsyncSteps &amp;asi){ // Some infinite loop logic }); asi.execute(); std::this_thread::sleep_for(std::chrono::seconds{10}); asi.cancel(); // called in d-tor by fact }</span></span></span></span></code> </pre> <br><h3 id="prochie-api">  autres API: </h3><br><ol><li>  <code>newInstance()</code> - vous permet de créer un nouveau thread d'exécution sans dépendance directe sur l'implémentation. </li><li>  <code>sync(object, func, onerror)</code> - la même chose, mais avec une synchronisation relative à un objet qui implémente l'interface correspondante. </li><li>  <code>parallel([on_error])</code> - spécial <code>add()</code> , dont les sous-étapes sont des flux AsyncSteps distincts: <br><ul><li>  tous les threads ont un <code>state()</code> commun <code>state()</code> , </li><li>  le thread parent continue son exécution à la fin de tous les enfants </li><li>  une erreur non détectée dans un enfant annule immédiatement tous les autres threads enfants. </li></ul></li></ol><br><p>  Exemples C ++: </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/mutex.hpp&gt; using namespace futoin; ri::Mutex mtx_a; void sync_example(IAsyncSteps&amp; asi) { asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { // synchronized section asi.add([](IAsyncSteps&amp; asi) { // inner step in the section // This synchronization is NOOP for already // acquired Mutex. asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { }); }); }); } void parallel_example(IAsyncSteps&amp; asi) { using OrderVector = std::vector&lt;int&gt;; asi.state("order", OrderVector{}); auto&amp; p = asi.parallel([](IAsyncSteps&amp; asi, ErrorCode) { // Overall error handler asi.success(); }); p.add([](IAsyncSteps&amp; asi) { // regular flow asi.state&lt;OrderVector&gt;("order").push_back(1); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(4); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(2); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(5); asi.error("SomeError"); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(3); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(6); }); }); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order"); // 1, 2, 3, 4, 5 }); };</span></span></span></span></code> </pre> <br><h3 id="standartnye-primitivy-dlya-sinhronizacii">  Primitives standard pour la synchronisation </h3><br><ol><li>  <code>Mutex</code> - restreint l'exécution simultanée de <code>N</code> threads avec une file d'attente dans <code>Q</code> , par défaut <code>N=1, Q=unlimited</code> . </li><li>  <code>Throttle</code> - limite le nombre d'entrées <code>N</code> dans la période <code>P</code> avec une file d'attente dans <code>Q</code> , par défaut <code>N=1, P=1s, Q=0</code> . </li><li>  <code>Limiter</code> est une combinaison de <code>Mutex</code> et <code>Throttle</code> , qui est généralement utilisée à l'entrée du traitement des requêtes externes et lors de l'appel de systèmes externes dans le but d'un fonctionnement stable sous charge. </li></ol><br><p>  En cas de <code>DefenseRejected</code> limites de file d'attente, une erreur <code>DefenseRejected</code> est <code>DefenseRejected</code> , dont la signification ressort clairement de la description du <code>Limiter</code> . </p><br><h3 id="klyuchevye-preimuschestva">  Avantages clés </h3><br><p>  Le concept d'AsyncSteps n'était pas une fin en soi, mais est né du besoin d'une exécution asynchrone plus contrôlée des programmes en termes de délai, d'annulation et de connectivité globale des rappels individuels.  Aucune des solutions universelles à l'époque et n'offre désormais les mêmes fonctionnalités.  Par conséquent: </p><br><p> <strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> FTN12</a>   </strong> —           . </p><br><p> <strong>  <code>setCancel()</code></strong> —                    .       ,     .   RAII  <code>atexit()</code>   . </p><br><p> <strong>   <code>cancel()</code></strong> —     ,         .   <code>SIGTERM</code>  <code>pthread_cancel()</code> ,       . </p><br><p> <strong>   <code>setTimeout()</code></strong> —                 .    ,    "Timeout". </p><br><p> <strong>     </strong> —  FutoIn AsyncSteps             . </p><br><p> <strong>      </strong> —          ABI     ,    .    Embedded     MMU. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8x/wv/yj8xwvibm7tjsj30qhojwbleige.jpeg"></div><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em> </em></a> </p><br><h2 id="k-cifram">   </h2><br><p>    Intel Xeon E3-1245v2/DDR1333  Debian Stretch    . </p><br><p>   : </p><br><ol><li> Boost.Fiber  <code>protected_fixedsize_stack</code> . </li><li> Boost.Fiber  <code>pooled_fixedsize_stack</code>     . </li><li> FutoIn AsyncSteps   . </li><li> FutoIn AsyncSteps      ( <code>FUTOIN_USE_MEMPOOL=false</code> ). <br><ul><li>      <code>futoin::IMemPool</code> . </li></ul></li><li> FutoIn NitroSteps&lt;&gt; —           . <br><ul><li>         . </li></ul></li></ol><br><p>    Boost.Fiber    : </p><br><ol><li>     1 . . </li><li>       30 .   1 . . <br><ul><li>   30 .     <code>mmap()/mprotect()</code>  <code>boost::fiber::protected_fixedsize_stack</code> . </li><li>          . </li></ul></li><li>   30 .   10 .     . <br><ul><li>    ""          . </li></ul></li></ol><br><p>      "" , ..     ,       .        .   . </p><br><p>    GCC 6.3.0.   lang  tcmalloc  ,     . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitLab</a> . </p><br><h3 id="1-posledovatelnoe-sozdanie"> 1.   </h3><br><table><thead><tr><th>  La technologie </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 4.8s </td><td> 208333.333Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 0.23s </td><td> 4347826.086Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>0.21s</strong> </td><td> <strong>4761904.761Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 0.31s </td><td> 3225806.451Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 0.255s </td><td> 3921568.627Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/ur/y6/qmury65-mbkth_om8smkfi7vamq.png"></div><br><p> <em> — .</em> </p><br><p>     Boost.Fiber -      ,     <code>pooled_fixedsize_stack</code>   ,    AsyncSteps. </p><br><h3 id="2-parallelnoe-sozdanie-i-ispolnenie"> 2.     </h3><br><table><thead><tr><th>  La technologie </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 6.31s </td><td> 158478.605Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 1.558s </td><td> 641848.523Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1.13s</strong> </td><td> <strong>884955.752Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 1.353s </td><td> 739098.300Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 1.43s </td><td> 699300.699Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0s/gz/lu/0sgzlur2xsrlf-wo4mrcynvzhxi.png"></div><br><p> <em> — .</em> </p><br><p>    ,          .    ,        —            . </p><br><h3 id="3-parallelnye-cikly"> 3.   </h3><br><table><thead><tr><th>  La technologie </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 5.096s </td><td> 1962323.390Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 5.077s </td><td> 1969667.126Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> 5.361s </td><td> 1865323.633Hz </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 8.288s </td><td> 1206563.706Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> <strong>3.68s</strong> </td><td> <strong>2717391.304Hz</strong> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/c1/17/pbc117djqds0d4twh5fzcklsmfc.png"></div><br><p> <em> — .</em> </p><br><p>   ,        Boost.Fiber      AsyncSteps,    NitroSteps. </p><br><h3 id="ispolzovanie-pamyati-po-rss">   ( RSS) </h3><br><table><thead><tr><th>  La technologie </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 124M </td></tr><tr><td> Boost.Fiber pooled </td><td> 505M </td></tr><tr><td> FutoIn AsyncSteps </td><td> 124M </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> <strong>84M</strong> </td></tr><tr><td> FutoIn NitroSteps </td><td> 115M </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/w0/6n/olw06nef5wj3ah1lo9u-pby9sfg.png"></div><br><p> <em> — .</em> </p><br><p>  , Boost.Fiber  . </p><br><h3 id="bonus-testy-na-nodejs"> :   Node.js </h3><br><p>      -  <code>Promise</code> : +    10 . .   10 .          JIT  <code>NODE_ENV=production</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>@futoin/optihelp</code></a> . </p><br><p>      <a href="">GitHub</a>  <a href="">GitLab</a> .   Node.js v8.12.0  v10.11.0,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FutoIn CID</a> . </p><br><table><thead><tr><th> Tech </th><th> Simple </th><th> Loop </th></tr></thead><tbody><tr><td> <strong>Node.js v10</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1342899.520Hz</strong> </td><td> 587.777Hz </td></tr><tr><td> async/await </td><td> 524983.234Hz </td><td> <strong>630.863Hz</strong> </td></tr><tr><td> <strong>Node.js v8</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>682420.735Hz</strong> </td><td> <strong>588.336Hz</strong> </td></tr><tr><td> async/await </td><td> 365050.395Hz </td><td> 400.575Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x7/-n/b5/x7-nb5v9dfkwn1lttyg67w2b_tk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/yj/9p/ghyj9pczw0smbfksq-aad_tltay.png"></div><br><p> <em> — .</em> </p><br><p>   <code>async/await</code> ? ,   V8  Node.js v10       . </p><br><p>  ,   Promise  <code>async/await</code> <strong></strong> Node.js Event Loop.          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ),   FutoIn AsyncSteps   . </p><br><p> <em>   AsyncSteps  Node.js Event Loop      <code>async/await</code>  -  Node.js v10.</em> </p><br><p> <em>,      ++   —    .  ,    Node.js    10 .</em> </p><br><h3 id="vyvody">  Conclusions </h3><br><p>   C++, FutoIn AsyncSteps  Boost.Fiber       ,     Boost.Fiber         <code>mmap()/mprotect</code> . </p><br><p>       ,      -      ,   .     . </p><br><p> FutoIn AsyncSteps  JavaScript  <code>async/await</code>       Node.js v10. </p><br><p>   ,       -,       .        . </p><br><p>   -                        ""  .     —   API. </p><br><hr><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> ,  FutoIn AsyncSteps ,          "" <code>async/await</code> . ,         .      <code>Promise</code>  ECMAScript, AsyncSteps    ""           . </p><br><p>               .        AsyncSteps  NitroSteps   . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,    - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p>       Java/JVM         —    .    . </p><br><p>      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitLab</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424311/">https://habr.com/ru/post/fr424311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424297/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 9: Sécurité des applications Web, partie 3</a></li>
<li><a href="../fr424301/index.html">Algorithme de filtre d'image de réseau neuronal adaptatif</a></li>
<li><a href="../fr424305/index.html">RIB pour architecture mobile multiplateforme Uber</a></li>
<li><a href="../fr424307/index.html">GitLab 11.3 publié avec le référentiel Maven et les environnements sécurisés</a></li>
<li><a href="../fr424309/index.html">DevCore: partie logicielle du projet DevBoy</a></li>
<li><a href="../fr424313/index.html">EveryLang est un programme qui peut faire presque tout</a></li>
<li><a href="../fr424315/index.html">Un nouveau cycle de substitution des importations. Où courir et que faire?</a></li>
<li><a href="../fr424319/index.html">La structure de la boutique en ligne. 2e partie</a></li>
<li><a href="../fr424321/index.html">Mettre NetFlow bon marché et en colère</a></li>
<li><a href="../fr424323/index.html">Un exemple de travail avec la méthode ICE du chef de produit de Google et Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>