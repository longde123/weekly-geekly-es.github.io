<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèø üõí üíáüèº Linux Kernel 5.0 - escrevendo Simple Block Device em blk-mq üë≥ üçè üéöÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boas not√≠cias, pessoal! 

 O kernel do Linux 5.0 j√° est√° aqui e aparece em distribui√ß√µes experimentais como Arch, openSUSE Tumbleweed, Fedora. 



 E ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0 - escrevendo Simple Block Device em blk-mq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/">  Boas not√≠cias, pessoal! <br><br>  O kernel do Linux 5.0 j√° est√° aqui e aparece em distribui√ß√µes experimentais como Arch, openSUSE Tumbleweed, Fedora. <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br>  E se voc√™ olhar as distribui√ß√µes RC do Ubuntu Disko Dingo e Red Hat 8, fica claro: em breve o kernel 5.0 tamb√©m ser√° transferido dos desktops dos f√£s para servidores s√©rios. <br>  Algu√©m dir√° - e da√≠?  O pr√≥ximo lan√ßamento, nada de especial.  Ent√£o o pr√≥prio Linus Torvalds disse: <blockquote>  Gostaria de salientar (mais uma vez) que n√£o fazemos lan√ßamentos baseados em recursos e que "5.0" n√£o significa nada mais do que os n√∫meros 4.x come√ßaram a ficar grandes o suficiente para ficar sem dedos e dedos dos p√©s. <br><br>  ( <i>Mais uma vez repito - nossos lan√ßamentos n√£o est√£o vinculados a nenhum recurso espec√≠fico, portanto, o n√∫mero da nova vers√£o 5.0 significa apenas que, para numerar as vers√µes 4.x, eu j√° n√£o tenho dedos das m√£os e p√©s</i> ) <br></blockquote><br>  No entanto, o m√≥dulo para disquetes (que n√£o sabe - s√£o discos do tamanho de uma camisa de bolso, com capacidade de 1,44 MB) - corrigido ... <br>  E aqui est√° o porqu√™: <br><a name="habracut"></a><br>  √â tudo sobre a camada de blocos com v√°rias filas (blk-mq).  Existem muitos artigos introdut√≥rios sobre ele na Internet, ent√£o vamos direto ao ponto.  A transi√ß√£o para o blk-mq foi iniciada h√° muito tempo e avan√ßava lentamente.  Apareceu o scsi de v√°rias filas (par√¢metro do kernel scsi_mod.use_blk_mq), novos agendadores mq-deadline, bfq e assim por diante‚Ä¶ <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br>  A prop√≥sito, qual √© a sua? <br><br>  O n√∫mero de drivers de dispositivo de bloco que funcionam √† moda antiga foi reduzido.  E no 5.0, a fun√ß√£o blk_init_queue () foi removida como desnecess√°ria.  E agora o velho e glorioso c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lwn.net/Articles/58720</a> de 2003 n√£o est√° apenas indo, como tamb√©m perdeu relev√¢ncia.  Al√©m disso, as novas distribui√ß√µes, que est√£o sendo preparadas para lan√ßamento este ano, usam uma camada de blocos com v√°rias filas na configura√ß√£o padr√£o.  Por exemplo, no 18¬∫ Manjaro, o kernel, apesar da vers√£o 4.19, √© blk-mq por padr√£o. <br><br>  Portanto, podemos assumir que a transi√ß√£o para o blk-mq no kernel 5.0 foi conclu√≠da.  E para mim, este √© um evento importante que exigir√° a reescrita do c√≥digo e testes adicionais.  O que por si s√≥ promete a apar√™ncia de bugs grandes e pequenos, al√©m de v√°rios servidores com falhas (√© necess√°rio, Fedya, √© necess√°rio! (C)). <br><br>  A prop√≥sito, se algu√©m pensa que para rhel8 esse ponto de inflex√£o n√£o chegou, j√° que o kernel foi "flashed" pela vers√£o 4.18 l√°, voc√™ est√° enganado.  No RC recente no rhel8, novos produtos do 5.0 j√° haviam migrado e a fun√ß√£o blk_init_queue () tamb√©m foi cortada (provavelmente ao arrastar outro check-in do github.com/torvalds/linux para suas fontes). <br>  Em geral, a vers√£o "congelada" do kernel para distribuidores Linux, como SUSE e Red Hat, √© um conceito de marketing h√° muito tempo.  O sistema relata que a vers√£o, por exemplo, √© 4.4 e, de fato, a funcionalidade √© de uma nova baunilha 4.8.  Ao mesmo tempo, uma inscri√ß√£o √© exibida no site oficial como: "Na nova distribui√ß√£o, mantivemos um kernel 4.4 est√°vel para voc√™". <br><br>  Mas est√°vamos distra√≠dos ... <br><br>  Ent√£o aqui.  Precisamos de um novo driver de dispositivo de bloco simples para deixar mais claro como isso funciona. <br>  Portanto, a fonte em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/CodeImp/sblkdev</a> .  Proponho discutir, fazer solicita√ß√µes pull, iniciar o problema - eu o corrigirei.  O controle de qualidade ainda n√£o foi testado. <br><br>  Mais adiante neste artigo, tentarei descrever o porqu√™.  Portanto, h√° muito c√≥digo. <br>  Pe√ßo desculpas imediatamente por o estilo de codifica√ß√£o do kernel do Linux n√£o ser totalmente respeitado e sim - eu n√£o gosto de ir. <br><br>  Ent√£o, vamos come√ßar pelos pontos de entrada. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br>  Obviamente, quando o m√≥dulo √© carregado, a fun√ß√£o sblkdev_init () √© iniciada, quando sblkdev_exit () √© descarregado. <br>  A fun√ß√£o register_blkdev () registra um dispositivo de bloco.  Ele recebe um n√∫mero importante.  unregister_blkdev () - libera esse n√∫mero. <br><br>  A estrutura de chaves do nosso m√≥dulo √© sblkdev_device_t. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br>  Ele cont√©m todas as informa√ß√µes sobre o dispositivo necess√°rias para o m√≥dulo do kernel, em particular: a capacidade do dispositivo de bloco, os dados em si (isso √© simples), ponteiros para o disco e a fila. <br><br>  Toda a inicializa√ß√£o do dispositivo de bloco √© realizada na fun√ß√£o sblkdev_add_device (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br>  Alocamos mem√≥ria para a estrutura, alocamos um buffer para armazenar dados.  Nada de especial aqui. <br>  Em seguida, inicializamos a fila de processamento de solicita√ß√µes com uma fun√ß√£o blk_mq_init_sq_queue () ou duas de uma vez: blk_mq_alloc_tag_set () + blk_mq_init_queue (). <br><br>  A prop√≥sito, se voc√™ olhar o c√≥digo fonte da fun√ß√£o blk_mq_init_sq_queue (), ver√° que este √© apenas um inv√≥lucro das fun√ß√µes blk_mq_alloc_tag_set () e blk_mq_init_queue (), que apareceram no kernel 4.20.  Al√©m disso, ele oculta muitos par√¢metros da fila, mas parece muito mais f√°cil.  Voc√™ tem que escolher qual op√ß√£o √© melhor, mas eu prefiro uma op√ß√£o mais expl√≠cita. <br><br>  A chave neste c√≥digo √© a vari√°vel global _mq_ops. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br>  √â aqui que est√° localizada a fun√ß√£o que fornece o processamento de solicita√ß√µes, mas um pouco mais tarde.  O principal √© que designamos o ponto de entrada para o manipulador de solicita√ß√µes. <br><br>  Agora que criamos a fila, podemos criar uma inst√¢ncia do disco. <br><br>  N√£o h√° grandes mudan√ßas.  O disco √© alocado, os par√¢metros s√£o definidos e o disco √© adicionado ao sistema.  Eu quero explicar sobre o par√¢metro disk-&gt; flags.  Ele permite que voc√™ informe ao sistema que o disco √© remov√≠vel ou, por exemplo, que ele n√£o cont√©m parti√ß√µes e que voc√™ n√£o precisa procur√°-las l√°. <br><br>  Existe uma estrutura _fops para gerenciamento de disco. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br>  Os pontos de entrada _open e _release para n√≥s para um m√≥dulo de dispositivo de bloco simples ainda n√£o s√£o muito interessantes.  Al√©m do contador at√¥mico e de incremento, n√£o h√° nada l√°.  Tamb√©m deixei compat_ioctl sem implementa√ß√£o, pois a vers√£o dos sistemas com um kernel de 64 bits e um ambiente de espa√ßo do usu√°rio de 32 bits n√£o me parece promissor. <br><br>  Mas _ioctl permite processar solicita√ß√µes de sistema para esta unidade.  Quando um disco aparece, o sistema tenta aprender mais sobre ele.  A seu crit√©rio, voc√™ pode responder a algumas perguntas (por exemplo, fingir ser um novo CD), mas a regra geral √© a seguinte: se voc√™ n√£o deseja responder a perguntas que n√£o lhe interessam, basta retornar o c√≥digo de erro -ENOTTY.  A prop√≥sito, se necess√°rio, aqui voc√™ pode adicionar seus manipuladores de solicita√ß√£o em rela√ß√£o a essa unidade espec√≠fica. <br><br>  Ent√£o, adicionamos o dispositivo - precisamos cuidar da libera√ß√£o de recursos.  Ferrugem n√£o est√° <s>aqui para</s> voc√™. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br>  Em princ√≠pio, tudo √© √≥bvio: exclu√≠mos o objeto de disco do sistema e liberamos a fila, ap√≥s o que tamb√©m liberamos nossos buffers (√°reas de dados). <br><br>  E agora o mais importante √© o processamento de consultas na fun√ß√£o queue_rq (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br>  Primeiro, considere os par√¢metros.  O primeiro √© struct blk_mq_hw_ctx * hctx - o estado da fila de hardware.  No nosso caso, fazemos sem a fila de hardware, portanto n√£o utilizada. <br><br>  O segundo par√¢metro √© const struct blk_mq_queue_data * bd - um par√¢metro com uma estrutura muito concisa, que n√£o tenho medo de apresentar √† sua aten√ß√£o em sua totalidade: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br>  Acontece que, em ess√™ncia, esse √© o mesmo pedido que nos chegou desde tempos em que o cronista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">elixir.bootlin.com</a> n√£o se lembra mais.  Ent√£o, pegamos a solicita√ß√£o e come√ßamos a process√°-la, sobre a qual notificamos o kernel chamando blk_mq_start_request ().  Ap√≥s a conclus√£o do processamento da solicita√ß√£o, informaremos o kernel sobre isso chamando a fun√ß√£o blk_mq_end_request (). <br><br>  Aqui est√° uma pequena observa√ß√£o: a fun√ß√£o blk_mq_end_request () √© essencialmente um inv√≥lucro sobre as chamadas para blk_update_request () + __blk_mq_end_request ().  Ao usar a fun√ß√£o blk_mq_end_request (), voc√™ n√£o pode especificar quantos bytes foram realmente processados.  Acredita que tudo √© processado. <br><br>  A op√ß√£o alternativa possui outro recurso: a fun√ß√£o blk_update_request √© exportada apenas para m√≥dulos somente GPL.  Ou seja, se voc√™ deseja criar um m√≥dulo propriet√°rio do kernel (deixe o PM salv√°-lo desse caminho espinhoso), n√£o poder√° usar blk_update_request ().  Ent√£o a escolha √© sua. <br><br>  Mudando diretamente os bytes da solicita√ß√£o para o buffer e vice-versa, coloquei na fun√ß√£o do_simple_request (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br>  N√£o h√° nada de novo: o rq_for_each_segment itera sobre tudo o que √© bio, e todos eles t√™m estruturas de bio_vec, o que nos permite acessar as p√°ginas com os dados da solicita√ß√£o. <br><br>  Quais s√£o as suas impress√µes?  Tudo parece simples?  O processamento de solicita√ß√µes em geral √© simplesmente copiar dados entre as p√°ginas da solicita√ß√£o e o buffer interno.  Bastante digno de um driver de dispositivo de bloco simples, certo? <br><br>  Mas h√° um problema: <b>isso n√£o √© para uso real!</b> <br><br>  A ess√™ncia do problema √© que a fun√ß√£o de processamento de solicita√ß√µes queue_rq () √© chamada em um loop que processa solicita√ß√µes da lista.  N√£o sei qual bloqueio dessa lista √© usado l√°, Spin ou RCU (n√£o quero mentir - quem sabe, me corrija), mas quando voc√™ tenta usar, por exemplo, mutex na fun√ß√£o de processamento de solicita√ß√µes, o kernel de depura√ß√£o jura e avisa: cochile aqui √© imposs√≠vel.  Ou seja, √© imposs√≠vel usar ferramentas de sincroniza√ß√£o convencionais ou mem√≥ria virtual cont√≠gua - que √© alocada usando vmalloc e pode ser trocada com tudo o que implica - √© imposs√≠vel, pois o processo n√£o pode entrar no estado de espera. <br><br>  Portanto, apenas bloqueios Spin ou RCU e um buffer na forma de uma matriz de p√°ginas, lista ou √°rvore, conforme implementado em .. \ linux \ drivers \ block \ brd.c, ou processamento atrasado em outro encadeamento, conforme implementado em .. \ linux \ drivers \ bloco \ loop.c. <br><br>  Acho que n√£o h√° necessidade de descrever como montar o m√≥dulo, como carreg√°-lo no sistema e como descarregar.  N√£o h√° novos produtos nesta frente, e obrigado por isso :) Portanto, se algu√©m quiser experimentar, certamente descobrir√°.  <b>S√≥ n√£o fa√ßa isso imediatamente no seu laptop favorito!</b>  Levante um virtualochka ou, pelo menos, fa√ßa um backup em uma bola. <br><br>  A prop√≥sito, o Veeam Backup for Linux 3.0.1.1046 j√° est√° dispon√≠vel.  Apenas n√£o tente executar o VAL 3.0.1.1046 em um kernel 5.0 ou posterior.  O veeamsnap n√£o ser√° montado.  E algumas inova√ß√µes de v√°rias filas ainda est√£o em fase de teste. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446148/">https://habr.com/ru/post/pt446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446134/index.html">Inje√ß√£o de Depend√™ncia em Flutter</a></li>
<li><a href="../pt446136/index.html">Minha m√°quina de m√°rmore impressa em 3D</a></li>
<li><a href="../pt446138/index.html">Como √© f√°cil organizar legalmente sua startup na forma de uma parceria simples</a></li>
<li><a href="../pt446142/index.html">Terra plana: experimentos e evid√™ncias</a></li>
<li><a href="../pt446144/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 292 (25 a 31 de mar√ßo)</a></li>
<li><a href="../pt446150/index.html">Aprendizado de m√°quina sem Python, Anaconda e outros r√©pteis</a></li>
<li><a href="../pt446152/index.html">Comando VM - Alternativa Kali Linux para Windows</a></li>
<li><a href="../pt446162/index.html">Como se tornar um "j√∫nior inteligente". Experi√™ncia pessoal</a></li>
<li><a href="../pt446166/index.html">Codec ASN1 simples do sprintf</a></li>
<li><a href="../pt446172/index.html">API de limite de mensagens VK - o que fazer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>