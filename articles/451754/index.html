<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéöÔ∏è üå∞ ‚õ¥Ô∏è C√≥mo encontramos expresiones lambda en IntelliJ IDEA ‚úÇÔ∏è üíπ üë©üèø‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La b√∫squeda de c√≥digos y la navegaci√≥n son caracter√≠sticas importantes de cualquier IDE. En Java, una de las opciones de b√∫squeda m√°s utilizadas es bu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo encontramos expresiones lambda en IntelliJ IDEA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/451754/"><p><img alt="Jerarqu√≠a de tipos en IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  La b√∫squeda de c√≥digos y la navegaci√≥n son caracter√≠sticas importantes de cualquier IDE.  En Java, una de las opciones de b√∫squeda m√°s utilizadas es buscar todas las implementaciones de una interfaz.  Esta caracter√≠stica a menudo se denomina Jerarqu√≠a de tipos, y se parece a la imagen de la derecha. </p><br><p>  Es ineficiente iterar sobre todas las clases de proyecto cuando se invoca esta caracter√≠stica.  Una opci√≥n es guardar la jerarqu√≠a de clases completa en el √≠ndice durante la compilaci√≥n, ya que el compilador la construye de todos modos.  Hacemos esto cuando el IDE ejecuta la compilaci√≥n y no se delega, por ejemplo, a Gradle.  Pero esto solo funciona si no se ha cambiado nada en el m√≥dulo despu√©s de la compilaci√≥n.  En general, el c√≥digo fuente es el proveedor de informaci√≥n m√°s actualizado, y los √≠ndices se basan en el c√≥digo fuente. </p><br><p> Encontrar hijos inmediatos es una tarea simple si no estamos tratando con una interfaz funcional.  Al buscar implementaciones de la interfaz <code>Foo</code> , necesitamos encontrar todas las clases que tienen <code>implements Foo</code> e interfaces que tienen <code>extends Foo</code> , as√≠ como <code>new Foo(...) {...}</code> clases an√≥nimas <code>new Foo(...) {...}</code> .  Para hacer esto, es suficiente construir de antemano un √°rbol de sintaxis de cada archivo de proyecto, encontrar las construcciones correspondientes y agregarlas a un √≠ndice. <a name="habracut"></a>  Sin embargo, aqu√≠ hay una complejidad: es posible que est√© buscando la interfaz <code>com.example.goodcompany.Foo</code> , mientras que en realidad se usa <code>org.example.evilcompany.Foo</code> .  ¬øPodemos poner el nombre completo de la interfaz principal en el √≠ndice de antemano?  Puede ser complicado  Por ejemplo, el archivo donde se usa la interfaz puede verse as√≠: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Al mirar el archivo solo, es imposible saber cu√°l es el nombre completo y calificado de <code>Foo</code> .  Tendremos que analizar el contenido de varios paquetes.  Y cada paquete se puede definir en varios lugares del proyecto (por ejemplo, en varios archivos JAR).  Si realizamos una resoluci√≥n de s√≠mbolo adecuada al analizar este archivo, la indexaci√≥n llevar√° mucho tiempo.  Pero el problema principal es que el √≠ndice creado en <code>MyFoo.java</code> tambi√©n depender√° de otros archivos.  Podemos mover la declaraci√≥n de la interfaz de <code>Foo</code> , por ejemplo, del paquete <code>org.example.foo</code> paquete <code>org.example.bar</code> , sin cambiar nada en el archivo <code>MyFoo.java</code> , pero el nombre completo de <code>Foo</code> cambiar√°. </p><br><p>  En IntelliJ IDEA, los √≠ndices dependen solo del contenido de un solo archivo.  Por un lado, es muy conveniente: el √≠ndice asociado con un archivo espec√≠fico deja de ser v√°lido cuando se cambia el archivo.  Por otro lado, impone restricciones importantes sobre lo que se puede incluir en el √≠ndice.  Por ejemplo, no permite que los nombres completos de las clases primarias se guarden de manera confiable en el √≠ndice.  Pero, en general, no es tan malo.  Al solicitar una jerarqu√≠a de tipos, podemos encontrar todo lo que coincida con nuestra solicitud con un nombre corto, y luego realizar la resoluci√≥n de s√≠mbolo adecuada para estos archivos y determinar si eso es lo que estamos buscando.  En la mayor√≠a de los casos, no habr√° demasiados s√≠mbolos redundantes y la verificaci√≥n no llevar√° mucho tiempo. </p><br><p><img alt="Jerarqu√≠a de interfaz funcional en IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Sin embargo, las cosas cambian cuando la clase cuyos hijos buscamos es una interfaz funcional.  Luego, adem√°s de las subclases expl√≠citas y an√≥nimas, habr√° expresiones lambda y referencias de m√©todos.  ¬øQu√© ponemos en el √≠ndice ahora y qu√© se evaluar√° durante la b√∫squeda? </p><br><p>  Supongamos que tenemos una interfaz funcional: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  El c√≥digo contiene diferentes expresiones lambda.  Por ejemplo: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">// a certain mismatch: no parameters (a, b) -&gt; a + b // a certain mismatch: two parameters s -&gt; { return list.add(s); // a certain mismatch: a value is returned } s -&gt; list.add(s); // a potential match</span></span></code> </pre> <br><p>  Significa que podemos filtrar r√°pidamente las lambdas que tienen un n√∫mero inapropiado de par√°metros o un tipo de retorno claramente inapropiado, por ejemplo, nulo en lugar de nulo.  Por lo general, es imposible determinar el tipo de retorno con mayor precisi√≥n.  Por ejemplo, en <code>s -&gt; list.add(s)</code> tendr√° que resolver <code>list</code> y <code>add</code> , y, posiblemente, ejecutar un procedimiento de inferencia de tipo regular.  Lleva tiempo y depende del contenido de otros archivos. </p><br><p>  Tenemos suerte si la interfaz funcional toma cinco argumentos.  Pero si solo se necesita uno, el filtro mantendr√° una gran cantidad de lambdas innecesarias.  Es a√∫n peor cuando se trata de referencias de m√©todos.  Por lo que parece, uno no puede decir si una referencia de m√©todo es adecuada o no. </p><br><p>  Para aclarar las cosas, podr√≠a valer la pena mirar lo que rodea a la lambda.  A veces funciona.  Por ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// declaration of a local variable or a field of different type Predicate&lt;String&gt; p = s -&gt; list.add(s); // a different return type IntPredicate getPredicate() { return s -&gt; list.add(s); } // assignment to a variable of a different type SomeType fn; fn = s -&gt; list.add(s); // cast to a different type foo((SomeFunctionalType)(s -&gt; list.add(s))); // declaration of a different type array Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  En todos estos casos, el nombre corto de la interfaz funcional correspondiente puede determinarse a partir del archivo actual y puede colocarse en el √≠ndice junto a la expresi√≥n funcional, ya sea una referencia lambda o de m√©todo.  Desafortunadamente, en proyectos de la vida real, estos casos cubren un porcentaje muy peque√±o de todas las lambdas.  En la mayor√≠a de los casos, las lambdas se usan como argumentos de m√©todo: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  ¬øCu√°l de las tres lambdas puede contener <code>StringConsumer</code> ?  Obviamente, ninguno.  Aqu√≠ tenemos una cadena Stream API que solo presenta interfaces funcionales de la biblioteca est√°ndar, no puede tener el tipo personalizado. </p><br><p>  Sin embargo, el IDE deber√≠a poder ver a trav√©s del truco y darnos una respuesta exacta.  ¬øQu√© <code>list.stream()</code> si <code>list</code> no es exactamente <code>java.util.List</code> y <code>list.stream()</code> devuelve algo diferente de <code>java.util.stream.Stream</code> ?  Luego tendremos que resolver la <code>list</code> , que, como sabemos, no se puede hacer de manera confiable solo en funci√≥n del contenido del archivo actual.  E incluso si lo hacemos, la b√∫squeda no deber√≠a depender de la implementaci√≥n de la biblioteca est√°ndar.  ¬øQu√© sucede si en este proyecto en particular hemos reemplazado <code>java.util.List</code> con una clase propia?  La b√∫squeda debe tener esto en cuenta.  Y, naturalmente, las lambdas se usan no solo en transmisiones est√°ndar: hay muchos otros m√©todos a los que se pasan. </p><br><p>  Como resultado, podemos consultar en el √≠ndice una lista de todos los archivos Java que usan lambdas con el n√∫mero requerido de par√°metros y un tipo de retorno v√°lido (de hecho, solo buscamos cuatro opciones: void, non-void, boolean y cualquiera)  Y que sigue?  ¬øNecesitamos construir un √°rbol PSI completo (una especie de √°rbol de an√°lisis con resoluci√≥n de s√≠mbolo, inferencia de tipos y otras caracter√≠sticas inteligentes) para cada uno de estos archivos y realizar una inferencia de tipo adecuada para lambdas?  Para un gran proyecto, tomar√° a√±os obtener la lista de todas las implementaciones de interfaz, incluso si solo hay dos de ellas. </p><br><p>  Entonces, debemos seguir los siguientes pasos: </p><br><ul><li>  Consultar √≠ndice (no es costoso) </li><li>  Construir PSI (costoso) </li><li>  Inferir tipo lambda (muy costoso) </li></ul><br><p>  Para Java 8 y versiones posteriores, la inferencia de tipos es una operaci√≥n extremadamente costosa.  En una cadena de llamadas compleja, puede haber muchos par√°metros gen√©ricos de sustituci√≥n, cuyos valores deben determinarse utilizando el procedimiento de golpe fuerte descrito en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 18</a> de la especificaci√≥n.  Para el archivo actual, esto se puede hacer en segundo plano, pero procesar miles de archivos sin abrir de esta manera ser√≠a una tarea costosa. </p><br><p>  Aqu√≠, sin embargo, es posible cortar esquinas ligeramente: en la mayor√≠a de los casos, no necesitamos el tipo de concreto.  A menos que un m√©todo acepte un par√°metro gen√©rico donde se le pasa el lambda, se puede evitar el paso final de sustituci√≥n del par√°metro.  Si hemos inferido el tipo de lambda <code>java.util.function.Function&lt;T, R&gt;</code> , no tenemos que evaluar los valores de los par√°metros de sustituci√≥n <code>T</code> y <code>R</code> : ya est√° claro si incluir el lambda en los resultados de b√∫squeda o no  Sin embargo, no funcionar√° para un m√©todo como este: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Este m√©todo se puede llamar con <code>doSmth(Runnable.class, () -&gt; {})</code> .  Entonces el tipo lambda se inferir√° como <code>T</code> , a√∫n se requiere sustituci√≥n.  Sin embargo, este es un caso raro.  De hecho, podemos ahorrar algo de tiempo de CPU aqu√≠, pero solo alrededor del 10%, por lo que esto no resuelve el problema en su esencia. </p><br><p>  Alternativamente, cuando la inferencia de tipo precisa es demasiado complicada, puede hacerse aproximada.  A diferencia de lo que sugiere la especificaci√≥n, deje que funcione solo en los tipos de clase borrados y no reduzca el conjunto de restricciones, sino simplemente siga una cadena de llamadas.  Mientras el tipo borrado no incluya par√°metros gen√©ricos, todo est√° bien.  Consideremos la secuencia del ejemplo anterior y determinemos si la √∫ltima lambda implementa <code>StringConsumer</code> : </p><br><ul><li>  variable de <code>list</code> -&gt; tipo <code>java.util.List</code> </li><li>  <code>List.stream()</code> ‚Üí tipo <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> -&gt; tipo <code>java.util.stream.Stream</code> , no tenemos que considerar argumentos de <code>filter</code> </li><li>  de manera similar, <code>Stream.map(...)</code> ‚Üí tipo <code>java.util.stream.Stream</code> </li><li>  <code>Stream.forEach(...)</code> ‚Üí dicho m√©todo existe, su par√°metro tiene el tipo de <code>Consumer</code> , que obviamente no es <code>StringConsumer</code> . </li></ul><br><p>  Y as√≠ es como podr√≠amos hacer sin inferencia de tipo regular.  Con este enfoque simple, sin embargo, es f√°cil encontrar m√©todos sobrecargados.  Si no realizamos una inferencia de tipo adecuada, no podemos elegir el m√©todo correcto sobrecargado.  Sin embargo, a veces es posible: si los m√©todos tienen un n√∫mero diferente de par√°metros.  Por ejemplo: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Aqu√≠ podemos ver eso: </p><br><ul><li>  Hay dos m√©todos <code>CompletableFuture.supplyAsync</code> ;  el primero toma un argumento y el segundo toma dos, as√≠ que elegimos el segundo.  Devuelve <code>CompletableFuture</code> . </li><li>  Tambi√©n hay dos m√©todos <code>thenRunAsync</code> , y podemos elegir de manera similar el que tome un argumento.  El par√°metro correspondiente tiene el tipo <code>Runnable</code> , lo que significa que no es <code>StringConsumer</code> . </li></ul><br><p>  Si varios m√©todos toman el mismo n√∫mero de par√°metros o tienen un n√∫mero variable de par√°metros pero parecen apropiados, tendremos que buscar a trav√©s de todas las opciones.  A menudo no es tan aterrador: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> obviamente crea <code>java.lang.StringBuilder</code> .  Para los constructores, todav√≠a resolvemos la referencia, pero aqu√≠ no se requiere inferencia de tipos complejos.  Incluso si hubiera un <code>new Foo&lt;&gt;(x, y, z)</code> , no inferir√≠amos los valores de los par√°metros de tipo ya que solo <code>Foo</code> nos interesa. </li><li>  Hay muchos m√©todos <code>StringBuilder.append</code> que toman un argumento, pero todos devuelven el tipo <code>java.lang.StringBuilder</code> , por lo que no nos importan los tipos de <code>foo</code> y <code>bar</code> . </li><li>  Hay un m√©todo <code>StringBuilder.chars</code> , y devuelve <code>java.util.stream.IntStream</code> . </li><li>  Hay un √∫nico m√©todo <code>IntStream.forEach</code> , y toma el tipo <code>IntConsumer</code> . </li></ul><br><p>  Incluso si quedan varias opciones, puede seguirlas todas.  Por ejemplo, el tipo lambda pasado a <code>ForkJoinPool.getInstance().submit(...)</code> puede ser <code>Runnable</code> o <code>Callable</code> , y si estamos buscando otra opci√≥n, a√∫n podemos descartar este lambda. </p><br><p>  Las cosas empeoran cuando el m√©todo devuelve un par√°metro gen√©rico.  Entonces el procedimiento falla y debe realizar una inferencia de tipo adecuada.  Sin embargo, hemos apoyado un caso.  Se muestra bien en mi biblioteca StreamEx, que tiene una clase abstracta <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> que contiene m√©todos como el <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Por lo general, las personas trabajan con una <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> concreta <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  En este caso, puede sustituir el par√°metro de tipo y descubrir que <code>S = StreamEx</code> . </p><br><p>  As√≠ es como nos hemos librado de la costosa inferencia de tipos en muchos casos.  Pero no hemos hecho nada con la construcci√≥n de PSI.  Es decepcionante haber analizado un archivo con 500 l√≠neas de c√≥digo solo para descubrir que el lambda en la l√≠nea 480 no coincide con nuestra consulta.  Volvamos a nuestra transmisi√≥n: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Si <code>list</code> es una variable local, un par√°metro de m√©todo o un campo en la clase actual, ya en la etapa de indexaci√≥n, podemos encontrar su declaraci√≥n y establecer que el nombre de tipo corto es <code>List</code> .  En consecuencia, podemos poner la siguiente informaci√≥n en el √≠ndice de la √∫ltima lambda: </p><br><blockquote>  Este tipo lambda es un tipo de par√°metro de un m√©todo <code>forEach</code> que toma un argumento, llamado el resultado de un m√©todo de <code>map</code> que toma un argumento, llamado el resultado de un m√©todo de <code>filter</code> que toma un argumento, llamado el resultado de un m√©todo de <code>stream</code> que toma cero argumentos, invocados en un objeto <code>List</code> . </blockquote><p>  Toda esta informaci√≥n est√° disponible en el archivo actual y, por lo tanto, se puede colocar en el √≠ndice.  Mientras buscamos, solicitamos dicha informaci√≥n sobre todas las lambdas del √≠ndice e intentamos restaurar el tipo de lambda sin construir un PSI.  Primero, tendremos que realizar una b√∫squeda global de clases con el nombre corto de <code>List</code> .  Obviamente, encontraremos no solo <code>java.util.List</code> sino tambi√©n <code>java.awt.List</code> o algo del c√≥digo del proyecto.  A continuaci√≥n, todas estas clases pasar√°n por el mismo procedimiento de inferencia de tipo aproximado que usamos antes.  Las clases redundantes a menudo se filtran r√°pidamente.  Por ejemplo, <code>java.awt.List</code> no tiene m√©todo de <code>stream</code> , por lo tanto, se excluir√°.  Pero incluso si queda algo redundante y encontramos varios candidatos para el tipo lambda, es probable que ninguno de ellos coincida con la consulta de b√∫squeda, y seguiremos evitando construir una PSI completa. </p><br><p>  La b√∫squeda global podr√≠a resultar demasiado costosa (cuando un proyecto contiene demasiadas clases de <code>List</code> ), o el comienzo de la cadena no podr√≠a resolverse en el contexto de un archivo (por ejemplo, es un campo de una clase principal), o el la cadena podr√≠a romperse ya que el m√©todo devuelve un par√°metro gen√©rico.  No nos rendiremos e intentaremos comenzar de nuevo con la b√∫squeda global del pr√≥ximo m√©todo de la cadena.  Por ejemplo, para la <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> , la siguiente instrucci√≥n va al √≠ndice: </p><br><blockquote>  Este tipo lambda es el tipo del par√°metro √∫nico de un m√©todo <code>updateAndGet</code> , invocado en el resultado de un m√©todo <code>get</code> con un par√°metro, invocado en un objeto <code>Map</code> . </blockquote><p>  Imagina que tenemos suerte, y el proyecto solo tiene un tipo de <code>Map</code> <code>java.util.Map</code> .  Tiene un m√©todo <code>get(Object)</code> , pero, desafortunadamente, devuelve un par√°metro gen√©rico <code>V</code>  Luego descartaremos la cadena y buscaremos el m√©todo <code>updateAndGet</code> con un par√°metro globalmente (usando el √≠ndice, por supuesto).  Y nos complace descubrir que solo hay tres m√©todos de este tipo en el proyecto: en las <code>AtomicInteger</code> , <code>AtomicLong</code> y <code>AtomicReference</code> con los tipos de par√°metros <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> y <code>UnaryOperator</code> , respectivamente.  Si estamos buscando otro tipo, ya hemos descubierto que este lambda no coincide con la solicitud, y no tenemos que construir la PSI. </p><br><p>  Sorprendentemente, este es un buen ejemplo de una caracter√≠stica que funciona m√°s lentamente con el tiempo.  Por ejemplo, cuando busca implementaciones de una interfaz funcional y solo tiene tres de ellas en su proyecto, IntelliJ IDEA tarda diez segundos en encontrarlas.  Recuerde que hace tres a√±os su n√∫mero era el mismo, pero el IDE le proporcion√≥ los resultados de b√∫squeda en solo dos segundos en la misma m√°quina.  Y aunque su proyecto es enorme, solo ha crecido un cinco por ciento en estos a√±os.  Es razonable comenzar a quejarse de lo que los desarrolladores de IDE han hecho mal para hacerlo tan terriblemente lento. </p><br><p>  Si bien podr√≠amos no haber cambiado nada en absoluto.  La b√∫squeda funciona igual que hace tres a√±os.  El caso es que hace tres a√±os, simplemente cambiaste a Java 8 y solo ten√≠as cien lambdas en tu proyecto.  Por ahora, sus colegas han convertido las clases an√≥nimas en lambdas, han comenzado a usar secuencias o alguna biblioteca reactiva.  Como resultado, en lugar de cien lambdas, hay diez mil.  Y ahora, para encontrar los tres necesarios, el IDE tiene que buscar entre cien veces m√°s opciones. </p><br><p>  Dije "podr√≠amos" porque, naturalmente, volvemos a esta b√∫squeda de vez en cuando e intentamos acelerarla.  Pero es como remar el arroyo, o m√°s bien subir la cascada.  Nos esforzamos mucho, pero la cantidad de lambdas en los proyectos sigue creciendo muy r√°pido. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451754/">https://habr.com/ru/post/451754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451742/index.html">Un d√≠a antes de DotNext 2019 Piter. Anuncio de transmisi√≥n gratuita</a></li>
<li><a href="../451746/index.html">MegaSlerm para ingenieros y arquitectos Kubernetes</a></li>
<li><a href="../451748/index.html">Supervisi√≥n del estado de SSD en matrices Qsan</a></li>
<li><a href="../451750/index.html">Libro "Elasticsearch, Kibana, Logstash y los motores de b√∫squeda de la pr√≥xima generaci√≥n"</a></li>
<li><a href="../451752/index.html">30 aniversario de la inseguridad desenfrenada</a></li>
<li><a href="../451758/index.html">Enlaces adicionales en la arquitectura l√≥gica del sistema Intel C620</a></li>
<li><a href="../451760/index.html">Uso de Golang para crear microservicios en The Economist: una retrospectiva</a></li>
<li><a href="../451766/index.html">Heisenbug 2019 Piter: lo que suceder√° en la transmisi√≥n gratuita y qu√© solo en el evento</a></li>
<li><a href="../451768/index.html">Mejorando el trabajo de Wi-Fi. Principios generales y cosas √∫tiles.</a></li>
<li><a href="../451770/index.html">Veeam Backup & Replication: consejos √∫tiles para hacer viables las copias de seguridad y r√©plicas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>