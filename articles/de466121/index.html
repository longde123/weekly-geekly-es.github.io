<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïå üö¥üèº üñ±Ô∏è Klangerzeugung auf AVR-Mikrocontrollern mithilfe der Wavetable-Methode mit Polyphonieunterst√ºtzung ü§õüèº üê≤ üëÇüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AVR-Mikrocontroller sind ziemlich billig und weit verbreitet. Wahrscheinlich beginnt fast jeder eingebettete Entwickler mit ihnen. Und unter Amateuren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klangerzeugung auf AVR-Mikrocontrollern mithilfe der Wavetable-Methode mit Polyphonieunterst√ºtzung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466121/">  AVR-Mikrocontroller sind ziemlich billig und weit verbreitet.  Wahrscheinlich beginnt fast jeder eingebettete Entwickler mit ihnen.  Und unter Amateuren regiert der Arduino den Ball, dessen Herz normalerweise der ATmega328p ist.  Sicherlich fragten sich viele: Wie k√∂nnen Sie sie klingen lassen? <br><br>  Wenn Sie sich vorhandene Projekte ansehen, gibt es verschiedene Arten von Projekten: <br><br><ol><li>  Rechteckimpulsgeneratoren.  Generieren Sie mit PWM oder Ruck-Pins in Interrupts.  In jedem Fall wird ein sehr charakteristisches Quietschger√§usch erhalten. </li><li>  Verwendung externer Ger√§te wie eines MP3-Decoders. </li><li>  Verwenden von PWM zur Ausgabe von 8-Bit-Sound (manchmal 16-Bit) im PCM- oder ADPCM-Format.  Da der Speicher in den Mikrocontrollern daf√ºr eindeutig nicht ausreicht, verwenden sie normalerweise eine SD-Karte. </li><li>  Verwenden von PWM zur Erzeugung von Sound basierend auf Wave-Tabellen wie MIDI. </li></ol><br>  Letzterer Typ war f√ºr mich besonders interessant, weil  erfordert fast keine zus√§tzliche Ausr√ºstung.  Ich pr√§sentiere meine Option der Community.  Zun√§chst eine kleine Demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Interessiert frage ich nach Katze. <br><a name="habracut"></a><br>  Also die Ausr√ºstung: <br><br><ul><li>  ATmega8 oder ATmega328.  Die Portierung auf andere ATmega ist nicht schwierig.  Und sogar auf ATtiny, aber dazu sp√§ter mehr; </li><li>  Widerstand; </li><li>  Kondensator; </li><li>  Lautsprecher oder Kopfh√∂rer; </li><li>  Ern√§hrung; </li></ul><br>  Wie alles. <br><br>  Eine einfache RC-Schaltung mit einem Lautsprecher ist an den Ausgang des Mikrocontrollers angeschlossen.  Der Ausgang ist ein 8-Bit-Sound mit einer Abtastfrequenz von 31250 Hz.  Bei einer Kristallfrequenz von 8 MHz k√∂nnen bis zu 5 Klangkan√§le + ein Rauschkanal f√ºr Percussion erzeugt werden.  In diesem Fall wird fast die gesamte Prozessorzeit verwendet, aber nach dem F√ºllen des Puffers kann der Prozessor zus√§tzlich zum Sound mit etwas N√ºtzlichem besch√§ftigt werden: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JwqY7FoxYsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dieses Beispiel passt vollst√§ndig in den ATmega8-Speicher, 5 Kan√§le + Rauschen werden mit einer Kristallfrequenz von 8 MHz verarbeitet und es bleibt wenig Zeit f√ºr Animationen auf dem Display. <br><br>  In diesem Beispiel wollte ich auch zeigen, dass die Bibliothek nicht nur als normale Musikpostkarte verwendet werden kann, sondern auch, um Sound mit vorhandenen Projekten zu verbinden, beispielsweise f√ºr Benachrichtigungen.  Und selbst wenn Sie nur einen Soundkanal verwenden, k√∂nnen Benachrichtigungen viel interessanter sein als ein einfacher Hocht√∂ner. <br><br>  Und jetzt die Details ... <br><br><h2>  Wave-Tabellen oder Wavetables </h2><br>  Die Mathematik ist sehr einfach.  Es gibt eine periodische <i>Tonfunktion</i> , zum Beispiel <i>Ton (t) = sin (t * freq / (2 * Pi))</i> . <br><br>  Es gibt auch eine Funktion zum √Ñndern der Lautst√§rke des Grundtons im Laufe der Zeit, zum Beispiel <i>Lautst√§rke (t) = e ^ (- t)</i> . <br><br>  Im einfachsten Fall ist der Klang eines Instruments das Produkt dieser Funktionen <i>Instrument (t) = Ton (t) * Lautst√§rke (t)</i> : <br><br>  Auf dem Diagramm sieht alles ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/pn/dp/pi/pndppihozomu4ep_fxzcho44xx8.png"><br><br>  Als n√§chstes nehmen wir alle Instrumente, die zu einem bestimmten Zeitpunkt klingen, und fassen sie mit einigen Lautst√§rkefaktoren (Pseudocode) zusammen: <br><br><pre><code class="cmake hljs">for (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; CHANNELS; i++) { value += channels[i].tone(t) * channels[i].volume(t) * channels[i].volume; }</code> </pre> <br>  Das Volumen muss nur so ausgew√§hlt werden, dass kein √úberlauf auftritt.  Und das ist fast alles. <br><br>  Der Rauschkanal funktioniert √§hnlich, jedoch anstelle einer Tonfunktion ein Pseudozufallssequenzgenerator. <br><br>  Percussion ist eine Mischung aus Rauschkanal und Niederfrequenzwelle bei etwa 50-70 Hz. <br>  Nat√ºrlich ist es schwierig, auf diese Weise einen hochwertigen Klang zu erzielen.  Aber wir haben nur 8 Kilobyte f√ºr alles.  Hoffe das kann vergeben werden. <br><br><h2>  Was kann ich aus 8 Bits herausdr√ºcken? </h2><br>  Anfangs habe ich mich auf ATmega8 konzentriert.  Ohne externen Quarz arbeitet es mit einer Frequenz von 8 MHz und verf√ºgt √ºber eine 8-Bit-PWM, die eine Basisabtastfrequenz von 8000000/256 = 31250 Hz ergibt.  Ein Timer verwendet PWM zur Tonausgabe und verursacht eine Unterbrechung w√§hrend des √úberlaufs, um den n√§chsten Wert an den PWM-Generator zu √ºbertragen.  Dementsprechend haben wir 256 Taktzyklen zur Berechnung des Sample-Werts f√ºr alles, einschlie√ülich Interrupt-Overhead, Aktualisierung der Soundkanalparameter, Verfolgung der Zeit, zu der Sie die n√§chste Note spielen m√ºssen usw. <br><br>  Zur Optimierung werden wir die folgenden Tricks aktiv anwenden: <br><br><ul><li>  Da wir einen 8-Bit-Prozessor haben, werden wir versuchen, die Variablen gleich zu machen.  Manchmal verwenden wir 16 Bit. </li><li>  Berechnungen werden bedingt in h√§ufig und nicht so unterteilt.  Die ersten m√ºssen f√ºr jede Probe berechnet werden, die zweite - viel seltener alle paar zehn / hundert Proben. </li><li>  Um die Last gleichm√§√üig √ºber die Zeit zu verteilen, verwenden wir einen Ringpuffer.  In der Hauptschleife des Programms f√ºllen wir den Puffer und subtrahieren ihn im Interrupt.  Wenn alles in Ordnung ist, f√ºllt sich der Puffer schneller als er sich leert und wir haben Zeit f√ºr etwas anderes. </li><li>  Der Code ist in C mit viel Inline geschrieben.  Die Praxis zeigt, dass es so viel schneller geht. </li><li>  Alles, was der Pr√§prozessor berechnen kann, insbesondere unter Beteiligung der Division, wird vom Pr√§prozessor erledigt. </li></ul><br>  Teilen Sie zuerst die Zeit in Intervalle von 4 Millisekunden (ich habe sie Ticks genannt).  Bei einer Abtastfrequenz von 31250 Hz erhalten wir 125 Abtastwerte pro Tick.  Die Tatsache, dass jede Probe gelesen werden muss, muss bei jeder Probe gez√§hlt werden, und der Rest - einmal pro Tick oder weniger.  Zum Beispiel ist die Lautst√§rke des Instruments innerhalb eines <i>Ticks</i> konstant: <i>Instrument (t) = Ton (t) * currentVolume</i> ;  und currentVolume selbst werden einmal pro Tick unter Ber√ºcksichtigung der Lautst√§rke (t) und der ausgew√§hlten Lautst√§rke des Soundkanals neu berechnet. <br><br>  Eine Tick-Dauer von 4 ms wurde basierend auf einer einfachen 8-Bit-Grenze gew√§hlt: Mit einem 8-Bit-Abtastz√§hler k√∂nnen Sie mit einer Abtastfrequenz von bis zu 64 kHz arbeiten, mit einem 8-Bit-Tick-Z√§hler k√∂nnen wir die Zeit bis zu 1 Sekunde messen. <br><br><h2>  Etwas Code </h2><br>  Der Kanal selbst wird durch diese Struktur beschrieben: <br><br><pre> <code class="cmake hljs">typedef struct { // Info about wave const int8_t* waveForm; // Wave table array uint16_t waveSample; // High byte is an index in waveForm array uint16_t waveStep; // Frequency, how waveSample is changed in time // Info about volume envelope const uint8_t* volumeForm; // Array of volume change in time uint8_t volumeFormLength; // Length of volumeForm uint8_t volumeTicksPerSample; // How many ticks should pass before index of volumeForm is changed uint8_t volumeTicksCounter; // Counter for volumeTicksPerSample // Info about volume uint8_t currentVolume; // Precalculated volume for current tick uint8_t instrumentVolume; // Volume of channel } waveChannel;</code> </pre> <br>  Bedingt sind die Daten hier in 3 Teile unterteilt: <br><br><ol><li>  Informationen zu Wellenform, Phase, Frequenz. <br><br>  WaveForm: Informationen zur Tone (t) -Funktion: Ein Verweis auf ein Array mit einer L√§nge von 256 Bytes.  Legt den Ton und den Instrumentenklang fest. <br><br>  WaveSample: High Byte gibt den aktuellen Index des WaveForm-Arrays an. <br><br>  WaveStep: Legt die Frequenz fest, um die WaveSample beim Z√§hlen des n√§chsten Samples erh√∂ht wird. <br><br>  Jede Probe wird ungef√§hr so ‚Äã‚Äãbetrachtet: <br><br><pre> <code class="cmake hljs">int8_t tone = channelData.waveForm[channelData.waveSample &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>]; channelData.waveSample += channelaData.waveStep; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tone * channelData.currentVolume;</code> </pre> <br></li><li>  Volumeninformationen.  Legt die Funktion zum √Ñndern der Lautst√§rke im Laufe der Zeit fest.  Da sich die Lautst√§rke nicht so oft √§ndert, k√∂nnen Sie sie einmal pro Tick seltener nachz√§hlen.  Dies geschieht folgenderma√üen: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((channel-&gt;volumeTicksCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; channel-&gt;volumeFormLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { channel-&gt;volumeTicksCounter = channel-&gt;volumeTicksPerSample; channel-&gt;volumeFormLength--; channel-&gt;volumeForm++; } channel-&gt;currentVolume = channel-&gt;volumeForm * channel-&gt;instrumentVolume &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br></li><li>  Legt die Lautst√§rke des Kanals und die berechnete aktuelle Lautst√§rke fest. <br></li></ol><br>  Bitte beachten Sie: Die Wellenform ist acht Bit, die Lautst√§rke ist ebenfalls acht Bit und das Ergebnis ist 16 Bit.  Mit einem leichten Leistungsverlust k√∂nnen Sie den Sound (fast) 16 Bit erzeugen. <br><br>  Im Kampf um Produktivit√§t musste ich auf schwarze Magie zur√ºckgreifen. <br><br>  Beispiel Nummer 1. So berechnen Sie die Lautst√§rke der Kan√§le neu: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tickSampleCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //    tickSampleCounter = SAMPLES_PER_TICK ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; //   - } // volume recalculation should no be done so often for all channels <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickSampleCounter &lt; CHANNELS_SIZE) { recalculateVolume(channels[tickSampleCounter]); }</code> </pre> <br>  Somit z√§hlen alle Kan√§le die Lautst√§rke einmal pro Tick, jedoch nicht gleichzeitig. <br><br>  Beispiel Nummer 2. Das Speichern von Kanalinformationen in einer statischen Struktur ist billiger als in einem Array.  Ohne auf Details der Implementierung von wavechannel.h einzugehen, m√∂chte ich sagen, dass diese Datei mehrmals (entsprechend der Anzahl der Kan√§le) mit unterschiedlichen Pr√§prozessoranweisungen in den Code eingef√ºgt wird.  Jede Einf√ºgung erstellt neue globale Variablen und eine neue Kanalberechnungsfunktion, die dann in den Hauptcode integriert wird: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#if CHANNELS_SIZE &gt;= 1 val += channel0NextSample(); #endif #if CHANNELS_SIZE &gt;= 2 val += channel1NextSample(); #endif ‚Ä¶</span></span></code> </pre><br>  Beispiel Nummer 3. Wenn wir etwas sp√§ter mit dem Spielen der n√§chsten Note beginnen, wird es niemand bemerken.  Stellen wir uns die Situation vor: Wir haben den Prozessor mit etwas aufgenommen und w√§hrend dieser Zeit war der Puffer fast leer.  Dann fangen wir an, es zu f√ºllen und pl√∂tzlich stellt sich heraus, dass eine neue Ma√ünahme kommt: Wir m√ºssen die aktuellen Notizen aktualisieren, aus dem Array lesen, was als n√§chstes kommt usw.  Wenn wir keine Zeit haben, kommt es zu charakteristischen Stottern.  Es ist viel besser, den Puffer ein wenig mit alten Daten zu f√ºllen und erst dann den Status der Kan√§le zu aktualisieren. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((samplesToWrite) &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { //          fillBuffer(SAMPLES_PER_TICK); //     -  updateMusicData(); //    }</code> </pre> <br>  Auf eine gute Weise w√§re es notwendig, den Puffer nach der Schleife wieder aufzuf√ºllen, aber da wir fast alles inline haben, ist die Codegr√∂√üe merklich aufgeblasen. <br><br><h2>  Musik </h2><br>  Ein 8-Bit-Tick-Z√§hler wird verwendet.  Wenn Null erreicht ist, beginnt ein neuer Takt, dem Z√§hler wird die Dauer des Takts zugewiesen (in Ticks), etwas sp√§ter wird das Array von Musikbefehlen √ºberpr√ºft. <br><br>  Die Musikdaten werden in einem Array von Bytes gespeichert.  Es ist ungef√§hr so ‚Äã‚Äãgeschrieben: <br><br><pre> <code class="cmake hljs">const uint8_t demoSample[] PROGMEM = { DATA_TEMPO(<span class="hljs-number"><span class="hljs-number">160</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> beats per minute DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_PLAY(<span class="hljs-number"><span class="hljs-number">0</span></span>, NOTE_A4, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A4 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_PLAY(<span class="hljs-number"><span class="hljs-number">1</span></span>, NOTE_A3, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A3 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_WAIT(<span class="hljs-number"><span class="hljs-number">63</span></span>), // Wait <span class="hljs-number"><span class="hljs-number">63</span></span> beats DATA_END() // End of data stream };</code> </pre> <br>  Alles, was mit DATA_ beginnt, sind Pr√§prozessormakros, die die Parameter auf die erforderliche Anzahl von Datenbytes erweitern. <br><br>  Beispielsweise wird der Befehl DATA_PLAY auf 2 Bytes erweitert, in denen gespeichert sind: die Befehlsmarkierung (1 Bit), die Pause vor dem n√§chsten Befehl (3 Bit), die Kanalnummer, auf der die Note gespielt werden soll (4 Bit), Informationen √ºber die Note (8 Bit).  Die wichtigste Einschr√§nkung besteht darin, dass dieser Befehl nicht f√ºr lange Pausen mit maximal 7 Takten verwendet werden kann.  Wenn Sie mehr ben√∂tigen, m√ºssen Sie den Befehl DATA_WAIT verwenden (bis zu 63 Kennzahlen).  Leider habe ich nicht gefunden, ob das Makro je nach Makroparameter auf eine andere Anzahl von Bytes des Arrays erweitert werden kann.  Und selbst Warnung, ich wei√ü nicht, wie ich anzeigen soll.  Vielleicht sagst du es mir. <br><br><h2>  Verwenden Sie </h2><br>  Im Demo-Verzeichnis gibt es mehrere Beispiele f√ºr verschiedene Mikrocontroller.  Aber kurz gesagt, hier ist ein St√ºck aus der Readme-Datei, ich habe wirklich nichts hinzuzuf√ºgen: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "../../microsound/devices/atmega8timer1.h" #include "../../microsound/micromusic.h" // Make some settings #define CHANNELS_SIZE 5 #define SAMPLES_SIZE 16 #define USE_NOISE_CHANNEL initMusic(); // Init music data and sound control sei(); // Enable interrupts, silence sound should be generated setSample(0, instrument1); // Use instrument1 as sample 0 setSample(1, instrument2); // Init all other instruments‚Ä¶ playMusic(mySong); // Start playing music at pointer mySong while (!isMusicStopped) { fillMusicBuffer(); // Fill music buffer in loop // Do some other stuff }</span></span></code> </pre> <br>  Wenn Sie neben Musik noch etwas anderes machen m√∂chten, k√∂nnen Sie den Puffer mit BUFFER_SIZE vergr√∂√üern.  Die Puffergr√∂√üe sollte 2 ^ n betragen, aber leider tritt bei einer Gr√∂√üe von 256 eine Leistungsverschlechterung auf.  Bis ich es herausgefunden habe. <br><br>  Um die Produktivit√§t zu steigern, k√∂nnen Sie die Frequenz mit externem Quarz erh√∂hen, die Anzahl der Kan√§le verringern und die Abtastfrequenz verringern.  Mit dem letzten Trick k√∂nnen Sie eine lineare Interpolation verwenden, die den Abfall der Klangqualit√§t etwas kompensiert. <br><br>  Eine Verz√∂gerung wird nicht empfohlen, da  CPU-Zeit wird verschwendet.  Stattdessen ist eine eigene Methode in der <i>Datei microsound / delay.h</i> implementiert, die zus√§tzlich zur Pause selbst am F√ºllen des Puffers beteiligt ist.  Diese Methode funktioniert bei kurzen Pausen m√∂glicherweise nicht sehr genau, bei langen Pausen jedoch mehr oder weniger vern√ºnftig. <br><br><h2>  Mach deine eigene Musik </h2><br>  Wenn Sie Befehle manuell schreiben, m√ºssen Sie in der Lage sein, zuzuh√∂ren, was passiert.  Das Eingie√üen jeder √Ñnderung in den Mikrocontroller ist nicht bequem, insbesondere wenn es eine Alternative gibt. <br><br>  Es gibt einen ziemlich lustigen Dienst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wavepot.com</a> - einen Online-JavaScript-Editor, in dem Sie von Zeit zu Zeit die Funktion des Tonsignals einstellen m√ºssen, und dieses Signal wird an die Soundkarte ausgegeben.  Das einfachste Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dsp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.1</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * t * <span class="hljs-number"><span class="hljs-number">440</span></span>); }</code> </pre> <br>  Ich habe die Engine auf JavaScript portiert, sie befindet sich in <i>demos / wavepot.js</i> .  Der Inhalt der Datei muss in den Editor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wavepot.com</a> eingef√ºgt werden und Sie k√∂nnen Experimente durchf√ºhren.  Wir schreiben unsere Daten in das SoundData-Array, h√∂ren zu, vergessen nicht zu speichern. <br><br>  Wir sollten auch die Variable simulate8bits erw√§hnen.  Sie simuliert laut Namen einen Acht-Bit-Sound.  Wenn pl√∂tzlich das Schlagzeug summt und in ged√§mpften Instrumenten Ger√§usche mit leisem Klang auftreten, dann ist dies eine Verzerrung eines Acht-Bit-Klangs.  Sie k√∂nnen versuchen, diese Option zu deaktivieren und auf den Unterschied zu achten.  Das Problem ist viel weniger auff√§llig, wenn die Musik keine Stille enth√§lt. <br><br><h2>  Verbindung </h2><br>  In einer einfachen Version sieht die Schaltung folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VC | R1 | Pin+---/\/\--+-----&gt; OUT | | | +---+GN | === C1 | +-------+ | | | --- Grnd --- Grnd</code> </pre> <br>  Der Ausgangspin h√§ngt vom Mikrocontroller ab.  Der Widerstand R1 und der Kondensator C1 m√ºssen basierend auf der Last, dem Verst√§rker (falls vorhanden) usw. ausgew√§hlt werden.  Ich bin kein Elektronikingenieur und gebe keine Formeln an. Sie lassen sich zusammen mit Online-Taschenrechnern leicht googeln. <br><br>  Ich habe R1 = 130 Ohm, C1 = 0,33 uF.  An den Ausgang schlie√üe ich gew√∂hnliche chinesische Kopfh√∂rer an. <br><br><h2>  Was war mit 16-Bit-Sound? </h2><br>  Wie ich oben sagte, erhalten wir beim Multiplizieren von zwei Acht-Bit-Zahlen (Frequenz und Lautst√§rke) eine 16-Bit-Zahl.  Sie k√∂nnen es nicht auf acht Bits runden, sondern beide Bytes in 2 PWM-Kan√§len ausgeben.  Wenn Sie diese beiden Kan√§le im Verh√§ltnis 1/256 mischen, erhalten Sie 16-Bit-Sound.  Der Unterschied zum Acht-Bit ist besonders leicht zu erkennen, wenn Sounds und Drums in Momenten, in denen nur ein Instrument erklingt, sanft verblassen. <br><br>  16-Bit-Ausgangsverbindung: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VCC | R1 | PinH+---/\/\--+-----&gt; OUT | | | | | R2 | | PinL+---/\/\--+ +---+GND | | | +-------+ === C1 | | --- Grnd --- Grnd</code> </pre> <br>  Es ist wichtig, die 2 Ausg√§nge richtig zu mischen: Der R2-Widerstand sollte 256-mal gr√∂√üer sein als der R1-Widerstand.  Je genauer, desto besser.  Leider liefern selbst Widerst√§nde mit einem Fehler von 1% nicht die erforderliche Genauigkeit.  Selbst bei einer nicht sehr genauen Auswahl von Widerst√§nden kann die Verzerrung merklich ged√§mpft werden. <br><br>  Leider verschlechtert sich bei Verwendung von 16-Bit-Sound die Leistung und 5 Kan√§le + Rauschen haben in den zugewiesenen 256 Taktzyklen keine Zeit mehr f√ºr die Verarbeitung. <br><br><h2>  Ist es auf Arduino m√∂glich? </h2><br>  Ja, das kannst du.  Ich habe nur einen chinesischen Nano-Klon auf ATmega328p, er funktioniert darauf.  H√∂chstwahrscheinlich sollten auch andere Arduine auf dem ATmega328p funktionieren.  Der ATmega168 scheint die gleichen Timer-Steuerregister zu haben.  H√∂chstwahrscheinlich werden sie unver√§ndert funktionieren.  Bei anderen Mikrocontrollern, die Sie √ºberpr√ºfen m√ºssen, m√ºssen Sie m√∂glicherweise einen Treiber hinzuf√ºgen. <br><br>  In <i>demos / arduino328p</i> gibt es eine Skizze, aber damit sie in der Arduino IDE normal ge√∂ffnet werden kann, m√ºssen Sie sie in das Stammverzeichnis des Projekts kopieren. <br><br>  In diesem Beispiel wird 16-Bit-Sound erzeugt und die Ausg√§nge D9 und D10 werden verwendet.  Zur Vereinfachung k√∂nnen Sie sich auf 8-Bit-Sound beschr√§nken und nur einen D9-Ausgang verwenden. <br><br>  Da fast alle Arduine mit 16 MHz arbeiten, k√∂nnen Sie auf Wunsch die Anzahl der Kan√§le auf 8 erh√∂hen. <br><br><h2>  Was ist mit ATtiny? </h2><br>  ATtiny hat keine Hardware-Multiplikation.  Die vom Compiler verwendete Softwaremultiplikation ist √§u√üerst langsam und wird am besten vermieden.  Bei Verwendung optimierter Assembler-Eins√§tze sinkt die Leistung im Vergleich zu ATmega um das Zweifache.  Es scheint, dass es keinen Sinn macht, ATtiny √ºberhaupt zu verwenden, aber ... <br><br>  Einige ATtiny haben einen Frequenzvervielfacher, PLL.  Und das bedeutet, dass es bei solchen Mikrocontrollern zwei interessante Funktionen gibt: <br><br><ol><li>  Die Frequenz des PWM-Generators betr√§gt 64 MHz, was eine PWM-Periode von 250 kHz ergibt, was viel besser ist als 31 250 Hz bei 8 MHz oder 62500 Hz mit Quarz bei 16 MHz bei jedem ATmega. </li><li>  Mit dem gleichen Frequenzvervielfacher kann der Kristall ohne Quarz mit 16 MHz takten. </li></ol><br>  Daher die Schlussfolgerung: Einige ATtiny k√∂nnen verwendet werden, um Ton zu erzeugen.  Sie schaffen es, die gleichen 5 Instrumente + Rauschkanal zu verarbeiten, jedoch bei 16 MHz, und sie ben√∂tigen keinen externen Quarz. <br><br>  Der Nachteil ist, dass die Frequenz nicht mehr erh√∂ht werden kann und die Berechnungen fast immer dauern.  Um Ressourcen freizugeben, k√∂nnen Sie die Anzahl der Kan√§le oder die Abtastrate reduzieren. <br><br>  Ein weiteres Minus ist die Notwendigkeit, zwei Timer gleichzeitig zu verwenden: einen f√ºr PWM und einen f√ºr Unterbrechungen.  Hier enden normalerweise die Timer. <br><br>  Von den mir bekannten PLL-Mikrocontrollern kann ich ATtiny85 / 45/25 (8 Beine), ATtiny861 / 461/261 (20 Beine), ATtiny26 (20 Beine) erw√§hnen. <br><br>  Was den Speicher betrifft, ist der Unterschied zu ATmega nicht gro√ü.  In 8kb passen mehrere Instrumente und Melodien perfekt.  In 4kb k√∂nnen Sie 1-2 Instrumente und 1-2 Melodien setzen.  Es ist schwer, etwas in 2 Kilobyte zu packen, aber wenn Sie wirklich wollen, dann k√∂nnen Sie.  Es ist notwendig, die Methoden zu trennen, einige Funktionen wie die Lautst√§rkeregelung √ºber die Kan√§le zu deaktivieren, die Abtastfrequenz und die Anzahl der Kan√§le zu reduzieren.  Im Allgemeinen f√ºr einen Amateur, aber es gibt ein funktionierendes Beispiel f√ºr ATtiny26. <br><br><h2>  Die Probleme </h2><br>  Es gibt Probleme.  Das gr√∂√üte Problem ist die Rechengeschwindigkeit.  Der Code ist vollst√§ndig in C mit kleinen Assembler-Multiplikationseins√§tzen f√ºr ATtiny geschrieben.  Der Compiler wird optimiert und verh√§lt sich manchmal seltsam.  Mit kleinen √Ñnderungen, die nichts zu beeinflussen scheinen, kann es zu einer sp√ºrbaren Leistungsminderung kommen.  Dar√ºber hinaus hilft der Wechsel von -Os zu -O3 nicht immer.  Ein solches Beispiel ist die Verwendung eines 256-Byte-Puffers.  Besonders unangenehm ist, dass es keine Garantie daf√ºr gibt, dass in neuen Versionen des Compilers bei demselben Code keine Leistungseinbu√üen auftreten. <br><br>  Ein weiteres Problem besteht darin, dass der D√§mpfungsmechanismus vor der n√§chsten Note √ºberhaupt nicht implementiert ist.  Das hei√üt,  Wenn auf einem Kanal eine Note durch eine andere ersetzt wird, wird der alte Ton abrupt unterbrochen, manchmal ist ein kleines Klicken zu h√∂ren.  Ich w√ºrde gerne einen Weg finden, dies loszuwerden, ohne an Leistung zu verlieren, aber bisher. <br><br>  Es gibt keine Befehle zum sanften Erh√∂hen / Verringern der Lautst√§rke.  Dies ist besonders wichtig f√ºr kurze Benachrichtigungsklingelt√∂ne, bei denen Sie am Ende die Lautst√§rke schnell d√§mpfen m√ºssen, damit der Ton nicht scharf unterbrochen wird.  Ein Teil des Problems besteht darin, eine Reihe von Befehlen mit manueller Einstellung der Lautst√§rke und einer kurzen Pause zu schreiben. <br><br>  Der gew√§hlte Ansatz ist im Prinzip nicht in der Lage, den Instrumenten einen naturalistischen Klang zu verleihen.  F√ºr einen nat√ºrlicheren Klang m√ºssen Sie die Kl√§nge der Instrumente in Attack-Sustain-Release unterteilen, mindestens die ersten beiden Teile verwenden und eine viel l√§ngere Dauer als eine Schwingungsperiode haben.  Aber dann brauchen die Daten f√ºr das Tool viel mehr.  Es gab die Idee, k√ºrzere Wellentabellen zu verwenden, beispielsweise in 32 Bytes anstelle von 256, aber ohne Interpolation nimmt die Klangqualit√§t dramatisch ab und mit der Interpolation nimmt die Leistung ab.  Und weitere 8 Bits Sampling reichen f√ºr Musik eindeutig nicht aus, k√∂nnen aber umgangen werden. <br><br>  Die Puffergr√∂√üe ist auf 256 Abtastwerte begrenzt.  Dies entspricht ungef√§hr 8 Millisekunden und dies ist die maximale integrale Zeitspanne, die anderen Aufgaben zugewiesen werden kann.  Gleichzeitig wird die Ausf√ºhrung von Aufgaben immer noch regelm√§√üig durch Unterbrechungen unterbrochen. <br><br>  Das Ersetzen der Standardverz√∂gerung funktioniert bei kurzen Pausen nicht sehr genau. <br><br>  Ich bin sicher, dass dies keine vollst√§ndige Liste ist. <br><br><h2>  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github Link</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PWM-Filterberechnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einige Ideen und eine Demo-Melodie wurden von hier √ºbernommen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466121/">https://habr.com/ru/post/de466121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466105/index.html">√úbertakten der Magento Rest API mit RoadRunner</a></li>
<li><a href="../de466107/index.html">Do-it-yourself-Smart-Home-System</a></li>
<li><a href="../de466109/index.html">Probleml√∂sung mit pwnable.kr 22 - Brainfuck. Ret2libc-Angriff</a></li>
<li><a href="../de466111/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 32. Kennwortwiederherstellung, XODEM / TFTPDNLD und Cisco-Lizenzaktivierung</a></li>
<li><a href="../de466113/index.html">Definieren der Textcodierung in PHP anstelle von mb_detect_encoding</a></li>
<li><a href="../de466123/index.html">Wachstum. Gewicht. Drei Nachbarn</a></li>
<li><a href="../de466127/index.html">KKW Kola oder am Reaktor stehen</a></li>
<li><a href="../de466129/index.html">Effizienz des Transports mit Benzin, Batterien und Wasserstoff</a></li>
<li><a href="../de466135/index.html">Megapack: Wie Factorio-Entwickler es geschafft haben, das 200-Spieler-Multiplayer-Problem zu l√∂sen</a></li>
<li><a href="../de466137/index.html">System.IO. Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>