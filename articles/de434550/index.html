<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏽 🛵 🚶🏻 Die Innenseiten von Retro-Spielen: Punch-Out für NES 🙍🏿 🈲 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 1. Passwörter 
 Das Punch-Out von NES-Spiel Mike Tyson verwendet ein Passwortsystem, mit dem Spieler das Spiel von einem bestimmten Punkt aus for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Innenseiten von Retro-Spielen: Punch-Out für NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434550/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0b/41b/4f2/b0b41b4f285c002424e55b62ff530362.png" alt="Bild"></div><br><h2>  Teil 1. Passwörter </h2><br>  Das Punch-Out von NES-Spiel Mike Tyson verwendet ein Passwortsystem, mit dem Spieler das Spiel von einem bestimmten Punkt aus fortsetzen können.  Jedes Passwort besteht aus 10 Ziffern, die zwischen 0 und 9 liegen können. Das Spiel kann zwei Arten von Passwörtern akzeptieren, die ich als "normale" und "spezielle" Passwörter bezeichne.  Spezielle Passwörter sind bestimmte Kombinationen von 10 Ziffern, auf deren Eingabe das Spiel auf einzigartige Weise reagiert.  Eine vollständige Liste spezieller Passwörter sieht folgendermaßen aus: <br><br><ul><li>  075 541 6113 - Besetztzeichen 1 </li><li>  800 422 2602 - Besetztzeichen 2 </li><li>  206 882 2040 - Besetztzeichen 3 </li><li>  135 792 4680 - Spiel in einem versteckten Turnier: "Another World Circuit" (damit das Passwort akzeptiert wird, müssen Sie die Auswahltaste gedrückt halten und A + B drücken) </li><li>  106 113 0120 - Anzeige der Titel (damit das Passwort akzeptiert wird, müssen Sie die Auswahltaste gedrückt halten und A + B drücken) </li><li>  007 373 5963 - versetzt den Spieler in den Kampf mit Mike Tyson </li></ul><br>  Die zweite Art von Passwörtern, die vom Spiel akzeptiert werden, sind reguläre Passwörter.  In regulären Passwörtern wird der Fortschritt, den der Spieler im Spiel gemacht hat, verschlüsselt.  Die folgenden Spieldaten sind in einem regulären Passwort verschlüsselt: <br><br><ul><li>  Anzahl der Karrieregewinne </li><li>  Anzahl der Karriereverluste </li><li>  Knockout gewinnt </li><li>  Nächster Gegner </li></ul><br><h2>  Passwortcodierung </h2><br>  Um beispielsweise die Passwortgenerierung zu untersuchen, verwenden wir ein Spiel mit 24 Siegen, 1 Niederlage, 19 Ausscheidungswettkämpfen und beginnen das Weltturnier mit einem Kampf gegen Super Macho Man. <br><a name="habracut"></a><br>  Der Vorgang des Codierens des Status eines Spiels in einem Passwort beginnt mit dem Sammeln der Anzahl von Gewinnen, Verlusten und Knockouts im Puffer.  Das Spiel präsentiert jede Zahl in Form eines <a title="Binärcodierte Dezimalstelle" href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">binären Dezimalcodes</a> , der aus 8 Bits pro Ziffer und 2 Ziffern für jeden Wert besteht.  Das heißt, für 24 Siege benötigen Sie ein Byte mit einem Wert von 2 und ein zweites Byte mit einem Wert von 4. Dasselbe gilt für Paare von Bytes für Verluste und Knockouts, dh es werden insgesamt 6 Bytes Daten erhalten.  In der folgenden Abbildung sind diese 6 Bytes mit dezimalen und binären Werten angegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/489/fab/198/489fab1987ec36a598e9f53353ddab14.png"></div><br>  Der nächste Schritt besteht darin, eine Prüfsumme für diese 6 Bytes zu generieren.  Das Prüfsummenbyte wird berechnet, indem 6 separate Bytes addiert und das Ergebnis von 255 subtrahiert werden. In unserem Fall 2 + 4 + 0 + 1 + 1 + 9 = 17, dh 255 - 17 = 238. <br><br>  Dann schreiben wir ein paar Bits von 6 Bytes in einen neuen Puffer.  Dieser Puffer kann als ein 28-Bit-Zwischenwert interpretiert werden, den wir Schritt für Schritt ausfüllen werden.  Bits aus dem ersten Puffer werden in Zweiergruppen unterteilt und an verschiedene fest codierte Positionen des zweiten Puffers verschoben.  Dies ist der erste von mehreren Schritten, deren einzige Aufgabe darin besteht, die Daten einfach zu verschleiern, um das Generieren von Passwörtern für Spieler zu erschweren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/41d/366/36941d366047379b7279a42b1305ea86.png"></div><br>  Beachten Sie, dass nicht alle Bits aus dem ursprünglichen Puffer in den neuen Zwischenpuffer übertragen werden.  Diese Bits werden ignoriert, da bekannt ist, dass sie immer 0 sind. Dank der Spielregeln reicht es aus, die Anzahl der Verluste im Passwort mit nur 2 Informationsbits zu übertragen.  Wenn die Gesamtzahl der Verluste 3 erreicht, tritt ein Spielende auf und der Spieler erhält kein Passwort.  Daher reicht es völlig aus, die Anzahl der Verluste mit den Zahlen 0, 1 und 2 zu beschreiben, und dafür reichen nur 2 Bits aus. <br><br>  Dann schreiben wir andere Bitpaare in den Zwischenpuffer.  Die ersten vier Paare werden aus dem zuvor berechneten Prüfsummenwert entnommen.  Ein weiteres Paar wird vom Wert des Feindes genommen.  Der Wert eines Gegners ist eine Zahl, die angibt, gegen welchen Gegner ein Spieler nach Eingabe eines Passworts kämpfen wird.  Drei mögliche feindliche Werte können verwendet werden: <br><br>  0 - DON FLAMENCO (erster Kampf des großen Turniers) <br><br>  1 - PISTON HONDA (erster Kampf des Weltturniers) <br><br>  2 - SUPER MACHO MAN (letzter Kampf des Weltturniers) <br><br>  Da wir ein Passwort generieren wollten, das uns mit Super Macho Man konfrontiert, verwenden wir 2 als Wert des Gegners. Anschließend werden die Prüfsummenbits und die Werte des Gegners wie folgt in die Zwischenbits geschrieben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e5/e6c/b30/0e5e6cb30922b23fc4f27cb10edfa383.png"></div><br>  Der nächste Schritt besteht darin, mehrere zyklische Permutationen der Zwischenbits links durchzuführen.  Eine zyklische Permutation nach links bedeutet, dass alle Bits um eine Position nach links verschoben werden und das am weitesten links liegende Bit sich bewegt und zum am weitesten rechts liegenden wird.  Um die Anzahl der Permutationen auf der linken Seite zu berechnen, nehmen wir die Summe aus dem Wert des Gegners und der Anzahl der Verluste, addieren 1 und dividieren dieses Ergebnis durch 3.  In unserem Fall stellt sich heraus, dass 2 + 1 + 1 = 4. Dann ist der Rest von 4/3 1, sodass wir die Zwischenbits einmal zyklisch nach links verschieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b6/877/748/9b68777488be3ba29882276e1bb9f3be.png"></div><br>  Zu diesem Zeitpunkt sind die Zwischenbits bereits gründlich gemischt und es ist Zeit, sie zu brechen, um die Zahlen zu erhalten, aus denen das Passwort besteht.  Passwörter sollten aus 10 Ziffern bestehen, daher werden 28 Zwischenbits in 10 separate Zahlen aufgeteilt, die wir als Passwortwerte P0, P1, P2 usw. bezeichnen.  Jeder der ersten neun Passwortwerte empfängt 3 Datenbits und der letzte erhält nur eines der Zwischenbits.  Um den fertigen Passwortwert zu vervollständigen, werden wir auch Bits einfügen, die die Anzahl der im vorherigen Schritt durchgeführten Permutationen angeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afe/071/3ee/afe0713eea345b68c5a429b804b146c5.png"></div><br>  Schließlich fügen wir jedem Passwortwert einen eindeutigen, fest codierten Offset hinzu.  Die fertige Passwortziffer ist der Rest dieser Summe aus der Division durch 10. In der siebten Position verwenden wir beispielsweise den Versatz 1, dh wir erhalten 5 + 1 = 6, und die letzte Ziffer ist der Rest von 6/10, dh 6. In der vierten Position verwenden wir Offset 7, das heißt, wir erhalten 5 + 7 = 12, und die endgültige Zahl entspricht dem Rest 12/10, dh 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/767/d3f/f08767d3fb4dff169947863869e2d7db.png"></div><br>  Also haben wir vorgefertigte Passwortziffern bekommen, die im Spiel überprüft werden können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70f/3df/4d4/70f3df4d44e3dee701740b7d1408a8c4.png"></div><br><h2>  Passwortdecodierung </h2><br>  Das Dekodieren von Passwörtern auf die Anzahl der Gewinne / Verluste / Knockouts und den Wert des Gegners ist eine einfache Implementierung in umgekehrter Reihenfolge aller oben beschriebenen Schritte.  Ich werde es den Lesern als Aufgabe überlassen.  Das Spiel weist jedoch zwei bemerkenswerte Fehler auf, die beim Dekodieren und Überprüfen der vom Spieler eingegebenen Passwörter auftreten. <br><br>  Der erste Fehler tritt im allerersten Schritt des Dekodierens des Kennworts auf, dh beim Subtrahieren von Offsets, um zu den Kennwortwerten zurückzukehren.  Die anfänglichen Passwortwerte enthielten jeweils 3 Datenbits, dh ihre Werte vor dem Anwenden von Offsets sollten im Bereich von 0 bis 7 liegen.  Der Spieler kann jedoch ein Passwort eingeben, das nach Abzug des Versatzes einen Passwortwert von 8 oder 9 ergibt (dividiert durch 10 mit dem Rest).  Anstatt ein solches Passwort sofort abzulehnen, überprüft das Spiel diesen Fall fälschlicherweise nicht und ermöglicht es Ihnen, dem Passwortwert ein zusätzliches Datenbit hinzuzufügen, das den Satz von Zwischenbits so verschmutzen kann, dass Passwörter nicht mehr eindeutig sind.  Da bestimmte Zwischenbits entweder mit der entsprechenden Ziffer des Passworts oder mit einem zusätzlichen Bit des benachbarten Passwortwerts gesetzt werden können, gibt es viele Passwörter, die in denselben Satz von Zwischenbits konvertiert werden können.  Aus diesem Grund können Sie verschiedene Passwörter finden, die das gleiche Ergebnis im Spiel liefern, obwohl sie eindeutig sein sollten. <br><br>  Der zweite Fehler ist ein Fehler in der Logik, mit der das Spiel Daten nach dem Entschlüsseln des Passworts überprüft.  Das Spiel versucht, die folgenden Bedingungen anzuwenden: <br><br><ul><li>  Die im Passwort gespeicherte Prüfsumme entspricht der Prüfsumme, die unter Berücksichtigung der Anzahl der im Passwort gespeicherten Gewinne / Verluste / Knockouts erhalten werden soll </li><li>  Verlustwert ist 0, 1 oder 2 </li><li>  Der feindliche Wert ist 0, 1 oder 2 </li><li>  Die Anzahl der im Passwort gespeicherten zyklischen Permutationen ist die richtige Anzahl, wobei der Wert der Verluste und der Wert des im Passwort gespeicherten Gegners berücksichtigt werden </li><li>  Alle im Passwort gespeicherten Gewinn- / Verlust- / Ko-Nummern liegen im Bereich von 0 bis 9 </li><li>  gewinnt&gt; = 3 </li><li>  gewinnt&gt; = Ko </li></ul><br>  Wenn eine dieser Bedingungen nicht erfüllt ist, muss das Spiel das Passwort ablehnen.  Es gibt jedoch einen Fehler bei der Implementierung der Endprüfung (nämlich beim Überprüfen der von BCD codierten Zahlen). Anstatt den Sieg&gt; = Knockouts zu überprüfen, erlaubt das Spiel Fälle, in denen die obere Anzahl der Siege 0, die untere Anzahl der Siege&gt; = 3 und die obere Anzahl der Knockouts kleiner als die untere Anzahl ist gewinnt.  Zum Beispiel wird ein Rekord mit 3 Siegen, 0 Verlusten und 23 Ko-Spielen vom Spiel akzeptiert (was das Passwort 099 837 5823 bestätigt), obwohl er abgelehnt werden sollte (da es unmöglich ist, 23 Kämpfe durch Ko zu gewinnen, wenn Sie in nur 3 Kämpfen gewonnen haben). <br><br><h2>  Fazit </h2><br>  Die besonderen Details eines solchen Codierungsschemas sind nur bei Punch-Out zu finden, aber die allgemeine Idee, wichtige Teile des Spielzustands zu erhalten, sie mit der Möglichkeit der Wiederherstellung zu konvertieren, um den Anfangszustand zu verschleiern, und sie dann zu verwenden, um eine bestimmte Anzahl von Zeichen zu generieren, um dem Spieler als Passwort zu demonstrieren, ist ein ziemlich universeller Ansatz.  Sie können Prüfsummen verwenden, damit versehentliche Kennwortänderungen (z. B. wenn ein Spieler einen Fehler macht) meistens zu dessen Ablehnung führen, anstatt ein anderes Kennwort mit einem zufälligen Spielstatus zu erstellen. <br><br><h2>  Teil 2. Überblick über Punch-Out </h2><br>  Jeder Kämpfer bei Mike Tysons Punch-Out !!!  gesteuert durch ein oder mehrere interpretierte Bytecode-Skripte.  Der Charakter des Spielers, Little Mac, führt ein einfaches Skript aus, das die Logik jeder Aktion enthält, die dem Spieler zur Verfügung steht (Ausweichen, Blockieren, Schlagen usw.). Die Charaktere des Gegners werden von drei Ebenen unabhängiger Skripte gesteuert, die zusammen das Verhalten des Charakters erzeugen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0b/c1e/911/d0bc1e9118006e13ce453f7ed991cead.png"></div><br><h2>  Match-Skript </h2><br>  Das Feindskript der höchsten Ebene wird in allen drei Kampfrunden ausgeführt und steuert die ehrgeizigsten Änderungen im Verhalten des Gegners.  Ich werde dieses Skript "Match-Skript" nennen.  Seine Hauptaufgabe ist es, die Verhaltensweisen auszuwählen, die der Feind als Reaktion auf verschiedene Ereignisse während des Kampfes ausführen wird.  Zum Beispiel beginnt ein bestimmtes Verhalten unmittelbar nach dem Aufstehen des Gegners nach einem Niederschlag oder wenn dem Spieler die Herzen ausgehen und er müde wird.  Diese Verhaltensweisen werden in die Tabelle geschrieben und von der Spiel-Engine als Reaktion auf die entsprechenden Ereignisse aufgerufen.  Das Match-Skript legt auch die Anfangswerte für die Konfigurationsoptionen fest, die sich auf die Komplexität des Kampfes beziehen (z. B. die Zeit, die der Gegner nach einem verpassten Treffer verwundbar bleibt). Schließlich wartet das Match-Skript während des Kampfes auf bestimmte temporäre Markierungen, um Änderungen an den zuvor festgelegten Werten vorzunehmen . <br><br><h2>  Verhaltensskript </h2><br>  Das Skript eines Gegners auf einer niedrigeren Ebene ist ein "Verhaltensskript".  Diese Ebene ist für die Abfolge bestimmter Schläge und Angriffe verantwortlich, die der Gegner im Rahmen des aktuellen Verhaltens ausführen muss (festgelegt durch das Match-Skript). Verhaltensskripte führen Befehle wie „Anwenden des rechten Stoßes, Pause für 28 Frames, zufälliges Anwenden des linken oder rechten Uppercuts, Wiederholen aller es ist 5 mal. "  Das Skript verfügt auch über Befehle zum Lesen und Schreiben an eine beliebige Adresse im Speicher der Spiel-Engine, sodass das Verhalten sehr dynamisch sein kann. <br><br><h2>  Animationsskript </h2><br>  Das Gegner-Skript der untersten Ebene ist ein „Animationsskript“.  Solche Skripte führen die Details jedes einzelnen Treffers, Blocks oder Spezialangriffs als Teil des Verhaltens aus (definiert durch das Verhaltensskript). Auf dieser Ebene können Befehle wie "Sprite 23 dem aktuellen Frame der feindlichen Animation zuweisen, es jedes zweite Frame um 1 Pixel nach unten und rechts verschieben." Ändern Sie für die nächsten 10 Bilder das Animationsbild in Sprite 24 und spielen Sie den Soundeffekt 7 "ab.  Zusätzlich zu Animationsbefehlen führen Animationsskripte auch Sequenzen verschiedener Änderungen der Spielzustände aus, die eng mit den Bewegungen des Feindes zusammenhängen.  In einer langen Animation eines Spezialangriffs kann ein Animationsskript beispielsweise Befehle einfügen, die den Feind mit einem Treffer über einen sehr kurzen Zeitraum für Niederschlag anfällig machen.  Wie Verhaltensskripte können Animationsskripte beliebige Speicheradressen in der Spiel-Engine lesen und schreiben, um dynamischere Effekte zu erzielen. <br><br><h2>  Skript Little Mac </h2><br>  Das vom Charakter des Little Mac-Players ausgeführte Skript ist den feindlichen Animationsskripten am ähnlichsten.  Es ändert den aktuellen Frame der reflektierten Animation und bewegt den Player über den Bildschirm.  Wie Animationsskripte führt das Little Mac-Skript Sequenzen bestimmter Spielereignisse aus, z. B. zu welchem ​​Zeitpunkt der Mac den Feind treffen sollte oder wann er einen Block oder eine Umgehung ausführen sollte.  Das Little Mac-Skript steuert die Eingabe des Players, ähnlich wie Verhaltensskripte feindliche Animationsskripte steuern. <br><br>  Jedes dieser vier Skripte wird von einem eigenen Interpreter verarbeitet.  Obwohl viele von ihnen dieselbe Funktionalität haben, z. B. grundlegende Steuerungssteuerung und direkten Zugriff auf den Speicher, implementiert jedes System seine eigene Version und teilt den gemeinsamen Code (oder den Opcode-Bereich) nicht mit anderen Systemen.  Dadurch kann jeder Skripttyp sehr spezifisch sein und effektiv einen kleinen Satz von Zielbefehlen verwenden.  Skriptdaten machen etwa 22% der nicht grafischen Daten der Spielekassette aus (der Maschinencode für die Spiel-Engine selbst macht nur 17% aus), daher war es sehr wichtig, dass die Skripte ein kompaktes Aussehen haben. <br><br><h2>  Teil 3. Punch-Out-Match-Skript </h2><br>  Das Skript des Spiels steuert das Verhalten des Gegners auf höchster Ebene.  Die Hauptoperation, die er immer wieder ausführt, besteht darin, auf eine bestimmte Zeit der Runde zu warten und in diesem Moment Änderungen an den Konfigurationsdaten des Gegners vorzunehmen.  Das Video zeigt die erste Runde des ersten Kampfes gegen Bald Bull sowie ein Match-Skript, das das Gesamtverhalten steuert. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/99DN0sM9ep8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Es gibt drei Hauptoperationen, die ein Übereinstimmungsskript ausführen kann.  Der erste besteht darin, zu warten, bis der runde Timer einen bestimmten Wert erreicht.  Die zweite ist zu fragen, ob sich das aktuelle Verhalten des Gegners geändert hat.  Verhaltensweisen werden in der Kampfkonfigurationstabelle im Speicher aufgezeichnet und dann zu unterschiedlichen Zeiten von den Match-Skripten und der Spiel-Engine selbst aufgerufen.  Die Tabelle enthält zwei Verhaltenssegmente, die von Übereinstimmungsskripten verwendet werden.  Ich nenne sie "grundlegendes" Verhalten und "spezielles" Verhalten.  Besondere Verhaltensweisen sind beispielsweise ein Bull Charge-Schlag eines Gegners von Bald Bull oder Honda Rush eines Gegners von Piston Honda, und die Hauptverhaltensweisen sind die üblichen Treffer, die der Gegner für den Rest der Zeit liefert.  Die spezifischen Verhaltensskripte, die zur Implementierung dieser Verhaltensweisen verwendet werden, können durch das Match-Skript direkt während des Kampfes geändert werden, sodass die Kämpfer mit einem Hauptverhalten beginnen und später zu einem anderen wechseln können (wie im Video zu sehen ist, tut Bald Bull dies, wenn der Timer 0 erreicht : 20.) <br><br>  Eine Funktion zum Ändern von Verhaltensweisen, die von Match-Skripten ausgeführt werden, besteht darin, dass sie durch Verhaltensänderungen ersetzt werden können, die von der Spiel-Engine angefordert werden.  Die Spiel-Engine verwendet vier Verhaltenssegmente, um neue Verhaltensweisen anzufordern, wenn der Mac alle Herzen verliert und müde wird und wenn der Gegner nach einem Niederschlag aufsteht.  Wenn das Match-Skript die Anforderung zum Ändern des Verhaltens erfüllt hat, aber eines dieser vier Ereignisse der Spiel-Engine auftritt, bevor die Anforderung verarbeitet wird (Anforderungen können nicht verarbeitet werden, bis der Gegner in den Wartezustand wechselt), legt die Spiel-Engine das gewünschte Verhalten fest und die Anforderung für das Match-Skript wird abgelehnt.  Einige Kämpfer, wie beispielsweise Bald Bull, fordern innerhalb kurzer Zeit mehrmals ein besonderes Verhalten.  Dies scheint nur erforderlich zu sein, um die Wahrscheinlichkeit zu verringern, dass eine dieser Anforderungen versehentlich gelöscht wird. <br><br>  Die dritte Hauptoperation des Match-Skripts ist das Patchen des Speichers.  Die meisten Speicher-Patches wirken sich auf die Battle-Konfigurationstabelle aus, in der Verhaltensskripte aufgezeichnet werden.  Zusätzlich zu den Verhaltenssätzen enthält die Tabelle Daten zur Komplexität des Kampfes.  Wenn der Timer im Video beispielsweise 0:30 erreicht, ändert Bald Bull seine Sicherheitseinstellungen.  Dies führt dazu, dass der Spieler ihn nicht länger täuschen kann, indem er nach oben drückt und dann einen Schlag auf den Körper ausführt.  Match-Skripte können außerdem beliebige Speicheradressen patchen, diese Funktion wird jedoch nur einmal verwendet - zu Beginn der zweiten Runde mit Mike Tyson, sodass der Spieler zum ersten Mal einen Stern erhält, wenn er ihn trifft, der sich im Standby-Modus befindet. <br><br><h2>  Teil 4. Punch-Out-Verhaltensskript </h2><br>  Nun betrachten wir Verhaltensskripte, die direkt an der Implementierung von Verhalten beteiligt sind. <br><br>  Das Video zeigt eine Interpretation dessen, wie das konkurrierende Verhaltensskript von Piston Honda 1 in englischen Teams aussehen könnte. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_Q9_7vSLndQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Animationsbefehle </h2><br>  Verhaltensskripte sind für das sequentielle Starten von Animationen verantwortlich, genauso wie Match-Skripte für das Starten von Animationen verantwortlich waren.  Der Befehl <code>anim</code> spielt eine bestimmte Animation ab, und der Befehl <code>anim_rnd</code> führt eine Animation aus, die zufällig aus einer Liste von 8 Optionen ausgewählt wurde.  Im obigen Video wird zum Zeitpunkt einer zufälligen Auswahl aus einer Liste von Optionen die ausgewählte Option vorübergehend rot hervorgehoben.  Wenn Piston Honda seine ersten beiden Stöße ausführt, <code>anim</code> für jeden von ihnen eine <code>anim</code> verwendet.  Danach wählt er mit <code>anim_rnd</code> zufällig aus einem Set mit 6 Hook-Animationen und 2 leeren Animationen.  Infolgedessen hakt er in 75% der Fälle und unternimmt in 25% der Fälle nichts. <br><br>  Aus Sicht des Skripts wird das Verhalten der Animationen synchron abgespielt, da der Skriptinterpreter angehalten wird, wenn sich das Animationssystem nicht im Leerlaufmodus befindet. <br><br><h2>  Ausführungssteuerungsbefehle </h2><br>  Es gibt mehrere Befehle, die die Ausführung des Verhaltensskripts selbst ändern.  <code>pause</code> können die Skriptausführung für eine bestimmte Anzahl von Frames oder für die Anzahl von Frames anhalten, die zufällig aus einer Liste von 2 Optionen ausgewählt wurden. <br><br>  Es gibt verschiedene Verzweigungsbefehle, die unter bestimmten Bedingungen optional zu verschiedenen Teilen des Verhaltensskripts wechseln.  Der <code>branch_rnd</code> hat eine bestimmte Wahrscheinlichkeit, dass bei jeder Ausführung eine Verzweigung auftritt.  Ein Sonderfall der probabilistischen Verzweigung ist der Befehl <code>branch_always</code> mit einer Verzweigungswahrscheinlichkeit von 100%. <br><br>  In den Verhaltensskriptinterpreter ist ein einfacher Schleifenmechanismus integriert.  Der Befehl <code>set_loop_count</code> legt den aktuellen Wert des Schleifenzählers fest.  Jedes Mal, <code>branch_while_loop</code> Befehl <code>branch_while_loop</code> verringert er den Wert des Schleifenzählers um eins und führt nur dann eine Verzweigung durch, wenn der <code>branch_while_loop</code> größer als Null ist. <br><br>  Die letzte Art der Verzweigung überprüft den Speicherinhalt, um eine Entscheidung über die Verzweigung zu treffen.  Piston Honda verwendet diesen Befehl <code>branch_mem_test</code> um zu überprüfen, ob sein letzter Treffer in einem bestimmten Verhalten erfolgreich war.  Wenn der Treffer das Ziel trifft, verzweigt er sich für den nächsten Treffer.  Wenn der Treffer nicht erfolgreich war, wird der Befehl <code>branch_while_loop</code> , um den Treffer nur dann fortzusetzen, wenn sich 5 fehlgeschlagene Treffer ansammeln. <br><br><h2>  Verhaltensbefehle </h2><br>  Es gibt zwei Befehle, mit denen Verhaltensskripte das Verhaltenssystem selbst steuern können.  Der Befehl <code>begin_behavior_main</code> verwendet, um das aktuelle ausführbare Verhalten zu beenden und das Hauptverhalten zu starten.  Dies unterscheidet sich von der Verzweigung im Verhaltensskript, da der Teil des Skripts, der als aktuelles „Hauptverhalten“ betrachtet wird, während des Spiels durch das Übereinstimmungsskript geändert werden kann (siehe den vorherigen Teil des Artikels über Übereinstimmungsskripte). <br><br>  Ein weiterer verhaltensbezogener Befehl ist <code>enable_behavior_change</code> .  Wenn ein neues Verhalten gestartet wird, beginnt es mit einem Sperrstatus, wenn alle weiteren Anforderungen zum Ändern des Verhaltens blockiert sind.  Mit dem Befehl <code>enable_behavior_change</code> signalisiert <code>enable_behavior_change</code> Skript, dass es bereit ist, andere Verhaltensweisen zuzulassen.  Beispielsweise wird im speziellen Verhalten von Piston Honda der Befehl <code>enable_behavior_change</code> nie ausgeführt. Wenn der Mac während dieser Zeit müde ist, wird das spezielle Verhalten fortgesetzt.  Knockdown-Ereignisse umgehen dieses System jedoch. Wenn also während des besonderen Verhaltens des Kolben-Honda die Hauptfigur niedergeschlagen wird, wird das Verhalten in jedem Fall geändert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434550/">https://habr.com/ru/post/de434550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434538/index.html">Der Kampf um den Weltraum: Was passiert auf dem Satelliten-Internetmarkt?</a></li>
<li><a href="../de434540/index.html">Was tun mit Menschen, die durch Roboter ersetzt werden?</a></li>
<li><a href="../de434542/index.html">Automatisierung des Qualitätskontrollprozesses für Unternehmensspeicherdaten</a></li>
<li><a href="../de434544/index.html">"Wir wollen keinen Krieg" - Interview mit Adblock Plus-Direktor Ben Williams</a></li>
<li><a href="../de434548/index.html">Der Patriot von Simbabwe gibt 5.000 US-Dollar für die Digitalisierung des Heimatlandes in Google Street View aus</a></li>
<li><a href="../de434552/index.html">GDG SPb. Was wir in einem Jahr geschafft haben</a></li>
<li><a href="../de434558/index.html">Sibirische Support-Community: Start</a></li>
<li><a href="../de434560/index.html">Was lehrte 2018 oder praktische Schritte zur Einführung digitaler Technologien im Jahr 2019</a></li>
<li><a href="../de434562/index.html">Samsung SSD 860 QVO 1 TB und 4 TB: der erste Consumer-SATA-QLC (1 Teil)</a></li>
<li><a href="../de434564/index.html">Das Zeichnen macht 10% der Arbeit des UX-Designers aus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>