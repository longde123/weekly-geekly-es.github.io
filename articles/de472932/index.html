<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📠 ⏪ 🤴🏻 IntelliJ IDEA Static Analysis vs Human Mind 👂🏿 🌵 🌘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit habe ich die Ausgabe des IntelliJ IDEA Static Analyzer für Java-Code untersucht und bin auf einen interessanten Fall gesto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IntelliJ IDEA Static Analysis vs Human Mind</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/472932/"><p>  Vor nicht allzu langer Zeit habe ich die Ausgabe des IntelliJ IDEA Static Analyzer für Java-Code untersucht und bin auf einen interessanten Fall gestoßen.  Da das entsprechende Codefragment nicht Open Source ist, habe ich es anonymisiert und von externen Abhängigkeiten gelöst.  Wir nehmen an, dass er so aussah: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, Integer&gt; options, List&lt;String&gt; inputs)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Integer&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : inputs) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.startsWith(<span class="hljs-string"><span class="hljs-string">"-"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options.containsKey(str)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>) cur = options.get(str); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options.containsKey(<span class="hljs-string"><span class="hljs-string">"+"</span></span> + str)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>) cur = res.isEmpty() ? -<span class="hljs-number"><span class="hljs-number">1</span></span> : res.remove(res.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur != -<span class="hljs-number"><span class="hljs-number">1</span></span>) res.add(cur + str.length()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  Der Code ist wie Code, etwas wird transformiert, etwas wird getan, aber der statische Analysator mochte es nicht.  Hier sehen wir zwei Warnungen: </p><br><p><img src="https://habrastorage.org/webt/oy/nx/zp/oynxzpyjinplzjyvflkbwjid8xw.png" alt="Code-Screenshot"></p><a name="habracut"></a><br><p>  Im Ausdruck <code>res.isEmpty()</code> sagt <code>res.isEmpty()</code> IDE, dass die Bedingung immer wahr ist, und im <code>cur</code> die Zuweisung bedeutungslos zu sein, da derselbe Wert bereits in dieser Variablen liegt.  Es ist leicht zu erkennen, dass das Zuordnungsproblem eine direkte Folge des ersten Problems ist.  Wenn <code>res.isEmpty()</code> wirklich immer wahr ist, wird die Zeichenfolge auf reduziert </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>) cur = -<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Das ist in der Tat überflüssig.  Aber warum ist der Ausdruck immer wahr?  Immerhin ist <code>res</code> eine Liste, die im selben Zyklus gefüllt wird.  Die Anzahl der Iterationen der Schleife und die Verzweigungen, in die wir gehen, hängen von den Eingabeparametern ab, die die IDE nicht kennen kann.  Wir könnten ein Element hinzufügen, das bei der vorherigen Iteration <code>res</code> , und dann wird die Liste nicht leer sein. </p><br><p>  Ich habe diesen Code zum ersten Mal gesehen und viel Zeit damit verbracht, mich mit diesem Fall zu befassen.  Zuerst war ich fast davon überzeugt, dass ich auf einen Fehler im Analysegerät gestoßen bin, und ich musste ihn beheben.  Mal sehen, ob das so ist. </p><br><p>  Zunächst markieren wir alle Zeilen, in denen sich der Status der Methode ändert.  Dies ist eine Änderung der Variablen <code>cur</code> oder eine Änderung der <code>res</code> Liste: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, Integer&gt; options, List&lt;String&gt; inputs)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Integer&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : inputs) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.startsWith(<span class="hljs-string"><span class="hljs-string">"-"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options.containsKey(str)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>) cur = options.get(str); <span class="hljs-comment"><span class="hljs-comment">// A } else if (options.containsKey("+" + str)) { if (cur == -1) cur = res.isEmpty() ? -1 : // B res.remove(res.size() - 1); // C if (cur != -1) res.add(cur + str.length()); // D } } return res; }</span></span></code> </pre> <br><p>  Die Zeilen <code>'A'</code> und <code>'B'</code> ( <code>'B'</code> ist der erste Zweig der bedingten Anweisung) ändern die Variable <code>cur</code> , <code>'D'</code> ändert die Liste und <code>'C'</code> (der zweite Zweig der bedingten Anweisung) ändert sowohl die Liste als auch die Variable <code>cur</code> .  Es ist uns wichtig, ob <code>cur</code> -1 darin liegt und ob die Liste leer ist.  Das heißt, Sie müssen vier Zustände überwachen: </p><br><p><img src="https://habrastorage.org/webt/zz/bv/bt/zzbvbtfjrox1wmrvjm7-zhvnwxc.png"></p><br><p>  String <code>'A'</code> ändert <code>cur</code> wenn vorher <code>-1</code> war.  Und wir wissen nicht, ob das Ergebnis <code>-1</code> oder nicht.  Daher sind zwei Optionen möglich: </p><br><p><img src="https://habrastorage.org/webt/el/qa/xa/elqaxagjyhxmrmypo9hcgloh_xa.png"></p><br><p>  String <code>'B'</code> funktioniert auch nur, wenn <code>cur</code> <code>-1</code> .  Gleichzeitig tut sie, wie wir bereits bemerkt haben, im Prinzip nichts.  Wir beachten aber trotzdem diese Rippe, um das Bild zu vervollständigen: </p><br><p><img src="https://habrastorage.org/webt/vw/zd/wm/vwzdwmqm5hd2apb38p87r00z_vy.png"></p><br><p>  Die Zeichenfolge <code>'C'</code> arbeitet wie die vorherigen mit <code>cur == -1</code> und ändert sie willkürlich (wie <code>'A'</code> ).  Gleichzeitig kann es jedoch die nicht leere Liste <code>res</code> in leer <code>res</code> oder nicht leer lassen, wenn mehr als ein Element vorhanden ist. </p><br><p><img src="https://habrastorage.org/webt/wf/s1/37/wfs137xdsscb9p0naoe3lrjb9xm.png"></p><br><p>  Schließlich vergrößert die Zeichenfolge <code>'D'</code> die Liste: Sie kann leer zu nicht leer oder nicht leer werden.  Es kann nicht leer zu leer machen: </p><br><p><img src="https://habrastorage.org/webt/nm/aj/l2/nmajl255y34yw-d3rxxkhanakg4.png"></p><br><p>  Was gibt uns das?  Gar nichts.  Es ist völlig unverständlich, warum die Bedingung <code>res.isEmpty()</code> immer wahr ist. </p><br><p>  Tatsächlich haben wir falsch angefangen.  In diesem Fall reicht es nicht aus, den Status jeder Variablen separat zu überwachen.  Hier spielen korrelierte Zustände eine wichtige Rolle.  Glücklicherweise haben wir aufgrund der Tatsache, dass <code>2+2 = 2*2</code> , auch nur vier davon: </p><br><p><img src="https://habrastorage.org/webt/wv/mo/np/wvmonphwjgopmouzrld0ydm-ao4.png"></p><br><p>  Mit einem doppelten Rand habe ich den Ausgangszustand markiert, den wir bei der Eingabe der Methode haben.  Versuchen Sie es erneut.  <code>'A'</code> ändert oder speichert <code>cur</code> für <code>res</code> , <code>res</code> ändert sich nicht: </p><br><p><img src="https://habrastorage.org/webt/qp/a7/nf/qpa7nfxohi1mvz63r4kxcdgtifm.png"></p><br><p>  <code>'B'</code> funktioniert nur mit <code>cur == -1 &amp;&amp; res.isEmpty()</code> und macht nichts.  Hinzufügen: </p><br><p><img src="https://habrastorage.org/webt/oz/lo/zy/ozlozyk9nh0j6ss3mfve5l1cpv0.png"></p><br><p>  <code>'C'</code> funktioniert nur mit <code>cur == -1 &amp;&amp; !res.isEmpty()</code> .  Gleichzeitig ändern sich <code>cur</code> und <code>res</code> willkürlich: Nach <code>'C'</code> landen wir in einem beliebigen Zustand: </p><br><p><img src="https://habrastorage.org/webt/b7/jm/dk/b7jmdkb-c5kqax0m6kyxevslyfi.png"></p><br><p>  Schließlich kann <code>'D'</code> in <code>cur != -1 &amp;&amp; res.isEmpty()</code> und die Liste nicht leer machen oder in <code>cur != -1 &amp;&amp; !res.isEmpty()</code> und dort bleiben: </p><br><p><img src="https://habrastorage.org/webt/qn/l4/h6/qnl4h6qs-sizqozc2rn-ecl4hwe.png"></p><br><p>  Auf den ersten Blick scheint es nur noch schlimmer geworden zu sein: Das Diagramm ist komplizierter geworden, und es ist nicht klar, wie man es verwendet.  Tatsächlich stehen wir jedoch einer Lösung nahe.  Die Pfeile zeigen nun den gesamten möglichen Ablauf der Ausführung unserer Methode.  Da wir wissen, von welchem ​​Zustand wir angefangen haben, machen wir einen Spaziergang entlang der Pfeile: </p><br><p><img src="https://habrastorage.org/webt/ye/au/jm/yeaujmkezkujggymcc20xa679_m.png"></p><br><p>  Und hier wird eine sehr interessante Sache offenbart.  Wir können nicht in die untere linke Ecke gelangen.  Und da wir nicht darauf eingehen können, können wir keinen der Pfeile <code>'C'</code> entlang gehen.  Das heißt, die Zeile <code>'C'</code> wirklich nicht erreichbar und das <code>'B'</code> kann ausgeführt werden.  Dies ist nur möglich, wenn die Bedingung <code>res.isEmpty()</code> tatsächlich immer wahr ist!  Die IntelliJ IDEA ist völlig korrekt.  Entschuldigung, Analysator, vergebens dachte ich, Sie wären fehlerhaft.  Du bist einfach so schlau, dass es für mich, einen normalen Menschen, schwierig ist, dich einzuholen. </p><br><p>  Unser Analysegerät verfügt über keine „Hype“ -Technologien für künstliche Intelligenz, sondern verwendet die Ansätze der Kontrollflussanalyse und Datenflussanalyse, die nicht weniger als ein halbes Jahrhundert alt sind.  Trotzdem zieht er manchmal sehr nicht triviale Schlussfolgerungen.  Dies ist jedoch verständlich: Lange Zeit ist es besser, Diagramme zu erstellen und mit Maschinen darauf zu laufen als mit Menschen.  Es gibt ein wichtiges ungelöstes Problem: Es reicht nicht aus, nur einer Person mitzuteilen, dass sie einen Programmfehler hat.  Das Siliziumgehirn muss dem Biologischen erklären, warum es dies beschlossen hat und damit das biologische Gehirn es versteht.  Wenn jemand brillante Ideen dazu hat, würde ich mich freuen, von Ihnen zu hören.  Wenn Sie bereit sind, Ihre Ideen selbst umzusetzen, wird unser Team die Zusammenarbeit mit Ihnen nicht ablehnen! </p><br><p>  Einer der Abnahmetests liegt vor Ihnen: Für dieses Beispiel sollte automatisch eine Erklärung generiert werden.  Es kann ein Text, eine Grafik, ein Baum, ein Bild mit Siegeln sein - alles, was nur eine Person verstehen könnte. </p><br><p>  Die Frage bleibt offen, was der Autor der Methode gemeint hat und wie der Code eigentlich aussehen soll.  Die Verantwortlichen des Subsystems haben mir mitgeteilt, dass dieser Teil etwas aufgegeben ist, und sie selbst wissen nicht, wie sie ihn reparieren sollen, oder es ist besser, ihn insgesamt zu entfernen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472932/">https://habr.com/ru/post/de472932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472918/index.html">ZX Spectrum in Russland und der GUS: Wie sich das Streben nach Online offline verändert hat</a></li>
<li><a href="../de472922/index.html">Defender-Programmierer stärker als Entropie</a></li>
<li><a href="../de472926/index.html">Das Gesetz der Beschleunigung der Rendite (Teil 1)</a></li>
<li><a href="../de472928/index.html">Hoch geladener GPU-Computerdienst</a></li>
<li><a href="../de472930/index.html">Silicon Valley Astrophysiker Quantifizierung der Mode</a></li>
<li><a href="../de472934/index.html">Was ist ein Zero Trust? Sicherheitsmodell</a></li>
<li><a href="../de472936/index.html">Operation TA505: Gruppieren der Netzwerkinfrastruktur. Teil 3</a></li>
<li><a href="../de472940/index.html">Über Betrüger und Menschen</a></li>
<li><a href="../de472944/index.html">Data as a Service: Was ist das, technische Schwierigkeiten und wie können Sie diese mithilfe von residenten Proxys umgehen?</a></li>
<li><a href="../de472946/index.html">Ein guter Entwickler ist weise, nicht brillant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>