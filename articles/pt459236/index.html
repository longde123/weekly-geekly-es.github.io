<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèø üë©üèø‚Äçü§ù‚Äçüë©üèæ üôåüèæ SQL: solu√ß√£o de tarefas para hor√°rio de trabalho ü§ó üïµÔ∏è ü•ß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, Radio SQL est√° no ar novamente! Hoje, temos uma solu√ß√£o para o problema que transmitimos em nossa transmiss√£o anterior e prometemos decifrar da p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: solu√ß√£o de tarefas para hor√°rio de trabalho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  Ol√°, Radio SQL est√° no ar novamente!  Hoje, temos uma solu√ß√£o para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema</a> que transmitimos em nossa transmiss√£o anterior e prometemos decifrar da pr√≥xima vez.  E esta pr√≥xima vez chegou. </p><br><p>  A tarefa despertou uma resposta animada entre os human√≥ides da gal√°xia da Via L√°ctea (e n√£o surpreendentemente, com a escravid√£o do trabalho, que eles ainda respeitam em benef√≠cio da civiliza√ß√£o).  Infelizmente, no terceiro planeta, o lan√ßamento do observat√≥rio espacial Spektr-RG foi adiado no final de julho de 2019, o RC (cronologia local), com a ajuda da qual estava planejado transmitir este programa.  Eu tive que procurar rotas de transmiss√£o alternativas, o que levou a um pequeno atraso no sinal.  Mas tudo est√° bem quando acaba bem. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Devo dizer imediatamente que n√£o haver√° m√°gica na an√°lise da tarefa, n√£o h√° necessidade de procurar revela√ß√µes aqui ou esperar por alguma implementa√ß√£o particularmente eficaz (ou especialmente em outro sentido).  Esta √© apenas uma tarefa de an√°lise.  Nele, aqueles que n√£o souberem abordar a solu√ß√£o de tais problemas poder√£o ver como resolv√™-los.  Al√©m disso, n√£o h√° nada de terr√≠vel aqui. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Deixe-me lembr√°-lo da condi√ß√£o.</b> <div class="spoiler_text"><p>  Existem v√°rios intervalos de tempo especificados pela data e hora do in√≠cio e do fim (um exemplo na sintaxe do PostgreSQL): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  √â necess√°rio em uma consulta SQL (c) calcular a dura√ß√£o de cada intervalo em hor√°rio comercial.  Acreditamos que trabalhamos durante a semana de segunda a sexta-feira, o hor√°rio de trabalho √© sempre das 10:00 √†s 19:00.  Al√©m disso, de acordo com o calend√°rio de produ√ß√£o da Federa√ß√£o Russa, existem v√°rios feriados oficiais que n√£o s√£o dias √∫teis e alguns dias de folga, pelo contr√°rio, s√£o dias √∫teis devido ao adiamento desses mesmos feriados.  N√£o √© necess√°rio o encurtamento dos dias pr√©-feriado, n√≥s os consideramos completos.  Como os feriados variam de ano para ano, ou seja, s√£o definidos por listagem expl√≠cita, nos limitaremos a datas apenas de 2018 e 2019.  Estou certo de que, se necess√°rio, a solu√ß√£o pode ser facilmente complementada. </p><br><p>  √â necess√°rio adicionar uma coluna com a dura√ß√£o do hor√°rio de trabalho aos per√≠odos iniciais dos <em>per√≠odos</em> .  Aqui est√° o resultado: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  N√£o verificamos os dados iniciais quanto √† exatid√£o; sempre consideramos <em>start_time &lt;= stop_time</em> . </p><br><p>  O fim da condi√ß√£o, o original est√° aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  A tarefa d√° uma ligeira √™nfase ao fato de eu ter dado conscientemente uma boa metade da condi√ß√£o de forma descritiva (como geralmente acontece na vida real), deixando a crit√©rio da implementa√ß√£o t√©cnica como o cronograma deve ser definido.  Por um lado, isso requer algumas habilidades de pensamento arquitetural.  E, por outro lado, o formato pronto desse cronograma teria solicitado algum uso do modelo.  E se voc√™ omitir, o pensamento e a fantasia funcionar√£o mais plenamente.  A recep√ß√£o valeu a pena completamente, permitindo-me tamb√©m encontrar abordagens interessantes nas solu√ß√µes publicadas. </p><br><p>  Portanto, para resolver o problema original dessa maneira, duas subtarefas precisar√£o ser resolvidas: </p><br><ol><li>  Determine como definir de maneira mais compacta um cronograma de trabalho e at√© mesmo para que seja conveniente usar uma solu√ß√£o. </li><li>  Calcule realmente a dura√ß√£o de cada per√≠odo de origem nas horas de trabalho, de acordo com o cronograma de trabalho da subtarefa anterior. </li></ol><br><p>  E √© melhor come√ßar com o segundo, para entender de que forma precisamos resolver o primeiro.  Resolva o primeiro e volte ao segundo para obter o resultado final. <br>  Coletaremos o resultado gradualmente, usando a sintaxe CTE, que nos permite colocar todas as amostras de dados necess√°rias em subconsultas nomeadas separadas e, em seguida, vincular tudo. </p><br><p>  Bem, vamos l√°. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Calcular a dura√ß√£o em hor√°rio comercial </h3><br><p>  Para calcular a dura√ß√£o de cada um dos per√≠odos nas horas de trabalho na testa, voc√™ precisa cruzar o per√≠odo inicial (cor verde no diagrama) com os intervalos que descrevem o tempo de trabalho (laranja).  Os intervalos de hor√°rio de trabalho s√£o segundas-feiras, das 10h √†s 19h, ter√ßas-feiras, das 10h √†s 19h e assim por diante.  O resultado √© mostrado em azul: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="imagem"></p><br><p>  A prop√≥sito, para ficar menos confuso, continuarei a me referir aos per√≠odos iniciais como per√≠odos iniciais e chamarei intervalos de horas de trabalho. </p><br><p>  O procedimento deve ser repetido para cada per√≠odo inicial.  Os per√≠odos iniciais para n√≥s j√° est√£o definidos na <em>guia de per√≠odos (</em> <em>hor√°rio de in√≠cio</em> , <em>hor√°rio de parada)</em> ; representaremos as horas de trabalho na forma de uma tabela, por exemplo, <em>hor√°rio (hor√°rio de estratifica√ß√£o, hor√°rio de parada)</em> , onde todos os dias √∫teis est√£o presentes.  O resultado √© um produto cartesiano completo de todos os per√≠odos e intervalos iniciais do tempo de trabalho. </p><br><p>  As interse√ß√µes podem ser contadas da maneira cl√°ssica, considerando todas as op√ß√µes poss√≠veis para intervalos de interse√ß√£o - interceptamos verde com laranja, o resultado √© azul: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="imagem"></p><br><p>  e tomando em cada caso o valor desejado para o in√≠cio e o final do resultado: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Como para cada interse√ß√£o, podemos ter apenas uma das quatro op√ß√µes, todas elas s√£o combinadas em uma solicita√ß√£o usando <em>union all</em> . </p><br><p>  Voc√™ pode fazer o contr√°rio usando o tipo de intervalo <em>tsrange</em> dispon√≠vel no PostgreSQL e a opera√ß√£o de interse√ß√£o j√° dispon√≠vel para ele: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  Concorde que isso √© um pouco mais f√°cil.  Em geral, existem muitas coisas convenientes no PostgreSQL; portanto, escrever consultas sobre ele √© muito bom. </p><br><h3 id="sgenerirovat-kalendar">  Gerar calend√°rio </h3><br><p>  Agora, de volta √† subtarefa com a programa√ß√£o do hor√°rio de trabalho. </p><br><p>  Precisamos obter o cronograma de trabalho na forma de intervalos de hor√°rio de trabalho das 10:00 √†s 19:00 para cada dia √∫til, algo como <em>cronograma (hor√°rio de in√≠cio, hor√°rio de parada)</em> .  Como entendemos, ser√° conveniente resolver nosso problema.  Na vida real, esse cronograma deve ser definido, por dois anos, s√£o apenas cerca de 500 registros; para fins pr√°ticos, ser√° necess√°rio definir at√© dez anos - s√£o dois mil e quinhentos registros, lixo real para bancos de dados modernos.  Mas temos um problema que ser√° resolvido em uma solicita√ß√£o e listar toda essa tabela nela n√£o √© muito pr√°tico.  Vamos tentar implement√°-lo de forma mais compacta. </p><br><p>  De qualquer forma, precisamos de feriados para remov√™-los da programa√ß√£o b√°sica e aqui apenas a listagem √© adequada: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  e dias √∫teis adicionais a serem adicionados: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  A sequ√™ncia de dias √∫teis por dois anos pode ser gerada por uma fun√ß√£o <em>generate_series ()</em> especial e muito adequada, lan√ßando imediatamente s√°bados e domingos pelo caminho: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Temos dias √∫teis conectando tudo: geramos uma sequ√™ncia de todos os dias √∫teis em dois anos, adicionamos dias √∫teis adicionais de <em>datas_include</em> e removemos todos os dias de <em>datas_exclude al√©m disso</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  E agora temos os intervalos de tempo que precisamos: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Ent√£o, n√≥s temos o cronograma. </p><br><h3 id="sobiraem-vsyo-vmeste">  Juntando tudo </h3><br><p>  Agora teremos os cruzamentos: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Preste aten√ß√£o √† condi√ß√£o de conex√£o <em>LIGADA</em> , ela n√£o corresponde a dois registros correspondentes das tabelas unidas, essa correspond√™ncia n√£o existe, mas √© introduzida uma otimiza√ß√£o que corta os intervalos de tempo de trabalho com os quais nosso per√≠odo inicial n√£o se cruza.  Isso √© feito usando o operador <em>&amp;&amp;</em> , que verifica a interse√ß√£o dos intervalos de intervalo.  Isso remove muitas interse√ß√µes vazias para n√£o atrapalhar os olhos, mas, por outro lado, remove informa√ß√µes sobre os per√≠odos iniciais que ficam fora do expediente.  Portanto, admiramos que nossa abordagem funcione e reescrevamos a solicita√ß√£o da seguinte maneira: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Em <em>period_wrk,</em> decompomos cada per√≠odo de origem em intervalos de trabalho e, em seguida, consideramos sua dura√ß√£o total.  O resultado foi um produto cartesiano completo de todos os per√≠odos e intervalos, mas nenhum per√≠odo foi perdido. </p><br><p>  Tudo, o resultado √© recebido.  N√£o gostei dos valores <em>NULL</em> para intervalos vazios. Deixe a consulta mostrar um intervalo de tamanho zero melhor.  Envolva a quantidade em <em>coalesc√™ncia ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Todos juntos d√£o o resultado final: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  Hurrah! .. Isso pode estar terminado, mas por uma quest√£o de integridade, consideraremos alguns t√≥picos mais relacionados. </p><br><h3 id="dalneyshee-razvitie-temy">  Desenvolvimento adicional do t√≥pico </h3><br><p>  Dias pr√©-feriado mais curtos, intervalos para almo√ßo, hor√°rios diferentes para dias da semana diferentes ... Em princ√≠pio, tudo est√° claro, √© necess√°rio corrigir a defini√ß√£o de <em>hor√°rio</em> , apenas alguns exemplos. </p><br><p>  √â assim que voc√™ pode definir diferentes hor√°rios de in√≠cio e t√©rmino de um dia √∫til, dependendo do dia da semana: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Se voc√™ precisar levar em considera√ß√£o os intervalos para o almo√ßo das 13:00 √†s 14:00, em vez de um intervalo por dia, fa√ßa dois: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Bem e assim por diante. </p><br><h3 id="proizvoditelnost">  Desempenho </h3><br><p>  Vou dizer algumas palavras sobre o desempenho, pois sempre h√° perguntas sobre ele.  Eu n√£o vou mastigar muito, esta √© uma se√ß√£o com um asterisco. </p><br><p>  Em geral, a otimiza√ß√£o prematura √© ruim.  De acordo com meus muitos anos de observa√ß√£o, a legibilidade do c√≥digo √© sua vantagem mais importante.  Se o c√≥digo for bem lido, ser√° mais f√°cil manter e desenvolver.  O c√≥digo leg√≠vel requer implicitamente uma boa arquitetura da solu√ß√£o, coment√°rios adequados e bons nomes de vari√°veis, compacta√ß√£o sem sacrificar a legibilidade, etc., ou seja, tudo pelo que o c√≥digo √© bom. </p><br><p>  Portanto, a solicita√ß√£o √© sempre escrita da forma mais leg√≠vel poss√≠vel e come√ßamos a otimizar se e somente se o desempenho for insuficiente.  Al√©m disso, otimizaremos precisamente onde o desempenho √© insuficiente e exatamente na medida em que ele se torna suficiente.  Se voc√™ certamente valoriza seu tempo e tem algo a fazer. </p><br><p>  Mas n√£o √© certo fazer um trabalho desnecess√°rio na solicita√ß√£o; voc√™ deve sempre tentar levar isso em considera√ß√£o. </p><br><p>  Com base nisso, incluiremos uma otimiza√ß√£o na consulta imediatamente - deixe que cada per√≠odo de origem se cruze apenas com os intervalos de tempo de trabalho com os quais possui pontos em comum (em vez de uma longa condi√ß√£o cl√°ssica nos limites do intervalo, √© mais conveniente usar o operador <em>&amp;&amp;</em> <em>interno</em> para o tipo <em>tsrange</em> ).  Essa otimiza√ß√£o j√° apareceu na solicita√ß√£o, mas levou ao fato de que os per√≠odos iniciais que ca√≠ram completamente fora do hor√°rio de trabalho desapareceram dos resultados. </p><br><p>  Traga essa otimiza√ß√£o de volta.  Para fazer isso, use <em>LEFT JOIN</em> , que salvar√° todos os registros da tabela de <em>per√≠odos</em> .  Agora a subconsulta <em>period_wrk</em> ficar√° assim: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  A an√°lise da solicita√ß√£o mostra que o tempo nos dados do teste diminuiu cerca da metade.  Como o tempo de execu√ß√£o depende do que o servidor estava fazendo ao mesmo tempo, fiz v√°rias medi√ß√µes e dei um resultado "t√≠pico", n√£o o maior, nem o menor, do meio. </p><br><p>  Consulta antiga: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Novo: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Mas o mais importante √© que essa solicita√ß√£o tamb√©m ser√° dimensionada melhor, exigindo menos recursos do servidor, pois o produto cartesiano completo cresce muito rapidamente. </p><br><p>  E nisso eu pararia com otimiza√ß√µes.  Quando resolvi esse problema, tive desempenho suficiente mesmo em uma forma muito mais terr√≠vel dessa solicita√ß√£o, mas realmente n√£o havia necessidade de otimizar.  Para obter um relat√≥rio sobre meus dados uma vez por trimestre, posso esperar mais dez segundos.  A hora extra gasta em otimiza√ß√£o nessas condi√ß√µes nunca ser√° recompensada. </p><br><p>  Mas acaba sendo desinteressante; ainda vamos pensar em como os eventos poderiam se desenvolver se a otimiza√ß√£o em termos de tempo de execu√ß√£o fosse realmente necess√°ria.  Por exemplo, queremos monitorar esse par√¢metro em tempo real para cada um de nossos registros no banco de dados, ou seja, para cada espirro, uma solicita√ß√£o desse tipo ser√° chamada.  Bem, ou invente seu pr√≥prio motivo, por que voc√™ precisaria otimizar. </p><br><p>  A primeira coisa que vem √† mente √© contar uma vez e colocar no banco de dados uma tabela com intervalos de trabalho.  Pode haver contra-indica√ß√µes: se o banco de dados n√£o puder ser alterado ou forem esperadas dificuldades com o suporte de dados relevantes nessa tabela.  Ent√£o voc√™ ter√° que deixar a gera√ß√£o de tempo de trabalho ‚Äúon the fly‚Äù na pr√≥pria solicita√ß√£o, pois essa n√£o √© uma subconsulta muito pesada. </p><br><p>  A pr√≥xima e mais poderosa abordagem (mas nem sempre aplic√°vel) √© a otimiza√ß√£o algor√≠tmica.  Algumas dessas abordagens j√° foram apresentadas nos coment√°rios do artigo com a condi√ß√£o do problema. </p><br><p>  Eu gosto deste acima de tudo.  Se voc√™ criar uma tabela com todos os dias (n√£o apenas √∫teis) do calend√°rio e calcular o total acumulado de quantas horas de trabalho por dia a partir de uma certa "cria√ß√£o do mundo" se passaram, ser√° poss√≠vel obter o n√∫mero de horas de trabalho entre duas datas com uma opera√ß√£o de subtra√ß√£o.  Resta apenas considerar corretamente as horas de trabalho do primeiro e do √∫ltimo dia - e pronto.  Aqui est√° o que eu consegui nessa abordagem: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Vou explicar brevemente o que est√° acontecendo aqui.  Na subconsulta <em>schedule_base</em> , geramos todos os dias do calend√°rio por dois anos e a cada dia determinamos o sinal, seja o dia √∫til (= 1) ou n√£o (= 0).  Al√©m disso, na subconsulta de <em>agendamento</em> , consideramos a fun√ß√£o de janela como o n√∫mero total acumulado de horas de trabalho de 01/01/2018.  Seria poss√≠vel fazer tudo em uma subconsulta, mas seria mais complicado, o que prejudicaria a legibilidade.  Em seguida, na solicita√ß√£o principal, consideramos a diferen√ßa entre o n√∫mero de horas de trabalho no final e no in√≠cio do per√≠odo e, de certa forma florida, levamos em considera√ß√£o as horas de trabalho do primeiro e do √∫ltimo dia do per√≠odo.  A floridez est√° associada √† mudan√ßa do tempo antes do in√≠cio do dia √∫til para o in√≠cio e do tempo ap√≥s o final do dia √∫til at√© o final.  Al√©m disso, se a parte da solicita√ß√£o com <em>shedule_base</em> e o <em>cronograma for</em> removida em uma tabela pr√©-calculada separada (como sugerido anteriormente), essa solicita√ß√£o se tornar√° completamente trivial. </p><br><p>  Vamos comparar a execu√ß√£o em uma amostra maior para mostrar melhor a otimiza√ß√£o realizada, por quatro per√≠odos da condi√ß√£o da tarefa, mais tempo √© gasto na gera√ß√£o de um cronograma de trabalho. </p><br><p>  Eu levei cerca de 3 mil per√≠odos.  Vou dar apenas a linha de resumo superior em EXPLAIN, os valores t√≠picos s√£o os seguintes. </p><br><p>  Op√ß√£o original: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Otimizado: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  O ganho de tempo foi de duas ordens de magnitude.  Com o aumento do n√∫mero de per√≠odos e sua dura√ß√£o em anos, a diferen√ßa s√≥ aumentar√°. </p><br><p>  Tudo parecia estar bem, mas por que, tendo feito essa otimiza√ß√£o, deixei a primeira vers√£o do pedido para mim at√© que seu desempenho fosse suficiente?  Sim, porque a vers√£o otimizada √©, sem d√∫vida, mais r√°pida, mas requer muito mais tempo para entender como funciona, ou seja, a legibilidade piorou.  Ou seja, da pr√≥xima vez que precisar reescrever a solicita√ß√£o sob minhas condi√ß√µes alteradas, eu (ou n√£o eu) terei que gastar muito mais tempo entendendo como a solicita√ß√£o funciona. </p><br><p>  √â tudo por hoje, mantenha os tent√°culos aquecidos, e digo adeus a voc√™ at√© o pr√≥ximo lan√ßamento do Radio SQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459236/">https://habr.com/ru/post/pt459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459224/index.html">De corretor de im√≥veis a desenvolvedor de jogos 2. ‚ÄúOpera√ß√£o: Android‚Äù</a></li>
<li><a href="../pt459226/index.html">"Fast-PoE e Perpetual-PoE - esses novos padr√µes s√£o ou n√£o?"</a></li>
<li><a href="../pt459230/index.html">Uma viagem ao call center e Product Backlog atrav√©s dos olhos do desenvolvedor</a></li>
<li><a href="../pt459232/index.html">Surround, mordida, corte: a nova competi√ß√£o Mini AI Cup # 4</a></li>
<li><a href="../pt459234/index.html">Smem - Relat√≥rios sobre aloca√ß√£o de mem√≥ria entre processos e usu√°rios no Linux</a></li>
<li><a href="../pt459238/index.html">De uma fun√ß√£o matem√°tica m√°gica - uma solu√ß√£o para governar todos eles</a></li>
<li><a href="../pt459240/index.html">10 anos em TI diagnosticada com esquizofrenia, dicas de sobreviv√™ncia</a></li>
<li><a href="../pt459242/index.html">Ap√≥s a confer√™ncia T + Conf 2019</a></li>
<li><a href="../pt459244/index.html">Gerente de produto do Notes: comportamento do usu√°rio nas p√°ginas dos jogos na loja de aplicativos. Quanto tempo leva para baixar um jogo</a></li>
<li><a href="../pt459246/index.html">Por que a convers√£o do site est√° diminuindo? Exemplos de 60 erros de design e usabilidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>