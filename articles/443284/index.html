<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè´ üë®üèΩ‚Äçüîß üéè √çndices en PostgreSQL - 4 (Btree) üë®üèº‚Äç‚öñÔ∏è üßëüèæ‚Äçü§ù‚Äçüßëüèº ‚è™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hemos discutido el motor de indexaci√≥n PostgreSQL y la interfaz de los m√©todos de acceso , as√≠ como el √≠ndice hash , uno de los m√©todos de acceso. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices en PostgreSQL - 4 (Btree)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/443284/">  Ya hemos discutido el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci√≥n</a> PostgreSQL y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz de los m√©todos de acceso</a> , as√≠ como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndice hash</a> , uno de los m√©todos de acceso.  Ahora consideraremos B-tree, el √≠ndice m√°s tradicional y ampliamente utilizado.  Este art√≠culo es grande, as√≠ que sea paciente. <br><br><h1>  Btree </h1><br><h2>  Estructura </h2><br>  El tipo de √≠ndice del √°rbol B, implementado como m√©todo de acceso "btree", es adecuado para los datos que se pueden ordenar.  En otras palabras, los operadores "mayor", "mayor o igual", "menor", "menor o igual" e "igual" deben definirse para el tipo de datos.  Tenga en cuenta que los mismos datos a veces se pueden ordenar de manera diferente, lo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nos lleva de vuelta</a> al concepto de familia de operadores. <br><a name="habracut"></a><br>  Como siempre, las filas de √≠ndice del √°rbol B se empaquetan en p√°ginas.  En las p√°ginas de hoja, estas filas contienen datos para indexar (claves) y referencias a filas de tabla (TID).  En las p√°ginas internas, cada fila hace referencia a una p√°gina secundaria del √≠ndice y contiene el valor m√≠nimo en esta p√°gina. <br><br>  Los √°rboles B tienen algunos rasgos importantes: <br><br><ul><li>  Los √°rboles B est√°n equilibrados, es decir, cada p√°gina de hoja est√° separada de la ra√≠z por el mismo n√∫mero de p√°ginas internas.  Por lo tanto, la b√∫squeda de cualquier valor lleva el mismo tiempo. <br></li><li>  Los √°rboles B son multibramificados, es decir, cada p√°gina (generalmente 8 KB) contiene muchos (cientos) TID.  Como resultado, la profundidad de los √°rboles B es bastante peque√±a, en realidad hasta 4-5 para tablas muy grandes. <br></li><li>  Los datos en el √≠ndice se ordenan en orden no decreciente (tanto entre p√°ginas como dentro de cada p√°gina), y las p√°ginas del mismo nivel est√°n conectadas entre s√≠ por una lista bidireccional.  Por lo tanto, podemos obtener un conjunto de datos ordenado simplemente por una lista caminando en una u otra direcci√≥n sin volver a la ra√≠z cada vez. <br></li></ul><br>  A continuaci√≥n se muestra un ejemplo simplificado del √≠ndice en un campo con teclas enteras. <br><br><img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br><br>  La primera p√°gina del √≠ndice es una metap√°gina, que hace referencia a la ra√≠z del √≠ndice.  Los nodos internos se encuentran debajo de la ra√≠z, y las p√°ginas de hoja est√°n en la fila inferior.  Las flechas hacia abajo representan referencias de nodos de hoja a filas de tabla (TID). <br><br><h3>  B√∫squeda por igualdad </h3><br>  Consideremos la b√∫squeda de un valor en un √°rbol por la condici√≥n " <em>indexed-field</em> = <em>expression</em> ".  Digamos que estamos interesados ‚Äã‚Äãen la clave del 49. <br><br><img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br><br>  La b√∫squeda comienza con el nodo ra√≠z, y necesitamos determinar a cu√°l de los nodos hijos descender.  Conociendo las claves en el nodo ra√≠z (4, 32, 64), por lo tanto, calculamos los rangos de valores en los nodos secundarios.  Como 32 ‚â§ 49 &lt;64, debemos descender al segundo nodo hijo.  A continuaci√≥n, el mismo proceso se repite recursivamente hasta llegar a un nodo hoja desde el que se pueden obtener los TID necesarios. <br><br>  En realidad, una serie de detalles complican este proceso aparentemente simple.  Por ejemplo, un √≠ndice puede contener claves no √∫nicas y puede haber tantos valores iguales que no caben en una p√°gina.  Volviendo a nuestro ejemplo, parece que deber√≠amos descender del nodo interno sobre la referencia al valor de 49. Pero, como se desprende de la figura, de esta manera omitiremos una de las teclas "49" en la p√°gina de hoja anterior. .  Por lo tanto, una vez que hayamos encontrado una clave exactamente igual en una p√°gina interna, tenemos que descender una posici√≥n hacia la izquierda y luego mirar a trav√©s de las filas de √≠ndice del nivel subyacente de izquierda a derecha en busca de la clave buscada. <br><br>  (Otra complicaci√≥n es que durante la b√∫squeda, otros procesos pueden cambiar los datos: el √°rbol se puede reconstruir, las p√°ginas se pueden dividir en dos, etc. Todos los algoritmos est√°n dise√±ados para que estas operaciones concurrentes no interfieran entre s√≠ y no causen bloqueos adicionales siempre que sea posible, pero evitaremos expandirnos en esto). <br><br><h3>  B√∫squeda por desigualdad </h3><br>  Al buscar por la condici√≥n " <em>expresi√≥n de</em> <em>campo indexado</em> ‚â§" (o " <em>expresi√≥n de</em> <em>campo indexado</em> ‚â•"), primero encontramos un valor (si lo hay) en el √≠ndice por la condici√≥n de igualdad " <em>campo indexado</em> = <em>expresi√≥n</em> " y luego recorremos hojas de hoja en la direcci√≥n adecuada hasta el final. <br><br>  La figura ilustra este proceso para n ‚â§ 35: <br><br><img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br><br>  Los operadores "mayor" y "menor" son compatibles de manera similar, excepto que el valor encontrado inicialmente debe descartarse. <br><br><h3>  Buscar por rango </h3><br>  Al buscar por rango " <em>expresi√≥n1</em> ‚â§ <em>campo indexado</em> ‚â§ <em>expresi√≥n2</em> ", encontramos un valor por condici√≥n " <em>campo indexado</em> = <em>expresi√≥n1</em> ", y luego seguimos caminando a trav√©s de las p√°ginas mientras se cumple la condici√≥n " <em>campo indexado</em> ‚â§ <em>expresi√≥n2</em> ";  o viceversa: comience con la segunda expresi√≥n y camine en direcci√≥n opuesta hasta llegar a la primera expresi√≥n. <br><br>  La figura muestra este proceso para la condici√≥n 23 ‚â§ n ‚â§ 64: <br><br><img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br><br><h2>  Ejemplo </h2><br>  Veamos un ejemplo de c√≥mo se ven los planes de consulta.  Como de costumbre, usamos la base de datos de demostraci√≥n, y esta vez consideraremos la tabla de aviones.  Contiene tan solo nueve filas, y el planificador elegir√≠a no usar el √≠ndice ya que la tabla completa se ajusta a una p√°gina.  Pero esta tabla es interesante para nosotros con un prop√≥sito ilustrativo. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts;</code> </pre> <pre> <code class="plaintext hljs"> aircraft_code | model | range ---------------+---------------------+------- 773 | Boeing 777-300 | 11100 763 | Boeing 767-300 | 7900 SU9 | Sukhoi SuperJet-100 | 3000 320 | Airbus A320-200 | 5700 321 | Airbus A321-200 | 5600 319 | Airbus A319-100 | 6700 733 | Boeing 737-300 | 4200 CN1 | Cessna 208 Caravan | 1200 CR2 | Bombardier CRJ-200 | 2700 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range); demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  (O expl√≠citamente, "crear √≠ndice en aeronaves usando btree (rango)", pero es un √°rbol B que se construye por defecto). <br><br>  B√∫squeda por igualdad: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range = <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range = 3000) (2 rows)</code> </pre><br>  B√∫squeda por desigualdad: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range &lt; 3000) (2 rows)</code> </pre><br>  Y por rango: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000)) (2 rows)</code> </pre><br><h2>  Clasificaci√≥n </h2><br>  Una vez m√°s, enfaticemos el punto de que con cualquier tipo de exploraci√≥n (√≠ndice, solo √≠ndice o mapa de bits), el m√©todo de acceso "btree" devuelve datos ordenados, que podemos ver claramente en las figuras anteriores. <br><br>  Por lo tanto, si una tabla tiene un √≠ndice en la condici√≥n de clasificaci√≥n, el optimizador considerar√° ambas opciones: exploraci√≥n de √≠ndice de la tabla, que devuelve f√°cilmente los datos ordenados, y exploraci√≥n secuencial de la tabla con la clasificaci√≥n posterior del resultado. <br><br><h3>  Orden de clasificaci√≥n </h3><br>  Al crear un √≠ndice, podemos especificar expl√≠citamente el orden de clasificaci√≥n.  Por ejemplo, podemos crear un √≠ndice por rangos de vuelo de esta manera en particular: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>);</code> </pre><br>  En este caso, los valores m√°s grandes aparecer√≠an en el √°rbol a la izquierda, mientras que los valores m√°s peque√±os aparecer√≠an a la derecha.  ¬øPor qu√© puede ser necesario si podemos recorrer los valores indexados en cualquier direcci√≥n? <br><br>  El prop√≥sito es √≠ndices de m√∫ltiples columnas.  Creemos una vista para mostrar modelos de aeronaves con una divisi√≥n convencional en naves de corto, mediano y largo alcance: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> model, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v;</code> </pre><pre> <code class="plaintext hljs"> model | class ---------------------+------- Boeing 777-300 | 3 Boeing 767-300 | 2 Sukhoi SuperJet-100 | 1 Airbus A320-200 | 2 Airbus A321-200 | 2 Airbus A319-100 | 2 Boeing 737-300 | 2 Cessna 208 Caravan | 1 Bombardier CRJ-200 | 1 (9 rows)</code> </pre><br>  Y creemos un √≠ndice (usando la expresi√≥n): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), model);</code> </pre><br>  Ahora podemos usar este √≠ndice para obtener datos ordenados por ambas columnas en orden ascendente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 1 | Bombardier CRJ-200 1 | Cessna 208 Caravan 1 | Sukhoi SuperJet-100 2 | Airbus A319-100 2 | Airbus A320-200 2 | Airbus A321-200 2 | Boeing 737-300 2 | Boeing 767-300 3 | Boeing 777-300 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Del mismo modo, podemos realizar la consulta para ordenar los datos en orden descendente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 3 | Boeing 777-300 2 | Boeing 767-300 2 | Boeing 737-300 2 | Airbus A321-200 2 | Airbus A320-200 2 | Airbus A319-100 1 | Sukhoi SuperJet-100 1 | Cessna 208 Caravan 1 | Bombardier CRJ-200 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan BACKWARD using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Sin embargo, no podemos usar este √≠ndice para ordenar los datos por una columna en orden descendente y por la otra columna en orden ascendente.  Esto requerir√° ordenar por separado: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------- Sort Sort Key: (CASE ... END), aircrafts.model DESC -&gt; Seq Scan on aircrafts (3 rows)</code> </pre><br>  (Tenga en cuenta que, como √∫ltimo recurso, el planificador eligi√≥ el escaneo secuencial independientemente de la configuraci√≥n "enable_seqscan = off" realizada anteriormente. Esto se debe a que en realidad esta configuraci√≥n no proh√≠be el escaneo de la tabla, sino que solo establece su costo astron√≥mico; mire el plan con "Costos en"). <br><br>  Para hacer que esta consulta use el √≠ndice, este √∫ltimo debe construirse con la direcci√≥n de clasificaci√≥n necesaria: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> aircrafts_case_asc_model_desc_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts (1 row)</code> </pre><br><h3>  Orden de columnas </h3><br>  Otro problema que surge cuando se usan √≠ndices de columnas m√∫ltiples es el orden de enumerar columnas en un √≠ndice.  Para B-tree, este orden es de gran importancia: los datos dentro de las p√°ginas se ordenar√°n por el primer campo, luego por el segundo, y as√≠ sucesivamente. <br><br>  Podemos representar el √≠ndice que construimos en intervalos de rango y modelos de manera simb√≥lica de la siguiente manera: <br><br><img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br><br>  En realidad, un √≠ndice tan peque√±o seguramente se ajustar√° a una p√°gina ra√≠z.  En la figura, se distribuye deliberadamente entre varias p√°ginas para mayor claridad. <br><br>  Est√° claro en este gr√°fico que la b√∫squeda por predicados como "class = 3" (buscar solo por el primer campo) o "class = 3 and model = 'Boeing 777-300'" (buscar por ambos campos) funcionar√° eficientemente. <br><br>  Sin embargo, la b√∫squeda por el predicado "modelo = 'Boeing 777-300'" ser√° mucho menos eficiente: comenzando con la ra√≠z, no podemos determinar a qu√© nodo hijo descender, por lo tanto, tendremos que descender a todos ellos.  Esto no significa que un √≠ndice como este no se pueda usar nunca; su eficiencia est√° en juego.  Por ejemplo, si tuvi√©ramos tres clases de aviones y una gran cantidad de modelos en cada clase, tendr√≠amos que revisar aproximadamente un tercio del √≠ndice y esto podr√≠a haber sido m√°s eficiente que el escaneo completo de la tabla ... o no. <br><br>  Sin embargo, si creamos un √≠ndice como este: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( model, (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>));</code> </pre><br>  el orden de los campos cambiar√°: <br><br><img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br><br>  Con este √≠ndice, la b√∫squeda por el predicado "model = 'Boeing 777-300'" funcionar√° de manera eficiente, pero la b√∫squeda por el predicado "class = 3" no lo har√°. <br><br><h3>  Nulos </h3><br>  El m√©todo de acceso "Btree" indexa NULL y admite la b√∫squeda por condiciones IS NULL y IS NOT NULL. <br><br>  Consideremos la tabla de vuelos, donde ocurren NULL: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (actual_arrival IS NULL) -&gt; Bitmap Index Scan on flights_actual_arrival_idx Index Cond: (actual_arrival IS NULL) (4 rows)</code> </pre><br>  Los NULL se encuentran en uno u otro extremo de los nodos hoja, dependiendo de c√≥mo se cre√≥ el √≠ndice (NULLS FIRST o NULLS LAST).  Esto es importante si una consulta incluye la clasificaci√≥n: el √≠ndice se puede usar si el comando SELECT especifica el mismo orden de NULL en su cl√°usula ORDER BY que el orden especificado para el √≠ndice creado (NULLS FIRST o NULLS LAST). <br><br>  En el siguiente ejemplo, estas √≥rdenes son las mismas, por lo tanto, podemos usar el √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS LAST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using flights_actual_arrival_idx on flights (1 row)</code> </pre><br>  Y aqu√≠ estas √≥rdenes son diferentes, y el optimizador elige el escaneo secuencial con la clasificaci√≥n posterior: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------- Sort Sort Key: actual_arrival NULLS FIRST -&gt; Seq Scan on flights (3 rows)</code> </pre><br>  Para usar el √≠ndice, debe crearse con NULL ubicados al principio: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_nulls_first_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using flights_nulls_first_idx on flights (1 row)</code> </pre><br>  Cuestiones como esta ciertamente son causadas por que los NULL no se pueden ordenar, es decir, el resultado de la comparaci√≥n de NULL y cualquier otro valor no est√° definido: <br><br><pre> <code class="pgsql hljs">demo=# \pset <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- NULL (1 row)</code> </pre><br>  Esto va en contra del concepto de √°rbol B y no encaja en el patr√≥n general.  Los NULL, sin embargo, juegan un papel tan importante en las bases de datos que siempre tenemos que hacer excepciones para ellos. <br><br>  Dado que los NULL se pueden indexar, es posible usar un √≠ndice incluso sin ninguna condici√≥n impuesta en la tabla (ya que el √≠ndice contiene informaci√≥n sobre todas las filas de la tabla con seguridad).  Esto puede tener sentido si la consulta requiere ordenar datos y el √≠ndice asegura el orden necesario.  En este caso, el planificador puede elegir el acceso al √≠ndice para guardar en una clasificaci√≥n separada. <br><br><h2>  Propiedades </h2><br>  Veamos las propiedades del m√©todo de acceso "btree" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya se han proporcionado consultas</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- btree | can_order | t btree | can_unique | t btree | can_multi_col | t btree | can_exclude | t</code> </pre><br>  Como hemos visto, B-tree puede ordenar datos y admite singularidad, y este es el √∫nico m√©todo de acceso que nos proporciona propiedades como estas.  Los √≠ndices de varias columnas tambi√©n est√°n permitidos, pero otros m√©todos de acceso (aunque no todos) tambi√©n pueden admitir dichos √≠ndices.  Discutiremos el soporte de la restricci√≥n EXCLUDE la pr√≥xima vez, y no sin raz√≥n. <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | t</code> </pre><br>  El m√©todo de acceso "Btree" admite ambas t√©cnicas para obtener valores: exploraci√≥n de √≠ndice, as√≠ como exploraci√≥n de mapa de bits.  Y como pudimos ver, el m√©todo de acceso puede caminar a trav√©s del √°rbol tanto "hacia adelante" como "hacia atr√°s". <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | t desc | f nulls_first | f nulls_last | t orderable | t distance_orderable | f returnable | t search_array | t search_nulls | t</code> </pre><br>  Las primeras cuatro propiedades de esta capa explican c√≥mo se ordenan exactamente los valores de una determinada columna espec√≠fica.  En este ejemplo, los valores se ordenan en orden ascendente ("asc") y los NULL se proporcionan al final ("nulls_last").  Pero como ya hemos visto, otras combinaciones son posibles. <br><br>  La propiedad "Search_array" indica que el √≠ndice admite expresiones como esta: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aircraft_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'733'</span></span>,<span class="hljs-string"><span class="hljs-string">'763'</span></span>,<span class="hljs-string"><span class="hljs-string">'773'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_pkey on aircrafts Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[])) (2 rows)</code> </pre><br>  La propiedad "Retornable" indica la compatibilidad con la exploraci√≥n de solo √≠ndice, lo cual es razonable ya que las filas del √≠ndice almacenan valores indexados (a diferencia del √≠ndice hash, por ejemplo).  Aqu√≠ tiene sentido decir algunas palabras sobre los √≠ndices de cobertura basados ‚Äã‚Äãen B-tree. <br><br><h3>  √çndices √∫nicos con filas adicionales </h3><br>  Como discutimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> , un √≠ndice de cobertura es el que almacena todos los valores necesarios para una consulta, no se requiere acceso a la tabla en s√≠ (casi).  Un √≠ndice √∫nico puede cubrir espec√≠ficamente. <br><br>  Pero supongamos que queremos agregar columnas adicionales necesarias para una consulta al √≠ndice √∫nico.  Sin embargo, la unicidad de tales valores compuestos no garantiza la unicidad de la clave, y luego se necesitar√°n dos √≠ndices en las mismas columnas: uno √∫nico para soportar la restricci√≥n de integridad y otro para ser utilizado como cobertura.  Esto es ineficiente con seguridad. <br><br>  En nuestra empresa, Anastasiya Lubennikova <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">lubennikovaav</a> mejor√≥ el m√©todo "btree" para que se pudieran incluir columnas adicionales, no √∫nicas, en un √≠ndice √∫nico.  Esperamos que este parche sea adoptado por la comunidad para formar parte de PostgreSQL, pero esto no suceder√° tan pronto como en la versi√≥n 10. En este punto, el parche est√° disponible en Pro Standard 9.5+, y esto es lo que parece me gusta <br><br><blockquote>  De hecho, este parche se comprometi√≥ con PostgreSQL 11. <br></blockquote><br>  Consideremos la tabla de reservas: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  En esta tabla, la clave primaria (book_ref, c√≥digo de reserva) es proporcionada por un √≠ndice "btree" regular.  Creemos un nuevo √≠ndice √∫nico con una columna adicional: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bookings(book_ref) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span> (book_date);</code> </pre><br>  Ahora reemplazamos el √≠ndice existente por uno nuevo (en la transacci√≥n, para aplicar todos los cambios simult√°neamente): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> bookings_pkey <span class="hljs-keyword"><span class="hljs-keyword">cascade</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> tickets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign key</span></span> (book_ref) <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> bookings (book_ref); demo=# <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>;</code> </pre><br>  Esto es lo que obtenemos: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Ahora, el mismo √≠ndice funciona como √∫nico y sirve como √≠ndice de cobertura para esta consulta, por ejemplo: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> book_ref, book_date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'059FC4'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Index Only Scan using bookings_pkey2 on bookings Index Cond: (book_ref = '059FC4'::bpchar) (2 rows)</code> </pre><br><h2>  Creaci√≥n del √≠ndice. </h2><br>  Es bien sabido, pero no menos importante, que para una tabla de gran tama√±o, es mejor cargar datos all√≠ sin √≠ndices y crear los √≠ndices necesarios m√°s adelante.  Esto no solo es m√°s r√°pido, sino que lo m√°s probable es que el √≠ndice tenga un tama√±o m√°s peque√±o. <br><br>  La cuesti√≥n es que la creaci√≥n del √≠ndice "btree" utiliza un proceso m√°s eficiente que la inserci√≥n de valores en fila en el √°rbol.  Aproximadamente, se ordenan todos los datos disponibles en la tabla y se crean p√°ginas de hoja de estos datos.  Luego, las p√°ginas internas se "construyen" sobre esta base hasta que toda la pir√°mide converja a la ra√≠z. <br><br>  La velocidad de este proceso depende del tama√±o de RAM disponible, que est√° limitado por el par√°metro "maintenance_work_mem".  Por lo tanto, aumentar el valor del par√°metro puede acelerar el proceso.  Para √≠ndices √∫nicos, se asigna memoria de tama√±o "work_mem" adem√°s de "maintenance_work_mem". <br><br><h3>  Sem√°ntica de comparaci√≥n </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La √∫ltima vez</a> que mencionamos que PostgreSQL necesita saber qu√© funciones hash solicitar valores de diferentes tipos y que esta asociaci√≥n se almacena en el m√©todo de acceso "hash".  Del mismo modo, el sistema debe descubrir c√≥mo ordenar los valores.  Esto es necesario para clasificaciones, agrupaciones (a veces), combinaciones de fusi√≥n, etc.  PostgreSQL no se une a los nombres de los operadores (como&gt;, &lt;, =) ya que los usuarios pueden definir su propio tipo de datos y dar a los operadores correspondientes diferentes nombres.  Una familia de operadores utilizada por el m√©todo de acceso "btree" define los nombres de los operadores en su lugar. <br><br>  Por ejemplo, estos operadores de comparaci√≥n se usan en la familia de operadores "bool_ops": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'bool_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> amopstrategy;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator | amopstrategy ---------------------+-------------- &lt;(boolean,boolean) | 1 &lt;=(boolean,boolean) | 2 =(boolean,boolean) | 3 &gt;=(boolean,boolean) | 4 &gt;(boolean,boolean) | 5 (5 rows)</code> </pre><br>  Aqu√≠ podemos ver cinco operadores de comparaci√≥n, pero como ya se mencion√≥, no debemos confiar en sus nombres.  Para determinar qu√© comparaci√≥n hace cada operador, se introduce el concepto de estrategia.  Se definen cinco estrategias para describir la sem√°ntica del operador: <br><br><ul><li>  1 - menos </li><li>  2 - menos o igual </li><li>  3 - igual </li><li>  4 - mayor o igual </li><li>  5 - mayor </li></ul><br>  Algunas familias de operadores pueden contener varios operadores que implementan una estrategia.  Por ejemplo, la familia de operadores "integer_ops" contiene los siguientes operadores para la estrategia 1: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'integer_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopstrategy = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator ---------------------- &lt;(integer,bigint) &lt;(smallint,smallint) &lt;(integer,integer) &lt;(bigint,bigint) &lt;(bigint,integer) &lt;(smallint,integer) &lt;(integer,smallint) &lt;(smallint,bigint) &lt;(bigint,smallint) (9 rows)</code> </pre><br>  Gracias a esto, el optimizador puede evitar la conversi√≥n de tipos al comparar valores de diferentes tipos contenidos en una familia de operadores. <br><br><h3>  Compatibilidad con √≠ndices para un nuevo tipo de datos </h3><br>  La documentaci√≥n proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> de creaci√≥n de un nuevo tipo de datos para n√∫meros complejos y de una clase de operador para ordenar valores de este tipo.  Este ejemplo usa lenguaje C, que es absolutamente razonable cuando la velocidad es cr√≠tica.  Pero nada nos impide usar SQL puro para el mismo experimento para tratar de comprender mejor la sem√°ntica de comparaci√≥n. <br><br>  Creemos un nuevo tipo compuesto con dos campos: partes reales e imaginarias. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (re <span class="hljs-type"><span class="hljs-type">float</span></span>, im <span class="hljs-type"><span class="hljs-type">float</span></span>);</code> </pre><br>  Podemos crear una tabla con un campo del nuevo tipo y agregar algunos valores a la tabla: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> numbers(x complex); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ((<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">10.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre><br>  Ahora surge una pregunta: ¬øc√≥mo ordenar n√∫meros complejos si no se define una relaci√≥n de orden para ellos en el sentido matem√°tico? <br><br>  Como resultado, los operadores de comparaci√≥n ya est√°n definidos para nosotros: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (0,10) (1,1) (1,3) (3 rows)</code> </pre><br>  De manera predeterminada, la ordenaci√≥n es por componentes para un tipo compuesto: primero se comparan los campos, luego los segundos campos, y as√≠ sucesivamente, aproximadamente de la misma manera que las cadenas de texto se comparan car√°cter por car√°cter.  Pero podemos definir un orden diferente.  Por ejemplo, los n√∫meros complejos pueden tratarse como vectores y ordenarse por el m√≥dulo (longitud), que se calcula como la ra√≠z cuadrada de la suma de los cuadrados de las coordenadas (el teorema de Pit√°goras).  Para definir dicho orden, creemos una funci√≥n auxiliar que calcule el m√≥dulo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> modulus(a complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> sqrt(a.re*a.re + a.im*a.im); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Ahora definiremos sistem√°ticamente las funciones para los cinco operadores de comparaci√≥n utilizando esta funci√≥n auxiliar: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_lt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_le(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_eq(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) = modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_ge(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_gt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Y crearemos los operadores correspondientes.  Para ilustrar que no necesitan llamarse "&gt;", "&lt;", etc., d√©mosles nombres "extra√±os". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #=#(leftarg=complex, rightarg=complex, procedure=complex_eq); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt);</code> </pre><br>  En este punto, podemos comparar n√∫meros: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>)::complex #&lt;# (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>)::complex;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Adem√°s de cinco operadores, el m√©todo de acceso "btree" requiere que se defina una funci√≥n m√°s (excesiva pero conveniente): debe devolver -1, 0 o 1 si el primer valor es menor, igual o mayor que el segundo uno.  Esta funci√≥n auxiliar se llama soporte.  Otros m√©todos de acceso pueden requerir la definici√≥n de otras funciones de soporte. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_cmp(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">case</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">-1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">else</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">end</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Ahora estamos listos para crear una clase de operador (y la familia de operadores con el mismo nombre se crear√° autom√°ticamente): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> complex_ops <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> btree <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> #&lt;#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> #&lt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> #=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> #&gt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> #&gt;#, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> complex_cmp(complex,complex);</code> </pre><br>  Ahora la clasificaci√≥n funciona seg√∫n lo deseado: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (1,1) (1,3) (0,10) (3 rows)</code> </pre><br>  Y sin duda ser√° compatible con el √≠ndice "btree". <br><br>  Para completar la imagen, puede obtener funciones de soporte utilizando esta consulta: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amp.amprocnum, amp.amproc, amp.amproclefttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, amp.amprocrighttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opfamily opf, pg_am am, pg_amproc amp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'complex_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amp.amprocfamily = opf.oid;</code> </pre><pre> <code class="plaintext hljs"> amprocnum | amproc | amproclefttype | amprocrighttype -----------+-------------+----------------+----------------- 1 | complex_cmp | complex | complex (1 row)</code> </pre><br><h2>  Internos </h2><br>  Podemos explorar la estructura interna del √°rbol B usando la extensi√≥n "pageinspect". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Metap√°gina del √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_metap(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> magic | version | root | level | fastroot | fastlevel --------+---------+------+-------+----------+----------- 340322 | 2 | 164 | 2 | 164 | 2 (1 row)</code> </pre><br>  Lo m√°s interesante aqu√≠ es el nivel de √≠ndice: el √≠ndice en dos columnas para una tabla con un mill√≥n de filas requiere tan solo 2 niveles (sin incluir la ra√≠z). <br><br>  Informaci√≥n estad√≠stica sobre el bloque 164 (ra√≠z): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, live_items, dead_items, avg_item_size, page_size, free_size <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_stats(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>);</code> </pre><pre> <code class="plaintext hljs"> type | live_items | dead_items | avg_item_size | page_size | free_size ------+------------+------------+---------------+-----------+----------- r | 33 | 0 | 31 | 8192 | 6984 (1 row)</code> </pre><br>  Y los datos en el bloque (el campo "datos", que aqu√≠ se sacrifica al ancho de la pantalla, contiene el valor de la clave de indexaci√≥n en representaci√≥n binaria): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> itemoffset, ctid, itemlen, left(data,<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid | itemlen | data ------------+---------+---------+---------------------------------------------------------- 1 | (3,1) | 8 | 2 | (163,1) | 32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00 3 | (323,1) | 32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00 4 | (482,1) | 32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00 5 | (641,1) | 32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00 (5 rows)</code> </pre><br>  El primer elemento pertenece a las t√©cnicas y especifica el l√≠mite superior de todos los elementos en el bloque (un detalle de implementaci√≥n que no discutimos), mientras que los datos en s√≠ comienzan con el segundo elemento.  Est√° claro que el nodo secundario m√°s a la izquierda es el bloque 163, seguido del bloque 323, y as√≠ sucesivamente.  Ellos, a su vez, pueden explorarse utilizando las mismas funciones. <br><br>  Ahora, siguiendo una buena tradici√≥n, tiene sentido leer la documentaci√≥n, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">README</a> y el c√≥digo fuente. <br><br>  Sin embargo, una extensi√≥n potencialmente √∫til m√°s es " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">amcheck</a> ", que se incorporar√° en PostgreSQL 10, y para versiones anteriores puede obtenerla de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> .  Esta extensi√≥n verifica la consistencia l√≥gica de los datos en los √°rboles B y nos permite detectar fallas por adelantado. <br><blockquote>  Eso es cierto, "amcheck" es una parte de PostgreSQL a partir de la versi√≥n 10. <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443284/">https://habr.com/ru/post/443284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443274/index.html">Recopilaci√≥n de noticias de la industria del juego del 8 de marzo al domingo</a></li>
<li><a href="../443276/index.html">Programador de consultas sorpresa en la base de datos PostgreSQL</a></li>
<li><a href="../443278/index.html">Coinbase crypto-exchange est√° perdiendo usuarios debido a la compra de una startup para los creadores de spyware del Hacking Team</a></li>
<li><a href="../443280/index.html">La historia de c√≥mo ensambl√© un cine en casa de 120 pulgadas con tubos, cuerdas, una pantalla plegable y terciopelo negro</a></li>
<li><a href="../443282/index.html">¬øQu√© debemos construir una blockchain?</a></li>
<li><a href="../443286/index.html">TDMS Fairway. Mecanismo de autocompletar para las principales inscripciones en los dibujos y detalles de los documentos.</a></li>
<li><a href="../443288/index.html">Navegaci√≥n en proyectos de m√≥dulos m√∫ltiples</a></li>
<li><a href="../443290/index.html">Zen Erlang [y Elixir - aprox. traductor</a></li>
<li><a href="../443292/index.html">Estudiamos el principio de funcionamiento de las unidades em utilizando el ejemplo de la tarea "Dise√±o de un precargador flexible"</a></li>
<li><a href="../443294/index.html">¬øQu√© permite Jupyter?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>