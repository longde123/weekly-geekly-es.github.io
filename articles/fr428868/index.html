<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öñÔ∏è ü§õüèΩ üçÖ Fichiers JAR √† plusieurs versions - mauvais ou bon? üêπ üëâüèæ üë≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis un traducteur: nous travaillons activement √† la traduction de la plate - forme sur des rails Java 11 et r√©fl√©chissons √† la fa√ßon de d√©velopper ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fichiers JAR √† plusieurs versions - mauvais ou bon?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/428868/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cn/ee/cmcnee4gyidm3xbo-0fl1fatdme.png"></div><br><p>  <em>Depuis un traducteur: nous travaillons activement √† la traduction de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plate</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">forme</a> sur des rails Java 11 et r√©fl√©chissons √† la fa√ßon de d√©velopper efficacement des biblioth√®ques Java (telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YARG</a> ), en tenant compte des fonctionnalit√©s de Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8/11</a> afin que vous n'ayez pas √† cr√©er des branches et des versions distinctes.</em>  <em>Une solution possible est un JAR √† plusieurs versions, mais tout n'est pas fluide.</em> </p><br><p>  Java 9 comprend une nouvelle option d'ex√©cution Java appel√©e JAR √† plusieurs versions.  C'est peut-√™tre l'une des innovations les plus controvers√©es de la plateforme.  <em>TL; DR: nous trouvons que c'est une solution tordue √† un probl√®me grave</em> .  Dans cet article, nous expliquerons pourquoi nous le pensons et vous expliquerons √©galement comment cr√©er un tel JAR si vous le souhaitez vraiment. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les JARs multi-versions</a> , ou MR JARs, est une nouvelle fonctionnalit√© de la plate-forme Java, introduite dans JDK 9. Nous allons d√©crire ici en d√©tail les risques importants associ√©s √† l'utilisation de cette technologie, et comment cr√©er des JARs multi-versions en utilisant Gradle, si vous voulez toujours. </p><br><p>  En fait, un JAR √† plusieurs versions est une archive Java qui comprend plusieurs variantes de la m√™me classe pour travailler avec diff√©rentes versions du runtime.  Par exemple, si vous travaillez dans JDK 8, l'environnement Java utilisera la version de classe pour JDK 8 et si dans Java 9, la version pour Java 9 est utilis√©e. De m√™me, si la version est cr√©√©e pour une future version de Java 10, le runtime utilise cette version au lieu de la version pour Java 9 ou la version par d√©faut (Java 8). </p><br><p>  Sous le chat, nous comprenons l'appareil du nouveau format JAR et voyons si c'est tout. </p><a name="habracut"></a><br><h2 id="kogda-ispolzovat-multi-release-jars">  Quand utiliser des fichiers JAR √† plusieurs versions </h2><br><ul><li>  Runtime optimis√©.  Il s'agit d'une solution au probl√®me auquel de nombreux d√©veloppeurs sont confront√©s: lors du d√©veloppement d'une application, on ne sait pas dans quel environnement elle sera ex√©cut√©e.  Cependant, pour certaines versions du runtime, vous pouvez incorporer des versions g√©n√©riques de la m√™me classe.  Supposons que vous souhaitiez afficher le num√©ro de version de Java dans lequel l'application s'ex√©cute.  Pour Java 9, vous pouvez utiliser la m√©thode Runtime.getVersion.  Cependant, il s'agit d'une nouvelle m√©thode disponible uniquement dans Java 9+.  Si vous avez besoin d'autres runtimes, par exemple Java 8, vous devez analyser la propri√©t√© java.version.  En cons√©quence, vous aurez 2 impl√©mentations diff√©rentes d'une fonction. </li><li><p>  API en conflit: la r√©solution des conflits entre les API est √©galement un probl√®me courant.  Par exemple, vous devez prendre en charge deux runtimes, mais dans l'un d'eux, l'API est obsol√®te.  Il existe 2 solutions courantes √† ce probl√®me: </p><br><ol><li>  Le premier est la r√©flexion.  Par exemple, vous pouvez sp√©cifier l'interface VersionProvider, puis 2 classes sp√©cifiques Java8VersionProvider et Java9VersionProvider, et charger la classe correspondante dans le runtime (c'est dr√¥le que pour choisir entre deux classes, vous devez analyser le num√©ro de version!).  L'une des options de cette solution consiste √† cr√©er une classe unique avec diff√©rentes m√©thodes appel√©es √† l'aide de la r√©flexion. </li><li>  Une solution plus avanc√©e consiste √† utiliser des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poign√©es de m√©thode</a> lorsque cela est possible.  Tr√®s probablement, la r√©flexion vous para√Ætra inhibitrice et inconfortable, et, en g√©n√©ral, telle qu'elle est. </li></ol><br></li></ul><br><h2 id="izvestnye-alternativy-podhodu-multi-release-jars">  Alternatives connues aux JAR √† plusieurs versions </h2><br><p> La deuxi√®me fa√ßon, plus simple et plus compr√©hensible, est de cr√©er 2 archives diff√©rentes pour des runtimes diff√©rents.  En th√©orie, vous cr√©ez deux impl√©mentations de la m√™me classe dans l'EDI, et les compiler, les tester et les emballer correctement dans 2 artefacts diff√©rents est la t√¢che du syst√®me de g√©n√©ration.  Il s'agit d'une approche qui a √©t√© utilis√©e √† Guava ou Spock depuis de nombreuses ann√©es.  Mais il est √©galement requis pour des langues comme Scala.  Et tout cela parce qu'il y a tellement d'options pour le compilateur et le runtime que la compatibilit√© binaire devient presque inaccessible. </p><br><p>  Mais il existe de nombreuses autres raisons d'utiliser des archives JAR distinctes: </p><br><ul><li>  JAR est juste un moyen d'emballage. </li></ul><br><p>  c'est un artefact d'assemblage qui inclut des classes, mais ce n'est pas tout: les ressources, en r√®gle g√©n√©rale, sont √©galement incluses dans l'archive.  L'emballage, comme la gestion des ressources, a un prix.  L'√©quipe Gradle vise √† am√©liorer la qualit√© de construction et √† r√©duire le temps d'attente pour le d√©veloppeur pour compiler les r√©sultats, les tests et le processus de construction en g√©n√©ral.  Si l'archive appara√Æt trop t√¥t dans le processus, un point de synchronisation inutile est cr√©√©.  Par exemple, pour compiler des classes d√©pendantes de l'API, la seule chose n√©cessaire est les fichiers .class.  Ni les archives du pot ni les ressources du pot ne sont n√©cessaires.  De m√™me, seuls les fichiers et les ressources Grade sont n√©cessaires pour ex√©cuter les tests Gradle.  Pour les tests, il n'est pas n√©cessaire de cr√©er un pot.  Il ne sera n√©cessaire que par un utilisateur externe (c'est-√†-dire lors de la publication).  Mais si la cr√©ation d'un artefact devient obligatoire, certaines t√¢ches ne peuvent pas √™tre ex√©cut√©es en parall√®le et l'ensemble du processus d'assemblage est inhib√©.  Si pour les petits projets ce n'est pas critique, pour les grands projets d'entreprise c'est le principal facteur de ralentissement. </p><br><ul><li>  il est beaucoup plus important que, √©tant un artefact, une archive jar ne puisse pas transporter d'informations sur les d√©pendances. </li></ul><br><p>  Il est peu probable que les d√©pendances de chaque classe dans Java 9 et Java 8 soient identiques.  Oui, dans notre exemple simple, ce sera le cas, mais pour les grands projets, ce n'est pas vrai: g√©n√©ralement, l'utilisateur importe le backport de la biblioth√®que pour la fonctionnalit√© Java 9 et l'utilise pour impl√©menter la version de la classe Java 8. Cependant, si vous emballez les deux versions dans une archive, dans un artefact il y aura des √©l√©ments avec diff√©rents arbres de d√©pendances.  Cela signifie que si vous travaillez avec Java 9, vous avez des d√©pendances qui ne seront jamais n√©cessaires.  De plus, il pollue le chemin de classe, cr√©ant des conflits probables pour les utilisateurs de biblioth√®que. </p><br><p>  Et enfin, dans un projet, vous pouvez cr√©er des fichiers JAR √† diff√©rentes fins: </p><br><ul><li>  pour l'API </li><li>  pour java 8 </li><li>  pour java 9 </li><li>  avec liaison native </li><li>  etc. </li></ul><br><p>  Une utilisation incorrecte du <em>classificateur de</em> d√©pendances entra√Æne des conflits li√©s au partage du m√™me m√©canisme.  Habituellement, les <em>sources</em> ou <em>javadocs</em> sont install√©s en tant que classificateurs, mais en r√©alit√©, ils n'ont pas de d√©pendances. </p><br><ul><li>  Nous ne voulons pas g√©n√©rer d'incoh√©rences; le processus de g√©n√©ration ne doit pas d√©pendre de la fa√ßon dont vous obtenez les classes.  En d'autres termes, l'utilisation de fichiers JAR √† plusieurs versions a un effet secondaire: appeler depuis l'archive JAR et appeler depuis le r√©pertoire de classe sont maintenant des choses compl√®tement diff√©rentes.  Ils ont une √©norme diff√©rence en s√©mantique! </li><li>  Selon l'outil que vous utilisez pour cr√©er le JAR, vous pouvez vous retrouver avec des archives JAR incompatibles!  Le seul outil qui garantit que lorsque vous empaquetez deux options de classe dans une archive, elles auront une seule API ouverte - l'utilitaire <em>jar</em> lui-m√™me.  Ce qui, non sans raison, n'implique pas n√©cessairement des outils d'assemblage ou m√™me des utilisateurs.  JAR est essentiellement une ¬´enveloppe¬ª ressemblant √† une archive ZIP.  Ainsi, selon la fa√ßon dont vous le collectez, vous obtiendrez diff√©rents comportements, ou peut-√™tre collecterez-vous un artefact incorrect (et vous ne le remarquerez pas). </li></ul><br><h2 id="bolee-effektivnye-sposoby-upravleniya-otdelnymi-jar-arhivami">  Des moyens plus efficaces pour g√©rer les archives JAR individuelles </h2><br><p>  La raison principale pour laquelle les d√©veloppeurs n'utilisent pas d'archives distinctes est qu'elles sont peu pratiques √† collecter et √† utiliser.  Les outils de construction sont √† bl√¢mer, qui, avant Gradle, ne s'en sortaient pas du tout.  En particulier, ceux qui ont utilis√© cette m√©thode dans Maven ne pouvaient compter que sur la fonction de <em>classificateur</em> faible pour publier des artefacts suppl√©mentaires.  Cependant, le <em>classificateur</em> n'aide pas dans cette situation difficile.  Ils sont utilis√©s √† diverses fins, de la publication de codes sources, de la documentation, des javadocs, √† l'impl√©mentation d'options de biblioth√®que (guava-jdk5, guava-jdk7, ...) ou √† divers cas d'utilisation (api, fat jar, ...).  En pratique, il n'y a aucun moyen de montrer que l'arbre de d√©pendances du <em>classifieur</em> est diff√©rent de l'arbre de d√©pendances du projet principal.  En d'autres termes, le format POM est fondamentalement cass√© car  Il repr√©sente la fa√ßon dont le composant est assembl√© et les artefacts qu'il fournit.  Supposons que vous ayez besoin d'impl√©menter 2 archives jar diff√©rentes: classique et fat jar, qui inclut toutes les d√©pendances.  Maven d√©cide que 2 artefacts ont des arbres de d√©pendance identiques, m√™me si c'est manifestement faux!  Dans ce cas, cela est plus qu'√©vident, mais la situation est la m√™me qu'avec les JAR √† plusieurs versions! </p><br><p>  La solution est de g√©rer correctement les options.  Gradle peut le faire en g√©rant les d√©pendances en fonction des options.  Cette fonctionnalit√© est actuellement disponible pour le d√©veloppement sur Android, mais nous travaillons √©galement sur sa version pour Java et les applications natives! </p><br><p>  La gestion des d√©pendances bas√©e sur les variantes est bas√©e sur le fait que les modules et les artefacts sont des choses compl√®tement diff√©rentes.  Le m√™me code peut parfaitement fonctionner dans diff√©rents temps d'ex√©cution, en tenant compte de diff√©rentes exigences.  Pour ceux qui travaillent avec la compilation native, cela est √©vident depuis longtemps: nous compilons pour <em>i386</em> et <em>amd64</em> et ne pouvons en aucun cas interf√©rer avec les d√©pendances de la biblioth√®que <em>i386</em> avec <em>arm64</em> !  Dans le contexte de Java, cela signifie que pour Java 8, vous devez cr√©er une version de l'archive JAR ¬´java 8¬ª, o√π le format de classe correspondra √† Java 8. Cet artefact contiendra des m√©tadonn√©es avec des informations sur les d√©pendances √† utiliser.  Pour Java 8 ou 9, les d√©pendances correspondant √† la version seront s√©lectionn√©es.  C'est aussi simple que cela (en fait, la raison n'est pas que le runtime n'est qu'un champ d'options, vous pouvez en combiner plusieurs). </p><br><p>  Bien s√ªr, personne ne l'avait fait auparavant en raison d'une complexit√© excessive: Maven, apparemment, ne permettrait jamais qu'une op√©ration aussi compliqu√©e soit effectu√©e.  Mais avec Gradle c'est possible.  L'√©quipe Gradle travaille actuellement sur un nouveau format de m√©tadonn√©es qui indique aux utilisateurs l'option √† utiliser.  Autrement dit, un outil de construction doit g√©rer la compilation, les tests, le conditionnement et le traitement de ces modules.  Par exemple, le projet devrait fonctionner dans les runtimes Java 8 et Java 9. Id√©alement, vous devez impl√©menter 2 versions de la biblioth√®que.  Cela signifie qu'il existe 2 compilateurs diff√©rents (pour √©viter d'utiliser l'API Java 9 lorsque vous travaillez en Java 8), 2 r√©pertoires de classe et, finalement, 2 archives JAR diff√©rentes.  Et aussi, tr√®s probablement, il sera n√©cessaire de tester 2 runtimes.  Ou vous impl√©mentez 2 archives, mais d√©cidez de tester le comportement de la version Java 8 dans le runtime Java 9 (car cela peut arriver au d√©marrage!). </p><br><p>  Ce sch√©ma n'a pas encore √©t√© mis en ≈ìuvre, mais l'√©quipe Gradle <a href="">a fait des progr√®s significatifs</a> dans cette direction. </p><br><h2 id="kak-sozdat-multi-release-jar-s-pomoschyu-gradle">  Comment cr√©er un JAR √† plusieurs versions √† l'aide de Gradle </h2><br><p>  Mais si cette fonction n'est pas encore pr√™te, que dois-je faire?  D√©tendez-vous, les artefacts corrects sont cr√©√©s de la m√™me mani√®re.  Avant que la fonction ci-dessus n'apparaisse dans l'√©cosyst√®me Java, il y a deux options: </p><br><ul><li>  bonne vieille m√©thode en utilisant la r√©flexion ou diff√©rentes archives JAR; </li><li>  utilisez des fichiers JAR √† plusieurs versions (notez que cela peut √™tre une mauvaise solution, m√™me s'il existe de bons cas d'utilisation). </li></ul><br><p>  Quoi que vous choisissiez, des archives diff√©rentes ou des fichiers JAR √† plusieurs versions, le sch√©ma sera le m√™me.  Les fichiers JAR √† plusieurs versions sont essentiellement le mauvais emballage: ils devraient √™tre une option, mais pas l'objectif.  Techniquement, la disposition source est la m√™me pour les fichiers JAR individuels et externes.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> d√©crit comment cr√©er un JAR √† plusieurs versions √† l'aide de Gradle.  L'essence du processus est bri√®vement d√©crite ci-dessous. </p><br><p>  Tout d'abord, vous devez toujours vous souvenir d'une mauvaise habitude des d√©veloppeurs: ils ex√©cutent Gradle (ou Maven) en utilisant la m√™me version de Java sur laquelle il est pr√©vu de lancer des artefacts.  De plus, parfois une version ult√©rieure est utilis√©e pour lancer Gradle, et la compilation se produit avec un niveau d'API ant√©rieur.  Mais il n'y a aucune raison particuli√®re de le faire.  A Gradle, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilation de Ross</a> est possible.  Il vous permet de d√©crire la position du JDK, ainsi que d'ex√©cuter la compilation en tant que processus distinct, pour compiler le composant √† l'aide de ce JDK.  La meilleure fa√ßon de configurer divers JDK est de configurer le chemin d'acc√®s au JDK via des variables d'environnement, comme cela est fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans ce fichier</a> .  Il vous suffit ensuite de configurer Gradle pour utiliser le bon JDK, en fonction de la compatibilit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avec la plate-forme source / cible</a> .  Il convient de noter qu'√† partir de JDK 9, les versions pr√©c√©dentes de JDK ne sont pas n√©cessaires pour la compilation crois√©e.  Cela fait une nouvelle fonctionnalit√©, -release.  Gradle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilise cette fonction et configurera le compilateur</a> selon les besoins. </p><br><p>  Un autre point cl√© est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensemble des sources de</a> d√©signation.  L'ensemble source est un ensemble de fichiers source qui doivent √™tre compil√©s ensemble.  Un JAR est obtenu en compilant un ou plusieurs ensembles source.  Pour chaque ensemble, Gradle cr√©e automatiquement une t√¢che de compilation personnalis√©e appropri√©e.  Cela signifie que s'il existe des sources pour Java 8 et Java 9, ces sources seront dans des ensembles diff√©rents.  C'est exactement ainsi que cela fonctionne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans l'ensemble source pour Java 9</a> , dans lequel il y aura une version de notre classe.  Cela fonctionne vraiment, et vous n'avez pas besoin de cr√©er un projet s√©par√©, comme dans Maven.  Mais surtout, cette m√©thode vous permet d'affiner la compilation de l'ensemble. </p><br><p>  L'une des difficult√©s d'avoir diff√©rentes versions d'une classe est que le code de classe est rarement ind√©pendant du reste du code (il a des d√©pendances avec des classes qui ne sont pas dans l'ensemble principal).  Par exemple, son API peut utiliser des classes qui n'ont pas besoin de sources sp√©ciales pour prendre en charge Java 9. En m√™me temps, je ne voudrais pas recompiler toutes ces classes communes et emballer leurs versions pour Java 9. Ce sont des classes communes, elles doivent donc exister s√©par√©ment de classes pour un JDK sp√©cifique.  Nous l'avons configur√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> : ajoutez une d√©pendance entre l'ensemble source pour Java 9 et l'ensemble principal, de sorte que lors de la compilation de la version pour Java 9, toutes les classes communes restent dans le chemin de classe de compilation. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'√©tape suivante est simple</a> : vous devez expliquer √† Gradle que l'ensemble principal de sources se compilera avec le niveau d'API Java 8 et l'ensemble pour Java 9 avec le niveau Java 9. </p><br><p>  Tout ce qui pr√©c√®de vous aidera √† utiliser les deux approches mentionn√©es pr√©c√©demment: impl√©menter des archives JAR distinctes ou des JAR √† plusieurs versions.  Puisque la publication porte sur ce sujet, regardons un exemple de comment obtenir Gradle pour construire un JAR √† plusieurs versions: </p><br><pre><code class="java hljs">jar { into(<span class="hljs-string"><span class="hljs-string">'META-INF/versions/9'</span></span>) { from sourceSets.java9.output } manifest.attributes( <span class="hljs-string"><span class="hljs-string">'Multi-Release'</span></span>: <span class="hljs-string"><span class="hljs-string">'true'</span></span> ) }</code> </pre> <br><p>  Ce bloc d√©crit: le conditionnement des classes pour Java 9 dans le <em>r√©pertoire META-INF / versions / 9</em> , qui est utilis√© pour les JAR MR, et la d√©finition de l'√©tiquette √† plusieurs versions dans le manifeste. </p><br><p>  Et voil√†, votre premier MR JAR est pr√™t! </p><br><p>  Mais malheureusement, le travail n'est pas termin√©.  Si vous avez travaill√© avec Gradle, vous savez que lorsque vous utilisez le plug-in d'application, vous pouvez ex√©cuter l'application directement via la t√¢che d' <em>ex√©cution</em> .  Cependant, √©tant donn√© que Gradle essaie g√©n√©ralement de r√©duire la quantit√© de travail, la t√¢che d' <em>ex√©cution</em> doit utiliser √† la fois les r√©pertoires de classe et les r√©pertoires des ressources trait√©es.  Pour les fichiers JAR √† plusieurs versions, c'est un probl√®me car les fichiers JAR sont n√©cessaires imm√©diatement!  Par cons√©quent, au lieu d'utiliser le plug-in, vous devrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cr√©er votre propre t√¢che</a> , et c'est un argument contre l'utilisation de JAR √† plusieurs versions. </p><br><p>  Enfin et surtout, nous avons mentionn√© que nous aurions besoin de tester 2 versions de la classe.  Pour cela, vous ne pouvez utiliser que des VM dans un processus distinct, car il n'y a pas d'√©quivalent du marqueur <em>-release</em> pour le runtime Java.  L'id√©e est qu'un seul test doit √™tre √©crit, mais il sera ex√©cut√© deux fois: en Java 8 et Java 9. C'est le seul moyen de s'assurer que les classes sp√©cifiques √† l'ex√©cution fonctionnent correctement.  Par d√©faut, Gradle cr√©e une t√¢che de test et utilise les r√©pertoires de classe de la m√™me mani√®re au lieu du JAR.  Par cons√©quent, nous allons faire deux choses: cr√©er une t√¢che de test pour Java 9 et configurer les deux t√¢ches afin qu'elles utilisent le JAR et les runtimes Java sp√©cifi√©s.  L'impl√©mentation ressemblera √† ceci: </p><br><pre> <code class="java hljs">test { dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_8"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 8"</span></span> } } <span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testJava9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Test)</span></span></span><span class="hljs-function"> </span></span>{ dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_9"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println classpath.asPath println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 9"</span></span> } } check.dependsOn(testJava9)</code> </pre> <br><p>  Maintenant, lorsque la t√¢che d√©marre, <em>v√©rifiez que</em> Gradle compilera chaque ensemble de sources √† l'aide du JDK souhait√©, cr√©era un JAR √† plusieurs versions, puis ex√©cutera les tests √† l'aide de ce JAR sur les deux JDK.  Les futures versions de Gradle vous aideront √† le faire de mani√®re plus d√©clarative. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Pour r√©sumer.  Vous avez appris que les fichiers JAR √† plusieurs versions sont une tentative de r√©soudre le vrai probl√®me auquel sont confront√©s de nombreux d√©veloppeurs de biblioth√®ques.  Cependant, cette solution au probl√®me semble √™tre incorrecte.  Gestion correcte des d√©pendances, liaison des artefacts et des options, souci des performances (la possibilit√© d'ex√©cuter autant de t√¢ches que possible en parall√®le) - tout cela fait de MR JAR une solution pour les pauvres.  Ce probl√®me peut √™tre r√©solu correctement √† l'aide des options.  Et pourtant, alors que la gestion des d√©pendances √† l'aide des options de Gradle est en cours de d√©veloppement, les fichiers JAR √† plusieurs versions sont tr√®s pratiques dans les cas simples.  Dans ce cas, cet article vous aidera √† comprendre comment faire cela et comment la philosophie de Gradle diff√®re de Maven (ensemble source vs projet). </p><br><p>  Enfin, nous ne nions pas qu'il existe des cas dans lesquels les JAR multi-versions ont du sens: par exemple, quand on ne sait pas dans quel environnement l'application sera ex√©cut√©e (pas une biblioth√®que), mais c'est plut√¥t une exception.  Dans cet article, nous avons d√©crit les principaux probl√®mes rencontr√©s par les d√©veloppeurs de biblioth√®ques et comment les JAR multi-versions tentent de les r√©soudre.  Mod√©lisation correcte des d√©pendances car les options am√©liorent les performances (gr√¢ce √† un parall√©lisme √† granularit√© fine) et r√©duisent les co√ªts de maintenance (√©vitant une complexit√© impr√©vue) par rapport aux JAR √† plusieurs versions.  Dans votre situation, des JAR MR peuvent √©galement √™tre n√©cessaires, donc Gradle a d√©j√† pris soin de cela.  Jetez un ≈ìil √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet exemple de projet</a> et essayez-le par vous-m√™me. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428868/">https://habr.com/ru/post/fr428868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428856/index.html">Une merveilleuse astuce pour faire du mainteneur de projet open source un jour</a></li>
<li><a href="../fr428858/index.html">Conf√©rence DEFCON 17. Riez de vos virus! Partie 1</a></li>
<li><a href="../fr428860/index.html">Conf√©rence DEFCON 17. Riez de vos virus! 2e partie</a></li>
<li><a href="../fr428864/index.html">Rendons le Web encore meilleur</a></li>
<li><a href="../fr428866/index.html">7 principes de design, attitude face aux tendances du design, portfolio UX-designer, ...</a></li>
<li><a href="../fr428870/index.html">Mrr: FRP total pour React</a></li>
<li><a href="../fr428872/index.html">L'histoire d'un ≈ìil et de 20 op√©rations (non lisible) ou il voulait √™tre pilote, mais il n'√©tait pas autoris√© √† voler dans le ciel</a></li>
<li><a href="../fr428876/index.html">Il n'y a pas de retour en arri√®re: l'exp√©rience personnelle du testeur</a></li>
<li><a href="../fr428878/index.html">Pig Flight, ou optimisation des interpr√®tes Bytecode</a></li>
<li><a href="../fr428880/index.html">Nouvelles m√©thodes d'authentification - une menace pour la vie priv√©e?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>