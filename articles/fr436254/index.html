<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏾 🤛🏻 🛍️ Un bot pour Starcraft en rouille, C ou toute autre langue 👩🏿‍🤝‍👩🏾 🤘 📛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="StarCraft: Brood War . Ce jeu compte beaucoup pour moi! Et pour beaucoup d'entre vous, je suppose. Tellement, que je me demande si je devrais même don...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un bot pour Starcraft en rouille, C ou toute autre langue</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436254/"><img src="https://habrastorage.org/webt/qv/fa/ex/qvfaexsnkzmckmwrt_spqmc7nr4.png" align="left"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StarCraft: Brood War</a> .  Ce jeu compte beaucoup pour moi!  Et pour beaucoup d'entre vous, je suppose.  Tellement, que je me demande si je devrais même donner un lien vers sa page sur Wikipedia ou non. </p><br><p>  Une fois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Halt</a> m'a envoyé PM et m'a proposé d'apprendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust</a> .  Comme toute personne ordinaire, nous avons décidé de commencer par <del>  bonjour le monde </del>  écrire une bibliothèque dynamique pour Windows qui pourrait être chargée dans l'espace d'adressage de StarCraft et gérer les unités. </p><br><p>  L'article suivant décrira le processus de recherche de solutions et l'utilisation de technologies et de techniques qui vous permettront d'apprendre de nouvelles choses sur Rust et son écosystème.  Vous pouvez également être inspiré pour implémenter un bot en utilisant votre langage préféré, que ce soit C, C ++, Ruby, Python, etc. </p><a name="habracut"></a><br><p>  Il vaut vraiment la peine d'écouter l'hymne de la Corée du Sud en lisant cet article: </p><br><div class="spoiler">  <b class="spoiler_title">Starcraft OST</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/pNt0iVG2VOA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2 id="bwapi">  Bwapi </h2><br><p>  Ce jeu a presque 20 ans.  Et c'est toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">populaire</a> ;  Les championnats ont attiré des foules de gens aux États-Unis même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en 2017,</a> où la bataille des grands maîtres Jaedong contre Bisu a eu lieu.  En plus des joueurs humains, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">machines sans âme</a> participent également aux batailles SC!  Et cela est possible grâce à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BWAPI</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liens</a> plus utiles. </p><br><p>  Depuis plus d'une décennie maintenant, il y a une communauté de développeurs de bots autour de ce jeu.  Les amateurs créent des bots et participent à divers championnats.  Beaucoup d'entre eux étudient l'IA et l'apprentissage automatique.  Le BWAPI est utilisé par les universités pour former leurs étudiants.  Il existe même une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne Twitch</a> diffusant de tels matchs. </p><br><p>  Ainsi, une équipe de fans a inversé le back-end de Starcraft il y a plusieurs années et a développé une API en C ++, qui vous permet de créer des bots, de faire des injections dans le processus de jeu et de dominer les humains misérables. </p><br><p>  Comme cela arrive souvent, avant <del>  construire une maison, il faut extraire du minerai, forger des outils </del>  la création d'un bot, vous devez implémenter une API.  Qu'est-ce que Rust a à offrir? </p><br><h2 id="ffi">  Ffi </h2><br><p>  Il est assez simple de travailler avec d'autres langues de Rust.  Il y a un <abbr title="Interface de fonction étrangère">FFI</abbr> pour cela.  Permettez-moi de vous donner un court extrait de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la documentation</a> . </p><br><p>  Imaginez que nous ayons une bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">snappy</a> , qui a un fichier d'en <a href="">-</a> tête <a href="">snappy-ch</a> , qui contient des déclarations de fonctions. </p><br><p>  Créons un projet avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cargo</a> . </p><br><pre><code class="bash hljs">$ cargo new --bin snappy Created binary (application) `snappy` project $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> snappy snappy$ tree . ├── Cargo.toml └── src └── main.rs 1 directory, 2 files</code> </pre> <br><p>  Cargo a créé une structure de fichiers standard pour le projet. </p><br><p>  Dans <code>Cargo.toml</code> nous <code>Cargo.toml</code> dépendance à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libc</a> : </p><br><pre> <code class="plaintext hljs">[dependencies] libc = "0.2"</code> </pre> <br><p>  Le fichier <code>src/main.rs</code> ressemblera à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> libc; <span class="hljs-comment"><span class="hljs-comment">// To import C types, in our case for size_t use libc::size_t; #[link(name = "snappy")] // Specify the name of the library for linking the function extern { // We write the declaration of the function which we want to import // in C the declaration looks like this: // size_t snappy_max_compressed_length(size_t source_length); fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t; } fn main() { let x = unsafe { snappy_max_compressed_length(100) }; println!("max compressed length of a 100 byte buffer: {}", x); }</span></span></code> </pre> <br><p>  Construisons et exécutons le projet: </p><br><pre> <code class="bash hljs">snappy$ cargo build ... snappy$ cargo run Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.02s Running `target/debug/snappy` max compressed length of a 100 byte buffer: 148</code> </pre> <br><p>  Vous ne pouvez appeler que le <code>cargo run</code> , ce qui appelle la <code>cargo build</code> avant le vol.  Une autre option est de construire le projet et d'appeler directement le binaire: </p><br><pre> <code class="bash hljs">snappy$ ./target/debug/snappy max compressed length of a 100 byte buffer: 148</code> </pre> <br><p>  Si la bibliothèque snappy est installée, le code sera compilé (pour Ubuntu, vous devez installer le paquet libsnappy-dev). </p><br><pre> <code class="bash hljs">snappy$ ldd target/debug/snappy ... libsnappy.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libsnappy.so.1 (0x00007f8de07cf000)</code> </pre> <br><p>  Comme vous pouvez le voir, notre binaire est lié à la bibliothèque partagée libsnappy.  Et un appel à <code>snappy_max_compressed_length</code> dans notre code est un appel de fonction de cette bibliothèque. </p><br><h2 id="rust-bindgen">  rouille-bindgen </h2><br><p>  Ce serait bien si nous pouvions générer automatiquement notre FFI.  Heureusement, il existe un utilitaire appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rust-bindgen</a> dans la boîte à outils d'un addict de Rust.  Il est capable de générer des liaisons FFI vers les bibliothèques C (et certaines C ++). </p><br><p>  Installation: </p><br><pre> <code class="bash hljs">$ cargo install bindgen</code> </pre> <br><p>  À quoi ressemble le <strong>rust-bindgen</strong> ?  Nous prenons les fichiers d'en-tête C / C ++, nous <strong>pointons l'</strong> utilitaire <strong>bindgen</strong> vers eux, et la sortie que nous obtenons est un code Rust généré avec les déclarations appropriées pour nous permettre d'utiliser les structures et les fonctions C.  Voici ce que <code>bindgen</code> génère pour <code>bindgen</code> : </p><br><pre> <code class="rust hljs">$ bindgen /usr/include/snappy-ch | grep -C <span class="hljs-number"><span class="hljs-number">1</span></span> snappy_max_compressed_length <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snappy_max_compressed_length</span></span></span></span>(source_length: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; }</code> </pre> <br><p>  Il s'avère que bindgen ne peut pas faire face aux en-têtes BWAPI, générant des tonnes de code non utilisable (à cause des fonctions membres virtuelles, std :: string dans une API publique, etc.).  Le fait est que BWAPI est écrit en C ++.  C ++ est généralement difficile à utiliser même à partir de projets C ++.  Une fois la bibliothèque assemblée, il est préférable de la lier avec le même éditeur de liens (même version), les fichiers d'en-tête doivent être analysés avec le même compilateur (même version).  Tous ces facteurs peuvent affecter le résultat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mangling</a> par exemple, qui ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut</a> toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas être implémenté sans erreurs</a> dans GNU GCC.  Ces facteurs sont si importants que même <abbr title="Cadre de test C ++ de Google">gtest</abbr> n'a pas pu le surmonter.  Et dans la <a href="">documentation,</a> il est dit: vous feriez mieux de construire gtest dans le cadre du projet par le même compilateur et le même éditeur de liens. </p><br><h2 id="bwapi-c">  Bwapi-c </h2><br><p>  C est la lingua franca du génie logiciel.  Si rust-bindgen fonctionne bien pour le langage C, pourquoi ne pas implémenter BWAPI pour C, puis utiliser son API?  Bonne idée! </p><br><p>  Oui, c'est une bonne idée jusqu'à ce que vous examiniez l'intérieur de BWAPI et que vous voyiez le nombre de classes et de méthodes que vous devez implémenter.  Surtout toutes ces dispositions de mémoire, codes asm, correctifs de mémoire et autres "horreurs" pour lesquelles nous n'avons pas le temps.  Il est nécessaire d'utiliser complètement la solution existante. </p><br><p>  Mais nous devons en quelque sorte battre les fonctions de mangling, de code C ++, d'héritage et de membre virtuel. </p><br><p>  En C ++, il existe deux outils puissants que nous utiliserons pour résoudre notre problème: les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pointeurs opaques</a> et le <code>extern "C"</code> . </p><br><p>  <code>extern "C" {}</code> permet au code C ++ de se "masquer" lui-même sous C. Il permet de générer des noms de fonction sans malmener. </p><br><p>  Les pointeurs opaques nous permettent d'effacer le type et de créer un pointeur vers "un certain type" sans fournir son implémentation.  Comme il ne s'agit que d'une déclaration d'un certain type, il est impossible d'utiliser ce type par valeur, vous ne pouvez l'utiliser que par pointeur. </p><br><p>  Imaginons que nous ayons ce code C ++: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> cpp { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bar; } }; } <span class="hljs-comment"><span class="hljs-comment">// namespace cpp</span></span></code> </pre> <br><p>  Nous pouvons le transformer en un en-tête C: </p><br><pre> <code class="plaintext hljs">extern "C" { typedef struct Foo_ Foo; // Opaque pointer to Foo // call cpp::Foo::get_bar int Foo_get_bar(Foo* self); }</code> </pre> <br><p>  Et voici la partie C ++ qui sera le lien entre l'en-tête C et l'implémentation C ++: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo_get_bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Foo* self)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// cast the opaque pointer to the certain cpp::Foo and call the method ::get_bar return reinterpret_cast&lt;cpp::Foo*&gt;(self)-&gt;get_bar(); }</span></span></code> </pre> <br><p>  Toutes les méthodes de cours n'ont pas dû être traitées de cette façon.  Dans BWAPI, il existe des classes que vous pouvez implémenter vous-même en utilisant les champs de ces structures, par exemple <code>typedef struct Position { int x; int y; } Position;</code> <code>typedef struct Position { int x; int y; } Position;</code>  et des méthodes comme <code>Position::get_distance</code> . </p><br><p>  Il y avait des cours que je devais traiter d'une manière spéciale.  Par exemple, AIModule doit être un pointeur vers une classe C ++ avec un ensemble spécifique de fonctions membres virtuelles.  Néanmoins, voici l'en- <a href="">tête</a> et l' <a href="">implémentation</a> . </p><br><p>  Ainsi, après plusieurs mois de dur labeur, <strong>554</strong> méthodes et une douzaine de classes, la bibliothèque multiplateforme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BWAPI-C</a> est née, qui vous permet <a href="">de créer des bots en C.</a>  Un sous-produit était la possibilité de compilation croisée et la possibilité d'implémenter l'API dans n'importe quel autre langage prenant en charge FFI et la convention d'appel cdecl. </p><br><p>  Si vous écrivez une bibliothèque, veuillez écrire son API en C. </p><br><p>  La caractéristique la plus importante de BWAPI-C est l'intégration la plus large possible avec d'autres langages de programmation.  <code>Python</code> , <code>Ruby</code> , <code>Rust</code> , <code>PHP</code> , <code>Java</code> et bien d'autres sont capables de travailler avec C, donc si vous corrigez les problèmes et implémentez vos propres wrappers, vous pouvez également écrire un bot avec leur aide. </p><br><h2 id="writing-a-bot-in-c">  Écrire un bot en C </h2><br><p>  Cette partie décrit les principes généraux de l'organisation interne des modules Starcraft. </p><br><p>  Il existe 2 types de bots: module et client.  Regardons un exemple d'écriture d'un module. </p><br><p>  Le module est une bibliothèque dynamique.  Le principe général du chargement des bibliothèques dynamiques peut être consulté <a href="">ici</a> .  Le module devrait exporter 2 fonctions: <code>newAIModule</code> et <code>gameInit</code> . </p><br><p>  <code>gameInit</code> est facile.  Cette fonction est appelée pour passer un pointeur sur une partie en cours.  Ce pointeur est très important, car il existe une variable statique globale dans les caractères génériques de BWAPI, qui est utilisée dans certaines sections du code.  <code>gameInit</code> : </p><br><pre> <code class="plaintext hljs">DLLEXPORT void gameInit(void* game) { BWAPIC_setGame(game); }</code> </pre> <br><p>  <code>newAIModule</code> est un peu plus compliqué.  Il devrait renvoyer le pointeur vers une classe C ++, qui a une table de méthode virtuelle avec des noms comme <strong>onXXXXX</strong> qui sont appelés sur certains événements de jeu.  Déclarons la structure du module: </p><br><pre> <code class="plaintext hljs">typedef struct ExampleAIModule { const AIModule_vtable* vtable_; const char* name; } ExampleAIModule;</code> </pre> <br><p>  Le premier champ doit être un pointeur vers la table des méthodes (c'est une sorte de magie).  Voici la <code>newAIModule</code> fonction <code>newAIModule</code> : </p><br><pre> <code class="plaintext hljs">DLLEXPORT void* newAIModule() { ExampleAIModule* const module = (ExampleAIModule*) malloc( sizeof(ExampleAIModule) ); module-&gt;name = "ExampleAIModule"; module-&gt;vtable_ = &amp;module_vtable; return createAIModuleWrapper( (AIModule*) module ); }</code> </pre> <br><p>  <code>createAIModuleWrapper</code> est une autre astuce magique qui transforme le pointeur C en pointeur vers la classe C ++ avec <del>  méthodes virtuelles </del>  fonctions des membres. </p><br><p>  <code>module_vtable</code> est une variable statique sur la table des méthodes, les valeurs des méthodes sont remplies de pointeurs vers les fonctions globales: </p><br><pre> <code class="plaintext hljs">static AIModule_vtable module_vtable = { onStart, onEnd, onFrame, onSendText, onReceiveText, onPlayerLeft, onNukeDetect, onUnitDiscover, onUnitEvade, onUnitShow, onUnitHide, onUnitCreate, onUnitDestroy, onUnitMorph, onUnitRenegade, onSaveGame, onUnitComplete }; void onEnd(AIModule* module, bool isWinner) { } void onFrame(AIModule* module) {} void onSendText(AIModule* module, const char* text) {} void onReceiveText(AIModule* module, Player* player, const char* text) {} void onPlayerLeft(AIModule* module, Player* player) {} void onNukeDetect(AIModule* module, Position target) {} void onUnitDiscover(AIModule* module, Unit* unit) {} void onUnitEvade(AIModule* module, Unit* unit) {} void onUnitShow(AIModule* module, Unit* unit) {} void onUnitHide(AIModule* module, Unit* unit) {} void onUnitCreate(AIModule* module, Unit* unit) {} void onUnitDestroy(AIModule* module, Unit* unit) {} void onUnitMorph(AIModule* module, Unit* unit) {} void onUnitRenegade(AIModule* module, Unit* unit) {} void onSaveGame(AIModule* module, const char* gameName) {} void onUnitComplete(AIModule* module, Unit* unit) {}</code> </pre> <br><p>  Si vous regardez le nom des fonctions et leurs signatures, il est clair dans quelles conditions et avec quels arguments elles doivent être appelées.  Pour un <a href="">exemple,</a> j'ai rendu toutes les fonctions vides, sauf </p><br><pre> <code class="plaintext hljs">void onStart(AIModule* module) { ExampleAIModule* self = (ExampleAIModule*) module; Game* game = BWAPIC_getGame(); Game_sendText(game, "Hello from bwapi-c!"); Game_sendText(game, "My name is %s", self-&gt;name); }</code> </pre> <br><p>  Cette fonction est appelée lorsque le jeu s'exécute.  L'argument est un pointeur vers le module actuel.  <code>BWAPIC_getGame</code> renvoie un pointeur global sur le jeu, que nous définissons à l'aide d'un appel à <code>BWAPIC_setGame</code> .  Alors, montrons un exemple de travail de compilation croisée d'un module: </p><br><pre> <code class="bash hljs">bwapi-c/example$ tree . ├── BWAPIC.dll └── Dll.c 0 directories, 2 files bwapi-c/example$ i686-w64-mingw32-gcc -mabi=ms -shared -o Dll.dll Dll.c -I../include -L. -lBWAPIC bwapi-c/example$ cp Dll.dll ~/Starcraft/bwapi-data/ bwapi-c/example$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Starcraft/bwapi-data/ Starcraft$ wine bwheadless.exe -e StarCraft.exe -l bwapi-data/BWAPI.dll --headful ... ... ...</code> </pre> <br><p>  Appuyez sur les boutons et lancez le jeu.  Plus d'informations sur la compilation et l'exécution peuvent être trouvées sur le site Web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BWAPI</a> et dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BWAPI-C</a> . </p><br><p>  Le résultat du module: </p><br><p><img src="https://habrastorage.org/webt/cw/a-/41/cwa-41ihsyva-pj2stpef1xjn2g.png" alt="image"></p><br><p>  Vous pouvez trouver un exemple un peu plus compliqué d'un module qui montre comment travailler avec les itérateurs, la gestion des unités, la recherche de minéraux et la sortie des statistiques dans <a href="">bwapi-c / example / Dll.c.</a> </p><br><h2 id="bwapi-sys">  bwapi-sys </h2><br><p>  Dans l'écosystème Rust, il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une certaine façon</a> de nommer les packages liés aux bibliothèques natives.  Tout paquet foo-sys exécute deux fonctions importantes: </p><br><ul><li>  liens avec la bibliothèque native libfoo; </li><li>  fournit des déclarations aux fonctions de la bibliothèque libfoo.  Mais des déclarations seulement!  Les abstractions de haut niveau ne sont pas fournies dans les caisses * -sys. </li></ul><br><p>  Pour que le package * -sys puisse se lier avec succès, vous devez dire à cargo <a href="">de rechercher</a> la bibliothèque native et / ou de <a href="">construire</a> la bibliothèque à partir des sources. </p><br><p>  Pour que le package * -sys fournisse des déclarations, vous devez soit les écrire vous-même, soit les générer à l'aide de bindgen.  Encore une fois bindgen.  Tentative numéro deux =) </p><br><p>  La génération de fixations est super simple: </p><br><pre> <code class="bash hljs">bindgen BWAPI.h -o lib.rs \ --opaque-type <span class="hljs-string"><span class="hljs-string">".+_"</span></span> \ --blacklist-type <span class="hljs-string"><span class="hljs-string">"std.*|__.+|.+_$|Game_v(Send|Print|Draw).*|va_list|.+_t$"</span></span> \ --no-layout-tests \ --no-derive-debug \ --raw-line <span class="hljs-string"><span class="hljs-string">"#![allow(improper_ctypes, non_snake_case)]"</span></span> \ -- -I../submodules/bwapi-c/include sed -i -r -- <span class="hljs-string"><span class="hljs-string">'s/.+\s+(.+)_;/pub struct \1;/'</span></span> lib.rs</code> </pre> <br><p>  <code>BWAPI.h</code> est un fichier contenant tous les en-têtes C de BWAPI-C. </p><br><p>  Par exemple, bindgen a déjà généré de telles déclarations pour les fonctions ci-dessus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-comment"><span class="hljs-comment">/// BWAPIC_setGame must be called from gameInit to initialize BWAPI::BroodwarPtr pub fn BWAPIC_setGame(game: *mut Game); } extern "C" { pub fn BWAPIC_getGame() -&gt; *mut Game; }</span></span></code> </pre> <br><p>  Il existe deux stratégies: stocker le code généré dans le référentiel et générer le code à la volée lors de la génération.  Les deux approches ont leurs avantages et leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inconvénients</a> . </p><br><p>  Heureux de vous rencontrer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bwapi-sys</a> ;  un petit pas de plus vers notre objectif. </p><br><p>  Vous souvenez-vous que plus tôt je parlais de multiplateforme?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">nlinker a</a> rejoint le projet et mis en œuvre une stratégie astucieuse.  Si l'hôte cible est Windows, téléchargez le BWAPIC déjà assemblé depuis GitHub.  Et pour les cibles restantes, nous collectons BWAPI-C à partir des sources d'OpenBW (je vous en parlerai un peu plus tard). </p><br><h2 id="bwapi-rs">  bwapi-rs </h2><br><p>  Nous avons maintenant les liaisons et nous pouvons définir des abstractions de haut niveau.  Nous avons deux types avec lesquels travailler: des valeurs pures et des pointeurs opaques. </p><br><p>  Tout est simple avec des valeurs pures.  Prenons l'exemple des couleurs.  Nous devons le rendre facile à utiliser à partir du code Rust afin d'utiliser les couleurs de manière pratique et naturelle: </p><br><pre> <code class="rust hljs">game.draw_line(CoordinateType::Screen, (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>), (<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>), Color::Red); ^^^</code> </pre> <br><p>  Ainsi, pour une utilisation pratique, il serait nécessaire de définir l'énumération avec des <a href="">constantes</a> C ++ mais également idiomatique pour Rust, et de définir des méthodes de conversion dans bwapi_sys :: Color en utilisant std :: convert :: From: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// FFI version #[repr(C)] #[derive(Copy, Clone)] pub struct Color { pub color: ::std::os::raw::c_int, } // Idiomatic version #[derive(PartialEq, PartialOrd, Copy, Clone)] pub enum Color { Black = 0, Brown = 19, ...</span></span></code> </pre> <br><p>  Pour votre commodité, vous pouvez utiliser la caisse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enum-primitive-derive</a> . </p><br><p>  Il est également facile d'utiliser des pointeurs opaques.  Utilisons le modèle <a href="">Newtype</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Player</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sys::Player);</code> </pre> <br><p>  Cela signifie que Player est une sorte de structure avec un champ privé - un pointeur opaque brut de C. Et voici la façon dont vous pouvez définir la couleur Player ::: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Player { <span class="hljs-comment"><span class="hljs-comment">// so the method is declared Player::getColor in bwapi-sys //extern "C" { // pub fn Player_getColor(self_: *mut Player) -&gt; Color; //} pub fn color(&amp;self) -&gt; Color { // bwapi_sys::Player_getColor - wrapper function from BWAPI-C // self.0 - opaque pointer let color = unsafe { bwapi_sys::Player_getColor(self.0) }; color.into() // cast bwapi_sys::Color -&gt; Color } }</span></span></code> </pre> <br><p>  Nous pouvons maintenant écrire notre premier bot en rouille! </p><br><h2 id="creating-a-bot-in-rust">  Créer un bot dans Rust </h2><br><p>  Comme preuve de concept, le bot sera similaire à un pays bien connu: toute la tâche consiste à embaucher des travailleurs et à collecter des minéraux. </p><br><p><img src="https://habrastorage.org/webt/hx/r_/jm/hxr_jmj2fbsitx-tfw96p2pa2tu.png" alt="Corée du Nord"></p><br><p><img src="https://habrastorage.org/webt/ww/gf/lr/wwgflrekcnxtv75thaurrwcm0g8.png" alt="Corée du sud"></p><br><p>  Commençons par les fonctions requises <code>gameInit</code> et <code>newAIModule</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gameInit</span></span></span></span>(game: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> void) { bwapi_sys::BWAPIC_setGame(game <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bwapi_sys::Game); } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newAIModule</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> void { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> module = ExampleAIModule { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"ExampleAIModule"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = wrap_handler(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(module)); result }</code> </pre> <br><p>  <code>#[no_mangle]</code> remplit la même fonction que l' <code>extern "C"</code> en C ++.  A l'intérieur de <code>wrap_handler</code> toute la magie se produit, avec la substitution de la table de fonction virtuelle et de la classe C ++ "masquante". </p><br><p>  Les définitions de la structure du module sont encore plus simples et plus sophistiquées qu'en C: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleAIModule</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Ajoutons quelques méthodes pour rendre les statistiques et donner des ordres: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ExampleAIModule { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_stat</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> game = Game::get(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Frame {}"</span></span>, game.frame_count()); game.draw_text(CoordinateType::Screen, (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), &amp;message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give_orders</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> player = Game::get().self_player(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> player.units() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> unit.get_type() { UnitType::Terran_SCV | UnitType::Zerg_Drone | UnitType::Protoss_Probe =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !unit.is_idle() { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit.is_carrying_gas() || unit.is_carrying_minerals() { unit.return_cargo(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(mineral) = Game::get() .minerals() .min_by_key(|m| unit.distance_to(m)) { <span class="hljs-comment"><span class="hljs-comment">// WE REQUIRE MORE MINERALS unit.right_click(&amp;mineral, false); } } UnitType::Terran_Command_Center =&gt; { unit.train(UnitType::Terran_SCV); } UnitType::Protoss_Nexus =&gt; { unit.train(UnitType::Protoss_Probe); } UnitType::Zerg_Hatchery | UnitType::Zerg_Lair | UnitType::Zerg_Hive =&gt; { unit.train(UnitType::Zerg_Drone); } _ =&gt; {} }; } } }</span></span></code> </pre> <br><p>  Pour transformer le type ExampleAIModule en un véritable module, vous devez le faire répondre aux événements <strong>onXXXX</strong> .  Pour ce faire, vous devez implémenter le type EventHandler, qui est un analogue de la table virtuelle AIModule_vtable de C: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> EventHandler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ExampleAIModule { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { Game::get().send_text(&amp;<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello from Rust! My name is {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_end</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _is_winner: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_frame</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.draw_stat(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.give_orders(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_send_text</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_receive_text</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _player: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Player, _text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_player_left</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _player: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Player) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_nuke_detect</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _target: Position) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_discover</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_evade</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_show</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_hide</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_destroy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_morph</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_renegade</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_save_game</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _game_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_complete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} }</code> </pre> <br><p>  La construction et l'exécution du module sont aussi simples que pour C: </p><br><pre> <code class="bash hljs">bwapi-rs$ cargo build --example dll --target=i686-pc-windows-gnu bwapi-rs$ cp ./target/i686-pc-windows-gnu/debug/examples/dll.dll ~/Starcraft/bwapi-data/Dll.dll bwapi-rs$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Starcraft/bwapi-data/ Starcraft$ wine bwheadless.exe -e StarCraft.exe -l bwapi-data/BWAPI.dll --headful ... ... ...</code> </pre> <br><p>  Et la vidéo de l'oeuvre: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rACbnWpI01M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="openbw">  Openbw </h2><br><p>  Ces gars sont allés encore plus loin.  Ils ont décidé d'écrire une version open source de SC: BW!  Et ils sont bons dans ce domaine.  L'un de leurs objectifs était d'implémenter des images HD, mais SC: Remastered était en avance sur eux = (En ce moment, vous pouvez utiliser leur API pour écrire des bots (oui, également en C ++), mais la fonctionnalité la plus étonnante est la possibilité de visualiser rejoue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">directement dans votre navigateur</a> . </p><br><h2 id="conclusion">  Conclusion </h2><br><p>  Il y avait un problème non résolu avec l'implémentation: nous ne contrôlons pas que les références soient uniques, donc l'existence de <code>&amp;mut</code> et <code>&amp;</code> vers la même région entraînera un comportement indéfini lorsque l'objet est modifié.  Une sorte de problème.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Halt a</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">essayé</a> d'implémenter des liaisons idiomatiques, mais il n'a pas réussi à trouver une solution.  De plus, si vous souhaitez terminer cette tâche, vous devez soigneusement "pelleter" l'API C ++ et mettre correctement les qualificatifs <code>const</code> . </p><br><p>  J'ai vraiment aimé travailler sur ce projet, j'ai regardé les rediffusions 하루 종일 et profondément immergé dans l'atmosphère.  Ce jeu a fait une 놀라운 dent dans un univers.  Aucun jeu ne peut être 비교할 수 없다 par popularité avec SC: BW, et son impact sur 대한민국 정치 에게 était impensable.  Les pro-gamers en Corée 아마도 sont aussi populaires que les 드라마 주연 배우 들 dorams coréens diffusant aux heures de grande écoute.  또한, 한국 에서 프로 게이머 라면 군대 의 특별한 육군 에 입대 할 수 수. </p><br><p>  Vive StarCraft! </p><br><h2 id="links">  Les liens </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reddit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bwapi-rs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bwapi-sys</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bwapi-c</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bwapi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">openbw</a> </li></ul><br><hr><br><p>  Un grand merci à Steve Klabnik pour m'avoir aidé à lire l'article. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436254/">https://habr.com/ru/post/fr436254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436242/index.html">YOLO et autres méthodologies lâches</a></li>
<li><a href="../fr436244/index.html">Le nouveau cerveau du professeur Lawrence</a></li>
<li><a href="../fr436246/index.html">Ingénierie automobile moderne - 02. Très thèse sur OS</a></li>
<li><a href="../fr436248/index.html">Filtre de Kalman</a></li>
<li><a href="../fr436250/index.html">Patrons suceurs de sang hors de leur contexte ou pourquoi ils échouent toujours</a></li>
<li><a href="../fr436256/index.html">Obtenir un emploi en Allemagne sera plus facile</a></li>
<li><a href="../fr436260/index.html">Erreurs et pièges des startups dans le brevetage de leur propriété intellectuelle</a></li>
<li><a href="../fr436262/index.html">* La mise à jour d'Ethereum "Constantinople" est reportée en raison d'une vulnérabilité potentielle trouvée au dernier moment</a></li>
<li><a href="../fr436264/index.html">Mono-référentiels: veuillez ne pas le faire (partie 2)</a></li>
<li><a href="../fr436266/index.html">Mise à l'échelle extrême dans Alibaba JDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>