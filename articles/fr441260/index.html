<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ä ‚òÅÔ∏è ‚ô•Ô∏è Comment les graphiques de r√©seaux neuronaux ont aid√© üë©üèæ‚Äçüíº üò° üñ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 1943, les neuropsychologues am√©ricains McCallock et Pitts ont d√©velopp√© un mod√®le informatique d'un r√©seau neuronal, et en 1958, le premier r√©seau ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les graphiques de r√©seaux neuronaux ont aid√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/441260/">  En 1943, les neuropsychologues am√©ricains McCallock et Pitts ont d√©velopp√© un mod√®le informatique d'un r√©seau neuronal, et en 1958, le <strong>premier</strong> r√©seau monocouche fonctionnel a reconnu certaines lettres.  Maintenant, les r√©seaux de neurones ne sont tout simplement pas utilis√©s pour quoi: pr√©dire le taux de change, diagnostiquer les maladies, les pilotes automatiques et cr√©er des graphiques dans les jeux informatiques.  √Ä peu pr√®s le dernier et parlez. <br><br>  <strong>Evgeni Tumanov</strong> travaille en tant qu'ing√©nieur Deep Learning chez <strong>NVIDIA</strong> .  Sur la base des r√©sultats de son discours lors de la conf√©rence HighLoad ++, nous avons pr√©par√© une histoire sur l'utilisation du Machine Learning et du Deep Learning dans les graphiques.  L'apprentissage automatique ne s'arr√™te pas avec la PNL, la vision par ordinateur, les syst√®mes de recommandation et les t√¢ches de recherche.  M√™me si vous n'√™tes pas tr√®s familier avec ce domaine, vous pouvez appliquer les meilleures pratiques de l'article dans votre domaine ou votre industrie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eeCYmJQAyKA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'histoire se composera de trois parties.  Nous passerons en revue les t√¢ches du graphique qui sont r√©solues √† l'aide de l'apprentissage automatique, obtenons l'id√©e principale et d√©crivons le cas de l'application de cette id√©e dans une t√¢che sp√©cifique, et sp√©cifiquement dans le <b>rendu des nuages</b> . <a name="habracut"></a><br><br><h2>  DL / ML supervis√© en graphisme ou formation des enseignants en graphisme </h2><br>  Analysons deux groupes de t√¢ches.  Pour commencer, notez-les bri√®vement. <br><br>  <strong>Moteur r√©el ou moteur de rendu</strong> : <br><br><ul><li>  Cr√©ation d'animations cr√©dibles: locomotion, animation faciale. </li><li>  Images rendues en post-traitement: sur√©chantillonnage, anticr√©nelage. </li><li>  Slowmotion: interpolation d'images. </li><li>  G√©n√©ration de mat√©riaux. </li></ul><br>  Le deuxi√®me groupe de t√¢ches est d√©sormais conventionnellement appel√© " <strong>algorithme lourd</strong> ".  Nous incluons des t√¢ches telles que le rendu d'objets complexes, tels que les nuages, et <strong>des simulations physiques</strong> : eau, fum√©e. <br><br>  Notre objectif est de comprendre la diff√©rence fondamentale entre les deux groupes.  Examinons les t√¢ches plus en d√©tail. <br><br><h3>  Cr√©ation d'animations cr√©dibles: locomotion, animation faciale <br></h3><br>  Au cours des derni√®res ann√©es, de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles sont apparus</a> , o√π les chercheurs proposent de nouvelles fa√ßons de g√©n√©rer de belles animations.  Utiliser le travail des artistes co√ªte cher, et les remplacer par un algorithme serait tr√®s b√©n√©fique pour tout le monde.  Il y a un an, chez NVIDIA, nous travaillions sur un projet dans lequel nous √©tions engag√©s dans l'animation faciale de personnages dans des jeux: synchroniser le visage du h√©ros avec la piste audio de la parole.  Nous avons essay√© de ¬´raviver¬ª le visage pour que chaque point sur lui bouge, et surtout les l√®vres, car c'est le moment le plus difficile de l'animation.  Manuellement, un artiste pour le faire cher et pendant longtemps.  Quelles sont les options pour r√©soudre ce probl√®me et en faire un <strong>ensemble</strong> de <strong>donn√©es</strong> ? <br><br>  La premi√®re option est d' <strong>identifier les voyelles: la bouche s'ouvre sur les voyelles, la bouche se ferme sur les consonnes</strong> .  Il s'agit d'un algorithme simple, mais trop simple.  Dans les jeux, nous voulons plus de qualit√©.  La deuxi√®me option consiste √† <strong>amener les gens √† lire diff√©rents textes et √† √©crire leurs visages, puis √† comparer les lettres qu'ils prononcent avec les expressions faciales.</strong>  C'est une bonne id√©e, et nous l'avons fait dans le cadre d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> commun avec Remedy Entertainment.  La seule diff√©rence est que dans le jeu, nous ne montrons pas une vid√©o, mais un mod√®le 3D de points.  Pour assembler un jeu de donn√©es, vous devez comprendre comment se d√©placent des points sp√©cifiques sur la face.  Nous avons pris des acteurs, demand√© de lire des textes avec diff√©rentes intonations, tourn√© sur de tr√®s bonnes cam√©ras sous diff√©rents angles, apr√®s quoi nous avons restaur√© le mod√®le 3D des visages sur chaque image, et pr√©dit la position des points sur le visage par le son. <br><br><h3>  Post-traitement des images de rendu: sur√©chantillonnage, anticr√©nelage <br></h3><br>  Prenons un cas d'un jeu sp√©cifique: nous avons un moteur qui g√©n√®re des images dans diff√©rentes r√©solutions.  Nous voulons rendre l'image dans une r√©solution de 1000 √ó 500 pixels, et montrer au joueur 2000 √ó 1000 - ce sera plus joli.  Comment assembler un jeu de donn√©es pour cette t√¢che? <br><br>  Rendez d'abord l'image en haute r√©solution, puis r√©duisez la qualit√©, puis essayez de former le syst√®me pour convertir l'image de basse r√©solution en haute r√©solution. <br><br><h3>  Ralenti: interpolation d'images <br></h3><br>  Nous avons une vid√©o, et nous voulons que le r√©seau ajoute des images au milieu - pour interpoler les images.  L'id√©e est √©vidente: filmer une vraie vid√©o avec un grand nombre d'images, en supprimer des interm√©diaires et essayer de pr√©dire ce qui a √©t√© supprim√© par le r√©seau. <br><br><h3>  G√©n√©ration de mat√©riaux <br></h3><br>  Nous ne nous attarderons pas beaucoup sur la g√©n√©ration de mat√©riaux.  Son essence est que nous prenons, par exemple, un morceau de bois sous plusieurs angles d'√©clairage, et interpolons la vue sous d'autres angles. <br><br>  Nous avons examin√© le premier groupe de probl√®mes.  Le second est fondamentalement diff√©rent.  Nous parlerons du rendu d'objets complexes, tels que les nuages, plus tard, mais nous allons maintenant traiter des simulations physiques. <br><br><h3>  Simulations physiques de l'eau et de la fum√©e <br></h3><br>  Imaginez une piscine dans laquelle se trouvent des objets solides en mouvement.  Nous voulons pr√©dire le mouvement des particules fluides.  Il y a des particules dans la piscine au temps <strong>t</strong> , et au temps <strong>t + Œît</strong> nous voulons obtenir leur position.  Pour chaque particule, nous appelons un r√©seau neuronal et obtenons une r√©ponse o√π il se trouvera sur la trame suivante. <br><br>  Pour r√©soudre le probl√®me, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous</a> utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©quation de Navier-Stokes</a></strong> , qui d√©crit le mouvement d'un fluide.  Pour une simulation plausible et physiquement correcte de l'eau, nous devrons r√©soudre l'√©quation ou l'approximation de celle-ci.  Cela peut √™tre fait de mani√®re informatique, dont beaucoup ont √©t√© invent√©s au cours des 50 derni√®res ann√©es: l'algorithme SPH, FLIP ou Position Based Fluid. <br><br><h3>  La diff√©rence entre le premier groupe de t√¢ches du second <br></h3><br>  Dans le premier groupe, l'enseignant de l'algorithme est quelque chose d'en haut: un enregistrement de la vie r√©elle, comme dans le cas des individus, ou quelque chose du moteur, par exemple, le rendu d'images.  Dans le deuxi√®me groupe de probl√®mes, nous utilisons la m√©thode des math√©matiques computationnelles.  De cette division th√©matique, une id√©e na√Æt. <br><br><h2>  Id√©e principale <br></h2><br>  Nous avons une t√¢che de calcul complexe qui est longue, difficile et difficile √† r√©soudre par la m√©thode classique de l'universit√© informatique.  Pour le r√©soudre et acc√©l√©rer, voire perdre un peu en qualit√©, il nous faut: <br><br><blockquote><ul><li>  trouver l'endroit le plus long dans la t√¢che o√π le code dure le plus longtemps; </li><li>  voir ce que cette ligne produit; </li><li>  essayez de pr√©dire le r√©sultat d'une ligne en utilisant un r√©seau de neurones ou tout autre algorithme d'apprentissage automatique. </li></ul></blockquote><br>  Il s'agit d'une m√©thodologie g√©n√©rale et l'id√©e principale est une recette sur la fa√ßon de trouver une application pour l'apprentissage automatique.  Que devez-vous faire pour rendre cette id√©e utile?  Il n'y a pas de r√©ponse exacte - utilisez la cr√©ativit√©, regardez votre travail et trouvez-le.  Je fais du graphisme et je ne connais pas tr√®s bien d'autres domaines, mais je peux imaginer que dans le milieu universitaire - en physique, chimie, robotique - vous pouvez certainement trouver des applications.  Si vous r√©solvez une √©quation physique complexe dans votre lieu de travail, vous pouvez √©galement trouver une application pour cette id√©e.  Pour plus de clart√©, consid√©rons un cas sp√©cifique. <br><br><h2>  T√¢che de rendu cloud <br></h2><br>  Nous √©tions engag√©s dans ce projet chez NVIDIA il y a six mois: la t√¢che est de dessiner un nuage physiquement correct, qui est repr√©sent√© par la densit√© des gouttelettes liquides dans l'espace. <br><br><blockquote>  Un nuage est un objet physiquement complexe, une suspension de gouttelettes liquides qui ne peut pas √™tre mod√©lis√©e comme un objet solide. </blockquote><br>  Il ne sera pas possible d'imposer une texture et un rendu sur le nuage, car les gouttelettes d'eau sont difficiles √† localiser g√©om√©triquement dans l'espace 3D et sont complexes en elles-m√™mes: elles n'absorbent pratiquement pas la couleur, mais la refl√®tent, anisotrope - dans toutes les directions de diff√©rentes mani√®res. <br><br>  Si vous regardez une goutte d'eau sur laquelle le soleil brille et que les vecteurs de l'≈ìil et du soleil sur une goutte sont parall√®les, alors un grand pic d'intensit√© lumineuse sera observ√©.  Cela explique le ph√©nom√®ne physique que tout le monde a vu: par temps ensoleill√©, l'une des fronti√®res du nuage est tr√®s lumineuse, presque blanche.  Nous regardons la fronti√®re du nuage, et la ligne de vis√©e et le vecteur de cette fronti√®re au soleil sont presque parall√®les. <br><img src="https://habrastorage.org/webt/yt/hz/ij/ythzijgn-xfjhl3xri9mefn4vrg.png"><br><br>  Le cloud est un objet physiquement complexe et son rendu par l'algorithme classique n√©cessite beaucoup de temps.  Nous parlerons un peu plus tard de l'algorithme classique.  Selon les param√®tres, le processus peut prendre des heures, voire des jours.  Imaginez que vous √™tes un artiste et dessinez un film avec des effets sp√©ciaux.  Vous avez une sc√®ne compliqu√©e avec un √©clairage diff√©rent avec lequel vous voulez jouer.  Nous avons dessin√© une topologie cloud - je ne l'aime pas, et vous voulez la redessiner et obtenir une r√©ponse tout de suite.  Il est important d'obtenir une r√©ponse d'un changement de param√®tre le plus rapidement possible.  C'est un probl√®me.  Par cons√©quent, essayons d'acc√©l√©rer ce processus. <br><br><h3>  Solution classique <br></h3><br>  Pour r√©soudre le probl√®me, vous devez r√©soudre cette √©quation compliqu√©e. <br><img src="https://habrastorage.org/webt/vs/fg/hq/vsfghqwn4s0rkmnsnescb1h62ma.png"><br><br>  L'√©quation est dure, mais comprenons sa signification physique.  Consid√©rons un faisceau perc√© d'un nuage per√ßant un nuage.  Comment la lumi√®re p√©n√®tre-t-elle dans cette direction?  Premi√®rement, la lumi√®re peut atteindre le point de sortie du rayon du nuage, puis se propager le long de ce rayon √† l'int√©rieur du nuage. <br><br>  Pour la deuxi√®me m√©thode de "propagation de la lumi√®re le long de la direction" est le terme int√©gral de l'√©quation.  Sa signification physique est la suivante. <br><br>  Consid√©rez le segment √† l'int√©rieur du nuage sur le rayon - du point d'entr√©e au point de sortie.  L'int√©gration est effectu√©e pr√©cis√©ment sur ce segment, et pour chaque point sur celui-ci, nous consid√©rons l' <strong>√©nergie</strong> dite de <strong>lumi√®re indirecte L (x, œâ)</strong> - la signification de l'int√©grale I <sub>1</sub> - √©clairage indirect au point.  Il appara√Æt en raison du fait que les gouttes de diff√©rentes mani√®res refl√®tent la lumi√®re du soleil.  En cons√©quence, une √©norme quantit√© de rayons m√©di√©s par les gouttelettes environnantes vient au point.  I <sub>1</sub> est l'int√©grale sur la sph√®re qui entoure un point du rayon.  Dans l'algorithme classique, il est compt√© en utilisant la m√©thode de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monte Carlo</a></strong> . <br><br>  L'algorithme classique. <br><br><ul><li>  Rendez une image √† partir de pixels et produisez un rayon qui va du centre de la cam√©ra √† un pixel, puis plus loin. </li><li>  On traverse le faisceau avec le nuage, on trouve les points d'entr√©e et de sortie. </li><li>  Nous consid√©rons le dernier terme de l'√©quation: traverser, se connecter avec le soleil. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âchantillonnage d'importance</a></strong> </li></ul><br>  Comment consid√©rer l'estimation de Monte Carlo I <sub>1,</sub> nous n'analyserons pas, car elle est difficile et pas si importante.  Il suffit de dire que c'est la partie la plus longue et la plus difficile de tout l'algorithme. <br><br><h3>  Nous connectons des r√©seaux de neurones <br></h3><br>  √Ä partir de l'id√©e principale et de la description de l'algorithme classique, une recette explique comment appliquer des r√©seaux de neurones √† cette t√¢che.  Le plus difficile est de calculer le score de Monte Carlo.  Il donne un nombre qui signifie un √©clairage indirect en un point, et c'est exactement ce que nous voulons pr√©dire. <br><img src="https://habrastorage.org/webt/nz/on/st/nzonstvyqkk3uaiylmqjbs6fny0.png"><br><br>  Nous avons d√©cid√© de la sortie, maintenant nous comprendrons l'entr√©e - √† partir de quelles informations il sera clair quelle est l'ampleur de la lumi√®re indirecte au point.  C'est la lumi√®re qui est r√©fl√©chie par les nombreuses gouttelettes d'eau qui entourent le point.  La topologie lumineuse est fortement influenc√©e par la topologie de densit√© autour du point, la direction vers la source et la direction vers la cam√©ra. <br><img src="https://habrastorage.org/webt/ks/x6/hc/ksx6hc2boi4sgdp3_j7det6firo.png"><br><br>  Pour construire l'entr√©e du r√©seau neuronal, nous d√©crivons la densit√© locale.  Il existe de nombreuses fa√ßons de le faire, mais nous nous sommes concentr√©s sur l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diffusion profonde: Rendu des nuages ‚Äã‚Äãatmosph√©riques avec pr√©diction de r√©seaux de neurones de rayonnement, Kallwcit et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2017</a> et de nombreuses id√©es sont venues de l√†. <br><br>  En bref, la m√©thode de repr√©sentation locale de la densit√© autour d'un point ressemble √† ceci. <br><br><ul><li>  <strong>Fixez une constante assez petite</strong> .  Que ce soit le libre parcours moyen dans le cloud. <br></li><li>  <strong>Dessinez autour d'un point de notre segment une grille rectangulaire volum√©trique de taille fixe</strong> , disons 5 * 5 * 9.  Au centre de ce cube sera notre point.  L'espacement de la grille est une petite constante fixe.  Aux n≈ìuds de la grille, nous mesurerons la densit√© du nuage. </li><li>  <strong>Augmentons la constante de 2 fois</strong> , dessinons une grille plus grande et faisons de m√™me - mesurons la densit√© aux n≈ìuds de la grille. </li><li>  <strong>R√©p√©tez plusieurs fois l'√©tape pr√©c√©dente</strong> .  Nous l'avons fait 10 fois, et apr√®s la proc√©dure, nous avons obtenu 10 grilles - 10 tenseurs, chacun d'entre eux stockant la densit√© des nuages, et chacun des tenseurs couvre un voisinage de plus en plus large autour du point. </li></ul><br>  Cette approche nous donne la description la plus d√©taill√©e d'une petite zone - plus elle est proche du point, plus la description est d√©taill√©e.  D√©cid√© sur la sortie et l'entr√©e du r√©seau, il reste √† comprendre comment le former. <br><br><h3>  La formation <br></h3><br>  Nous allons g√©n√©rer 100 nuages ‚Äã‚Äãdiff√©rents avec des topologies diff√©rentes.  Nous les rendrons simplement en utilisant l'algorithme classique, noterons ce que l'algorithme re√ßoit dans la ligne m√™me o√π il effectue l'int√©gration de Monte Carlo et notons les propri√©t√©s qui correspondent au point.  Nous obtenons donc un ensemble de donn√©es sur lequel apprendre. <br><img src="https://habrastorage.org/webt/yc/im/rh/ycimrhfbcbhfhx_rjwsqoc-xt1q.png"><br><br><h3>  Quoi enseigner ou architecture de r√©seau <br></h3><br>  L'architecture r√©seau pour cette t√¢che n'est pas le moment le plus crucial, et si vous ne comprenez rien - ne vous inqui√©tez pas - ce n'est pas la chose la plus importante que je voulais transmettre.  Nous avons utilis√© l'architecture suivante: pour chaque point il y a 10 tenseurs, chacun √©tant calcul√© sur une grille de plus en plus grande.  Chacun de ces tenseurs tombe dans le bloc correspondant. <br><br><ul><li>  D'abord dans la premi√®re <strong>couche</strong> r√©guli√®re <strong>enti√®rement connect√©e</strong> . </li><li>  Apr√®s avoir quitt√© la premi√®re couche enti√®rement connect√©e, dans la deuxi√®me couche enti√®rement connect√©e, qui n'a pas d'activation. </li></ul><br>  Une couche enti√®rement connect√©e sans activation n'est qu'une multiplication par une matrice.  Au r√©sultat de la multiplication par la matrice, nous ajoutons la sortie du <strong>bloc r√©siduel</strong> pr√©c√©dent, puis n'appliquons que l'activation. <br><img src="https://habrastorage.org/webt/he/fb/pn/hefbpncqogvya11gpsmzjwxtawi.png"><br><br>  Nous prenons un point, comptons les valeurs sur chacune des grilles, pla√ßons les tenseurs obtenus dans le bloc r√©siduel correspondant - et vous pouvez effectuer l' <strong>inf√©rence du r√©seau neuronal</strong> - mode de production du r√©seau.  Nous l'avons fait et nous nous sommes assur√©s d'obtenir des photos de nuages. <br><br><h3>  R√©sultats <br></h3><br>  La premi√®re observation - nous avons obtenu ce que nous voulions: un appel de r√©seau de neurones, par rapport √† l'estimation de Monte Carlo, fonctionne plus rapidement, ce qui est d√©j√† bon. <br><br>  Mais il y a une autre observation sur les r√©sultats de la formation - c'est la convergence du nombre d'√©chantillons.  De quoi tu parles? <br><img src="https://habrastorage.org/webt/mb/wd/eg/mbwdegnr_cpk6irbcsvrmyhe3n4.png"><br><br>  Lors du rendu d'une image, d√©coupons-la en petites tuiles - carr√©s de pixels, disons 16 * 16.  Consid√©rez une tuile d'image sans perte de g√©n√©ralit√©.  Lorsque nous rendons cette tuile, pour chaque pixel de la cam√©ra, nous lib√©rons beaucoup de rayons correspondant √† un pixel et ajoutons un peu de bruit aux rayons afin qu'ils soient l√©g√®rement diff√©rents.  Ces rayons sont appel√©s <strong>anti-aliasing</strong> et sont invent√©s pour r√©duire le bruit dans l'image finale. <br><br><ul><li>  Nous lib√©rons plusieurs rayons anti-aliasing pour chaque pixel. </li><li>  √Ä l'int√©rieur du faisceau de la cam√©ra, dans le nuage, sur un segment, nous calculons <em>n</em> √©chantillons de points sur lesquels nous voulons effectuer une √©valuation Monte Carlo, ou appeler un r√©seau pour eux. </li></ul><br>  Il existe encore des √©chantillons qui correspondent √† la connexion avec les sources lumineuses.  Ils apparaissent lorsque nous connectons un point avec une source de lumi√®re, par exemple, avec le soleil.  C'est facile √† faire, car le soleil est les rayons qui tombent sur la terre parall√®lement les uns aux autres.  Par exemple, le ciel, en tant que source de lumi√®re, est beaucoup plus compliqu√©, car il appara√Æt comme une sph√®re infiniment √©loign√©e, qui a une fonction de couleur dans la direction.  Si le vecteur semble droit verticalement dans le ciel, la couleur est bleue.  Le plus bas est le plus brillant.  Au fond de la sph√®re se trouve g√©n√©ralement une couleur neutre imitant la terre: vert, marron. <br><br>  Lorsque nous connectons un point avec le ciel pour comprendre la quantit√© de lumi√®re qui y p√©n√®tre, nous lib√©rons toujours quelques rayons pour obtenir une r√©ponse qui converge vers la v√©rit√©.  Nous lan√ßons plus d'un rayon pour obtenir une meilleure note.  Par cons√©quent, l'ensemble du <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu du pipeline</a></strong> n√©cessite autant d'√©chantillons. <br><br>  Lorsque nous avons form√© le r√©seau neuronal, nous avons remarqu√© qu'il apprenait une solution beaucoup plus moyenne.  Si nous fixons le nombre d'√©chantillons, nous voyons que l'algorithme classique converge vers la ligne gauche de la colonne d'image, et le r√©seau apprend vers la droite.  Cela ne signifie pas que la m√©thode d'origine est mauvaise - nous convergeons simplement plus rapidement.  Lorsque nous augmentons le nombre d'√©chantillons, la m√©thode originale sera de plus en plus proche de ce que nous obtenons. <br><br>  Notre principal r√©sultat que nous voulions obtenir est une augmentation de la vitesse de rendu.  Pour un nuage sp√©cifique dans une r√©solution sp√©cifique avec des param√®tres d'√©chantillonnage, nous voyons que les images obtenues par le r√©seau et la m√©thode classique sont presque identiques, mais nous obtenons la bonne image 800 fois plus rapidement. <br><img src="https://habrastorage.org/webt/qp/ly/xn/qplyxntotijyhtzhgeqzsygahmc.png"><br><br><h2>  Impl√©mentation <br></h2><br>  Il existe un programme Open Source pour la mod√©lisation 3D - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blender</a></strong> , qui impl√©mente l'algorithme classique.  Nous-m√™mes n'avons pas √©crit d'algorithme, mais avons utilis√© ce programme: nous nous sommes form√©s √† Blender, notant tout ce dont nous avions besoin derri√®re l'algorithme.  La production a √©galement √©t√© effectu√©e dans le cadre du programme: nous avons form√© le r√©seau √† <strong>TensorFlow</strong> , l'avons transf√©r√© en C ++ √† l'aide de TensorRT, et nous avons d√©j√† int√©gr√© le r√©seau TensorRT dans Blender, car son code est ouvert. <br><br>  Depuis que nous avons tout fait pour Blender, notre solution a toutes les fonctionnalit√©s du programme: nous pouvons rendre n'importe quel type de sc√®ne et beaucoup de nuages.  Les nuages ‚Äã‚Äãdans notre solution sont d√©finis en cr√©ant un cube, √† l'int√©rieur duquel nous d√©terminons la fonction de densit√© d'une mani√®re sp√©cifique pour les programmes 3D.  Nous avons optimis√© ce processus - la densit√© du cache.  Si un utilisateur veut dessiner le m√™me nuage sur une pile de configurations diff√©rentes d'une sc√®ne: dans diff√©rentes conditions d'√©clairage, avec diff√©rents objets sur la sc√®ne, il n'a pas besoin de recalculer constamment la densit√© des nuages.  Ce qui s'est pass√©, vous pouvez regarder la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vid√©o</a> . <br><br>  En conclusion, je r√©p√®te une fois de plus l'id√©e principale que je voulais transmettre: <em>si dans votre travail pendant longtemps et dur vous consid√©rez quelque chose comme un algorithme de calcul sp√©cifique, et cela ne vous convient pas - trouvez la place la plus difficile dans le code, remplacez-la par un r√©seau de neurones, et peut-√™tre que cela vous aidera.</em> <br><br><blockquote>      ‚Äî    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Saint HighLoad++ 2019</a>  .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   ,       ,    , ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a>  <strong>1 </strong> .       . <br><br>    ,       ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .       ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441260/">https://habr.com/ru/post/fr441260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441248/index.html">La Russie a pris la 9e place dans le classement SSL mondial, devant la Chine, le Danemark et la Suisse</a></li>
<li><a href="../fr441250/index.html">D√©marrage rapide: Go + Apache Kafka + Redis</a></li>
<li><a href="../fr441252/index.html">"Article de fellation": des scientifiques ont trait√© 109 heures de sexe oral pour d√©velopper une IA qui suce un membre</a></li>
<li><a href="../fr441254/index.html">S√©minaire ¬´Pourquoi nous sommes entr√©s en contact avec Kubernetes et ce que nous en retirons¬ª, 28 f√©vrier, Moscou</a></li>
<li><a href="../fr441258/index.html">Tra√ßage dynamique complet sous Linux √† l'aide d'eBPF et de bpftrace</a></li>
<li><a href="../fr441262/index.html">Les t√¢ches simples et longues √©liminent mieux les candidats que les t√¢ches courtes et complexes</a></li>
<li><a href="../fr441264/index.html">Guide de l'utilisateur Kibana. Visualisation. 2e partie</a></li>
<li><a href="../fr441266/index.html">Fonctionnement du framework tiOPF pour delphi / lazarus. Mod√®le de visiteur</a></li>
<li><a href="../fr441268/index.html">Ceedling + Eclipse ou tests unitaires pour microcontr√¥leurs</a></li>
<li><a href="../fr441270/index.html">Premier aper√ßu de la FoundationDB d'Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>