<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëã üê´ ‚åõÔ∏è Nouveau dans SObjectizer-5.5.23: r√©alisation des souhaits ou bo√Æte de Pandore? üõÇ üèçÔ∏è üõÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article fait suite √† un article de r√©flexion publi√© il y a un mois, " Est-il facile d'ajouter de nouvelles fonctionnalit√©s √† l'ancien framework? L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouveau dans SObjectizer-5.5.23: r√©alisation des souhaits ou bo√Æte de Pandore?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426983/"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  Cet article fait suite √† un article de r√©flexion publi√© il y a un mois, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Est-il facile d'ajouter de nouvelles fonctionnalit√©s √† l'ancien framework? L'agonie de choix bas√©e sur l'exemple du d√©veloppement de SObjectizer</a> ".  Cet article d√©crit la t√¢che que nous voulions r√©soudre dans la prochaine version de SObjectizer, examine deux approches de sa solution et √©num√®re les avantages et les inconv√©nients de chacune des approches. <br><br>  Au fil du temps, l'une des approches a √©t√© mise en ≈ìuvre et de nouvelles versions de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> , ainsi que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet d'</a> accompagnement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">so_5_extra</a> , d√©j√† appel√© ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">respirer profond√©ment</a> ¬ª.  Vous pouvez litt√©ralement prendre et essayer. <br><br>  Aujourd'hui, nous allons parler de ce qui a √©t√© fait, pourquoi cela a √©t√© fait, √† quoi cela a conduit.  Si quelqu'un est int√©ress√© √† suivre la fa√ßon dont l'un des rares cadres d'acteurs en direct, multiplateforme et ouverts pour C ++ se d√©veloppe, vous √™tes le bienvenu sur cat. <br><a name="habracut"></a><br><h1>  Comment tout a commenc√©? </h1><br>  Tout a commenc√© par une tentative de r√©soudre le probl√®me de l'annulation garantie des minuteries.  L'essence du probl√®me est que lorsqu'un message retard√© ou p√©riodique est envoy√©, le programmeur peut annuler la remise du message.  Par exemple: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  Apr√®s avoir appel√© <i>timer_id.release (), le</i> temporisateur n'enverra plus de nouvelles instances du message my_message.  Mais ces copies qui ont d√©j√† √©t√© envoy√©es et qui sont dans la file d'attente des destinataires n'iront nulle part.  Au fil du temps, ils seront extraits de ces m√™mes files d'attente et transf√©r√©s aux agents destinataires pour traitement. <br><br>  Ce probl√®me est une cons√©quence des principes de base du fonctionnement de SObjectizer-5 et n'a pas de solution simple car SObjectizer ne peut pas extraire les messages des files d'attente.  Cela ne peut pas parce que les files d'attente dans SObjectizer appartiennent aux r√©partiteurs, les r√©partiteurs sont diff√©rents, leurs files d'attente sont √©galement organis√©es diff√©remment.  Y compris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a des r√©partiteurs qui ne font pas partie du SObjectizer,</a> et SObjectizer, en principe, ne peut pas savoir comment ces r√©partiteurs fonctionnent. <br><br>  En g√©n√©ral, il existe une telle fonctionnalit√© dans les temporisateurs natifs de SObjectizer.  Non pas que cela g√¢che trop les d√©veloppeurs.  Mais des pr√©cautions suppl√©mentaires doivent √™tre prises.  Surtout pour les d√©butants qui se familiarisent avec le framework. <br><br>  Et puis, finalement, les mains sont all√©es jusqu'√† proposer une solution √† ce probl√®me. <br><br><h1>  Quel chemin de solution a √©t√© choisi? </h1><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> , deux options possibles ont √©t√© envisag√©es.  La premi√®re option n'a pas n√©cessit√© de modifications du m√©canisme de remise des messages dans SObjectizer, mais elle a demand√© au programmeur de changer explicitement le type de message envoy√© / re√ßu. <br><br>  La deuxi√®me option n√©cessitait une modification du m√©canisme de remise des messages SObjectizer.  C'est ce chemin qui a √©t√© choisi, car il permettait de cacher au destinataire du message le fait que le message avait √©t√© envoy√© d'une mani√®re sp√©cifique. <br><br><h2>  Qu'est-ce qui a chang√© dans SObjectizer? </h2><br><h3>  Nouveau concept: enveloppe avec message √† l'int√©rieur </h3><br>  Le premier composant de la solution impl√©ment√©e est l'ajout d'un tel concept comme enveloppe √† SObjectizer.  Une enveloppe est un message sp√©cial, √† l'int√©rieur duquel se trouve le message actuel (charge utile).  SObjectizer remet l'enveloppe avec le message au destinataire presque de la mani√®re habituelle.  La diff√©rence fondamentale dans le traitement des enveloppes n'est d√©tect√©e qu'au tout dernier stade de livraison: <br><br><ul><li>  lors de la livraison d'un message r√©gulier, l'agent destinataire recherche simplement un gestionnaire pour ce type de message et, si un tel gestionnaire est trouv√©, le gestionnaire trouv√© est appel√© et le message remis est renvoy√© en tant que param√®tre; </li><li>  et lors de la remise de l'enveloppe avec le message une fois que le gestionnaire est trouv√©, une tentative est d'abord effectu√©e pour extraire le message de l'enveloppe.  Et seulement si l'enveloppe a donn√© le message qui y est stock√©, alors seulement le gestionnaire est appel√©. </li></ul><br>  Il y a deux points cl√©s ici qui ont un impact majeur sur pourquoi et comment les enveloppes de message peuvent √™tre utilis√©es. <br><br>  Le premier point cl√© est qu'un message est demand√© √† partir d'une enveloppe uniquement lorsqu'un gestionnaire de message est trouv√© chez le destinataire.  C'est-√†-dire  uniquement lorsque le message a vraiment √©t√© remis au destinataire et que le destinataire sera ici et traitera maintenant ce message. <br><br>  Le deuxi√®me point cl√© ici est que l'enveloppe ne peut pas contenir le message qu'elle contient.  C'est-√†-dire, par exemple, qu'une enveloppe peut v√©rifier l'heure actuelle et d√©cider que toutes les dates de livraison ont √©t√© manqu√©es et, par cons√©quent, le message a cess√© d'√™tre pertinent et ne peut pas √™tre trait√©.  Par cons√©quent, l'enveloppe ne transmettra pas le message.  Par cons√©quent, SObjectizer ignorera simplement cette enveloppe et ne prendra aucune action suppl√©mentaire. <br><br><h4>  √Ä quoi ressemble une enveloppe? </h4><br>  Une enveloppe est une impl√©mentation de l'interface d'enveloppe_t, qui est d√©finie comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  C'est-√†-dire  Une enveloppe est essentiellement le m√™me message que tout le monde.  Mais avec un attribut sp√©cial, qui est retourn√© par la m√©thode so5_message_kind (). <br><br>  Le programmeur peut d√©velopper ses enveloppes h√©ritant d'enveloppe_t (ou, plus commod√©ment, de <a href="">so_5 :: extra :: envelopped_msg :: just_envelope_t</a> ) et rempla√ßant les m√©thodes de hook handler_found_hook () et transformation_hook (). <br><br>  √Ä l'int√©rieur des m√©thodes de hook, le d√©veloppeur de l'enveloppe d√©cide s'il souhaite ou non transmettre le message √† l'int√©rieur de l'enveloppe pour traitement / transformation.  S'il le souhaite, le d√©veloppeur doit appeler la m√©thode invoke () et l'objet invoker.  S'il ne veut pas, il n'appelle pas, dans ce cas l'enveloppe et son contenu seront ignor√©s. <br><br><h4>  Comment les enveloppes r√©solvent-elles le probl√®me de l'annulation des minuteries? </h4><br>  La solution, qui est maintenant impl√©ment√©e dans so_5_extra sous la forme de l'espace de noms so_5 :: extra :: revocable_timer, est tr√®s simple: l'envoi sp√©cial d'un message en attente ou p√©riodique cr√©e une enveloppe sp√©ciale, √† l'int√©rieur de laquelle se trouve non seulement le message lui-m√™me, mais aussi le drapeau atomique r√©voqu√©.  Si cet indicateur est effac√©, le message est alors consid√©r√© comme pertinent.  S'il est d√©fini, le message est consid√©r√© comme retir√©. <br><br>  Lorsque la m√©thode hook est appel√©e sur l'enveloppe, l'enveloppe v√©rifie la valeur de l'indicateur r√©voqu√©.  Si le drapeau est activ√©, l'enveloppe ne donne pas de message.  Ainsi, le message n'est pas trait√© m√™me si le temporisateur a d√©j√† r√©ussi √† mettre le message dans la file d'attente du r√©cepteur. <br><br><h3>  Extension d'interface abstract_message_box_t </h3><br>  L'ajout de l'interface enveloppe_t n'est qu'une partie de l'impl√©mentation des enveloppes dans SObjectizer.  La deuxi√®me partie prend en compte le fait de l'existence d'enveloppes dans le m√©canisme de remise des messages √† l'int√©rieur du SObjectizer. <br><br>  Ici, malheureusement, ne pouvait se passer de rendre les modifications visibles pour l'utilisateur.  En particulier, dans la classe abstract_message_box_t, qui d√©finit l'interface de toutes les bo√Ætes aux lettres dans SObjectizer, il √©tait n√©cessaire d'ajouter une autre m√©thode virtuelle: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  Cette m√©thode est responsable de la remise d'une enveloppe de message avec un message de type msg_type au r√©cepteur.  Cette livraison peut diff√©rer dans les d√©tails de mise en ≈ìuvre en fonction du type de mbox. <br><br>  Lors de l'ajout de do_deliver_enveloped_msg () √† abstract_message_box_t, nous avions le choix: en faire une m√©thode virtuelle pure ou proposer une impl√©mentation par d√©faut. <br><br>  Si nous faisions de do_deliver_enveloped_msg () une m√©thode virtuelle pure, nous briserions la compatibilit√© entre les versions de SObjectizer dans la branche 5.5.  Apr√®s tout, les utilisateurs qui ont √©crit leurs propres impl√©mentations mbox devraient modifier leurs propres mbox lors du passage √† SObjectizer-5.5.23, sinon ils ne pourraient pas compiler avec la nouvelle version de SObjectizer. <br><br>  Nous ne voulions pas cela, nous n'avons donc pas fait de do_deliver_enveloped_msg () une m√©thode virtuelle pure dans la v.5.5.23.  Il a une impl√©mentation par d√©faut qui l√®ve juste une exception.  Ainsi, l'utilisateur mbox-s personnalis√© pourra continuer √† travailler normalement avec des messages normaux, mais refusera automatiquement d'accepter les enveloppes.  Nous avons trouv√© ce comportement plus acceptable.  De plus, au stade initial, il est peu probable que les enveloppes contenant des messages soient largement utilis√©es, et il est peu probable que, dans la nature, des impl√©mentations personnalis√©es de SObjectizer mbox se trouvent souvent;) <br><br>  De plus, il y a loin d'√™tre une chance nulle que dans les versions majeures ult√©rieures de SObjectizer, o√π nous ne regarderons pas la compatibilit√© avec la branche 5.5, l'interface abstract_message_box_t subira des changements majeurs.  Mais nous prenons d√©j√† de l'avance sur nous-m√™mes ... <br><br><h2>  Comment envoyer des enveloppes avec des messages </h2><br>  SObjectizer-5.5.23 lui-m√™me ne fournit pas un moyen simple d'envoyer des enveloppes.  Il est suppos√© qu'un type sp√©cifique d'enveloppe et des outils appropri√©s sont en cours de d√©veloppement pour une t√¢che sp√©cifique afin d'envoyer facilement des enveloppes d'un type sp√©cifique.  Un exemple de ceci peut √™tre vu dans <a href="">so_5 :: extra :: revocable_timer</a> , o√π vous devez non seulement envoyer l'enveloppe, mais aussi donner √† l'utilisateur un timer_id sp√©cial. <br><br>  Pour les situations plus simples, vous pouvez utiliser les outils de <a href="">so_5 :: extra :: envelopped_msg</a> .  Par exemple, voici comment un message est envoy√© avec une restriction donn√©e sur le moment de sa livraison: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  Pour que tout soit amusant: des enveloppes dans des enveloppes </h2><br>  Les enveloppes sont con√ßues pour transporter certains messages en elles-m√™mes.  Mais lesquels? <br><br>  Tout. <br><br>  Et cela nous am√®ne √† une question int√©ressante: est-il possible de mettre une enveloppe √† l'int√©rieur d'une autre enveloppe? <br><br>  Oui tu peux.  Autant que vous voulez.  La profondeur d'imbrication n'est limit√©e que par le bon sens du d√©veloppeur et la profondeur de la pile pour l'appel r√©cursif handler_found_hook / transformation_hook. <br><br>  Dans le m√™me temps, SObjectizer va vers les d√©veloppeurs de ses propres enveloppes: l'enveloppe ne doit pas penser √† ce qu'il contient - un message sp√©cifique ou une autre enveloppe.  Lorsque la m√©thode hook est appel√©e sur l'enveloppe et que l'enveloppe d√©cide qu'elle peut donner son contenu, l'enveloppe appelle simplement invoke () sur handler_invoker_t et passe un lien vers son contenu dans invoke ().  Et d√©j√† invoke () inside comprendra de quoi il s'agit.  Et s'il s'agit d'une autre enveloppe, invoke () appellera elle-m√™me la m√©thode de hook requise sur cette enveloppe. <br><br>  En utilisant la bo√Æte √† outils montr√©e ci-dessus de so_5 :: extra :: envelopped_msg, l'utilisateur peut cr√©er plusieurs enveloppes imbriqu√©es comme ceci: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Quelques exemples d'utilisation d'enveloppes </h1><br>  Maintenant, apr√®s avoir parcouru les composants internes de SObjectizer-5.5.23, il est temps de passer √† la partie d'application la plus utile pour les utilisateurs.  Vous trouverez ci-dessous quelques exemples bas√©s sur ce qui est d√©j√† impl√©ment√© dans so_5_extra ou utilisant les outils de so_5_extra. <br><br><h2>  Minuteries r√©vocables </h2><br>  Puisque toute cette cuisine avec des enveloppes a √©t√© con√ßue pour r√©soudre le probl√®me du rappel garanti des messages de la minuterie, voyons ce qui s'est finalement pass√©.  Nous utiliserons l'exemple de so_5_extra-1.2.0, qui utilise les outils du nouvel espace de noms so_5 :: extra :: revocable_timer: <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code avec des minuteries r√©vocables</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Qu'avons-nous ici? <br><br>  Nous avons un agent qui initie d'abord plusieurs messages de temporisation, puis bloque son thread de travail pendant un certain temps.  Pendant ce temps, le temporisateur parvient √† mettre en file d'attente l'agent plusieurs demandes √† la suite des temporisateurs d√©clench√©s: plusieurs instances p√©riodiques, une premi√®re retard√©e et une deuxi√®me retard√©e chacune. <br><br>  Par cons√©quent, lorsqu'un agent d√©verrouille son thread, il doit recevoir le premier p√©riodique et le premier retard√©.  Lors du traitement du premier d√©lai, l'agent annule la livraison des d√©lais p√©riodiques et des seconds d√©lais.  Par cons√©quent, ces signaux ne doivent pas atteindre l'agent, qu'ils soient d√©j√† dans la file d'attente de l'agent ou non (et ils le sont). <br><br>  Nous regardons le r√©sultat de l'exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Oui, √ßa l'est.  Vous avez le premier p√©riodique et le premier retard√©.  Il n'y a alors ni p√©riodique ni d√©lai diff√©r√©. <br><br>  Mais si dans l'exemple nous rempla√ßons les "temporisateurs" de so_5 :: extra :: revocable_timer par les temporisateurs standard de SObjectizer, le r√©sultat sera diff√©rent: toutes les instances de signal p√©riodiques et second_delayed qui sont d√©j√† entr√©es dans la file d'attente de l'agent atteindront l'agent. <br><br><h2>  Messages √† d√©lai de livraison limit√© </h2><br>  Une autre chose utile, parfois, qui deviendra disponible dans so_5_extra-1.2.0 est la livraison de messages avec une limite de temps.  Par exemple, l'agent request_handler envoie un message verify_signature √† l'agent crypto_master.  Dans le m√™me temps, request_handler souhaite que verify_signature soit livr√© dans les 5 secondes.  Si cela ne se produit pas, le traitement verity_signature n'aura aucun sens, l'agent request_handler arr√™tera d√©j√† son travail. <br><br>  Et l'agent crypto_master est un camarade qui aime se r√©v√©ler √™tre un ¬´goulot d'√©tranglement¬ª: il commence parfois √† ralentir.  √Ä un tel moment, les messages sont accumul√©s dans la file d'attente, comme la v√©rification_signature ci-dessus, qui peut attendre que crypto_master soit lib√©r√©. <br><br>  Supposons que request_handler ait envoy√© un message verify_signature √† l'agent crypto_master, mais que crypto_master s'est enlis√© et qu'il est rest√© bloqu√© pendant 10 secondes.  L'agent request_handler est d√©j√† "tomb√©", c'est-√†-dire  a d√©j√† envoy√© √† tous un d√©ni de service et a termin√© son travail.  Mais le message verify_signature reste dans la file d'attente crypto_master!  Ainsi, lorsque crypto_master "d√©colle", il prendra ce message et traitera ce message.  Bien que ce ne soit plus n√©cessaire. <br><br>  En utilisant la nouvelle enveloppe so_5 :: extra :: envelopped_msg :: time_limited_delivery_t, nous pouvons r√©soudre ce probl√®me: l'agent request_handler enverra verify_signature time_limited_delivery_t enferm√© dans l'enveloppe avec un d√©lai de livraison: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Maintenant, si crypto_master ¬´colle¬ª et ne parvient pas √† arriver √† verify_signature en 5 secondes, l'enveloppe n'enverra tout simplement pas ce message pour traitement.  Et crypto_master ne fera pas le travail dont personne d'autre n'a besoin. <br><br><h2>  Rapports de livraison des destinataires </h2><br>  Et enfin, un exemple d'une chose curieuse qui n'est pas r√©guli√®rement impl√©ment√©e dans SObjectizer ou so_5_extra, mais qui peut √™tre effectu√©e ind√©pendamment. <br><br>  Parfois, vous voulez recevoir du SObjectizer quelque chose comme un message de ¬´remise de rapport¬ª au destinataire.  Apr√®s tout, c'est une chose lorsque le message a atteint le destinataire, mais le destinataire pour une raison quelconque n'y a pas r√©pondu.  Une autre chose est lorsque le message n'a pas du tout atteint le destinataire.  Par exemple, il a √©t√© bloqu√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un m√©canisme de protection contre les surcharges d'agent</a> .  Dans le premier cas, un message auquel nous n'avons pas attendu de r√©ponse peut √™tre omis.  Mais dans le deuxi√®me cas, il peut √™tre judicieux de renvoyer le message apr√®s un certain temps. <br><br>  Nous allons maintenant examiner comment le m√©canisme le plus simple de ¬´rapports de livraison¬ª peut √™tre mis en ≈ìuvre √† l'aide d'enveloppes. <br><br>  Donc, nous faisons d'abord les √©tapes pr√©paratoires n√©cessaires: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Nous pouvons maintenant d√©finir les messages qui seront utilis√©s dans l'exemple.  Le premier message est une demande pour effectuer certaines actions dont nous avons besoin.  Et le deuxi√®me message est une confirmation que le premier message a atteint le destinataire: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  Ensuite, nous pouvons d√©finir un agent processor_t qui traitera les messages de type request_t.  Mais le traitement se fera avec une imitation de ¬´collage¬ª.  C'est-√†-dire  il traite request_t, apr√®s quoi il change son √©tat de st_normal √† st_busy.  Dans l'√©tat st_busy, il ne fait rien et ignore tous les messages qui lui parviennent. <br><br>  Cela signifie que si l'agent processor_t envoie trois messages request_t cons√©cutifs, il traitera le premier et les deux autres seront lev√©s, car  lors du traitement du premier message, l'agent ira √† st_busy et ignorera ce qui lui arrivera pendant qu'il est dans st_busy. <br><br>  Dans st_busy, l'agent processor_t passera 2 secondes, apr√®s quoi il reviendra √† nouveau √† st_normal et sera pr√™t √† traiter les nouveaux messages. <br><br>  Voici √† quoi ressemble l'agent processor_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Nous pouvons maintenant d√©finir l'agent requests_generator_t, qui a un tas de requ√™tes qui doivent √™tre livr√©es √† processor_t.  L'agent request_generator_t envoie le paquet entier toutes les 3 secondes, puis attend la confirmation de livraison sous la forme de delivery_receipt_t. <br><br>  Lorsque delivery_recept_t arrive, l'agent requests_generator_t jette la demande livr√©e hors du bundle.  Si le pack est compl√®tement vide, l'exemple est termin√©.  S'il reste quelque chose d'autre, le paquet restant sera envoy√© √† nouveau lors de la prochaine fois pour le renvoi. <br><br>  Voici donc le code de l'agent request_generator_t.  C'est assez volumineux, mais primitif.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous ne pouvez faire attention qu'aux internes de la m√©thode send_requests (), dans laquelle les messages request_t sont envoy√©s, enferm√©s dans une enveloppe sp√©ciale. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code d'agent Requests_generator_t</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant des messages et des agents qui doivent utiliser ces messages pour communiquer. </font><font style="vertical-align: inherit;">Il ne restait qu'une petite chose - faire en sorte que les messages delivery_receipt_t arrivent lors de la remise de request_t √† processor_t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se fait en utilisant cette enveloppe:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, il n'y a rien de compliqu√©. </font><font style="vertical-align: inherit;">Nous h√©ritons de so_5 :: extra :: envelopped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">Il s'agit d'un type d'enveloppe auxiliaire qui stocke le message qu'il </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient </font><font style="vertical-align: inherit;">et fournit l'impl√©mentation de base des hooks </font><font style="vertical-align: inherit;">handler_found_hook () et transformation_hook (). </font><font style="vertical-align: inherit;">Par cons√©quent, nous ne pouvons enregistrer que les attributs dont nous avons besoin dans custom_envelope_t et envoyer delivery_receipt_t dans le hook handler_found_hook ().</font></font><br><br>  En fait, c'est tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous ex√©cutons cet exemple, nous obtenons ce qui suit: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, je dois dire que dans la pratique, un simple custom_envelope_t pour g√©n√©rer des rapports de livraison ne convient gu√®re. </font><font style="vertical-align: inherit;">Mais si quelqu'un s'int√©resse √† ce sujet, alors il peut √™tre discut√© dans les commentaires, et non augmenter le volume de l'article.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que pourrait-on faire d'autre avec des enveloppes? </font></font></h1><br>  Grande question!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä laquelle nous-m√™mes n'avons pas de r√©ponse globale. </font><font style="vertical-align: inherit;">Probablement, les possibilit√©s ne sont limit√©es que par l'imagination des utilisateurs. </font><font style="vertical-align: inherit;">Eh bien, si pour la r√©alisation de fantasmes dans SObjectizer quelque chose manque, alors cela peut nous √™tre dit. </font><font style="vertical-align: inherit;">Nous √©coutons toujours. </font><font style="vertical-align: inherit;">Et, ce qui est important, parfois nous le faisons m√™me :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Int√©gration d'agents avec mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parlant un peu plus au s√©rieux, c'est une autre fonctionnalit√© que j'aimerais avoir de temps en temps et qui √©tait m√™me pr√©vue pour so_5_extra-1.2.0. Mais qui, tr√®s probablement, ne tombera pas dans la version 1.2.0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit de simplifier l'int√©gration des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cha√Ænes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et des agents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le fait est qu'au d√©part, des cha√Ænes ont √©t√© ajout√©es √† SObjectizer afin de simplifier la communication des agents avec d'autres parties de l'application √©crites sans agents. Par exemple, il existe le thread principal de l'application, sur lequel l'utilisateur interagit √† l'aide de l'interface graphique. Et il y a plusieurs agents-travailleurs qui font le travail ¬´dur¬ª de fond. L'envoi d'un message √† un agent √† partir du thread principal n'est pas un probl√®me: il suffit d'appeler l'envoi r√©gulier. Mais comment retransf√©rer des informations?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cela, des cha√Ænes ont √©t√© ajout√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais au fil du temps, il s'est av√©r√© que les cha√Ænes pouvaient jouer un r√¥le beaucoup plus important. Il est possible, en principe, de faire des applications multithread sur SObjectizer sans aucun agent, uniquement sur mchain-ahs (plus de d√©tails </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Et vous pouvez utiliser mchain-s comme moyen d'√©quilibrer la charge des agents. Comme m√©canisme de r√©solution des probl√®mes producteurs-consommateurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me avec le producteur-consommateur est que si le producteur g√©n√®re des messages plus rapidement que le consommateur ne peut les traiter, alors nous sommes en difficult√©. Les files d'attente de messages vont augmenter, les performances peuvent se d√©grader avec le temps ou l'application se bloque compl√®tement en raison de l'√©puisement de la m√©moire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solution habituelle que nous avons propos√© d'utiliser dans ce cas est d'utiliser</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une paire d'agents collectionneurs-interpr√®tes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous pouvez √©galement utiliser des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limites de messages</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (soit en tant que m√©canisme de protection principal, soit en compl√©ment du collecteur-interpr√®te). Mais l'√©criture collector-performer n√©cessite un travail suppl√©mentaire de la part du programmeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais les cha√Ænes peuvent √™tre utilis√©es √† ces fins avec un effort minimal du d√©veloppeur. Ainsi, le producteur mettrait le message suivant dans la cha√Æne, et le consommateur prendrait les messages de cette cha√Æne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais le probl√®me est que lorsque le consommateur est un agent, il n'est pas tr√®s pratique pour un agent de travailler avec mchain via les fonctions de r√©ception () et de s√©lection () disponibles. Et cet inconv√©nient pourrait √™tre tent√© d'√™tre √©limin√© √† l'aide d'un outil d'int√©gration d'agents et de cha√Ænes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du d√©veloppement d'un tel outil, il sera n√©cessaire de r√©soudre plusieurs probl√®mes. Par exemple, lorsqu'un message arrive dans mchain, √† quel moment doit-il √™tre extrait de mchain? Si le consommateur est libre et ne traite rien, vous pouvez imm√©diatement r√©cup√©rer le message de mchain et le transmettre √† l'agent consommateur. Si un message a d√©j√† √©t√© envoy√© au consommateur depuis mchain, il n'a pas encore r√©ussi √† traiter ce message, mais un nouveau message est d√©j√† arriv√© dans mchain ... Que faire dans ce cas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a des sp√©culations que les enveloppes pourraient aider dans ce cas. Ainsi, lorsque nous prenons le premier message de mchain et l'envoyons au consommateur, nous enveloppons ce message dans une enveloppe sp√©ciale. Lorsque l'enveloppe voit que le message a √©t√© remis et trait√©, elle demande le message suivant √† mchain (s'il y en a un).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, tout n'est pas si simple ici. </font><font style="vertical-align: inherit;">Mais jusqu'√† pr√©sent, cela semble assez r√©soluble. </font><font style="vertical-align: inherit;">Et, j'esp√®re, un m√©canisme similaire appara√Ætra dans l'une des prochaines versions de so_5_extra.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allons-nous ouvrir la bo√Æte de Pandore? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter qu'avec nous, les capacit√©s suppl√©mentaires elles-m√™mes provoquent un double sentiment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une part, les enveloppes ont d√©j√† permis / permis de faire des choses qui ont √©t√© mentionn√©es pr√©c√©demment (mais qui r√™vaient de quelque chose). </font><font style="vertical-align: inherit;">Par exemple, il s'agit d'une annulation garantie des minuteries et d'une restriction du d√©lai de livraison, des rapports de livraison, de la possibilit√© de rappeler un message pr√©c√©demment envoy√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'un autre c√¥t√©, il n'est pas clair √† quoi cela conduira par la suite. </font><font style="vertical-align: inherit;">Apr√®s tout, vous pouvez cr√©er un probl√®me √† partir de n'importe quelle opportunit√© si vous commencez √† utiliser cette opportunit√© l√† o√π vous en avez besoin et o√π vous n'en avez pas. </font><font style="vertical-align: inherit;">Alors peut-√™tre que nous ouvrons la bo√Æte de Pandore et nous n'imaginons toujours pas ce qui nous attend? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne reste plus qu'√† √™tre patient et √† voir o√π tout cela nous m√®nera.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä propos des plans de d√©veloppement imm√©diat de SObjectizer au lieu de conclure </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu d'une conclusion, je veux parler de la fa√ßon dont nous voyons l'avenir tr√®s proche (et pas seulement) de SObjectizer. Si quelqu'un n'est pas satisfait de quelque chose dans nos plans, alors vous pouvez parler et influencer la fa√ßon dont SObjectizer-5 se d√©veloppera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les premi√®res versions b√™ta de SObjectizer-5.5.23 et so_5_extra-1.2.0 sont d√©j√† corrig√©es et disponibles pour t√©l√©chargement et exp√©rimentations. Il y aura encore beaucoup de travail √† faire dans le domaine de la documentation et des cas d'utilisation. Par cons√©quent, la sortie officielle est pr√©vue dans la premi√®re d√©cennie de novembre. Si cela fonctionne plus t√¥t, nous le ferons plus t√¥t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sortie de SObjectizer-5.5.23 semble signifier que l'√©volution de la branche 5.5 touche √† sa fin. La toute </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premi√®re version de ce fil a eu lieu il y a quatre ans, en octobre 2014.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Depuis lors, SObjectizer-5 a √©volu√© au sein de la branche 5.5 sans aucun changement majeur entre les versions. Ce n'√©tait pas facile. Surtout compte tenu du fait que pendant tout ce temps, nous avons d√ª regarder en arri√®re des compilateurs qui avaient loin d'√™tre un support id√©al pour C ++ 11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous ne voyons aucune raison de revenir sur la compatibilit√© au sein de la branche 5.5, et en particulier sur les anciens compilateurs C ++. Ce qui pouvait √™tre justifi√© en 2014, alors que le C ++ 14 se pr√©parait √† √™tre officiellement adopt√© et que le C ++ 17 n'√©tait pas encore √† l'horizon, il semble maintenant compl√®tement diff√©rent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, dans SObjectizer-5.5 lui-m√™me, il a d√©j√† accumul√© une bonne quantit√© de rake et de sauvegardes qui sont apparues en raison de cette m√™me compatibilit√© et qui compliquent le d√©veloppement ult√©rieur de SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, dans les prochains mois, nous allons agir selon le sc√©nario suivant: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. D√©veloppement de la prochaine version de so_5_extra, dans laquelle je souhaite ajouter des outils pour simplifier l'√©criture de tests pour les agents. Il ne sera pas encore clair si ce sera so_5_extra-1.3.0 (c'est-√†-dire avec des changements de rupture par rapport √† 1.2.0) ou s'il sera so_5_extra-1.2.1 (c'est-√†-dire sans changements de rupture). Voyons comment √ßa se passe. Il est clair que la prochaine version de so_5_extra sera bas√©e sur SObjectizer-5.5.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1a. Si pour la prochaine version de so_5_extra vous devez faire quelque chose de plus dans SObjectizer-5.5, alors la prochaine version 5.5.24 sera publi√©e. Si pour so_5_extra il ne sera pas n√©cessaire d'apporter des am√©liorations au c≈ìur de SObjectizer, alors la version 5.5.23 se r√©v√©lera √™tre la derni√®re version significative dans le cadre de la branche 5.5. Des versions mineures de correction de bugs sortiront. Mais le d√©veloppement de la branche 5.5 elle-m√™me s'arr√™te sur la version 5.5.23 ou 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Ensuite, une version de SObjectizer-5.6.0 sera publi√©e, ce qui ouvrira une nouvelle branche. Dans la branche 5.6, nous allons nettoyer le code SObjectizer de toutes les b√©quilles et sauvegardes accumul√©es, ainsi que des anciennes corbeilles qui ont longtemps √©t√© marqu√©es comme obsol√®tes. Il est probable que certaines choses subiront une refactorisation (par exemple, abstract_message_box_t peut √™tre modifi√©), mais √† peine cardinal. Les principes de base du travail et les caract√©ristiques de SObjectizer-5.5 dans SObjectizer-5.6 resteront sous la m√™me forme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 n√©cessitera d√©j√† C ++ 14 (au moins au niveau GCC-5.5). Les compilateurs Visual C ++ sous VC ++ 15 (qui proviennent de Visual Studio 2017) ne seront pas pris en charge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous consid√©rons la branche 5.6 comme une branche stable de SObjectizer, qui sera pertinente jusqu'√† l'apparition de la premi√®re version de SObjectizer-5.7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je voudrais publier la version 5.6.0 au d√©but de 2019, provisoirement en f√©vrier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Apr√®s avoir stabilis√© la branche 5.6, nous aimerions commencer √† travailler sur la branche 5.7, dans laquelle nous pourrions r√©viser certains principes de base du travail de SObjectizer. Par exemple, abandonnez compl√®tement les r√©partiteurs publics pour ne laisser que des r√©partiteurs priv√©s. Refaire le m√©canisme des coop√©ratives et leurs relations parents-enfants, √©liminant ainsi le goulot d'√©tranglement lors de l'enregistrement / de la d√©sinscription des coop√©ratives. Supprimer la division par message / signal. Autorisez uniquement send / send_delayed / send_periodic √† envoyer des messages, et masquez les m√©thodes delivery_message et schedule_timer ¬´sous le capot¬ª. Modifiez le m√©canisme de distribution des messages de mani√®re √† supprimer compl√®tement dynamic_casts de ce processus ou √† les r√©duire au minimum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, il y a o√π se retourner. Dans le m√™me temps, SObjectizer-5.7 n√©cessitera d√©j√† C ++ 17, sans √©gard √† C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous regardez des choses sans lunettes roses, c'est bien si la version 5.7.0 a lieu √† la fin de l'automne 2019. la principale version de travail de SObjectizer pour 2019 sera la branche 5.6. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Parall√®lement √† tout cela, so_5_extra va se d√©velopper. Probablement, la version so_5_extra-2 sera publi√©e avec SObjectizer-5.6, qui incorporera de nouvelles fonctionnalit√©s au cours de 2019, mais bas√© sur SObjectizer-5.6.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, nous voyons nous-m√™mes une √©volution progressive de SObjectizer-5 avec une r√©vision progressive de certains des principes de base de SObjectizer-5. Dans le m√™me temps, nous essaierons de le faire le plus en douceur possible afin qu'il soit possible de passer d'une version √† l'autre avec un minimum de douleur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, si quelqu'un souhaite des changements plus spectaculaires et significatifs de SObjectizer, alors </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons quelques r√©flexions √† ce sujet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En bref: vous pouvez refaire SObjectizer comme vous le souhaitez, jusqu'√† impl√©menter SObjectizer-6 pour un autre langage de programmation. Mais nous ne le ferons pas compl√®tement √† nos propres frais, comme cela se produit avec l'√©volution de SObjectizer-5.</font></font><br><br>  C‚Äôest probablement tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les commentaires </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur l'article pr√©c√©dent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se sont r√©v√©l√©s √™tre une discussion bonne et constructive. </font><font style="vertical-align: inherit;">Il serait utile pour nous qu'une discussion similaire ait lieu cette fois. </font><font style="vertical-align: inherit;">Comme toujours, nous sommes pr√™ts √† r√©pondre √† toutes les questions, mais aux plus sens√©es, et avec plaisir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et aux lecteurs les plus patients qui ont atteint ces lignes, merci beaucoup pour le temps pass√© √† lire l'article.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426983/">https://habr.com/ru/post/fr426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426973/index.html">Sandwichs d'entreprise</a></li>
<li><a href="../fr426975/index.html">Joker 2018: l'impossible est possible</a></li>
<li><a href="../fr426977/index.html">LibreOffice: le cauchemar d'un comptable</a></li>
<li><a href="../fr426979/index.html">Comment apprendre l'anglais gratuitement: 3 outils communs et des instructions d√©taill√©es pour chacun</a></li>
<li><a href="../fr426981/index.html">10 astuces pour un tableau de bord avanc√© dans Splunk. Partie 1</a></li>
<li><a href="../fr426985/index.html">kubebox et autres coques de console pour Kubernetes</a></li>
<li><a href="../fr426987/index.html">Apprenez OpenGL. Le√ßon 6.3 - √âclairage bas√© sur l'image. Irradiation diffuse</a></li>
<li><a href="../fr426991/index.html">Startup Digest: 10 √©v√©nements IT √† venir √† Moscou</a></li>
<li><a href="../fr426993/index.html">Dois-je apprendre le C pour comprendre le fonctionnement d'un ordinateur?</a></li>
<li><a href="../fr426995/index.html">Le recyclage nuit aux produits et aux employ√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>