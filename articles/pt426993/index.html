<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✉️ 🧘🏾 🧘🏻 Preciso aprender C para entender como um computador funciona? 🦍 🍎 📙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu sempre ouvi pessoas sugerindo estudar C. para entender o desempenho do computador.É uma boa idéia? Tem certeza Esbocarei imediatamente as conclusõe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preciso aprender C para entender como um computador funciona?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426993/">  Eu sempre ouvi pessoas sugerindo estudar C. para entender o desempenho do computador.É uma boa idéia?  Tem certeza  Esbocarei imediatamente as conclusões do artigo, apenas para maior clareza: <br><br><ul><li>  C não é como o computador funciona. </li><li>  Eu não acho que a maioria das pessoas fala literalmente, então isso não importa. </li><li>  Compreender o contexto significa que aprender C por esse motivo ainda pode fazer sentido, dependendo de seus objetivos. </li></ul><br>  Pretendo escrever mais dois artigos com uma explicação mais detalhada das conclusões, mas isso já é suficiente.  Adicione links aqui quando os artigos forem publicados. <br><a name="habracut"></a><br>  Muitas vezes ouvi das pessoas isso: <br><br><blockquote> Ao estudar C, você pode entender como os computadores funcionam. </blockquote><br>  Não acho que a ideia esteja inicialmente errada, mas tem algumas reservas.  Se você os lembrar, pode muito bem ser uma estratégia viável para aprender coisas novas e importantes.  No entanto, raramente vejo pessoas discutindo essas reservas em detalhes, por isso estou escrevendo este artigo para fornecer, em minha opinião, um contexto muito necessário ... Se você está pensando em aprender C a entender como o computador funciona, este artigo é para você.  Espero que ela ajude você a descobrir. <br><br><blockquote>  Antes de realmente começarmos, gostaria de dizer mais uma coisa: se você quer aprender C, então estude!  Aprender é ótimo.  Aprender C se tornou muito importante para minha compreensão da computação e minha carreira.  Aprender essa linguagem e seu lugar na história de uma linguagem de programação fará de você um programador melhor.  Você não precisa de nenhuma desculpa.  Aprenda as coisas apenas para aprender.  Este artigo pretende ser uma diretriz para entender a verdade, não discute se deve ou não estudar C. </blockquote><br>  Antes de tudo, para quem essa idéia é geralmente recomendada.  Se você está tentando "descobrir como os computadores funcionam", não é necessário dizer que atualmente você não entende isso.  Quais programadores não entendem como os computadores funcionam?  Eu basicamente vi que esse sentimento vem de pessoas que programam principalmente em linguagens de "script" de tipo dinâmico, como Ruby, Python ou JavaScript.  Eles supostamente "não sabem como os computadores funcionam" porque essas linguagens funcionam dentro de uma máquina virtual, onde apenas a semântica da máquina virtual é importante.  No final, toda a idéia de uma máquina virtual é fornecer portabilidade.  O objetivo não é depender do equipamento em que a VM está sendo executada. <br><br>  Há apenas um problema: C <i>também</i> funciona dentro de uma máquina virtual. <br><br><h3>  Máquina abstrata C </h3><br>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especificação C99</a> , seção 5.1.2.3, “Execução do Programa”: <br><br><blockquote>  As descrições semânticas nesta Norma descrevem o comportamento de uma máquina abstrata na qual os problemas de otimização não são relevantes. </blockquote><br>  Na minha opinião, é mais importante entender ao aprender C. A linguagem não "descreve como um computador funciona", mas descreve como uma "máquina C abstrata" funciona.  Tudo o mais importante segue esse conceito. <br><br><blockquote> Mais uma observação: aqui eu escolhi o C99, que não é o mais recente padrão C. Por que?  Bem, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSVC tem ... suporte interessante à linguagem C</a> , e eu sou usuário do Windows atualmente.  Sim, você pode executar o <code>clang</code> e o <code>gcc</code> no Windows.  Não há uma diferença tão grande entre C89, C99 e C11 quanto ao que estamos falando.  Em algum momento, você tem que escolher.  A versão que mencionei aqui inclui algumas alterações na especificação original. </blockquote><br>  Você pode ter ouvido outra frase em sua palestra em C: "C é montador portátil".  Se você pensar nessa frase, entenderá que, se isso for verdade, C não poderá corresponder à operação de um computador: existem muitos computadores diferentes com arquiteturas diferentes.  Se C é como um montador que roda em computadores diferentes com arquiteturas diferentes, ele não pode funcionar simultaneamente exatamente como cada um desses computadores.  Ele <i>deve</i> esconder os detalhes, caso contrário ele não será portátil! <br><br>  No entanto, acho que esse fato não importa, porque as pessoas quase não estão literalmente se referindo a "C é como o computador funciona".  Antes de retornar a isso, vamos falar sobre a máquina C abstrata e por que muitos parecem não entender esse aspecto de C. <br><br><h3>  Digressão: por que as pessoas estão enganadas? </h3><br>  Só posso falar da minha experiência, embora com certeza não seja única. <br><br>  Aprendi GW-BASIC, C, C ++ e Java.  Ouvi falar sobre Java antes de começar a escrevê-lo em 1999, quatro anos depois que ele apareceu.  O marketing na época contrastou ativamente Java e C ++, concentrando-se na JVM como plataforma e no fato de que o modelo da máquina o distingue do C ++ e, portanto, a C. Sun Microsystems não existe mais, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">espelho</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunicado de imprensa</a> nos lembra: <br><br><blockquote>  Os aplicativos Java são independentes de plataforma;  você só precisa portar a máquina virtual Java para cada plataforma.  Ele atua como um intérprete entre o computador do usuário e o aplicativo Java.  Um aplicativo gravado no ambiente Java pode funcionar em qualquer lugar, eliminando a necessidade de portar aplicativos para várias plataformas. </blockquote><br>  O lema principal era "Escreva uma vez, corra em todos os lugares".  Essas duas frases tornaram-se como eu (e muitas outras) entendemos o Java e como ele difere do C ++.  Java tem um intérprete, uma máquina virtual Java.  Não há máquina virtual em C ++. <br><br>  Com esse marketing poderoso, a “máquina virtual” na mente de muitas pessoas se tornou sinônimo de “um grande tempo de execução e / ou intérprete”.  Os idiomas sem esse recurso estavam muito vinculados a um computador específico e exigiam portabilidade porque não eram verdadeiramente independentes de plataforma.  O principal motivo pelo qual o Java existiu foi uma alteração nessa falha do C ++. <br><br><blockquote>  "Ambiente de tempo de execução", "máquina virtual" e "máquina abstrata" são palavras diferentes para o mesmo conceito fundamental.  Mas desde então eles receberam conotações diferentes devido a uma ligeira variação na implementação dessas idéias. </blockquote><br>  Pessoalmente, acredito que esse marketing de 1995 seja a razão pela qual os programadores ainda não entendem a natureza de C. <br><br>  Então, essa afirmação é falsa?  Por que a Sun Microsystems gastaria milhões e milhões de dólares promovendo mentiras?  Se C também é baseado em uma máquina abstrata que oferece portabilidade entre plataformas, por que precisamos do Java?  Eu acho que essa é a chave para entender o que as pessoas realmente querem dizer quando dizem "C é como o computador funciona". <br><br><h3>  O que as pessoas realmente querem dizer? </h3><br>  Embora C funcione no contexto de uma máquina virtual, ainda é significativamente diferente das linguagens semelhantes a Java.  Sun não mentiu.  Para entender, você precisa conhecer a história de C. <br><br>  Em 1969, o Bell Labs escreveu um sistema operacional de computador em linguagem assembly.  Em 1970, foi apelidado de UNIX.  Com o tempo, o Bell Labs comprou mais e mais novos computadores, incluindo o PDP-11. <br><br>  Quando chegou a hora de portar o Unix para o PDP-11, eles decidiram usar uma linguagem de nível superior, o que era uma ideia bastante radical na época.  Imagine que hoje vou lhe dizer: “Vou escrever um SO em Java” - você provavelmente rirá, embora a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ideia seja realizável</a> .  A situação (no meu entender, eu não vivia na época) era aproximadamente a mesma.  Consideramos uma linguagem chamada B, mas ela não suportava algumas das funções do PDP-11 e, portanto, elas criaram um sucessor chamando-a de "C", porque era a próxima letra do alfabeto. <br><br><blockquote>  Não havia idioma "A";  B conseguiu o BCPL (Basic Combined Programming Language). </blockquote><br>  Em 1972, o primeiro compilador C foi escrito no PDP-11 e, ao mesmo tempo, reescreveu o UNIX em C. Inicialmente, eles não pensavam em portabilidade, mas C ganhou fama, então os compiladores C foram portados para outros sistemas. <br><br>  Em 1978, a primeira edição do livro "Linguagem de programação C" foi publicada.  Chamado carinhosamente "K&amp;R", de acordo com os nomes de seus autores, o livro não se parecia em nada com a especificação, mas ao mesmo tempo descreveu a linguagem em detalhes suficientes, como resultado dos quais outros também tentaram escrever compiladores C. Mais tarde, essa "versão" será chamada "K&amp;R C". <br><br>  À medida que o UNIX e o C se espalham, ambos foram portados para muitos computadores.  Nos anos 70 e 80, sua base de hardware estava em constante crescimento.  Da mesma maneira que C foi criado porque B não suportava todas as funções do PDP-11, muitos compiladores usavam extensões de idioma.  Como havia apenas K&amp;R e não uma especificação, isso foi considerado aceitável desde que as extensões estivessem razoavelmente próximas.  Em 1983, a falta de padronização estava causando problemas, então a ANSI criou uma equipe para preparar a especificação.  Em 1989, o padrão C89 foi lançado, às vezes chamado de "ANSI C". <br><br>  A especificação C tentou unificar essas diversas implementações em vários hardwares.  Portanto, a máquina C abstrata é um tipo da menor especificação possível que permitiria que o mesmo código funcionasse da mesma maneira em todas as plataformas.  As implementações de C foram compiladas, não interpretadas, portanto não havia intérprete; portanto, não havia “VM” no sentido de 1995.  No entanto, os programas C são gravados nesse computador abstrato inexistente e, em seguida, o código é convertido em assembler específico para o computador específico no qual o programa está sendo executado.  Você não pode confiar em alguns detalhes específicos para escrever código portátil C. Isso torna muito difícil escrever portátil C, pois você pode ter assumido uma plataforma específica ao escrever a versão inicial do seu código. <br><br>  Isso é melhor ilustrado por um exemplo.  Um dos principais tipos de dados em C é <code>char</code> , da palavra "caractere".  No entanto, a máquina C abstrata não determina quantos bits devem estar em <code>char</code> .  Bem, determina, mas não pelo número;  determina o tamanho de <code>CHAR_BIT</code> , que é uma constante.  Seção 5.2.4.2.1 da especificação: <br><br><blockquote>  Os valores abaixo devem ser substituídos por expressões constantes que são adequadas ou usadas nas <code>#if</code> pré-processamento <code>#if</code> ... Os valores em implementações específicas devem ser iguais ou maiores em magnitude (valor absoluto) aos dados aqui com o mesmo sinal. <br><br> <code>CHAR_BIT: 8</code> </blockquote> <br>  Em outras palavras, você sabe que <code>char</code> é pelo menos 8 bits, mas as implementações podem ser maiores.  Para codificar corretamente uma “máquina C abstrata”, <code>CHAR_BIT</code> deve ser usado em vez de <code>8</code> como o tamanho no processamento de <code>char</code> .  Mas isso não é algum tipo de função de intérprete, como pensamos em máquinas virtuais;  esta é uma propriedade de como o compilador converte o código-fonte em código de máquina. <br><br><blockquote>  Sim, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">existem sistemas em</a> que <code>CHAR_BIT</code> não <code>CHAR_BIT</code> <code>8</code> . </blockquote><br>  Portanto, essa "máquina abstrata", embora tecnicamente a mesma idéia que a máquina virtual Java, é mais provável uma construção de compilação para gerenciar compiladores para criar código assembler, em vez de algum tipo de verificação ou propriedade de tempo de execução.  O tipo equivalente em Java é um <code>byte</code> , sempre com 8 bits, e a implementação da JVM é encarregada do que fazer em plataformas com mais bytes.  (Não tenho certeza se a JVM funciona em qualquer uma dessas plataformas, mas é assim que deve funcionar.)  A máquina C abstrata foi criada como um invólucro mínimo para vários "hardwares", e não como um tipo de plataforma feita de tecido sólido escrito em software para seu código. <br><br>  Portanto, embora a Sun estivesse tecnicamente errada, na prática eles significam um pouco do que literalmente dizem, e o que eles <i>querem dizer</i> é verdade.  A mesma coisa com a frase "Aprenda C para entender como os computadores funcionam". <br><br><h3>  Aprenda C para MELHOR Compreender como os computadores funcionam </h3><br>  O <i>que as</i> pessoas <i>realmente</i> querem dizer?  No contexto de "um rubista deve aprender C para entender como os computadores funcionam" - este é um conselho para descer "ao nível do ferro".  Ou seja, não apenas para entender como o seu próprio programa funciona dentro da máquina virtual, mas também como a combinação do programa e da VM funciona no contexto da própria máquina. <br><br>  O Learning C <i>fornecerá</i> mais desses detalhes, porque a máquina abstrata está muito mais próxima do hardware, bem como das abstrações dos sistemas operacionais.  A linguagem C é muito diferente das linguagens de alto nível, portanto, aprendê-lo pode ensinar muito. <br><br>  Mas é importante lembrar que C é essencialmente uma <i>abstração de</i> hardware e as abstrações são imperfeitas.  Cuidado com o que C faz ou como funciona com a própria máquina.  Se você for muito fundo, certamente encontrará essas diferenças, que podem causar problemas.  A maioria dos recursos de treinamento para C, especialmente hoje, quando o equipamento está se tornando mais homogêneo, promoverá a ideia de que <i>é assim que</i> um computador funciona.  Portanto, pode ser difícil para um aluno entender o que está acontecendo sob o capô e qual é a abstração fornecida por C. <br><br>  Nesta discussão, nem tocamos em outros assuntos.  Por exemplo, devido à enorme popularidade de C, o hardware se tornou mais uniforme porque tende a avançar para a semântica da máquina abstrata C. Se sua arquitetura é muito diferente da semântica C, os programas C podem ser executados muito mais lentamente que outros. e a velocidade do hardware é frequentemente medida por testes em C. Este artigo já é bastante longo ... <br><br>  Por esse motivo, acho que uma versão mais precisa dessa declaração seria "Ao aprender C, você aprenderá <i>mais</i> sobre como os computadores funcionam".  Eu realmente acho que um conhecimento aproximado de C é útil para muitos programadores, mesmo que eles próprios não escrevam C. A introdução de C também dará uma idéia da história de nossa indústria. <br><br>  Existem outras maneiras de explorar esse tópico;  C não <i>é inerentemente</i> projetado para aprender sobre um computador, mas é uma boa opção. <br><br>  Há muito o que aprender em programação.  Desejo-lhe sucesso nesta jornada. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426993/">https://habr.com/ru/post/pt426993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426981/index.html">10 truques para painéis avançados no Splunk. Parte 1</a></li>
<li><a href="../pt426983/index.html">Novo no SObjectizer-5.5.23: realização de desejos ou caixa de Pandora?</a></li>
<li><a href="../pt426985/index.html">kubebox e outras conchas do console para o Kubernetes</a></li>
<li><a href="../pt426987/index.html">Aprenda o OpenGL. Lição 6.3 - Iluminação Baseada em Imagem. Irradiação difusa</a></li>
<li><a href="../pt426991/index.html">Startup Digest: 10 próximos eventos de TI em Moscou</a></li>
<li><a href="../pt426995/index.html">A reciclagem prejudica produtos e funcionários</a></li>
<li><a href="../pt426997/index.html">Como criar formas personalizadas usando MaterialShapeDrawable</a></li>
<li><a href="../pt426999/index.html">Seguindo as tendências ou avançando para o RxJava e o LiveData</a></li>
<li><a href="../pt427003/index.html">Mapas hexagonais em Unity: neblina da guerra, pesquisa de mapas, geração de procedimentos</a></li>
<li><a href="../pt427005/index.html">Desenvolvedores de IA - a profissão de milionários?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>