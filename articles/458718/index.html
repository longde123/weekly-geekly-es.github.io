<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçµ üï∂Ô∏è ü§¶ Gran entrevista con Cliff Click, el padre de la compilaci√≥n JIT en Java üëâüèæ ü§õüèº üç∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cliff Click es el CTO de Cratus (sensores IoT para la mejora de procesos), fundador y cofundador de varias startups (incluidas Rocket Realtime School,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gran entrevista con Cliff Click, el padre de la compilaci√≥n JIT en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/458718/"><p><img src="https://habrastorage.org/getpro/habr/post_images/bed/01d/799/bed01d799e35f74331803908a94516bb.jpg" width="200" align="left">  <strong>Cliff Click</strong> es el CTO de Cratus (sensores IoT para la mejora de procesos), fundador y cofundador de varias startups (incluidas Rocket Realtime School, Neurensic y H2O.ai) con varias salidas exitosas.  ¬°Cliff escribi√≥ su primer compilador a los 15 a√±os (Pascal para TRS Z-80)!  Mejor conocido por trabajar en C2 en Java (Sea of ‚Äã‚ÄãNodes IR).  Este compilador mostr√≥ al mundo que JIT puede producir c√≥digo de alta calidad, que se ha convertido en uno de los factores para hacer de Java una de las principales plataformas de software modernas.  Cliff luego ayud√≥ a Azul Systems a construir un mainframe de 864 n√∫cleos con un software Java puro que admit√≠a pausas GC en un mont√≥n de 500 gigabytes durante 10 milisegundos.  En general, Cliff logr√≥ trabajar en todos los aspectos de la JVM. <br clear="all"><br>  Esta publicaci√≥n central es una gran entrevista con Cliff.  Hablaremos sobre los siguientes temas: </p><br><ul><li>  Transici√≥n a optimizaciones de bajo nivel </li><li>  C√≥mo hacer muchas refactorizaciones </li><li>  Modelo de costo </li><li>  Entrenamiento de optimizaci√≥n de bajo nivel </li><li>  Estudios de casos de mejora de la productividad </li><li>  ¬øPor qu√© crear tu propio lenguaje de programaci√≥n? </li><li>  Carrera de ingeniero de rendimiento </li><li>  Desaf√≠os t√©cnicos </li><li>  Un poco sobre la asignaci√≥n de registros y multin√∫cleo </li><li>  El mayor desaf√≠o de la vida. </li></ul><br><p>  Entrevistas realizadas por: </p><br><ul><li>  <strong>Andrey Satarin</strong> de Amazon Web Services.  En su carrera, logr√≥ trabajar en proyectos completamente diferentes: prob√≥ la base de datos distribuida NewSQL en Yandex, el sistema de detecci√≥n en la nube en Kaspersky Lab, el juego multiusuario en Mail.ru y el servicio de c√°lculo de cambio de divisas en Deutsche Bank.  Est√° interesado en probar sistemas distribuidos y backend a gran escala. </li><li>  <strong>Vladimir Sitnikov</strong> de Netcracker.  Durante diez a√±os, ha estado trabajando en el rendimiento y la escalabilidad del sistema operativo NetCracker, un software utilizado por los operadores de telecomunicaciones para automatizar los procesos de gesti√≥n de redes y equipos de red.  Est√° interesado en los problemas de rendimiento de Java y Oracle Database.  El autor de m√°s de una docena de mejoras de rendimiento en el controlador JDBC oficial de PostgreSQL. <a name="habracut"></a></li></ul><br><h1 id="perehod-k-nizkourovnevym-optimizaciyam">  Transici√≥n a optimizaciones de bajo nivel </h1><br><p>  <strong>Andrei</strong> : Eres una persona famosa en el mundo de la compilaci√≥n JIT, en Java y trabajas en el rendimiento en general, ¬øverdad? </p><br><p>  <strong>Cliff</strong> : ¬°Eso es! </p><br><p>  <strong>Andrew</strong> : Comencemos con preguntas generales sobre c√≥mo trabajar en el rendimiento.  ¬øQu√© opina de la elecci√≥n entre optimizaciones de alto y bajo nivel como el trabajo a nivel de CPU? </p><br><p> <strong>Acantilado</strong> : es f√°cil.  El c√≥digo m√°s r√°pido es uno que nunca se ejecuta.  Por lo tanto, siempre debe comenzar desde un alto nivel, trabajar en algoritmos.  Una mejor notaci√≥n O superar√° a una notaci√≥n O peor, a menos que intervengan constantes bastante grandes.  Las cosas de bajo nivel son lo √∫ltimo.  Por lo general, si optimiz√≥ el resto de la pila lo suficientemente bien, y todav√≠a queda algo interesante: este es el nivel bajo.  Pero, ¬øc√≥mo comenzar desde un nivel alto?  ¬øC√≥mo descubrir que se ha realizado suficiente trabajo a alto nivel?  Bueno ... de ninguna manera.  No hay recetas preparadas.  Debe comprender el problema, decidir qu√© va a hacer (para no hacer pasos innecesarios en el futuro) y luego puede descubrir un generador de perfiles que pueda decir algo √∫til.  En alg√∫n momento, usted mismo comprende que se deshizo de cosas innecesarias y que es hora de ajustar el nivel bajo.  Este es definitivamente un tipo especial de arte.  Mucha gente hace cosas innecesarias, pero se mueven tan r√°pido que no tienen tiempo para preocuparse por el rendimiento.  Pero esto es mientras la pregunta no se mantenga en pie.  Por lo general, el 99% de las veces a nadie le importa lo que hago, hasta el momento en que algo importante que le importa a alguien no entra en el camino cr√≠tico.  Y aqu√≠ todo el mundo comienza a molestarte sobre el tema "por qu√© no funcion√≥ perfectamente desde el principio".  En general, siempre hay algo que mejorar en el rendimiento.  ¬°Pero el 99% de las veces no tienes pistas!  Solo est√° tratando de hacer que algo funcione y en el proceso comprende lo que es importante.  Nunca se puede saber de antemano que esta pieza debe perfeccionarse, por lo tanto, en esencia, debe ser perfecto en todo.  Y esto es imposible, y t√∫ no haces eso.  Siempre hay un mont√≥n de cosas que arreglar, y eso es perfectamente normal. </p><br><h1 id="kak-delat-bolshoy-refaktoring">  C√≥mo hacer muchas refactorizaciones </h1><br><p>  <strong>Andrew</strong> : ¬øC√≥mo trabajas en el rendimiento?  Este es un tema transversal.  Por ejemplo, ¬øha tenido que trabajar en problemas derivados de la intersecci√≥n de una gran cantidad de funcionalidad existente? </p><br><p>  <strong>Cliff</strong> : trato de evitar esto.  Si s√© que el rendimiento se convertir√° en un problema, lo pienso antes de comenzar a codificar, especialmente en estructuras de datos.  Pero a menudo descubres todo esto mucho m√°s tarde.  Y luego tienes que tomar medidas extremas y hacer lo que yo llamo "reescribir y conquistar": necesitas agarrar una pieza bastante grande.  Parte del c√≥digo a√∫n tendr√° que reescribirse debido a problemas de rendimiento u otra cosa.  Cualquiera sea la raz√≥n para reescribir el c√≥digo, casi siempre es mejor reescribir un fragmento m√°s grande que un fragmento m√°s peque√±o.  En este momento, todos comienzan a temblar de miedo: "¬°Dios m√≠o, no puedes tocar tanto c√≥digo!"  Pero, de hecho, este enfoque casi siempre funciona mucho mejor.  Debes abordar el gran problema de inmediato, dibujar un gran c√≠rculo alrededor de √©l y decir: reescribir√© todo dentro del c√≠rculo.  El borde es mucho m√°s peque√±o que el contenido en su interior que debe reemplazarse.  Y si esa delimitaci√≥n de bordes le permite hacer el trabajo en el interior perfectamente: tiene las manos desatadas, haga lo que quiera.  Una vez que comprenda el problema, el proceso de reescritura es mucho m√°s f√°cil, ¬°as√≠ que muerda una gran parte! <br>  Al mismo tiempo, cuando reescribe en fragmentos grandes y comprende que el rendimiento se convertir√° en un problema, puede comenzar a preocuparse de inmediato.  Por lo general, esto se convierte en cosas simples como "no copie datos, administre datos lo m√°s simple posible, h√°galos m√°s peque√±os".  En reescrituras grandes, hay formas est√°ndar de mejorar el rendimiento.  Y casi siempre giran en torno a los datos. </p><br><h1 id="model-stoimosti">  Modelo de costo </h1><br><p>  <strong>Andrew</strong> : En uno de los podcasts, habl√≥ sobre modelos de costos en el contexto de la productividad.  ¬øPuedes explicar qu√© se entiende por esto? </p><br><p>  <strong>Acantilado</strong> : por supuesto.  Nac√≠ en una era en la que el rendimiento del procesador era extremadamente importante.  Y esta era est√° volviendo de nuevo: el destino no est√° exento de iron√≠a.  Comenc√© a vivir en la √©poca de las m√°quinas de ocho bits; mi primera computadora funcionaba con 256 bytes.  Es bytes.  Todo era muy peque√±o.  Tuvimos que leer las instrucciones y tan pronto como comenzamos a subir la pila de lenguajes de programaci√≥n, los lenguajes adquirieron cada vez m√°s.  Hubo Assembler, luego Basic, luego C, y C se hizo cargo del trabajo con muchos detalles, como la asignaci√≥n de registros y la selecci√≥n de instrucciones.  Pero todo estaba bastante claro all√≠, y si hice un puntero a una instancia de una variable, obtendr√© carga, y el costo es conocido por esta instrucci√≥n.  Iron produce un n√∫mero conocido de ciclos de m√°quina, por lo que la velocidad de ejecuci√≥n de diferentes piezas se puede calcular simplemente agregando todas las instrucciones que estaba a punto de ejecutar.  Cada comparaci√≥n / prueba / sucursal / llamada / carga / tienda podr√≠a plegarse y decir: aqu√≠ tiene el tiempo de entrega.  Cuando mejore el rendimiento, definitivamente prestar√° atenci√≥n a qu√© tipo de n√∫meros corresponden a peque√±os ciclos calientes. <br>  Pero tan pronto como cambie a Java, Python y cosas similares, se alejar√° r√°pidamente del hierro de bajo nivel.  ¬øCu√°nto cuesta una llamada getter en Java?  Si el JIT en HotSpot est√° correctamente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">l√≠nea</a> , se cargar√°, pero si no lo hizo, ser√° una llamada de funci√≥n.  Dado que el desaf√≠o radica en el bucle activo, deshacer√° todas las dem√°s optimizaciones en este bucle.  Por lo tanto, el valor real ser√° mucho mayor.  E inmediatamente pierde la capacidad de mirar un fragmento de c√≥digo y comprende que debemos ejecutarlo en t√©rminos de la velocidad del reloj del procesador, la memoria utilizada y el cach√©.  Todo esto se vuelve interesante solo si realmente te emborrachaste en el rendimiento. <br>  Ahora estamos en una situaci√≥n en la que las velocidades de los procesadores casi no han crecido durante una d√©cada.  Los viejos tiempos han vuelto!  Ya no puede contar con un buen rendimiento de subproceso √∫nico.  Pero si de repente te involucras en la computaci√≥n paralela, es incre√≠blemente dif√≠cil, todos te miran como James Bond.  La aceleraci√≥n de diez veces aqu√≠ generalmente ocurre en aquellos lugares donde alguien golpea algo.  La concurrencia requiere mucho trabajo.  Para obtener la misma aceleraci√≥n de diez veces, debe comprender el modelo de costos.  Qu√© y cu√°nto cuesta.  Y para esto necesita comprender c√≥mo la lengua se apoya en el hierro subyacente. <br>  ¬°Martin Thompson tiene una gran palabra para su blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mechanical Sympathy</a> !  Debe comprender qu√© har√° el hierro, c√≥mo lo har√° exactamente y por qu√© generalmente hace lo que hace.  Con esto, es bastante simple comenzar a leer las instrucciones y descubrir d√≥nde fluye el tiempo de ejecuci√≥n.  Si no tienes el entrenamiento adecuado, solo est√°s buscando un gato negro en una habitaci√≥n oscura.  Constantemente veo personas que optimizan el rendimiento que no tienen idea de qu√© demonios est√°n haciendo.  Est√°n muy atormentados y realmente no van a ning√∫n lado.  Y cuando tomo el mismo c√≥digo, le doy un par de peque√±os trucos all√≠ y obtengo una aceleraci√≥n de cinco o diez veces, son as√≠: bueno, es tan deshonesto, ya sab√≠amos que eres mejor.  Es asombroso.  De lo que estoy hablando ... el modelo de costo es sobre qu√© c√≥digo escribes y qu√© tan r√°pido funciona en promedio en la imagen general. </p><br><p>  <strong>Andrew</strong> : ¬øY c√≥mo mantener ese volumen en tu cabeza?  ¬øEsto se logra con m√°s experiencia o?  ¬øD√≥nde se gana esa experiencia? </p><br><p>  <strong>Cliff</strong> : Bueno, mi experiencia no fue la forma m√°s f√°cil.  Lo program√© en Assembler en un momento en que era posible entender cada instrucci√≥n individual.  Suena tonto, pero desde entonces en mi cabeza, en mi memoria, el conjunto de instrucciones Z80 se ha mantenido para siempre.  No recuerdo los nombres de las personas un minuto despu√©s de la conversaci√≥n, pero recuerdo el c√≥digo escrito hace 40 a√±os.  Es curioso, parece un s√≠ndrome de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">idiota aprendido</a> ". </p><br><h1 id="obuchenie-nizkourovnevym-optimizaciyam">  Entrenamiento de optimizaci√≥n de bajo nivel </h1><br><p>  <strong>Andrew</strong> : ¬øHay alguna forma m√°s sencilla de entrar en el negocio? </p><br><p>  <strong>Acantilado</strong> : S√≠ y no.  El hierro que todos usamos no ha cambiado tanto durante este tiempo.  Todos usan x86, con la excepci√≥n de los tel√©fonos inteligentes Arm.  Si no realiza una incrustaci√≥n hardcore, tiene lo mismo.  Ok, siguiente  Las instrucciones tampoco han cambiado en siglos.  Tienes que ir y escribir algo en Assembler.  Un poco, pero suficiente para comenzar a entender.  Est√°s sonriendo, pero lo digo en serio.  Es necesario comprender la correspondencia del lenguaje y el hierro.  Despu√©s de eso, debes ir, orinar un poco y hacer un peque√±o compilador de juguetes para un lenguaje de juguetes peque√±o.  "Juguete" significa que debes hacerlo en un tiempo razonable.  Puede ser s√∫per simple, pero debe generar instrucciones.  El acto de generar instrucciones nos permitir√° comprender el modelo de costo para el puente entre el c√≥digo de alto nivel en el que todos escriben y el c√≥digo de m√°quina que se ejecuta en el hardware.  Esta correspondencia se grabar√° en el cerebro al momento de escribir el compilador.  Incluso el compilador m√°s simple.  Despu√©s de eso, puede comenzar a mirar Java y al hecho de que tiene una brecha sem√°ntica m√°s profunda, y construir puentes encima es mucho m√°s dif√≠cil.  En Java, es mucho m√°s dif√≠cil entender si nuestro puente result√≥ ser bueno o malo, lo que har√° que se desmorone y no.  Pero necesitas un punto de partida cuando miras el c√≥digo y entiendes: "s√≠, este captador debe estar en l√≠nea todo el tiempo".  Y luego resulta que a veces esto sucede, con la excepci√≥n de la situaci√≥n cuando el m√©todo se hace demasiado grande y el JIT comienza a alinear todo.  El rendimiento de dichos lugares se puede predecir al instante.  Por lo general, los captadores funcionan bien, pero luego miras los grandes bucles calientes y te das cuenta de que hay alg√∫n tipo de llamadas a funciones flotantes que no saben lo que est√°n haciendo.  Este es el problema con el uso generalizado de captadores, la raz√≥n por la que no est√°n en l√≠nea: no est√° claro si se trata de un captador.  Si tiene una base de c√≥digo s√∫per peque√±a, puede recordarla y luego decir: este es un captador, pero este es un establecedor.  En una base de c√≥digo grande, cada funci√≥n vive su propia historia, que, en general, nadie conoce.  El generador de perfiles dice que perdimos el 24% de nuestro tiempo en alg√∫n tipo de ciclo, y para comprender lo que hace este ciclo, debemos observar cada funci√≥n en su interior.  Es imposible entender esto sin estudiar la funci√≥n, y esto ralentiza seriamente el proceso de comprensi√≥n.  Es por eso que no uso getters y setters, ¬°fui a un nuevo nivel! <br>  ¬øD√≥nde obtener el modelo de costo?  Bueno, puedes leer algo, por supuesto ... Pero creo que la mejor manera es actuar.  Haga un peque√±o compilador y esta ser√° la mejor manera de realizar el modelo de costos y ajustarlo en su propia cabeza.  Un peque√±o compilador que funcionar√≠a para la programaci√≥n de microondas es una tarea para un principiante.  Bueno, quiero decir, si ya tienes habilidades de programaci√≥n, entonces deber√≠an ser suficientes.  Todas estas cosas son como analizar una cadena, que tendr√° alg√∫n tipo de expresi√≥n algebraica, extraer las instrucciones de las operaciones matem√°ticas desde all√≠ en el orden correcto, tomar los valores correctos de los registros; todo esto se hace a la vez.  Y mientras lo hagas, quedar√° impreso en el cerebro.  Creo que todos saben lo que hace el compilador.  Y esto dar√° una comprensi√≥n del modelo de costos. </p><br><h1 id="prakticheskie-primery-uluchsheniya-proizvoditelnosti">  Estudios de casos de mejora de la productividad </h1><br><p>  <strong>Andrew</strong> : ¬øA qu√© m√°s vale la pena prestar atenci√≥n al trabajar en el rendimiento? </p><br><p>  <strong>Acantilado</strong> : Estructuras de datos.  Por cierto, s√≠, no he ense√±ado estas clases durante mucho tiempo ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rocket School</a> .  Fue divertido, pero tom√≥ mucho esfuerzo invertir, ¬°y tambi√©n tengo vida!  Esta bien  Entonces, en una de las clases grandes e interesantes, "¬øA d√≥nde va su desempe√±o?", Les di un ejemplo a los estudiantes: se leyeron dos gigabytes y medio de datos fintech de un archivo CSV y luego tuvimos que calcular la cantidad de productos vendidos.  Datos regulares del mercado de ticks.  Paquetes UDP convertidos a formato de texto desde los a√±os 70.  El Chicago Mercantile Exchange es todo tipo de cosas como mantequilla, ma√≠z, soja y similares.  Era necesario contar estos productos, el n√∫mero de transacciones, el volumen promedio de movimiento de fondos y bienes, etc.  Esta es una matem√°tica comercial bastante simple: encuentre el c√≥digo del producto (estos son 1-2 caracteres en la tabla hash), obtenga la cantidad, agr√©guela a uno de los conjuntos de ofertas, agregue volumen, agregue valor y un par de otras cosas.  Muy simple matem√°tica.  La implementaci√≥n del juguete fue muy sencilla: todo est√° en el archivo, lo leo y me muevo alrededor, separando las entradas individuales en cadenas de Java, buscando las cosas necesarias en ellas y dobl√°ndolas de acuerdo con las matem√°ticas descritas anteriormente.  Y funciona a baja velocidad. </p><br><p> Con este enfoque, todo es obvio lo que est√° sucediendo, y la computaci√≥n paralela no ayudar√° aqu√≠, ¬øverdad?  Resulta que un aumento de cinco veces en la productividad solo se puede lograr eligiendo las estructuras de datos correctas.  ¬°Y esto incluso sorprende a los programadores experimentados!  En mi caso particular, el truco fue que no deber√≠a hacer asignaciones de memoria en un bucle activo.  Bueno, esta no es toda la verdad, pero en general, no debe resaltar "una vez en X" cuando X es lo suficientemente grande.  Cuando X es de dos gigabytes y medio, no debe asignar nada "una vez por letra", "una vez por l√≠nea", o "una vez por campo", nada de eso.  Eso es exactamente lo que lleva tiempo.  ¬øC√≥mo funciona?  Imagine hacer una llamada a <code>String.split()</code> o <code>BufferedReader.readLine()</code> .  <code>Readline</code> una l√≠nea a partir de un conjunto de bytes que provienen de la red, una vez por cada l√≠nea, por cada uno de cientos de millones de l√≠neas.  Tomo esta l√≠nea, la analizo y la tiro.  ¬øPor qu√© tirarlo? Bueno, ya lo proces√©, eso es todo.  Entonces, por cada byte le√≠do de estos 2.7G, se escribir√°n dos caracteres en la l√≠nea, es decir, 5.4G ya, y ya no los necesito, por lo tanto, se descartan.  Si observa el ancho de banda de la memoria, cargamos 2.7G, que pasan por la memoria y el bus de memoria en el procesador, y luego se env√≠an el doble a la l√≠nea que se encuentra en la memoria, y todo esto se deshilacha cuando se crea cada nueva l√≠nea.  Pero necesito leerlo, el hierro lo lee, incluso si entonces todo se frota.  Y tengo que escribirlo, porque cre√© la l√≠nea y los cach√©s estaban llenos; el cach√© no puede caber 2.7G.  En total, por cada byte le√≠do, leo dos bytes m√°s y escribo dos bytes adicionales, y como resultado tienen una relaci√≥n 4: 1, en esta relaci√≥n desperdiciamos ancho de banda de memoria.  Y luego resulta que si hago <code>String.split()</code> , entonces no lo hago la √∫ltima vez, puede haber otros 6-7 campos dentro.  Por lo tanto, el c√≥digo de lectura CSV cl√°sico seguido del an√°lisis de l√≠neas conduce a una p√©rdida de ancho de banda de memoria en la regi√≥n de 14: 1 en relaci√≥n con lo que realmente le gustar√≠a tener.  Si tira estas secreciones, puede obtener una aceleraci√≥n de cinco veces. </p><br><p>  Y no es tan dif√≠cil.  Si observa el c√≥digo desde el √°ngulo correcto, todo se vuelve bastante simple, tan pronto como se d√© cuenta de la esencia del problema.  Ni siquiera deje de asignar memoria: el √∫nico problema es que asigna algo e inmediatamente muere y quema un recurso importante en el camino, que en este caso es el ancho de banda de la memoria.  Y todo esto resulta en una ca√≠da en la productividad.  En x86, generalmente necesita grabar activamente los relojes del procesador, y aqu√≠ quem√≥ toda la memoria mucho antes.  Soluci√≥n: debe reducir la cantidad de descarga. <br>  Otra parte del problema es que si inicia el generador de perfiles cuando la tira de memoria ha finalizado, justo en el momento en que esto sucede, generalmente espera a que regrese el cach√©, porque est√° lleno de basura que acaba de generar con todas estas l√≠neas.  Por lo tanto, cada operaci√≥n de carga o almacenamiento se vuelve lenta, ya que conducen a errores en el cach√©: todo el cach√© se volvi√≥ lento, esperando que la basura lo abandone.  Por lo tanto, el generador de perfiles solo mostrar√° un ruido aleatorio c√°lido extendido a lo largo de todo el ciclo; no habr√° instrucciones o lugares calientes independientes en el c√≥digo.  Solo el ruido.  Y si observa los ciclos de GC, todos ser√°n Young Generation y s√∫per r√°pidos, microsegundos o milisegundos como m√°ximo.  Despu√©s de todo, todo este recuerdo muere instant√°neamente.  Usted asigna miles de millones de gigabytes, y los corta, y los corta, y los vuelve a cortar.  Todo esto sucede muy r√°pido.  Resulta que hay ciclos de GC baratos, ruido c√°lido a lo largo de todo el ciclo, pero queremos obtener una aceleraci√≥n 5x.  En ese momento, algo deber√≠a cerrarse en mi cabeza y sonar: "¬øpor qu√©?"  El desbordamiento del ancho de banda no aparece en el depurador cl√°sico, debe ejecutar el depurador del contador de rendimiento del hardware y verlo usted mismo y directamente.  Y no directamente, se puede sospechar de estos tres s√≠ntomas.  El tercer s√≠ntoma es cuando miras lo que resaltas, le preguntas al generador de perfiles, y √©l responde: "Hiciste mil millones de l√≠neas, pero el GC funcion√≥ de forma gratuita".  Tan pronto como esto sucedi√≥, te das cuenta de que has generado demasiados objetos y quemado toda la tira de memoria.  Hay una manera de resolver esto, pero no es obvio. </p><br><p>  El problema est√° en la estructura de datos: la estructura b√°sica detr√°s de todo lo que sucede, es demasiado grande, es 2.7G en el disco, por lo que hacer una copia de esto es muy indeseable: quiero cargarlo desde el b√∫fer de bytes de red inmediatamente en los registros para no leer y escribir en la cadena ida y vuelta cinco veces.  Desafortunadamente, Java por defecto no le proporciona una biblioteca como parte del JDK.  Pero esto es trivial, ¬øverdad?  De hecho, estas son 5-10 l√≠neas de c√≥digo que se usar√°n para implementar su propio cargador de l√≠nea almacenado en b√∫fer, que repite el comportamiento de la clase de l√≠nea, mientras que es un contenedor alrededor del b√∫fer de bytes subyacente.  Como resultado, resulta que trabajas casi como con cadenas, pero de hecho hay punteros que se mueven al b√∫fer, y los bytes sin procesar no se copian en ninguna parte, y de esta manera se reutilizan los mismos b√∫feres, una y otra vez, y el sistema operativo est√° feliz de asumir cosas para las que est√° destinado, como el doble almacenamiento en b√∫fer oculto de estos b√∫feres de bytes, y usted mismo ya no tritura un flujo interminable de datos innecesarios.  Por cierto, ¬øentiendes que cuando trabajas con el GC, se garantiza que cada asignaci√≥n de memoria no ser√° visible para el procesador despu√©s del √∫ltimo ciclo del GC?  Por lo tanto, todo esto de ninguna manera puede estar en la memoria cach√©, y luego ocurre una falla 100% garantizada.  Cuando se trabaja con un puntero en x86, restar un registro de la memoria toma 1-2 ciclos, y tan pronto como esto sucede, paga, paga, paga, porque la memoria est√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NUEVE cach√©s</a> , y este es el costo de asignar memoria.  Valor presente </p><br><p>  En otras palabras, las estructuras de datos son las m√°s dif√≠ciles de cambiar.  Y tan pronto como se d√© cuenta de que ha elegido la estructura de datos incorrecta que matar√° la productividad en el futuro, por lo general necesita aumentar el trabajo esencial, pero si no lo hace, entonces ser√° peor.  En primer lugar, debe pensar en las estructuras de datos, esto es importante.  El costo principal aqu√≠ radica en las estructuras de datos en negrita, que comienzan a usar al estilo de "Copi√© la estructura de datos X en la estructura de datos Y, porque me gusta m√°s la forma".  Pero la operaci√≥n de copia (que parece barata) en realidad gasta una franja de memoria y aqu√≠ est√° enterrado todo el tiempo de ejecuci√≥n perdido.  Si tengo una cadena gigante con JSON y quiero convertirla en un √°rbol DOM estructurado de POJO o algo as√≠, la operaci√≥n de analizar esta cadena y construir un POJO, y luego una nueva llamada a POJO en el futuro resultar√° in√∫til, no es algo barato.  Excepto si correr√° en POJO con mucha m√°s frecuencia que en una l√≠nea.  Por el contrario, puede intentar descifrar la cadena y extraer solo lo que necesita de ella, sin convertirla en ning√∫n POJO.  Si todo esto sucede en la ruta desde la que se requiere el m√°ximo rendimiento, no hay POJO para usted; de alguna manera, debe excavar directamente en la l√≠nea. </p><br><h1 id="zachem-sozdavat-svoy-yazyk-programmirovaniya">  ¬øPor qu√© crear tu propio lenguaje de programaci√≥n? </h1><br><p>  <strong>Andrei</strong> : Dijiste que para comprender el modelo de costos, debes escribir tu propio lenguaje peque√±o ... </p><br><p>  <strong>Cliff</strong> : No es un lenguaje, sino un compilador.  El lenguaje y el compilador son dos cosas diferentes.  La diferencia m√°s importante est√° en tu cabeza. </p><br><p>  <strong>Andrei</strong> : Por cierto, que yo sepa, est√°s experimentando con la creaci√≥n de tus propios idiomas.  Por qu√© </p><br><p>  <strong>Cliff</strong> : ¬°Porque puedo!  Estoy medio retirado, as√≠ que este es mi hobby.  He estado implementando los idiomas de otra persona toda mi vida.  Tambi√©n trabaj√© duro en el estilo de codificaci√≥n.  Y tambi√©n porque veo problemas en otros idiomas.  Veo que hay mejores formas de hacer las cosas habituales.  Y los usar√≠a.  Me cans√© de ver problemas en m√≠ mismo, en Java, en Python, en cualquier otro idioma.  Escribo en React Native, JavaScript y Elm como un pasatiempo, que no se trata de la jubilaci√≥n, sino del trabajo activo.  Y tambi√©n escribo en Python y, muy probablemente, continuar√© trabajando en aprendizaje autom√°tico para backends Java.  Hay muchos idiomas populares y todos tienen caracter√≠sticas interesantes.  Todos son buenos en algo propio y puedes intentar juntar todas estas fichas.  Entonces, estudio las cosas que me interesan, el comportamiento del lenguaje, trato de llegar a una sem√°ntica razonable.  ¬°Y hasta ahora lo estoy haciendo!  En este momento, estoy luchando con la sem√°ntica de la memoria, porque quiero tenerla tanto en C como en Java, y obtener un modelo de memoria fuerte y una sem√°ntica de memoria para cargas y tiendas.  Al mismo tiempo, tenga una inferencia de tipo autom√°tica como en Haskell.  Aqu√≠, estoy tratando de mezclar inferencia tipo Haskell con memoria trabajando tanto en C como en Java.  He estado haciendo esto durante los √∫ltimos 2-3 meses, por ejemplo. </p><br><p>  <strong>Andrei</strong> : Si est√°s construyendo un lenguaje que toma mejores aspectos de otros idiomas, ¬øpensaste que alguien har√≠a lo contrario: tomar tus ideas y usarlas? </p><br><p>  <strong>Cliff</strong> : ¬°As√≠ es como aparecen los nuevos idiomas!  ¬øPor qu√© Java es similar a C?  Debido a que C ten√≠a una buena sintaxis que todos entend√≠an y Java se inspir√≥ en esta sintaxis, agregando seguridad de tipos, verificando los l√≠mites de las matrices, GC y mejoraron algunas cosas de C. Agregaron la suya propia.  Pero se inspiraron bastante, ¬øverdad?  Todos se paran sobre los hombros de los gigantes que vinieron antes que t√∫, as√≠ es como se progresa. </p><br><p>  <strong>Andrew</strong> : Seg√∫n tengo entendido, su idioma estar√° seguro con respecto al uso de la memoria.  ¬øAlguna vez has pensado en implementar algo como el comprobador de pr√©stamos de Rust?  Lo miraste, ¬øc√≥mo te gustaba? </p><br><p>  <strong>Cliff</strong> : Bueno, he estado escribiendo C durante a√±os, con todos estos malloc y gratis, y administro manualmente la vida.  Ya sabes, el 90-95% de un tiempo de vida administrado manualmente tiene la misma estructura.  Y es muy, muy doloroso hacer esto manualmente.  Me gustar√≠a que el compilador simplemente dijera lo que est√° sucediendo all√≠ y lo que logr√≥ con sus acciones.  Para algunas cosas, un corrector de pr√©stamos lo hace fuera de la caja.  Y deber√≠a mostrar informaci√≥n autom√°ticamente, entender todo y ni siquiera cargarme para expresar esta comprensi√≥n.  Deber√≠a hacer al menos un an√°lisis de escape local, y solo si no tiene √©xito, entonces debe agregar anotaciones de tipo que describir√°n el tiempo de vida, y dicho esquema es mucho m√°s complicado que un comprobador de pr√©stamos o cualquier comprobador de memoria existente.  La elecci√≥n entre "todo est√° en orden" y "No entend√≠ nada" - no, debe haber algo mejor. <br>  Entonces, como persona que escribi√≥ mucho c√≥digo C, creo que tener el soporte para el control autom√°tico de por vida es lo m√°s importante.  Y me cans√© de cu√°nto Java usa la memoria y la queja principal est√° en GC.  Al asignar memoria en Java, no devolver√° la memoria que era local en el √∫ltimo bucle del GC.  En idiomas con administraci√≥n de memoria m√°s precisa, esto no es as√≠.  Si llamas a malloc, inmediatamente obtienes la memoria que generalmente se usaba.  Por lo general, hace algunas cosas temporales con su memoria e inmediatamente la recupera.  E inmediatamente regresa a la piscina de malloc, y el siguiente ciclo de malloc la saca de nuevo.  Por lo tanto, el uso de memoria real se reduce a un conjunto de objetos vivos en un punto particular en el tiempo, adem√°s de fugas.  Y si todo no fluye de manera indecente, la mayor parte de la memoria se deposita en cach√©s y en el procesador, y funciona r√°pidamente.  Pero requiere una gran cantidad de administraci√≥n de memoria manual con malloc y gratis, llamado en el orden correcto, en el lugar correcto.  El √≥xido en s√≠ mismo puede manejar esto correctamente y, en muchos casos, ofrece un rendimiento a√∫n mayor, ya que el consumo de memoria se reduce solo a los c√°lculos actuales, en lugar de esperar al pr√≥ximo ciclo de GC para liberar memoria.  Como resultado, obtuvimos una forma muy interesante de mejorar el rendimiento.  Y bastante poderoso, en el sentido, hice esas cosas al procesar datos para el fintech, y esto me permiti√≥ acelerar cinco veces.  Esta es una aceleraci√≥n bastante grande, especialmente en un mundo donde los procesadores no son cada vez m√°s r√°pidos, y todos seguimos esperando mejoras. </p><br><h1 id="karera-performans-inzhenera">  Carrera de ingeniero de rendimiento </h1><br><p>  <strong>Andrew</strong> : Tambi√©n me gustar√≠a preguntar sobre la carrera en general.  Te hiciste famoso por trabajar en JIT en HotSpot y luego mudarte a Azul, y esta tambi√©n es una empresa JVM.  Pero ya estaban involucrados en m√°s hierro que software.  Y de repente se cambi√≥ a Big Data y Machine Learning, y luego a detecci√≥n de fraude.  Como sucedio  Estas son √°reas muy diferentes de desarrollo. </p><br><p>  <strong>Cliff</strong> : He estado programando durante bastante tiempo y logr√© registrarme en clases muy diferentes.  Y cuando la gente dice: "¬°Oh, t√∫ eres el que hizo JIT para Java!", Siempre es divertido.  Pero antes de eso, particip√© en el clon PostScript, el lenguaje que Apple alguna vez us√≥ para sus impresoras l√°ser.  Y antes de eso hizo la implementaci√≥n del lenguaje Forth.  Creo que el tema com√∫n para m√≠ es el desarrollo de herramientas.  Toda mi vida he estado haciendo herramientas con las que otras personas escriben sus programas geniales.  Pero tambi√©n particip√© en el desarrollo de sistemas operativos, controladores, depuradores a nivel de n√∫cleo, lenguajes para desarrollar el sistema operativo, que comenz√≥ de manera trivial, pero con el tiempo todo se volvi√≥ complicado y complicado.  Pero el tema principal, sin embargo, es el desarrollo de herramientas.  Una gran parte de la vida pas√≥ entre Azul y Sun, y se trataba de Java.  Pero cuando comenc√© Big Data y Machine Learning, me puse el sombrero de nuevo y dije: "Ah, y ahora tenemos un problema no trivial, y aqu√≠ suceden muchas cosas interesantes y personas que hacen algo".  Este es un gran camino de desarrollo que vale la pena tomar. </p><br><p>  S√≠, realmente me gusta la inform√°tica distribuida.  Mi primer trabajo fue como estudiante en C, en un proyecto publicitario.  Estos fueron distribuidos computaci√≥n en chips Zilog Z80, que recopilaron datos para el reconocimiento de texto √≥ptico anal√≥gico producido por un analizador anal√≥gico real.  Fue un tema genial y totalmente anormal.  Pero hubo problemas, una parte no se reconoci√≥ correctamente, por lo que era necesario obtener una imagen y mostr√°rsela a una persona que ya le√≠a con los ojos e informaba lo que se dec√≠a all√≠, y por lo tanto, hab√≠a falsificadores de datos, y este trabajo ten√≠a su propio idioma. .  Hubo un back-end que manej√≥ todo esto, funcionando en paralelo al Z80 con terminales vt100 en ejecuci√≥n, uno por persona, y hab√≠a un modelo de programaci√≥n paralela en el Z80.  Cierta pieza de memoria com√∫n compartida por todos los Z80 dentro de una configuraci√≥n en estrella;  se comparti√≥ el plano posterior, y la mitad de la RAM se comparti√≥ dentro de la red, y otra mitad era privada o se gastaba en otra cosa.  Un sistema distribuido paralelo significativamente complejo con memoria compartida ... semi-compartida.  Cuando era ... Ya no lo recuerdo, en alg√∫n lugar a mediados de los 80.  Hace bastante tiempo <br>  S√≠, asumiremos que 30 a√±os es bastante tiempo. Las tareas asociadas con la inform√°tica distribuida han existido durante mucho tiempo, la gente ha luchado durante mucho tiempo con los cl√∫steres de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Beowulf</a> .  Tales cl√∫steres se parecen a ... Por ejemplo: hay Ethernet y su x86 r√°pido est√° conectado a esta Ethernet, y ahora desea obtener una memoria compartida falsa, porque nadie pod√≠a codificar la inform√°tica distribuida, era demasiado complicado y, por lo tanto, era una memoria compartida falsa con protecci√≥n p√°ginas de memoria x86, y si escribiste en esta p√°gina, les dijimos a los otros procesadores que si ten√≠an acceso a la misma memoria compartida, tendr√≠an que descargarse de ti, y por lo tanto apareci√≥ algo as√≠ como un protocolo de soporte de coherencia de cach√© y software para esto.  Concepto interesante  El verdadero problema, por supuesto, era diferente.  Todo esto funcion√≥, pero r√°pidamente tuvo problemas de rendimiento, porque nadie entend√≠a los modelos de rendimiento a un nivel suficientemente bueno: qu√© patrones de acceso a la memoria existen, c√≥mo asegurarse de que los nodos no se hagan ping interminablemente, y as√≠ sucesivamente. </p><br><p>  En H2O, se me ocurri√≥ esto: los propios desarrolladores son responsables de determinar d√≥nde est√° oculto el paralelismo y d√≥nde no.  Se me ocurri√≥ un modelo de codificaci√≥n tal que escribir c√≥digo de alto rendimiento fue f√°cil y simple.  Pero escribir c√≥digo de ejecuci√≥n lenta es dif√≠cil, se ver√° mal.  Debe intentar seriamente escribir c√≥digo lento, debe utilizar m√©todos no est√°ndar.  El c√≥digo de frenado es visible de un vistazo.  Como resultado, generalmente se escribe un c√≥digo que funciona r√°pidamente, pero debe averiguar qu√© hacer en el caso de la memoria compartida.  Todo esto est√° vinculado a grandes matrices y el comportamiento all√≠ es similar a las grandes matrices no vol√°tiles en Java paralelo.  Quiero decir, imagina que dos hilos escriben en una matriz paralela, uno de ellos gana, y el otro, respectivamente, pierde, y no sabes cu√°l de ellos es qui√©n.  Si no son vol√°tiles, entonces el orden puede ser cualquier cosa, y realmente funciona bien.  Las personas realmente se preocupan por el orden de las operaciones, establecen vol√°tiles correctamente y esperan problemas de memoria en los lugares correctos.  De lo contrario, simplemente escribir√≠an el c√≥digo en forma de ciclos de 1 a N, donde N son algunos billones, con la esperanza de que todos los casos complejos se vuelvan paralelos autom√°ticamente, y esto no funciona all√≠.  Pero en H2O esto no es Java ni Scala, puede considerarlo "Java menos menos" si lo desea.  Este es un estilo de programaci√≥n muy comprensible y es similar a escribir c√≥digo C o Java simple con bucles y matrices.  Pero al mismo tiempo, la memoria puede procesarse con terabytes.  Todav√≠a uso H2O.        ‚Äì        ,     .    Big Data   ,    H2O. </p><br><h1 id="tehnicheskie-chellenzhi">   </h1><br><p> <strong></strong> :          ? </p><br><p> <strong></strong> :        ?   ,    ‚Äì  . <br>    .    .    ,     ,     ,      ,  .     Sun,   ,    ,      ,       .      ,      ,   .     ,   C1,      ,    ‚Äì      .                   ,         . ,         x86-    ,    ,      5-10    ,       50 . </p><br><p>  ,       ,        ,        ,    C.  , ,   - ,   C  .       C,       C    .   ,    ,     C,      - ‚Ä¶    ,      .     ,      .     ,           ,     .      ,    ,        5% .          -    ‚Äì     ,         ¬´     ¬ª,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,    .     :               ,  ,    .     .  ,     ‚Äì    ,       .    ,        .       -  ‚Äì    .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   ,    (   ,   ),  ,     ,       .       ,    ,     ,      . </p><br><p>   , ,    ,  ,     ,       ,   .    ,   ,        ,   -   .     ,     ,     ,          .    ,      ,       ,  ,    . ,     :     ,           . ,   ,  - : ,   ,   -   ,    .      ‚Äì  , ,    ‚Äì   ! ‚Äì     ,      .       Java. Java    ,         ,   ,   ,       ‚Äì   ,       ¬´  ¬ª.           , ,   .            ,   Java  C    .    ‚Äì      Java,       C   ,   ,    ,   . ,    ‚Äì  ,      .    ,  .    ,    ,       .     :      . </p><br><h1 id="nemnogo-pro-allokaciyu-registrov-i-mnogoyadernost">       </h1><br><p> <strong></strong> :      -   . ,   ,  -   ,     ? </p><br><p> <strong></strong> : !   ‚Äì  ,     NP-     - .        , ?   . , Ahead of Time  ‚Äì    .     -  .   ,       ,       ‚Äì   ,      !   ‚Äì  ,   .       ,      ,    .    .   ?    ,       : ,   ,   -  !  -  ,             .   .     ,       ,       .      : - , - .        ,      ,   .  ,     ,  ,      ,     - .    !      ,     ,  ,   ‚Äì        .    .      NP- . </p><br><p> <strong></strong> :  ,       ‚Äì    . ,   ,   ,   ,     ‚Ä¶ </p><br><p> <strong></strong> :     .       ¬´¬ª.       .   ,     .        ‚Äì  ,  ,  ,             ( , ).   ,  -  .    ,   ,   ,        . , ,   .            ,     .   ,             ,     .     ,   ,   .          ,     ,  -       ,     ‚Äì .      ‚Äì              . ,     GC,    , ,  ,     ‚Äì  ,     .    ,  .              ,     ,         . ,   ‚Äì    , ?       ,       . </p><br><p> <strong></strong> :     ,    ?   ? </p><br><p> <strong></strong> :  GPU ,   ! </p><br><p> <strong></strong> :   .      ? </p><br><p> <strong></strong> : ,   - Azul.     ,      .      .   H2O  ,       .     ,    GPU.            ? ,     Azul,  :   ‚Äì  . </p><br><h1 id="samyy-bolshoy-chellenzh-v-zhizni">      </h1><br><p> <strong></strong> :    ? </p><br><p> <strong></strong> :      ,   ‚Ä¶     .   ,       . ,    ,    ,   ,             .   ,   ,    . ,   Java   C1  C2 ‚Äì   . ,   Java        ‚Äì   . ,      ,    ‚Äì    .       ‚Ä¶   . - ,      Sun,  ‚Ä¶ ,   ,        .     ,           .  ,        .       ‚Ä¶        ‚Ä¶  ,        .   , , .       .     - ,      :   .  , , ,   ,  ,    ,     .   ,        .          .      ,    . ¬´    ,   ,   ¬ª.   : ¬´!¬ª.    ,  , , : ,           . </p><br><p>  ‚Äì    ,    ,       ,     .      .      ,        ,            ,  ,    .  ,      Java JIT,  C2.       ,  ‚Äì         .       ,   ‚Äì   !    .  ,   ,  ,     ,    ,       ,    .        .    .        ,   . ,      ,       ,      ,        :      ,     ,     .   ,           ‚Äì      .       ,     ,      -   .     : ¬´     ?¬ª.  ,          .      ,     ,      : ,    ,        ‚Äì     ?       ,  .  ,   ,  ,  ,         ,    ,     - . </p><br><p> <strong></strong> :         ,    -.     ? </p><br><p> <strong></strong> : ,     ,       .      ‚Äì   .      . ,    .        .          .   :    ,   ,   - ‚Äì          .      .  ,       ,      ‚Äì   ,       . ,    ,    ,          ,  -  ,        .       ,       .       ,       ,     - .   ,    ,     ‚Äì   ,  . <br>       ,    .   ,    ‚Äì   ,   ,    .  ,   .     ,       ‚Äì   .     ,       .   ,     ,     ¬´  ¬ª,      ,  ‚Äì   ,   ,       ,     ,        .     ,  ,    ¬´  ¬ª. </p><br><p>       .   .   - ,      ,        ¬´¬ª:    ,    ‚Äì .  ‚Äì     .         ,  ,    . ¬´,     -,     ,    ¬ª.       ,     : ,  .  ,     ,     .  .   ‚Äì ,     . , ?  ,     ?    ? ,          ?        .       ,  .    ‚Äì   .     .  ,     .     ‚Äì    ‚Äì  ,        .        ,   ¬´ ¬ª   .    : ¬´--¬ª,  : ¬´, !¬ª   .   .   ,       ,   ,    ,        .     ,      .        ,         .    ,         ‚Äì      ,    .    ‚Äì   ,            .      ,    ,   ,   . </p><br><p> ,           ‚Äì   , .          ,        , .    ,   .         ,    ,    ,    ,      .        ,      ,       . ,       ,      ,          ,      .          .     ,      ,     ,      .    ,     ,    ,        ,    .      , ,    ,   .   ,       ‚Äì  , ,    ,      .     ,     . </p><br><p> <strong></strong> :  ‚Ä¶ . ,          .          .   Hydra! </p><br><blockquote>         Hydra 2019,   11-12  2019   -.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´The Azul Hardware Transactional Memory experience¬ª</a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458718/">https://habr.com/ru/post/458718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458704/index.html">Implementaci√≥n de un sistema DLP en el ejemplo del comercio minorista</a></li>
<li><a href="../458706/index.html">Los gopniks est√°n ahora en los mercados extranjeros, o "¬øPor qu√© es tan dif√≠cil encontrar un programador normal?"</a></li>
<li><a href="../458708/index.html">¬øQuiere <s> perder peso </s> para aprender TI por su cuenta? Preguntame como</a></li>
<li><a href="../458710/index.html">Ofuscador de espacio en blanco para PHP</a></li>
<li><a href="../458716/index.html">Primer vistazo a los UPS Delta Amplon RT</a></li>
<li><a href="../458720/index.html">La escuela de programadores hh.ru por d√©cima vez abre un conjunto de especialistas en TI</a></li>
<li><a href="../458724/index.html">Redes neuronales y aprendizaje profundo, cap√≠tulo 3, parte 1: mejorar la forma en que se entrenan las redes neuronales</a></li>
<li><a href="../458726/index.html">Habr Special // Podcast con el autor de Invasion. Una breve historia de los hackers rusos</a></li>
<li><a href="../458728/index.html">¬øQu√© son las bicicletas el√©ctricas (revisi√≥n grupal de cinco modelos de dos fabricantes), parte 2</a></li>
<li><a href="../458730/index.html">Combatir la complejidad en el desarrollo de software.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>