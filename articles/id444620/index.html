<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ŒğŸ» ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¾ ğŸ‘ŒğŸ¾ Menggunakan File Urutan Kernel Linux ğŸ‘ˆğŸ» ğŸ‘ƒ ğŸ‘¶ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fitur karakteristik pemrograman modern adalah penggunaan jaringan global sebagai sumber informasi referensi, khususnya, sumber pola untuk memecahkan m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan File Urutan Kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444620/"> Fitur karakteristik pemrograman modern adalah penggunaan jaringan global sebagai sumber informasi referensi, khususnya, sumber pola untuk memecahkan masalah yang tidak diketahui atau sedikit diketahui untuk programmer tertentu.  Pendekatan semacam ini menghemat banyak waktu dan seringkali memberikan hasil yang cukup kualitatif.  Namun, solusi yang dituangkan dalam jaringan meskipun biasanya benar, tidak selalu memperhitungkan semua seluk-beluk penyelesaian masalah, yang mengarah pada penampilan dalam kode sumber bagian yang biasanya bekerja dengan benar, tetapi dalam keadaan yang tidak cukup standar menjadi sumber kejutan yang tidak menyenangkan. <br><br>  Pertimbangkan topik menggunakan file urutan dalam kernel Linux, file tersebut dianggap sebagai mekanisme yang paling nyaman untuk mencetak dari mode kernel.  Namun dalam praktiknya, menggunakannya dengan benar jauh lebih sulit daripada yang Anda kira. <br><br>  Banyak materi tentang topik ini tersedia online.  Yang terbaik adalah kode sumber dari kernel itu sendiri yang memiliki komentar yang cukup rinci.  Masalah dengan sumber informasi ini adalah volumenya.  Jika Anda tidak tahu persis apa yang harus dicari, lebih baik jika Anda hanya memiliki waktu terbatas, jangan mencoba sama sekali.  Bagi saya, ketika saya menjadi tertarik dengan topik ini, Google memberikan beberapa sumber informasi yang tampaknya sangat baik berkaitan dengan pencarian saya: buku terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Pemrograman Modul Kernel Linux</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel oleh Rob Day</a> .  Sumber-sumber ini tidak baru, tetapi sangat solid. <br><a name="habracut"></a><br>  Pertama-tama mari kita pertimbangkan secara lebih rinci kapan wajar menggunakan file urutan.  Situasi yang paling umum adalah membuat file Anda sendiri di sistem file / proc.  Dengan membaca file dari sistem ini, Anda bisa mendapatkan berbagai informasi tentang peralatan yang digunakan, drivernya, RAM, proses, dll. <br><br>  Tampaknya cetakan apa pun adalah tugas paling sederhana dalam pemrograman.  Tetapi bekerja dalam mode kernel OS memaksakan banyak pembatasan yang mungkin tampak benar-benar tak terbayangkan bagi pengembang perangkat lunak aplikasi.  Dalam mode kernel, ukuran buffer cetak dibatasi oleh ukuran halaman memori virtual.  Untuk arsitektur x86 itu adalah empat kilobyte.  Oleh karena itu, program yang baik saat mencetak data dalam jumlah besar pertama-tama harus mencapai pengisian buffer secara maksimal, lalu mencetaknya, dan kemudian mengulangi iterasi ini hingga data untuk pencetakan benar-benar habis.  Anda tentu saja dapat mencetak karakter demi karakter, yang akan sangat menyederhanakan segalanya, tetapi kita berbicara tentang program yang bagus. <br><br>  Sumber yang disebutkan di atas sedikit lebih buruk dari yang diharapkan.  Dalam buku itu misalnya, beberapa informasi ternyata secara umum tidak benar dan itulah yang mendorong saya untuk menulis catatan ini.  Adalah umum untuk mempertimbangkan bahwa informasi yang diberikan dalam bentuk skema-gambar adalah yang paling mudah untuk dipahami dan digunakan.  Namun dalam buku ini gambar yang berhubungan dengan subjek tidak benar.  Menggunakan skema semacam itu dapat menyebabkan kesalahan serius, meskipun contoh dalam buku ini berfungsi dengan benar dan mengikuti skema ini.  Ini disebabkan oleh fakta bahwa dalam contoh ini, hanya beberapa byte yang dicetak pada saat / proc / iter diakses.  Jika Anda menggunakannya sebagai templat untuk mencetak teks yang lebih besar dari satu halaman memori, akan ada kejutan.  Seri artikel yang disebutkan di atas tidak mengandung kesalahan yang jelas, tetapi tidak melaporkan beberapa detail yang penting untuk memahami topik tersebut. <br><br>  Jadi, pertama mari kita pertimbangkan skema yang benar tentang cara bekerja dengan file urutan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0t/9q/lf/0t9qlfqbhu3y7x1abgwo-uc4tmu.png"></div><br><br>  Untuk bekerja dengan file seperti itu, Anda harus membuat fungsi start (), stop (), next () dan show ().  Nama-nama fungsi ini dapat berupa apa saja, saya memilih kata-kata terpendek yang sesuai dengan makna dengan tindakan fungsi.  Ketika fungsi-fungsi tersebut hadir dan terhubung dengan benar ke sistem kernel, mereka mulai bekerja secara otomatis ketika mengakses file yang terkait dengannya di direktori / proc.  Yang paling membingungkan adalah penggunaan fungsi stop (), yang dapat dipanggil dalam tiga konteks berbeda.  Memanggilnya setelah mulai () berarti mengakhiri pekerjaan cetak.  Memanggilnya setelah show () berarti bahwa operasi cetak terakhir ke buffer (biasanya fungsi seq_printf digunakan untuk ini) meluap buffer halaman dan operasi cetak ini dibatalkan.  Panggilannya setelah next () adalah kasus paling menarik yang terjadi saat mencetak beberapa data ke buffer berakhir dan Anda harus menyelesaikan pekerjaan atau menggunakan data baru.  Sebagai contoh, misalkan file kita di direktori / proc, ketika mengaksesnya, pertama menghasilkan beberapa informasi tentang perangkat blok, dan kemudian pada karakter.  Pertama, fungsi start () menginisialisasi pencetakan untuk perangkat blok, dan berikutnya () dan, mungkin, fungsi show () menggunakan data inisialisasi ini untuk mencetak informasi langkah-demi-langkah tentang perangkat blok.  Ketika semuanya sudah siap, setelah panggilan terakhir ke berikutnya (), panggilan untuk berhenti () akan dibuat, setelah itu mulai () dipanggil, yang kali ini sudah harus memulai pencetakan lebih lanjut untuk perangkat karakter. <br><br>  Saya memberikan contoh yang sedikit dimodifikasi (isi file evens.c) dari artikel oleh Rob Day.  Saya harus mengganti panggilan fungsi, yang tidak ada di kernel modern dengan padanan sebenarnya.  Komentarnya juga sedikit berubah. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/moduleparam.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/proc_fs.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/seq_file.h&gt; #include &lt;linux/slab.h&gt; static int limit = 10; //default value, it can be changed here or module_param(limit, int, S_IRUGO); //transfered as a module parameter static int* even_ptr; //we will work with dynamic memory /** * start */ static void *ct_seq_start(struct seq_file *s, loff_t *pos) { printk(KERN_INFO "Entering start(), pos = %Ld, seq-file pos = %lu.\n", *pos, s-&gt;count); if (*pos &gt;= limit) { // are we done? printk(KERN_INFO "Apparently, we're done.\n"); return NULL; } //Allocate an integer to hold our increasing even value even_ptr = kmalloc(sizeof(int), GFP_KERNEL); if (!even_ptr) // fatal kernel allocation error return NULL; printk(KERN_INFO "In start(), even_ptr = %pX.\n", even_ptr); *even_ptr = (*pos)*2; return even_ptr; } /** * show */ static int ct_seq_show(struct seq_file *s, void *v) { printk(KERN_INFO "In show(), even = %d.\n", *(int*)v); seq_printf(s, "The current value of the even number is %d\n", *(int*)v); return 0; } /** * next */ static void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos) { printk(KERN_INFO "In next(), v = %pX, pos = %Ld, seq-file pos = %lu.\n", v, *pos, s-&gt;count); (*pos)++; //increase my position counter if (*pos &gt;= limit) //are we done? return NULL; *(int*)v += 2; //to the next even value return v; } /** * stop */ static void ct_seq_stop(struct seq_file *s, void *v) { printk(KERN_INFO "Entering stop().\n"); if (v) printk(KERN_INFO "v is %pX.\n", v); else printk(KERN_INFO "v is null.\n"); printk(KERN_INFO "In stop(), even_ptr = %pX.\n", even_ptr); if (even_ptr) { printk(KERN_INFO "Freeing and clearing even_ptr.\n"); kfree(even_ptr); even_ptr = NULL; } else printk(KERN_INFO "even_ptr is already null.\n"); } /** * This structure gathers functions which control the sequential reading */ static struct seq_operations ct_seq_ops = { .start = ct_seq_start, .next = ct_seq_next, .stop = ct_seq_stop, .show = ct_seq_show }; /** * This function is called when a file from /proc is opened */ static int ct_open(struct inode *inode, struct file *file) { return seq_open(file, &amp;ct_seq_ops); }; /** * This structure gathers functions for a /proc-file operations */ static struct file_operations ct_file_ops = { .owner = THIS_MODULE, .open = ct_open, .read = seq_read, .llseek = seq_lseek, .release = seq_release }; /** * This function is called when this module is loaded into the kernel */ static int __init ct_init(void) { proc_create("evens", 0, NULL, &amp;ct_file_ops); return 0; } /** * This function is called when this module is removed from the kernel */ static void __exit ct_exit(void) { remove_proc_entry("evens", NULL); } module_init(ct_init); module_exit(ct_exit); MODULE_LICENSE("GPL");</span></span></span></span></code> </pre> <br><br>  Fungsi untuk bekerja dengan file urutan menggunakan dua petunjuk dengan fungsi yang tumpang tindih (ini juga agak membingungkan).  Salah satunya harus menunjuk ke objek saat ini untuk dicetak ke buffer oleh show () - itu adalah `v'-pointer dalam program.  Pointer lain `pos 'biasanya digunakan untuk menunjuk ke counter. <br><br>  Bagi mereka yang mungkin baru pertama kali ingin menjalankan program mereka dalam mode kernel, saya memberikan contoh Makefile untuk build yang berhasil.  Tentu saja, untuk membangun yang sukses, Anda harus memiliki header sumber kernel Linux di sistem. <br><br><pre> <code class="plaintext hljs">obj-m += evens.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</code> </pre><br><br>  Menghubungkan ke kernel dilakukan dengan perintah <code>sudo insmod evens.ko</code> , memeriksa fungsi file / proc / evens, yang muncul setelah ini, dengan perintah <code>cat /proc/evens</code> , membaca log peristiwa yang menjelaskan operasi sistem dengan perintah <code>sudo cat /var/log/messages</code> . <br><br>  Untuk melimpah buffer halaman, atur parameter batas ke nilai yang lebih besar, misalnya, 200. Nilai ini dapat dimasukkan ke dalam teks program atau digunakan saat memuat modul dengan perintah <code>sudo insmod events.ko limit=200</code> . <br><br>  Analisis log dapat menjelaskan poin-poin tidak jelas yang tersisa.  Sebagai contoh, Anda mungkin memperhatikan bahwa sebelum memanggil stop () setelah next () atau start (), sistem nol variabel `v '.  Anda juga dapat memperhatikan bahwa sebelum memanggil start () setelah stop (), sistem mencetak isi buffer. <br><br>  Saya akan berterima kasih jika seseorang melaporkan ketidakakuratan yang ditemukan dalam catatan saya atau apa pun yang harus disebutkan. <br><br>  Kode sumber juga tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444620/">https://habr.com/ru/post/id444620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444602/index.html">Enkapsulasi dalam C ++ dan C</a></li>
<li><a href="../id444610/index.html">Statistik dan pemantauan skrip PHP secara real time. ClickHouse dan Grafana pergi untuk membantu Pinba</a></li>
<li><a href="../id444612/index.html">Kerugian makro untuk kode C ++</a></li>
<li><a href="../id444614/index.html">Seluruh sejarah Linux. Bagian II: pasang surut perusahaan</a></li>
<li><a href="../id444616/index.html">Membuat Perekam Suara Android Anda Sendiri Menggunakan Kotlin</a></li>
<li><a href="../id444622/index.html">Paket R tidyr dan fungsi pivot_longer dan pivot_wider yang baru</a></li>
<li><a href="../id444624/index.html">Mobil listrik terbakar dan mandi</a></li>
<li><a href="../id444630/index.html">Meja informasi: inisiatif Internet global</a></li>
<li><a href="../id444634/index.html">Epic Games memberi pengembang $ 100 juta</a></li>
<li><a href="../id444636/index.html">Mengapa saya tidak dapat tumbuh demi uang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>