<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸï¸ ğŸš¡ ğŸ‘©ğŸ¼â€ğŸ¤ Buku Panduan Aplikasi Arsitektur Cloud ğŸ¤¦ğŸ¾ ğŸ˜ ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Panduan ini panduan desain terstruktur untuk aplikasi cloud yang skalabel, ulet, dan mudah diakses. Ini dirancang untuk membantu Anda membuat keputusa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku Panduan Aplikasi Arsitektur Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423179/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img align="left" width="250" src="https://habrastorage.org/webt/zk/ns/pq/zknspqark8ose3vto4iom_kbdaq.jpeg"></a>  Panduan ini panduan desain terstruktur untuk aplikasi cloud yang skalabel, ulet, dan mudah diakses.  Ini dirancang untuk membantu Anda membuat keputusan tentang arsitektur Anda, apa pun platform cloud yang Anda gunakan. <br><br>  Manual ini disusun sebagai urutan langkah - memilih arsitektur â†’ memilih teknologi untuk menghitung dan menyimpan data â†’ merancang aplikasi Azure â†’ memilih template â†’ memeriksa arsitektur.  Untuk masing-masing dari mereka, ada rekomendasi yang akan membantu Anda dalam mengembangkan arsitektur aplikasi. <br><a name="habracut"></a><br><br>  Hari ini kami menerbitkan bagian dari bab pertama buku ini.  Anda dapat mengunduh versi lengkapnya secara gratis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><hr><br><h2>  Daftar isi </h2><br><ul><li>  Pilihan arsitektur - 1; </li><li>  Pilihan teknologi untuk komputasi dan menyimpan data - 35; </li><li>  Merancang aplikasi Azure: prinsip-prinsip desain - 60; </li><li>  Merancang aplikasi Azure: indikator kualitas - 95; </li><li>  Merancang aplikasi Azure: pola desain - 103; </li><li>  Direktori Templat - 110; </li><li>  Daftar Periksa Validasi Arsitektur - 263; </li><li>  Kesimpulan - 291; </li><li>  Arsitektur Referensi Azure - 292; </li></ul><br><h2>  Pilihan arsitektur </h2><br>  Keputusan pertama yang perlu Anda buat saat merancang aplikasi cloud adalah memilih arsitektur.  Pilihan arsitektur tergantung pada kompleksitas aplikasi, ruang lingkup, jenisnya (IaaS atau PaaS) dan tugas yang dimaksudkan.  Penting juga untuk mempertimbangkan keterampilan tim pengembangan dan manajer proyek, serta ketersediaan arsitektur yang sudah jadi untuk aplikasi tersebut. <br><br>  Pilihan arsitektur memberlakukan batasan tertentu pada struktur aplikasi, membatasi pilihan teknologi dan elemen aplikasi lainnya.  Batasan ini dikaitkan dengan kelebihan dan kekurangan dari arsitektur yang dipilih. <br><br>  Informasi di bagian ini akan membantu Anda menemukan keseimbangan di antara mereka ketika menerapkan arsitektur tertentu.  Bagian ini mencantumkan sepuluh prinsip desain yang perlu diingat.  Mengikuti prinsip-prinsip ini akan membantu Anda membuat aplikasi yang lebih skalabel, tangguh, dan mudah dikelola. <br><br>  Kami telah mengidentifikasi serangkaian opsi arsitektur yang biasanya digunakan dalam aplikasi cloud.  Bagian yang didedikasikan untuk masing-masing berisi: <br><br><ul><li>  deskripsi dan logika arsitektur; </li><li>  rekomendasi tentang ruang lingkup arsitektur ini; </li><li>  keuntungan, kerugian dan rekomendasi untuk digunakan; </li><li>  Opsi penyebaran yang disarankan menggunakan layanan Azure yang sesuai. </li></ul><br><h4>  Tinjauan Arsitektur </h4><br>  Bagian ini memberikan tinjauan singkat tentang opsi arsitektur yang telah kami identifikasi, serta rekomendasi umum untuk penggunaannya.  Anda dapat menemukan informasi lebih rinci di bagian terkait yang tersedia melalui tautan. <br><br><h4>  Tingkat-N </h4><br>  Arsitektur N-tier paling umum digunakan dalam aplikasi perusahaan.  Untuk mengelola dependensi, aplikasi dibagi menjadi beberapa lapisan, yang masing-masing bertanggung jawab atas fungsi logis tertentu, misalnya untuk penyajian data, logika bisnis, atau akses ke data.  Sebuah layer dapat memanggil layer lain di bawah ini.  Namun, pembagian seperti itu menjadi lapisan horisontal dapat menyebabkan kesulitan tambahan.  Misalnya, mungkin sulit untuk melakukan perubahan pada satu bagian aplikasi tanpa mempengaruhi elemen lainnya.  Oleh karena itu, memperbarui aplikasi seperti itu seringkali tidak mudah, dan pengembang harus menambahkan fitur baru lebih jarang. <br><br>  Arsitektur N-tier adalah pilihan alami ketika mentransfer aplikasi yang sudah digunakan yang dibangun berdasarkan arsitektur tier.  Oleh karena itu, arsitektur ini paling sering digunakan dalam solusi IaaS (infrastruktur sebagai layanan) atau dalam aplikasi yang menggabungkan IaaS dengan layanan terkelola. <br><br><img src="https://habrastorage.org/webt/at/qq/rq/atqqrqyydelrti2zaumzbdxjxxo.png"><br><br><h4>  Antarmuka Web - Antrian - Peran Pekerja </h4><br>  Untuk solusi PaaS, arsitektur web-interface-queue-work-role cocok.  Dengan arsitektur ini, aplikasi memiliki antarmuka web yang memproses permintaan HTTP, dan peran kerja server yang bertanggung jawab untuk operasi yang membutuhkan waktu lama atau menuntut sumber daya komputasi.  Antrian pesan asinkron digunakan untuk berkomunikasi antara antarmuka dan peran kerja server. <br><br>  Arsitektur "antarmuka web - antrian - peran kerja" cocok untuk tugas yang relatif sederhana yang memerlukan sumber daya komputasi.  Seperti arsitektur N-tier, model ini mudah dimengerti.  Menggunakan layanan terkelola menyederhanakan penerapan dan pengoperasian.  Tetapi ketika membuat aplikasi untuk area subjek yang kompleks, mungkin sulit untuk mengontrol dependensi.  Antarmuka web dan peran kerja dapat dengan mudah diperluas ke komponen monolitik besar yang sulit untuk dipertahankan dan diperbarui.  Seperti halnya arsitektur N-tier, model ini ditandai dengan tingkat pembaruan yang lebih rendah dan peluang peningkatan yang terbatas. <br><br><img src="https://habrastorage.org/webt/x2/1z/nr/x21znrgjcymzqtdu58fsl_ls4aa.png"><br><br><h4>  Layanan microser </h4><br>  Jika aplikasi ini dirancang untuk memecahkan masalah yang lebih kompleks, cobalah untuk mengimplementasikannya berdasarkan arsitektur layanan microsoft.  Aplikasi semacam itu terdiri dari banyak layanan independen kecil.  Setiap layanan bertanggung jawab atas fungsi bisnis yang terpisah.  Layanan secara longgar digabungkan dan menggunakan kontrak API untuk berinteraksi. <br><br>  Tim kecil pengembang dapat bekerja untuk menciptakan layanan terpisah.  Layanan dapat digunakan tanpa koordinasi yang kompleks antar pengembang, sehingga mudah untuk memperbaruinya secara berkala.  Arsitektur microservice lebih sulit untuk diimplementasikan dan dikelola daripada dua pendekatan sebelumnya.  Ini membutuhkan budaya manajemen pembangunan yang matang.  Tetapi jika semuanya diatur dengan benar, pendekatan ini membantu meningkatkan frekuensi rilis versi baru, mempercepat implementasi inovasi dan membuat arsitektur lebih toleran terhadap kesalahan. <br><br><img src="https://habrastorage.org/webt/xb/wq/v-/xbwqv-3-fq2yn_bdp-fq_de9-ie.png"><br><br><h4>  Cqrs </h4><br>  Arsitektur CQRS (Command and Query Responsibility Segregation, distribusi tanggung jawab antara tim dan pertanyaan) memungkinkan Anda untuk memisahkan operasi baca dan tulis antara masing-masing model.  Akibatnya, bagian dari sistem yang bertanggung jawab untuk mengubah data diisolasi dari bagian-bagian dari sistem yang bertanggung jawab untuk membaca data.  Selain itu, operasi baca dapat dilakukan dalam tampilan terwujud yang secara fisik terpisah dari database yang sedang ditulis.  Ini memungkinkan Anda untuk secara mandiri mengukur proses membaca dan menulis dan mengoptimalkan presentasi yang dibuat untuk eksekusi permintaan. <br><br>  Model CQRS paling baik digunakan untuk subsistem arsitektur yang lebih besar.  Secara umum, itu tidak boleh diterapkan ke seluruh aplikasi, karena ini tidak perlu mempersulit arsitekturnya.  Ini bekerja dengan baik dalam sistem kolaborasi, di mana sejumlah besar pengguna secara bersamaan bekerja dengan data yang sama. <br><br><img src="https://habrastorage.org/webt/dp/wb/xh/dpwbxh6upc37vxvmx7hdacfdboi.png"><br><br><h4>  Arsitektur Berbasis Acara </h4><br>  Arsitektur berbasis acara menggunakan model berlangganan-penerbitan di mana pemasok mempublikasikan acara dan konsumen berlangganan.  Pemasok tidak tergantung pada konsumen, dan konsumen tidak tergantung satu sama lain. <br><br>  Arsitektur berbasis peristiwa sangat cocok untuk aplikasi yang perlu menerima dan memproses data dalam jumlah besar dengan latensi rendah, seperti Internet of Things.  Selain itu, arsitektur seperti itu berfungsi dengan baik jika subsistem yang berbeda harus memproses data peristiwa yang sama secara berbeda. <br><br><img src="https://habrastorage.org/webt/hp/vf/mw/hpvfmw4c0gzltzrkhecwb4xl8hg.png"><br><br><h4>  Data besar, komputasi besar </h4><br>  Data besar dan komputasi besar adalah opsi arsitektur khusus yang digunakan untuk menyelesaikan masalah khusus.  Saat menggunakan arsitektur big data, kumpulan data besar dibagi menjadi beberapa fragmen, yang kemudian diproses secara paralel untuk keperluan analisis dan pelaporan.  Komputasi besar juga disebut komputasi kinerja tinggi (HPC).  Teknologi ini memungkinkan Anda untuk mendistribusikan komputasi di antara beberapa (ribuan) inti prosesor.  Arsitektur ini dapat digunakan untuk simulasi, render 3D dan tugas serupa lainnya. <br><br><h4>  Pilihan arsitektur sebagai batasan </h4><br>  Arsitektur bertindak sebagai kendala dalam merancang solusi, khususnya, ia menentukan elemen mana yang dapat digunakan dan koneksi mana di antara mereka yang mungkin.  Batasan mendefinisikan "bentuk" dari arsitektur dan memungkinkan Anda untuk membuat pilihan dari serangkaian opsi yang lebih sempit.  Jika batasan arsitektur yang dipilih terpenuhi, solusinya akan memiliki sifat karakteristik arsitektur ini. <br><br>  Sebagai contoh, layanan microsoft ditandai oleh pembatasan berikut: <br><br><ul><li>  setiap layanan bertanggung jawab atas fungsi yang terpisah; </li><li>  layanan tidak tergantung satu sama lain; </li><li>  Data hanya tersedia untuk layanan yang bertanggung jawab untuknya.  Layanan tidak bertukar data. </li></ul><br>  Mengikuti batasan-batasan ini mengarah pada penciptaan sistem di mana layanan dapat digunakan secara independen satu sama lain, kesalahan diisolasi, pembaruan sering dimungkinkan, dan teknologi baru mudah ditambahkan ke aplikasi. <br><br>  Sebelum memilih arsitektur, pastikan Anda memahami prinsip-prinsip dasar dan batasan terkait dengan baik.  Jika tidak, Anda bisa mendapatkan solusi yang sesuai dengan model arsitektur yang dipilih, tetapi tidak sepenuhnya mengungkapkan potensi model ini.  Akal sehat juga penting.  Terkadang lebih bijaksana untuk meninggalkan satu atau lain keterbatasan daripada berusaha untuk arsitektur yang bersih. <br><br>  Tabel berikut ini menunjukkan bagaimana manajemen ketergantungan diterapkan di masing-masing arsitekturnya, dan untuk tugas-tugas apa arsitektur ini atau itu paling cocok. <br><br><img src="https://habrastorage.org/webt/hg/ac/6t/hgac6towdl1iflxacojntx8-l4a.png"><br><br><h4>  Analisis kelebihan dan kekurangan </h4><br>  Keterbatasan menimbulkan kesulitan tambahan, jadi penting untuk memahami apa yang harus Anda korbankan ketika memilih satu atau beberapa opsi arsitektur, dan untuk dapat menjawab pertanyaan apakah kelebihan dari opsi yang dipilih lebih besar daripada kerugiannya untuk tugas tertentu dalam konteks tertentu. <br><br>  Di bawah ini adalah beberapa kelemahan yang perlu dipertimbangkan ketika memilih arsitektur: <br><br><ul><li>  <b>Kompleksitas</b>  Apakah penggunaan arsitektur kompleks dibenarkan untuk tugas Anda?  Dan sebaliknya, apakah arsitektur yang terlalu sederhana dipilih untuk tugas yang kompleks?  Dalam hal ini, Anda berisiko mendapatkan sistem tanpa struktur yang jelas, karena arsitektur yang digunakan tidak memungkinkan Anda untuk mengelola dependensi dengan benar. </li><li>  <b>Pesan tidak sinkron dan akhirnya konsistensi.</b>  Pesan asinkron membantu memisahkan layanan dan meningkatkan keandalan (berkat kemampuan untuk mengirim ulang pesan) dan skalabilitas.  Namun, itu menciptakan kesulitan tertentu, seperti semantik hanya satu transmisi dan masalah koherensi dalam jangka panjang. </li><li>  <b>Interaksi antar layanan.</b>  Jika Anda membagi aplikasi menjadi layanan yang terpisah, ada risiko bahwa pertukaran data antara layanan tersebut akan memakan waktu terlalu lama atau menyebabkan kemacetan jaringan (misalnya, ketika menggunakan layanan mikro). </li><li>  <b>Kelola.</b>  Seberapa sulitkah mengelola aplikasi, memantau pekerjaannya, menyebarkan pembaruan, dan melakukan tugas-tugas lain? </li></ul><br><h2>  Arsitektur N-tier </h2><br>  Dalam arsitektur N-tier, aplikasi dibagi menjadi lapisan logis dan lapisan fisik. <br><br><img src="https://habrastorage.org/webt/k0/qc/3z/k0qc3zf0bmj9w9zixiwr2e3fqkw.png"><br><br>  Lapisan adalah mekanisme untuk berbagi tanggung jawab dan mengelola dependensi.  Setiap lapisan memiliki bidang tanggung jawab masing-masing.  Lapisan tingkat yang lebih tinggi menggunakan layanan lapisan tingkat yang lebih rendah, tetapi tidak sebaliknya. <br><br>  Level-levelnya terpisah secara fisik dan bekerja pada komputer yang berbeda.  Satu tingkat dapat mengakses yang lain secara langsung atau menggunakan pesan asinkron (antrian pesan).  Meskipun setiap lapisan harus ditempatkan pada levelnya sendiri, ini tidak perlu.  Anda dapat menempatkan beberapa layer pada satu level.  Pemisahan fisik level membuat solusi tidak hanya lebih scalable dan toleran terhadap kesalahan, tetapi juga lebih lambat, karena jaringan sering digunakan untuk interaksi.  Aplikasi tiga tingkat tradisional terdiri dari tingkat presentasi, tingkat menengah, dan tingkat basis data.  Tingkat menengah adalah opsional.  Aplikasi yang lebih kompleks dapat terdiri dari lebih dari tiga level.  Diagram di atas menunjukkan aplikasi dengan dua tingkat menengah yang bertanggung jawab untuk berbagai bidang fungsional. <br><br>  Aplikasi N-tier mungkin memiliki arsitektur lapisan tertutup atau arsitektur lapisan terbuka. <br><br><ul><li>  Dalam arsitektur tertutup, lapisan sewenang-wenang hanya dapat mengakses lapisan bawah terdekat. </li><li>  Dalam arsitektur terbuka, lapisan sewenang-wenang dapat merujuk ke lapisan yang lebih rendah. </li></ul><br>  Arsitektur lapisan tertutup membatasi ketergantungan antar lapisan.  Namun, penggunaannya dapat secara berlebihan meningkatkan lalu lintas jaringan jika lapisan tertentu hanya meneruskan permintaan ke lapisan berikutnya. <br><br><h4>  Aplikasi Arsitektur </h4><br>  Arsitektur N-tier biasanya digunakan dalam aplikasi IaaS, di mana setiap tier berjalan pada set mesin virtual yang terpisah.  Namun, aplikasi N-tier tidak harus menjadi aplikasi IaaS murni.  Seringkali nyaman untuk menggunakan layanan terkelola untuk beberapa komponen solusi, terutama untuk caching, pengiriman pesan, dan penyimpanan data. <br><br>  Arsitektur N-tier direkomendasikan untuk digunakan dalam kasus berikut: <br><br><ul><li>  aplikasi web sederhana; </li><li>  Porting aplikasi lokal ke Azure dengan refactoring minimal </li><li>  penyebaran aplikasi lokal dan cloud yang konsisten. </li></ul><br>  Arsitektur N-tier adalah umum di antara aplikasi lokal biasa, sehingga sangat cocok untuk porting aplikasi yang sudah ada ke Azure. <br><br><h4>  Manfaatnya </h4><br><ul><li>  Kemampuan untuk mentransfer aplikasi antara penyebaran di tempat dan cloud, serta antara platform cloud. </li><li>  Kurang pelatihan untuk sebagian besar pengembang. </li><li>  Perpanjangan alami dari model aplikasi tradisional. </li><li>  Dukungan untuk lingkungan heterogen (Windows / Linux). </li></ul><br><h4>  Kekurangan </h4><br><ul><li>  Sangat mudah untuk mendapatkan aplikasi di mana tingkat menengah hanya melakukan operasi CRUD dalam database, meningkatkan waktu pemrosesan permintaan dan tidak membawa manfaat apa pun. </li><li>  Arsitektur monolitik tidak akan memungkinkan pengembangan komponen individu oleh tim pengembangan independen. </li><li>  Mengelola aplikasi IaaS lebih memakan waktu daripada aplikasi hanya layanan yang dikelola. </li><li>  Sulit untuk mengelola keamanan jaringan dalam sistem besar. </li></ul><br><h4>  Rekomendasi </h4><br><ul><li>  Gunakan penskalaan otomatis pada beban variabel.  Lihat Praktik Terbaik untuk Penskalaan Otomatis. </li><li>  Gunakan pesan tidak sinkron untuk memisahkan level satu sama lain. </li><li>  Tembolok data semi-statis.  Lihat Pertimbangan Caching. </li><li>  Pastikan ketersediaan tinggi tingkat database dengan solusi seperti Grup Ketersediaan Selalu di SQL Server. </li><li>  Instal firewall aplikasi web (WAF) antara antarmuka dan Internet. </li><li>  Tempatkan setiap level di subnet Anda sendiri;  gunakan subnet sebagai batas keamanan. </li><li>  Batasi akses ke tingkat data dengan hanya mengizinkan kueri dari tingkat menengah. </li></ul><br><h4>  Arsitektur mesin virtual N-tier </h4><br>  Bagian ini memberikan pedoman untuk membangun arsitektur N-tier menggunakan mesin virtual. <br><br><img src="https://habrastorage.org/webt/lt/wy/90/ltwy90ykt4cyungzwsk1cunzc28.png"><br><br>  Bagian ini memberikan pedoman untuk membangun arsitektur N-tier menggunakan mesin virtual.  Setiap tingkatan terdiri dari dua atau lebih mesin virtual yang dihosting dalam set ketersediaan atau dalam set mesin virtual yang dapat diskalakan.  Penggunaan beberapa mesin virtual memberikan toleransi kesalahan jika terjadi kegagalan salah satunya.  Untuk mendistribusikan permintaan antara mesin virtual pada level yang sama, subsistem load balancing digunakan.  Level dapat ditingkatkan secara horizontal, menambahkan mesin virtual baru ke pool. <br><br>  Setiap level juga ditempatkan di dalam subnetnya sendiri.  Ini berarti bahwa alamat IP internal mereka berada dalam kisaran yang sama.  Ini membuatnya mudah untuk menerapkan aturan Grup Keamanan Jaringan (NSG) dan tabel routing ke masing-masing layer. <br><br>  Tingkat web tier dan tingkat bisnis tidak dipantau.  Mesin virtual apa pun dapat menangani permintaan apa pun untuk level ini.  Lapisan data harus terdiri dari basis data yang direplikasi.  Untuk Windows, kami sarankan menggunakan SQL Server dengan Grup Selalu Aktif untuk ketersediaan tinggi.  Untuk Linux, Anda harus memilih database yang mendukung replikasi, seperti Apache Cassandra. <br><br>  Akses ke setiap level dibatasi oleh grup keamanan jaringan (NSGs).  Misalnya, akses ke tingkat basis data hanya diizinkan untuk tingkat bisnis <br><br><h4>  Fitur Tambahan </h4><br><ul><li>  Arsitektur N-tier tidak harus terdiri dari tiga tingkatan.  Aplikasi yang lebih kompleks cenderung menggunakan lebih banyak level.  Dalam hal ini, gunakan perutean melalui lapisan 7 untuk mengarahkan permintaan ke tingkat tertentu. </li><li>  Level membatasi keputusan mengenai skalabilitas, keandalan, dan keamanan.  Disarankan agar Anda menggunakan level yang berbeda untuk layanan dengan persyaratan berbeda untuk karakteristik ini. </li><li>  Gunakan penskalaan otomatis menggunakan set mesin virtual yang dapat diskalakan. </li><li>  Temukan elemen dalam arsitektur Anda yang dapat Anda terapkan dengan layanan terkelola tanpa refactoring utama.  Secara khusus, perhatikan caching, perpesanan, penyimpanan, dan basis data. </li><li>  Untuk meningkatkan keamanan, letakkan aplikasi di belakang jaringan perimeter.  Jaringan perimeter mencakup komponen jaringan virtual yang menyediakan keamanan, seperti firewall dan inspektur paket.  Untuk informasi lebih lanjut, lihat Arsitektur Jaringan Referensi Perimeter. </li><li>  Untuk ketersediaan tinggi, tempatkan dua atau lebih komponen jaringan virtual dalam kumpulan ketersediaan dan tambahkan load balancer untuk mendistribusikan permintaan Internet di antara mereka.  Untuk informasi lebih lanjut, lihat Menyebarkan Komponen Jaringan Virtual untuk Ketersediaan Tinggi. </li><li>  Jangan izinkan akses langsung ke mesin virtual yang menjalankan kode aplikasi melalui protokol RDP dan SSH.  Sebagai gantinya, operator harus memasukkan node benteng.  Ini adalah mesin virtual yang terletak di jaringan yang digunakan oleh administrator untuk terhubung ke mesin virtual lain.  Pada bastion host, aturan NSG dikonfigurasikan untuk memungkinkan akses melalui RDP dan SSH hanya dari alamat IP publik yang disetujui. </li><li>  Anda dapat memperluas jaringan virtual Azure ke jaringan lokal menggunakan jaringan-ke-jaringan tipe virtual (VPN) atau Azure ExpressRoute.  Untuk informasi lebih lanjut, lihat Arsitektur Referensi Jaringan Hibrid. </li><li>  Jika organisasi Anda menggunakan Active Directory untuk manajemen identitas, Anda dapat memperluas lingkungan Active Directory Anda ke jaringan virtual Azure.  Untuk informasi lebih lanjut, lihat Arsitektur Referensi Manajemen Identitas. </li><li>  Jika tingkat ketersediaan yang lebih tinggi diperlukan daripada yang disyaratkan oleh Perjanjian Tingkat Layanan Mesin Virtual Azure, gandakan aplikasi antara kedua wilayah dan konfigurasikan Manajer Lalu Lintas Azure untuk failover.  Untuk informasi lebih lanjut, lihat Memulai mesin virtual Windows di beberapa wilayah dan Memulai mesin virtual Linux di beberapa wilayah. </li></ul><br><hr><br>  Anda dapat mengunduh versi lengkap buku ini secara gratis dan mempelajarinya di tautan di bawah ini. <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Unduh</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423179/">https://habr.com/ru/post/id423179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423169/index.html">Startup of the day (Juli-Agustus 2018)</a></li>
<li><a href="../id423171/index.html">Bagaimana Discord secara bersamaan melayani 2,5 juta obrolan suara menggunakan WebRTC</a></li>
<li><a href="../id423173/index.html">Waktu minimum - nyeri maksimum</a></li>
<li><a href="../id423175/index.html">Mengapa menulis mesin gim Anda sendiri?</a></li>
<li><a href="../id423177/index.html">Buku Infrastruktur Keamanan Microsoft Azure</a></li>
<li><a href="../id423181/index.html">Buku Panduan Pengembang Azure</a></li>
<li><a href="../id423183/index.html">Buku Dasar-Dasar Microsoft Azure</a></li>
<li><a href="../id423185/index.html">Jangan memakannya! Pencetakan Gula 3D yang Berguna</a></li>
<li><a href="../id423187/index.html">Root dan sertifikat perantara dari Otoritas Sertifikasi resmi Rusia</a></li>
<li><a href="../id423189/index.html">Penelitian: setengah dari perusahaan menambal kerentanan dalam sebulan - mengapa?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>