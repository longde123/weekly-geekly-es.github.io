<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💹 👨🏾‍🚒 👩‍❤️‍💋‍👩 Lisp parfumé avec Pascal ou le langage de programmation 8501st 🌦️ 🕴🏼 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelque temps (environ trois ans), j'ai décidé de lire un manuel sur Lisp. Sans but précis, juste pour le développement général et la capacité ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lisp parfumé avec Pascal ou le langage de programmation 8501st</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424447/">  Il y a quelque temps (environ trois ans), j'ai décidé de lire un manuel sur Lisp.  Sans but précis, juste pour le développement général et la capacité de choquer les interlocuteurs avec de l'exotisme (une fois que cela semble, ça a même fonctionné). <br><br>  Mais en y regardant de plus près, Lisp s'est avéré être vraiment puissant, flexible et, curieusement, utile dans la vie quotidienne.  Toutes les tâches d'automatisation mineures ont rapidement migré vers des scripts en Lisp, et il y avait également des possibilités d'automatisation de tâches plus complexes. <br><br>  Il convient de noter ici que par «capacité d'automatisation», je veux dire une situation où le temps total pour écrire et déboguer un programme est inférieur au temps passé à résoudre manuellement la même tâche. <br><br>  Paul Graham a écrit plus d'un article et même un livre sur les avantages de Lisp.  Au moment d'écrire ces lignes, Lisp est classé 33ème dans le classement TOIBE (trois fois mort que Delphi mort).  La question se pose: pourquoi la langue est-elle si petite si elle est si pratique?  Environ deux ans d'utilisation ont donné quelques indications sur les raisons. <br><a name="habracut"></a><br><h3>  Inconvénients </h3><br>  <i>1. Structures de données partagées</i> <br>  Un concept qui vous permet d'optimiser des programmes fonctionnels, mais lourd d'erreurs subtiles en impératif.  La possibilité de dommages accidentels à une structure de données superflue lorsqu'une variable qui n'a pas de connexion visible avec la structure nécessite que le programmeur surveille constamment ce qui se passe dans les coulisses et connaisse l'implémentation interne de chaque fonction utilisée (système et utilisateur).  La chose la plus étonnante est la possibilité d'endommager le corps d'une fonction en modifiant sa valeur de retour. <br><br>  <i>2. Manque d'encapsulation</i> <br>  Bien que le concept de package existe, il n'a rien à voir avec le <b>package</b> dans Ada ou l' <b>unité</b> dans Delphi.  Tout code peut ajouter n'importe quoi à n'importe quel package (sauf ceux du système).  Tout code peut extraire n'importe quoi de n'importe quel package en utilisant l'opérateur <b>::</b> . <br><br>  <i>3. Abréviations aléatoires</i> <br>  Quelle est la différence entre MAPCAN et MAPCON?  Pourquoi dans SETQ, la dernière lettre Q?  Compte tenu de l'âge de la langue, vous pouvez comprendre les raisons de cet état de fait, mais je veux que la langue soit un peu plus propre. <br><br>  <i>4. Multithreading</i> <br>  Cet inconvénient est indirectement lié à Lisp et concerne principalement l'implémentation que j'utilise - SteelBank Common Lisp.  Common Lisp ne prend pas en charge le multithreading.  Une tentative d'utilisation de l'implémentation fournie par SBCL a échoué. <br><br>  Il est dommage de refuser un outil aussi pratique, mais l'insatisfaction s'accumule progressivement. <br><br><h3>  Rechercher une solution </h3><br>  Vous pouvez d'abord aller sur Wikipedia sur la page Lisp.  Inspectez la section "Dialectes".  Lisez une brève introduction à chacun.  Et réalisez que le goût et la couleur de tous les marqueurs sont différents. <br><blockquote>  Si vous voulez faire quelque chose, vous devez le faire vous-même <br>  - Jean Baptiste Emmanuel Sorg </blockquote>  Essayons de créer notre propre Lisp correct en y ajoutant un peu d'Ada, beaucoup de Delphi et une goutte d'Oberon.  Nous appelons le mélange résultant Fox. <br><br><h3>  Concepts de base </h3><br>  <i>1. Pas de pointeurs</i> <br>  Dans la lutte contre PROBLEM-1, toutes les opérations doivent être effectuées en copiant les valeurs.  Par le type de structure de données dans le code ou lors de l'impression, toutes ses propriétés, connexions externes et internes doivent être entièrement visibles. <br><br>  <i>2. Ajouter des modules</i> <br>  Dans le cadre de la lutte contre le problème 2, nous importons des <b>packages</b> , <b>avec</b> et <b>utilisons des</b> déclarations d'Ada.  Dans le processus, nous rejetons le schéma d'importation / d'observation trop complexe pour les symboles Lisp. <br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">package</span></span> - (  ) () ())</code> </pre> <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">with</span></span> -) <span class="hljs-comment"><span class="hljs-comment">;  «-.lisya»   </span></span></code> </pre> <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">use</span></span> -) <span class="hljs-comment"><span class="hljs-comment">;,      </span></span></code> </pre> <br><br>  <i>3. Moins d'abréviations</i> <br>  Les caractères les plus courants et les plus courants seront toujours abrégés, mais surtout les plus évidents: <b>const</b> , <b>var</b> .  Fonction de sortie formatée - FMT nécessite une réduction, car elle se trouve souvent à l'intérieur des expressions.  <b>Elt</b> - prenant un élément - a fui de Common Lisp et a pris racine, bien qu'il ne soit pas nécessaire de le réduire. <br><br>  <i>4. Identifiants insensibles à la casse</i> <br>  Je pense que la langue (et le système de fichiers) corrects {$ HOLYWAR +} devrait être insensible à la casse {$ HOLYWAR-} afin de ne pas lui faire une fois de plus la cervelle. <br><br>  <i>5. Facilité d'utilisation avec la disposition du clavier russe</i> <br>  La syntaxe Lisi évite de toutes les manières possibles l'utilisation de caractères qui ne sont pas disponibles dans l'une des mises en page.  Pas d'accolades carrées ou bouclées.  Non #, ~, &amp;, &lt;,&gt;, |.  Lors de la lecture de littéraux numériques, une virgule et un point sont considérés comme des séparateurs décimaux. <br><br>  <i>6. Alphabet étendu</i> <br>  Une des bonnes choses à propos de SBCL était UTF-8 dans le code.  La possibilité de déclarer les constantes BEAR, VODKA et BALALAYKA simplifie grandement l'écriture du code d'application.  La possibilité d'insérer Ω, Ψ et Σ rend les formules dans le code plus visuelles.  Bien qu'il soit théoriquement possible d'utiliser des caractères Unicode, il est difficile de garantir l'exactitude du travail avec eux (plutôt paresse que difficile).  Nous nous limitons au cyrillique, au latin et au grec. <br><br>  <i>7. Littéraux numériques</i> <br>  C'est l'extension linguistique la plus utile pour moi. <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">10</span></span>_000 <span class="hljs-comment"><span class="hljs-comment">;    10k ;       10 ;       10° 10pi 10deg 10 ;   10π ; pi     10+i10 ;   10+10 ;    1010deg ;         </span></span></code> </pre> <br>  Cette dernière option me semble la plus peu esthétique, mais elle est la plus populaire. <br><br>  <i>8. Cycles</i> <br>  Les cycles en Lisp sont non standard et assez désordonnés.  Simplifiez à l'ensemble standard minimum. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">for</span></span> i <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">;   i = 0..4 ) (for i 1..6 ;   i = 1..5 ) (for i  ;     ;      ) (for i (subseq  2) ;           )</span></span></code> </pre> <br>  La variable de boucle n'est pas visible à l'extérieur. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">while</span></span>  )</code> </pre> <br>  <i>9. GOTO</i> <br>  Pas un opérateur très nécessaire, mais sans lui, il est difficile de démontrer la négligence des règles de programmation structurelle. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">block</span></span> : (<span class="hljs-name"><span class="hljs-name">goto</span></span> :)) <span class="hljs-comment"><span class="hljs-comment">;    </span></span></code> </pre> <br>  <i>10. Unification du champ d'application</i> <br>  Il existe deux types différents de portée dans Lisp: TOPLEVEL et local.  En conséquence, il existe deux façons différentes de déclarer des variables. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) …)</code> </pre> <br>  Dans Fox, il n'y a qu'une seule méthode utilisée à la fois au niveau supérieur du script et dans les zones locales, y compris les packages. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">var</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Si vous souhaitez limiter la portée, utilisez l'opérateur <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">block</span></span> (<span class="hljs-name"><span class="hljs-name">var</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">set</span></span> A <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">fmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> A))</code> </pre> <br>  Le corps de la boucle est contenu dans l'instruction BLOCK implicite (comme le corps de la fonction / procédure).  Toutes les variables déclarées dans la boucle sont détruites à la fin de l'itération. <br><br>  <i>11. Caractères à un seul emplacement</i> <br>  En Lisp, les fonctions sont des objets spéciaux et sont stockées dans un emplacement de symbole spécial.  Un seul caractère peut stocker simultanément une variable, une fonction et une liste de propriétés.  Chez un renard, chaque personnage n'est associé qu'à une seule signification. <br><br>  <i>12. ELT pratique</i> <br>  L'accès typique à un élément de structure complexe en Lisp ressemble à ceci <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">elt</span></span> (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>) '<span class="hljs-number"><span class="hljs-number">-2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Le Fox implémente un opérateur ELT unifié qui donne accès à des éléments de tous types composites (listes, chaînes, enregistrements, tableaux d'octets, tables de hachage). <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">elt</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> \<span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Des fonctionnalités identiques peuvent également être obtenues avec une macro en Lisp <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> field (<span class="hljs-name"><span class="hljs-name">object</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> f) <span class="hljs-string"><span class="hljs-string">"       . (field *object* 0 :keyword symbol \"string\")       .        plist.   ( )    .        ."</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> f (<span class="hljs-name"><span class="hljs-name">symbol-macrolet</span></span> ((<span class="hljs-name"><span class="hljs-name">f0</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span> f <span class="hljs-number"><span class="hljs-number">0</span></span>))(<span class="hljs-name"><span class="hljs-name">rest</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> f <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> f0) `(field (elt ,object ,f0) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">keywordp</span></span> f0) `(field (getf ,object ,f0) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">stringp</span></span> f0) `(field (cdr (assoc ,f0 ,object :test 'equal)) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">listp</span></span> f0) (<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> f0))) `(field (,(car f0) ,(cadr f0) ,object) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">symbolp</span></span> f0) `(field (,f0 ,object) ,@rest)) (<span class="hljs-name"><span class="hljs-name">t</span></span> `(error <span class="hljs-string"><span class="hljs-string">"   "</span></span>)))) object))</code> </pre> <br>  <i>13. Restriction des modes de transfert des paramètres des sous-programmes</i> <br>  Il existe au moins cinq modes de transfert de paramètres en Lisp: obligatoire, <i>&amp; facultatif</i> , <i>&amp; reste</i> , <i>&amp; clé</i> , <i>&amp; entier</i> et leur combinaison arbitraire est autorisée.  En fait, la plupart des combinaisons donnent des effets étranges. <br>  Dans Fox, il est autorisé d'utiliser uniquement une combinaison des paramètres requis et l'un des modes suivants parmi lesquels choisir <i>: clé</i> <i>,: facultatif ,:</i> <i>drapeau</i> <i>,:</i> <i>repos</i> . <br><br>  <i>14. Multithreading</i> <br>  Afin de simplifier au maximum l'écriture de programmes multithreads, le concept de séparation de mémoire a été adopté.  Lorsqu'un thread est généré, toutes les variables disponibles pour le nouveau thread sont copiées.  Toutes les références à ces variables sont remplacées par des références à des copies.  Le transfert d'informations entre les flux n'est possible que via des objets protégés ou via le résultat renvoyé par le flux une fois terminé. <br><br>  Les objets protégés contiennent toujours des sections critiques pour assurer les opérations atomiques.  La connexion aux sections critiques est automatique - il n'y a pas d'opérateurs séparés pour cela dans la langue.  Les objets protégés incluent: file d'attente de messages, console et descripteurs de fichiers. <br><br>  La création de threads est possible avec une fonction d'affichage multi-thread <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">map-th</span></span> (<span class="hljs-name"><span class="hljs-name">function</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) …) --)</code> </pre> <br>  Map-th démarre automatiquement le nombre de threads égal au nombre de processeurs du système (ou deux fois plus si vous avez Intel à l'intérieur).  Dans un appel récursif, les appels de mappage suivants fonctionnent dans un seul thread. <br><br>  En outre, il existe une fonction de thread intégrée qui exécute une procédure / fonction dans un thread séparé. <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   (var  (thread --1)) (+ (--2) (wait ))</span></span></code> </pre> <br>  <i>15. Propreté fonctionnelle dans le code impératif</i> <br>  Le Fox a des fonctions de programmation fonctionnelle et des procédures procédurales.  Les routines déclarées à l'aide du mot clé function sont soumises aux exigences de l'absence d'effets secondaires et de l'indépendance du résultat vis-à-vis des facteurs externes. <br><br><h3>  Non réalisé </h3><br>  Certaines fonctionnalités intéressantes de Lisp n'ont pas été satisfaites en raison d'une faible priorité. <br><br>  <i>1. Méthodes généralisées</i> <br>  Capacité à surcharger les fonctions avec defgeneric / defmethod. <br><br>  <i>2. Héritage</i> <br><br>  <i>3. Débogueur intégré</i> <br>  Lorsqu'une exception se produit, l'interpréteur Lisp passe en mode débogage. <br><br>  <i>4. UFFI</i> <br>  Interface pour connecter des modules écrits dans d'autres langues. <br><br>  <i>5. BIGNUM</i> <br>  Prise en charge de la profondeur de bits arbitraire <br><br>  <b>Jeté</b> <br><br>  Certaines fonctionnalités de Lisp ont été considérées et considérées comme inutiles / nuisibles. <br><br>  <i>1. Combinaison guidée de méthodes</i> <br>  Lorsqu'une méthode est appelée pour une classe, une combinaison de méthodes parentes est effectuée et il est possible de modifier les règles de combinaison.  Le comportement final de la méthode semble peu prévisible. <br><br>  <i>2. Redémarre</i> <br>  Le gestionnaire d'exceptions peut apporter des modifications à l'état du programme et envoyer une commande de redémarrage au code qui a généré l'exception.  L'effet de l'application est similaire à l'utilisation de l'opérateur GOTO pour passer d'une fonction à l'autre. <br><br>  <i>3. Le récit romain</i> <br>  Lisp prend en charge le système de numérotation, qui est obsolète peu de temps avant son apparition. <br><br><h3>  Utiliser </h3><br>  Voici quelques exemples de code simples. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">function</span></span> crc8 (<span class="hljs-name"><span class="hljs-name">data</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:optional</span></span> seed) (<span class="hljs-name"><span class="hljs-name">var</span></span> result (<span class="hljs-name"><span class="hljs-name">if-nil</span></span> seed <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">var</span></span> s_data data) (<span class="hljs-name"><span class="hljs-name">for</span></span> bit <span class="hljs-number"><span class="hljs-number">8</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">bit-and</span></span> (<span class="hljs-name"><span class="hljs-name">bit-xor</span></span> result s_data) $<span class="hljs-number"><span class="hljs-number">01</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">shift</span></span> result <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)) (<span class="hljs-name"><span class="hljs-name">else</span></span> (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">bit-xor</span></span> result $<span class="hljs-number"><span class="hljs-number">18</span></span>)) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">shift</span></span> result <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">bit-or</span></span> result $<span class="hljs-number"><span class="hljs-number">80</span></span>)))) (<span class="hljs-name"><span class="hljs-name">set</span></span> s_data (<span class="hljs-name"><span class="hljs-name">shift</span></span> s_data <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>))) result)</code> </pre> <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;     (map (function (x) (** x 2)) \(1 2 3))</span></span></code> </pre> <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   ,   qwe      (filter (function (x) (regexp:match x «^qwe...»)) -) ;   ,   ,    (filter-th (function (x) (regexp:match x «^qwe...»)) -)</span></span></code> </pre> <br><h3>  Implémentation </h3><br>  L'interpréteur est écrit en Delphi (FreePascal en mode compatibilité).  Il est construit dans Lazarus 1.6.2 et supérieur, sous Windows et Linux 32 et 64 bits.  Parmi les dépendances externes, nécessite libmysql.dll.  Contient environ 15_000..20_000 lignes.  Il existe environ 200 fonctions intégrées à des fins diverses (certaines sont surchargées huit fois). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stocké ici</a> <br><br>  La prise en charge du typage dynamique est effectuée de manière triviale - tous les types de données traitées sont représentés par les héritiers de la même classe TValue. <br><br>  Le type le plus important pour Lisp - la liste est, comme c'est la coutume dans Delphi, une classe contenant un tableau dynamique d'objets de type TValue.  Pour ce type, le mécanisme CopyOnWrite est implémenté. <br><br>  La gestion de la mémoire est automatique basée sur le comptage des références.  Pour les structures récursives, tous les liens de la structure sont comptés simultanément.  La libération de mémoire démarre immédiatement lorsque les variables quittent la portée.  Il n'y a aucun mécanisme pour le démarrage différé du ramasse-miettes. <br><br>  La gestion des exceptions fonctionne sur un mécanisme intégré à Delphi.  Ainsi, les erreurs qui se produisent dans le code de l'interpréteur peuvent être traitées par le code exécutable sur le Fox. <br><br>  Chaque opérateur ou fonction Lisi intégrée est implémentée en tant que méthode ou fonction dans le code d'interpréteur.  Le script est exécuté par appel mutuellement récursif d'implémentations.  Le code interprète et le script ont une pile d'appels commune. <br><br>  Les variables de script sont stockées dans la mémoire dynamique indépendamment.  Chaque fonction définie par l'utilisateur a sa propre pile pour stocker les références de variables, indépendamment de la pile de niveau supérieur ou de la pile des fonctions parentes. <br><br>  La mise en œuvre de l'opérateur d'affectation (ensemble) pour les éléments structuraux est particulièrement difficile.  Le calcul direct du pointeur vers l'élément requis entraîne le risque de suspendre les liens, car la syntaxe Lisi n'interdit pas de modifier la structure lors du calcul de l'élément requis.  Comme solution de compromis, un «pointeur de chaîne» est implémenté - un objet contenant une référence à une variable et un tableau d'indices numériques pour indiquer le chemin dans la structure.  Un tel pointeur est également sensible au problème des liens pendants, mais en cas de défaillance, il génère un message d'erreur significatif. <br><br><h3>  Outils de développement </h3><br>  <i>1. Console</i> <br><br>  <i>2. Éditeur de texte</i> <br>  Équipé de la coloration syntaxique et de la possibilité d'exécuter un script modifiable en F9. <br><img src="https://habrastorage.org/webt/1c/q9/yo/1cq9yo4edbezhjgav_mjby393rs.png"><br><br><h3>  Conclusion </h3><br>  Dans l'état actuel, le projet résout les problèmes pour lesquels il a été conçu et ne nécessite pas de développement actif supplémentaire.  Bon nombre des imperfections présentes n'affectent pas significativement le travail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424447/">https://habr.com/ru/post/fr424447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424435/index.html">Zoo de forage pétrolier: mettre les choses en ordre</a></li>
<li><a href="../fr424437/index.html">Orme. Confortable et maladroit. Json.Encoder et Json.Decoder</a></li>
<li><a href="../fr424441/index.html">Nouveautés du premier CTP de SQL Server 2019</a></li>
<li><a href="../fr424443/index.html">Vivaldi 2.0 en notre faveur</a></li>
<li><a href="../fr424445/index.html">La traduction par Neil Ford des microservices en tant qu'architecture évolutive</a></li>
<li><a href="../fr424453/index.html">Apprenez OpenGL. Leçon 6.2 - Rendu basé sur la physique. Sources de lumière analytiques</a></li>
<li><a href="../fr424455/index.html">Intel Optane - maintenant 1,5 téraoctets</a></li>
<li><a href="../fr424457/index.html">Mise à niveau d'IDA Pro. Apprendre à écrire des chargeurs de démarrage en Python</a></li>
<li><a href="../fr424459/index.html">Success Story, ou DEV + DEVOPS + OPS</a></li>
<li><a href="../fr424461/index.html">Pourquoi apprendre des langues impopulaires. Exemple de communauté F #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>