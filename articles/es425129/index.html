<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∫ üëåüèª üç∫ ¬øC√≥mo automatizar la creaci√≥n de m√°quinas virtuales? Contamos en detalle ü•© ‚ôìÔ∏è üêí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Crear una nueva m√°quina virtual es una rutina que consume mucho tiempo. Y mientras m√°s infraestructura y organizaci√≥n, m√°s procedimientos asociados co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo automatizar la creaci√≥n de m√°quinas virtuales? Contamos en detalle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/icl_services/blog/425129/"> Crear una nueva m√°quina virtual es una rutina que consume mucho tiempo.  Y mientras m√°s infraestructura y organizaci√≥n, m√°s procedimientos asociados con este proceso.  Automatizamos este proceso usando PowerShell. <br><br>  Bienvenido a Kat si est√°s interesado. <br><br><img src="https://habrastorage.org/webt/fv/fr/cc/fvfrccl_crsi5nfvcnstarorits.jpeg"><br><br><a name="habracut"></a><br>  A los programadores no les gusta hacer doble trabajo, los administradores del sistema tambi√©n. <br><br>  A continuaci√≥n se muestra un ejemplo de automatizaci√≥n de uno de nuestros clientes. <br><br>  Quer√≠amos asegurarnos de que cualquier ingeniero o gerente de proyecto pudiera crear una nueva m√°quina virtual con un m√≠nimo esfuerzo y por un per√≠odo m√≠nimo.  Nuestro cliente tiene un sistema ITSM, en este ejemplo es ServiceNow, creamos el formulario web correspondiente en el cat√°logo de servicios.  Para "ordenar" una nueva m√°quina, el gerente necesita completar los campos y confirmar el "pedido", despu√©s de que se inicia la cadena de proceso, y en la salida tenemos la m√°quina lista para usar. <br><br>  Entonces, echemos un vistazo a lo que un gerente necesita definir para crear una nueva m√°quina virtual: <br><br><img src="https://habrastorage.org/webt/3l/8d/yo/3l8dyowobrfvbgpznotayqjywvu.png"><br><br>  <b>Descripci√≥n de VM: descripci√≥n de m√°quina virtual</b> <b><br></b>  Aqu√≠ se necesitan algunas aclaraciones.  En nuestra soluci√≥n, PowerShell 5.1 se usa activamente, por lo que, aunque solo sea Windows, en el futuro intentaremos agregar soporte para m√°quinas Unix y cambiar a PowerShell Core. <br><br>  <b>OS</b> , sistema operativo.  No existen barreras particulares para usar Windows 2008 (R2), pero estamos usando 2012R2 o 2016. <br><br>  <b>Tama√±o de</b> m√°quina virtual, tama√±o de m√°quina virtual.  Para cada uno, esto se puede determinar a su manera, en este ejemplo Peque√±o 1CPU-4Gb Ram, Medio 2CPU-8Gb, Grande 4-16. <br><br>  <b>VM Storage</b> , Disk 0 (C: \) tiene un tama√±o fijo que no puede cambiar, solo est√° disponible el selector de almacenamiento Fast / Slow.  "R√°pido" puede ser Nivel de almacenamiento con SSD, y "Lento" puede ser almacenamiento en HDD "normales" (por supuesto, SAN).  Disk1 (Disk2 en adelante) tambi√©n tiene un selector para seleccionar Almacenamiento, as√≠ como campos para ingresar el tama√±o deseado en gigabytes, Letra para la partici√≥n y tama√±o del cl√∫ster (que es importante para SQL Server). <br><br>  <b>Confianza</b> , determinamos que la m√°quina debe estar unida al dominio o no, con acceso desde la red p√∫blica o no. <br><br>  <b>Tipo</b> , tipo de m√°quina.  Casi todas las m√°quinas se pueden definir como aplicaciones front-end o back-end u otras en todos los dem√°s casos.  Seg√∫n el tipo seleccionado, podemos determinar la subred m√°s adecuada para la m√°quina. <br><br>  <b>Medio ambiente</b> , en la infraestructura del cliente hay dos centros de datos: Primario (Producci√≥n) y Secundario (Dev / prueba), DC est√°n conectados por un canal de comunicaci√≥n r√°pido y proporcionan tolerancia a fallas.  Por acuerdo, todas las m√°quinas virtuales en DC primario tienen una direcci√≥n IP que comienza en 10.230 y en DC secundario en 10.231. <br><br>  <b>(SLA) Acuerdo de nivel de servicio</b> , este par√°metro afecta la calidad de servicio de esta m√°quina. <br><br>  <b>Aplicaciones</b>  Hemos agregado la capacidad de instalar y configurar SQL Server.  Debe seleccionar la edici√≥n, el nombre de la instancia y la clasificaci√≥n.  Tambi√©n es posible configurar la funci√≥n del servidor web y mucho m√°s. <br><br>  Ahora necesitamos determinar c√≥mo almacenar los valores seleccionados.  Decidimos que el formato m√°s conveniente es un archivo JSON.  Como dije anteriormente, el entorno del cliente utiliza ITSM ServiceNow;  el administrador, despu√©s de seleccionar todos los valores necesarios, hace clic en el bot√≥n "ordenar" y luego ServiceNow pasa todos los par√°metros a nuestro script de PowerShell (al ServiceNow de fondo), que crear√° el archivo JSON.  Se parece a esto: <br><br><pre><code class="plaintext hljs">.\CreateConfiguration.ps1 -SecurityZone trusted -VMDescription "VM for CRM System" -Requestor "evgeniy.vpro" -OSVersion 2k16 -OSEdition Standard -BuildNewVM -VMEnvironment Prod -VMServiceLevel GOLD -VMSize Medium -Disk0Tier Fast -Disk1Size 50 -Disk1Tier Eco -Disk1Letter D -MSSQLServer -MSSQLInstanceName "Instance1" -SQLCollation Latin1_General_CI_AS -SQLEdition Standard -Disk2Size 35 -Disk3Size 65</code> </pre> <br><br>  En el cuerpo del script CreateConfiguration .ps1: <br><br><pre> <code class="plaintext hljs"># PowerShell- $config = [ordered]@{} #    . $config.SecurityZone=$SecurityZone</code> </pre><br><br>  Al final, exporte nuestro objeto a un archivo JSON: <br><br><pre> <code class="plaintext hljs">$ServerConfig = New-Object ‚ÄìTypeName PSObject $config ConvertTo-Json -InputObject $ServerConfig -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$($Hostname.ToLower()).json" -Force</code> </pre><br><br>  Configuraci√≥n de muestra: <br><br><pre> <code class="plaintext hljs">{ "Hostname": "dsctest552", "SecurityZone": "trusted", "Domain": "testdomain", "Requestor": "evgeniy.vpro", "VM": { "Size": "Medium", "Environment": "Prod", "SLA": "GOLD", "DbEngine": "MSSQL", "RAM": 8, "Storage": [ { "Id": 0, "Tier": "Fast", "Size": "100", "Allocation": 4, "Letter": "C" }, { "Id": 1, "Tier": "Eco", "Size": 50, "Label": "Data", "Allocation": 64, "Letter": "D" }, { "Id": 2, "Tier": "Fast", "Size": 35, "Label": "Data", "Allocation": 64, "Letter": "E" }, { "Id": 3, "Tier": "Fast", "Size": 65, "Label": "Data", "Allocation": 64, "Letter": "F" } ] }, "Network": { "MAC": "", "IP": "10.230.168.50", "Gateway": "10.230.168.1", "VLAN": ‚ÄúVLAN168‚Äù }, "OS": { "Version": "2k16", "Edition": "Standard", "Administrators": [ "LocaAdmin", "testdomain\\ Security-LocalAdmins" ] }, "OU": "OU=Servers,OU=Staging,DC=testdomain", "Applications": [ { "Application": "Microsoft SQL Server 2016", "InstanceName": "vd", "Collation": "Latin1_General_CI_AS", "Edition": "Standard", "Features": "SQLENGINE", "Folders": { "DataRoot": "E:\\MSSQL", "UserDB": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Data", "UserLog": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Log", "TempDB": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "TempDBLog": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "Backup": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Backup" }, "MaxMemory": 2147483647 } ], "Description": "VM for CRM", "Certificate": { "File": null, "Thumbprint": null }, "Version": 0 }</code> </pre><br><br>  Es posible que haya notado que el formulario web no ten√≠a un nombre de m√°quina virtual y una direcci√≥n IP.  Obtenemos estos valores autom√°ticamente de la siguiente manera: <br><br>  <b>El nombre de la m√°quina</b> , ITSM ServiceNow tiene una secci√≥n especial: CMDB (Base de datos de administraci√≥n de configuraci√≥n), esta base de datos almacena todos los registros sobre m√°quinas virtuales existentes, su estado, equipo de soporte, etc.  Hemos creado alrededor de 200 registros de respaldo con estado asignado.  Para obtener un nombre para la m√°quina virtual, realizamos una solicitud REST a CMDB y obtenemos el primer registro "gratuito" y cambiamos su estado de Asignado a Pendiente de instalaci√≥n. <br><br>  <b>Direcci√≥n IP y VLAN</b> , implementamos IPAM en nuestra red: esta es una caracter√≠stica incorporada en Windows Server 2016 que le permite administrar las direcciones IP en su red.  No es necesario usar todas las funciones de IPAM (DHCP, DNS, AD), sino usarlo solo como una base de datos de direcciones IP con una posible extensi√≥n de funcionalidad.  El script que crea el archivo JSON realiza una solicitud a IPAM para la primera direcci√≥n IP libre en la subred.  Y la subred VLAN (subred x / 24) se determina en funci√≥n de los valores de SLA, Entorno, Confianza y Tipo seleccionados. <br>  El archivo de configuraci√≥n est√° listo, todos los campos est√°n en su lugar, puede crear una m√°quina.  La pregunta es, "¬øc√≥mo almacenar credenciales para todos nuestros scripts?".  Usamos el paquete <a href="">CredentialManager</a> .  Este paquete funciona con la API integrada de Windows Credential Manager para almacenar contrase√±as.  Ejemplo de creaci√≥n de una contrase√±a: <br><br><pre> <code class="plaintext hljs">New-StoredCredential -Target "ESXi" -UserName "testdomain.eu\vmwareadm" -Password "veryultraP@ssw00rd." -Type Generic -Persist LocalMachine</code> </pre><br><br>  La contrase√±a estar√° disponible para leer dentro de esta m√°quina y cuenta. <br><br><pre> <code class="plaintext hljs">$ESXiAdmin = Get-StoredCredential -Type Generic -Target ESXi</code> </pre> <br><br>  Tenemos un servidor en el que se almacenan todas las configuraciones con GIT, ahora podemos realizar un seguimiento confiable de todos los cambios en las configuraciones: qui√©n, qu√©, d√≥nde y cu√°ndo. <br><br>  La tarea programada se configura en este servidor: verifique la carpeta con las configuraciones y escriba en el Registro de eventos de Windows acerca de todos los cambios. <br><br>  Despu√©s de 15 minutos, la tarea programada escribir√° en Windows EventLog que se ha detectado un nuevo archivo de configuraci√≥n. <br><br>  Es hora de verificar esta configuraci√≥n.  En primer lugar, debemos asegurarnos de que el archivo tenga el formato correcto: <br><br><pre> <code class="plaintext hljs">$Configuration=(Get-Content -Raw $File | Out-String | ConvertFrom-Json)</code> </pre> <br><br>  Si todo est√° bien, es hora de comenzar a crear la m√°quina y ejecutar el script BuildVM.ps1. <br><br>  En BuildVM.ps1, verificamos que el archivo de configuraci√≥n tiene una descripci√≥n de todas las caracter√≠sticas de la m√°quina virtual: tama√±o, env, sla, tipo, almacenamiento, ram, red. <br><br>  Aseg√∫rese de verificar si hay una m√°quina con el mismo nombre en la infraestructura (CheckVM.ps1). <br>  Nos conectamos a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VMWare PowerShell CLI</a> a nuestro vSphere: <br><br><pre> <code class="plaintext hljs">$VmWareAdmin = Get-StoredCredential -Type Generic -Target ESXi Connect-VIServer -Server "vSphereSrv" -Credential $VmWareAdmin | Out-Null</code> </pre><br><br>  Verifique si hay una m√°quina con el mismo nombre en la infraestructura <br><br><pre> <code class="plaintext hljs">$VM=Get-VM $server -ErrorAction SilentlyContinue</code> </pre> <br><br>  Y apaga: <br><br><pre> <code class="plaintext hljs">Disconnect-VIServer * -Force -Confirm:$false</code> </pre> <br><br>  Aseg√∫rese de que la m√°quina tampoco est√© disponible en WinRM <br><br><pre> <code class="plaintext hljs">$ping=Test-NetConnection -ComputerName $Configuration.Hostname -CommonTCPPort WINRM -InformationLevel Quiet -ErrorAction SilentlyContinue</code> </pre> <br><br>  Si $ VM y $ ping est√°n vac√≠os, puede crear una nueva m√°quina.  (Manejamos situaciones en las que una m√°quina ya est√° creada manualmente en ESXi o esta m√°quina est√° en otro centro de datos). <br><br><blockquote>  Algunas palabras sobre el auto.  Esta es una imagen de m√°quina virtual preparada que fue finalizada por sysprep y convertida a plantilla en nuestro vSphere.  El administrador local con la contrase√±a conocida se guarda en la imagen, esta cuenta no se bloquea despu√©s de sysprep, lo que nos permitir√° acceder a cada m√°quina desde esta plantilla, y luego podemos reemplazar esta contrase√±a por motivos de seguridad. </blockquote><br><br><h3>  Crear una m√°quina virtual <br></h3><br>  Encuentra el grupo SLR correspondiente: <br><br><pre> <code class="plaintext hljs">$Cluster=Get-Cluster -Name $Configuration.VM.SLA</code> </pre> <br><br>  Comprueba que tenemos suficiente espacio en el almac√©n de datos: <br><br><pre> <code class="plaintext hljs">$DatastoreCluster = Get-DatastoreCluster |Where-Object {$_.Name -like $Datastore1Name} $Datastore1 = Get-Datastore -Location $DatastoreCluster |sort -Property "FreeSpaceGB" |select -Last 1 IF ($Datastore1.FreeSpaceGB -le "200"){ Write-Host -foreground red "STOP: Not enough datastore capacity for DISK" $vdisk.Id Break }</code> </pre><br><br>  Y suficiente memoria: <br><br><pre> <code class="plaintext hljs">$VMHost = Get-VMHost -Location $Cluster |sort -Property "MemoryUsageGB" |select -First 1 IF ($VMHost.MemoryUsageGB -le "20"){ Write-Host -foreground red "STOP: No enough ESXi host capacity" Break }</code> </pre><br><br>  Tomamos nuestra plantilla <br><br><pre> <code class="plaintext hljs">$VMTemplate = Get-Template -Name 'Win2016_Std_x64_Template'</code> </pre> <br><br>  Y crea una nueva m√°quina virtual <br><br><pre> <code class="plaintext hljs">New-VM -Name $Configuration.Hostname.ToUpper() -VMHost $VMHost -ResourcePool $ResourcePool -Datastore $Datastore -Template $VMTemplate -Location "AutoDeployed VMs"</code> </pre> <br><br>  Es importante conectar la interfaz de red a una subred con DHCP habilitado. <br><br>  Iniciamos la maquina virtual <br><br><pre> <code class="plaintext hljs">Start-VM $VM</code> </pre> <br><br>  Y guarde la descripci√≥n de la m√°quina, para que luego pueda determinar la m√°quina en el nivel VMWare. <br><br><pre> <code class="plaintext hljs">Set-Annotation -Entity $VM -CustomAttribute "Change request" -Value $Configuration.Request -Confirm:$false Set-VM $VM -Notes $Configuration.Description -Confirm:$false</code> </pre><br><br>  La m√°quina se inici√≥ y ahora podemos encontrar la direcci√≥n MAC recibida: <br><br><pre> <code class="plaintext hljs">$vMAC = (($VM | Get-NetworkAdapter | Select-Object -Property "MacAddress").MacAddress).Replace(':','')</code> </pre> <br><br>  Guarde este valor en nuestro archivo JSON. <br><br><pre> <code class="plaintext hljs">$Configuration.Network.MAC=$VMAC ConvertTo-Json -InputObject $Configuration -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$Hostname.json" -Force</code> </pre><br><br>  Este es el momento de comprometerse con nuestro Git para que la m√°quina se cree y tenga su propio MAC √∫nico. <br><br>  La m√°quina comienza a inicializarse (despu√©s de sysprep), configurando el equipo y la configuraci√≥n inicial. <br><br>  Esperemos hasta que nuestra m√°quina WinRM est√© disponible con el script EstablishConnection.ps1. <br><br>  Primero descubrimos qu√© IP recibi√≥ la m√°quina de DHCP: <br><br><pre> <code class="plaintext hljs"># $MAC = $vMAC while($isOnline -ne $true){ if((Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer -ErrorAction Ignore).IPAddress.IPAddressToString){ $tempIP=(Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer).IPAddress.IPAddressToString break } else{ if($isOnline -ne $true){ Write-Host "`r$i`t" -NoNewline $i++ } } }</code> </pre><br><br>  Y ahora esperaremos, cuando la m√°quina estar√° disponible en WinRM: <br><br><pre> <code class="plaintext hljs">$LocalAdmin = Get-StoredCredential -Type Generic -Target LocalAdmin $i=0 $isOnline=$false while($isOnline -ne $true){ if(Invoke-Command -ComputerName $tempIP -ScriptBlock{ Get-ItemProperty -Path "Registry::\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing" } -Credential $LocalAdmin -ErrorAction SilentlyContinue){ $isOnline=$true break } else{ if($isOnline -ne $true){ Write-Host "`r$i" -NoNewline $i++ Start-Sleep -Seconds 1 } } }</code> </pre><br><br>  La m√°quina est√° lista para conducir. <br><br><h3>  Configuraci√≥n de estado deseada <br></h3><br>  Para configurar la configuraci√≥n deseada, utilizamos la parte de PowerShell: DSC (Configuraci√≥n de estado deseada).  Hay un DSC Pull Server configurado en la red: dscpull.testdomain.eu. <br>  A continuaci√≥n se muestra la configuraci√≥n de nuestro servidor DSC Pull.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buen art√≠culo sobre la configuraci√≥n de DSC Pull.</a> <br><br><pre> <code class="plaintext hljs">Node $NodeName { WindowsFeature DSCServiceFeature { Ensure = "Present" Name = "DSC-Service" } xDscWebService PSDSCPullServer { Ensure = "Present" EndpointName = "PSDSCPullServer" Port = 8080 PhysicalPath = "$env:SystemDrive\inetpub\PSDSCPullServer" CertificateThumbPrint = $certificateThumbPrint ModulePath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Modules" ConfigurationPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Configuration" State = "Started" DependsOn = "[WindowsFeature]DSCServiceFeature" RegistrationKeyPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService" AcceptSelfSignedCertificates = $true UseSecurityBestPractices = $true } File RegistrationKeyFile { Ensure = 'Present' Type = 'File' DestinationPath = "$env:ProgramFiles\WindowsPowerShell\DscService\RegistrationKeys.txt" Contents = $RegistrationKey } }</code> </pre><br><br>  Est√° disponible en: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://dscpull.testdomain.eu:8080</a> <br><br>  Su punto final: <a href="">https://dscpull.testdomain.eu:8080/PSDSCPullserver.svc</a> <br><br>  Todos los clientes del servidor de extracci√≥n deben tener instalado PowerShell 5.1 <br>  Si no est√° instalado PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">$PSVersionTable.PSVersion.Major ‚Äìlt 5</code> </pre> <br><br>  instalar PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">Write-Host "Download PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock { [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12;Invoke-WebRequest -Uri "https://dscpull.testdomain.eu:8080/Files/Updates/WMF.msu" -OutFile C:\TEMP\WMF.MSU } Write-Host "Extract PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'wusa.exe' -ArgumentList "C:\temp\WMF.msu /extract:C:\temp\" -Wait -PassThru } Write-Host "Apply PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:C:\temp\WindowsBlue-KB3191564-x64.cab /Quiet" -Wait -PassThru } Write-Host "PowerShell 5.1 has been installed"</code> </pre><br><br>  Tambi√©n se implementa un servidor PKI en nuestra red.  Esta es una condici√≥n para el cifrado seguro de credenciales almacenadas en archivos DSC mof (los archivos Mof son el "idioma" en el que se comunican Pull Server y sus clientes).  Cuando un cliente intenta registrarse en el servidor Pull, es necesario especificar un certificado de huella digital y luego el servidor Pull utilizar√° este certificado para cifrar las contrase√±as.  A continuaci√≥n veremos c√≥mo funciona. <br><br>  Importe Root CA a nuestra nueva m√°quina: <br><br><pre> <code class="plaintext hljs"> Invoke-Command -ComputerName $server -ScriptBlock{ $PKI="-----BEGIN CERTIFICATE----- MIIF2TCCA8GgAwIBAgIQSPIjcff9rotNdxbg3+ygqDANBgkqhkiG9w0BAQUFADAe **************************************************************** znafMvVx0B4tGEz2PFss/FviGdC3RohBHG0rF5jO50J4nS/3cGGm+HGdn1w/tZd0 a0FWpn9VCOSmXM2It+tSW1f4nZVt6T2kr1ZlTxkDhT7HMSGsrX/XJswzCkDGe3dE qrVVjNUkhVTaeeBWdujB5J6mcx7YkNsAUhODiS9Cf7FnYnxLFA72M0pijI48P5F0 ShM9HWAAUIrLkv13ug== -----END CERTIFICATE-----" $PKI | Out-File RootCA.cer Import-Certificate RootCA.cer -CertStoreLocation Cert:\LocalMachine\Root | select Thumbprint | Out-Null } -Credential $LocalAdmin | Out-Null</code> </pre><br><br>  Para m√°s trabajo, necesitamos un par de claves RSA.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generaremos un certificado autofirmado</a> y trabajaremos temporalmente con √©l. <br><br>  Ahora podemos registrarnos en el servidor Pull: <br><br><pre> <code class="plaintext hljs">$DscHostFQDN = [System.Net.Dns]::GetHostEntry([string]$env:computername).HostName $DscPullServerURL = "https://$($DscHostFQDN):8080/PSDSCPullserver.svc" $DscWebConfigChildPath = '\inetpub\psdscpullserver\web.config' $DscWebConfigPath = Join-Path -Path $env:SystemDrive -ChildPath $DscWebConfigChildPath $DscWebConfigXML = [xml](Get-Content $DscWebConfigPath) $DscRegKeyName = 'RegistrationKeys.txt' $DscRegKeyXMLNode = "//appSettings/add[@key = 'RegistrationKeyPath']" $DscRegKeyParentPath = ($DscWebConfigXML.SelectNodes($DscRegKeyXMLNode)).value $DscRegKeyPath = Join-Path -Path $DscRegKeyParentPath -ChildPath $DscRegKeyName $DscRegKey = Get-Content $DscRegKeyPath [DSCLocalConfigurationManager()] configuration RegisterOnPull { Node $Node { Settings { ConfigurationModeFrequencyMins = 1440 CertificateID = $Thumbprint RefreshMode ='Pull' RefreshFrequencyMins = 1440 RebootNodeIfNeeded = $true ConfigurationMode ='ApplyAndAutoCorrect' AllowModuleOverwrite = $true DebugMode = 'None' StatusRetentionTimeInDays = 1 } ConfigurationRepositoryWeb $([string]$env:computername) { ServerURL = $DscPullServerURL RegistrationKey = $DscRegKey CertificateID = $Thumbprint ConfigurationNames = @("$hostx") } } } RegisterOnPull -OutputPath $MetaConfigsStorage Set-DscLocalConfigurationManager -ComputerName $Node -Path $MetaConfigsStorage -Verbose -Force -Credential $LocalAdmin</code> </pre><br><br>  Enviar la primera configuraci√≥n a nuestra m√°quina <br><br><pre> <code class="plaintext hljs">Configuration Rename { param ( [Parameter()] [System.String[]] $Node, $hostname ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname } } } Rename -Node $Node -OutputPath $DscConfigPath -hostname $hostname New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  El servidor cambiar√° de nombre y se reiniciar√° autom√°ticamente.  Ahora podemos ejecutar Join Domain. <br><br><pre> <code class="plaintext hljs">Configuration JoinAD { param ( [Parameter()] [System.String[]] $Node, [Parameter(Mandatory = $true)] [ValidateNotNullorEmpty()] [System.Management.Automation.PSCredential] $DomainAdmin, $hostname, $domain ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname DomainName = $domain Credential = $DomainAdmin JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu" } GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( 'testdomain-eu\dscstaging' ) } } } $cd = @{ AllNodes = @( @{ NodeName = $Node PSDscAllowPlainTextPassword = $false PSDscAllowDomainUser=$true Certificatefile = $CertFile Thumbprint = $Certificate.ToString() } ) } JoinAD -Node $Node -OutputPath $DscConfigPath -DomainAdmin $DomainAdmin -hostname $hostname -ConfigurationData $cd -domain $domain New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  As√≠ es como se ve nuestro archivo mof: <br><br><pre> <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H \ nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO + BEyD2cr6vKHdn \ nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT + GX4IkPezR \ nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp + VQCx2ljlwif6ac4X / PQG \ n ----- ----- FIN CMS"; <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> </pre><br><br>  Credenciales cifradas DSC de una cuenta de servicio con derechos de administrador de dominio: testdomain.eu \\ service_DomainJoin_001 con un certificado autofirmado.  DSC Client con su clave privada descifra las credenciales y aplica todos los m√≥dulos de configuraci√≥n con las credenciales de dominio especificadas.  En este caso, realiza la uni√≥n de dominio en la unidad organizativa especificada. <br><br><pre> <code class="plaintext hljs">GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( testdomain-eu\dscstaging' ) }</code> </pre><br><br>  Este m√≥dulo agrega dscstaging a los administradores locales para una mayor configuraci√≥n. <br><br>  Despu√©s de reiniciar, podremos ingresar a la m√°quina con credenciales de dominio. <br><br>  Estamos esperando que el servidor reciba un certificado de nuestra PKI (tenemos configurada la inscripci√≥n autom√°tica) y en el futuro trabajaremos con el certificado emitido por nuestra PKI. <br><br><pre> <code class="plaintext hljs">$vmcert=Invoke-Command -ComputerName $server -ScriptBlock{ return Get-ChildItem -Path cert:\LocalMachine\My | where {$_.EnhancedKeyUsageList.FriendlyName -eq "Document Encryption"-and $_.Issuer -eq "CN=TestDomain Issuing CA, DC=testdomain, DC=eu"} } -ErrorAction Ignore</code> </pre> <br><br>  Ahora reg√≠strate en Pull Server nuevamente con la huella digital actualizada. <br><br>  Eso es todo, la m√°quina unida al dominio, y podemos usarla de la manera que m√°s nos convenga. <br><br><h3>  Instalar SQL Server <br></h3><br>  El archivo JSON describe los requisitos para MS SQL Server, tambi√©n usamos DSC para instalar y configurar SQL Server.  As√≠ es como se ve la configuraci√≥n: <br><br><pre> <code class="plaintext hljs">Configuration $Node{ WindowsFeature "NetFramework35"{ Name = "NET-Framework-Core" Ensure = "Present" Source = "\\$DscHostFQDN\Files\Updates" } WindowsFeature "NetFramework45"{ Name = "NET-Framework-45-Core" Ensure= "Present" } SqlSetup "MSSQL2012NamedInstance"{ InstanceName = $MSSQL.InstanceName Features = $MSSQL.Features ProductKey = $ProductKey SQLCollation = $MSSQL.Collation SQLSysAdminAccounts = @('testdomain-EU\SQLAdmins',' testdomain-EU\Backup') InstallSharedDir = "C:\Program Files\Microsoft SQL Server" InstallSharedWOWDir = "C:\Program Files (x86)\Microsoft SQL Server" InstallSQLDataDir = $MSSQL.DataRoot SQLUserDBDir = $MSSQL.UserDBDir SQLUserDBLogDir = $MSSQL.UserLogDir SQLTempDBDir = $MSSQL.TempDBDir SQLTempDBLogDir = $MSSQL.TempDBLogDir SQLBackupDir = $MSSQL.BackupDir SourcePath = $SQLSource SAPwd = $SA SecurityMode = 'SQL' UpdateSource = ".\Updates" Action = "Install" ForceReboot = $True SQLSvcAccount = $SqlServiceCredential AgtSvcAccount = $SqlServiceCredential ISSvcAccount = $SqlServiceCredential BrowserSvcStartupType = "Automatic" DependsOn = '[WindowsFeature]NetFramework35', '[WindowsFeature]NetFramework45' }</code> </pre><br>  Donde se define $ MSSQL: <br><pre> <code class="plaintext hljs">$MSSQL=$Configuration.Applications | where {$_.Application -eq "Microsoft SQL Server 2012"}</code> </pre> <br><br>  $ MSSQL.InstanceName: todo esto se indica en nuestro archivo Json.  La aplicaci√≥n de esta configuraci√≥n instalar√° MS SQL Server con todas las actualizaciones en la carpeta Actualizaciones y reiniciar√° el servidor si es necesario. <br><br>  El auto est√° listo. <br><br><h2>  Servicio ahora </h2><br>  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varias API disponibles</a> en Service-Now.  Usamos la API Rest. <br>  Para obtener una lista de m√°quinas con estado Asignado, se utiliza una consulta del formulario: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instance.service-now.com/cmdb_ci_server_list.do?sysparm_query=install_status=16</a> ^ u_subtype = ^ ORDERBYname <br>  En PowerShell, se ve as√≠: <br><pre> <code class="plaintext hljs">$url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=install_status=16^u_subtype=^ORDERBYname" $uri= new-object System.Uri("https://instance.service-now.com/") #       $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json #   Configuration Items  $ServersCI=$Servers.result</code> </pre> <br>  El primer objeto de matriz es el nombre de host que necesitamos. <br>  Si la m√°quina est√° lista, puede cambiar el estado de la m√°quina en Service-Now, para esto el script UpdateCI.ps1: <br><pre> <code class="plaintext hljs">param( $CI, [ValidateSet("Allocated","In use","Pending install")] $NewStatus='In use' ) $url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=name=$CI" $uri= new-object System.Uri("https://instance.service-now.com/") $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json $ServerCI=$Servers.result[0] $update=@{} if($NewStatus -eq "In use"){ $update.install_status=1 } if($NewStatus -eq "Pending install"){ $update.install_status=4 } $stringcontent = New-Object System.Net.Http.StringContent((ConvertTo-Json -InputObject $update -Depth 100),[System.Text.Encoding]::UTF8, "application/json"); $result=$HttpClient.PutAsync("https://instance.service-now.com/api/now/table/cmdb_ci_server/$($ServerCI.sys_id)", $stringcontent)</code> </pre> <br>  Para obtener la tabla y los registros, se utilizan las solicitudes REST API GET, para cambiar las solicitudes PUT / POST del registro, en cuyo cuerpo se deben cambiar los campos. <br><br>  <i>Hemos creado una herramienta conveniente con una herramienta gr√°fica como Azure Portal, que nos permite administrar la infraestructura local de la manera m√°s conveniente para nosotros y nuestros clientes.</i> <br>  PS 12.24.2018.  ¬øTodo parece estar desactualizado?  Es hora de usar Azure DevOps.  En el siguiente art√≠culo, le mostrar√© c√≥mo hacer todo esto con la canalizaci√≥n de Azure DevOps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425129/">https://habr.com/ru/post/es425129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425113/index.html">"Tipograf√≠a digital" o mi experiencia en digitalizaci√≥n m√≥vil de libros</a></li>
<li><a href="../es425115/index.html">DevOps en toda regla: tragedia griega en tres actos</a></li>
<li><a href="../es425117/index.html">Dos bits por transistor: ROM de alta densidad en un chip Intel 8087 de punto flotante</a></li>
<li><a href="../es425123/index.html">El misterioso coraz√≥n de la caja de ritmos Roland TR-808</a></li>
<li><a href="../es425125/index.html">@Pythonetc Septiembre 2018</a></li>
<li><a href="../es425131/index.html">Qu√© leer sobre la tecnolog√≠a blockchain: gu√≠as, libros y art√≠culos.</a></li>
<li><a href="../es425133/index.html">Problemas de pago transfronterizos: por qu√© y c√≥mo se usa blockchain aqu√≠</a></li>
<li><a href="../es425135/index.html">Por qu√© VoIP es reconocido como un servicio de informaci√≥n en los EE. UU. Y qu√© significa para la industria de telecomunicaciones y los usuarios</a></li>
<li><a href="../es425137/index.html">Trabajamos en la consola de forma r√°pida y eficiente.</a></li>
<li><a href="../es425139/index.html">Pop estrellas bajo la lente de la inteligencia artificial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>