<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📬 👨‍👨‍👧‍👦 🤣 如何打败巨龙：在Golang上重写程序 🌫️ 🚣🏼 ☮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="碰巧您的程序是用脚本语言（例如，Ruby）编写的，因此需要用Golang重写。 


 一个合理的问题： 为什么您根本需要重写已经编写并且可以正常运行的程序？ 





 首先，假设程序与特定的生态系统相关联 -在我们的例子中，这些是Docker和Kubernetes。 这些项目的整个基础架构都是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何打败巨龙：在Golang上重写程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/437044/"><p> 碰巧您的程序是用脚本语言（例如，Ruby）编写的，因此需要用Golang重写。 </p><br><p> 一个合理的问题： <strong>为什么</strong>您根本需要重写已经编写并且可以正常运行的程序？ </p><br><p><img src="https://habrastorage.org/webt/b7/a0/ho/b7a0hogmqu_sytkfqkhaqbmwbz0.jpeg"><a name="habracut"></a></p><br><p> 首先，假设程序<strong>与特定的生态系统相关联</strong> -在我们的例子中，这些是Docker和Kubernetes。 这些项目的整个基础架构都是用Golang编写的。 这将打开对使用Docker，Kubernetes等库的访问。 从支持，开发和完成您的程序的角度来看，使用与主要产品所使用的相同的基础结构会更有利可图。 在这种情况下，所有新功能将立即可用，而您不必用另一种语言重新实现它们。 仅<strong>在我们的特定情况</strong>下<strong>，</strong>这种<strong>情况</strong>才足以就原则上是否需要更改语言以及应该更改哪种语言做出决定。 但是，还有其他优点... </p><br><p> 其次， <strong>易于</strong>在Golang <strong>上安装</strong>应用程序。 您无需在系统中安装Rvm，Ruby，一组gems等，只需下载一个静态二进制文件并使用它即可。 </p><br><p>第三，Golang上<strong>的</strong>程序<strong>速度</strong>更高。 这不是通过任何语言使用正确的体系结构和算法获得的系统速度的显着提高。 但是，从控制台启动程序时会感觉到这种增加。 例如，Ruby中的<code>--help</code>可以在0.8秒内计算出来，而在Golang上可以-0.02秒计算出来。 它只是明显改善了使用该程序的用户体验。 </p><br><p>  <em><strong>注意</strong> ：正如我们博客的普通读者可能会猜到的那样，该文章基于重写<strong>dapp</strong>产品的经验，该产品现在-尚未正式（！）-称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">werf</a> 。</em>  <em>有关更多详细信息，请参见本文结尾。</em> </p><br><p> 很好：您只需拿起并编写与旧脚本代码完全隔离的新代码即可。 但是，立即出现了一些<strong>困难和限制</strong> ，这些<strong>困难和局限性</strong>在于为发展分配的资源和时间： </p><br><ul><li>  Ruby中程序的当前版本一直需要改进和更正： <br><ul><li> 使用时会发生错误，应立即修复； </li><li> 您无法在六个月内冻结新功能的添加，因为 客户/用户通常需要这些功能。 </li></ul></li><li> 同时维护2个代码库既困难又昂贵： <br><ul><li> 考虑到除了该Ruby程序之外其他项目的存在，只有2-3人的团队很少。 </li></ul></li><li> 新版本简介： <br><ul><li> 功能不应显着降低； </li><li> 理想情况下，这应该是无缝的和无缝的。 </li></ul></li></ul><br><p> 需要一个连续的移植过程。 但是，如果将Golang版本开发为独立程序，该怎么办？ </p><br><h2 id="pishem-srazu-na-dvuh-yazykah"> 我们一次用两种语言写 </h2><br><p> 但是，如果您将组件从下往上转移到Golang，该怎么办？ 我们从低层次的事物开始，然后进行抽象。 </p><br><p> 假设您的程序由以下组件组成： </p><br><pre> <code class="plaintext hljs">lib/ config.rb build/ image.rb git_repo/ base.rb local.rb remote.rb docker_registry.rb builder/ base.rb shell.rb ansible.rb stage/ base.rb from.rb before_install.rb git.rb install.rb before_setup.rb setup.rb deploy/ kubernetes/ client.rb manager/ base.rb job.rb deployment.rb pod.rb</code> </pre> <br><h3 id="portirovat-komponent-s-funkciyami"> 具有功能的端口组件 </h3><br><p> 一个简单的案例。 我们采用了一个与其余组件完全隔离的现有组件-例如， <code>config</code> （ <code>lib/config.rb</code> ）。 在此组件中，仅定义了<code>Config::parse</code>函数，该函数将获取配置的路径，读取配置并生成填充的结构。  Golang <code>config</code>和相应的包<code>config</code>上的单独二进制文件将负责其实现： </p><br><pre> <code class="plaintext hljs">cmd/ config/ main.go pkg/ config/ config.go</code> </pre> <br><p>  Golang二进制文件从JSON文件接收参数，并将结果输出到JSON文件。 </p><br><pre> <code class="plaintext hljs">config -args-from-file args.json -res-to-file res.json</code> </pre> <br><p>  <code>config</code>可以将消息输出到stdout / stderr（在我们的Ruby程序中，输出<em>始终</em>转到stdout / stderr，因此未对该功能进行参数化）。 </p><br><p> 调用<code>config</code>二进制文件等效于调用<code>config</code>组件的某些功能。  <code>args.json</code>文件中的参数指示函数的名称及其参数。 在<code>res.json</code>文件的输出中， <code>res.json</code>获得了函数的结果。 如果函数应返回某个类的对象，则该类的<em>对象</em>的数据以JSON序列化形式返回。 </p><br><p> 例如，要调用<code>Config::parse</code>函数，请指定以下<code>args.json</code> ： </p><br><pre> <code class="plaintext hljs">{ "command": "Parse", "configPath": "path-to-config.yaml" }</code> </pre> <br><p> 我们在<code>res.json</code>结果： </p><br><pre> <code class="plaintext hljs">{ "config": { "Images": [{"Name": "nginx"}, {"Name": "rails"}], "From": "ubuntu:16.04" }, }</code> </pre> <br><p> 在<code>config</code>字段中，我们获取以JSON序列化的<code>Config::Config</code>对象的状态。 从这种状态开始，在Ruby中的调用者上，您需要构造一个<code>Config::Config</code>对象。 </p><br><p> 如果<em>提供了</em>错误，二进制文件可以返回以下JSON： </p><br><pre> <code class="plaintext hljs">{ "error": "no such file path-to-config.yaml" }</code> </pre> <br><p>  <code>error</code>字段必须由调用方处理。 </p><br><h4 id="vyzyvaem-golang-iz-ruby"> 从Ruby调用Golang </h4><br><p> 在Ruby方面，我们将<code>Config::parse(config_path)</code>转换为包装器，该包装器调用<code>config</code> ，获取结果，处理所有可能的错误。 这是一个简化的示例Ruby伪代码： </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config_path</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_id</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_random_number</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args_file</span></span></span><span class="hljs-class"> = "</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#{get_tmp_dir}/args.#{call_id}.json" res_file = "#{get_tmp_dir}/res.#{call_id}.json" args_file.write(JSON.dump( "command" =&gt; "Parse", "configPath" =&gt; config_path, )) system("config -args-from-file #{args_file} -res-to-file #{res_file}") raise "config failed with unknown error" if $?.exitstatus != 0 res = JSON.load_file(res_file) raise ParseError, res["error"] if res["error"] return Config.new_from_state(res["config"]) end end</span></span></span></span></code> </pre> <br><p> 二进制文件可能会因非零的意外代码而崩溃-这是一种例外情况。 或使用提供的代码-在这种情况下，我们查看<code>res.json</code>文件中是否存在<code>error</code>和<code>config</code>字段，结果我们从序列化的<code>config</code>字段中返回<code>Config::Config</code>对象。 </p><br><p> 从用户的角度来看， <code>Config::Parse</code>函数没有更改。 </p><br><h3 id="portirovat-komponent-klass"> 端口组件类 </h3><br><p> 例如，使用类层次结构<code>lib/git_repo</code> 。 有2个类： <code>GitRepo::Local</code>和<code>GitRepo::Remote</code> 。 将它们的实现组合在单个<code>git_repo</code>二进制文件中，并因此在Golang中打包<code>git_repo</code>是有意义的。 </p><br><pre> <code class="plaintext hljs">cmd/ git_repo/ main.go pkg/ git_repo/ base.go local.go remote.go</code> </pre> <br><p> 对<code>git_repo</code>二进制文件的调用对应于对<code>GitRepo::Local</code>或<code>GitRepo::Remote</code>对象的某些方法的调用。 对象具有状态，可以在方法调用后更改。 因此，在参数中，我们传递以JSON序列化的当前状态。 在输出中，我们总是获得对象的新状态-也在JSON中。 </p><br><p> 例如，要调用<code>local_repo.commit_exists?(commit)</code>方法，我们指定以下<code>args.json</code> ： </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "method": "IsCommitExists", "commit": "e43b1336d37478282693419e2c3f2d03a482c578" }</code> </pre> <br><p> 输出为<code>res.json</code> ： </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "result": true, }</code> </pre> <br><p> 在<code>localGitRepo</code>字段中，接收到对象的新状态（可能不会更改）。 无论如何，我们必须将此状态放入当前的Ruby对象<code>local_git_repo</code> 。 </p><br><h4 id="vyzyvaem-golang-iz-ruby-1"> 从Ruby调用Golang </h4><br><p> 在Ruby方面，我们将<code>GitRepo::Base</code> ， <code>GitRepo::Local</code> ， <code>GitRepo::Remote</code>每个方法转换为调用<code>git_repo</code>包装器，获取结果，设置<code>GitRepo::Local</code>或<code>GitRepo::Remote</code>类的对象的新状态。 </p><br><p> 否则，一切都类似于调用简单函数。 </p><br><h4 id="kak-byt-s-polimorfizmom-i-bazovymi-klassami"> 如何处理多态和基类 </h4><br><p> 最简单的方法是不支持Golang的多态性。 即 确保始终对<code>git_repo</code>二进制文件的调用始终明确地寻址到特定的实现（如果在参数<code>localGitRepo</code>指定了<code>localGitRepo</code> ，则该调用来自<code>GitRepo::Local</code>类对象；如果指定了<code>remoteGitRepo</code>则来自<code>GitRepo::Remote</code> ），并通过复制少量样板在cmd中的代码。 毕竟，向Golang的迁移完成后， <strong>该代码将被丢弃</strong> 。 </p><br><h4 id="kak-menyat-sostoyanie-drugogo-obekta"> 如何更改另一个对象的状态 </h4><br><p> 在某些情况下，一个对象接收另一个对象作为参数并调用一个隐式更改该第二个对象的状态的方法。 </p><br><p> 在这种情况下，您必须： </p><br><ol><li> 调用二进制文件时，除了调用该方法的对象的序列化状态外，还传输所有参数对象的序列化状态。 </li><li> 调用之后，重置调用该方法的对象的状态，并重置所有作为参数传递的对象的状态。 </li></ol><br><p> 否则，一切都是相似的。 </p><br><h3 id="chto-poluchaetsya"> 怎么了 </h3><br><p> 我们使用一个组件，移植到Golang，发布新版本。 </p><br><p> 如果已经移植了基础组件，并且已转移了使用它们的更高级别的组件，则该<strong>组件可以“吸收”这些基础组件</strong> 。 在这种情况下，相应的多余二进制文件可能已作为不必要的文件而被删除。 </p><br><p> 这一直持续到我们到达最顶层，将<strong>所有底层抽象</strong>粘合在一起。 这将完成第一阶段的移植。 顶层是CLI。 在完全切换到Golang之前，他仍然可以在Ruby上生活一段时间。 </p><br><h2 id="kak-rasprostranyat-etogo-monstra"> 如何分配这个怪物？ </h2><br><p> 好：现在，我们有了一种逐步移植所有组件的方法。 问题：如何用2种语言分发这样的程序？ </p><br><p> 对于Ruby，该程序仍作为Gem安装。 一旦调用二进制文件，它就可以将此依赖项下载到特定的URL（它是硬编码的），并在系统中本地将其缓存（在服务文件中的某个位置）。 </p><br><p> 当我们使用两种语言发布程序的新版本时，我们必须： </p><br><ol><li> 收集所有二进制依赖性并将其上载到特定主机。 </li><li> 创建一个新的Ruby Gem版本。 </li></ol><br><p> 即使某些组件没有更改，每个后续版本的二进制文件也会分别收集。 可以对所有相关二进制文件进行单独的版本控制。 这样就不必为程序的每个新版本收集新的二进制文件。 但是在我们的案例中，我们是从没有时间做非常复杂的事情和优化时间代码这一事实出发的，因此为了简单起见，我们为程序的每个版本收集了单独的二进制文件，这有损于节省下载的空间和时间。 </p><br><h2 id="nedostatki-podhoda"> 该方法的缺点 </h2><br><p> 显然， <code>exec</code>通过<code>system</code> / <code>exec</code>不断调用外部程序的开销。 </p><br><p> 很难<strong>在Golang级别</strong>上<strong>缓存任何全局数据</strong> -毕竟，Golang中的所有数据（例如，包变量）都是在调用方法时创建的，并在完成后死亡。 必须始终牢记这一点。 但是，仍可以<strong>在类实例级别</strong>或<strong>通过将参数显式传递</strong>给外部组件来进行缓存。 </p><br><p> 我们一定不要忘记将<strong>对象</strong>的<strong>状态</strong>转移<strong>到Golang</strong>并在调用后正确还原它。 </p><br><p> 对Golang的二进制依赖<strong>占用了很多空间</strong> 。 只有一个30 MB二进制文件是一回事-Golang上的程序。 另一件事，当您移植〜10个组件（每个组件重30 MB）时， <strong>每个版本</strong>我们将获得300 MB文件。 因此，二进制主机和主机上程序运行并不断更新的空间很快就会消失。 但是，如果您定期删除旧版本，则问题并不严重。 </p><br><p> 还要注意，随着程序的每次更新，下载二进制依赖项都将花费一些时间。 </p><br><h2 id="preimuschestva-podhoda"> 方法的好处 </h2><br><p> 尽管提到了所有缺点，但是这种方法允许您组织一个<strong>连续的过程，以移植到另一种语言</strong>并与一个开发团队一起工作。 </p><br><p> 最重要的优点是能够获得有关新代码的<strong>快速反馈</strong> ，对其进行测试并使其稳定的能力。 </p><br><p> 在这种情况下，除其他外，您可以向程序添加新功能，修复当前版本中的错误。 </p><br><h2 id="kak-sdelat-okonchatelnyy-perevorot-na-golang"> 如何在Golang上进行最终政变 </h2><br><p> 当所有主要组件都转换为Golang并已经在生产中进行测试时，剩下的就是将程序的顶部接口（CLI）重写为Golang并丢弃所有旧的Ruby代码。 </p><br><p> 在此阶段，剩下的只是解决新CLI与旧CLI的兼容性问题。 </p><br><p> 同志们，万岁！ 革命实现了。 </p><br><h2 id="kak-my-perepisali-dapp-na-golang"> 我们如何在Golang上重写dapp </h2><br><p>  Dapp是由Flant开发的用于组织CI / CD流程的实用程序。 由于历史原因，它是用Ruby编写的： </p><br><ul><li> 在Ruby中开发程序的丰富经验。 </li><li> 二手厨师（食谱使用Ruby编写）。 </li><li> 惯性，拒绝为我们认真使用新语言。 </li></ul><br><p> 本文中介绍的方法已应用于在Golang上重写dapp。 下图显示了善（Golang，蓝色）和邪恶（Ruby，红色）之间进行斗争的时间顺序： </p><br><img src="https://habrastorage.org/webt/xc/qg/gy/xcqggyavhbvkewruasv-pgcxbfa.png"><br><p>  <em>Ruby与语言的dapp / werf项目中的代码量</em>  <em>Golang在发行过程中</em> </p><br><p> 目前，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>没有Ruby <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的alpha版本1.0</a> 。 我们也将dapp重命名为werf，但这是另一个故事…… <strong>等待werf 1.0的完整发布！</strong> </p><br><p> 作为此迁移的其他优点以及与臭名昭著的Kubernetes生态系统集成的例证，我们注意到在Golang上重写dapp给了我们创建另一个项目<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubedog</a></strong>的机会。 因此，我们能够将用于跟踪K8s资源的代码分离到一个单独的项目中，这<strong>不仅</strong>在werf中有用，而且在其他项目中也很有用。 对于同一任务，还有其他解决方案<em>（有关详细信息</em> ， <em>请参见我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最近的公告</a> ）</em> ，但是要在没有Go的情况下与它们“竞争”（就受欢迎程度而言），因为它的基础很难实现。 </p><br><h2 id="ps"> 聚苯乙烯 </h2><br><p> 另请参阅我们的博客： </p><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">介绍了用于跟踪Kubernetes资源的kubedog库。</a> ” </li><li>  “我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正式推出了用于维护CI / CD的dapp-DevOps实用程序</a> 。” </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等等：在dapp中支持YAML和Ansible（没有母牛）</a> 。” </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用dapp和GitLab CI在Kubernetes中构建和安装应用程序</a> 。” </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437044/">https://habr.com/ru/post/zh-CN437044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437032/index.html">NGINX ModSecurity安装说明</a></li>
<li><a href="../zh-CN437034/index.html">通用哨子：Snom A230和A210 USB加密狗评论</a></li>
<li><a href="../zh-CN437036/index.html">用于假人的SAPUI5第2部分：完整的分步练习</a></li>
<li><a href="../zh-CN437038/index.html">本杰明·温特贝格Stream API指南翻译</a></li>
<li><a href="../zh-CN437040/index.html">在俄罗斯，开始测试家用神经接口“ Neurochat”</a></li>
<li><a href="../zh-CN437050/index.html">该书“ Python。 快速课程。 第三版。</a></li>
<li><a href="../zh-CN437052/index.html">不要错过学习：大学的IT专家需要吗</a></li>
<li><a href="../zh-CN437054/index.html">新型英特尔第9代处理器：核心减去GPU</a></li>
<li><a href="../zh-CN437056/index.html">Zimbra协作套件和Zextras套件与家用RED OS完全兼容</a></li>
<li><a href="../zh-CN437062/index.html">延迟以及芯片和软件结论长度对计算导体总长度/延迟的影响</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>