<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗞️ 🤸🏾 💝 Inovasi JavaScript: hasil Google I / O 2019. Bagian 1 👨🏾‍🎓 🥘 🔢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Materi, bagian pertama dari terjemahan yang kami terbitkan hari ini, dikhususkan untuk fitur JavaScript standar baru yang dibahas pada konferensi Goog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inovasi JavaScript: hasil Google I / O 2019. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464129/">  Materi, bagian pertama dari terjemahan yang kami terbitkan hari ini, dikhususkan untuk fitur JavaScript standar baru yang dibahas pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google I / O 2019</a> .  Secara khusus, di sini kita akan berbicara tentang ekspresi reguler, tentang bidang kelas, tentang bekerja dengan string. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/h9/k-/lh/h9k-lhwr73vkp2jrbj6onwpliay.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">Pemeriksaan Ekspresi Reguler</font> </h2><br>  Ekspresi reguler (Ekspresi Reguler, singkatnya - RegEx atau RegExp) adalah teknologi pemrosesan string yang kuat yang diimplementasikan dalam banyak bahasa pemrograman.  Ekspresi reguler sangat berguna dalam kasus-kasus di mana Anda perlu, misalnya, untuk mencari fragmen string dengan pola yang kompleks.  Sampai saat ini, implementasi JavaScript dari ekspresi reguler memiliki segalanya kecuali melihat ke belakang. <br><br>  Untuk memahami apa itu pemeriksaan retrospektif, mari kita bicara tentang lookaheads yang sudah didukung dalam JavaScript. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a> <br><a name="habracut"></a><br><h3>  <font color="#3AC1EF">▍ Cek muka</font> </h3><br>  Sintaks pemeriksaan terdepan dalam ekspresi reguler memungkinkan Anda untuk mencari fragmen string ketika diketahui bahwa fragmen lain berada di sebelah kanannya.  Misalnya, saat bekerja dengan string <code>MangoJuice, VanillaShake, GrapeJuice</code> Anda dapat menggunakan sintaks dari pemeriksaan awal positif untuk menemukan kata yang segera diikuti oleh kata <code>Juice</code> .  Dalam kasus kami, ini adalah kata <code>Mango</code> dan <code>Grape</code> . <br><br>  Ada dua jenis cek terkemuka.  Ini adalah lookaheads positif dan lookaheads negatif. <br><br><h4>  Pemeriksaan timah positif </h4><br>  Pemeriksaan awal positif digunakan untuk mencari garis di sebelah kanan yang merupakan garis lain yang sebelumnya diketahui.  Berikut ini sintaks ekspresi reguler yang digunakan untuk pemeriksaan ini: <br><br><pre> <code class="javascript hljs">/[a-zA-Z]+(?=Juice)/</code> </pre> <br>  Template ini memungkinkan Anda untuk memilih kata-kata yang terdiri dari huruf kecil atau huruf besar, diikuti oleh kata <code>Juice</code> .  Jangan bingung antara struktur yang menggambarkan pemeriksaan terkemuka dan retrospektif dengan kelompok tangkap.  Meskipun kondisi pemeriksaan ini ditulis dalam tanda kurung, sistem tidak menangkapnya.  Mari kita lihat contoh pemeriksaan timah positif. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/[a-zA-Z]+(?=Juice)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Mango", "Grape"]</span></span></code> </pre> <br><h4>  Pemeriksaan Timbal Negatif </h4><br>  Jika kami mempertimbangkan, menggunakan baris di atas, mekanisme aksi pemeriksaan negatif, ternyata mereka memungkinkan Anda menemukan kata di sebelah kanan yang tidak ada kata <code>Juice</code> .  Sintaks pemeriksaan awal negatif mirip dengan sintaks pemeriksaan positif.  Namun, ada satu fitur di dalamnya, yaitu simbol <code>=</code> (sama) berubah menjadi simbol <code>!</code>  (tanda seru).  Begini tampilannya: <br><br><pre> <code class="javascript hljs">/[a-zA-Z]+(?!Juice)/</code> </pre> <br>  Ekspresi reguler ini memungkinkan Anda memilih semua kata di sebelah kanan yang tidak ada kata <code>Juice</code> .  Tetapi ketika menerapkan template seperti itu, semua kata dalam baris akan dipilih ( <code>MangoJuice, VanillaShake, GrapeJuice</code> ).  Faktanya adalah bahwa, menurut sistem, tidak ada satu kata pun di sini yang berakhir dengan <code>Juice</code> .  Akibatnya, untuk mencapai hasil yang diinginkan, Anda perlu memperjelas ekspresi reguler dan menulis ulang seperti ini: <br><br><pre> <code class="javascript hljs">/(Mango|Vanilla|Grape)(?!Juice)/</code> </pre> <br>  Dengan menggunakan templat ini, Anda dapat memilih kata <code>Mango</code> , atau <code>Vanilla</code> , atau <code>Grape</code> , setelah itu tidak ada kata <code>Juice</code> .  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(Mango|Vanilla|Grape)(?!Juice)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Vanilla"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Pemeriksaan Retrospektif</font> </h3><br>  Dengan analogi dengan sintaks pemeriksaan terkemuka, sintaks pemeriksaan retrospektif memungkinkan Anda untuk memilih urutan karakter hanya jika di sebelah kiri urutan ini adalah pola yang diberikan.  Misalnya, saat memproses string <code>FrozenBananas, DriedApples, FrozenFish</code> kita dapat menggunakan pemeriksaan retrospektif positif untuk menemukan kata di sebelah kiri yang terdapat kata <code>Frozen</code> .  Dalam kasus kami, kata <code>Bananas</code> dan <code>Fish</code> sesuai dengan kondisi ini. <br><br>  Ada, seperti halnya dengan pemeriksaan terkemuka, pemeriksaan retrospektif positif (terlihat positif di belakang) dan pemeriksaan retrospektif negatif (terlihat negatif atau negatif). <br><br><h4>  Ulasan retrospektif positif </h4><br>  Pemeriksaan retrospektif positif digunakan untuk mencari pola di sebelah kiri yang merupakan pola lainnya.  Berikut adalah contoh sintaks yang digunakan untuk menggambarkan pemeriksaan tersebut: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=Frozen)[a-zA-Z]+</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Simbol <code>&lt;</code> digunakan di sini, yang tidak dalam deskripsi pemeriksaan awal.  Selain itu, kondisi dalam ekspresi reguler terletak tidak di sebelah kanan templat yang menarik bagi kami, tetapi di sebelah kiri.  Menggunakan templat di atas, Anda dapat memilih semua kata yang dimulai dengan <code>Frozen</code> .  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Frozen)[a-zA-Z]+/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Bananas", "Fish"]</span></span></code> </pre> <br><h4>  Pemeriksaan Retrospektif Negatif </h4><br>  Mekanisme pemeriksaan retrospektif negatif memungkinkan Anda mencari pola pada garis di sebelah kiri yang tidak ada pola tertentu.  Misalnya, jika Anda perlu memilih kata-kata yang tidak dimulai dengan <code>Frozen</code> di <code>FrozenBananas, DriedApples, FrozenFish</code> line, Anda dapat mencoba menggunakan ekspresi reguler ini: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">!Frozen)[a-zA-Z]+</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Tapi, karena menggunakan konstruksi ini akan mengarah pada pemilihan semua kata dari string, karena tidak ada yang dimulai dengan <code>Frozen</code> , ekspresi reguler perlu diklarifikasi: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">!Frozen)(Bananas|Apples|Fish)</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Frozen)(Bananas|Apples|Fish)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Apples"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br>  Bagian ini dan bagian serupa lainnya akan memberikan informasi tentang tahap harmonisasi fitur yang dijelaskan JS dalam Komite Teknis 39 (Komite Teknis 39, TC39), yang bertanggung jawab dalam ECMA Internasional untuk mendukung spesifikasi ECMAScript.  Bagian tersebut juga akan memberikan data tentang versi Chrome dan Node.js (dan terkadang pada versi Firefox), dimulai dengan mana Anda dapat menggunakan fitur yang sesuai. <br><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">62+</a> </li><li>  Node: 8.10.0+ </li></ul><br><h2>  <font color="#3AC1EF">Bidang kelas</font> </h2><br>  Bidang kelas adalah konstruk sintaksis baru yang digunakan untuk mendefinisikan properti instance kelas (objek) di luar konstruktor kelas.  Ada dua jenis bidang kelas: bidang kelas publik dan bidang kelas pribadi. <br><br><h3>  <font color="#3AC1EF">Fields Bidang kelas publik</font> </h3><br>  Sampai saat ini, sifat-sifat objek harus didefinisikan di dalam konstruktor kelas.  Properti ini bersifat publik (publik).  Ini berarti bahwa mereka dapat diakses dengan bekerja dengan instance kelas (objek).  Berikut adalah contoh menyatakan properti publik: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'Tommy'</span></span>;    } }</code> </pre> <br>  Ketika itu perlu untuk membuat kelas yang akan memperpanjang kelas induk tertentu, perlu untuk memanggil <code>super()</code> di konstruktor kelas anak.  Ini harus dilakukan sebelum propertinya dapat ditambahkan ke kelas anak.  Begini tampilannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {        <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//  super   `this`          this.sound = 'Woof! Woof!';    }    makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog(); tommy.makeSound(); // Woof! Woof!</span></span></code> </pre> <br>  Berkat kemunculan sintaks bidang publik suatu kelas, dimungkinkan untuk menggambarkan bidang kelas di luar konstruktor.  Sistem akan membuat panggilan implisit ke <code>super()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog(); tommy.makeSound(); // Woof! Woof!</span></span></code> </pre> <br>  Ketika secara implisit memanggil <code>super()</code> , semua argumen yang disediakan oleh pengguna saat membuat instance kelas diteruskan ke dalamnya (ini adalah perilaku standar JavaScript, tidak ada yang istimewa tentang bidang kelas privat).  Jika konstruktor dari kelas induk membutuhkan argumen yang disiapkan dengan cara khusus, Anda perlu memanggil <code>super()</code> sendiri.  Lihatlah hasil panggilan konstruktor implisit dari kelas induk saat membuat turunan dari kelas anak. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( ...args ) {        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'Animal args:'</span></span>, args );    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog( 'Tommy', 'Loves', 'Toys!' ); tommy.makeSound(); // Animal args: [ 'Tommy', 'Loves', 'Toys!' ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Bidang kelas pribadi</font> </h3><br>  Seperti yang Anda ketahui, dalam JavaScript tidak ada pengubah akses ke bidang kelas seperti <code>public</code> , <code>private</code> , atau <code>protected</code> .  Semua properti objek bersifat publik secara default.  Ini berarti bahwa akses ke mereka tidak terbatas.  Hal terdekat untuk membuat properti dari objek yang mirip dengan properti pribadi adalah dengan menggunakan tipe data <code>Symbol</code> .  Ini memungkinkan Anda untuk menyembunyikan properti objek dari dunia luar.  Anda mungkin menggunakan nama properti yang diawali dengan <code>_</code> (garis bawah) untuk menunjukkan bahwa properti yang sesuai harus dianggap dimaksudkan hanya untuk digunakan dalam objek.  Namun, ini hanya semacam pemberitahuan bagi mereka yang akan menggunakan fasilitas ini.  Ini tidak memecahkan masalah pembatasan nyata akses ke properti. <br><br>  Berkat mekanisme bidang privat kelas, dimungkinkan untuk membuat properti kelas hanya dapat diakses di dalam kelas ini.  Ini mengarah pada fakta bahwa mereka tidak dapat diakses dari luar dan bekerja dengan instance kelas (objek).  Ambil contoh sebelumnya dan coba akses properti kelas dari luar, ketika awalan <code>_</code> digunakan. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    _sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//            makeSound() {        console.log( this._sound );    } } //    const tommy = new Dog(); console.log( tommy._sound ); // Woof! Woof!</span></span></code> </pre> <br>  Seperti yang Anda lihat, menggunakan <code>_</code> awalan tidak menyelesaikan masalah kami.  Bidang pribadi kelas dapat dideklarasikan dengan cara yang sama dengan bidang publik, tetapi alih-alih awalan dalam bentuk garis bawah, Anda harus menambahkan awalan dalam bentuk tanda pound ( <code>#</code> ) ke nama mereka.  Upaya akses tidak sah ke properti pribadi objek yang dinyatakan dengan cara ini akan menghasilkan kesalahan berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>: Undefined private field</code> </pre> <br>  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    #sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  -      makeSound() {        console.log( this.#sound );    } } //    const tommy = new Dog(); tommy.makeSound() // Woof! Woof! //console.log( tommy.#sound ); // SyntaxError</span></span></code> </pre> <br>  Perhatikan bahwa properti pribadi hanya dapat diakses dari kelas di mana mereka dinyatakan.  Akibatnya, kelas turunan tidak dapat langsung menggunakan properti serupa dari kelas induk. <br><br>  Bidang pribadi (dan publik) dapat dideklarasikan tanpa menuliskan nilai tertentu ke dalamnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    #name;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( name ) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#name = name;    }    showName() {        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#name );    } } <span class="hljs-comment"><span class="hljs-comment">//    const tommy = new Dog( 'Tommy' ); tommy.showName(); // Tommy</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: 74+ </li><li>  Node: 12+ </li></ul><br><h2>  <font color="#3AC1EF">Metode String .matchAll ()</font> </h2><br>  Prototipe tipe data <code>String</code> memiliki metode <code>.match()</code> yang mengembalikan array fragmen string yang cocok dengan kondisi yang ditentukan oleh ekspresi reguler.  Berikut ini contoh menggunakan metode ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/([A-Z0-9]+)/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( colors.match( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : ["EEE", "CCC", "FAFAFA", "F00", "000"]</span></span></code> </pre> <br>  Ketika menggunakan metode ini, bagaimanapun, tidak ada informasi tambahan yang diberikan (seperti indeks) tentang fragmen string yang ditemukan.  Jika Anda menghapus flag <code>g</code> dari ekspresi reguler yang dilewatkan ke metode <code>.match()</code> , itu akan mengembalikan array yang akan berisi informasi tambahan tentang hasil pencarian.  Namun, dengan pendekatan ini, hanya fragmen pertama dari string yang cocok dengan ekspresi reguler yang akan ditemukan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( colors.match( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"]</span></span></code> </pre> <br>  Untuk mendapatkan sesuatu yang serupa, tetapi untuk beberapa bagian string, Anda harus menggunakan metode ekspresi reguler <code>.exec()</code> .  Konstruksi yang diperlukan untuk ini lebih rumit daripada yang di mana metode string tunggal akan digunakan untuk mendapatkan hasil yang serupa.  Secara khusus, di sini kita memerlukan <code>while</code> yang akan mengeksekusi sampai <code>.exec()</code> mengembalikan <code>null</code> .  Menggunakan pendekatan ini, perlu diingat bahwa <code>.exec()</code> tidak mengembalikan iterator. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/g</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        , // Uncaught ReferenceError: match is not defined while( match = matchColorRegExp.exec( colors ) ) {  console.log( match ); } // : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"] ["#CCC", "CCC", index: 6, input: "&lt;colors&gt;"] ["#FAFAFA", "FAFAFA", index: 12, input: "&lt;colors&gt;"] ["#F00", "F00", index: 21, input: input: "&lt;colors&gt;"] ["#000", "000", index: 27, input: input: "&lt;colors&gt;"]</span></span></code> </pre> <br>  Untuk mengatasi masalah tersebut, kita sekarang dapat menggunakan metode string <code>.matchAll()</code> , yang mengembalikan iterator.  Setiap panggilan ke metode <code>.next()</code> dari iterator ini <code>.next()</code> elemen berikutnya dari hasil pencarian.  Hasilnya, contoh di atas dapat ditulis ulang sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( ...colors.matchAll( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"] ["#CCC", "CCC", index: 6, input: "&lt;colors&gt;"] ["#FAFAFA", "FAFAFA", index: 12, input: "&lt;colors&gt;"] ["#F00", "F00", index: 21, input: input: "&lt;colors&gt;"] ["#000", "000", index: 27, input: input: "&lt;colors&gt;"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tahap 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">73+</a> </li><li>  Node: 12+ </li><li>  Firefox: 67+ </li></ul><br><h2>  <font color="#3AC1EF">Grup Bernama dalam Ekspresi Reguler</font> </h2><br>  Konsep grup dalam implementasi JavaScript dari mekanisme ekspresi reguler sedikit berbeda dari implementasi konsep serupa dalam bahasa lain.  Yaitu, ketika menggunakan JavaScript, template RegEx ditempatkan dalam tanda kurung (kecuali ketika tanda kurung digunakan untuk pemeriksaan retrospektif atau lanjutan), templat menjadi grup. <br><br>  Fragmen string yang ditangkap oleh grup akan tercermin dalam hasil penerapan ekspresi reguler. <br><br>  Pada contoh sebelumnya, Anda bisa melihat bahwa elemen pertama array dengan hasil pencarian adalah elemen yang cocok dengan seluruh ekspresi reguler, dan yang kedua adalah elemen yang sesuai dengan grup.  Berikut ini elemen array ini: <br><br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">"#EEE"</span></span>, <span class="hljs-string"><span class="hljs-string">"EEE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">index</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">input</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;colors&gt;"</span></span>]</code> </pre> <br>  Jika ada beberapa grup dalam ekspresi reguler, maka mereka akan masuk ke hasil pemrosesan string dalam urutan deskripsi mereka dalam ekspresi reguler.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">"My name is John Doe."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/My name is ([az]+) ([az]+)/i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = str.match( matchRegExp );<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result ); <span class="hljs-comment"><span class="hljs-comment">//   result  null -   console.log( { firstName: result[1], lastName: result[2] } ); // : ["My name is John Doe", "John", "Doe", index: 0, input: "My name is John Doe.", groups: undefined] {firstName: "John", lastName: "Doe"}</span></span></code> </pre> <br>  Di sini Anda dapat melihat bahwa baris pertama dari output adalah seluruh baris yang sesuai dengan ekspresi reguler.  Elemen kedua dan ketiga mewakili apa yang ditangkap oleh kelompok. <br><br>  Menggunakan grup yang diberi nama memungkinkan Anda untuk menyimpan apa yang ditangkap <code>groups</code> objek <code>groups</code> , yang nama propertinya bersesuaian dengan nama yang ditetapkan untuk grup. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">"My name is John Doe."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/My name is (?&lt;firstName&gt;[az]+) (?&lt;lastName&gt;[az]+)/i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = str.match( matchRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result.groups ); <span class="hljs-comment"><span class="hljs-comment">// : ["My name is John Doe", "John", "Doe", index: 0, input: "My name is John Doe.", groups: {firstName: "John", lastName: "Doe"}] {firstName: "John", lastName: "Doe"}</span></span></code> </pre> <br>  Perlu dicatat bahwa grup yang diberi nama berfungsi dengan baik bersama dengan metode <code>.matchAll()</code> . <br><br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 4</a> </li><li>  Chrome: 64+ </li><li>  Node: 10+ </li></ul><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Sudahkah Anda menggunakan salah satu inovasi JavaScript yang dijelaskan di sini? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464129/">https://habr.com/ru/post/id464129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464117/index.html">Mengunjungi Vladimir Likhachev, ayah Nikolai Likhachev, lebih dikenal sebagai Chris Kaspersky</a></li>
<li><a href="../id464119/index.html">Frontend Weekly Digest (12 - 18 Agustus 2019)</a></li>
<li><a href="../id464121/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 376 (12 - 18 Agustus 2019)</a></li>
<li><a href="../id464125/index.html">Kisah internet rahasia dalam kebijakan privasi Google 4.000 kata</a></li>
<li><a href="../id464127/index.html">Pengembangan favicon animasi</a></li>
<li><a href="../id464131/index.html">Inovasi JavaScript: hasil Google I / O 2019. Bagian 2</a></li>
<li><a href="../id464133/index.html">Performa bukan hanya tentang CPU: membuat profiler Anda sendiri untuk Python</a></li>
<li><a href="../id464137/index.html">Dukungan teknis Miran: cara kerjanya</a></li>
<li><a href="../id464141/index.html">Fantasi tentang masalah metaclasses di C #</a></li>
<li><a href="../id464143/index.html">Obat kanker pribadi. Bagaimana Gen Pasien Mempengaruhi Keberhasilan Perawatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>