<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòØ ü§Ωüèø üîí C√°lculo de colisi√≥n 2D: Algoritmo de Gilbert-Johnson-Kirti üë®‚Äçüé§ üëèüèø üì∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Acept√© el estudio de los procesos de reconocimiento de colisiones, y esto me llev√≥ al algoritmo Gilbert-Johnson-Keerthi (GJK). 

 Todos los ejemplos d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√°lculo de colisi√≥n 2D: Algoritmo de Gilbert-Johnson-Kirti</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472404/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/837/791/d92837791f7e383147effd9265b24f91.png" alt="imagen"></div><br>  Acept√© el estudio de los procesos de reconocimiento de colisiones, y esto me llev√≥ al algoritmo Gilbert-Johnson-Keerthi (GJK). <br><br>  Todos los ejemplos de c√≥digo en la publicaci√≥n est√°n escritos en TypeScript.  Los ejemplos usan las estructuras que cre√© que no se discuten en detalle en la publicaci√≥n.  Son simples y se pueden ver en el repositorio de GitHub: <br><br><ul><li><code>Vector</code> </li> <li> <code>IShape</code> </li> <li> <code>Collision</code> </li> </ul><br>  Todo el c√≥digo de la publicaci√≥n se almacena en el repositorio de GitHub: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jthomperoo/gjk-ts-implementation</a> <br><br>  La publicaci√≥n fue escrita sobre la base de este art√≠culo y el video recomendado en √©l: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://mollyrocket.com/849</a> </li></ul><br><h2>  Introduccion </h2><br>  GJK es un algoritmo dise√±ado para determinar la intersecci√≥n de dos formas convexas.  Es simple e implementado utilizando una "funci√≥n auxiliar" generalizada que le permite utilizar un enfoque m√°s general; de la misma manera, puede procesar pol√≠gonos y formas que consisten en curvas, por ejemplo, elipses. <br><a name="habracut"></a><br><h2>  Informacion requerida </h2><br><h3>  Suma de Minkowski </h3><br>  GJK usa un concepto llamado la suma de Minkowski.  SM se calcula sumando todos los puntos de dos figuras.  Por ejemplo, tome las dos figuras que se muestran a continuaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/714/175/459/714175459fab7824d38f46a68b1b736d.png"></div><br>  <strong>Figura A (verde):</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  Un </th><th>  B </th><th>  C </th></tr></thead><tbody><tr><td>  (0,1) </td><td>  (1, -1) </td><td>  (-1, -1) </td></tr></tbody></table></div><br>  <strong>Figura B (p√∫rpura):</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  D </th><th>  E </th><th>  F </th></tr></thead><tbody><tr><td>  (0, -1) </td><td>  (1,1) </td><td>  (-1.1) </td></tr></tbody></table></div><br>  Tomando los valores de la figura A y la figura B, podemos calcular la suma de Minkowski: <br><br> <code>A + D = (0,1) + (0,-1) = (0,0) <br> <br> A + E = (0,1) + (1,1) = (1,2) <br> <br> A + F = (0,1) + (-1,1) = (-1,2) <br> <br> B + D = (1,-1) + (0,-1) = (1,-2) <br> <br> B + E = (1,-1) + (1,1) = (2,0) <br> <br> B + F = (1,-1) + (-1,1) = (0,0) <br> <br> C + D = (-1,-1) + (0,-1) = (-1,-2) <br> <br> C + E = (-1,-1) + (1,1) = (0,0) <br> <br> C + F = (-1,-1) + (-1,1) = (-2,0)</code> <br> <br>  Si tomamos estos valores y hacemos un gr√°fico a partir de ellos, veremos qu√© figura ser√° el resultado. <br><br>  <strong>Suma de Minkowski para las figuras A y B:</strong> <br><br>  <em>Tenga en cuenta que AD en la tabla y el gr√°fico corresponde a A + D</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e40/64c/260/e4064c260487a98fb29c87fa43682ec5.png" alt="Gr√°fico de la suma de Minkowski de las formas A y B"></div><br><div class="scrollable-table"><table><thead><tr><th>  AD </th><th>  Ae </th><th>  AF </th><th>  Bd </th><th>  BE </th><th>  Bf </th><th>  CD </th><th>  CE </th><th>  CF </th></tr></thead><tbody><tr><td>  (0,0) </td><td>  (1,2) </td><td>  (-1.2) </td><td>  (1, -2) </td><td>  (2.0) </td><td>  (0,0) </td><td>  (-1, -2) </td><td>  (0,0) </td><td>  (-2.0) </td></tr></tbody></table></div><br>  Para comprender mejor la suma de Minkowski, podemos imaginar que tomamos una figura A y la obviamos con el contorno de una B. La figura resultante ser√° la suma de Minkowski. <br><br><h3>  Diferencia de Minkowski </h3><br>  GJK usa una variaci√≥n de la suma de Minkowski, en la cual no se toma A + B, sino A - B. En las fuentes que le√≠, esto se llama la "Diferencia de Minkowski".  La diferencia de Minkowski tiene una propiedad interesante: si dos figuras se superponen / intersectan, entonces la diferencia de Minkowski resultante contendr√° el origen.  Y esta es la base del algoritmo GJK. <br><br>  Tomando los valores de las figuras A y B, podemos calcular la diferencia de Minkowski: <br><br> <code>A - D = (0,1) - (0,-1) = (0,2) <br> <br> A - E = (0,1) - (1,1) = (-1,0) <br> <br> A - F = (0,1) - (-1,1) = (1,0) <br> <br> B - D = (1,-1) - (0,-1) = (-1,0) <br> <br> B - E = (1,-1) - (1,1) = (0,-2) <br> <br> B - F = (1,-1) - (-1,1) = (2,-2) <br> <br> C - D = (-1,-1) - (0,-1) = (-1,0) <br> <br> C - E = (-1,-1) - (1,1) = (-2,-2) <br> <br> C - F = (-1,-1) - (-1,1) = (0,-2)</code> <br> <br>  Si tomamos estos valores y los colocamos en el gr√°fico, veremos la cifra resultante. <br><br>  <strong>Diferencia de Minkowski para las figuras A y B:</strong> <br><br>  <em>Tenga en cuenta que AD en la tabla y el gr√°fico se refiere a A - D</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/141/a87/b0f141a87c0f42c4c1f64956a8458082.png" alt="Gr√°fico de la suma de Minkowski de las formas A y B"></div><br><div class="scrollable-table"><table><thead><tr><th>  AD </th><th>  Ae </th><th>  AF </th><th>  Bd </th><th>  BE </th><th>  Bf </th><th>  CD </th><th>  CE </th><th>  CF </th></tr></thead><tbody><tr><td>  (0.2) </td><td>  (-1.0) </td><td>  (1,0) </td><td>  (-1.0) </td><td>  (0, -2) </td><td>  (2, -2) </td><td>  (-1.0) </td><td>  (-2, -2) </td><td>  (0, -2) </td></tr></tbody></table></div><br><h2>  Algoritmo </h2><br>  Basado en estos conceptos, el algoritmo GJK los optimiza.  Calcular la suma de Minkowski puede llevar mucho tiempo, especialmente si verifica la intersecci√≥n de dos figuras que consisten en muchos puntos.  Para evitar esto, GJK utiliza dos conceptos clave: funciones auxiliares y s√≠mplex. <br><br><h3>  Funciones de ayuda </h3><br>  Las funciones auxiliares son una forma de muestrear un punto en el borde de la diferencia de Minkowski sin construir la figura completa.  La funci√≥n auxiliar obtiene dos cifras comparadas y la direcci√≥n que debe verificarse.  Luego, la funci√≥n auxiliar recibe de cada figura un punto m√°s alejado de dos direcciones opuestas.  Usando estos dos puntos m√°s distantes, puede calcular el punto auxiliar en la figura de la diferencia de Minkowski.  Tomamos puntos de direcciones opuestas porque obtenemos un punto en la diferencia de Minkowski, lo que nos dar√° el √°rea m√°s grande, es decir, habr√° una mayor probabilidad de que encerremos el origen en la figura.  Dado que la diferencia de Minkowski es el <code>    a -     b</code> , la presencia del punto de la figura b muestreado desde la direcci√≥n opuesta nos dar√° un punto auxiliar lo m√°s lejos posible en esta direcci√≥n. <br><br>  La implementaci√≥n de la funci√≥n auxiliar es bastante simple: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> support(a: IShape, b: IShape, direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFar = a.FarthestPointInDirection(direction); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bFar = b.FarthestPointInDirection(direction.Invert()); return aFar.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(bFar); }</code> </pre> <br>  Una de las ventajas de GJK es que <code>FarthestPointInDirection</code> se puede abstraer y aplicar a pol√≠gonos y curvas.  Aqu√≠ est√° la implementaci√≥n de <code>FarthestPointInDirection</code> para un pol√≠gono. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Polygon implements IShape { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> points: Vector[]; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FarthestPointInDirection(direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> farthestDistance = -Infinity; // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> there are no points, just return point <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> farthestPoint: Vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point of this.points) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceInDirection = point.Dot(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distanceInDirection &gt; farthestDistance) { farthestPoint = point; farthestDistance = distanceInDirection; } } return farthestPoint; } }</code> </pre> <br>  Si desea ver c√≥mo se implementar√°n otras formas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consulte el repositorio de Git de esta publicaci√≥n</a> , que presenta la implementaci√≥n de <code>Circle</code> . <br><br>  As√≠ se calcular√° el punto auxiliar en la direcci√≥n <strong>(1,0)</strong> para las figuras A y B: <br><br><ol><li>  Tome el punto m√°s distante de la figura A;  Resulta ser el punto <strong>B (1, -1)</strong> .  (Puede calcularlo, como lo hace el algoritmo que se muestra arriba, o simplemente verlo mirando el gr√°fico). </li><li>  Tome el punto m√°s distante de la figura B;  Resulta ser el punto <strong>F (-1, 1)</strong> . </li><li>  Calcule <strong>B - F</strong> ;  resulta ser el punto <strong>BF (2, -2)</strong> , ser√° <strong>auxiliar</strong> . </li></ol><br><h3>  S√≠mplex </h3><br>  Un s√≠mplex es una muestra de puntos a lo largo de la figura de diferencia de Minkowski.  Los s√≠mplex pueden contener hasta tres puntos.  GJK los usa, tratando de construir un tri√°ngulo alrededor del origen para determinar la ocurrencia de una colisi√≥n. <br><br><h4>  Construcci√≥n simple </h4><br>  Los s√≠mplex se construyen iterativamente agregando puntos auxiliares en diferentes direcciones.  Cada punto auxiliar debe apuntar en una nueva direcci√≥n, para que podamos construir lo m√°s r√°pido posible un simplex que contenga un punto de origen.  La dificultad radica en elegir la direcci√≥n para obtener el siguiente punto auxiliar. <br><br><h3>  Detecci√≥n de colisi√≥n y selecci√≥n de direcci√≥n </h3><br>  El algoritmo b√°sico simplemente construye un simplex con la ayuda de una funci√≥n auxiliar, tratando de encerrar un punto de origen en la figura.  Podemos entender que no hay colisi√≥n / intersecci√≥n verificando si el punto auxiliar calculado alcanza el origen, y si no lo hace, entonces el origen debe estar fuera de la diferencia de Minkowski;  por lo tanto, podemos decir que no hay colisi√≥n / intersecci√≥n. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Calculate(a: IShape, b: IShape): Collision | undefined { // Build a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> determining <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a collision has occurred <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> simplex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex(); // Choose an arbitrary starting direction <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction: Vector | undefined = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the first support point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> add it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initSupportPoint = support(a, b, direction); simplex.Add(initSupportPoint); // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert(); // Keep iterating until the direction <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined, this will occur when // <span class="hljs-comment"><span class="hljs-comment">'CalculateDirection' doesn't return a direction, indicating that an // intersection has been detected while(direction) { const supportPoint = support(a, b, direction); // If the support point did not reach as far as the origin, // the simplex must not contain the origin and therefore there is no // intersection if (supportPoint.Dot(direction!) &lt;= 0) { // No intersection return; } // Add the simplex and determine a new direction simplex.Add(supportPoint); direction = simplex.CalculateDirection(); } // No direction calculated, intersection detected return new Collision(a, b); }</span></span></code> </pre> <br>  Toda la complejidad y el funcionamiento interno del algoritmo est√°n en <code>simplex.CalculateDirection</code> .  Esta funci√≥n determina si el origen est√° en el simplex actual; de ser as√≠, volver√° <code>undefined</code> ;  de lo contrario, devolver√° una nueva direcci√≥n para obtener un punto auxiliar, que debe agregarse al simplex. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Simplex { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> points: Vector[]; ... CalculateDirection(): Vector | undefined { // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex // C <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the oldest point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a-&gt;b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a-&gt;c lines <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ac = c.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); // Determine perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(c) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return abPerp; } // Determine perpendicular of the a-&gt;c line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> acPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ac.y, -ac.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(b) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { acPerp = acPerp.Invert(); } // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return acPerp; } return undefined; } // Otherwise the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> just a line // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex, // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> the other <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> of the line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a -&gt; b line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face TOWARDS the origin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } return abPerp; } }</code> </pre> <br>  Te preguntar√°s: ¬øpor qu√© no verificamos el segmento BC?  Porque podemos excluir incondicionalmente que el origen es a lo largo de su perpendicular.  Dado que los puntos B y C ya est√°n en el simplex, y no solo se han agregado, sabemos que se verificaron en la iteraci√≥n anterior.  Podr√≠an verificarse como parte de un tri√°ngulo o como un segmento de los primeros dos puntos en un simplex, no importa.  Por lo tanto, podemos omitir con seguridad la comprobaci√≥n del segmento BC. <br><br><h4>  Explicaci√≥n detallada </h4><br>  Tenemos mucho c√≥digo y parece confuso.  A continuaci√≥n analizar√© los pasos del algoritmo para las figuras A y B que se muestran arriba. <br><br>  <strong>Puntos de las figuras A y B:</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  Un </th><th>  B </th><th>  C </th><th>  D </th><th>  E </th><th>  F </th></tr></thead><tbody><tr><td>  (0,1) </td><td>  (1, -1) </td><td>  (-1, -1) </td><td>  (0, -1) </td><td>  (1,1) </td><td>  (-1.1) </td></tr></tbody></table></div><br><ol><li>  Preparaci√≥n del algoritmo;  tomamos <code>(0,1)</code> como la direcci√≥n inicial. <br><br><pre> <code class="vbscript hljs">// Build a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> determining <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a collision has occurred <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> simplex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex(); // Choose an arbitrary starting direction <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction: Vector | undefined = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br></li><li>  Obtenemos el primer punto auxiliar. <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the first support point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> add it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initSupportPoint = support(a, b, direction); simplex.Add(initSupportPoint); // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert();</code> </pre> <br>  Obtenemos el punto m√°s alejado del punto A en la direcci√≥n <code>(0,1)</code> y del punto B en la direcci√≥n <code>(0,-1)</code> . <br><br>  <strong>aFar:</strong> <code>(0,1)</code> y <strong>bFar:</strong> <code>(0,-1)</code> <br><br>  Use estos valores para obtener el punto auxiliar. <br><br>  <strong>Soporte:</strong> <em>aFar-bFar</em> = <code>(0,2)</code> <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> support(a: IShape, b: IShape, direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFar = a.FarthestPointInDirection(direction); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bFar = b.FarthestPointInDirection(direction.Invert()); return aFar.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(bFar); }</code> </pre> <br></li><li>  Volteamos la direcci√≥n del siguiente punto auxiliar y comenzamos la iteraci√≥n, calculando un nuevo punto auxiliar. <br><br>  <strong>Soporte:</strong> <code>(0,-3)</code> <br><br><pre> <code class="vbscript hljs"> // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert(); // Keep iterating until the direction <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined, this will occur when // <span class="hljs-comment"><span class="hljs-comment">'CalculateDirection' doesn't return a direction, indicating that an // intersection has been detected while(direction) { const supportPoint = support(a, b, direction);</span></span></code> </pre> </li><li>  Verifique si el punto auxiliar ha llegado al origen;  si no, no deber√≠a haber intersecci√≥n.  Si ella lleg√≥ al origen, entonces agregue el punto al s√≠mplex. <br><br>  En este caso, el punto auxiliar ha llegado al origen. <br><br>  <strong>direcci√≥n:</strong> <code>(0,-1)</code> <br><br>  <strong>Soporte:</strong> <code>(0,-3)</code> <br><br>  <strong>supportPoint.Dot (direcci√≥n):</strong> <code>3</code> <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the support point did <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reach as far as the origin, // the simplex must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contain the origin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> therefore there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> no // intersection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportPoint.Dot(direction!) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { // No intersection return; } // Add the simplex <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction simplex.Add(supportPoint);</code> </pre> <br></li><li>  En esta etapa, el simplex es un segmento, por lo que no puede contener un punto de origen;  definir una nueva direcci√≥n en la que buscar el punto auxiliar. <br><br><pre> <code class="vbscript hljs"> direction = simplex.CalculateDirection();</code> </pre> <br><ol><li>  Tomamos el √∫ltimo punto agregado al simplex y determinamos la direcci√≥n al origen, este ser√° el rec√≠proco de este punto. <br><br>  <strong>a:</strong> <code>(0,-3)</code> <strong>ao:</strong> <code>(0,3)</code> <br><br><pre> <code class="vbscript hljs"> CalculateDirection(): Vector | undefined { // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) {</code> </pre> </li><li>  Como el simplex es un segmento, no un tri√°ngulo, tomamos el segundo punto del segmento y calculamos el segmento del simplex. <br><br>  <strong>b:</strong> <code>(0,2)</code> <strong>ab:</strong> <code>(0,5)</code> <br><br><pre> <code class="vbscript hljs"> // Otherwise the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> just a line // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex, // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> the other <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> of the line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a -&gt; b line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a);</code> </pre> </li><li>  Calculamos la perpendicular a este segmento y verificamos que se dirija al origen.  Esta ser√° la nueva direcci√≥n para el pr√≥ximo punto auxiliar. <br><br>  <strong>abPerp:</strong> <code>(5, 0)</code> <br><br>  <strong>abPerp.Dot (ao)</strong> <code>0</code> <br><br>  <strong>abPerp:</strong> <code>(-5, 0)</code> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef6/e2d/38d/ef6e2d38de9923b0788d6fb4c21491f3.png" alt="Gr√°fico de la l√≠nea ab y su perpendicular"></div><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face TOWARDS the origin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } return abPerp;</code> </pre> </li></ol></li><li>  Ahora tenemos una direcci√≥n para buscar el siguiente punto auxiliar.  Regresamos al comienzo del ciclo y no salimos de √©l, porque si bien tenemos una direcci√≥n, y la intersecci√≥n a√∫n no se ha encontrado. <br><br>  <strong>direcci√≥n:</strong> <code>(-5, 0)</code> <br><br>  <strong>Soporte:</strong> <code>(-2,-2)</code> <br><br>  <strong>supportPoint.Dot (direcci√≥n):</strong> <code>10</code> <br><br>  El punto auxiliar ha llegado al origen, por lo que no podemos decir que no hay intersecci√≥n. <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(direction) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportPoint = support(a, b, direction); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the support point did <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reach as far as the origin, // the simplex must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contain the origin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> therefore there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> no // intersection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportPoint.Dot(direction!) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { // No intersection return; }</code> </pre> </li><li>  Agregue un nuevo punto auxiliar al simplex, creando un tri√°ngulo.  Este tri√°ngulo puede contener el origen, y si es as√≠, el s√≠mplex volver√° <code>undefined</code> , y no una nueva direcci√≥n para la b√∫squeda. <br><br><pre> <code class="vbscript hljs"> // Add the simplex <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction simplex.Add(supportPoint); direction = simplex.CalculateDirection();</code> </pre> <br><ol><li>  Toma los puntos del simplex del tri√°ngulo. <br>  <strong>a:</strong> <code>(-2,-2)</code> <strong>b:</strong> <code>(0,-3)</code> <strong>c:</strong> <code>(0,2)</code> <strong>ao:</strong> <code>(2,2)</code> <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex // C <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the oldest point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> </li><li>  Tome los segmentos ab y ac. <br><br>  <strong>ab:</strong> <code>(2,-1)</code> <strong>ac:</strong> <code>(2,4)</code> <br><br><pre> <code class="vbscript hljs"> // Determine a-&gt;b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a-&gt;c lines <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ac = c.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a);</code> </pre> </li><li>  Calculamos el perpendicular al segmento ab, dirigido desde el simplex. <br><br>  <strong>abperp:</strong> <code>(-1,-2)</code> <br><br><pre> <code class="vbscript hljs"> // Determine perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(c) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); }</code> </pre> </li><li>  Determinamos si el origen est√° fuera del s√≠mplex m√°s all√° de ab. <br><br>  <strong>abPerp.Dot (ao):</strong> <code>-6</code> <br><br>  El origen no se encuentra fuera del s√≠mplex m√°s all√° de ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/12b/63d/84512b63d57ecf2e9e9a0b833f03d395.png" alt="Gr√°fico de la l√≠nea ab y su perpendicular"></div><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return abPerp; }</code> </pre> </li><li>  Calculamos la perpendicular al segmento ac dirigido desde el simplex. <br><br>  <strong>acPerp:</strong> <code>(-4,2)</code> <br><br><pre> <code class="vbscript hljs"> // Determine perpendicular of the a-&gt;c line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> acPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ac.y, -ac.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(b) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { acPerp = acPerp.Invert(); }</code> </pre> </li><li>  Determine si el origen est√° fuera del s√≠mplex m√°s all√° de ac. <br><br>  <strong>acPerp.Dot (ao):</strong> <code>-4</code> <br><br>  El origen no est√° fuera del s√≠mplex m√°s all√° de ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/f52/962/2d6f52962deaea1aca8a87288d6f1dc6.png" alt="Gr√°fico de la l√≠nea ac y su perpendicular"></div><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return acPerp; }</code> </pre> </li><li>  Dado que AB y AC se verificaron en esta iteraci√≥n, y sabemos que BC se verific√≥ en la iteraci√≥n anterior, el origen debe estar dentro del simplex, por lo que se detect√≥ una colisi√≥n / intersecci√≥n, informando sobre esto, la funci√≥n volver√° <code>undefined</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bab/0de/57f/bab0de57f6848dc95e8cea565a549cc4.png" alt="L√≠neas ab, ac y bc y perpendiculares relevantes"></div></li></ol></li><li>  Como se ha detectado una colisi√≥n, se sale del bucle y se devuelve informaci√≥n de <code>Collision</code> sobre la colisi√≥n entre las dos figuras. <br><br><pre> <code class="vbscript hljs"> direction = simplex.CalculateDirection(); } // No direction calculated, intersection detected return <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collision(a, b);</code> </pre> </li></ol><br><h1>  Conclusi√≥n </h1><br>  Espero que este art√≠culo te ayude a entender el algoritmo GJK.  El algoritmo da una respuesta de s√≠ / no sobre la presencia de un conflicto entre las dos figuras.  Se puede ver un ejemplo de trabajo con pol√≠gonos y c√≠rculos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de esta publicaci√≥n</a> .  Puede expandir este c√≥digo con algoritmos y t√©cnicas adicionales al tratar de obtener la distancia de penetraci√≥n entre las dos figuras, la colisi√≥n normal y el punto de contacto.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n dyn4j</a> tiene enlaces a buenos recursos en varios algoritmos de reconocimiento de colisi√≥n / respuesta;  si quieres expandir GJK, entonces debes estudiarlos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472404/">https://habr.com/ru/post/472404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472388/index.html">Walmart declara guerra de precios en Amazon</a></li>
<li><a href="../472392/index.html">El aumento, la ca√≠da y el posible regreso de los casetes de audio: tratamos los mitos y damos una visi√≥n general de la situaci√≥n</a></li>
<li><a href="../472394/index.html">Evaluar el impacto de la inteligencia artificial en el petr√≥leo y el gas en alta mar</a></li>
<li><a href="../472396/index.html">La vuelta al mundo en 4 segundos en Columnstore (Parte 1)</a></li>
<li><a href="../472402/index.html">Transmisi√≥n de videollamadas RTMP</a></li>
<li><a href="../472406/index.html">Ampliar el centro de datos durante la entrega de pizza</a></li>
<li><a href="../472410/index.html">Dise√±o de sistemas de color disponibles</a></li>
<li><a href="../472412/index.html">Analista de sistemas y m√©tricas de productos: ¬øagitar pero no mezclar?</a></li>
<li><a href="../472414/index.html">La larga historia de los reactores de neutrones r√°pidos y la promesa de un ciclo cerrado de combustible</a></li>
<li><a href="../472416/index.html">ZeroNights Hackquest 2019. Resultados y rese√±as</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>