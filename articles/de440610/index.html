<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô£Ô∏è üë®üèΩ‚Äçüç≥ üéá F√ºhren Sie die statische Analyse in den Prozess ein und suchen Sie damit nicht nur nach Fehlern üèåÔ∏è üë©üèΩ‚Äç‚öñÔ∏è üë©üèø‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine autorisierte √úbersetzung des urspr√ºnglichen Beitrags . Die √úbersetzung wurde mit freundlicher Unterst√ºtzung der Jungs von PVS-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F√ºhren Sie die statische Analyse in den Prozess ein und suchen Sie damit nicht nur nach Fehlern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440610/"> <i>Dieser Artikel ist eine autorisierte √úbersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">urspr√ºnglichen Beitrags</a> .</i>  <i>Die √úbersetzung wurde mit freundlicher Unterst√ºtzung der Jungs von PVS-Studio gemacht.</i>  <i>Danke Jungs!</i> <br><br>  Was mich dazu ermutigt hat, diesen Artikel zu schreiben, ist eine betr√§chtliche Menge an Materialien zur statischen Analyse, die in letzter Zeit zunehmend aufgetaucht sind.  Erstens ist dies ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog von PVS-Studio</a> , das sich aktiv daf√ºr einsetzt, dass Habr Bewertungen von Fehlern ver√∂ffentlicht, die von seinem Tool in Open-Source-Projekten gefunden wurden.  PVS-Studio hat k√ºrzlich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java-Unterst√ºtzung</a> implementiert, und nat√ºrlich konnten sich Entwickler von IntelliJ IDEA, dessen integrierter Analysator heute wahrscheinlich der fortschrittlichste f√ºr Java ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht fernhalten</a> . <br><br>  Wenn ich diese Bewertungen lese, habe ich das Gef√ºhl, dass es sich um ein magisches Elixier handelt: Klicken Sie auf die Schaltfl√§che, und hier ist es - die Liste der Fehler direkt vor Ihren Augen.  Es scheint, dass mit zunehmender Weiterentwicklung der Analyseger√§te immer mehr Fehler gefunden werden und Produkte, die von diesen Robotern gescannt werden, ohne unser Zutun immer besser werden. <br><br>  Nun, aber es gibt keine magischen Elixiere.  Ich m√∂chte dar√ºber sprechen, was in Posts wie "Hier sind Dinge, die unser Roboter finden kann" normalerweise nicht gesprochen wird: Was Analysatoren nicht k√∂nnen, was ihr eigentlicher Teil und Platz im Prozess der Softwarebereitstellung ist und wie sie implementiert werden die Analyse richtig. <br><br><img src="https://habrastorage.org/webt/ey/2o/ta/ey2otantl8aitotp4_lojjuscn4.png" width="500"><br>  <i>Ratsche (Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ).</i> <br><a name="habracut"></a><br><h2>  Was statische Analysatoren niemals k√∂nnen </h2><br>  Was ist die Analyse des Quellcodes aus praktischer Sicht?  Wir nehmen die Quelldateien und erhalten in kurzer Zeit einige Informationen √ºber die Systemqualit√§t (viel k√ºrzer als ein Testlauf).  Die haupts√§chliche und mathematisch un√ºberwindbare Einschr√§nkung besteht darin, dass wir auf diese Weise nur eine sehr begrenzte Teilmenge von Fragen zum analysierten System beantworten k√∂nnen. <br><br>  Das bekannteste Beispiel f√ºr eine Aufgabe, die mit statischer Analyse nicht l√∂sbar ist, ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Halteproblem</a> : Dies ist ein Theorem, das beweist, dass man keinen allgemeinen Algorithmus ausarbeiten kann, der definiert, ob ein Programm mit einem bestimmten Quellcode f√ºr immer geloopt oder abgeschlossen ist das letzte Mal.  Die Erweiterung dieses Theorems ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rice-Theorem</a> , das behauptet, dass f√ºr jede nicht triviale Eigenschaft berechenbarer Funktionen die Frage, ob ein gegebenes Programm eine Funktion mit dieser Eigenschaft berechnet, eine algorithmisch unl√∂sbare Aufgabe ist.  Beispielsweise k√∂nnen Sie keinen Analysator schreiben, der anhand des Quellcodes bestimmt, ob das analysierte Programm eine Implementierung eines bestimmten Algorithmus ist, beispielsweise eines, der das Quadrieren einer Ganzzahl berechnet. <br><br>  Somit weist die Funktionalit√§t von statischen Analysatoren un√ºberwindbare Einschr√§nkungen auf.  Der statische Analysator kann niemals alle F√§lle von beispielsweise "Nullzeiger-Ausnahme" in Sprachen ohne die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leersicherheit erkennen</a> .  Oder erkennen Sie alle Vorkommen von "Attribut nicht gefunden" in dynamisch typisierten Sprachen.  Alles, was der perfekteste statische Analysator tun kann, ist, bestimmte F√§lle zu erfassen.  Die Anzahl von ihnen unter allen m√∂glichen Problemen mit Ihrem Quellcode ist ohne √úbertreibung ein Tropfen auf den hei√üen Stein. <br><br><h2>  Statische Analyse ist keine Suche nach Fehlern </h2><br>  Hier ist eine Schlussfolgerung, die sich aus dem Obigen ergibt: Eine statische Analyse ist nicht der Weg, um die Anzahl der Fehler in einem Programm zu verringern.  Ich w√ºrde Folgendes behaupten: Wenn es zuerst auf Ihr Projekt angewendet wird, findet es "am√ºsante" Stellen im Code, findet aber h√∂chstwahrscheinlich keine M√§ngel, die die Qualit√§t Ihres Programms beeintr√§chtigen. <br><br>  Beispiele f√ºr Fehler, die von Analysatoren automatisch gefunden werden, sind beeindruckend. Wir sollten jedoch nicht vergessen, dass diese Beispiele durch Scannen einer gro√üen Anzahl von Codebasen anhand relativ einfacher Regeln gefunden wurden.  Auf die gleiche Weise finden Hacker, die die M√∂glichkeit haben, mehrere einfache Passw√∂rter f√ºr eine gro√üe Anzahl von Konten auszuprobieren, die Konten schlie√ülich mit einem einfachen Passwort. <br><br>  Bedeutet dies, dass keine statische Analyse erforderlich ist?  Nat√ºrlich nicht!  Es sollte aus demselben Grund angewendet werden, aus dem Sie m√∂glicherweise jedes neue Kennwort in der Stoppliste nicht sicherer Kennw√∂rter √ºberpr√ºfen m√∂chten. <br><br><h2>  Statische Analyse ist mehr als die Suche nach Fehlern </h2><br>  Tats√§chlich sind die Aufgaben, die durch die Analyse in der Praxis gel√∂st werden k√∂nnen, viel umfassender.  Da die statische Analyse im Allgemeinen jede √úberpr√ºfung des Quellcodes darstellt, die vor der Ausf√ºhrung durchgef√ºhrt wird.  Hier sind einige Dinge, die Sie tun k√∂nnen: <br><br><ul><li> Eine √úberpr√ºfung des Codierungsstils im weitesten Sinne dieses Wortes.  Es umfasst sowohl eine √úberpr√ºfung der Formatierung als auch eine Suche nach der Verwendung leerer / unn√∂tiger Klammern, die Festlegung von Schwellenwerten f√ºr Metriken wie die Anzahl der Zeilen / die zyklomatische Komplexit√§t einer Methode usw. - alles Dinge, die die Lesbarkeit und Wartbarkeit von Code erschweren.  In Java repr√§sentiert Checkstyle ein Tool mit einer solchen Funktionalit√§t, in Python - <code>flake8</code> .  Solche Programme werden √ºblicherweise als "Linters" bezeichnet. </li><li>  Es kann nicht nur ausf√ºhrbarer Code analysiert werden.  Ressourcen wie JSON-, YAML-, XML- und <code>.properties</code> Dateien k√∂nnen (und m√ºssen!) Automatisch auf ihre G√ºltigkeit √ºberpr√ºft werden.  Der Grund daf√ºr ist, dass es besser ist, herauszufinden, dass beispielsweise die JSON-Struktur aufgrund der ungepaarten Anf√ºhrungszeichen in der fr√ºhen Phase der automatisierten √úberpr√ºfung einer Pull-Anforderung besch√§digt ist, als dies w√§hrend der Testausf√ºhrung oder zur Laufzeit nicht der Fall ist es?  Es gibt einige relevante Tools, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YAMLlint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSONLint</a> und <code>xmllint</code> . </li><li>  Das Kompilieren (oder Parsen f√ºr dynamische Programmiersprachen) ist auch eine Art statische Analyse.  Normalerweise k√∂nnen Compiler Warnungen ausgeben, die auf Probleme mit der Qualit√§t des Quellcodes hinweisen, und sie sollten nicht ignoriert werden. </li><li>  Manchmal wird die Kompilierung nicht nur auf ausf√ºhrbaren Code angewendet.  Wenn Sie beispielsweise √ºber eine Dokumentation im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AsciiDoctor-</a> Format verf√ºgen und diese dann in HTML / PDF kompilieren, kann das AsciiDoctor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maven-Plugin</a> ) Warnungen ausgeben, z. B. bei fehlerhaften internen Links.  Dies ist ein wichtiger Grund, eine Pull-Anforderung mit Dokumentations√§nderungen nicht zu akzeptieren. </li><li>  Die Rechtschreibpr√ºfung ist auch eine Art statische Analyse.  Das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aspell</a> kann die Rechtschreibung nicht nur in der Dokumentation, sondern auch im Quellcode von Programmen (Kommentare und Literale) in verschiedenen Programmiersprachen wie C / C ++, Java und Python √ºberpr√ºfen.  Ein Rechtschreibfehler in der Benutzeroberfl√§che oder Dokumentation ist ebenfalls ein Fehler! </li><li>  Konfigurationstests stellen tats√§chlich eine Form der statischen Analyse dar, da sie w√§hrend des Ausf√ºhrungsprozesses keinen Quellcode ausf√ºhren, obwohl Konfigurationstests als <code>pytest</code> ausgef√ºhrt werden. </li></ul><br>  Wie wir sehen k√∂nnen, spielt die Suche nach Fehlern in dieser Liste die geringste Rolle, und alles andere ist verf√ºgbar, wenn kostenlose Open-Source-Tools verwendet werden. <br><br>  Welcher dieser statischen Analysetypen sollte in Ihrem Projekt verwendet werden?  Klar, je mehr desto besser!  Wichtig ist hier eine ordnungsgem√§√üe Implementierung, auf die weiter eingegangen wird. <br><br><h2>  Eine Bereitstellungspipeline als mehrstufiger Filter und statische Analyse als erste Stufe </h2><br>  Eine Pipeline mit einem Fluss von √Ñnderungen (von √Ñnderungen des Quellcodes bis zur Lieferung in der Produktion) ist eine klassische Metapher f√ºr die kontinuierliche Integration.  Die Standardsequenz der Stufen dieser Pipeline sieht wie folgt aus: <br><br><ol><li>  statische Analyse </li><li>  Zusammenstellung </li><li>  Unit-Tests </li><li>  Integrationstests </li><li>  UI-Tests </li><li>  manuelle √úberpr√ºfung </li></ol><br>  √Ñnderungen, die in der N-ten Stufe der Pipeline abgelehnt wurden, werden in Stufe N + 1 nicht weitergeleitet. <br><br>  Warum so und nicht anders?  In dem Teil der Pipeline, der sich mit Tests befasst, erkennen Tester die bekannte Testpyramide: <br><br><img src="https://habrastorage.org/webt/hr/41/ut/hr41utwuuzfwoe_3pkr6xm7rcwo.png" width="400"><br>  <i>Testpyramide.</i>  <i>Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Artikel</a> von Martin Fowler.</i> <br><br>  Am Ende dieser Pyramide befinden sich Tests, die einfacher zu schreiben sind, schneller ausgef√ºhrt werden und nicht dazu neigen, falsch positive Ergebnisse zu erzielen.  Daher sollte es mehr davon geben, sie sollten den gr√∂√üten Teil des Codes abdecken und zuerst ausgef√ºhrt werden.  An der Spitze der Pyramide ist die Situation ganz anders, daher sollte die Anzahl der Integrations- und UI-Tests auf das erforderliche Minimum reduziert werden.  Menschen in dieser Kette sind die teuerste, langsamste und unzuverl√§ssigste Ressource. Sie befinden sich also ganz am Ende und erledigen die Arbeit nur, wenn in den vorherigen Schritten keine Fehler festgestellt wurden.  In den Teilen, die nicht mit dem Testen zusammenh√§ngen, wird die Pipeline nach denselben Prinzipien gebaut! <br><br>  Ich m√∂chte die Analogie in Form eines mehrstufigen Systems der Wasserfiltration vorschlagen.  Schmutziges Wasser (√Ñnderungen mit Defekten) wird im Eingang zugef√ºhrt, und als Ausgang ben√∂tigen wir sauberes Wasser, das nicht alle unerw√ºnschten Verunreinigungen enth√§lt. <br><br><img src="https://habrastorage.org/webt/nf/2n/gi/nf2ngidmm_2_aaiye4c52ol0fr0.jpeg" width="400"><br>  <i>Mehrstufiger Filter.</i>  <i>Quelle: <a href="">Wikimedia Commons</a></i> <br><br>  Wie Sie vielleicht wissen, sind Reinigungsfilter so konzipiert, dass in jeder nachfolgenden Stufe Verunreinigungspartikel kleinerer Gr√∂√üe entfernt werden k√∂nnen.  Eingangsstufen der Grobreinigung haben einen h√∂heren Durchsatz und niedrigere Kosten.  In unserer Analogie bedeutet dies, dass Gates mit Eingangsqualit√§t eine h√∂here Leistung aufweisen, weniger Startaufwand erfordern und weniger Betriebskosten verursachen.  Die Rolle der statischen Analyse, die (wie wir jetzt verstehen) nur die schwerwiegendsten M√§ngel beseitigen kann, ist die Rolle des Sumpffilters als erste Stufe der mehrstufigen Reiniger. <br><br>  Die statische Analyse verbessert nicht die Qualit√§t des Endprodukts an sich, genauso wie der "Sumpf" das Wasser nicht trinkbar macht.  In Verbindung mit anderen Pipeline-Elementen ist seine Bedeutung jedoch offensichtlich.  Obwohl in einem mehrstufigen Filter die Ausgangsstufen m√∂glicherweise alles entfernen k√∂nnen, was die Eingangsstufen k√∂nnen, sind wir uns der Konsequenzen bewusst, die sich ergeben, wenn versucht wird, nur mit Stufen der Feinreinigung ohne Eingangsstufen auszukommen. <br><br>  Der Zweck des "Sumpfes" besteht darin, nachfolgende Stufen von der Erfassung sehr grober Defekte zu entlasten.  Beispielsweise sollte eine Person, die eine Code√ºberpr√ºfung durchf√ºhrt, nicht durch falsch formatierte Verst√∂√üe gegen Code- und Codestandards (wie redundante Klammern oder zu tief verschachtelte Verzweigungen) abgelenkt werden.  Fehler wie NPE sollten von den Komponententests erfasst werden. Wenn der Analysator jedoch zuvor anzeigt, dass ein Fehler unvermeidlich auftreten soll, beschleunigt dies die Behebung erheblich. <br><br>  Ich nehme an, es ist jetzt klar, warum statische Analysen die Qualit√§t des Produkts bei gelegentlicher Anwendung nicht verbessern und kontinuierlich angewendet werden m√ºssen, um √Ñnderungen mit schwerwiegenden Fehlern zu filtern.  Die Frage, ob die Anwendung eines statischen Analyseger√§ts die Qualit√§t Ihres Produkts verbessert, entspricht in etwa der Frage: "Wenn wir Wasser aus schmutzigen Teichen entnehmen, wird sich die Trinkqualit√§t verbessern, wenn wir es durch ein Sieb passieren?" <br><br><h2>  Einf√ºhrung in ein Legacy-Projekt </h2><br>  Ein wichtiges praktisches Thema: Wie kann eine statische Analyse im kontinuierlichen Integrationsprozess als "Qualit√§tsgatter" implementiert werden?  Bei automatisierten Tests ist alles klar: Es gibt eine Reihe von Tests. Ein Fehler bei einem dieser Tests ist ein ausreichender Grund zu der Annahme, dass ein Build kein Qualit√§tsgatter passiert hat.  Der Versuch, das Gate anhand der Ergebnisse der statischen Analyse auf die gleiche Weise festzulegen, schl√§gt fehl: Es gibt zu viele Analysewarnungen f√ºr Legacy-Code. Sie m√∂chten nicht alle ignorieren. Andererseits ist es unm√∂glich, die Produktlieferung zu stoppen, nur weil Es enth√§lt Warnungen des Analysators. <br><br>  F√ºr jedes Projekt gibt der Analysator eine gro√üe Anzahl von Warnungen aus, die beim ersten Mal angewendet werden.  Die meisten Warnungen haben nichts mit der ordnungsgem√§√üen Funktion des Produkts zu tun.  Es wird unm√∂glich sein, alle zu reparieren, und viele von ihnen m√ºssen √ºberhaupt nicht repariert werden.  Am Ende wissen wir, dass unser Produkt bereits vor Einf√ºhrung der statischen Analyse funktioniert! <br><br>  Infolgedessen beschr√§nken sich viele Entwickler darauf, gelegentlich statische Analysen zu verwenden oder diese nur im informativen Modus zu verwenden, bei dem beim Erstellen eines Projekts ein Analysebericht abgerufen wird.  Dies ist gleichbedeutend mit dem Fehlen jeglicher Analyse, denn wenn wir bereits viele Warnungen haben, bleibt das Auftreten einer anderen (wie schwerwiegend auch immer) beim √Ñndern des Codes unbemerkt. <br><br>  Hier sind die bekannten Methoden zur Einf√ºhrung von Qualit√§tstoren: <br><br><ul><li>  Festlegen der Begrenzung der Gesamtzahl der Warnungen oder der Anzahl der Warnungen, geteilt durch die Anzahl der Codezeilen.  Es funktioniert schlecht, da ein solches Tor √Ñnderungen mit neuen Fehlern durchl√§sst, bis deren Grenze √ºberschritten wird. </li><li>  Markieren Sie alle alten Warnungen im Code als in einem bestimmten Moment ignoriert und erstellen Sie einen Fehler, wenn neue Warnungen angezeigt werden.  Solche Funktionen k√∂nnen von PVS-Studio und einigen anderen Tools bereitgestellt werden, z. B. Codacy.  Ich habe noch nicht mit PVS-Studio gearbeitet.  Meine Erfahrung mit Codacy besteht darin, dass die Unterscheidung zwischen einem alten und einem neuen Fehler ein komplizierter und nicht immer funktionierender Algorithmus ist, insbesondere wenn sich Dateien erheblich √§ndern oder umbenannt werden.  Meines Wissens k√∂nnte Codacy neue Warnungen in einer Pull-Anfrage √ºbersehen und gleichzeitig eine Pull-Anfrage aufgrund von Warnungen behindern, die nicht mit √Ñnderungen im Code dieser PR zusammenh√§ngen. </li><li>  Meiner Meinung nach ist die effektivste L√∂sung die im Buch " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Continuous Delivery</a> " beschriebene "Ratschen" -Methode.  Die Grundidee ist, dass die Anzahl der Warnungen zur statischen Analyse eine Eigenschaft jeder Version ist und nur solche √Ñnderungen zul√§ssig sind, die die Gesamtzahl der Warnungen nicht erh√∂hen. </li></ul><br><h2>  Ratsche </h2><br>  Es funktioniert folgenderma√üen: <br><br><ol><li>  In der Anfangsphase wird in den Release-Metadaten ein Eintrag zu einer Reihe von Warnungen hinzugef√ºgt, die von den Codeanalysatoren gefunden wurden.  Daher wird beim Erstellen des Hauptzweigs nicht nur "Release 7.0.2" in Ihren Repository-Manager geschrieben, sondern auch "Release 7.0.2, das 100500 Checkstyle-Warnungen enth√§lt".  Wenn Sie den erweiterten Repositorys-Manager (z. B. Artifactory) verwenden, k√∂nnen Sie solche Metadaten zu Ihrer Version problemlos aufbewahren. </li><li>  Beim Erstellen vergleicht jede Pull-Anforderung die Anzahl der resultierenden Warnungen mit ihrer Anzahl in einer aktuellen Version.  Wenn ein PR zu einem Wachstum dieser Zahl f√ºhrt, besteht der Code bei der statischen Analyse kein Qualit√§tsgatter.  Wenn die Anzahl der Warnungen reduziert oder nicht ge√§ndert wird, ist sie erfolgreich. </li><li>  Bei der n√§chsten Ver√∂ffentlichung wird die neu berechnete Nummer erneut in die Metadaten geschrieben. </li></ol><br>  Daher wird die Anzahl der Warnungen langsam aber sicher gegen Null konvergieren.  Nat√ºrlich kann das System get√§uscht werden, indem eine neue Warnung eingef√ºhrt und die einer anderen Person korrigiert wird.  Dies ist normal, da es auf lange Sicht das Ergebnis ergibt: Warnungen werden behoben, normalerweise nicht einzeln, sondern nach Gruppen eines bestimmten Typs, und alle leicht zu l√∂senden Warnungen werden relativ schnell behoben. <br><br>  Diese Grafik zeigt die Gesamtzahl der Checkstyle-Warnungen f√ºr sechs Monate einer solchen "Ratsche" in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem unserer OpenSource-Projekte</a> .  Die Anzahl der Warnungen wurde erheblich reduziert, und dies geschah nat√ºrlich parallel zur Entwicklung des Produkts! <br><br><img src="https://habrastorage.org/webt/ye/wa/u5/yewau5w494aa0vpkaevdydizoqm.png" width="500"><br><br>  Ich wende die ge√§nderte Version dieser Methode an.  Ich z√§hle die Warnungen f√ºr verschiedene Projektmodule und Analysetools separat.  Die dabei gebildete YAML-Datei mit Metadaten zum Build sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">celesta-sql: checkstyle: 434 spotbugs: 45 celesta-core: checkstyle: 206 spotbugs: 13 celesta-maven-plugin: checkstyle: 19 spotbugs: 0 celesta-unit: checkstyle: 0 spotbugs: 0</code> </pre><br>  In jedem fortschrittlichen CI-System kann eine "Ratsche" f√ºr alle statischen Analysetools implementiert werden, ohne auf Plugins und Tools von Drittanbietern angewiesen zu sein.  Jeder der Analysatoren gibt seinen Bericht in einem einfachen Text- oder XML-Format aus, das leicht analysiert werden kann.  Danach m√ºssen Sie nur noch die erforderliche Logik in ein CI-Skript schreiben.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen,</a> wie es in unseren auf Jenkins und Artifactory basierenden Quellprojekten implementiert wird.  Beide Beispiele h√§ngen von der Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ratchetlib ab</a> : Die Methode <code>countWarnings()</code> in √ºblicher Weise XML-Tags in Dateien, die von Checkstyle und Spotbugs generiert wurden, und <code>compareWarningMaps()</code> implementiert <code>compareWarningMaps()</code> diese Ratsche und gibt einen Fehler aus, falls die Anzahl der Warnungen in einer der <code>compareWarningMaps()</code> Die Kategorien nehmen zu. <br><br>  Eine interessante Art der "Ratschen" -Implementierung ist m√∂glich, um die Rechtschreibung von Kommentaren, Textliteralen und Dokumentationen mit Aspell zu analysieren.  Wie Sie vielleicht wissen, sind bei der √úberpr√ºfung der Rechtschreibung nicht alle im Standardw√∂rterbuch unbekannten W√∂rter falsch, sondern k√∂nnen dem benutzerdefinierten W√∂rterbuch hinzugef√ºgt werden.  Wenn Sie ein benutzerdefiniertes W√∂rterbuch zu einem Teil des Quellcode-Projekts machen, kann das Qualit√§tsgatter f√ºr die Rechtschreibung wie folgt formuliert werden: Wenn Sie aspell mit einem Standardw√∂rterbuch und einem benutzerdefinierten W√∂rterbuch ausf√ºhren, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sollten</a> keine Rechtschreibfehler gefunden werden. <br><br><h2>  Die Wichtigkeit des Fixierens der Analyzer-Version </h2><br>  Abschlie√üend muss Folgendes beachtet werden: Unabh√§ngig davon, wie Sie die Analyse in Ihre Lieferpipeline einf√ºhren, muss die Analysatorversion festgelegt werden.  Wenn Sie den Analysator sich spontan aktualisieren lassen, k√∂nnen beim Erstellen einer weiteren Pull-Anforderung neue Fehler auftreten, die sich nicht auf ge√§nderten Code beziehen, sondern auf die Tatsache, dass der neue Analysator einfach mehr Fehler erkennen kann.  Dies unterbricht Ihren Prozess der √úberpr√ºfung von Pull-Anforderungen.  Das Upgrade des Analysators muss eine bewusste Aktion sein.  Auf jeden Fall ist die starre Versionsfixierung jeder Build-Komponente eine allgemeine Anforderung und ein Thema f√ºr ein anderes Thema. <br><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Bei der statischen Analyse werden keine Fehler gefunden und die Qualit√§t Ihres Produkts durch einen einzelnen Durchlauf nicht verbessert.  Nur die kontinuierliche Ausf√ºhrung im Lieferprozess wirkt sich positiv aus. </li><li>  Die Fehlersuche ist √ºberhaupt nicht das Hauptziel der Analyse.  Die √ºberwiegende Mehrheit der n√ºtzlichen Funktionen ist in OpenSource-Tools verf√ºgbar. </li><li>  F√ºhren Sie Qualit√§tsgatter anhand der Ergebnisse der statischen Analyse in der ersten Phase der Lieferpipeline ein, indem Sie die "Ratsche" f√ºr Legacy-Code verwenden. </li></ul><br><h2>  Referenzen </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontinuierliche Lieferung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexey Kudryavtsev: Programmanalyse: Sind Sie ein guter Entwickler?</a>  Bericht √ºber verschiedene Analysemethoden von Code, nicht nur statisch! </li></ol><br><br><hr><br><h2>  Ausz√ºge aus der Diskussion des Originalartikels </h2><br><br>  <b>Evgeniy Ryzhkov</b> <br><br>  Ivan, danke f√ºr den Artikel und daf√ºr, dass er uns bei unserer Arbeit geholfen hat, die Technologie der statischen Code-Analyse bekannt zu machen.  Sie haben absolut Recht, dass Artikel aus dem PVS-Studio-Blog bei unreifen K√∂pfen diese beeinflussen und zu Schlussfolgerungen wie "Ich werde den Code nur einmal √ºberpr√ºfen, die Fehler beheben und das wird reichen" f√ºhren k√∂nnen.  Dies ist mein pers√∂nlicher Schmerz, den ich schon seit einigen Jahren nicht mehr √ºberwinden kann.  Tatsache ist, dass Artikel √ºber Projektpr√ºfungen: <br><br><ol><li>  Verursacht Wow-Effekt bei Menschen.  Die Leute lesen gerne, wie Entwickler solcher Unternehmen wie Google, Epic Games, Microsoft und anderer Unternehmen manchmal scheitern.  Die Leute denken gerne, dass jeder falsch liegen kann, selbst Branchenf√ºhrer machen Fehler.  Leute lesen gerne solche Artikel. </li><li>  Dar√ºber hinaus k√∂nnen Autoren Artikel √ºber den Ablauf schreiben, ohne sich Gedanken machen zu m√ºssen.  Nat√ºrlich m√∂chte ich unsere Leute, die diese Artikel schreiben, nicht beleidigen.  Es ist jedoch viel schwieriger, jedes Mal einen neuen Artikel zu verfassen, als einen Artikel √ºber eine Projektpr√ºfung zu schreiben (ein Dutzend Fehler, ein paar Witze, verwechseln Sie ihn mit Einhornbildern). </li></ol><br>  Sie haben einen sehr guten Artikel geschrieben.  Ich habe auch ein paar Artikel zu diesem Thema.  Haben Sie auch andere Kollegen.  Dar√ºber hinaus besuche ich verschiedene Unternehmen mit einem Bericht zum Thema "Philosophie der statischen Code-Analyse", in dem ich √ºber den Prozess selbst spreche, aber nicht √ºber bestimmte Fehler. <br><br>  Es ist jedoch nicht m√∂glich, 10 Artikel √ºber den Prozess zu schreiben.  Um f√ºr unser Produkt zu werben, m√ºssen wir regelm√§√üig viel schreiben.  Ich m√∂chte ein paar weitere Punkte aus dem Artikel mit einem separaten Kommentar kommentieren, um die Diskussion bequemer zu gestalten. <br><br>  In diesem kurzen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> geht es um die ‚ÄûPhilosophie der statischen Code-Analyse‚Äú, die mein Thema beim Besuch verschiedener Unternehmen ist. <br><br>  <b>Ivan Ponomarev</b> <br>  Evgeniy, vielen Dank f√ºr die informative Bewertung des Artikels!  Ja, Sie haben meine Besorgnis in der Post √ºber die Auswirkungen auf die "unreifen K√∂pfe" absolut richtig bekommen! <br><br>  Hier ist niemand schuld, da die Autoren der Artikel / Berichte √ºber <i>Analyseger√§te</i> nicht darauf abzielen, Artikel / Berichte √ºber die <i>Analyse zu</i> erstellen.  Aber nach ein paar k√ºrzlich ver√∂ffentlichten Beitr√§gen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Andrey2008</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">lany</a> entschied ich, dass ich nicht mehr schweigen konnte. <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Ivan, wie oben geschrieben, werde ich drei Punkte des Artikels kommentieren.  Es bedeutet, dass ich denen zustimme, die ich nicht kommentiere. <br><br>  1. <i>Die Standardsequenz der Stufen dieser Pipeline sieht wie folgt aus ...</i> <br><br>  Ich stimme nicht zu, dass der erste Schritt die statische Analyse ist und nur der zweite die Kompilierung.  Ich glaube, dass die √úberpr√ºfung der Kompilierung im Durchschnitt schneller und logischer ist als eine sofortige "schwerere" statische Analyse.  Wir k√∂nnen diskutieren, wenn Sie anders denken. <br><br>  2. <i>Ich habe noch nicht mit PVS-Studio gearbeitet.</i>  <i>Meine Erfahrung mit Codacy besteht darin, dass die Unterscheidung zwischen einem alten und einem neuen Fehler ein komplizierter und nicht immer funktionierender Algorithmus ist, insbesondere wenn sich Dateien erheblich √§ndern oder umbenannt werden.</i> <br><br>  In PVS-Studio ist es unglaublich praktisch.  Dies ist eines der Hauptmerkmale des Produkts, das in den Artikeln leider nur schwer zu beschreiben ist. Deshalb sind die Leute mit dem Produkt nicht sehr vertraut.  Wir sammeln Informationen √ºber die vorhandenen Fehler in einer Basis.  Und nicht nur "der Dateiname und die Zeile", sondern auch zus√§tzliche Informationen (Raute von drei Zeilen - aktuell, vorher, weiter), damit wir sie im Falle einer Verschiebung des Codefragments immer noch finden k√∂nnen.  Daher verstehen wir bei geringf√ºgigen √Ñnderungen immer noch, dass es sich um einen alten Fehler handelt.  Und der Analysator beschwert sich nicht dar√ºber.  Jetzt kann jemand sagen: "Nun, was ist, wenn sich der Code stark ge√§ndert hat, dann w√ºrde dies nicht funktionieren, und Sie beschweren sich dar√ºber, als w√§re es der neu geschriebene?"  Ja  Wir beschweren uns.  Aber eigentlich ist das neuer Code.  Wenn sich der Code stark ge√§ndert hat, ist dies jetzt ein neuer Code und nicht mehr der alte. <br><br>  Dank dieser Funktion haben wir pers√∂nlich an der Implementierung des Projekts mit 10 Millionen Zeilen C ++ - Code teilgenommen, der jeden Tag von einer Reihe von Entwicklern "ber√ºhrt" wird.  Alles verlief ohne Probleme.  Daher empfehlen wir die Verwendung dieser Funktion von PVS-Studio jedem, der statische Analysen in seinen Prozess einf√ºhrt.  Die Option, die Anzahl der Warnungen gem√§√ü einer Ver√∂ffentlichung festzulegen, scheint mir weniger sympathisch zu sein. <br><br>  3. <i>Unabh√§ngig davon, wie Sie Ihre Lieferpipeline-Analyse einf√ºhren, muss die Analysatorversion festgelegt werden</i> <br><br>  Dem kann ich nicht zustimmen.  Ein definitiver Gegner eines solchen Ansatzes.  Ich empfehle, den Analysator im automatischen Modus zu aktualisieren.  Da f√ºgen wir neue Diagnosen hinzu und verbessern die alten.  Warum?  Zun√§chst erhalten Sie Warnungen vor neuen echten Fehlern.  Zweitens k√∂nnten einige alte Fehlalarme verschwinden, wenn wir sie √ºberwinden. <br><br>  Das Nicht-Aktualisieren des Analysators entspricht dem Nicht-Aktualisieren von Antiviren-Datenbanken (‚ÄûWas passiert, wenn sie √ºber Viren benachrichtigt werden‚Äú).  Wir werden hier nicht auf die wahre N√ºtzlichkeit von Antivirensoftware als Ganzes eingehen. <br><br>  Wenn Sie nach dem Upgrade der Analyzer-Version viele neue Warnungen haben, unterdr√ºcken Sie diese, wie oben beschrieben, √ºber diese Funktion.  Aber nicht um die Version zu aktualisieren ... In der Regel aktualisieren solche Clients (sicher gibt es einige) die Analyseversion jahrelang nicht.  Keine Zeit daf√ºr.  Sie zahlen f√ºr die Lizenzverl√§ngerung, verwenden jedoch nicht die neuen Versionen.  Warum?  Denn einmal haben sie beschlossen, eine Version zu reparieren.  Das Produkt heute und vor drei Jahren ist Tag und Nacht.  Es stellt sich heraus wie "Ich werde das Ticket kaufen, aber nicht kommen". <br><br>  <b>Ivan Ponomarev</b> <br><br>  1. Hier hast du recht.  Ich bin bereit, am Anfang einem Compiler / Parser zuzustimmen, und dies sollte sogar im Artikel ge√§ndert werden!  Zum Beispiel k√∂nnen die ber√ºchtigten <code>spotbugs</code> nicht anders handeln, da sie kompilierten Bytecode analysieren.  Es gibt exotische F√§lle, zum Beispiel in der Pipeline f√ºr Ansible-Playbooks. Eine statische Analyse sollte besser vor dem Parsen festgelegt werden, da sie dort leichter ist.  Aber das ist das Exotische selbst) <br><br>  2. <i>Die Option, die Anzahl der Warnungen gem√§√ü einer Ver√∂ffentlichung festzulegen, scheint f√ºr mich weniger sympathisch zu sein ...</i> - <i>Nun</i> ja, es ist weniger sympathisch, weniger technisch, aber sehr praktisch :-) Hauptsache, es ist eine Allgemeine Methode, mit der ich statische Analysen √ºberall effektiv implementieren kann, selbst im gruseligsten Projekt, mit jeder Codebasis und jedem Analysator (nicht unbedingt Ihrer), unter Verwendung von Groovy- oder Bash-Skripten auf CI.  √úbrigens z√§hlen wir jetzt die Warnungen f√ºr verschiedene Projektmodule und Tools separat, aber wenn wir sie granulierter (f√ºr Dateien) aufteilen, ist dies viel n√§her an der Methode zum Vergleichen neuer / alter.  Aber wir haben uns so gef√ºhlt und ich mochte dieses Ratschen, weil es Entwickler dazu anregt, die Gesamtzahl der Warnungen zu √ºberwachen und diese Anzahl langsam zu verringern.  Wenn wir die Methode der alten / neuen h√§tten, w√ºrde dies die Entwickler motivieren, die Kurve der Warnzahl zu √ºberwachen?  - wahrscheinlich ja, vielleicht nein. <br><br>  Was Punkt 3 betrifft, so ist hier ein echtes Beispiel aus meiner Erfahrung.  Schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Commit an</a> .  Woher kam es?  Wir setzen Linters im TravisCI-Skript.  Sie arbeiteten dort als Qualit√§tstore.  Aber pl√∂tzlich, als eine neue Version von Ansible-lint mehr Warnungen fand, scheiterten einige Pull-Request-Builds aufgrund von Warnungen im Code, die sie nicht ge√§ndert hatten !!!  Am Ende war der Prozess unterbrochen und dringende Pull-Anfragen wurden zusammengef√ºhrt, ohne die Qualit√§tstore zu passieren. <br><br>  Niemand sagt, dass es nicht notwendig ist, die Analysatoren zu aktualisieren.  Nat√ºrlich ist es das!  Wie alle anderen Build-Komponenten.  Aber es muss ein bewusster Prozess sein, der sich im Quellcode widerspiegelt.  Und jedes Mal h√§ngen die Aktionen von den Umst√§nden ab (ob wir die erkannten Warnungen erneut beheben oder nur die "Ratsche" zur√ºcksetzen). <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Wenn ich gefragt werde: "Gibt es eine M√∂glichkeit, jedes Commit in PVS-Studio zu √ºberpr√ºfen?", Antworte ich, dass dies der Fall ist.  Und dann f√ºge hinzu: "Nur um Gottes willen, scheitere nicht am Build, wenn PVS-Studio etwas findet!"  Denn sonst wird PVS-Studio fr√ºher oder sp√§ter als st√∂rend empfunden.  Und es gibt Situationen, in denen es notwendig ist, schnell ein Commit durchzuf√ºhren, anstatt mit den Tools zu k√§mpfen, die das Commit nicht passieren lassen. <br><br>  Meiner Meinung nach ist es in diesem Fall schlecht, den Build nicht zu bestehen.  Es ist gut, Nachrichten an die Autoren des Problemcodes zu senden. <br><br>  <b>Ivan Ponomarev</b> <br>  Meiner Meinung nach gibt es kein "wir m√ºssen uns schnell festlegen".  Dies ist alles nur ein schlechter Prozess.  Ein guter Prozess erzeugt Geschwindigkeit, nicht weil wir ein Prozess- / Qualit√§tsgatter durchbrechen, wenn wir es ‚Äûschnell erledigen‚Äú m√ºssen. <br><br>  Dies widerspricht nicht der Tatsache, dass wir auf einigen Klassen statischer Analyseergebnisse nicht scheitern k√∂nnen.  Es bedeutet nur, dass das Tor so eingerichtet ist, dass bestimmte Arten von Befunden ignoriert werden, und f√ºr andere Befunde haben wir eine Nulltoleranz. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mein Lieblings-Commitstrip zum Thema "schnell".</a> <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Ich bin definitiv ein Gegner des Ansatzes, die alte Analysatorversion zu verwenden.  Was ist, wenn ein Benutzer einen Fehler in dieser Version gefunden hat?  Er schreibt an einen Werkzeugentwickler und ein Werkzeugentwickler wird es sogar reparieren.  Aber in der neuen Version.  F√ºr einige Clients wird niemand die alte Version unterst√ºtzen.  Wenn wir nicht √ºber Vertr√§ge im Wert von Millionen von Dollar sprechen. <br><br>  <b>Ivan Ponomarev</b> <br>  Evgeniy, wir reden √ºberhaupt nicht dar√ºber.  Niemand sagt, wir m√ºssen sie alt halten.  Es geht darum, Versionen von Build-Komponenten-Abh√§ngigkeiten f√ºr ihr kontrolliertes Update zu korrigieren - es ist eine g√§ngige Disziplin, die f√ºr alles gilt, einschlie√ülich Bibliotheken und Tools. <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Ich verstehe, wie "es theoretisch gemacht werden sollte".  Aber ich sehe nur zwei Entscheidungen der Kunden.  Bleib entweder beim neuen oder beim alten.  Wir haben also FAST keine solchen Situationen, in denen ‚Äûwir Disziplin haben und bei zwei Ver√∂ffentlichungen hinter der aktuellen Version zur√ºckbleiben‚Äú.  Es ist nicht wichtig f√ºr mich zu sagen, ob es gut oder schlecht ist.  Ich sage nur, was ich sehe. <br><br>  <b>Ivan Ponomarev</b> <br>  Ich habe es verstanden  Auf jeden Fall h√§ngt alles stark davon ab, √ºber welche Tools / Prozesse Ihre Kunden verf√ºgen und wie sie diese verwenden.  Zum Beispiel wei√ü ich nichts dar√ºber, wie das alles in der C ++ - Welt funktioniert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440610/">https://habr.com/ru/post/de440610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440600/index.html">Wie viele .com-Domainnamen werden nicht verwendet?</a></li>
<li><a href="../de440602/index.html">Mahnwesen mit Kruger, Sokrates und den Wissenskreisen</a></li>
<li><a href="../de440604/index.html">Buchhaltungsmaschinen, IBM 1403, und warum 132 Spalten der Standard f√ºr Drucker sind</a></li>
<li><a href="../de440606/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 286 (vom 11. bis 17. Februar)</a></li>
<li><a href="../de440608/index.html">Die Aufgabe, mit den Augen eines Sch√ºlers zu klassifizieren: das Vorhandensein eines Autos auf dem Parkplatz anhand von Rahmen einer √úberwachungskamera zu bestimmen</a></li>
<li><a href="../de440612/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 5. Anschlie√üen von CISCO-Ger√§ten und IOS-Modi</a></li>
<li><a href="../de440614/index.html">Verkehrssicherheitsprobleme, sortiert nach Punkten</a></li>
<li><a href="../de440616/index.html">Die NASA kauft zwei weitere Sitze auf Sojus, testet den RS-25 und verl√§sst die erdnahe Station nicht</a></li>
<li><a href="../de440618/index.html">Julia und Optimierung</a></li>
<li><a href="../de440620/index.html">Dotfile Madness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>