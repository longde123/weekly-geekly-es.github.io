<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ñ¢Ô∏è üëó üêå Programmation dynamique ou Diviser pour mieux r√©gner üë©üèø‚Äçü§ù‚Äçüë©üèΩ üë®‚Äçüë©‚Äçüëß üõåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article discute des similitudes et des diff√©rences entre les deux approches pour r√©soudre les probl√®mes algorithmiques: la programmation dynamique...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation dynamique ou Diviser pour mieux r√©gner</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423939/"> Cet article discute des similitudes et des diff√©rences entre les deux approches pour r√©soudre les probl√®mes algorithmiques: <b>la programmation</b> dynamique (programmation dynamique) et le principe de <b>¬´diviser pour r√©gner¬ª</b> (diviser et conqu√©rir).  Nous comparerons en utilisant deux algorithmes comme exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la recherche binaire</a> (comment trouver rapidement un nombre dans un tableau tri√©) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la distance de Levenshtein</a> (comment convertir une ligne en une autre avec un nombre minimum d'op√©rations). <br><br>  <i>Je tiens √† noter tout de suite que cette comparaison et explication ne pr√©tend pas √™tre extr√™mement correcte.</i>  <i>Et peut-√™tre m√™me que certains professeurs d'universit√© voudraient m'expulser :) Cet article est juste ma tentative personnelle de trier les choses et de comprendre ce qu'est la programmation dynamique et comment le principe de ¬´diviser pour mieux r√©gner¬ª est impliqu√©.</i> <br><br>  Alors commen√ßons ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="image"><br><a name="habracut"></a><br><h3>  Le probl√®me </h3><br>  Quand j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commenc√© √† √©tudier les algorithmes,</a> il m'√©tait difficile de comprendre l'id√©e de base de la programmation dynamique (ci-apr√®s <b>DP</b> , de Dynamic Programming) et en quoi elle diff√®re de l'approche ¬´diviser pour r√©gner¬ª (plus loin <b>DC</b> , pour diviser et conqu√©rir).  Lorsqu'il s'agit de comparer ces deux paradigmes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beaucoup utilisent avec succ√®s la fonction Fibonacci</a> pour illustrer.  Et c'est une excellente illustration.  Mais il me semble que lorsque nous utilisons <b>la m√™me</b> t√¢che pour illustrer DP et DC, nous perdons un d√©tail important qui peut nous aider √† rattraper plus rapidement la diff√©rence entre les deux approches.  Et ce d√©tail est que ces deux techniques se manifestent le mieux dans la r√©solution de <b>diff√©rents</b> types de probl√®mes. <br><br>  Je suis toujours en train d'apprendre le DP et le DC et je ne peux pas dire que j'ai compl√®tement compris ces concepts.  Mais j'esp√®re toujours que cet article apportera un √©clairage suppl√©mentaire et aidera √† franchir la prochaine √©tape dans l'√©tude d'approches importantes telles que la programmation dynamique et le diviser pour mieux r√©gner. <br><br><h3>  Similitudes entre DP et DC </h3><br>  La fa√ßon dont je vois ces deux concepts maintenant, je peux conclure que <b>DP est une version √©tendue de DC</b> . <br><br>  Je <b>ne les</b> consid√©rerais <b>pas</b> comme quelque chose de compl√®tement diff√©rent.  Parce que ces deux concepts <b>divisent r√©cursivement un probl√®me en deux ou plusieurs sous-probl√®mes du m√™me type</b> jusqu'√† ce que ces sous-probl√®mes soient assez faciles √† r√©soudre directement.  De plus, toutes les solutions au sous-probl√®me sont combin√©es afin de donner finalement une r√©ponse au probl√®me original et original. <br><br>  Alors, pourquoi avons-nous encore deux approches diff√©rentes (DP et DC) et pourquoi j'ai appel√© la programmation dynamique une extension.  En effet, la programmation dynamique peut √™tre appliqu√©e √† des t√¢ches qui pr√©sentent certaines <b>caract√©ristiques et limitations</b> .  Et seulement dans ce cas, DP √©tend DC en <b>utilisant</b> deux techniques: la <b>m√©morisation</b> et la <b>tabulation</b> . <br><br>  Allons un peu plus loin dans les d√©tails ... <br><br><h3>  Limitations et caract√©ristiques n√©cessaires √† une programmation dynamique </h3><br>  Comme nous venons de le d√©couvrir, il existe deux caract√©ristiques cl√©s qu'une t√¢che / un probl√®me doit avoir pour que nous puissions le r√©soudre √† l'aide de la programmation dynamique: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sous-structure optimale</a> - il devrait √™tre possible de composer une solution optimale √† un probl√®me d'une solution optimale √† ses sous-t√¢ches. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sous-probl√®mes crois√©s</a> - le probl√®me doit √™tre d√©compos√© en sous-probl√®mes, qui √† leur tour sont r√©utilis√©s √† plusieurs reprises.  En d'autres termes, une approche r√©cursive pour r√©soudre le probl√®me impliquerait une solution multiple (et <b>non une</b> seule) au m√™me sous-probl√®me, au lieu de produire des sous-probl√®mes nouveaux et uniques dans chaque cycle r√©cursif. </li></ol><br>  D√®s que nous pouvons trouver ces deux caract√©ristiques dans le probl√®me que nous consid√©rons, nous pouvons dire qu'il peut √™tre r√©solu en utilisant la programmation dynamique. <br><br><h3>  La programmation dynamique comme extension du principe de "diviser pour mieux r√©gner" </h3><br>  DP √©tend DC avec l'aide de deux techniques ( <b>m√©morisation</b> et <b>tabulation</b> ), dont le but est de sauvegarder des solutions aux sous-probl√®mes pour leur future r√©utilisation.  Ainsi, les solutions sont mises en cache par sous-probl√®me, ce qui conduit √† une am√©lioration significative des performances de l'algorithme.  Par exemple, la complexit√© temporelle d'une impl√©mentation r√©cursive ¬´na√Øve¬ª de la fonction de Fibonacci est <code>O(2 <sup>n</sup> )</code> .  Dans le m√™me temps, une solution bas√©e sur la programmation dynamique est ex√©cut√©e en seulement <code>(n)</code> . <br><br>  <b>La m√©morisation (remplir le cache de haut en bas)</b> est une technique de mise en cache qui utilise des solutions nouvellement calcul√©es pour les sous-t√¢ches.  La fonction de Fibonacci utilisant la technique de m√©morisation ressemblerait √† ceci: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>La tabulation (remplissage du cache de bas en haut)</b> est une technique similaire, mais qui se concentre principalement sur le remplissage du cache, et non sur la recherche d'une solution au sous-probl√®me.  Le calcul des valeurs qui doivent √™tre mises en cache est plus facile dans ce cas √† effectuer de mani√®re it√©rative, plut√¥t que r√©cursive.  La fonction de Fibonacci utilisant la technique de tabulation ressemblerait √† ceci: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  Vous pouvez en savoir plus sur la comparaison de la m√©morisation et de la tabulation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  L'id√©e principale qui doit √™tre prise dans ces exemples est que puisque nos probl√®mes DC ont des sous-probl√®mes qui se chevauchent, nous pouvons utiliser la mise en cache des solutions aux sous-probl√®mes en utilisant l'une des deux techniques de mise en cache: la m√©morisation et la tabulation. <br><br><h3>  Alors, quelle est la diff√©rence entre DP et DC √† la fin </h3><br>  Nous avons d√©couvert les limites et les conditions pr√©alables √† l'utilisation de la programmation dynamique, ainsi que les techniques de mise en cache utilis√©es dans l'approche DP.  Essayons de r√©sumer et de d√©crire les pens√©es ci-dessus dans l'illustration suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="image"><br><br>  Essayons de r√©soudre quelques probl√®mes en utilisant DP et DC pour d√©montrer ces deux approches en action. <br><br><h3>  Exemple de division et de conqu√™te: recherche binaire </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'</a> algorithme de recherche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">binaire</a> est un algorithme de recherche qui trouve la position de l'√©l√©ment demand√© dans un tableau tri√©.  En recherche binaire, nous comparons la valeur de la variable avec la valeur de l'√©l√©ment au milieu du tableau.  S'ils ne sont pas √©gaux, alors la moiti√© du tableau dans lequel l'√©l√©ment souhait√© ne peut pas √™tre exclu d'une recherche ult√©rieure.  La recherche se poursuit dans la moiti√© du tableau, dans laquelle la variable souhait√©e peut √™tre localis√©e jusqu'√† ce qu'elle soit trouv√©e.  Si la moiti√© suivante du tableau ne contient pas d'√©l√©ments, la recherche est consid√©r√©e comme termin√©e et nous concluons que le tableau ne contient pas la valeur souhait√©e. <br><br>  <b>Exemple</b> <br><br>  L'illustration ci-dessous est un exemple de recherche binaire du nombre 4 dans un tableau. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="image"><br><br>  Repr√©sentons la m√™me logique de recherche, mais sous la forme d'un ¬´arbre de d√©cision¬ª. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="image"><br><br>  Vous pouvez voir dans ce diagramme un principe clair de ¬´diviser pour r√©gner¬ª, utilis√© pour r√©soudre ce probl√®me.  Nous divisons de mani√®re it√©rative notre tableau d'origine en sous-tableaux et essayons de trouver l'√©l√©ment que nous recherchons d√©j√† en eux. <br><br>  Pouvons-nous r√©soudre ce probl√®me en utilisant la programmation dynamique?  <b>Non.</b>  Pour la raison que cette t√¢che <b>ne contient pas de sous-probl√®mes qui se croisent</b> .  Chaque fois que nous divisons un tableau en parties, les deux parties sont compl√®tement ind√©pendantes et ne se chevauchent pas.  Et selon les hypoth√®ses et les limites de la programmation dynamique dont nous avons discut√© ci-dessus, les sous-probl√®mes doivent en quelque sorte se chevaucher, ils <b>doivent √™tre r√©p√©titifs</b> . <br><br>  Habituellement, chaque fois qu'un arbre de d√©cision ressemble exactement √† un <b>arbre</b> (et <b>non √† un graphique</b> ), cela signifie tr√®s probablement qu'il n'y a pas de sous-probl√®mes qui se chevauchent, <br><br>  <b>Impl√©mentation d'algorithme</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> vous pouvez trouver le code source complet de l'algorithme de recherche binaire avec des tests et des explications. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Exemple de programmation dynamique: modification de la distance </h3><br>  Habituellement, lorsqu'il s'agit d'expliquer la programmation dynamique, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction Fibonacci est</a> utilis√©e comme exemple.  Mais dans notre cas, prenons un exemple un peu plus complexe.  Plus il y a d'exemples, plus il est facile de comprendre le concept. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La distance d'√©dition</a> (ou la distance Levenshtein) entre deux lignes est le nombre minimum d'op√©rations pour ins√©rer un caract√®re, supprimer un caract√®re et remplacer un caract√®re par un autre, n√©cessaire pour transformer une ligne en une autre. <br><br>  <b>Exemple</b> <br><br>  Par exemple, la distance d'√©dition entre les mots ¬´chaton¬ª et ¬´assis¬ª est de 3, car vous devez effectuer trois op√©rations d'√©dition (deux remplacements et un insert) afin de convertir une ligne en une autre.  Et il est impossible de trouver une option de conversion plus rapide avec moins d'op√©rations: <br><br><ol><li>  chaton ‚Üí sitten (remplacer ¬´k¬ª par ¬´s¬ª) </li><li>  sitten ‚Üí sittin (en rempla√ßant ¬´e¬ª par ¬´i¬ª) </li><li>  sittin ‚Üí assis (ins√©rer compl√®tement ¬´g¬ª). </li></ol><br>  <b>Application d'algorithme</b> <br><br>  L'algorithme a un large √©ventail d'applications, par exemple pour la v√©rification orthographique, les syst√®mes de correction de reconnaissance optique, la recherche de cha√Æne inexacte, etc. <br><br>  <b>D√©finition math√©matique d'un probl√®me</b> <br><br>  Math√©matiquement, la distance de Levenstein entre deux lignes <code>a, b</code> (respectivement de longueurs | a | et <code>|b|</code> ) est d√©termin√©e par la fonction <code>function lev(|a|, |b|)</code> , o√π: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="image"><br><br>  Veuillez noter que la premi√®re ligne de la fonction <code>min</code> correspond √† l'op√©ration de <b>suppression</b> , la deuxi√®me ligne correspond √† l'op√©ration d' <b>insertion</b> et la troisi√®me ligne correspond √† l'op√©ration de <b>remplacement</b> (dans le cas o√π les lettres ne sont pas √©gales). <br><br>  <b>Explication</b> <br><br>  Essayons de comprendre ce que cette formule nous dit.  Prenons un exemple simple pour trouver la distance de montage minimale entre les lignes <b>ME</b> et <b>MY</b> .  Intuitivement, vous savez d√©j√† que la distance de montage minimale est une ( <b>1</b> ) op√©ration de remplacement (remplacez ¬´E¬ª par ¬´Y¬ª).  Mais formalisons notre solution et transformons-la en une forme algorithmique, afin de pouvoir r√©soudre des versions plus complexes de ce probl√®me, comme la transformation du mot <b>samedi</b> en <b>dimanche</b> . <br><br>  Afin d'appliquer la formule √† la transformation ME ‚Üí MY, nous devons d'abord trouver la distance d'√©dition minimale entre ME ‚Üí M, M ‚Üí MY et M ‚Üí M.  Ensuite, nous devons choisir le minimum de trois distances et y ajouter une op√©ration (+1) de la transformation E ‚Üí Y. <br><br>  On voit donc d√©j√† le caract√®re r√©cursif de cette solution: la distance d'√©dition minimale ME ‚Üí MY est calcul√©e √† partir des trois transformations possibles pr√©c√©dentes.  Ainsi, nous pouvons d√©j√† dire qu'il s'agit d'un algorithme de division et de conqu√™te. <br><br>  Pour expliquer davantage l'algorithme, pla√ßons nos deux lignes dans une matrice: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="image"><br><br>  <b>La cellule (0,1)</b> contient le nombre rouge 1. Cela signifie que nous devons effectuer 1 op√©ration pour convertir M en une cha√Æne vide - supprimer M. Par cons√©quent, nous avons marqu√© ce nombre en rouge. <br><br>  <b>La cellule (0,2)</b> contient un nombre rouge 2. Cela signifie que nous devons effectuer 2 op√©rations afin de transformer la cha√Æne ME en une cha√Æne vide - supprimer E, supprimer M. <br><br>  <b>La cellule (1,0)</b> contient un nombre vert 1. Cela signifie que nous avons besoin d'une op√©ration pour transformer une cha√Æne vide en M - coller M. Nous avons marqu√© l'op√©ration d'insertion en vert. <br><br>  <b>La cellule (2,0)</b> contient un nombre vert 2. Cela signifie que nous devons effectuer 2 op√©rations afin de convertir une cha√Æne vide en une cha√Æne MY - ins√©rer Y, ins√©rer M. <br><br>  <b>La cellule (1,1)</b> contient le nombre 0. Cela signifie que nous n'avons besoin d'aucune op√©ration pour convertir la cha√Æne M en M. <br><br>  <b>La cellule (1,2)</b> contient le num√©ro rouge 1. Cela signifie que nous devons effectuer 1 op√©ration pour transformer la cha√Æne ME en M - supprimer E. <br><br>  Et ainsi de suite ... <br><br>  Cela ne semble pas difficile pour les petites matrices, comme la n√¥tre (seulement 3x3).  Mais comment calculer les valeurs de toutes les cellules pour les grandes matrices (par exemple, pour une matrice 9x7 dans la transformation samedi ‚Üí dimanche)? <br><br>  La bonne nouvelle est que, selon la formule, tout ce dont nous avons besoin pour calculer la valeur de n'importe quelle cellule avec les coordonn√©es <code>(i,j)</code> est juste les valeurs de 3 cellules voisines <code>(i-1,j)</code> , <code>(i-1,j-1)</code> et <code>(i,j-1)</code> .  Tout ce que nous devons faire est de trouver la valeur minimale de trois cellules voisines et d'ajouter un (+1) √† cette valeur si nous avons des lettres diff√©rentes dans la i-√®me ligne et la j-√®me colonne. <br><br>  Encore une fois, vous pouvez clairement voir la nature r√©cursive de cette t√¢che. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="image"><br><br>  Nous avons √©galement vu que nous avions affaire √† une t√¢che de division et de conqu√™te.  Mais, pouvons-nous appliquer une programmation dynamique pour r√©soudre ce probl√®me?  Cette t√¢che satisfait-elle aux conditions de ¬´ <b>probl√®mes crois√©s</b> ¬ª et de ¬´ <b>sous-structures optimales</b> ¬ª mentionn√©es ci-dessus?  <b>Oui</b>  Construisons un arbre de d√©cision. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="image"><br><br>  Tout d'abord, vous remarquerez peut-√™tre que notre arbre de d√©cision ressemble plus √† un <b>graphique de d√©cision</b> <b>qu'√†</b> un <b>arbre</b> .  Vous pouvez √©galement remarquer <b>plusieurs sous-t√¢ches qui se chevauchent</b> .  On voit √©galement qu'il est impossible de r√©duire le nombre d'op√©rations et de le rendre inf√©rieur au nombre d'op√©rations de ces trois cellules voisines (sous-probl√®mes). <br><br>  Vous pouvez √©galement remarquer que la valeur de chaque cellule est calcul√©e en fonction des valeurs pr√©c√©dentes.  Ainsi, dans ce cas, la technique de <b>tabulation</b> est utilis√©e (remplissage du cache dans le sens ascendant).  Vous le verrez dans l'exemple de code ci-dessous. <br><br>  En appliquant tous ces principes, nous pouvons r√©soudre des probl√®mes plus complexes, par exemple, la t√¢che de transformation samedi ‚Üí dimanche: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="image"><br><br>  <b>Exemple de code</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> vous pouvez trouver une solution compl√®te pour trouver la distance de montage minimale avec des tests et des explications: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  Conclusions </h3><br>  Dans cet article, nous avons compar√© deux approches algorithmiques (¬´programmation dynamique¬ª et ¬´diviser pour mieux r√©gner¬ª) pour r√©soudre des probl√®mes.  Nous avons constat√© que la programmation dynamique utilise le principe de ¬´diviser pour mieux r√©gner¬ª et peut √™tre appliqu√©e √† la r√©solution de probl√®mes si le probl√®me contient des sous-probl√®mes entrecrois√©s et la sous-structure optimale (comme c'est le cas avec la distance de Levenshtein).  La programmation dynamique utilise en outre des techniques de m√©morisation et de tabulation pour pr√©server les sous-r√©solutions pour une r√©utilisation ult√©rieure. <br><br>  J'esp√®re que cet article a clarifi√© plut√¥t que compliqu√© la situation pour ceux d'entre vous qui essayaient de traiter des concepts aussi importants que la programmation dynamique et ¬´diviser pour mieux r√©gner¬ª :) <br><br>  Vous pouvez trouver plus d'exemples algorithmiques utilisant la programmation dynamique, avec des tests et des explications dans le r√©f√©rentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript Algorithms and Data Structures</a> . <br><br>  Codage r√©ussi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423939/">https://habr.com/ru/post/fr423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423927/index.html">10 moteurs de recherche prometteurs pour am√©liorer le r√©f√©rencement</a></li>
<li><a href="../fr423931/index.html">Comment contourner l'authentification SMS lors de la connexion aux r√©seaux Wi-Fi publics?</a></li>
<li><a href="../fr423933/index.html">S√©curit√© de Microsoft Office: objets int√©gr√©s</a></li>
<li><a href="../fr423935/index.html">Embox r√©pond aux questions les plus courantes du festival TechTrain IT</a></li>
<li><a href="../fr423937/index.html">El√©vation de privil√®ges Windows</a></li>
<li><a href="../fr423941/index.html">Rapports d'iOS mitap Redmadrobot</a></li>
<li><a href="../fr423943/index.html">Optimisation des prix de d√©tail hors ligne</a></li>
<li><a href="../fr423945/index.html">La Cour supr√™me a pr√©cis√© la proc√©dure √† suivre pour examiner les cas de reposts et de likes</a></li>
<li><a href="../fr423947/index.html">Nos donn√©es personnelles ne vous co√ªtent rien</a></li>
<li><a href="../fr423949/index.html">Un univers conforme √† nos croyances actuelles peut ne pas √™tre possible.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>