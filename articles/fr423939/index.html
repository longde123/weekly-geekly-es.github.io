<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>™️ 👗 🐌 Programmation dynamique ou Diviser pour mieux régner 👩🏿‍🤝‍👩🏽 👨‍👩‍👧 🛌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article discute des similitudes et des différences entre les deux approches pour résoudre les problèmes algorithmiques: la programmation dynamique...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation dynamique ou Diviser pour mieux régner</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423939/"> Cet article discute des similitudes et des différences entre les deux approches pour résoudre les problèmes algorithmiques: <b>la programmation</b> dynamique (programmation dynamique) et le principe de <b>«diviser pour régner»</b> (diviser et conquérir).  Nous comparerons en utilisant deux algorithmes comme exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la recherche binaire</a> (comment trouver rapidement un nombre dans un tableau trié) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la distance de Levenshtein</a> (comment convertir une ligne en une autre avec un nombre minimum d'opérations). <br><br>  <i>Je tiens à noter tout de suite que cette comparaison et explication ne prétend pas être extrêmement correcte.</i>  <i>Et peut-être même que certains professeurs d'université voudraient m'expulser :) Cet article est juste ma tentative personnelle de trier les choses et de comprendre ce qu'est la programmation dynamique et comment le principe de «diviser pour mieux régner» est impliqué.</i> <br><br>  Alors commençons ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="image"><br><a name="habracut"></a><br><h3>  Le problème </h3><br>  Quand j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commencé à étudier les algorithmes,</a> il m'était difficile de comprendre l'idée de base de la programmation dynamique (ci-après <b>DP</b> , de Dynamic Programming) et en quoi elle diffère de l'approche «diviser pour régner» (plus loin <b>DC</b> , pour diviser et conquérir).  Lorsqu'il s'agit de comparer ces deux paradigmes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beaucoup utilisent avec succès la fonction Fibonacci</a> pour illustrer.  Et c'est une excellente illustration.  Mais il me semble que lorsque nous utilisons <b>la même</b> tâche pour illustrer DP et DC, nous perdons un détail important qui peut nous aider à rattraper plus rapidement la différence entre les deux approches.  Et ce détail est que ces deux techniques se manifestent le mieux dans la résolution de <b>différents</b> types de problèmes. <br><br>  Je suis toujours en train d'apprendre le DP et le DC et je ne peux pas dire que j'ai complètement compris ces concepts.  Mais j'espère toujours que cet article apportera un éclairage supplémentaire et aidera à franchir la prochaine étape dans l'étude d'approches importantes telles que la programmation dynamique et le diviser pour mieux régner. <br><br><h3>  Similitudes entre DP et DC </h3><br>  La façon dont je vois ces deux concepts maintenant, je peux conclure que <b>DP est une version étendue de DC</b> . <br><br>  Je <b>ne les</b> considérerais <b>pas</b> comme quelque chose de complètement différent.  Parce que ces deux concepts <b>divisent récursivement un problème en deux ou plusieurs sous-problèmes du même type</b> jusqu'à ce que ces sous-problèmes soient assez faciles à résoudre directement.  De plus, toutes les solutions au sous-problème sont combinées afin de donner finalement une réponse au problème original et original. <br><br>  Alors, pourquoi avons-nous encore deux approches différentes (DP et DC) et pourquoi j'ai appelé la programmation dynamique une extension.  En effet, la programmation dynamique peut être appliquée à des tâches qui présentent certaines <b>caractéristiques et limitations</b> .  Et seulement dans ce cas, DP étend DC en <b>utilisant</b> deux techniques: la <b>mémorisation</b> et la <b>tabulation</b> . <br><br>  Allons un peu plus loin dans les détails ... <br><br><h3>  Limitations et caractéristiques nécessaires à une programmation dynamique </h3><br>  Comme nous venons de le découvrir, il existe deux caractéristiques clés qu'une tâche / un problème doit avoir pour que nous puissions le résoudre à l'aide de la programmation dynamique: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sous-structure optimale</a> - il devrait être possible de composer une solution optimale à un problème d'une solution optimale à ses sous-tâches. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sous-problèmes croisés</a> - le problème doit être décomposé en sous-problèmes, qui à leur tour sont réutilisés à plusieurs reprises.  En d'autres termes, une approche récursive pour résoudre le problème impliquerait une solution multiple (et <b>non une</b> seule) au même sous-problème, au lieu de produire des sous-problèmes nouveaux et uniques dans chaque cycle récursif. </li></ol><br>  Dès que nous pouvons trouver ces deux caractéristiques dans le problème que nous considérons, nous pouvons dire qu'il peut être résolu en utilisant la programmation dynamique. <br><br><h3>  La programmation dynamique comme extension du principe de "diviser pour mieux régner" </h3><br>  DP étend DC avec l'aide de deux techniques ( <b>mémorisation</b> et <b>tabulation</b> ), dont le but est de sauvegarder des solutions aux sous-problèmes pour leur future réutilisation.  Ainsi, les solutions sont mises en cache par sous-problème, ce qui conduit à une amélioration significative des performances de l'algorithme.  Par exemple, la complexité temporelle d'une implémentation récursive «naïve» de la fonction de Fibonacci est <code>O(2 <sup>n</sup> )</code> .  Dans le même temps, une solution basée sur la programmation dynamique est exécutée en seulement <code>(n)</code> . <br><br>  <b>La mémorisation (remplir le cache de haut en bas)</b> est une technique de mise en cache qui utilise des solutions nouvellement calculées pour les sous-tâches.  La fonction de Fibonacci utilisant la technique de mémorisation ressemblerait à ceci: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>La tabulation (remplissage du cache de bas en haut)</b> est une technique similaire, mais qui se concentre principalement sur le remplissage du cache, et non sur la recherche d'une solution au sous-problème.  Le calcul des valeurs qui doivent être mises en cache est plus facile dans ce cas à effectuer de manière itérative, plutôt que récursive.  La fonction de Fibonacci utilisant la technique de tabulation ressemblerait à ceci: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  Vous pouvez en savoir plus sur la comparaison de la mémorisation et de la tabulation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  L'idée principale qui doit être prise dans ces exemples est que puisque nos problèmes DC ont des sous-problèmes qui se chevauchent, nous pouvons utiliser la mise en cache des solutions aux sous-problèmes en utilisant l'une des deux techniques de mise en cache: la mémorisation et la tabulation. <br><br><h3>  Alors, quelle est la différence entre DP et DC à la fin </h3><br>  Nous avons découvert les limites et les conditions préalables à l'utilisation de la programmation dynamique, ainsi que les techniques de mise en cache utilisées dans l'approche DP.  Essayons de résumer et de décrire les pensées ci-dessus dans l'illustration suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="image"><br><br>  Essayons de résoudre quelques problèmes en utilisant DP et DC pour démontrer ces deux approches en action. <br><br><h3>  Exemple de division et de conquête: recherche binaire </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'</a> algorithme de recherche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">binaire</a> est un algorithme de recherche qui trouve la position de l'élément demandé dans un tableau trié.  En recherche binaire, nous comparons la valeur de la variable avec la valeur de l'élément au milieu du tableau.  S'ils ne sont pas égaux, alors la moitié du tableau dans lequel l'élément souhaité ne peut pas être exclu d'une recherche ultérieure.  La recherche se poursuit dans la moitié du tableau, dans laquelle la variable souhaitée peut être localisée jusqu'à ce qu'elle soit trouvée.  Si la moitié suivante du tableau ne contient pas d'éléments, la recherche est considérée comme terminée et nous concluons que le tableau ne contient pas la valeur souhaitée. <br><br>  <b>Exemple</b> <br><br>  L'illustration ci-dessous est un exemple de recherche binaire du nombre 4 dans un tableau. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="image"><br><br>  Représentons la même logique de recherche, mais sous la forme d'un «arbre de décision». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="image"><br><br>  Vous pouvez voir dans ce diagramme un principe clair de «diviser pour régner», utilisé pour résoudre ce problème.  Nous divisons de manière itérative notre tableau d'origine en sous-tableaux et essayons de trouver l'élément que nous recherchons déjà en eux. <br><br>  Pouvons-nous résoudre ce problème en utilisant la programmation dynamique?  <b>Non.</b>  Pour la raison que cette tâche <b>ne contient pas de sous-problèmes qui se croisent</b> .  Chaque fois que nous divisons un tableau en parties, les deux parties sont complètement indépendantes et ne se chevauchent pas.  Et selon les hypothèses et les limites de la programmation dynamique dont nous avons discuté ci-dessus, les sous-problèmes doivent en quelque sorte se chevaucher, ils <b>doivent être répétitifs</b> . <br><br>  Habituellement, chaque fois qu'un arbre de décision ressemble exactement à un <b>arbre</b> (et <b>non à un graphique</b> ), cela signifie très probablement qu'il n'y a pas de sous-problèmes qui se chevauchent, <br><br>  <b>Implémentation d'algorithme</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> vous pouvez trouver le code source complet de l'algorithme de recherche binaire avec des tests et des explications. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Exemple de programmation dynamique: modification de la distance </h3><br>  Habituellement, lorsqu'il s'agit d'expliquer la programmation dynamique, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction Fibonacci est</a> utilisée comme exemple.  Mais dans notre cas, prenons un exemple un peu plus complexe.  Plus il y a d'exemples, plus il est facile de comprendre le concept. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La distance d'édition</a> (ou la distance Levenshtein) entre deux lignes est le nombre minimum d'opérations pour insérer un caractère, supprimer un caractère et remplacer un caractère par un autre, nécessaire pour transformer une ligne en une autre. <br><br>  <b>Exemple</b> <br><br>  Par exemple, la distance d'édition entre les mots «chaton» et «assis» est de 3, car vous devez effectuer trois opérations d'édition (deux remplacements et un insert) afin de convertir une ligne en une autre.  Et il est impossible de trouver une option de conversion plus rapide avec moins d'opérations: <br><br><ol><li>  chaton → sitten (remplacer «k» par «s») </li><li>  sitten → sittin (en remplaçant «e» par «i») </li><li>  sittin → assis (insérer complètement «g»). </li></ol><br>  <b>Application d'algorithme</b> <br><br>  L'algorithme a un large éventail d'applications, par exemple pour la vérification orthographique, les systèmes de correction de reconnaissance optique, la recherche de chaîne inexacte, etc. <br><br>  <b>Définition mathématique d'un problème</b> <br><br>  Mathématiquement, la distance de Levenstein entre deux lignes <code>a, b</code> (respectivement de longueurs | a | et <code>|b|</code> ) est déterminée par la fonction <code>function lev(|a|, |b|)</code> , où: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="image"><br><br>  Veuillez noter que la première ligne de la fonction <code>min</code> correspond à l'opération de <b>suppression</b> , la deuxième ligne correspond à l'opération d' <b>insertion</b> et la troisième ligne correspond à l'opération de <b>remplacement</b> (dans le cas où les lettres ne sont pas égales). <br><br>  <b>Explication</b> <br><br>  Essayons de comprendre ce que cette formule nous dit.  Prenons un exemple simple pour trouver la distance de montage minimale entre les lignes <b>ME</b> et <b>MY</b> .  Intuitivement, vous savez déjà que la distance de montage minimale est une ( <b>1</b> ) opération de remplacement (remplacez «E» par «Y»).  Mais formalisons notre solution et transformons-la en une forme algorithmique, afin de pouvoir résoudre des versions plus complexes de ce problème, comme la transformation du mot <b>samedi</b> en <b>dimanche</b> . <br><br>  Afin d'appliquer la formule à la transformation ME → MY, nous devons d'abord trouver la distance d'édition minimale entre ME → M, M → MY et M → M.  Ensuite, nous devons choisir le minimum de trois distances et y ajouter une opération (+1) de la transformation E → Y. <br><br>  On voit donc déjà le caractère récursif de cette solution: la distance d'édition minimale ME → MY est calculée à partir des trois transformations possibles précédentes.  Ainsi, nous pouvons déjà dire qu'il s'agit d'un algorithme de division et de conquête. <br><br>  Pour expliquer davantage l'algorithme, plaçons nos deux lignes dans une matrice: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="image"><br><br>  <b>La cellule (0,1)</b> contient le nombre rouge 1. Cela signifie que nous devons effectuer 1 opération pour convertir M en une chaîne vide - supprimer M. Par conséquent, nous avons marqué ce nombre en rouge. <br><br>  <b>La cellule (0,2)</b> contient un nombre rouge 2. Cela signifie que nous devons effectuer 2 opérations afin de transformer la chaîne ME en une chaîne vide - supprimer E, supprimer M. <br><br>  <b>La cellule (1,0)</b> contient un nombre vert 1. Cela signifie que nous avons besoin d'une opération pour transformer une chaîne vide en M - coller M. Nous avons marqué l'opération d'insertion en vert. <br><br>  <b>La cellule (2,0)</b> contient un nombre vert 2. Cela signifie que nous devons effectuer 2 opérations afin de convertir une chaîne vide en une chaîne MY - insérer Y, insérer M. <br><br>  <b>La cellule (1,1)</b> contient le nombre 0. Cela signifie que nous n'avons besoin d'aucune opération pour convertir la chaîne M en M. <br><br>  <b>La cellule (1,2)</b> contient le numéro rouge 1. Cela signifie que nous devons effectuer 1 opération pour transformer la chaîne ME en M - supprimer E. <br><br>  Et ainsi de suite ... <br><br>  Cela ne semble pas difficile pour les petites matrices, comme la nôtre (seulement 3x3).  Mais comment calculer les valeurs de toutes les cellules pour les grandes matrices (par exemple, pour une matrice 9x7 dans la transformation samedi → dimanche)? <br><br>  La bonne nouvelle est que, selon la formule, tout ce dont nous avons besoin pour calculer la valeur de n'importe quelle cellule avec les coordonnées <code>(i,j)</code> est juste les valeurs de 3 cellules voisines <code>(i-1,j)</code> , <code>(i-1,j-1)</code> et <code>(i,j-1)</code> .  Tout ce que nous devons faire est de trouver la valeur minimale de trois cellules voisines et d'ajouter un (+1) à cette valeur si nous avons des lettres différentes dans la i-ème ligne et la j-ème colonne. <br><br>  Encore une fois, vous pouvez clairement voir la nature récursive de cette tâche. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="image"><br><br>  Nous avons également vu que nous avions affaire à une tâche de division et de conquête.  Mais, pouvons-nous appliquer une programmation dynamique pour résoudre ce problème?  Cette tâche satisfait-elle aux conditions de « <b>problèmes croisés</b> » et de « <b>sous-structures optimales</b> » mentionnées ci-dessus?  <b>Oui</b>  Construisons un arbre de décision. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="image"><br><br>  Tout d'abord, vous remarquerez peut-être que notre arbre de décision ressemble plus à un <b>graphique de décision</b> <b>qu'à</b> un <b>arbre</b> .  Vous pouvez également remarquer <b>plusieurs sous-tâches qui se chevauchent</b> .  On voit également qu'il est impossible de réduire le nombre d'opérations et de le rendre inférieur au nombre d'opérations de ces trois cellules voisines (sous-problèmes). <br><br>  Vous pouvez également remarquer que la valeur de chaque cellule est calculée en fonction des valeurs précédentes.  Ainsi, dans ce cas, la technique de <b>tabulation</b> est utilisée (remplissage du cache dans le sens ascendant).  Vous le verrez dans l'exemple de code ci-dessous. <br><br>  En appliquant tous ces principes, nous pouvons résoudre des problèmes plus complexes, par exemple, la tâche de transformation samedi → dimanche: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="image"><br><br>  <b>Exemple de code</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> vous pouvez trouver une solution complète pour trouver la distance de montage minimale avec des tests et des explications: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  Conclusions </h3><br>  Dans cet article, nous avons comparé deux approches algorithmiques («programmation dynamique» et «diviser pour mieux régner») pour résoudre des problèmes.  Nous avons constaté que la programmation dynamique utilise le principe de «diviser pour mieux régner» et peut être appliquée à la résolution de problèmes si le problème contient des sous-problèmes entrecroisés et la sous-structure optimale (comme c'est le cas avec la distance de Levenshtein).  La programmation dynamique utilise en outre des techniques de mémorisation et de tabulation pour préserver les sous-résolutions pour une réutilisation ultérieure. <br><br>  J'espère que cet article a clarifié plutôt que compliqué la situation pour ceux d'entre vous qui essayaient de traiter des concepts aussi importants que la programmation dynamique et «diviser pour mieux régner» :) <br><br>  Vous pouvez trouver plus d'exemples algorithmiques utilisant la programmation dynamique, avec des tests et des explications dans le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript Algorithms and Data Structures</a> . <br><br>  Codage réussi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423939/">https://habr.com/ru/post/fr423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423927/index.html">10 moteurs de recherche prometteurs pour améliorer le référencement</a></li>
<li><a href="../fr423931/index.html">Comment contourner l'authentification SMS lors de la connexion aux réseaux Wi-Fi publics?</a></li>
<li><a href="../fr423933/index.html">Sécurité de Microsoft Office: objets intégrés</a></li>
<li><a href="../fr423935/index.html">Embox répond aux questions les plus courantes du festival TechTrain IT</a></li>
<li><a href="../fr423937/index.html">Elévation de privilèges Windows</a></li>
<li><a href="../fr423941/index.html">Rapports d'iOS mitap Redmadrobot</a></li>
<li><a href="../fr423943/index.html">Optimisation des prix de détail hors ligne</a></li>
<li><a href="../fr423945/index.html">La Cour suprême a précisé la procédure à suivre pour examiner les cas de reposts et de likes</a></li>
<li><a href="../fr423947/index.html">Nos données personnelles ne vous coûtent rien</a></li>
<li><a href="../fr423949/index.html">Un univers conforme à nos croyances actuelles peut ne pas être possible.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>