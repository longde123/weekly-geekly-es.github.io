<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëç üõ§Ô∏è üîµ Kami meng-overclock router JTAG üôáüèª üåΩ üôèüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda tiba-tiba perlu men-debug beberapa mikrokontroler / mikroprosesor di Crimea, minum smoothie dari kantor pengap di Khimki. Jika papan mikropr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami meng-overclock router JTAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402233/"><img src="https://habrastorage.org/files/246/ed6/597/246ed659739644049ad207725286591d.png"><br>  Jika Anda tiba-tiba perlu men-debug beberapa mikrokontroler / mikroprosesor di Crimea, minum smoothie dari kantor pengap di Khimki.  Jika papan mikroprosesor terletak pada objek yang bergerak dan tidak ada cara untuk mencapai debugger JTAG (papan tersebut terletak pada balon / quadrocopter).  Jika Anda tiba-tiba hanya membutuhkan isolasi galvanik antara host dan papan yang sedang di-debug (misalnya, perangkat bertegangan tinggi).  Dan bagus juga masih murah, ceria, dan universal bagi pabrikan (STM, Broadcom, Xilinx, dll) atau arsitektur (ARM, MIPS, FPGA, dll).  Maka Anda memerlukan router, ya, hanya router, misalnya, seperti ini. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/geektimes/post_images/3a9/c06/f83/3a9c06f8316481c4695a7cab8b686b4f.jpg" alt="gambar"><br>  <i>Gambar dari sagemcom.ru</i> <br><br>  Mari kita lihat ke dalam: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c8e/2ff/765/c8e2ff765b2a6c1c4a479e9c7b5ea6c8.png" alt="gambar"><br>  <i>wiki.openwrt.org</i> <br><br>  Jadi, ini adalah Sagem F @ ST2704 V2, didistribusikan oleh Rostelecom di seluruh negeri.  Kami memiliki inti arsitektur MIPS SoC BCM6328, 320 MHz, sepasang port USB yang disolder [1].  Ada wifi dan ethernet.  Dan bagian terbaiknya adalah rilis openwrt untuk model ini.  Semua itu dibutuhkan dari peralatan untuk tujuan di atas. <br><br>  Segera muncul ide untuk mengambil st-link dan mencoba meneruskan USB melalui jaringan.  Sepertinya penopang, kemungkinan besar janji untuk bekerja tidak cepat dan tidak terlalu stabil, biaya overhead sangat besar.  Kami melihat lebih jauh apa yang bisa dilakukan. <br><br>  Anda dapat port openocd ke openwrt, mengambil st-link atau chip ftdi dan memulai server gdb.  Untungnya, openocr sudah dipindahkan ke openwrt.  Tampaknya cukup untuk memikirkan opsi ini.  Tapi saya ingin melihat opsi lain yang diberikan Openocd kepada kami.  Dan di sini dalam dokumentasi antarmuka sysfsgpio menemukan.  Apa yang Anda butuhkan, adalah mungkin untuk mengontrol tck, tdi, sinyal tdo, sarana reguler OS linux via / sys / class / gpio pada pin solder dari chip. <br><br>  Kami mencoba.  Untuk memulai, kumpulkan openwrt (menggunakan cabang chaos_calmer) bersama dengan openocd.  Secara default, pada GPIO yang disolder, fungsi indikasi cahaya telah diperbaiki, serta tombol polling untuk menjalankan beberapa perintah (rfkill, reset, dan wpsc).  Agar mereka tidak mengganggu, saya mematikannya dengan menghapus modul kernel yang sesuai dari perakitan. <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$cat</span></span> target/linux/brcm63xx/config-3.18 b/target/linux/brcm63xx/config-3.18 ... <span class="hljs-comment"><span class="hljs-comment"># CONFIG_NEW_LEDS is not set ‚Ä¶ $cat .config ‚Ä¶ # CONFIG_PACKAGE_kmod-input-gpio-keys-polled is not set ... # CONFIG_PACKAGE_kmod-input-polldev is not set ... CONFIG_PACKAGE_openocd=y</span></span></code> </pre> <br>  perakitan itu sendiri: <br><br><pre> <code class="bash hljs">./scripts/feeds update -a ./scripts/feeds install -a make V=s</code> </pre><br>  Firmware: <br><br><pre> <code class="bash hljs">mtd -q write openwrt-brcm63xx-generic-F@ST2704V2-squashfs-cfe.bin linux</code> </pre><br>  Untuk tes sysfsgpio kami mengkompilasi konfigurasi: <br><br><pre> <code class="bash hljs">root@OpenWrt:~<span class="hljs-comment"><span class="hljs-comment"># cat sysfs.cfg.2.11 interface sysfsgpio transport select swd sysfsgpio_swclk_num 482 sysfsgpio_swdio_num 491 source [find target/stm32f1x.cfg]</span></span></code> </pre><br>  Hubungkan seperti di foto: <br><br><img src="https://habrastorage.org/files/e07/279/152/e07279152f9c4347af961fc1368c2275.png"><br><br>  Kami meluncurkan: <br><br><pre> <code class="hljs pgsql">root@OpenWrt:~# openocd -f sysfs.cfg<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">On</span></span>-Chip Debugger <span class="hljs-number"><span class="hljs-number">0.10</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>+dev<span class="hljs-number"><span class="hljs-number">-00085</span></span>-gfced6ac6-dirty (<span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-03</span></span>-xx<span class="hljs-number"><span class="hljs-number">-21</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span>) Licensed under GNU GPL v2 <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> bug reports, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> http://openocd.org/doc/doxygen/bugs.html SysfsGPIO num: swclk = <span class="hljs-number"><span class="hljs-number">482</span></span> SysfsGPIO num: swdio = <span class="hljs-number"><span class="hljs-number">491</span></span> SysfsGPIO num: trst = <span class="hljs-number"><span class="hljs-number">481</span></span> adapter speed: <span class="hljs-number"><span class="hljs-number">1000</span></span> kHz adapter_nsrst_delay: <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> separate cortex_m reset_config sysresetreq <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : SysfsGPIO JTAG/SWD bitbang driver <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : SWD <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> mode enabled (specify tck, tms, tdi <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tdo gpios <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> JTAG mode) Warn : gpio <span class="hljs-number"><span class="hljs-number">482</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> already exported Warn : gpio <span class="hljs-number"><span class="hljs-number">491</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> already exported <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : This adapter doesn<span class="hljs-string"><span class="hljs-string">'t support configurable speed Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span></span></code> </pre> <br>  Jalankan debug di IDE, semuanya berfungsi. <br><br><img src="https://habrastorage.org/files/3f0/983/aec/3f0983aecb41441592f838b44e8ca5db.png"><br><br>  Hanya dengan sangat lambat. <br><br>  Kami mencoba menghitung kecepatan, pergi ke router telnet: <br><br><pre> <code class="bash hljs">telnet 10.65.9.239 4444</code> </pre><br>  Kami membuat memori dump. <br><br><pre> <code class="hljs swift">&gt; dump_image <span class="hljs-built_in"><span class="hljs-built_in">dump</span></span>.bin <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x1ffff</span></span> dumped <span class="hljs-number"><span class="hljs-number">131071</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>.013523s (<span class="hljs-number"><span class="hljs-number">2.327</span></span> <span class="hljs-type"><span class="hljs-type">KiB</span></span>/s)</code> </pre><br>  Hmm, misalnya, st-linkv2 pada host saya memberikan kecepatan sekitar 45 KiB / s.  20 kali bedanya! <br><br><img src="https://habrastorage.org/files/a12/7ef/250/a127ef250a2c41adae14f1f5ae211050.png"><br><br>  Intinya, tentu saja, adalah karena pekerjaan yang lambat dengan file di / sys / class / gpio.  Mengaduk-aduk di openocd.  Temukan driver antarmuka untuk RaspberryPi (src / jtag / drivers / bcm2835gpio.c).  Dilihat dari tes [5], seharusnya memiliki kecepatan yang mirip dengan st-link.  Ini dicapai, sebagian besar, karena akses langsung ke register GPIO.  Kami akan melakukan hal yang sama untuk SoC kami, dan ini juga akan berlaku untuk seluruh keluarga chip bcm63xx. <br><br><div class="spoiler">  <b class="spoiler_title">antarmuka seperti itu ternyata</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @file * This driver implements a bitbang jtag interface using gpio lines via * router ob BCM63XX SoC. * The aim of this driver implementation is use system GPIOs but avoid the * need for a additional kernel driver. * (Note memory mapped IO is another option, however it doesn't mix well with * the kernel gpiolib driver - which makes sense I guess.) * * A gpio is required for tck, tms, tdi and tdo. One or both of srst and trst * must be also be specified. The required jtag gpios are specified via the * bcm63xx_gpio_jtag_nums command or the relevant bcm63xx_gpio_XXX_num commang. * The srst and trst gpios are set via the bcm63xx_gpio_srst_num and * bcm63xx_gpio_trst_num respectively. GPIO numbering follows the kernel * convention of starting from 0. * * The gpios should not be in use by another entity, and must not be requested * by a kernel driver without also being exported by it (otherwise they can't * be exported by bcm63xx_). * * The bcm63xx gpio interface can only manipulate one gpio at a time, so the * bitbang write handler remembers the last state for tck, tms, tdi to avoid * superfluous writes. * For speed the bcm63xx "value" entry is opened at init and held open. * This results in considerable gains over open-write-close (45s vs 900s) * * Further work could address: * -srst and trst open drain/ push pull * -configurable active high/low for srst &amp; trst */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_CONFIG_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jtag/interface.h&gt; #include "bitbang.h" #include &lt;sys/mman.h&gt; /* * Helper func to determine if gpio number valid * * Assume here that there will be less than 1000 gpios on a system */ static int is_gpio_valid(int gpio) { return gpio &gt;= 0 &amp;&amp; gpio &lt; 32; } off_t address_dir = NULL; off_t address_val = NULL; static int dev_mem_fd = -1; static volatile uint32_t *pio_base = NULL; static volatile uint32_t *pval_base = NULL; static volatile uint32_t *pads_base = NULL; static unsigned int jtag_delay = 0; static void set_dir_gpio(const int gpio, const int direction) { if(direction) *pio_base |= 1 &lt;&lt; gpio; else *pio_base &amp;= ~(1 &lt;&lt; gpio); } static void set_value_gpio(const int gpio, const int value) { if(value) *pval_base |= 1 &lt;&lt; gpio; else *pval_base &amp;= ~(1 &lt;&lt; gpio); for (unsigned int i = 0; i &lt; jtag_delay; i++) asm volatile (""); } static int read_gpio(const int gpio) { uint32_t val = *pval_base &amp; (1 &lt;&lt; gpio); val = val ? 1 : 0; return val; } static int setup_bcm63xx_gpio(int gpio, int is_output, int init_high) { char buf[40]; char gpiostr[4]; int ret; if (!is_gpio_valid(gpio)) return ERROR_OK; if((address_dir == NULL) || (address_val == NULL)){ perror("address of gpio register don't set"); return ERROR_FAIL; } if( dev_mem_fd &lt; 0 ) { dev_mem_fd = open("/dev/mem", O_RDWR | O_SYNC); if (dev_mem_fd &lt; 0) { perror("open"); return ERROR_FAIL; } const uint32_t mapped_size = getpagesize(); const off_t target_mmap = address_dir &amp; ~(off_t)(mapped_size - 1); pads_base = mmap(NULL, mapped_size, PROT_READ | PROT_WRITE, MAP_SHARED, dev_mem_fd, target_mmap); if (pads_base == MAP_FAILED) { perror("mmap. Check correct register address."); close(dev_mem_fd); return ERROR_FAIL; } pio_base = (char*)pads_base + (unsigned)(address_dir - target_mmap); pval_base = (char*)pads_base + (unsigned)(address_val - target_mmap); } set_dir_gpio(gpio, is_output); set_value_gpio(gpio, init_high); return 0; } /* gpio numbers for each gpio. Negative values are invalid */ static int tck_gpio = -1; static int tms_gpio = -1; static int tdi_gpio = -1; static int tdo_gpio = -1; static int trst_gpio = -1; static int srst_gpio = -1; static int swclk_gpio = -1; static int swdio_gpio = -1; /* * file descriptors for /sys/class/gpio/gpioXX/value * Set up during init. */ static int tck_fd = -1; static int tms_fd = -1; static int tdi_fd = -1; static int tdo_fd = -1; static int trst_fd = -1; static int srst_fd = -1; static int swclk_fd = -1; static int swdio_fd = -1; static int last_swclk; static int last_swdio; static bool last_stored; static bool swdio_input; static void bcm63xx_gpio_swdio_drive(bool is_output) { set_dir_gpio(swdio_gpio, is_output ? 1 : 0); last_stored = false; swdio_input = !is_output; } static int bcm63xx_gpio_swdio_read(void) { return read_gpio(swdio_gpio); } static void bcm63xx_gpio_swdio_write(int swclk, int swdio) { const char one[] = "1"; const char zero[] = "0"; size_t bytes_written; if (!swdio_input) { if (!last_stored || (swdio != last_swdio)) { set_value_gpio(swdio_gpio, swdio ? 1 : 0); } } /* write swclk last */ if (!last_stored || (swclk != last_swclk)) { set_value_gpio(swclk_gpio, swclk ? 1 : 0); } last_swdio = swdio; last_swclk = swclk; last_stored = true; } /* * Bitbang interface read of TDO * * The bcm63xx value will read back either '0' or '1'. The trick here is to call * lseek to bypass buffering in the bcm63xx kernel driver. */ static int bcm63xx_gpio_read(void) { return read_gpio(tdo_gpio); } /* * Bitbang interface write of TCK, TMS, TDI * * Seeing as this is the only function where the outputs are changed, * we can cache the old value to avoid needlessly writing it. */ static void bcm63xx_gpio_write(int tck, int tms, int tdi) { if (swd_mode) { bcm63xx_gpio_swdio_write(tck, tdi); return; } const char one[] = "1"; const char zero[] = "0"; static int last_tck; static int last_tms; static int last_tdi; static int first_time; size_t bytes_written; if (!first_time) { last_tck = !tck; last_tms = !tms; last_tdi = !tdi; first_time = 1; } if (tdi != last_tdi) { set_value_gpio(tdi_gpio,tdi); } if (tms != last_tms) { set_value_gpio(tms_gpio,tms); } /* write clk last */ if (tck != last_tck) { set_value_gpio(tck_gpio,tck); } last_tdi = tdi; last_tms = tms; last_tck = tck; } /* * Bitbang interface to manipulate reset lines SRST and TRST * * (1) assert or (0) deassert reset lines */ static void bcm63xx_gpio_reset(int trst, int srst) { LOG_DEBUG("bcm63xx_gpio_reset"); const char one[] = "1"; const char zero[] = "0"; size_t bytes_written; /* assume active low */ if (srst_fd &gt;= 0) { set_value_gpio(srst_gpio,srst); } /* assume active low */ if (trst_fd &gt;= 0) { set_value_gpio(trst_gpio,trst); } } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionums) { if (CMD_ARGC == 4) { COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tck_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], tms_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], tdi_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], tdo_gpio); } else if (CMD_ARGC != 0) { return ERROR_COMMAND_SYNTAX_ERROR; } command_print(CMD_CTX, "bcm63xx_GPIO nums: tck = %d, tms = %d, tdi = %d, tdo = %d", tck_gpio, tms_gpio, tdi_gpio, tdo_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tck) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tck_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tck = %d", tck_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tms) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tms_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tms = %d", tms_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tdo) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tdo_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tdo = %d", tdo_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tdi) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tdi_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tdi = %d", tdi_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_srst) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], srst_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: srst = %d", srst_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_trst) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], trst_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: trst = %d", trst_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_swd_gpionums) { if (CMD_ARGC == 2) { COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swclk_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], swdio_gpio); } else if (CMD_ARGC != 0) { return ERROR_COMMAND_SYNTAX_ERROR; } command_print(CMD_CTX, "bcm63xx_GPIO nums: swclk = %d, swdio = %d", swclk_gpio, swdio_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_swd_gpionum_swclk) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swclk_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: swclk = %d", swclk_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_swd_gpionum_swdio) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swdio_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: swdio = %d", swdio_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_jtag_delay) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], jtag_delay); command_print(CMD_CTX, "bcm63xx_GPIO jtag_delay:= %d tics", jtag_delay); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_adresses) { if (CMD_ARGC == 2) { COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address_dir); COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], address_val); } else if (CMD_ARGC != 0) { return ERROR_COMMAND_SYNTAX_ERROR; } command_print(CMD_CTX, "bcm63xx_GPIO address: direction = %x, value = %x", address_dir, address_val); return ERROR_OK; } static const struct command_registration bcm63xx_gpio_command_handlers[] = { { .name = "bcm63xx_gpio_jtag_nums", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionums, .mode = COMMAND_CONFIG, .help = "gpio numbers for tck, tms, tdi, tdo. (in that order)", .usage = "(tck tms tdi tdo)* ", }, { .name = "bcm63xx_gpio_tck_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tck, .mode = COMMAND_CONFIG, .help = "gpio number for tck.", }, { .name = "bcm63xx_gpio_tms_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tms, .mode = COMMAND_CONFIG, .help = "gpio number for tms.", }, { .name = "bcm63xx_gpio_tdo_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tdo, .mode = COMMAND_CONFIG, .help = "gpio number for tdo.", }, { .name = "bcm63xx_gpio_tdi_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tdi, .mode = COMMAND_CONFIG, .help = "gpio number for tdi.", }, { .name = "bcm63xx_gpio_srst_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_srst, .mode = COMMAND_CONFIG, .help = "gpio number for srst.", }, { .name = "bcm63xx_gpio_trst_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_trst, .mode = COMMAND_CONFIG, .help = "gpio number for trst.", }, { .name = "bcm63xx_gpio_swd_nums", .handler = &amp;bcm63xx_gpio_handle_swd_gpionums, .mode = COMMAND_CONFIG, .help = "gpio numbers for swclk, swdio. (in that order)", .usage = "(swclk swdio)* ", }, { .name = "bcm63xx_gpio_swclk_num", .handler = &amp;bcm63xx_gpio_handle_swd_gpionum_swclk, .mode = COMMAND_CONFIG, .help = "gpio number for swclk.", }, { .name = "bcm63xx_gpio_swdio_num", .handler = &amp;bcm63xx_gpio_handle_swd_gpionum_swdio, .mode = COMMAND_CONFIG, .help = "gpio number for swdio.", }, { .name = "bcm63xx_gpio_jtag_delay", .handler = &amp;bcm63xx_gpio_jtag_delay, .mode = COMMAND_CONFIG, .help = "qty tics gpio delay.", }, { .name = "bcm63xx_gpio_adresses", .handler = &amp;bcm63xx_gpio_adresses, .mode = COMMAND_CONFIG, .help = "addresses for direction and value setup. (in that order)", .usage = "(address_dir address_val)* ", }, COMMAND_REGISTRATION_DONE }; static int bcm63xx_gpio_init(void); static int bcm63xx_gpio_quit(void); static const char * const bcm63xx_gpio_transports[] = { "jtag", "swd", NULL }; struct jtag_interface bcm63xxgpio_interface = { .name = "bcm63xxgpio", .supported = DEBUG_CAP_TMS_SEQ, .execute_queue = bitbang_execute_queue, .transports = bcm63xx_gpio_transports, .swd = &amp;bitbang_swd, .commands = bcm63xx_gpio_command_handlers, .init = bcm63xx_gpio_init, .quit = bcm63xx_gpio_quit, }; static struct bitbang_interface bcm63xx_gpio_bitbang = { .read = bcm63xx_gpio_read, .write = bcm63xx_gpio_write, .reset = bcm63xx_gpio_reset, .swdio_read = bcm63xx_gpio_swdio_read, .swdio_drive = bcm63xx_gpio_swdio_drive, .blink = 0 }; static void unusing_all_gpio(void) { munmap(pads_base, sysconf(_SC_PAGE_SIZE)); close(dev_mem_fd); LOG_INFO("unusing_all_gpio\n"); } static bool bcm63xx_gpio_jtag_mode_possible(void) { if (!is_gpio_valid(tck_gpio)) return 0; if (!is_gpio_valid(tms_gpio)) return 0; if (!is_gpio_valid(tdi_gpio)) return 0; if (!is_gpio_valid(tdo_gpio)) return 0; return 1; } static bool bcm63xx_gpio_swd_mode_possible(void) { if (!is_gpio_valid(swclk_gpio)) return 0; if (!is_gpio_valid(swdio_gpio)) return 0; return 1; } static int bcm63xx_gpio_init(void) { bitbang_interface = &amp;bcm63xx_gpio_bitbang; LOG_INFO("bcm63xx_gpio JTAG/SWD bitbang driver"); if (bcm63xx_gpio_jtag_mode_possible()) { if (bcm63xx_gpio_swd_mode_possible()) LOG_INFO("JTAG and SWD modes enabled"); else LOG_INFO("JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)"); if (!is_gpio_valid(trst_gpio) &amp;&amp; !is_gpio_valid(srst_gpio)) { LOG_ERROR("Require at least one of trst or srst gpios to be specified"); return ERROR_JTAG_INIT_FAILED; } } else if (bcm63xx_gpio_swd_mode_possible()) { LOG_INFO("SWD only mode enabled (specify tck, tms, tdi and tdo gpios to add JTAG mode)"); } else { LOG_ERROR("Require tck, tms, tdi and tdo gpios for JTAG mode and/or swclk and swdio gpio for SWD mode"); return ERROR_JTAG_INIT_FAILED; } /* * Configure TDO as an input, and TDI, TCK, TMS, TRST, SRST * as outputs. Drive TDI and TCK low, and TMS/TRST/SRST high. * For SWD, SWCLK and SWDIO are configures as output high. */ if (tck_gpio &gt;= 0) { tck_fd = setup_bcm63xx_gpio(tck_gpio, 1, 0); if (tck_fd &lt; 0) goto out_error; } if (tms_gpio &gt;= 0) { tms_fd = setup_bcm63xx_gpio(tms_gpio, 1, 1); if (tms_fd &lt; 0) goto out_error; } if (tdi_gpio &gt;= 0) { tdi_fd = setup_bcm63xx_gpio(tdi_gpio, 1, 0); if (tdi_fd &lt; 0) goto out_error; } if (tdo_gpio &gt;= 0) { tdo_fd = setup_bcm63xx_gpio(tdo_gpio, 0, 0); if (tdo_fd &lt; 0) goto out_error; } /* assume active low*/ if (trst_gpio &gt;= 0) { trst_fd = setup_bcm63xx_gpio(trst_gpio, 1, 1); if (trst_fd &lt; 0) goto out_error; } /* assume active low*/ if (srst_gpio &gt;= 0) { srst_fd = setup_bcm63xx_gpio(srst_gpio, 1, 1); if (srst_fd &lt; 0) goto out_error; } if (swclk_gpio &gt;= 0) { swclk_fd = setup_bcm63xx_gpio(swclk_gpio, 1, 0); if (swclk_fd &lt; 0) goto out_error; } if (swdio_gpio &gt;= 0) { swdio_fd = setup_bcm63xx_gpio(swdio_gpio, 1, 0); if (swdio_fd &lt; 0) goto out_error; } if (bcm63xx_gpio_swd_mode_possible()) { if (swd_mode) bitbang_swd_switch_seq(JTAG_TO_SWD); else bitbang_swd_switch_seq(SWD_TO_JTAG); } return ERROR_OK; out_error: unusing_all_gpio(); return ERROR_JTAG_INIT_FAILED; } static int bcm63xx_gpio_quit(void) { unusing_all_gpio(); return ERROR_OK; }</span></span></span></span></code> </pre><br></div></div><br>  Dibandingkan dengan sysfsgpio, ia menambahkan beberapa opsi: <br><br><ul><li>  bcm63xx_gpio_jtag_delay </li><li>  bcm63xx_gpio_adresses </li></ul><br>  Pengaturan pertama mengatur penundaan antara pin switching, ini merupakan analog tidak langsung dari bcm2835gpio_speed_coeffs untuk driver RaspberryPi, yang menetapkan frekuensi jtag.  Sebagai contoh, pada zero delay, frekuensi switching sekitar satu megahertz, semuanya bekerja cukup stabil, tetapi untuk keandalan lebih baik untuk dapat mengatur parameter ini. <br><br>  Dan opsi kedua adalah analog dari bcm2835gpio_peripheral_base, hanya untuk itu Anda perlu mendaftarkan dua alamat untuk register, yang menetapkan fungsi input / output dari pin, dan register, yang bertanggung jawab atas nilai logis input / output pada gpio.  Pada awalnya, dibutuhkan nilai register dari file header kernel.  Tetapi tidak ada yang berhasil dengan nilai-nilai ini.  Ternyata register periferal tidak dapat diakses secara langsung dari userspace, mis.  sebuah remap harus dibuat kembali di kernel.  Baik bahwa driver gpio telah menerapkan ini untuk saya dan nilai-nilai yang diperlukan dapat diambil dari / proc / iomem. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tambahkan antarmuka kami ke majelis openocd</a> <br><br>  Ingatlah untuk menambahkan --enable-bcm63xxgpio ke CONFIGURE_ARGS dalam file feeds / paket / utils / openocd / Makefile. <br><br>  Kami membangun kembali, menginstal dan menjalankan router: <br><br><pre> <code class="hljs pgsql">root@OpenWrt:~# openocd -f interface/bcm63xx-swd.cfg -f target/stm32f1x.cfg <span class="hljs-keyword"><span class="hljs-keyword">Open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">On</span></span>-Chip Debugger <span class="hljs-number"><span class="hljs-number">0.10</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>+dev<span class="hljs-number"><span class="hljs-number">-00085</span></span>-gfced6ac6-dirty (<span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-03</span></span>-xx<span class="hljs-number"><span class="hljs-number">-21</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span>) Licensed under GNU GPL v2 <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> bug reports, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> http://openocd.org/doc/doxygen/bugs.html bcm63xx_GPIO num: swclk = <span class="hljs-number"><span class="hljs-number">2</span></span> bcm63xx_GPIO num: swdio = <span class="hljs-number"><span class="hljs-number">11</span></span> bcm63xx_GPIO jtag_delay:= <span class="hljs-number"><span class="hljs-number">10</span></span> tics bcm63xx_GPIO address: direction = <span class="hljs-number"><span class="hljs-number">10000084</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">1000008</span></span>c adapter speed: <span class="hljs-number"><span class="hljs-number">1000</span></span> kHz adapter_nsrst_delay: <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> separate cortex_m reset_config sysresetreq <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : bcm63xx_gpio JTAG/SWD bitbang driver <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : SWD <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> mode enabled (specify tck, tms, tdi <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tdo gpios <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> JTAG mode) <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : This adapter doesn<span class="hljs-string"><span class="hljs-string">'t support configurable speed Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span></span></code> </pre><br>  Periksa kecepatan dump. <br><br><pre> <code class="hljs swift">&gt; dump_image <span class="hljs-built_in"><span class="hljs-built_in">dump</span></span>.bin <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x1ffff</span></span> dumped <span class="hljs-number"><span class="hljs-number">131071</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>.729815s (<span class="hljs-number"><span class="hljs-number">27.062</span></span> <span class="hljs-type"><span class="hljs-type">KiB</span></span>/s)</code> </pre><br>  Sangat bagus, kita kalah dua kali di suatu tempat st-link dan raspberry, tetapi menurut perbedaannya tidak terlihat.  Tidak ada jalur selama debugging, well, dan tunggu beberapa detik untuk mem-flash selama firmware - "pamer". <br><br>  Semua tes dilakukan pada mikrokontroler STM32F103C8T6 dan, sayangnya, tidak ada jtag pada papan debug hanya pada antarmuka SWD,  Oleh karena itu, saya tidak dapat menjamin kerja penuh pada jtag.  Selain itu, kita tidak boleh lupa tentang koordinasi level sinyal (khususnya untuk MK AVR). <br><br>  Router itu sendiri diambil dari tumpukan sampah, di antaranya penuh dengan Sagem F @ st 2704V2 dan V7.  Sayangnya, semua perangkat rusak.  Tetapi adalah mungkin untuk mengembalikan papan tanpa masalah (lihat [2]). <br><br>  Jika seseorang siap untuk membuat debugger / programmer dari konstruktor ini, maka ia siap untuk berbagi stoknya dengan publik tanpa biaya, melepaskan semua tanggung jawab dan dana untuk pengiriman (dari default-city). <br><br>  Firmware yang diperbarui di <a href="">sini</a> . <br>  Saya memperingatkan Anda bahwa pengaturan jaringan dan firewall default telah diubah. <br><br>  Itu saja, debugging yang bagus! <br><br><h3>  Daftar sumber daya yang bermanfaat </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki.openwrt.org/toh/sagem/fast2704</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">radiohlam.ru/forum/viewtopic.php?f=54&amp;t=3749</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openocd.org</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">developer.mbed.org/handbook/CMSIS-DAP</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Programming-an-STM32F103XXX-with-a-generic-ST-Link-V2-programmer-from-Linux</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id402233/">https://habr.com/ru/post/id402233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id402219/index.html">Bagaimana camcorder fleksibel membantu menghilangkan penyumbatan</a></li>
<li><a href="../id402221/index.html">Para peretas yang terhormat, di mana mesin pemotong rumput mandiri Anda?</a></li>
<li><a href="../id402225/index.html">Silicon Graphics O2 - Stasiun kecil dengan fitur hebat</a></li>
<li><a href="../id402229/index.html">Cina sedang mengembangkan pesawat ruang angkasa yang dapat digunakan kembali untuk terbang ke bulan</a></li>
<li><a href="../id402231/index.html">Tanyakan Ethan: dapatkah energi gelap mengarah pada pengulangan siklus kehidupan alam semesta?</a></li>
<li><a href="../id402235/index.html">Peta jalan terperinci diperlukan untuk mobil pintar, bukan untuk orang</a></li>
<li><a href="../id402237/index.html">Mengapa Intel Mobileye?</a></li>
<li><a href="../id402239/index.html">Jejaring Agama</a></li>
<li><a href="../id402243/index.html">Ion Mikro-UPS</a></li>
<li><a href="../id402247/index.html">Tips Pencetakan Epson</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>