<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏽 🈂️ 🤳🏿 Bases du moteur JavaScript: optimisation du prototype. 2e partie 🧒🏾 🈹 🥓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour mes amis! Le cours "Sécurité des systèmes d'information" a été lancé, en lien avec cela nous partageons avec vous la dernière partie de l'arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases du moteur JavaScript: optimisation du prototype. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449144/">  Bonjour mes amis!  Le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Sécurité des systèmes d'information" a été</a> lancé, en lien avec cela nous partageons avec vous la dernière partie de l'article "Fondamentaux des moteurs JavaScript: optimisation des prototypes", dont la première partie peut être lue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Nous vous rappelons également que la publication actuelle est une continuation de ces deux articles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Fondamentaux des moteurs JavaScript: formulaires généraux et mise en cache en ligne.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">" Principes de base des moteurs JavaScript: formulaires généraux et mise en cache en ligne.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png"><br><br>  <b>Cours et programmation de prototypes</b> <br><br>  Maintenant que nous savons comment accéder rapidement aux propriétés des objets JavaScript, nous pouvons jeter un œil à la structure plus complexe des classes JavaScript.  Voici à quoi ressemble la syntaxe des classes en JavaScript: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Bien que cela semble être un concept relativement nouveau pour JavaScript, il ne s'agit que de «sucre syntaxique» pour le prototype de programmation qui a toujours été utilisé en JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Ici, nous <code>getX</code> propriété <code>getX</code> à l'objet <code>getX</code> .  Cela fonctionnera comme avec tout autre objet, car les prototypes en JavaScript sont les mêmes objets.  Dans les langages de programmation de prototypes tels que JavaScript, les méthodes sont accessibles via des prototypes, tandis que les champs sont stockés dans des instances spécifiques. <br><br>  Examinons de plus près ce qui se passe lorsque nous créons une nouvelle instance de <code>Bar</code> , que nous appellerons <code>foo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Une instance créée à l'aide de ce code a un formulaire avec une seule propriété <code>'x'</code> .  Le prototype <code>foo</code> est <code>Bar.prototype</code> , qui appartient à la classe <code>Bar</code> . <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  Ce <code>Bar.prototype</code> a la forme de lui-même, contenant la seule propriété <code>'getX'</code> , dont la valeur est déterminée par la fonction <code>'getX'</code> qui, lorsqu'elle est appelée, renvoie <code>this.x</code>  Le prototype <code>Bar.prototype</code> est <code>Object.prototype</code> , qui fait partie du langage JavaScript.  <code>Object.prototype</code> est la racine de l'arbre du prototype, tandis que son prototype est <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  Lorsque vous créez une nouvelle instance de la même classe, les deux instances ont la même forme, comme nous l'avons déjà compris.  Les deux instances pointeront vers le même objet <code>Bar.prototype</code> . <br><br>  <b>Accéder aux propriétés du prototype</b> <br><br>  Eh bien, maintenant nous savons ce qui se passe lorsque nous définissons une classe et créons une nouvelle instance.  Mais que se passe-t-il si nous appelons la méthode sur l'instance, comme nous l'avons fait dans l'exemple suivant? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Vous pouvez considérer tout appel de méthode comme deux étapes distinctes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  La première étape consiste à charger la méthode, qui est en fait une propriété du prototype (dont la valeur est une fonction).  La deuxième étape consiste à appeler une fonction avec une instance, par exemple, la valeur de <code>this</code> .  Examinons de plus près la première étape où la méthode <code>getX</code> est <code>getX</code> partir de l'instance <code>foo</code> . <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  Le moteur démarre une instance de <code>foo</code> et se rend compte que le formulaire <code>foo</code> n'a pas <code>'getX'</code> , il doit donc passer par la chaîne de prototype pour le trouver.  Nous <code>Bar.prototype</code> à <code>Bar.prototype</code> , regardons la forme du prototype, voyons qu'elle a la propriété <code>'getX'</code> à zéro décalage.  Nous recherchons la valeur de ce décalage dans <code>Bar.prototype</code> et trouvons la <code>JSFunction getX</code> que nous recherchions. <br><br>  La flexibilité de JavaScript permet aux prototypes de maillons de chaîne de changer, par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// → true Object.setPrototypeOf(foo, null); foo.getX(); // → Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  Dans cet exemple, nous appelons <pre> <code class="javascript hljs">foo.getX()</code> </pre>  deux fois, mais à chaque fois il a des significations et des résultats complètement différents.  C'est pourquoi, malgré le fait que les prototypes ne sont que des objets en JavaScript, accélérer l'accès aux propriétés d'un prototype est une tâche encore plus importante pour les moteurs JavaScript que d'accélérer leur propre accès aux propriétés des objets normaux. <br><br>  Dans la pratique quotidienne, le chargement des propriétés d'un prototype est une opération assez courante: cela se produit chaque fois que vous appelez une méthode! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Plus tôt, nous avons expliqué comment les moteurs optimisent le chargement des propriétés régulières à l'aide de formulaires et de caches en ligne.  Comment puis-je optimiser le chargement des propriétés du prototype pour des objets de même forme?  D'en haut, nous avons vu comment les propriétés sont chargées. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  Pour ce faire rapidement avec des téléchargements répétés dans ce cas particulier, vous devez connaître les trois choses suivantes: <br><br><ul><li>  Le formulaire <code>foo</code> ne contient pas <code>'getX'</code> et il n'a pas changé.  Cela signifie que personne n'a modifié l'objet foo en ajoutant ou en supprimant une propriété ou en modifiant l'un des attributs de propriété. </li><li>  Le prototype foo est toujours le <code>Bar.prototype</code> original.  Donc, personne n'a changé le prototype <code>foo</code> utilisant <code>Object.setPrototypeOf()</code> ou en l'affectant à la propriété spéciale <code>_proto_</code> . </li><li>  Le formulaire <code>Bar.prototype</code> contient <code>'getX'</code> et n'a pas changé.  Cela signifie que personne n'a modifié <code>Bar.prototype</code> en ajoutant ou en supprimant une propriété ou en modifiant l'un des attributs de propriété. </li></ul><br>  Dans le cas général, cela signifie que vous devez effectuer une vérification de l'instance elle-même et deux vérifications supplémentaires pour chaque prototype jusqu'au prototype qui contient la propriété souhaitée.  Les vérifications 1 + 2N, où N est le nombre de prototypes utilisés, ne sonnent pas si mal dans ce cas, car la chaîne de prototypes est relativement peu profonde.  Cependant, les moteurs doivent souvent gérer des chaînes de prototypes beaucoup plus longues, comme c'est le cas avec les classes DOM régulières.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Nous avons un <code>HTMLAnchorElement</code> et nous appelons la méthode <code>getAttribute()</code> .  La chaîne de cet élément simple comprend déjà 6 prototypes!  La plupart des méthodes DOM qui nous intéressent ne se trouvent pas dans le prototype <code>HTMLAnchorElement</code> - <code>HTMLAnchorElement</code> , mais quelque part dans la chaîne. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  La méthode <code>getAttribute()</code> trouve dans <code>Element.prototype</code> .  Cela signifie que chaque fois que nous appelons <code>anchor.getAttribute()</code> , le moteur JavaScript a besoin: <br><br><ol><li>  Vérifiez que <code>'getAttribute'</code> pas un objet d' <code>anchor</code> soi; </li><li>  Vérifiez que le prototype final est <code>HTMLAnchorElement.prototype</code> ; </li><li>  Confirmez l'absence de <code>'getAttribute'</code> là-bas; </li><li>  Vérifiez que le prochain prototype est <code>HTMLElement.prototype</code> ; </li><li>  Confirmez à nouveau l'absence de <code>'getAttribute'</code> ; </li><li>  Vérifiez que le prochain prototype est <code>Element.prototype</code> ; </li><li>  Vérifiez que <code>'getAttribute'</code> présent. </li></ol><br>  Un total de 7 chèques.  Étant donné que ce type de code est assez courant sur le Web, les moteurs utilisent diverses astuces pour réduire le nombre de contrôles requis pour charger les propriétés du prototype. <br><br>  Revenons à un exemple précédent dans lequel nous n'avions effectué que trois vérifications lors de la demande de <code>'getX'</code> pour <code>foo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Pour chaque objet apparaissant avant le prototype contenant la propriété souhaitée, il est nécessaire de vérifier les formes pour l'absence de cette propriété.  Ce serait bien si nous pouvions réduire le nombre de contrôles en présentant le prototype de chèque comme un contrôle de l'absence de propriété.  En substance, c'est exactement ce que font les moteurs avec une astuce simple: au lieu de stocker le lien prototype vers l'instance elle-même, les moteurs le stockent sous forme. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Chaque formulaire indique un prototype.  Cela signifie que chaque fois que le prototype change, le moteur passe à une nouvelle forme.  Nous devons maintenant vérifier uniquement la forme de l'objet pour confirmer l'absence de certaines propriétés, ainsi que protéger le lien prototype (protéger le lien prototype). <br><br>  Avec cette approche, nous pouvons réduire le nombre de contrôles requis de 2N + 1 à 1 + N pour accélérer l'accès.  C'est toujours une opération assez coûteuse, car c'est toujours une fonction linéaire du nombre de prototypes dans la chaîne.  Les moteurs utilisent diverses astuces pour réduire davantage le nombre de contrôles à une certaine valeur constante, en particulier dans le cas d'un chargement séquentiel des mêmes propriétés. <br><br>  <b>Cellules de validité</b> <br><br>  Le V8 traite des formulaires prototypes spécialement à cet effet.  Chaque prototype a une forme unique qui n'est pas partagée avec d'autres objets (en particulier, avec d'autres prototypes), et chacune de ces formes de prototype a une <code>ValidityCell</code> spéciale qui lui est associée. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  Cette <code>ValidityCell</code> désactivée à chaque fois que quelqu'un change le prototype qui lui est associé ou tout autre prototype au-dessus.  Voyons comment cela fonctionne. <br>  Pour accélérer les téléchargements de prototypes ultérieurs, V8 place le cache en ligne dans un emplacement à quatre champs: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  Lorsque le cache en ligne est chauffé la première fois que le code est exécuté, V8 se souvient de l'offset auquel la propriété a été trouvée dans le prototype, ce prototype (par exemple, <code>Bar.prototype</code> ), le formulaire d'instance (dans notre cas, le formulaire <code>foo</code> ), et lie également la <code>ValidityCell</code> actuelle au prototype reçu à partir de l'instance du formulaire (dans notre cas, <code>Bar.prototype</code> est pris). <br><br>  La prochaine fois que vous utiliserez le cache en ligne, le moteur devra vérifier le formulaire d'instance et <code>ValidityCell</code> .  S'il est toujours valide, le moteur utilise directement l'offset sur le prototype, ignorant les étapes de recherche supplémentaires. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  Lorsque vous modifiez le prototype, un nouveau formulaire est mis en surbrillance et la cellule <code>ValidityCell</code> précédente est désactivée.  Pour cette raison, le cache en ligne est ignoré au prochain démarrage, ce qui entraîne des performances médiocres. <br><br>  Revenons à l'exemple avec l'élément DOM.  Chaque modification dans <code>Object.prototype</code> invalide non seulement les caches en ligne pour <code>Object.prototype</code> , mais aussi pour tout prototype dans la chaîne en dessous, y compris <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., jusqu'à <code>HTMLAnchorElement.prototype</code> lui-même. <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  En fait, la modification de <code>Object.prototype</code> pendant que le code s'exécute est une perte de performance terrible.  Ne fais pas ça! <br><br>  Regardons un exemple spécifique pour mieux comprendre comment cela fonctionne.  Disons que nous avons une classe <code>Bar</code> et une fonction <code>loadX</code> qui appelle une méthode sur des objets de type <code>Bar</code> .  Nous appelons la fonction <code>loadX</code> plusieurs fois avec des instances de la même classe. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  Le cache en ligne dans <code>loadX</code> pointe désormais vers <code>ValidityCell</code> pour <code>Bar.prototype</code> .  Si vous modifiez ensuite le (Object) <code>Object.prototype</code> , qui est la racine de tous les prototypes en JavaScript, <code>ValidityCell</code> devient invalide et les caches Inline existants ne seront pas utilisés la prochaine fois, ce qui entraînera de mauvaises performances. <br><br>  Changer <code>Object.prototype</code> est toujours une mauvaise idée, car il invalide tous les caches Inline pour les prototypes chargés au moment du changement.  Voici un exemple de comment NE PAS faire: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  Nous développons <code>Object.prototype</code> , qui invalide tous les caches de prototypes Inline chargés par le moteur à ce stade.  Ensuite, nous exécuterons du code qui utilise la méthode décrite par nous.  Le moteur devra démarrer dès le début et configurer les caches Inline pour tout accès à la propriété prototype.  Et puis, enfin, «nettoyer» et supprimer la méthode prototype que nous avons ajoutée précédemment. <br><br>  Vous pensez que le nettoyage est une bonne idée, non?  Eh bien, dans ce cas, cela aggravera encore la situation!  La suppression des propriétés modifie <code>Object.prototype</code> , de sorte que tous les caches Inline sont à nouveau désactivés et que le moteur doit recommencer à travailler depuis le début. <br><br>  <b>Pour résumer</b> .  Bien que les prototypes ne soient que des objets, ils sont spécialement traités par des moteurs JavaScript afin d'optimiser les performances des recherches de méthodes par prototypes.  <b>Laissez les prototypes tranquilles!</b>  Ou si vous avez vraiment besoin de les gérer, faites-le avant d'exécuter le code, vous n'invaliderez donc pas toutes les tentatives d'optimisation de votre code lors de son exécution! <br><br><blockquote>  <b>Résumer</b> <br><br>  Nous avons appris comment JavaScript stocke les objets et les classes, et comment les formulaires, les caches en ligne et les cellules de validité aident à optimiser les opérations du prototype.  Sur la base de ces connaissances, nous avons compris comment améliorer les performances d'un point de vue pratique: ne touchez pas aux prototypes!  (ou si vous en avez vraiment besoin, faites-le avant d'exécuter le code). </blockquote><br>  ← <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La première partie</a> <br><br>  Cette série de publications vous a-t-elle été utile?  Écrivez dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449144/">https://habr.com/ru/post/fr449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449132/index.html">Top 17 des plugins pour Android Studio</a></li>
<li><a href="../fr449134/index.html">Zoo afl</a></li>
<li><a href="../fr449138/index.html">5 raisons pour crypto-hat Pourquoi les informaticiens n'aiment pas le bitcoin</a></li>
<li><a href="../fr449140/index.html">Laissez une demande et nous vous répondrons en ligne dans un délai d'une minute. Ou comment nous avons quitté OTRS</a></li>
<li><a href="../fr449142/index.html">Microbiota. Quelles bactéries vivent dans les intestins des Russes</a></li>
<li><a href="../fr449146/index.html">Mais n'agitons-nous pas à la communication optique? Lasers, espace, CubeSat</a></li>
<li><a href="../fr449148/index.html">Livres d'art pour enfants sur l'ingénierie sociale</a></li>
<li><a href="../fr449154/index.html">FAQ sur l'étiquetage obligatoire des chaussures: tout ce que vous ne saviez pas et aviez peur de demander</a></li>
<li><a href="../fr449158/index.html">Rough Coster: livre de recettes communautaire</a></li>
<li><a href="../fr449162/index.html">C ++ Russia 2019. Un petit reportage du lieu des événements et l'annonce de la prochaine conférence à Saint-Pétersbourg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>