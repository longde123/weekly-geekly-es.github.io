<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèΩ üàÇÔ∏è ü§≥üèø Bases du moteur JavaScript: optimisation du prototype. 2e partie üßíüèæ üàπ ü•ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour mes amis! Le cours "S√©curit√© des syst√®mes d'information" a √©t√© lanc√©, en lien avec cela nous partageons avec vous la derni√®re partie de l'arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases du moteur JavaScript: optimisation du prototype. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449144/">  Bonjour mes amis!  Le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"S√©curit√© des syst√®mes d'information" a √©t√©</a> lanc√©, en lien avec cela nous partageons avec vous la derni√®re partie de l'article "Fondamentaux des moteurs JavaScript: optimisation des prototypes", dont la premi√®re partie peut √™tre lue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Nous vous rappelons √©galement que la publication actuelle est une continuation de ces deux articles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Fondamentaux des moteurs JavaScript: formulaires g√©n√©raux et mise en cache en ligne.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">" Principes de base des moteurs JavaScript: formulaires g√©n√©raux et mise en cache en ligne.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png"><br><br>  <b>Cours et programmation de prototypes</b> <br><br>  Maintenant que nous savons comment acc√©der rapidement aux propri√©t√©s des objets JavaScript, nous pouvons jeter un ≈ìil √† la structure plus complexe des classes JavaScript.  Voici √† quoi ressemble la syntaxe des classes en JavaScript: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Bien que cela semble √™tre un concept relativement nouveau pour JavaScript, il ne s'agit que de ¬´sucre syntaxique¬ª pour le prototype de programmation qui a toujours √©t√© utilis√© en JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Ici, nous <code>getX</code> propri√©t√© <code>getX</code> √† l'objet <code>getX</code> .  Cela fonctionnera comme avec tout autre objet, car les prototypes en JavaScript sont les m√™mes objets.  Dans les langages de programmation de prototypes tels que JavaScript, les m√©thodes sont accessibles via des prototypes, tandis que les champs sont stock√©s dans des instances sp√©cifiques. <br><br>  Examinons de plus pr√®s ce qui se passe lorsque nous cr√©ons une nouvelle instance de <code>Bar</code> , que nous appellerons <code>foo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Une instance cr√©√©e √† l'aide de ce code a un formulaire avec une seule propri√©t√© <code>'x'</code> .  Le prototype <code>foo</code> est <code>Bar.prototype</code> , qui appartient √† la classe <code>Bar</code> . <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  Ce <code>Bar.prototype</code> a la forme de lui-m√™me, contenant la seule propri√©t√© <code>'getX'</code> , dont la valeur est d√©termin√©e par la fonction <code>'getX'</code> qui, lorsqu'elle est appel√©e, renvoie <code>this.x</code>  Le prototype <code>Bar.prototype</code> est <code>Object.prototype</code> , qui fait partie du langage JavaScript.  <code>Object.prototype</code> est la racine de l'arbre du prototype, tandis que son prototype est <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  Lorsque vous cr√©ez une nouvelle instance de la m√™me classe, les deux instances ont la m√™me forme, comme nous l'avons d√©j√† compris.  Les deux instances pointeront vers le m√™me objet <code>Bar.prototype</code> . <br><br>  <b>Acc√©der aux propri√©t√©s du prototype</b> <br><br>  Eh bien, maintenant nous savons ce qui se passe lorsque nous d√©finissons une classe et cr√©ons une nouvelle instance.  Mais que se passe-t-il si nous appelons la m√©thode sur l'instance, comme nous l'avons fait dans l'exemple suivant? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Vous pouvez consid√©rer tout appel de m√©thode comme deux √©tapes distinctes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  La premi√®re √©tape consiste √† charger la m√©thode, qui est en fait une propri√©t√© du prototype (dont la valeur est une fonction).  La deuxi√®me √©tape consiste √† appeler une fonction avec une instance, par exemple, la valeur de <code>this</code> .  Examinons de plus pr√®s la premi√®re √©tape o√π la m√©thode <code>getX</code> est <code>getX</code> partir de l'instance <code>foo</code> . <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  Le moteur d√©marre une instance de <code>foo</code> et se rend compte que le formulaire <code>foo</code> n'a pas <code>'getX'</code> , il doit donc passer par la cha√Æne de prototype pour le trouver.  Nous <code>Bar.prototype</code> √† <code>Bar.prototype</code> , regardons la forme du prototype, voyons qu'elle a la propri√©t√© <code>'getX'</code> √† z√©ro d√©calage.  Nous recherchons la valeur de ce d√©calage dans <code>Bar.prototype</code> et trouvons la <code>JSFunction getX</code> que nous recherchions. <br><br>  La flexibilit√© de JavaScript permet aux prototypes de maillons de cha√Æne de changer, par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true Object.setPrototypeOf(foo, null); foo.getX(); // ‚Üí Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  Dans cet exemple, nous appelons <pre> <code class="javascript hljs">foo.getX()</code> </pre>  deux fois, mais √† chaque fois il a des significations et des r√©sultats compl√®tement diff√©rents.  C'est pourquoi, malgr√© le fait que les prototypes ne sont que des objets en JavaScript, acc√©l√©rer l'acc√®s aux propri√©t√©s d'un prototype est une t√¢che encore plus importante pour les moteurs JavaScript que d'acc√©l√©rer leur propre acc√®s aux propri√©t√©s des objets normaux. <br><br>  Dans la pratique quotidienne, le chargement des propri√©t√©s d'un prototype est une op√©ration assez courante: cela se produit chaque fois que vous appelez une m√©thode! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Plus t√¥t, nous avons expliqu√© comment les moteurs optimisent le chargement des propri√©t√©s r√©guli√®res √† l'aide de formulaires et de caches en ligne.  Comment puis-je optimiser le chargement des propri√©t√©s du prototype pour des objets de m√™me forme?  D'en haut, nous avons vu comment les propri√©t√©s sont charg√©es. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  Pour ce faire rapidement avec des t√©l√©chargements r√©p√©t√©s dans ce cas particulier, vous devez conna√Ætre les trois choses suivantes: <br><br><ul><li>  Le formulaire <code>foo</code> ne contient pas <code>'getX'</code> et il n'a pas chang√©.  Cela signifie que personne n'a modifi√© l'objet foo en ajoutant ou en supprimant une propri√©t√© ou en modifiant l'un des attributs de propri√©t√©. </li><li>  Le prototype foo est toujours le <code>Bar.prototype</code> original.  Donc, personne n'a chang√© le prototype <code>foo</code> utilisant <code>Object.setPrototypeOf()</code> ou en l'affectant √† la propri√©t√© sp√©ciale <code>_proto_</code> . </li><li>  Le formulaire <code>Bar.prototype</code> contient <code>'getX'</code> et n'a pas chang√©.  Cela signifie que personne n'a modifi√© <code>Bar.prototype</code> en ajoutant ou en supprimant une propri√©t√© ou en modifiant l'un des attributs de propri√©t√©. </li></ul><br>  Dans le cas g√©n√©ral, cela signifie que vous devez effectuer une v√©rification de l'instance elle-m√™me et deux v√©rifications suppl√©mentaires pour chaque prototype jusqu'au prototype qui contient la propri√©t√© souhait√©e.  Les v√©rifications 1 + 2N, o√π N est le nombre de prototypes utilis√©s, ne sonnent pas si mal dans ce cas, car la cha√Æne de prototypes est relativement peu profonde.  Cependant, les moteurs doivent souvent g√©rer des cha√Ænes de prototypes beaucoup plus longues, comme c'est le cas avec les classes DOM r√©guli√®res.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Nous avons un <code>HTMLAnchorElement</code> et nous appelons la m√©thode <code>getAttribute()</code> .  La cha√Æne de cet √©l√©ment simple comprend d√©j√† 6 prototypes!  La plupart des m√©thodes DOM qui nous int√©ressent ne se trouvent pas dans le prototype <code>HTMLAnchorElement</code> - <code>HTMLAnchorElement</code> , mais quelque part dans la cha√Æne. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  La m√©thode <code>getAttribute()</code> trouve dans <code>Element.prototype</code> .  Cela signifie que chaque fois que nous appelons <code>anchor.getAttribute()</code> , le moteur JavaScript a besoin: <br><br><ol><li>  V√©rifiez que <code>'getAttribute'</code> pas un objet d' <code>anchor</code> soi; </li><li>  V√©rifiez que le prototype final est <code>HTMLAnchorElement.prototype</code> ; </li><li>  Confirmez l'absence de <code>'getAttribute'</code> l√†-bas; </li><li>  V√©rifiez que le prochain prototype est <code>HTMLElement.prototype</code> ; </li><li>  Confirmez √† nouveau l'absence de <code>'getAttribute'</code> ; </li><li>  V√©rifiez que le prochain prototype est <code>Element.prototype</code> ; </li><li>  V√©rifiez que <code>'getAttribute'</code> pr√©sent. </li></ol><br>  Un total de 7 ch√®ques.  √âtant donn√© que ce type de code est assez courant sur le Web, les moteurs utilisent diverses astuces pour r√©duire le nombre de contr√¥les requis pour charger les propri√©t√©s du prototype. <br><br>  Revenons √† un exemple pr√©c√©dent dans lequel nous n'avions effectu√© que trois v√©rifications lors de la demande de <code>'getX'</code> pour <code>foo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Pour chaque objet apparaissant avant le prototype contenant la propri√©t√© souhait√©e, il est n√©cessaire de v√©rifier les formes pour l'absence de cette propri√©t√©.  Ce serait bien si nous pouvions r√©duire le nombre de contr√¥les en pr√©sentant le prototype de ch√®que comme un contr√¥le de l'absence de propri√©t√©.  En substance, c'est exactement ce que font les moteurs avec une astuce simple: au lieu de stocker le lien prototype vers l'instance elle-m√™me, les moteurs le stockent sous forme. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Chaque formulaire indique un prototype.  Cela signifie que chaque fois que le prototype change, le moteur passe √† une nouvelle forme.  Nous devons maintenant v√©rifier uniquement la forme de l'objet pour confirmer l'absence de certaines propri√©t√©s, ainsi que prot√©ger le lien prototype (prot√©ger le lien prototype). <br><br>  Avec cette approche, nous pouvons r√©duire le nombre de contr√¥les requis de 2N + 1 √† 1 + N pour acc√©l√©rer l'acc√®s.  C'est toujours une op√©ration assez co√ªteuse, car c'est toujours une fonction lin√©aire du nombre de prototypes dans la cha√Æne.  Les moteurs utilisent diverses astuces pour r√©duire davantage le nombre de contr√¥les √† une certaine valeur constante, en particulier dans le cas d'un chargement s√©quentiel des m√™mes propri√©t√©s. <br><br>  <b>Cellules de validit√©</b> <br><br>  Le V8 traite des formulaires prototypes sp√©cialement √† cet effet.  Chaque prototype a une forme unique qui n'est pas partag√©e avec d'autres objets (en particulier, avec d'autres prototypes), et chacune de ces formes de prototype a une <code>ValidityCell</code> sp√©ciale qui lui est associ√©e. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  Cette <code>ValidityCell</code> d√©sactiv√©e √† chaque fois que quelqu'un change le prototype qui lui est associ√© ou tout autre prototype au-dessus.  Voyons comment cela fonctionne. <br>  Pour acc√©l√©rer les t√©l√©chargements de prototypes ult√©rieurs, V8 place le cache en ligne dans un emplacement √† quatre champs: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  Lorsque le cache en ligne est chauff√© la premi√®re fois que le code est ex√©cut√©, V8 se souvient de l'offset auquel la propri√©t√© a √©t√© trouv√©e dans le prototype, ce prototype (par exemple, <code>Bar.prototype</code> ), le formulaire d'instance (dans notre cas, le formulaire <code>foo</code> ), et lie √©galement la <code>ValidityCell</code> actuelle au prototype re√ßu √† partir de l'instance du formulaire (dans notre cas, <code>Bar.prototype</code> est pris). <br><br>  La prochaine fois que vous utiliserez le cache en ligne, le moteur devra v√©rifier le formulaire d'instance et <code>ValidityCell</code> .  S'il est toujours valide, le moteur utilise directement l'offset sur le prototype, ignorant les √©tapes de recherche suppl√©mentaires. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  Lorsque vous modifiez le prototype, un nouveau formulaire est mis en surbrillance et la cellule <code>ValidityCell</code> pr√©c√©dente est d√©sactiv√©e.  Pour cette raison, le cache en ligne est ignor√© au prochain d√©marrage, ce qui entra√Æne des performances m√©diocres. <br><br>  Revenons √† l'exemple avec l'√©l√©ment DOM.  Chaque modification dans <code>Object.prototype</code> invalide non seulement les caches en ligne pour <code>Object.prototype</code> , mais aussi pour tout prototype dans la cha√Æne en dessous, y compris <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., jusqu'√† <code>HTMLAnchorElement.prototype</code> lui-m√™me. <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  En fait, la modification de <code>Object.prototype</code> pendant que le code s'ex√©cute est une perte de performance terrible.  Ne fais pas √ßa! <br><br>  Regardons un exemple sp√©cifique pour mieux comprendre comment cela fonctionne.  Disons que nous avons une classe <code>Bar</code> et une fonction <code>loadX</code> qui appelle une m√©thode sur des objets de type <code>Bar</code> .  Nous appelons la fonction <code>loadX</code> plusieurs fois avec des instances de la m√™me classe. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  Le cache en ligne dans <code>loadX</code> pointe d√©sormais vers <code>ValidityCell</code> pour <code>Bar.prototype</code> .  Si vous modifiez ensuite le (Object) <code>Object.prototype</code> , qui est la racine de tous les prototypes en JavaScript, <code>ValidityCell</code> devient invalide et les caches Inline existants ne seront pas utilis√©s la prochaine fois, ce qui entra√Ænera de mauvaises performances. <br><br>  Changer <code>Object.prototype</code> est toujours une mauvaise id√©e, car il invalide tous les caches Inline pour les prototypes charg√©s au moment du changement.  Voici un exemple de comment NE PAS faire: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  Nous d√©veloppons <code>Object.prototype</code> , qui invalide tous les caches de prototypes Inline charg√©s par le moteur √† ce stade.  Ensuite, nous ex√©cuterons du code qui utilise la m√©thode d√©crite par nous.  Le moteur devra d√©marrer d√®s le d√©but et configurer les caches Inline pour tout acc√®s √† la propri√©t√© prototype.  Et puis, enfin, ¬´nettoyer¬ª et supprimer la m√©thode prototype que nous avons ajout√©e pr√©c√©demment. <br><br>  Vous pensez que le nettoyage est une bonne id√©e, non?  Eh bien, dans ce cas, cela aggravera encore la situation!  La suppression des propri√©t√©s modifie <code>Object.prototype</code> , de sorte que tous les caches Inline sont √† nouveau d√©sactiv√©s et que le moteur doit recommencer √† travailler depuis le d√©but. <br><br>  <b>Pour r√©sumer</b> .  Bien que les prototypes ne soient que des objets, ils sont sp√©cialement trait√©s par des moteurs JavaScript afin d'optimiser les performances des recherches de m√©thodes par prototypes.  <b>Laissez les prototypes tranquilles!</b>  Ou si vous avez vraiment besoin de les g√©rer, faites-le avant d'ex√©cuter le code, vous n'invaliderez donc pas toutes les tentatives d'optimisation de votre code lors de son ex√©cution! <br><br><blockquote>  <b>R√©sumer</b> <br><br>  Nous avons appris comment JavaScript stocke les objets et les classes, et comment les formulaires, les caches en ligne et les cellules de validit√© aident √† optimiser les op√©rations du prototype.  Sur la base de ces connaissances, nous avons compris comment am√©liorer les performances d'un point de vue pratique: ne touchez pas aux prototypes!  (ou si vous en avez vraiment besoin, faites-le avant d'ex√©cuter le code). </blockquote><br>  ‚Üê <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La premi√®re partie</a> <br><br>  Cette s√©rie de publications vous a-t-elle √©t√© utile?  √âcrivez dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449144/">https://habr.com/ru/post/fr449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449132/index.html">Top 17 des plugins pour Android Studio</a></li>
<li><a href="../fr449134/index.html">Zoo afl</a></li>
<li><a href="../fr449138/index.html">5 raisons pour crypto-hat Pourquoi les informaticiens n'aiment pas le bitcoin</a></li>
<li><a href="../fr449140/index.html">Laissez une demande et nous vous r√©pondrons en ligne dans un d√©lai d'une minute. Ou comment nous avons quitt√© OTRS</a></li>
<li><a href="../fr449142/index.html">Microbiota. Quelles bact√©ries vivent dans les intestins des Russes</a></li>
<li><a href="../fr449146/index.html">Mais n'agitons-nous pas √† la communication optique? Lasers, espace, CubeSat</a></li>
<li><a href="../fr449148/index.html">Livres d'art pour enfants sur l'ing√©nierie sociale</a></li>
<li><a href="../fr449154/index.html">FAQ sur l'√©tiquetage obligatoire des chaussures: tout ce que vous ne saviez pas et aviez peur de demander</a></li>
<li><a href="../fr449158/index.html">Rough Coster: livre de recettes communautaire</a></li>
<li><a href="../fr449162/index.html">C ++ Russia 2019. Un petit reportage du lieu des √©v√©nements et l'annonce de la prochaine conf√©rence √† Saint-P√©tersbourg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>