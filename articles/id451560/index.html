<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™“ï¸ ğŸ§ğŸ¾ ğŸ¤šğŸ¿ Pelanggan yang terhormat, itu sebabnya perubahan ini butuh waktu lama. ğŸ§ğŸ¿ ğŸ“¹ ğŸ™ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perubahan dalam sistem perangkat lunak yang rumit tampaknya berlangsung selamanya, bukan? Bahkan insinyur sering berpikir bahwa perubahan melampaui ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelanggan yang terhormat, itu sebabnya perubahan ini butuh waktu lama.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451560/"> Perubahan dalam sistem perangkat lunak yang rumit tampaknya berlangsung selamanya, bukan?  Bahkan insinyur sering berpikir bahwa perubahan melampaui apa yang seharusnya, meskipun kami menyadari kompleksitas sistem! <br><br>  Bagi pelanggan, situasinya bahkan lebih sulit dipahami.  Masalahnya diperparah oleh kompleksitas acak, yang ditambahkan dari waktu ke waktu karena dukungan sistem yang buruk.  Ada perasaan bahwa kami mencoba mengambil air dari sebuah kapal dengan seribu lubang. <br><br>  Oleh karena itu, cepat atau lambat, pelanggan akan mengirim surat: "Kenapa itu butuh waktu begitu lama?"  Jangan lupa bahwa kita, sebagai insinyur perangkat lunak, memiliki jendela ke dunia, yang seringkali tidak mereka miliki.  Mereka sangat mempercayai kita, tetapi terkadang perubahan yang tampaknya tidak penting benar-benar membutuhkan banyak waktu.  Karena itu, timbul pertanyaan. <br><a name="habracut"></a><br>  Jangan tersinggung oleh pertanyaan ini;  menganggapnya sebagai kesempatan untuk menunjukkan empati dan memberi seseorang gambaran yang lebih jelas tentang kompleksitas sistem.  Pada saat yang sama, Anda dapat menyarankan cara untuk memperbaiki situasi.  Ketika seseorang kesal, ini adalah saat terbaik untuk menawarkan solusi! <br><br>  Sebuah surat diterbitkan di bawah ini, yang dalam satu atau lain bentuk, kami telah berulang kali mengirim selama bertahun-tahun.  Kami harap ini membantu Anda menjawab pertanyaan-pertanyaan ini. <br><br><h1>  Sepucuk surat </h1><br>  Pelanggan yang terhormat, <br><br>  Saya melihat komentar Anda pada kartu "Beritahu sebelum berakhirnya tugas" dan saya akan senang untuk membahasnya pada pertemuan berikutnya.  Di sini, sebagai referensi, saya akan merangkum pikiran saya, tidak perlu dijawab. <br><br>  Untuk memparafrasekan catatan Anda: <br><br>  <i>Mengubah tenggat waktu untuk menyelesaikan tugas satu hari untuk pemberitahuan melalui pos harus dilakukan satu baris.</i>  <i>Bagaimana bisa memakan waktu 4-8 jam?</i>  <i>Apa yang saya lewatkan?</i> <br><br>  Di satu sisi, saya setuju dengan Anda.  Cukup ubah bagian permintaan dari <code>tasks due &lt;= today</code> ke <code>tasks due &lt;= tomorrow</code> . <br><br>  Di sisi lain, menguranginya menjadi ide yang disederhanakan, kami secara tidak sengaja mengabaikan kompleksitas yang melekat dan membuat sejumlah keputusan rekayasa.  Beberapa dari mereka harus kita diskusikan. <br><br><h1>  Bagian 1. Mengapa perubahan kecil ini lebih dari yang terlihat? </h1><br>  Ini sederhana, perubahan kecil, satu baris kode.  Menghabiskan sepanjang hari untuk itu, bahkan setengah hari, tampak berlebihan. <br><br>  Tentu saja, Anda tidak bisa hanya melakukan perubahan produksi tanpa menjalankan setidaknya secara lokal atau pada server pengujian.  Anda harus memastikan bahwa kode dieksekusi dengan benar, dan jika permintaan berubah, Anda harus membandingkan hasilnya dan memastikan bahwa itu terlihat kurang lebih benar. <br><br>  Di sini, membandingkan output bisa minimal, hanya pemeriksaan kecil: pastikan hasilnya masuk akal, dll. Ini adalah pemberitahuan untuk karyawan internal.  Jika matematika berdasarkan tanggal tidak benar (sedikit kesalahan), kami akan segera mendengarnya dari tim.  Jika itu, katakanlah, email untuk pelanggan Anda, studi yang lebih dalam akan diperlukan.  Tetapi untuk pengujian dan ulasan yang mudah ini, 20-40 menit sudah cukup, tergantung pada apakah sesuatu yang aneh atau tidak terduga muncul.  Menggali data bisa memakan waktu.  Melepaskan perubahan tanpa melakukan tinjauan hanyalah kelalaian yang tidak profesional. <br><br>  Dengan demikian, kami menambahkan waktu untuk logistik normal, seperti melakukan kode, menggabungkan perubahan, menyebarkan, dll: dari awal pekerjaan hingga rilis dalam produksi, setidaknya satu jam berlalu dari insinyur profesional yang kompeten. <br><br>  Tentu saja, ini mengasumsikan bahwa Anda tahu persis baris kode mana yang harus diubah.  Alur kerja tugas pada dasarnya tinggal di sistem lama, tetapi beberapa bagian dari logika tinggal di sistem baru.  Memindahkan logika dari sistem lama itu baik, tetapi itu berarti bahwa fungsionalitas tugas saat ini dibagi menjadi dua sistem. <br><br>  Karena kami telah bekerja bersama begitu lama, tim kami tahu proses mana yang mengirim email dengan tugas yang sudah kadaluwarsa dan dapat menunjuk ke baris kode dalam sistem baru yang mengawali proses.  Jadi kita tidak perlu membuang waktu untuk mencari tahu. <br><br>  Tetapi jika kita melihat kode tugas dalam sistem yang lama, setidaknya ada empat cara berbeda untuk menentukan apakah tugas itu sudah jatuh tempo.  Selain itu, melihat pola dan perilaku email, ada setidaknya dua tempat lagi di mana tampaknya logika khusus untuk tugas ini diterapkan. <br><br>  Dan kemudian logika notifikasi lebih rumit dari yang Anda pikirkan.  Ini membedakan antara tugas umum dan individual, terbuka dan pribadi, berulang, fungsi pemberitahuan tambahan dari manajer dalam kasus tugas yang terlambat, dll. Tapi kita dapat dengan cepat mengetahui bahwa sebenarnya hanya 2 dari 6+ definisi tugas yang terlambat digunakan untuk pemberitahuan.  Dan hanya satu hal yang perlu diubah untuk mencapai tujuan. <br><br>  Tinjauan seperti itu dapat dengan mudah memakan waktu setengah jam atau lebih, mungkin kurang jika Anda baru-baru ini berada di bagian basis kode ini.  Selain itu, kompleksitas laten berarti bahwa kami dapat melampaui perkiraan kami untuk pengujian manual.  Tapi mari kita tambahkan 30 menit saja untuk usaha ekstra. <br><br>  Dengan demikian, kami mencapai 1,5 jam untuk merasa yakin bahwa perubahan akan dilakukan seperti yang diharapkan. <br><br>  Tentu saja, kami belum memeriksa apakah proses lain menggunakan kueri yang dapat diubah.  Kami tidak ingin secara tidak sengaja mengganggu fungsi lain dengan mengubah konsep "tenggat waktu" menjadi hari yang mendahului hari terakhir untuk menyelesaikan tugas.  Kita harus mempertimbangkan basis kode dari sudut pandang ini.  Dalam hal ini, tampaknya tidak ada dependensi utama - mungkin karena sebagian besar antarmuka pengguna masih pada sistem yang lama.  Oleh karena itu, tidak perlu khawatir tentang mengubah atau menguji proses lain.  Dalam kasus terbaik, ini adalah 15-30 menit lagi. <br><br>  Oh, dan karena bagian utama dari antarmuka pengguna tugas masih ada di sistem lama, kami benar-benar perlu melakukan tinjauan singkat tentang fungsi tugas di sistem ini dan memastikan bahwa umpan baliknya benar.  Misalnya, jika antarmuka pengguna menyoroti tugas yang tenggat waktunya telah tiba, kami dapat mengubah logika ini agar sesuai dengan pemberitahuan.  Atau setidaknya kembali dan tanyakan kepada klien bagaimana ia ingin melakukannya.  Baru-baru ini, saya tidak melihat fungsionalitas tugas di sistem lama dan saya tidak ingat apakah ia mengetahui batas waktu / penundaan.  Ulasan ini menambah 15-30 menit lagi.  Mungkin lebih jika sistem lama juga memiliki beberapa definisi "tugas", dll. <br><br>  Dengan demikian, kami pergi ke kisaran 2â€“2,5 jam untuk menyelesaikan tugas dengan keyakinan bahwa semuanya akan baik-baik saja, tanpa efek samping yang tidak diinginkan atau kebingungan dalam pekerjaan pengguna. <br><br><h1>  Bagian 2. Bagaimana saya bisa mengurangi waktu ini? </h1><br>  Sayangnya, satu-satunya hasil dari upaya ini hanyalah pemenuhan tugas.  Ini tidak optimal, yang sangat mengecewakan.  Pengetahuan yang diperoleh pengembang selama bekerja bersifat pribadi dan sementara.  Jika pengembang lain (atau diri kami sendiri setelah 6 bulan) lagi perlu melakukan perubahan pada bagian kode ini, proses tersebut harus diulang. <br><br>  Ada dua taktik utama untuk memperbaiki situasi: <br><br><ol><li>  Secara aktif membersihkan basis kode untuk mengurangi duplikasi dan kerumitan. <br></li><li>  Tulis tes otomatis. </li></ol><br>  Catatan: kami sudah membahas dokumentasi, tetapi dalam hal ini ini bukan solusi terbaik.  Dokumentasi bermanfaat untuk ide-ide tingkat tinggi, seperti menjelaskan logika bisnis atau proses yang sering diulang, seperti daftar mitra baru.  Tetapi ketika datang ke kode, dokumentasi dengan cepat menjadi terlalu tebal dan menjadi ketinggalan zaman ketika kode berubah. <br><br>  Anda perhatikan bahwa tidak satu pun dari taktik ini termasuk dalam 2â€“2,5 jam kami. <br><br>  Misalnya, mempertahankan basis kode yang bersih berarti bahwa alih-alih hanya menyelesaikan tugas, kami mengajukan pertanyaan: <br><br><ul><li>  Mengapa ada begitu banyak cara berbeda untuk mengidentifikasi tugas-tugas yang batas waktunya telah mendekati / kedaluwarsa? <br></li><li>  Apakah mereka semua membutuhkan dan mengerjakannya? <br></li><li>  Bisakah metode ini direduksi menjadi satu atau dua konsep / metode? <br></li><li>  Jika konsep ini dibagi antara yang lama dan yang baru, dapatkah itu dikonsolidasikan? </li></ul><br>  Dan sebagainya. <br><br>  Jawaban atas pertanyaan-pertanyaan ini bisa sangat cepat: misalnya, jika kita menemukan kode mati jelas.  Atau mereka mungkin memakan waktu beberapa jam: misalnya, jika tugas digunakan dalam banyak proses yang kompleks.  Segera setelah kami memiliki jawaban ini, akan diperlukan lebih banyak waktu untuk refactoring untuk mengurangi duplikasi / kebingungan dan mendapatkan deskripsi tunggal tentang konsep "tenggat waktu" - atau mengganti nama konsep dalam kode untuk memahami dengan jelas perbedaannya dan mengapa. <br><br>  Tetapi pada akhirnya, ini bagian dari basis kode akan menjadi lebih sederhana, akan lebih mudah untuk membaca dan memodifikasi. <br><br>  Taktik lain yang biasanya kita gunakan adalah pengujian otomatis.  Dalam arti tertentu, tes otomatis mirip dengan dokumentasi yang tidak dapat kedaluwarsa dan yang lebih mudah dideteksi.  Alih-alih menjalankan kode secara manual dan melihat output, kami menulis kode uji yang meluncurkan permintaan dan memverifikasi output secara terprogram.  Setiap pengembang dapat menjalankan kode tes ini untuk memahami bagaimana sistem seharusnya bekerja dan memastikan bahwa itu masih berfungsi seperti itu. <br><br>  Jika Anda memiliki sistem dengan cakupan tes yang layak, perubahan ini akan memakan waktu lebih singkat.  Anda dapat mengubah logika dan menjalankan suite uji lengkap dan memastikannya <br><br><ol><li>  perubahan berfungsi dengan benar; <br></li><li>  perubahan tidak merusak apa pun (ini bahkan informasi yang lebih berharga daripada paragraf pertama). </li></ol><br>  Ketika kami membangun sistem dari awal di Simple Thread, kami selalu menyertakan waktu untuk menulis tes otomatis dalam evaluasi tenggat waktu.  Ini dapat memperlambat pengembangan awal, tetapi sangat meningkatkan efisiensi kerja dan pemeliharaan.  Hanya ketika sistem tumbuh, apakah Anda benar-benar memahami pentingnya tes, tetapi pada titik ini bisa sangat sulit untuk mengembalikan tes ke sistem.  Kehadiran tes juga sangat menyederhanakan pekerjaan karyawan baru, dan mengubah perilaku sistem jauh lebih cepat dan lebih aman. <br><br><h1>  Bagian 3. Dari mana kita berasal?  Kemana kita akan pergi </h1><br>  Hari ini, kami jarang menunjukkan dalam penilaian Anda waktu untuk menghapus kode atau menulis tes.  Ini sebagian karena menulis tes dari awal adalah overhead kecil, dan menambahkan tes ke backdating basis kode adalah banyak pekerjaan, seperti memulihkan fondasi di bawah rumah tempat tinggal orang. <br><br>  Ini juga sebagian karena fakta bahwa mulai bekerja dengan Anda, kami segera beralih ke mode resusitasi.  Kami memiliki masalah hampir setiap hari dengan menyinkronkan data pihak ketiga, masalah mingguan dengan menghasilkan laporan, permintaan konstan untuk dukungan untuk perubahan data kecil, pemantauan yang tidak memadai dan pencatatan sistem, dll. Basis kode tenggelam karena beban hutang teknis, dan kami dengan tergesa-gesa mencoba untuk menjaga sistem tetap menyala mengapung, sambil menempel lubang dengan pita listrik. <br><br>  Seiring waktu, sistem menjadi lebih stabil dan dapat diandalkan, kami mengotomatiskan / menyediakan UI untuk swalayan atas permintaan dukungan yang sering.  Kami masih memiliki banyak hutang teknis, tetapi kami keluar dari mode darurat.  Tetapi saya tidak berpikir bahwa kita akan sepenuhnya beralih dari mentalitas penghidupan kembali ini ke mentalitas "rencana dan eksekusi" yang lebih proaktif dan matang. <br><br>  Kami mencoba menghapus kode saat dalam perjalanan, dan kami selalu menguji secara menyeluruh.  Tetapi berhati-hati dan rajin bukanlah refactoring proaktif atau menciptakan infrastruktur yang diperlukan untuk pengujian otomatis yang baik. <br><br>  Jika kita tidak mulai membayar hutang teknis, kita tidak akan pernah dapat memperbaiki situasi secara signifikan.  Pengembang yang kompeten dan berkompeten tinggi akan membutuhkan waktu berbulan-bulan untuk bernavigasi dan membuat perubahan yang tidak sepele. <br><br>  Dengan kata lain, 4-8 jam untuk tugas ini adalah sekitar 2-4 kali pasokan, tetapi itu akan secara signifikan mengurangi upaya untuk perubahan tersebut di masa depan.  Jika bagian dari basis kode ini lebih bersih dan memiliki cakupan yang baik dengan tes otomatis, maka pengembang yang kompeten akan menyelesaikannya dalam satu jam atau kurang.  Dan kuncinya adalah bahwa pengembang baru akan mengambil sedikit lebih banyak waktu. <br><br>  Untuk perubahan dalam hal ini, kami membutuhkan persetujuan Anda.  Ini adalah upaya sadar untuk secara fundamental meningkatkan kinerja sistem Anda, bukan hanya bagaimana pengguna melihatnya.  Saya memahami bahwa sulit untuk menyetujui investasi semacam itu karena tidak ada manfaat yang terlihat, tetapi kami senang untuk duduk bersama Anda dan menyiapkan beberapa angka jelas yang akan menunjukkan bagaimana investasi ini akan terbayar dalam jangka panjang dari sudut pandang teknik. <br><br>  Terima kasih <br>  Al </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451560/">https://habr.com/ru/post/id451560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451540/index.html">Berapa Banyak Pengembang yang Perlu Membuat Layanan Seperti Airbnb</a></li>
<li><a href="../id451542/index.html">Bagaimana dan mengapa kami melakukan pengakuan tengara di Cloud Mail.ru</a></li>
<li><a href="../id451552/index.html">Kami membangun saluran penjualan jaringan gadget DO-RA</a></li>
<li><a href="../id451556/index.html">Flutter: pelokalan aplikasi menggunakan Android Studio</a></li>
<li><a href="../id451558/index.html">Suatu hari dalam kehidupan otomatisasi QA</a></li>
<li><a href="../id451562/index.html">Bagaimana cara melarikan diri dari sekte?</a></li>
<li><a href="../id451566/index.html">Operation TaskMasters: Bagaimana Kami Mengekspos Organisasi Penyerang Kelompok Cyber â€‹â€‹di Rusia dan CIS</a></li>
<li><a href="../id451570/index.html">Pindah ke Prancis untuk bekerja: gaji, visa, dan resume</a></li>
<li><a href="../id451572/index.html">Tren Teknologi Pengembangan Web 2019</a></li>
<li><a href="../id451574/index.html">Kembangkan utilitas di GraalVM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>