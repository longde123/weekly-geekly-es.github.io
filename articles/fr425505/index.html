<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèΩ üë®üèæ‚Äçüîß üë©üèæ‚Äç‚öïÔ∏è Analyse du processus de d√©marrage du noyau Linux üë®üèæ‚Äçüíª üë©üèæ‚Äçüè≠ üë©üèª‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Pendant que Leonid se pr√©pare pour sa premi√®re le√ßon ouverte dans notre cours Administrateur Linux , nous continuons √† parler du ch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse du processus de d√©marrage du noyau Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Bonjour √† tous! <br><br>  Pendant que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Leonid</a> se pr√©pare pour sa premi√®re <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le√ßon ouverte</a> dans notre cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Administrateur Linux</a> , nous continuons √† parler du chargement du noyau Linux. <br><br>  C'est parti! <br><br>  Comprendre comment un syst√®me fonctionne sans √©checs - Se pr√©parer √† corriger les pannes in√©vitables <br><br>  La blague la plus ancienne dans le domaine open source est l'affirmation selon laquelle ¬´le code se documente lui-m√™me¬ª.  L'exp√©rience a montr√© que lire le code source, c'est comme √©couter les pr√©visions m√©t√©orologiques: les gens intelligents iront toujours dehors et regarderont le ciel.  Vous trouverez ci-dessous des conseils pour v√©rifier et examiner le d√©marrage du syst√®me Linux √† l'aide d'outils de d√©bogage familiers.  Une analyse du processus de d√©marrage d'un syst√®me qui fonctionne bien pr√©pare les utilisateurs et les d√©veloppeurs √† r√©soudre les plantages in√©vitables. <br><br>  D'une part, le processus de t√©l√©chargement est √©tonnamment simple.  Le noyau du syst√®me d'exploitation (noyau) fonctionne sur un seul thread et de mani√®re synchrone sur un noyau (noyau), ce qui peut sembler compr√©hensible m√™me pour un esprit humain path√©tique.  Mais comment d√©marre le noyau de l'OS?  Quelles fonctions font initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un disque RAM pour l'initialisation initiale</a> ) et les chargeurs de d√©marrage?  Et attendez, pourquoi le voyant du port Ethernet est-il toujours allum√©? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Lisez la suite pour obtenir des r√©ponses √† ces questions et √† d'autres;  Le code des d√©mos et exercices d√©crits est √©galement disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  <b>D√©but de d√©marrage: statut OFF</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Un √©tat OFF signifie que le syst√®me n'est pas aliment√©, non?  La simplicit√© apparente est trompeuse.  Par exemple, le voyant Ethernet est allum√© m√™me dans cet √©tat, car le r√©veil sur r√©seau local (WOL, r√©veil sur [le signal du] r√©seau local) est activ√© sur votre syst√®me.  Assurez-vous en √©crivant: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  √Ä la place, il peut √™tre, par exemple, eth0 (ethtool est dans les packages Linux du m√™me nom).  Si le ¬´Wake-on¬ª dans la sortie affiche g, les h√¥tes distants peuvent d√©marrer le syst√®me en envoyant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MagicPacket</a> .  Si vous ne souhaitez pas allumer votre syst√®me √† distance vous-m√™me et donner cette opportunit√© aux autres, d√©sactivez WOL dans le menu BIOS du syst√®me ou utilisez: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Un processeur r√©pondant √† MagicPacket peut √™tre un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contr√¥leur de gestion</a> de la carte m√®re (BMC) ou une partie d'une interface r√©seau. <br><br>  <i><b>Intel Management Engine, Platform Controller Hub et Minix</b></i> <br><br>  Le BMC n'est pas le seul microcontr√¥leur (MCU) qui peut ¬´√©couter¬ª un syst√®me nominalement √©teint.  Les syst√®mes X86_64 disposent du progiciel Intel Management Engine (IME) pour la gestion √† distance des syst√®mes.  Une large gamme de p√©riph√©riques, des serveurs aux ordinateurs portables, dispose d'une technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dot√©e de fonctionnalit√©s</a> telles que le contr√¥le √† distance KVM ou le service de licence de capacit√© Intel.  Selon le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propre outil</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IME a des vuln√©rabilit√©s non corrig√©es.</a>  La mauvaise nouvelle est qu'il est difficile de d√©sactiver IME.  Trammell Hudson a cr√©√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le projet me_cleaner, qui efface</a> certains des composants IME les plus flagrants, tels que le serveur Web int√©gr√©, mais en m√™me temps, il est possible que l'utilisation du projet transforme le syst√®me sur lequel il s'ex√©cute en brique. <br><br>  Le micrologiciel IME et le programme System Management Mode (SMM) qui le suit au d√©marrage sont bas√©s sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le syst√®me d'exploitation Minix</a> et s'ex√©cutent sur un processeur Platform Controller Hub distinct, et non sur le processeur principal du syst√®me.  SMM lance ensuite le programme UEFI (Universal Extensible Firmware Interface) sur le processeur principal, qui a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©crit plus d'une fois</a> .  Le groupe Coreboot a lanc√© un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NERF (Non-Extensible Reduced Firmware)</a> spectaculairement ambitieux chez Google, qui vise √† remplacer non seulement UEFI, mais aussi les premiers composants de l'espace utilisateur Linux, tels que systemd.  En attendant, nous attendons les r√©sultats, les utilisateurs de Linux peuvent acheter des ordinateurs portables aupr√®s de Purism, System76 ou Dell, sur lesquels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IME est d√©sactiv√©</a> , et nous pouvons esp√©rer des ordinateurs portables avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">processeur ARM 64 bits</a> . <br><br>  <i><b>Chargeurs</b></i> <i><b><br></b></i> <br>  Que fait le firmware amor√ßable en plus du lancement du logiciel espion suspect?  La t√¢che du chargeur de d√©marrage est de fournir au processeur qui vient d'√™tre allum√© les ressources n√©cessaires pour ex√©cuter un syst√®me d'exploitation √† usage g√©n√©ral comme Linux.  Lors de la mise sous tension, il n'y a pas seulement de la m√©moire virtuelle, mais aussi de la DRAM jusqu'au moment d'√©lever son contr√¥leur.  Le chargeur de d√©marrage allume ensuite les blocs d'alimentation et analyse les bus et les interfaces pour trouver l'image du noyau et le syst√®me de fichiers racine.  Les chargeurs de d√©marrage populaires, tels que U-Boot et GRUB, prennent en charge √† la fois les interfaces courantes comme USB, PCI et NFS, ainsi que d'autres p√©riph√©riques int√©gr√©s plus sp√©cialis√©s, tels que les flashs NOR et NAND.  Les chargeurs interagissent √©galement avec les p√©riph√©riques mat√©riels de s√©curit√©, tels que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module de plateforme s√©curis√©e (TPM)</a> , pour √©tablir une cha√Æne de confiance d√®s le d√©but du t√©l√©chargement. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Ex√©cution du chargeur U-boot dans le bac √† sable sur le serveur de g√©n√©ration.</i> <br><br>  Le chargeur de d√©marrage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">U-Boot</a> open source populaire est pris en charge par les syst√®mes du Raspberry Pi aux appareils Nintendo, aux cartes de voiture et aux Chromebooks.  Il n'y a pas de journal syst√®me et en cas de probl√®me, il se peut m√™me qu'il n'y ait pas de sortie de console.  Pour faciliter le d√©bogage, l'√©quipe U-Boot fournit un bac √† sable pour tester les correctifs sur l'h√¥te de g√©n√©ration ou m√™me dans le syst√®me d'int√©gration continue.  Sur un syst√®me avec des outils de d√©veloppement communs tels que Git et la collection de compilateurs GNU (GCC) install√©s, il est facile de comprendre le sandbox U-Boot. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  C'est tout: vous avez lanc√© U-Boot sur x86_64 et vous pouvez tester des fonctionnalit√©s d√©licates, par exemple, la r√©partition des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">p√©riph√©riques de stockage fictifs</a> , la manipulation des cl√©s secr√®tes bas√©e sur TPM et le branchement √† chaud des p√©riph√©riques USB.  Le sandbox U-Boot peut √™tre en une √©tape dans le d√©bogueur GDB.  Le d√©veloppement utilisant le bac √† sable est 10 fois plus rapide que le test en √©crasant le chargeur de d√©marrage sur la carte, de plus, le bac √† sable ¬´brique¬ª peut √™tre restaur√© en appuyant sur Ctrl + C. <br><br>  <b>Lancement du noyau</b> <br><br>  <i><b>D√©marrage de l'approvisionnement du noyau</b></i> <br><br>  √Ä la fin de ses t√¢ches, le chargeur de d√©marrage passera au code du noyau qu'il a charg√© dans la m√©moire principale et commencera √† l'ex√©cuter, en passant tous les param√®tres de ligne de commande que l'utilisateur a sp√©cifi√©s.  Quel programme est le noyau?  file / boot / vmlinuz montre qu'il s'agit de bzImage.  L'arborescence des sources Linux poss√®de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un outil extract-vmlinux</a> que vous pouvez utiliser pour extraire le fichier: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  Le noyau est un fichier binaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ELF (Executable and Linking Format)</a> , comme les programmes d'espace utilisateur Linux.  Cela signifie que nous pouvons utiliser des commandes binutils comme readelf pour l'apprendre.  Comparez, par exemple, les conclusions suivantes: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  La liste des partitions dans les fichiers binaires est pour la plupart similaire. <br><br>  Donc, le noyau devrait lancer d'autres binaires ELF Linux ... Mais comment fonctionnent les programmes d'espace utilisateur?  Dans la fonction <code>main()</code> , non?  Pas vraiment. <br><br>  Avant d'ex√©cuter la fonction <code>main()</code> , les programmes ont besoin d'un contexte d'ex√©cution, y compris de la m√©moire tas (tas) et pile (pile), ainsi que des descripteurs de fichiers pour <code>stdio</code> , <code>stdout</code> et <code>stderr</code> .  Les programmes de l'espace utilisateur obtiennent ces ressources de la biblioth√®que standard ( <code>glibc</code> pour la plupart des syst√®mes Linux).  Tenez compte des √©l√©ments suivants: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  Les binaires ELF ont un interpr√©teur, tout comme les scripts Bash et Python.  Mais il n'a pas besoin d'√™tre sp√©cifi√© via <code>#!</code>  comme dans les scripts, car ELF est un format Linux natif.  L'interpr√©teur ELF fournit au fichier binaire toutes les ressources n√©cessaires en appelant <code>_start()</code> , une fonction disponible dans le paquet source <code>glibc</code> , qui peut √™tre apprise via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDB</a> .  Le noyau, √©videmment, n'a pas d'interpr√®te, et il devrait se fournir ind√©pendamment, mais comment? <br><br>  Une √©tude sur le d√©marrage d'un noyau avec GDB fournit une r√©ponse √† cette question.  Pour commencer, installez le package de d√©bogage du noyau, qui contient la version non coup√©e de <code>vmlinux</code> , par exemple, <code>apt-get install linux-image-amd64-dbg</code> .  Ou compilez et installez votre propre noyau √† partir d'une source, par exemple, en suivant les instructions de l'excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel du noyau Debian</a> .  <code>gdb vmlinux</code> suivi des <code>info files</code> montre la section ELF <code>init.text</code> .  Indiquez le d√©but de l'ex√©cution du programme dans <code>init.text</code> avec <code>l *(address)</code> , o√π adresse est le d√©but hexad√©cimal de <code>init.text</code> .  GDB indiquera que le noyau x86_64 est lanc√© dans le <code><a href="">arch/x86/kernel/head_64.S</a></code> , o√π nous trouvons la fonction de construction <code>start_cpu0()</code> et le code qui cr√©e explicitement la pile et d√©compresse zImage avant d'appeler <code>x86_64 start_kernel()</code> .  Les c≈ìurs ARM 32 bits ont un <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> est ind√©pendant de l'architecture, donc la fonction est situ√©e dans le noyau <code>init/main.c</code>  On peut dire que <code>start_kernel()</code> est une vraie fonction Linux <code>main()</code> . <br><br>  <b>De start_kernel () √† PID 1</b> <br>  <i><b>Manifeste mat√©riel du noyau: tables ACPI et arborescences de p√©riph√©riques</b></i> <br><br>  Lors du d√©marrage, le noyau a besoin d'informations sur le mat√©riel en plus du type de processeur pour lequel il a √©t√© compil√©.  Les instructions du code sont compl√©t√©es par des donn√©es de configuration, qui sont stock√©es s√©par√©ment.  Il existe deux m√©thodes principales de stockage des donn√©es: les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arborescences de</a> p√©riph√©riques et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tables ACPI</a> .  √Ä partir de ces fichiers, le noyau d√©couvre quel √©quipement doit √™tre ex√©cut√© √† chaque d√©marrage. <br><br>  Pour les p√©riph√©riques int√©gr√©s, l'arborescence des p√©riph√©riques (DU) est un manifeste de l'√©quipement install√©.  DU est un fichier qui se compile en m√™me temps que la source du noyau et se trouve g√©n√©ralement dans / boot avec <code>vmlinux</code> .  Pour voir ce qui se trouve dans l'arborescence des p√©riph√©riques binaires sur le p√©riph√©rique ARM, utilisez simplement la commande <code>strings</code> du package binutils dans le fichier dont le nom correspond √† <code>/boot/*.dtb</code> , car <code>dtb</code> signifie le fichier binaire de l'arborescence des p√©riph√©riques (Device-Tree Binary).  Vous pouvez modifier la t√©l√©commande en modifiant les fichiers de type JSON qui la composent et en red√©marrant le compilateur sp√©cial dtc fourni avec la source du noyau.  DU est un fichier statique dont le chemin est g√©n√©ralement transmis au noyau par les chargeurs de d√©marrage sur la ligne de commande, mais ces derni√®res ann√©es, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">superposition d'arborescence de p√©riph√©riques</a> a √©t√© ajout√©e o√π le noyau peut charger dynamiquement des fragments suppl√©mentaires en r√©ponse aux √©v√©nements de connexion √† chaud apr√®s le chargement. <br><br>  La famille x86 et de nombreux appareils de niveau professionnel ARM64 utilisent le m√©canisme alternatif de configuration avanc√©e et d'interface d'alimentation ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACPI)</a> .  Contrairement √† la t√©l√©commande, les informations ACPI sont stock√©es dans le syst√®me de fichiers virtuel <code>/sys/firmware/acpi/tables</code> , qui est cr√©√© par le noyau au d√©marrage en acc√©dant √† la ROM interne.  Pour lire les tables ACPI, utilisez la commande <code>acpica-tools</code> package <code>acpica-tools</code> .  Voici un exemple: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>Les tableaux ACPI sur les ordinateurs portables Lenovo sont pr√™ts pour Windows 2001.</i> <br><br>  Oui, votre syst√®me Linux est pr√™t pour Windows 2001 si vous souhaitez l'installer.  ACPI a √† la fois des m√©thodes et des donn√©es, contrairement √† la t√©l√©commande, qui ressemble plus √† un langage de description mat√©rielle.  Les m√©thodes ACPI restent actives apr√®s le d√©marrage.  Par exemple, si vous ex√©cutez la commande acpi_listen (√† partir du package apcid), puis fermez et ouvrez le couvercle de l'ordinateur portable, vous verrez que la fonctionnalit√© ACPI a continu√© √† fonctionner pendant tout ce temps.  Une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©√©criture</a> temporaire et dynamique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des tables ACPI</a> est possible, mais une modification permanente n√©cessitera une interaction avec le menu du BIOS au d√©marrage ou le flashage de la ROM.  Au lieu de telles complexit√©s, vous devriez peut-√™tre simplement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer coreboot</a> , un remplacement pour le firmware open source. <br><br>  De start_kernel () √† l'espace utilisateur <br><br>  Le code dans <code><a href="">init/main.c</a></code> est √©tonnamment facile √† lire et, curieusement, porte toujours le copyright original de Linus Torvalds de 1991-1992.  Lignes trouv√©es √† <code>dmesg | head</code>  <code>dmesg | head</code> syst√®me en cours d'ex√©cution provient essentiellement de ce fichier source.  Le premier CPU est enregistr√© par le syst√®me, les structures de donn√©es globales sont initialis√©es, le planificateur, les gestionnaires d'interruption (IRQ), les temporisateurs et la console sont lev√©s les uns apr√®s les autres.  Tous les horodatages avant d'ex√©cuter <code>timekeeping_init()</code> sont nuls.  Cette partie de l'initialisation du noyau est synchrone, c'est-√†-dire que l'ex√©cution se produit dans un seul thread.  Les fonctions ne sont ex√©cut√©es que lorsque la derni√®re d'entre elles est termin√©e et renvoy√©e.  En cons√©quence, la sortie <code>dmesg</code> sera enti√®rement reproductible m√™me entre les deux syst√®mes, tant qu'ils ont la m√™me t√©l√©commande ou les m√™mes tables ACPI.  Linux se comporte √©galement comme un syst√®me d'exploitation en temps r√©el (RTOS) fonctionnant sur un MCU, tel que QNX ou VxWorks.  Cette situation est stock√©e dans la fonction <code>rest_init()</code> , qui est appel√©e par <code>start_kernel()</code> au moment de son ach√®vement. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Une br√®ve description du processus de d√©marrage pr√©coce du noyau</i> <i><br></i> <br>  Le modestement nomm√© <code>rest_init()</code> cr√©e un nouveau thread qui ex√©cute <code>kernel_init()</code> , qui √† son tour appelle <code>do_initcalls()</code> .  Les utilisateurs peuvent surveiller le fonctionnement des <code>initcalls</code> en ajoutant <code>initcalls_debug</code> √† la ligne de commande du noyau.  Par cons√©quent, vous obtiendrez l'entit√© <code>dmesg</code> chaque fois que vous ex√©cutez la fonction <code>initcall</code> .  <code>initcalls</code> passe par sept niveaux cons√©cutifs: early, core, postcore, arch, subsys, fs, device et late.  La partie la plus notable des <code>initcalls</code> pour les utilisateurs est l'identification et l'installation des p√©riph√©riques du processeur: bus, r√©seau, stockage, √©crans, etc., accompagn√©s du chargement de leurs modules du noyau.  <code>rest_init()</code> cr√©e √©galement un deuxi√®me thread dans le processeur de d√©marrage, qui commence par ex√©cuter <code>cpu_idle()</code> pendant que le planificateur distribue son travail. <br><br>  <code>kernel_init()</code> configure √©galement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multitraitement sym√©trique</a> (SMP).  Dans les noyaux modernes, vous pouvez trouver ce moment dans la sortie dmesg par la ligne "Bringing up secondary CPUs ...".  SMP fabrique ensuite le CPU √† chaud, ce qui signifie qu'il g√®re son cycle de vie √† l'aide d'une machine d'√©tat conditionnellement similaire √† celles utilis√©es dans des appareils tels que les cl√©s USB √† d√©tection automatique.  Le syst√®me de gestion de l'alimentation du noyau arr√™te souvent les c≈ìurs individuels (c≈ìurs) et les r√©veille selon les besoins afin que le m√™me code CPU hotplug soit appel√© √† plusieurs reprises sur une machine inoccup√©e.  Jetez un ≈ìil √† la fa√ßon dont un syst√®me de gestion de l'alimentation appelle un hotplug CPU √† l'aide d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un outil BCC</a> appel√© <code>offcputime.py</code> . <br><br>  Notez que le code dans <code>init/main.c</code> presque termin√© son ex√©cution lorsque <code>smp_init()</code> ex√©cut√©.  Le processeur de d√©marrage a termin√© la plupart de l'initialisation unique, que les autres noyaux n'ont pas besoin de r√©p√©ter.  Cependant, des threads doivent √™tre cr√©√©s pour chaque c≈ìur afin de contr√¥ler les interruptions (IRQ), la file d'attente de travail, les temporisateurs et les √©v√©nements d'alimentation sur chacun d'eux.  Par exemple, regardez les threads du processeur qui servent les softirqs et les files d'attente de travail avec la commande <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  o√π le champ PSR signifie ¬´processeur¬ª.  Chaque c≈ìur doit avoir ses propres temporisateurs et gestionnaires de hotplug cpuhp. <br><br>  Et enfin, comment est lanc√© l'espace utilisateur?  Vers la fin, <code>kernel_init()</code> recherche un <code>initrd</code> qui peut d√©marrer le processus <code>init</code> en son nom.  Sinon, le noyau ex√©cute <code>init</code> lui-m√™me.  Pourquoi alors <code>initrd</code> peut √™tre n√©cessaire? <br><br>  <i><b>Espace utilisateur pr√©coce: qui a command√© initrd?</b></i> <br><br>  En plus de l'arborescence des p√©riph√©riques, un autre chemin d'initialisation du fichier, √©ventuellement fourni par le noyau au d√©marrage, appartient √† <code>initrd</code> .  <code>initrd</code> souvent dans / boot avec le fichier bzImage vmlinuz sur x86, ou avec une uImage similaire et une arborescence de p√©riph√©riques pour ARM.  Une liste du contenu <code>intrd</code> peut √™tre consult√©e √† l'aide de l'outil <code>lsinitramfs</code> , qui fait partie du package <code>initramfs-tools-core</code> .  L'image de distribution initrd contient les r√©pertoires minimum <code>/bin</code> , <code>/sbin</code> et <code>/etc</code> , ainsi que les modules et fichiers du noyau dans <code>/scripts</code> .  Tout devrait √™tre plus ou moins familier, car <code>initrd</code> pour la plupart similaire au syst√®me de fichiers racine Linux simplifi√©.  Cette similitude est un peu trompeuse, car presque tous les ex√©cutables dans <code>/bin</code> et <code>/sbin</code> int√©rieur du ramdisk sont des liens symboliques vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">binaire BusyBox</a> , ce qui rend les r√©pertoires / bin et / sbin 10 fois plus petits que dans la <code>glibc</code> . <br><br>  Pourquoi essayer de cr√©er un <code>initrd</code> si la seule chose qu'il fait est de charger certains modules et d'ex√©cuter <code>init</code> sur un syst√®me de fichiers racine normal?  Prenons un syst√®me de fichiers racine chiffr√©.  Le d√©chiffrement peut d√©pendre du chargement du module du noyau stock√© dans <code>/lib/modules</code> syst√®me de fichiers racine ... et, comme pr√©vu, dans <code>initrd</code> .  Le module crypto peut √™tre compil√© statiquement dans le noyau, et non charg√© √† partir d'un fichier, mais il y a plusieurs raisons de le refuser.  Par exemple, la compilation statique d'un noyau avec des modules peut le rendre trop volumineux pour tenir dans le stockage disponible, ou la compilation statique peut violer les termes de la licence du logiciel.  Sans surprise, les pilotes de stockage, les r√©seaux et les HID (p√©riph√©riques d'entr√©e humains) peuvent √©galement √™tre repr√©sent√©s dans <code>initrd</code> - essentiellement tout code qui n'est pas une partie requise du noyau n√©cessaire pour monter le syst√®me de fichiers racine.  Toujours dans initrd, les utilisateurs peuvent stocker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leur propre code ACPI pour les tables</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Amusez-vous avec la coquille de sauvetage et l'initrd personnalis√©.</i> <br><br>  <code>initrd</code> √©galement id√©al pour tester les syst√®mes de fichiers et les p√©riph√©riques de stockage.  Placez les outils de test dans <code>initrd</code> et ex√©cutez les tests √† partir de la m√©moire, pas √† partir de l'objet de test. <br><br>  Enfin, lorsque <code>init</code> cours d'ex√©cution, le syst√®me fonctionne!  Comme les processeurs secondaires sont d√©j√† en cours d'ex√©cution, la machine est devenue une cr√©ature asynchrone, pagin√©e, impr√©visible et performante que nous connaissons et aimons tous.  En effet, <code>ps -o pid,psr,comm -p</code> indique que le processus d' <code>init</code> espace utilisateur ne s'ex√©cute plus sur le processeur de d√©marrage. <br><br>  <b>R√©sum√©</b> <br><br>  Le processus de d√©marrage Linux semble interdit, compte tenu de la quantit√© de logiciels affect√©s, m√™me sur un simple p√©riph√©rique int√©gr√©.  D'un autre c√¥t√©, le processus de d√©marrage est assez simple, car il n'y a pas de complexit√© excessive caus√©e par l'√©viction du multit√¢che, du RCU et des conditions de course.  En faisant attention uniquement au noyau et au PID 1, on peut ignorer l'excellent travail accompli par les chargeurs de d√©marrage et les processeurs auxiliaires pour pr√©parer la plate-forme au lancement du noyau.  Le noyau est certainement diff√©rent des autres programmes Linux, mais l'utilisation d'outils pour travailler avec d'autres binaires ELF aidera √† mieux comprendre sa structure.  L'√©tude d'un processus de d√©marrage r√©alisable pr√©parera de futurs plantages. <br><br>  LA FIN <br><br>  Nous attendons vos commentaires et questions, comme d'habitude, ici ou √† notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le√ßon ouverte</a> o√π Leonid sera √©poustoufl√©. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425505/">https://habr.com/ru/post/fr425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425493/index.html">Configuration de MikroTik hAP mini pour IPTV Beeline</a></li>
<li><a href="../fr425497/index.html">Meetup Tutu PHP # 2: diffusion d'√©v√©nements en direct</a></li>
<li><a href="../fr425499/index.html">HyperX Impact DDR4 - SO-DIMM qui pourrait! Ou pourquoi dans un ordinateur portable 64 Go de m√©moire avec une fr√©quence de 3200 MHz?</a></li>
<li><a href="../fr425501/index.html">Tests A / B sur Android de A √† Z</a></li>
<li><a href="../fr425503/index.html">√âvier Cassandra pour le streaming structur√© Spark</a></li>
<li><a href="../fr425507/index.html">Parsim Wikipedia pour les t√¢ches PNL en 4 √©quipes</a></li>
<li><a href="../fr425511/index.html">Fonctionnalit√©s non √©videntes de l'application Rotativa pour la g√©n√©ration de PDF dans l'application ASP.NET MVC</a></li>
<li><a href="../fr425515/index.html">Apple bloque la r√©paration ind√©pendante des nouveaux mod√®les de MacBook</a></li>
<li><a href="../fr425517/index.html">Comment Yandex a cr√©√© une pr√©vision des pr√©cipitations mondiales √† l'aide de radars et de satellites</a></li>
<li><a href="../fr425521/index.html">M√©thodes prot√©g√©es dans JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>