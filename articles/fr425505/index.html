<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏽 👨🏾‍🔧 👩🏾‍⚕️ Analyse du processus de démarrage du noyau Linux 👨🏾‍💻 👩🏾‍🏭 👩🏻‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! 

 Pendant que Leonid se prépare pour sa première leçon ouverte dans notre cours Administrateur Linux , nous continuons à parler du ch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse du processus de démarrage du noyau Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Bonjour à tous! <br><br>  Pendant que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Leonid</a> se prépare pour sa première <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leçon ouverte</a> dans notre cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Administrateur Linux</a> , nous continuons à parler du chargement du noyau Linux. <br><br>  C'est parti! <br><br>  Comprendre comment un système fonctionne sans échecs - Se préparer à corriger les pannes inévitables <br><br>  La blague la plus ancienne dans le domaine open source est l'affirmation selon laquelle «le code se documente lui-même».  L'expérience a montré que lire le code source, c'est comme écouter les prévisions météorologiques: les gens intelligents iront toujours dehors et regarderont le ciel.  Vous trouverez ci-dessous des conseils pour vérifier et examiner le démarrage du système Linux à l'aide d'outils de débogage familiers.  Une analyse du processus de démarrage d'un système qui fonctionne bien prépare les utilisateurs et les développeurs à résoudre les plantages inévitables. <br><br>  D'une part, le processus de téléchargement est étonnamment simple.  Le noyau du système d'exploitation (noyau) fonctionne sur un seul thread et de manière synchrone sur un noyau (noyau), ce qui peut sembler compréhensible même pour un esprit humain pathétique.  Mais comment démarre le noyau de l'OS?  Quelles fonctions font initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un disque RAM pour l'initialisation initiale</a> ) et les chargeurs de démarrage?  Et attendez, pourquoi le voyant du port Ethernet est-il toujours allumé? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Lisez la suite pour obtenir des réponses à ces questions et à d'autres;  Le code des démos et exercices décrits est également disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  <b>Début de démarrage: statut OFF</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Un état OFF signifie que le système n'est pas alimenté, non?  La simplicité apparente est trompeuse.  Par exemple, le voyant Ethernet est allumé même dans cet état, car le réveil sur réseau local (WOL, réveil sur [le signal du] réseau local) est activé sur votre système.  Assurez-vous en écrivant: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  À la place, il peut être, par exemple, eth0 (ethtool est dans les packages Linux du même nom).  Si le «Wake-on» dans la sortie affiche g, les hôtes distants peuvent démarrer le système en envoyant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MagicPacket</a> .  Si vous ne souhaitez pas allumer votre système à distance vous-même et donner cette opportunité aux autres, désactivez WOL dans le menu BIOS du système ou utilisez: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Un processeur répondant à MagicPacket peut être un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôleur de gestion</a> de la carte mère (BMC) ou une partie d'une interface réseau. <br><br>  <i><b>Intel Management Engine, Platform Controller Hub et Minix</b></i> <br><br>  Le BMC n'est pas le seul microcontrôleur (MCU) qui peut «écouter» un système nominalement éteint.  Les systèmes X86_64 disposent du progiciel Intel Management Engine (IME) pour la gestion à distance des systèmes.  Une large gamme de périphériques, des serveurs aux ordinateurs portables, dispose d'une technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotée de fonctionnalités</a> telles que le contrôle à distance KVM ou le service de licence de capacité Intel.  Selon le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propre outil</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IME a des vulnérabilités non corrigées.</a>  La mauvaise nouvelle est qu'il est difficile de désactiver IME.  Trammell Hudson a créé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le projet me_cleaner, qui efface</a> certains des composants IME les plus flagrants, tels que le serveur Web intégré, mais en même temps, il est possible que l'utilisation du projet transforme le système sur lequel il s'exécute en brique. <br><br>  Le micrologiciel IME et le programme System Management Mode (SMM) qui le suit au démarrage sont basés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le système d'exploitation Minix</a> et s'exécutent sur un processeur Platform Controller Hub distinct, et non sur le processeur principal du système.  SMM lance ensuite le programme UEFI (Universal Extensible Firmware Interface) sur le processeur principal, qui a été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit plus d'une fois</a> .  Le groupe Coreboot a lancé un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NERF (Non-Extensible Reduced Firmware)</a> spectaculairement ambitieux chez Google, qui vise à remplacer non seulement UEFI, mais aussi les premiers composants de l'espace utilisateur Linux, tels que systemd.  En attendant, nous attendons les résultats, les utilisateurs de Linux peuvent acheter des ordinateurs portables auprès de Purism, System76 ou Dell, sur lesquels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IME est désactivé</a> , et nous pouvons espérer des ordinateurs portables avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">processeur ARM 64 bits</a> . <br><br>  <i><b>Chargeurs</b></i> <i><b><br></b></i> <br>  Que fait le firmware amorçable en plus du lancement du logiciel espion suspect?  La tâche du chargeur de démarrage est de fournir au processeur qui vient d'être allumé les ressources nécessaires pour exécuter un système d'exploitation à usage général comme Linux.  Lors de la mise sous tension, il n'y a pas seulement de la mémoire virtuelle, mais aussi de la DRAM jusqu'au moment d'élever son contrôleur.  Le chargeur de démarrage allume ensuite les blocs d'alimentation et analyse les bus et les interfaces pour trouver l'image du noyau et le système de fichiers racine.  Les chargeurs de démarrage populaires, tels que U-Boot et GRUB, prennent en charge à la fois les interfaces courantes comme USB, PCI et NFS, ainsi que d'autres périphériques intégrés plus spécialisés, tels que les flashs NOR et NAND.  Les chargeurs interagissent également avec les périphériques matériels de sécurité, tels que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module de plateforme sécurisée (TPM)</a> , pour établir une chaîne de confiance dès le début du téléchargement. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Exécution du chargeur U-boot dans le bac à sable sur le serveur de génération.</i> <br><br>  Le chargeur de démarrage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">U-Boot</a> open source populaire est pris en charge par les systèmes du Raspberry Pi aux appareils Nintendo, aux cartes de voiture et aux Chromebooks.  Il n'y a pas de journal système et en cas de problème, il se peut même qu'il n'y ait pas de sortie de console.  Pour faciliter le débogage, l'équipe U-Boot fournit un bac à sable pour tester les correctifs sur l'hôte de génération ou même dans le système d'intégration continue.  Sur un système avec des outils de développement communs tels que Git et la collection de compilateurs GNU (GCC) installés, il est facile de comprendre le sandbox U-Boot. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  C'est tout: vous avez lancé U-Boot sur x86_64 et vous pouvez tester des fonctionnalités délicates, par exemple, la répartition des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">périphériques de stockage fictifs</a> , la manipulation des clés secrètes basée sur TPM et le branchement à chaud des périphériques USB.  Le sandbox U-Boot peut être en une étape dans le débogueur GDB.  Le développement utilisant le bac à sable est 10 fois plus rapide que le test en écrasant le chargeur de démarrage sur la carte, de plus, le bac à sable «brique» peut être restauré en appuyant sur Ctrl + C. <br><br>  <b>Lancement du noyau</b> <br><br>  <i><b>Démarrage de l'approvisionnement du noyau</b></i> <br><br>  À la fin de ses tâches, le chargeur de démarrage passera au code du noyau qu'il a chargé dans la mémoire principale et commencera à l'exécuter, en passant tous les paramètres de ligne de commande que l'utilisateur a spécifiés.  Quel programme est le noyau?  file / boot / vmlinuz montre qu'il s'agit de bzImage.  L'arborescence des sources Linux possède <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un outil extract-vmlinux</a> que vous pouvez utiliser pour extraire le fichier: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  Le noyau est un fichier binaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ELF (Executable and Linking Format)</a> , comme les programmes d'espace utilisateur Linux.  Cela signifie que nous pouvons utiliser des commandes binutils comme readelf pour l'apprendre.  Comparez, par exemple, les conclusions suivantes: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  La liste des partitions dans les fichiers binaires est pour la plupart similaire. <br><br>  Donc, le noyau devrait lancer d'autres binaires ELF Linux ... Mais comment fonctionnent les programmes d'espace utilisateur?  Dans la fonction <code>main()</code> , non?  Pas vraiment. <br><br>  Avant d'exécuter la fonction <code>main()</code> , les programmes ont besoin d'un contexte d'exécution, y compris de la mémoire tas (tas) et pile (pile), ainsi que des descripteurs de fichiers pour <code>stdio</code> , <code>stdout</code> et <code>stderr</code> .  Les programmes de l'espace utilisateur obtiennent ces ressources de la bibliothèque standard ( <code>glibc</code> pour la plupart des systèmes Linux).  Tenez compte des éléments suivants: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  Les binaires ELF ont un interpréteur, tout comme les scripts Bash et Python.  Mais il n'a pas besoin d'être spécifié via <code>#!</code>  comme dans les scripts, car ELF est un format Linux natif.  L'interpréteur ELF fournit au fichier binaire toutes les ressources nécessaires en appelant <code>_start()</code> , une fonction disponible dans le paquet source <code>glibc</code> , qui peut être apprise via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDB</a> .  Le noyau, évidemment, n'a pas d'interprète, et il devrait se fournir indépendamment, mais comment? <br><br>  Une étude sur le démarrage d'un noyau avec GDB fournit une réponse à cette question.  Pour commencer, installez le package de débogage du noyau, qui contient la version non coupée de <code>vmlinux</code> , par exemple, <code>apt-get install linux-image-amd64-dbg</code> .  Ou compilez et installez votre propre noyau à partir d'une source, par exemple, en suivant les instructions de l'excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel du noyau Debian</a> .  <code>gdb vmlinux</code> suivi des <code>info files</code> montre la section ELF <code>init.text</code> .  Indiquez le début de l'exécution du programme dans <code>init.text</code> avec <code>l *(address)</code> , où adresse est le début hexadécimal de <code>init.text</code> .  GDB indiquera que le noyau x86_64 est lancé dans le <code><a href="">arch/x86/kernel/head_64.S</a></code> , où nous trouvons la fonction de construction <code>start_cpu0()</code> et le code qui crée explicitement la pile et décompresse zImage avant d'appeler <code>x86_64 start_kernel()</code> .  Les cœurs ARM 32 bits ont un <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> est indépendant de l'architecture, donc la fonction est située dans le noyau <code>init/main.c</code>  On peut dire que <code>start_kernel()</code> est une vraie fonction Linux <code>main()</code> . <br><br>  <b>De start_kernel () à PID 1</b> <br>  <i><b>Manifeste matériel du noyau: tables ACPI et arborescences de périphériques</b></i> <br><br>  Lors du démarrage, le noyau a besoin d'informations sur le matériel en plus du type de processeur pour lequel il a été compilé.  Les instructions du code sont complétées par des données de configuration, qui sont stockées séparément.  Il existe deux méthodes principales de stockage des données: les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arborescences de</a> périphériques et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tables ACPI</a> .  À partir de ces fichiers, le noyau découvre quel équipement doit être exécuté à chaque démarrage. <br><br>  Pour les périphériques intégrés, l'arborescence des périphériques (DU) est un manifeste de l'équipement installé.  DU est un fichier qui se compile en même temps que la source du noyau et se trouve généralement dans / boot avec <code>vmlinux</code> .  Pour voir ce qui se trouve dans l'arborescence des périphériques binaires sur le périphérique ARM, utilisez simplement la commande <code>strings</code> du package binutils dans le fichier dont le nom correspond à <code>/boot/*.dtb</code> , car <code>dtb</code> signifie le fichier binaire de l'arborescence des périphériques (Device-Tree Binary).  Vous pouvez modifier la télécommande en modifiant les fichiers de type JSON qui la composent et en redémarrant le compilateur spécial dtc fourni avec la source du noyau.  DU est un fichier statique dont le chemin est généralement transmis au noyau par les chargeurs de démarrage sur la ligne de commande, mais ces dernières années, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">superposition d'arborescence de périphériques</a> a été ajoutée où le noyau peut charger dynamiquement des fragments supplémentaires en réponse aux événements de connexion à chaud après le chargement. <br><br>  La famille x86 et de nombreux appareils de niveau professionnel ARM64 utilisent le mécanisme alternatif de configuration avancée et d'interface d'alimentation ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACPI)</a> .  Contrairement à la télécommande, les informations ACPI sont stockées dans le système de fichiers virtuel <code>/sys/firmware/acpi/tables</code> , qui est créé par le noyau au démarrage en accédant à la ROM interne.  Pour lire les tables ACPI, utilisez la commande <code>acpica-tools</code> package <code>acpica-tools</code> .  Voici un exemple: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>Les tableaux ACPI sur les ordinateurs portables Lenovo sont prêts pour Windows 2001.</i> <br><br>  Oui, votre système Linux est prêt pour Windows 2001 si vous souhaitez l'installer.  ACPI a à la fois des méthodes et des données, contrairement à la télécommande, qui ressemble plus à un langage de description matérielle.  Les méthodes ACPI restent actives après le démarrage.  Par exemple, si vous exécutez la commande acpi_listen (à partir du package apcid), puis fermez et ouvrez le couvercle de l'ordinateur portable, vous verrez que la fonctionnalité ACPI a continué à fonctionner pendant tout ce temps.  Une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réécriture</a> temporaire et dynamique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des tables ACPI</a> est possible, mais une modification permanente nécessitera une interaction avec le menu du BIOS au démarrage ou le flashage de la ROM.  Au lieu de telles complexités, vous devriez peut-être simplement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer coreboot</a> , un remplacement pour le firmware open source. <br><br>  De start_kernel () à l'espace utilisateur <br><br>  Le code dans <code><a href="">init/main.c</a></code> est étonnamment facile à lire et, curieusement, porte toujours le copyright original de Linus Torvalds de 1991-1992.  Lignes trouvées à <code>dmesg | head</code>  <code>dmesg | head</code> système en cours d'exécution provient essentiellement de ce fichier source.  Le premier CPU est enregistré par le système, les structures de données globales sont initialisées, le planificateur, les gestionnaires d'interruption (IRQ), les temporisateurs et la console sont levés les uns après les autres.  Tous les horodatages avant d'exécuter <code>timekeeping_init()</code> sont nuls.  Cette partie de l'initialisation du noyau est synchrone, c'est-à-dire que l'exécution se produit dans un seul thread.  Les fonctions ne sont exécutées que lorsque la dernière d'entre elles est terminée et renvoyée.  En conséquence, la sortie <code>dmesg</code> sera entièrement reproductible même entre les deux systèmes, tant qu'ils ont la même télécommande ou les mêmes tables ACPI.  Linux se comporte également comme un système d'exploitation en temps réel (RTOS) fonctionnant sur un MCU, tel que QNX ou VxWorks.  Cette situation est stockée dans la fonction <code>rest_init()</code> , qui est appelée par <code>start_kernel()</code> au moment de son achèvement. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Une brève description du processus de démarrage précoce du noyau</i> <i><br></i> <br>  Le modestement nommé <code>rest_init()</code> crée un nouveau thread qui exécute <code>kernel_init()</code> , qui à son tour appelle <code>do_initcalls()</code> .  Les utilisateurs peuvent surveiller le fonctionnement des <code>initcalls</code> en ajoutant <code>initcalls_debug</code> à la ligne de commande du noyau.  Par conséquent, vous obtiendrez l'entité <code>dmesg</code> chaque fois que vous exécutez la fonction <code>initcall</code> .  <code>initcalls</code> passe par sept niveaux consécutifs: early, core, postcore, arch, subsys, fs, device et late.  La partie la plus notable des <code>initcalls</code> pour les utilisateurs est l'identification et l'installation des périphériques du processeur: bus, réseau, stockage, écrans, etc., accompagnés du chargement de leurs modules du noyau.  <code>rest_init()</code> crée également un deuxième thread dans le processeur de démarrage, qui commence par exécuter <code>cpu_idle()</code> pendant que le planificateur distribue son travail. <br><br>  <code>kernel_init()</code> configure également le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multitraitement symétrique</a> (SMP).  Dans les noyaux modernes, vous pouvez trouver ce moment dans la sortie dmesg par la ligne "Bringing up secondary CPUs ...".  SMP fabrique ensuite le CPU à chaud, ce qui signifie qu'il gère son cycle de vie à l'aide d'une machine d'état conditionnellement similaire à celles utilisées dans des appareils tels que les clés USB à détection automatique.  Le système de gestion de l'alimentation du noyau arrête souvent les cœurs individuels (cœurs) et les réveille selon les besoins afin que le même code CPU hotplug soit appelé à plusieurs reprises sur une machine inoccupée.  Jetez un œil à la façon dont un système de gestion de l'alimentation appelle un hotplug CPU à l'aide d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un outil BCC</a> appelé <code>offcputime.py</code> . <br><br>  Notez que le code dans <code>init/main.c</code> presque terminé son exécution lorsque <code>smp_init()</code> exécuté.  Le processeur de démarrage a terminé la plupart de l'initialisation unique, que les autres noyaux n'ont pas besoin de répéter.  Cependant, des threads doivent être créés pour chaque cœur afin de contrôler les interruptions (IRQ), la file d'attente de travail, les temporisateurs et les événements d'alimentation sur chacun d'eux.  Par exemple, regardez les threads du processeur qui servent les softirqs et les files d'attente de travail avec la commande <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  où le champ PSR signifie «processeur».  Chaque cœur doit avoir ses propres temporisateurs et gestionnaires de hotplug cpuhp. <br><br>  Et enfin, comment est lancé l'espace utilisateur?  Vers la fin, <code>kernel_init()</code> recherche un <code>initrd</code> qui peut démarrer le processus <code>init</code> en son nom.  Sinon, le noyau exécute <code>init</code> lui-même.  Pourquoi alors <code>initrd</code> peut être nécessaire? <br><br>  <i><b>Espace utilisateur précoce: qui a commandé initrd?</b></i> <br><br>  En plus de l'arborescence des périphériques, un autre chemin d'initialisation du fichier, éventuellement fourni par le noyau au démarrage, appartient à <code>initrd</code> .  <code>initrd</code> souvent dans / boot avec le fichier bzImage vmlinuz sur x86, ou avec une uImage similaire et une arborescence de périphériques pour ARM.  Une liste du contenu <code>intrd</code> peut être consultée à l'aide de l'outil <code>lsinitramfs</code> , qui fait partie du package <code>initramfs-tools-core</code> .  L'image de distribution initrd contient les répertoires minimum <code>/bin</code> , <code>/sbin</code> et <code>/etc</code> , ainsi que les modules et fichiers du noyau dans <code>/scripts</code> .  Tout devrait être plus ou moins familier, car <code>initrd</code> pour la plupart similaire au système de fichiers racine Linux simplifié.  Cette similitude est un peu trompeuse, car presque tous les exécutables dans <code>/bin</code> et <code>/sbin</code> intérieur du ramdisk sont des liens symboliques vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">binaire BusyBox</a> , ce qui rend les répertoires / bin et / sbin 10 fois plus petits que dans la <code>glibc</code> . <br><br>  Pourquoi essayer de créer un <code>initrd</code> si la seule chose qu'il fait est de charger certains modules et d'exécuter <code>init</code> sur un système de fichiers racine normal?  Prenons un système de fichiers racine chiffré.  Le déchiffrement peut dépendre du chargement du module du noyau stocké dans <code>/lib/modules</code> système de fichiers racine ... et, comme prévu, dans <code>initrd</code> .  Le module crypto peut être compilé statiquement dans le noyau, et non chargé à partir d'un fichier, mais il y a plusieurs raisons de le refuser.  Par exemple, la compilation statique d'un noyau avec des modules peut le rendre trop volumineux pour tenir dans le stockage disponible, ou la compilation statique peut violer les termes de la licence du logiciel.  Sans surprise, les pilotes de stockage, les réseaux et les HID (périphériques d'entrée humains) peuvent également être représentés dans <code>initrd</code> - essentiellement tout code qui n'est pas une partie requise du noyau nécessaire pour monter le système de fichiers racine.  Toujours dans initrd, les utilisateurs peuvent stocker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leur propre code ACPI pour les tables</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Amusez-vous avec la coquille de sauvetage et l'initrd personnalisé.</i> <br><br>  <code>initrd</code> également idéal pour tester les systèmes de fichiers et les périphériques de stockage.  Placez les outils de test dans <code>initrd</code> et exécutez les tests à partir de la mémoire, pas à partir de l'objet de test. <br><br>  Enfin, lorsque <code>init</code> cours d'exécution, le système fonctionne!  Comme les processeurs secondaires sont déjà en cours d'exécution, la machine est devenue une créature asynchrone, paginée, imprévisible et performante que nous connaissons et aimons tous.  En effet, <code>ps -o pid,psr,comm -p</code> indique que le processus d' <code>init</code> espace utilisateur ne s'exécute plus sur le processeur de démarrage. <br><br>  <b>Résumé</b> <br><br>  Le processus de démarrage Linux semble interdit, compte tenu de la quantité de logiciels affectés, même sur un simple périphérique intégré.  D'un autre côté, le processus de démarrage est assez simple, car il n'y a pas de complexité excessive causée par l'éviction du multitâche, du RCU et des conditions de course.  En faisant attention uniquement au noyau et au PID 1, on peut ignorer l'excellent travail accompli par les chargeurs de démarrage et les processeurs auxiliaires pour préparer la plate-forme au lancement du noyau.  Le noyau est certainement différent des autres programmes Linux, mais l'utilisation d'outils pour travailler avec d'autres binaires ELF aidera à mieux comprendre sa structure.  L'étude d'un processus de démarrage réalisable préparera de futurs plantages. <br><br>  LA FIN <br><br>  Nous attendons vos commentaires et questions, comme d'habitude, ici ou à notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leçon ouverte</a> où Leonid sera époustouflé. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425505/">https://habr.com/ru/post/fr425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425493/index.html">Configuration de MikroTik hAP mini pour IPTV Beeline</a></li>
<li><a href="../fr425497/index.html">Meetup Tutu PHP # 2: diffusion d'événements en direct</a></li>
<li><a href="../fr425499/index.html">HyperX Impact DDR4 - SO-DIMM qui pourrait! Ou pourquoi dans un ordinateur portable 64 Go de mémoire avec une fréquence de 3200 MHz?</a></li>
<li><a href="../fr425501/index.html">Tests A / B sur Android de A à Z</a></li>
<li><a href="../fr425503/index.html">Évier Cassandra pour le streaming structuré Spark</a></li>
<li><a href="../fr425507/index.html">Parsim Wikipedia pour les tâches PNL en 4 équipes</a></li>
<li><a href="../fr425511/index.html">Fonctionnalités non évidentes de l'application Rotativa pour la génération de PDF dans l'application ASP.NET MVC</a></li>
<li><a href="../fr425515/index.html">Apple bloque la réparation indépendante des nouveaux modèles de MacBook</a></li>
<li><a href="../fr425517/index.html">Comment Yandex a créé une prévision des précipitations mondiales à l'aide de radars et de satellites</a></li>
<li><a href="../fr425521/index.html">Méthodes protégées dans JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>