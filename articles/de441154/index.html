<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏿 🤳🏻 👨‍👨‍👧 Elf versteckte Perlen von Java 11 🐥 👍🏾 👩🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 11 hat keine innovativen Funktionen eingeführt, enthält jedoch einige Juwelen, von denen Sie vielleicht noch nichts gehört haben. Sie haben sich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elf versteckte Perlen von Java 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441154/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java 11</a> hat keine innovativen Funktionen eingeführt, enthält jedoch einige Juwelen, von denen Sie vielleicht noch nichts gehört haben.  Sie haben sich bereits die neuesten <code>String</code> , <code>Optional</code> , <code>Collection</code> und anderen Arbeitspferden angesehen?  Wenn nicht, dann sind Sie bei der Adresse angelangt: Heute werden wir uns 11 versteckte Juwelen aus Java 11 ansehen! </p><a name="habracut"></a><br><h3 id="vyvod-tipov-dlya-lyambda-parametrov">  Typinferenz für Lambda-Parameter </h3><br><p>  Beim Schreiben eines Lambda-Ausdrucks können Sie wählen, ob Sie Typen explizit angeben oder überspringen möchten: </p><br><pre> <code class="java hljs">Function&lt;String, String&gt; append = string -&gt; string + <span class="hljs-string"><span class="hljs-string">" "</span></span>; Function&lt;String, String&gt; append = (String s) -&gt; s + <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java 10 führte</a> <code>var</code> , konnte aber nicht in Lambdas verwendet werden: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Java 10 Function&lt;String, String&gt; append = (var string) -&gt; string + " ";</span></span></code> </pre> <br><p>  In Java 11 ist dies bereits möglich.  Aber warum?  Es scheint nicht so, als hätte <code>var</code> mehr als nur einen Typpass gegeben.  Obwohl dies der Fall ist, hat die Verwendung von <code>var</code> zwei geringfügige Vorteile: </p><br><ul><li>  macht die Verwendung von <code>var</code> universeller, indem die Ausnahme von der Regel entfernt wird </li><li>  Mit dieser Option können Sie dem Parametertyp Anmerkungen hinzufügen, ohne den vollständigen Namen verwenden zu müssen </li></ul><br><p>  Hier ist ein Beispiel für den zweiten Fall: </p><br><pre> <code class="java hljs">List&lt;EnterpriseGradeType&lt;With, Generics&gt;&gt; types = <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>; types .stream() <span class="hljs-comment"><span class="hljs-comment">// ,     @Nonnull   .filter(type -&gt; check(type)) //  Java 10    ~&gt;  .filter((@Nonnull EnterpriseGradeType&lt;With, Generics&gt; type) -&gt; check(type)) //  Java 11    ~&gt;   .filter((@Nonnull var type) -&gt; check(type))</span></span></code> </pre> <br><p>  Obwohl das Mischen abgeleiteter, expliziter und impliziter Typen in Lambda-Ausdrücken der Form <code>(var type, String option, index) -&gt; ...</code> implementiert werden kann, wurde diese Arbeit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Rahmen von JEP-323</a> ) nicht ausgeführt.  Daher ist es notwendig, einen der drei Ansätze zu wählen und ihn für alle Parameter des Lambda-Ausdrucks einzuhalten.  Die Notwendigkeit, <code>var</code> für alle Parameter anzugeben, um Anmerkungen für einen von ihnen hinzuzufügen, kann etwas ärgerlich sein, ist aber im Allgemeinen tolerierbar. </p><br><h3 id="potokovaya-obrabotka-strok-s-stringlines">  Stream-Verarbeitung von Strings mit <code>'String::lines'</code> </h3><br><p>  Hast du eine mehrzeilige Zeichenfolge?  Möchten Sie mit jeder Zeile etwas anfangen?  Dann ist <code>String::lines</code> die richtige Wahl: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiline = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n\r\n"</span></span>; multiline .lines() <span class="hljs-comment"><span class="hljs-comment">//Stream&lt;String&gt; .map(line -&gt; "// " + line) .forEach(System.out::println); // : //  //  //  // </span></span></code> </pre> <br><p>  Beachten Sie, dass die ursprüngliche Zeile die <code>\r\n</code> Schraubenbegrenzer verwendet und obwohl ich unter Linux bin, hat <code>lines()</code> immer noch beschädigt.  Dies liegt an der Tatsache, dass diese Methode trotz des aktuellen Betriebssystems <code>\r</code> , <code>\n</code> und <code>\r\n</code> als Zeilenumbrüche interpretiert - auch wenn sie in derselben Zeile gemischt sind. </p><br><p>  Ein Zeilenstrom enthält niemals die Zeilentrennzeichen selbst.  Zeilen können leer sein ( <code>"\n\n \n\n"</code> , der 5 Zeilen enthält), aber die letzte Zeile der ursprünglichen Zeile wird ignoriert, wenn sie leer ist ( <code>"\n\n"</code> ; 2 Zeilen).  <em>(Hinweis des Übersetzers: Es ist praktisch, wenn sie eine <code>line</code> , aber eine <code>string</code> , und wir haben beide.)</em> </p><br><p>  Im Gegensatz zu <code>split("\R")</code> sind <code>lines()</code> faul und bieten, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich zitiere</a> , "eine bessere Leistung [...] durch schnellere Suche nach neuen Zeilenumbrüchen".  (Wenn jemand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen</a> Benchmark für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMH</a> zur Überprüfung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einreichen</a> möchte, lassen Sie es mich wissen.)  Es spiegelt auch den Verarbeitungsalgorithmus besser wider und verwendet eine bequemere Datenstruktur (Stream anstelle von Array). </p><br><h3 id="udalenie-probelnyh-simvolov-s-stringstrip-i-tp">  Leerzeichen mit <code>'String::strip'</code> usw. entfernen </h3><br><p>  Anfangs hatte <code>String</code> eine <code>trim</code> zum Entfernen von Leerzeichen, die als alles mit Codes bis <code>U+0020</code> .  Ja, <code>BACKSPACE</code> ( <code>U+0008)</code> ist ein Leerraum wie <code>BELL</code> ( <code>U+0007</code> ), aber <code>LINE SEPARATOR</code> ( <code>U+2028</code> ) wird nicht mehr als solcher betrachtet. </p><br><p>  Java 11 führte die <code>strip</code> Methode ein, deren Ansatz mehr Nuancen aufweist.  Es verwendet die <code>Character::isWhitespace</code> von Java 5, um zu bestimmen, was genau entfernt werden muss.  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seiner Dokumentation</a> geht hervor, dass dies: </p><br><ul><li>  <code>SPACE SEPARATOR</code> , <code>LINE SEPARATOR</code> , <code>PARAGRAPH SEPARATOR</code> , aber kein untrennbarer Raum </li><li>  <code>HORIZONTAL TABULATION</code> ( <code>U+0009</code> ), <code>LINE FEED</code> ( <code>U+000A</code> ), <code>VERTICAL TABULATION</code> ( <code>U+000B</code> ), <code>FORM FEED</code> <code>VERTICAL TABULATION</code> ( <code>U+000B</code> ), <code>CARRIAGE RETURN</code> ( <code>U+000D</code> ) </li><li>  <code>FILE SEPARATOR</code> ( <code>U+001C</code> ), <code>GROUP SEPARATOR</code> ( <code>U+001D</code> ), <code>RECORD SEPARATOR</code> ( <code>U+001E</code> ), <code>UNIT SEPARATOR</code> ( <code>U+001F</code> ) </li></ul><br><p>  Mit der gleichen Logik gibt es zwei weitere Reinigungsmethoden, <code>stripLeading</code> und <code>stripTailing</code> , die genau das tun, was von ihnen erwartet wird. </p><br><p>  Und wenn Sie nur herausfinden müssen, ob die Zeile nach dem Entfernen von Leerzeichen leer ist, müssen Sie sie nicht wirklich löschen - verwenden Sie einfach <code>isBlank</code> : </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span>.isBlank(); <span class="hljs-comment"><span class="hljs-comment">//  ~&gt; true " ".isBlank(); //   ~&gt; false</span></span></code> </pre> <br><h3 id="povtorenie-strok-s-stringrepeat">  Wiederholen von Zeichenfolgen mit <code>'String::repeat'</code> </h3><br><p>  Fangen Sie die Idee: </p><br><h6 id="shag-1-pristalno-sledim-za-razvitiem-jdk">  Schritt 1: JDK im Auge behalten </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/874/8df/a06/8748dfa06086f57aae4b16686d9c6c04.png" alt="Behalten Sie die JDK-Entwicklung im Auge"></p><br><h6 id="shag-2-razyskivaem-na-stackoverflow-svyazannye-voprosy">  Schritt 2: Finden von Fragen zu StackOverflow </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df2/3f8/7ae/df23f87ae8d723f53beb5617017de913.png" alt="Suchen Sie nach verwandten Fragen zu Stackoverflow"></p><br><h6 id="shag-3-priletaem-s-novym-otvetom-osnovannym-na-buduschih-izmeneniyah">  Schritt 3: Ankunft mit einer neuen Antwort basierend auf zukünftigen Änderungen </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b68/556/748/b685567487db2b1ea3cab180b8f39089.png" alt="Kommen Sie mit einer neuen Antwort, die auf bevorstehenden Änderungen basiert"></p><br><h6 id="shag-4-">  Schritt 4: ???? </h6><br><h6 id="shag-4-profit">  Schritt 4: Gewinn </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/695/015/36969501570588225baae6cd5dd3edb1.gif" alt="¯ \ _ (ツ) _ / ¯"></p><br><p>  Wie Sie sich vorstellen können, hat <code>String</code> eine neue <code>repeat(int)</code> .  Es funktioniert genau im Einklang mit den Erwartungen und es gibt wenig zu diskutieren. </p><br><h3 id="sozdanie-putey-s-pathof">  Erstellen von Pfaden mit <code>'Path::of'</code> </h3><br><p>  Ich mag die <code>Path</code> API sehr, aber das Konvertieren von Pfaden zwischen verschiedenen Ansichten (wie <code>Path</code> , <code>File</code> , <code>URL</code> , <code>URI</code> und <code>String</code> ) ist immer noch ärgerlich.  Dieser Punkt ist in Java 11 weniger verwirrend geworden, indem zwei <code>Paths::get</code> Methoden in <code>Path::of</code> Methoden kopiert wurden: </p><br><pre> <code class="java hljs">Path tmp = Path.of(<span class="hljs-string"><span class="hljs-string">"/home/nipa"</span></span>, <span class="hljs-string"><span class="hljs-string">"tmp"</span></span>); Path codefx = Path.of(URI.create(<span class="hljs-string"><span class="hljs-string">"http://codefx.org"</span></span>));</code> </pre> <br><p>  Sie können als kanonisch betrachtet werden, da beide alten <code>Paths::get</code> Methoden neue Optionen verwenden. </p><br><h3 id="chtenie-i-zapis-faylov-s-filesreadstring-i-fileswritestring">  Lesen und Schreiben von Dateien mit <code>'Files::readString'</code> und <code>'Files::writeString'</code> </h3><br><p>  Wenn ich aus einer großen Datei lesen muss, verwende ich normalerweise <code>Files::lines</code> , um einen faulen Stream ihrer Zeilen zu erhalten.  Um eine große Datenmenge zu schreiben, die möglicherweise nicht vollständig im Speicher gespeichert ist, verwende ich <code>Files::write</code> um sie als <code>Iterable&lt;String&gt;</code> . </p><br><p>  Aber was ist mit dem einfachen Fall, wenn ich den Inhalt einer Datei als einzelne Zeile verarbeiten möchte?  Dies ist nicht sehr praktisch, da <code>Files::readAllBytes</code> und die entsprechenden Varianten von <code>Files::write</code> mit Byte-Arrays arbeiten. </p><br><p>  Und dann erscheint Java 11 und <code>writeString</code> den <code>Files</code> <code>readString</code> und <code>writeString</code> : </p><br><pre> <code class="java hljs">String haiku = Files.readString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku.txt"</span></span>)); String modified = modify(haiku); Files.writeString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku-mod.txt"</span></span>), modified);</code> </pre> <br><p>  Klar und einfach zu bedienen.  Bei Bedarf können Sie den <code>Charset</code> an <code>readString</code> und in <code>writeString</code> auch an ein <code>OpenOptions</code> Array übergeben. </p><br><h3 id="pustoe-io-s-readernullreader-i-tp">  Leeren Sie die E / A mit <code>'Reader::nullReader'</code> usw. </h3><br><p>  <code>OutputStream</code> Sie einen <code>OutputStream</code> , der nirgendwo schreibt?  Oder ein leerer <code>InputStream</code> ?  Was ist mit <code>Reader</code> und <code>Writer</code> , die nichts tun?  Java 11 bietet alles: </p><br><pre> <code class="java hljs">InputStream input = InputStream.nullInputStream(); OutputStream output = OutputStream.nullOutputStream(); Reader reader = Reader.nullReader(); Writer writer = Writer.nullWriter();</code> </pre> <br><p>  <em>(Anmerkung des Übersetzers: In <code>commons-io</code> diese Klassen seit ungefähr 2014.)</em> </p><br><p>  Ich bin jedoch überrascht - ist <code>null</code> wirklich das beste Präfix?  Mir gefällt nicht, wie es "absichtliche Abwesenheit" bedeutet ... Vielleicht wäre es besser, <code>noOp</code> zu verwenden?  <em>(Anmerkung des Übersetzers: Höchstwahrscheinlich wurde dieses Präfix aufgrund der allgemeinen Verwendung von <code>/dev/null</code> .)</em> </p><br><h3 id="-----s-collectiontoarray">  <code>{ } ~&gt; [ ]</code> mit <code>'Collection::toArray'</code> </h3><br><p>  Wie konvertieren Sie Sammlungen in Arrays? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Java 11 List&lt;String&gt; list = /*...*/; Object[] objects = list.toArray(); String[] strings_0 = list.toArray(new String[0]); String[] strings_size = list.toArray(new String[list.size()]);</span></span></code> </pre> <br><p>  Die erste Option, <code>objects</code> , verliert alle Informationen zu Typen, sodass sie im Flug ist.  Was ist mit dem Rest?  Beide sind sperrig, aber der erste ist kürzer.  Letzteres erstellt ein Array mit der erforderlichen Größe, damit es produktiver aussieht (dh es scheint "produktiver zu sein", siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glaubwürdigkeit</a> ).  Aber ist es wirklich produktiver?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nein, im Gegenteil, es ist</a> (im Moment) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">langsamer</a> . </p><br><p>  Aber warum sollte mich das interessieren?  Gibt es nicht einen besseren Weg, dies zu tun?  In Java 11 gibt es: </p><br><pre> <code class="java hljs">String[] strings_fun = list.toArray(String[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br><p>  Eine neue Variante von <code>Collection::toArray</code> , die <code>IntFunction&lt;T[]&gt;</code> akzeptiert, d. H.  Eine Funktion, die die Größe eines Arrays abruft und ein Array mit der erforderlichen Größe zurückgibt  Es kann kurz als Referenz auf einen Konstruktor der Form <code>T[]::new</code> (für ein bekanntes <code>T</code> ) ausgedrückt werden. </p><br><p>  Interessanterweise <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code> die Standardimplementierung von <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code> immer <code>0</code> an den Array-Generator.  Zuerst habe ich beschlossen, dass diese Lösung auf der besten Leistung für Arrays mit einer Länge von Null basiert. Jetzt denke ich, dass der Grund dafür sein kann, dass die Berechnung der Größe für einige Sammlungen eine sehr teure Operation sein kann und Sie diesen Ansatz nicht in der Standardimplementierung von <code>Collection</code> .  Bestimmte Sammlungsimplementierungen wie <code>ArrayList</code> können diesen Ansatz jedoch ändern, in Java 11 jedoch nicht.  Das ist es nicht wert, denke ich. </p><br><h3 id="proverka-otsutstviya-s-optionalisempty">  Abwesenheitsprüfung mit <code>'Optional::isEmpty'</code> </h3><br><p>  Bei der häufigen Verwendung von <code>Optional</code> , insbesondere in großen Projekten, bei denen Sie häufig auf einen nicht <code>Optional</code> Ansatz stoßen, müssen Sie häufig prüfen, ob dieser einen Wert hat.  <code>Optional::isPresent</code> gibt es eine <code>Optional::isPresent</code> Methode.  Aber genauso oft muss man das Gegenteil wissen - dass <code>Optional</code> leer ist.  Kein Problem, benutze einfach <code>!opt.isPresent()</code> , oder? </p><br><p>  Natürlich ist es so möglich, aber es ist fast immer einfacher, die <code>if</code> Logik zu verstehen, <code>if</code> ihre Bedingung nicht invertiert ist.  Und manchmal erscheint <code>Optional</code> am Ende einer langen Kette von Anrufen, und wenn Sie es auf nichts überprüfen müssen, müssen Sie wetten <code>!</code>  ganz am Anfang: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isPresent(); }</code> </pre> <br><p>  In diesem Fall überspringen Sie es <code>!</code>  sehr einfach.  Ab Java 11 gibt es eine bessere Option: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isEmpty(); }</code> </pre> <br><h3 id="invertirovanie-predikatov-s-predicatenot">  Prädikate mit <code>'Predicate::not'</code> invertieren </h3><br><p>  Apropos Invertieren ... Die <code>Predicate</code> verfügt über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> <code>negate</code> : Sie gibt ein neues Prädikat zurück, das dieselbe Prüfung durchführt, aber das Ergebnis invertiert.  Leider schaffe ich es selten, es zu benutzen ... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Stream .of("a", "b", "", "c") // ,  ~&gt;        .filter(s -&gt; !s.isBlank()) //          ~&gt;  .filter((String::isBlank).negate()) // ,  ~&gt;       .filter(((Predicate&lt;String&gt;) String::isBlank).negate()) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Das Problem ist, dass ich selten Zugriff auf die <code>Predicate</code> Instanz habe.  Häufiger möchte ich eine solche Instanz über einen Link zu einer Methode abrufen (und invertieren), aber damit dies funktioniert, muss der Compiler wissen, wohin er den Verweis auf die Methode bringen soll - ohne sie kann er nichts tun.  Und genau das passiert, wenn Sie das <code>(String::isBlank).negate()</code> : Der Compiler weiß nicht mehr, was <code>String::isBlank</code> sein soll, und gibt auf.  Eine korrekt angegebene Kaste behebt dies, aber zu welchem ​​Preis? </p><br><p>  Obwohl es eine einfache Lösung gibt.  Verwenden Sie nicht die <code>negate</code> instance, sondern die neue statische Methode <code>Predicate.not(Predicate&lt;T&gt;)</code> aus Java 11: </p><br><pre> <code class="java hljs">Stream .of(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   `java.util.function.Predicate.not` .filter(not(String::isBlank)) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Schon besser! </p><br><h3 id="regulyarnye-vyrazheniya-kak-predikat-s-patternasmatchpredicate">  Reguläre Ausdrücke als Prädikat mit <code>'Pattern::asMatchPredicate'</code> </h3><br><p>  Gibt es einen regulären Ausdruck?  Müssen Sie Daten darauf filtern?  Wie wäre es damit: </p><br><pre> <code class="java hljs">Pattern nonWordCharacter = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\W"</span></span>); Stream .of(<span class="hljs-string"><span class="hljs-string">"Metallica"</span></span>, <span class="hljs-string"><span class="hljs-string">"Motörhead"</span></span>) .filter(nonWordCharacter.asPredicate()) .forEach(System.out::println);</code> </pre> <br><p>  Ich habe mich sehr gefreut, diese Methode zu finden!  Es ist erwähnenswert, dass dies eine Methode aus Java 8 ist. Hoppla, ich habe sie dann verpasst.  Java 11 hat eine weitere ähnliche Methode hinzugefügt: <code>Pattern::asMatchPredicate</code> .  Was ist der Unterschied? </p><br><ul><li>  <code>asPredicate</code> prüft, ob die Zeichenfolge <strong>oder ein Teil der Zeichenfolge</strong> mit dem Muster übereinstimmt (funktioniert wie <code>s -&gt; this.matcher(s).find()</code> ) </li><li>  <code>asMatchPredicate</code> prüft, ob die <strong>gesamte Zeichenfolge</strong> mit dem Muster übereinstimmt (funktioniert wie <code>s -&gt; this.matcher(s).matches()</code> ) </li></ul><br><p>  Zum Beispiel haben wir einen regulären Ausdruck, der Telefonnummern überprüft, aber keine <code>^</code> und <code>$</code> , um den Anfang und das Ende einer Zeile zu verfolgen.  Dann funktioniert der folgende Code nicht wie erwartet: </p><br><pre> <code class="java hljs">prospectivePhoneNumbers .stream() .filter(phoneNumberPatter.asPredicate()) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::robocall);</code> </pre> <br><p>  Hast du einen Fehler bemerkt?  Eine Zeile wie <code>" -152 ? +1-202-456-1414"</code> wird gefiltert, da sie eine gültige Telefonnummer enthält.  Auf der anderen Seite lässt <code>Pattern::asMatchPredicate</code> nicht zu, da die <strong>gesamte</strong> Zeichenfolge nicht <strong>mehr</strong> mit dem Muster übereinstimmt. </p><br><h3 id="samoproverka">  Selbsttest </h3><br><p>  Hier ist eine Übersicht aller elf Perlen - erinnern Sie sich noch daran, was jede Methode bewirkt?  Wenn ja, haben Sie den Test bestanden. </p><br><ul><li>  in <code>String</code> : <br><ul><li> <code>Stream&lt;String&gt; lines()</code> </li> <li> <code>String strip()</code> </li> <li> <code>String stripLeading()</code> </li> <li> <code>String stripTrailing()</code> </li> <li> <code>boolean isBlank()</code> </li> <li> <code>String repeat(int)</code> </li> </ul></li><li>  im <code>Path</code> : <br><ul><li> <code>static Path of(String, String...)</code> </li> <li> <code>static Path of(URI)</code> </li> </ul></li><li>  in <code>Files</code> : <br><ul><li> <code>String readString(Path) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, OpenOption...) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, Charset, OpenOption...) throws IOException</code> </li> </ul></li><li>  in <code>InputStream</code> : <code>static InputStream nullInputStream()</code> </li><li>  in <code>OutputStream</code> : <code>static OutputStream nullOutputStream()</code> </li><li>  im <code>Reader</code> : <code>static Reader nullReader()</code> </li><li>  in <code>Writer</code> : <code>static Writer nullWriter()</code> </li><li>  in <code>Collection</code> : <code>T[] toArray(IntFunction&lt;T[]&gt;)</code> </li><li>  in <code>Optional</code> : <code>boolean isEmpty()</code> </li><li>  im <code>Predicate</code> : <code>static Predicate&lt;T&gt; not(Predicate&lt;T&gt;)</code> </li><li>  im <code>Pattern</code> : <code>Predicate&lt;String&gt; asMatchPredicate()</code> </li></ul><br><p>  Viel Spaß mit Java 11! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441154/">https://habr.com/ru/post/de441154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441142/index.html">12 Punkte Conversion-Wachstum oder Inhalte, die sich wirklich verkaufen</a></li>
<li><a href="../de441146/index.html">Industrielle drahtlose Netzwerke: Welches soll man wählen?</a></li>
<li><a href="../de441148/index.html">Wie man richtig mit Fehlern umgeht: Stille ist nicht immer gut</a></li>
<li><a href="../de441150/index.html">Erste Einführung in das HTTP-Protokoll durch Schreiben des einfachsten Java-Webservers</a></li>
<li><a href="../de441152/index.html">So minimieren Sie Fehler bei der Integration in externe Services: die Erfahrung eines Online-Brokers</a></li>
<li><a href="../de441158/index.html">Wie Ethik zum teuersten Thema im Silicon Valley wurde und Philosophie zur praktischsten Lösung wurde</a></li>
<li><a href="../de441160/index.html">Wie man lernt zu bestimmen, wann man nein sagt</a></li>
<li><a href="../de441166/index.html">Wir erhalten das Master-Passwort vom gesperrten Passwort-Manager 1Password 4</a></li>
<li><a href="../de441168/index.html">QUIC DataChannels: Erste Schritte</a></li>
<li><a href="../de441172/index.html">Wie der 3D-Druckmarkt 2018 wuchs und was er für das Geschäft bedeutet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>