<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏼 😀 👈🏼 Konvergensi dengan Kubernet ☹️ 👨🏽‍🌾 ☕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Standarisasi total 


 Saya menyiapkan bahan ini untuk pidato saya di konferensi dan bertanya kepada direktur teknis kami apa fitur utama Kubernetes u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konvergensi dengan Kubernet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/427441/"><h3 id="totalnaya-standartizaciya">  Standarisasi total </h3><br><p>  Saya menyiapkan bahan ini untuk pidato saya di konferensi dan bertanya kepada direktur teknis kami apa fitur utama Kubernetes untuk organisasi kami.  Dia menjawab: </p><br><blockquote>  Para pengembang sendiri tidak mengerti berapa banyak pekerjaan ekstra yang mereka lakukan. </blockquote><p>  Rupanya, dia terinspirasi oleh buku yang baru-baru ini dibaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Factfulness"</a> - sulit untuk melihat perubahan kecil dan berkelanjutan menjadi lebih baik, dan kita terus-menerus melupakan kemajuan kita. </p><br><p>  Tetapi beralih ke Kubernetes jelas tidak signifikan. </p><br><p><img src="https://habrastorage.org/webt/72/vu/bn/72vubnen7dnspn7tp9wmy2if9cu.png"></p><a name="habracut"></a><br><p> Hampir 30 tim kami menjalankan semua atau sebagian beban kerja pada kluster.  Sekitar 70% dari lalu lintas HTTP kami dihasilkan oleh aplikasi pada kluster Kubernetes.  Ini mungkin merupakan konvergensi teknologi terbesar sejak saya bergabung dengan perusahaan setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Forward membeli uSwitch</a> pada tahun 2010, ketika kami beralih dari .NET dan server fisik ke AWS dan dari sistem monolitik ke layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mikro</a> . </p><br><p>  Dan itu semua terjadi dengan sangat cepat.  Pada akhir 2017, semua tim menggunakan infrastruktur AWS mereka.  Mereka mengatur load balancers, instance EC2, pembaruan cluster ECS, dan hal-hal seperti itu.  Sedikit lebih dari setahun berlalu, dan semuanya berubah. </p><br><p>  Kami menghabiskan sedikit waktu untuk berkumpul, dan sebagai hasilnya, Kubernetes membantu kami memecahkan masalah yang mendesak - cloud kami tumbuh, organisasi menjadi lebih rumit, dan kami berjuang untuk menyesuaikan orang-orang baru ke dalam tim.  Kami tidak mengubah organisasi untuk menggunakan Kubernetes.  Sebaliknya - kami menggunakan Kubernetes untuk mengubah organisasi. </p><br><p>  Pengembang mungkin tidak memperhatikan perubahan besar, tetapi datanya berbicara sendiri.  Lebih lanjut tentang ini nanti. </p><br><hr><br><p>  Beberapa tahun yang lalu saya berada di sebuah konferensi Clojure dan mendengar ceramah oleh Michael Nygard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang arsitektur yang tidak dapat dibawa ke keadaan akhirnya</a> .  Dia membuka mata saya.  Sistem yang rapi dan tertata terlihat karikatur ketika membandingkan toko-toko TV dengan produk dapur dan arsitektur perangkat lunak berskala besar - sistem yang ada terlihat seperti pisau bisu, dan beberapa jenis bubur keluar bukannya irisan.  Tanpa pisau baru, tidak ada yang perlu dipikirkan tentang salad. </p><br><p>  Ini tentang bagaimana organisasi memuja proyek tiga tahun: tahun pertama adalah pengembangan dan persiapan, tahun kedua implementasi, yang ketiga kembali.  Dalam sebuah ceramah, ia mengatakan bahwa proyek seperti itu biasanya dilakukan terus menerus dan jarang sampai pada akhir tahun kedua (seringkali karena akuisisi oleh perusahaan lain dan perubahan arah dan strategi), sehingga arsitektur yang biasa adalah </p><br><blockquote>  stratifikasi perubahan dalam beberapa kemiripan stabilitas. </blockquote><p>  Dan uSwitch adalah contoh yang bagus. </p><br><p>  Kami beralih ke AWS karena berbagai alasan - sistem kami tidak dapat mengatasi beban puncak, dan organisasi terhalang oleh sistem yang terlalu kaku dan tim yang terkait erat yang dibentuk untuk proyek tertentu dan dibagi dengan spesialisasi. </p><br><p>  Kami tidak akan berhenti semuanya, mentransfer semua sistem dan memulai dari awal.  Kami menciptakan layanan baru dengan proxy melalui load balancer yang ada dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara bertahap mencekik</a> aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lama</a> .  Kami ingin segera menunjukkan pengembalian dan pada minggu pertama kami melakukan pengujian A / B versi pertama dari layanan baru dalam produksi.  Sebagai hasilnya, kami mengambil produk jangka panjang dan mulai membentuk tim untuk mereka dari pengembang, desainer, analis, dll. Dan kami segera melihat hasilnya.  Pada 2010, ini tampak seperti revolusi nyata. </p><br><p>  Tahun demi tahun, kami menambahkan tim, layanan, dan aplikasi baru dan secara bertahap "mencekik" sistem monolitik.  Tim berkembang dengan cepat - sekarang mereka bekerja secara independen satu sama lain dan terdiri dari spesialis di semua bidang yang diperlukan.  Kami meminimalkan interaksi tim untuk rilis produk.  Kami telah mengalokasikan beberapa perintah hanya untuk konfigurasi penyeimbang beban. </p><br><p>  Tim sendiri memilih metode pengembangan, alat dan bahasa.  Kami menetapkan tugas untuk mereka, dan mereka sendiri menemukan solusi, karena mereka adalah yang terbaik dalam hal ini.  Dengan AWS, perubahan ini menjadi lebih mudah. </p><br><p>  Kami secara intuitif mengikuti prinsip pemrograman - tim yang terhubung secara longgar satu sama lain akan lebih kecil kemungkinannya untuk berkomunikasi, dan kami tidak perlu menghabiskan sumber daya berharga untuk mengoordinasikan pekerjaan mereka.  Semua ini dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku Accelerate yang</a> baru diterbitkan. </p><br><p>  Hasilnya, seperti dijelaskan oleh Michael Nygard, kami mendapat sistem banyak lapisan perubahan - beberapa sistem diotomatisasi dengan Wayang, beberapa dengan Terraform, di suatu tempat kami menggunakan ECS, di suatu tempat EC2. </p><br><p>  Pada tahun 2012, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami bangga dengan arsitektur kami, yang dapat dengan mudah diubah menjadi percobaan</a> , menemukan solusi yang sukses dan mengembangkannya. </p><br><p>  Tetapi pada tahun 2017, kami menyadari bahwa banyak yang telah berubah. </p><br><hr><br><p>  AWS sekarang jauh lebih kompleks daripada tahun 2010. Ini menawarkan banyak pilihan dan fitur - tetapi bukan tanpa konsekuensi.  Hari ini, tim mana pun yang bekerja dengan EC2 harus memilih VPC, konfigurasi jaringan, dan banyak lagi. </p><br><p>  Kami mengalaminya sendiri - tim mulai mengeluh bahwa mereka menghabiskan lebih banyak waktu untuk memelihara infrastruktur, misalnya memperbarui contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam kluster AWS ECS</a> , mesin EC2, beralih dari penyeimbang ELB ke ALB, dll. </p><br><p>  Pada pertengahan 2017, di sebuah acara perusahaan, saya mendesak semua orang untuk membakukan pekerjaan mereka untuk meningkatkan kualitas sistem secara keseluruhan.  Saya menggunakan metafora gunung es untuk menunjukkan bagaimana kami membuat dan memelihara perangkat lunak: </p><br><p><img src="https://habrastorage.org/webt/sn/ci/pt/sncipt6axzuuqa2pcqxrpbcwzh0.png"></p><br><p>  Saya mengatakan bahwa sebagian besar tim di perusahaan kami harus membuat layanan atau produk dan fokus pada pemecahan masalah, kode aplikasi, platform dan perpustakaan, dll. Dalam urutan itu.  Banyak pekerjaan yang masih ada di bawah air - integrasi kayu bulat, meningkatkan daya pengamatan, mengelola rahasia, dll. </p><br><p>  Pada saat itu, setiap tim pengembang aplikasi menangani hampir seluruh gunung es dan membuat semua keputusan dengan sendirinya - memilih bahasa, lingkungan pengembangan, alat perpustakaan dan metrik, sistem operasi, tipe instance, penyimpanan. </p><br><p>  Di dasar piramida, kami memiliki infrastruktur Amazon Web Services.  Tetapi tidak semua layanan AWS sama.  Mereka memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Backend-as-a-Service (BaaS)</a> , misalnya untuk otentikasi dan penyimpanan data.  Dan ada layanan lain yang relatif rendah, seperti EC2.  Saya ingin mempelajari data dan memahami bahwa tim memiliki alasan untuk mengeluh dan mereka benar-benar menghabiskan lebih banyak waktu bekerja dengan layanan tingkat rendah dan membuat banyak keputusan yang tidak penting. </p><br><p>  Saya membagi layanan menjadi beberapa kategori, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CloudTrail. Saya</a> mengumpulkan semua statistik yang tersedia, dan kemudian menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BigQuery</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Athena</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ggplot2</a> untuk melihat bagaimana situasi untuk pengembang telah berubah belakangan ini.  Pertumbuhan untuk layanan seperti RDS, Redshift, dll., Kami anggap diinginkan (dan diharapkan), dan pertumbuhan untuk EC2, CloudFormation, dll. - sebaliknya. </p><br><p><img src="https://habrastorage.org/webt/dd/bd/-f/ddbd-fy5t4wzicbekukgyx_lji0.png"></p><br><p>  Setiap titik pada diagram menunjukkan persentil ke-90 (merah), ke-80 (hijau) dan ke-50 (biru) untuk jumlah <strong>layanan tingkat rendah</strong> yang digunakan orang-orang kita setiap minggu selama periode tertentu.  Saya menambahkan garis smoothing untuk menunjukkan tren. </p><br><p>  Meskipun kami bertujuan untuk abstraksi tingkat tinggi ketika menggunakan perangkat lunak, misalnya, menggunakan kontainer dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon ECS</a> , pengembang kami secara teratur menggunakan lebih banyak layanan AWS dan tidak cukup mengabaikan kesulitan dalam mengelola sistem.  Dalam dua tahun, jumlah layanan meningkat dua kali lipat untuk 50% karyawan dan hampir tiga kali lipat untuk 20%. </p><br><p>  Ini membatasi pertumbuhan perusahaan kami.  Tim mencari otonomi, tetapi bagaimana cara merekrut orang baru?  Kami membutuhkan pengembang aplikasi dan produk yang kuat serta pengetahuan tentang sistem AWS yang semakin canggih. </p><br><hr><br><p>  Kami ingin memperluas tim kami dan pada saat yang sama menjaga prinsip-prinsip keberhasilan kami: otonomi, koordinasi minimal, dan infrastruktur swalayan. </p><br><p>  Dengan Kubernetes, kami menyelesaikan ini dengan abstraksi yang berfokus pada aplikasi dan kemampuan untuk mempertahankan dan mengkonfigurasi cluster dengan koordinasi tim yang minimal. </p><br><h3 id="abstrakcii-s-fokusom-na-prilozheniya">  Abstraksi yang berfokus pada aplikasi </h3><br><p>  Konsep Kubernet mudah dicocokkan dengan bahasa yang digunakan pengembang aplikasi.  Misalkan Anda mengelola versi aplikasi sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyebaran</a> .  Anda dapat menjalankan beberapa replika di belakang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan</a> dan memetakannya ke HTTP melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ingress</a> .  Dan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber daya pengguna,</a> Anda dapat memperluas dan mengkhususkan bahasa ini tergantung pada apa yang Anda butuhkan. </p><br><p>  Tim bekerja lebih efisien dengan abstraksi ini.  Pada dasarnya, contoh ini memiliki semua yang Anda butuhkan untuk menggunakan dan menjalankan aplikasi web.  Sisanya adalah Kubernet. </p><br><p>  Dalam gambar dengan gunung es, konsep-konsep ini berada di permukaan air dan menggabungkan tugas-tugas pengembang dari atas dengan platform di bawah ini.  Tim manajemen kluster dapat membuat keputusan tingkat rendah dan tidak penting (tentang mengelola metrik, penebangan, dll.) Dan pada saat yang sama berbicara bahasa yang sama dengan pengembang di atas air. </p><br><p>  Pada 2010, uSwitch memiliki tim tradisional untuk melakukan servis sistem monolitik, dan baru-baru ini kami memiliki departemen TI yang mengelola sebagian akun AWS kami.  Tampak bagi saya bahwa kurangnya konsep umum secara serius menghambat pekerjaan tim ini. </p><br><p>  Cobalah mengatakan sesuatu yang berguna jika Anda hanya memiliki instance EC2 dalam kosakata, load balancers, dan subnet Anda.  Sulit atau bahkan tidak mungkin untuk menggambarkan esensi aplikasi.  Itu bisa berupa paket Debian, penyebaran melalui Capistrano, dan sebagainya.  Kami tidak dapat mendeskripsikan aplikasi dalam bahasa yang umum untuk semua. </p><br><p>  Pada awal 2000-an, saya bekerja di ThoughtWorks di London.  Pada wawancara itu, saya disarankan untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Problem-Oriented Designing</a> Eric Evans.  Saya membeli buku dalam perjalanan pulang dan mulai membaca di kereta.  Sejak itu, saya mengingatnya di hampir setiap proyek dan sistem. </p><br><p>  Salah satu konsep utama buku ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa tunggal</a> di mana berbagai tim berkomunikasi.  Kubernetes hanya menyediakan bahasa yang disatukan untuk pengembang dan tim pemeliharaan infrastruktur, dan ini adalah salah satu keunggulan utamanya.  Plus itu dapat diperluas dan ditambah dengan bidang subjek lain dan lini bisnis. </p><br><p>  Komunikasi dalam bahasa yang umum lebih produktif, tetapi kita masih perlu membatasi interaksi antar tim sebanyak mungkin. </p><br><h3 id="neobhodimyy-minimum-vzaimodeystviya">  Diperlukan interaksi minimum </h3><br><p>  Para penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Accelerate</a> menyoroti karakteristik arsitektur yang digabungkan secara longgar dengan tim TI yang bekerja lebih efisien: </p><br><blockquote>  Pada 2017, keberhasilan pengiriman berkelanjutan bergantung pada apakah tim dapat: <br>  Serius mengubah struktur sistem Anda tanpa izin manajemen. <br>  Serius mengubah struktur sistem Anda, tanpa menunggu tim lain untuk mengubah mereka, dan tanpa membuat banyak pekerjaan yang tidak perlu untuk tim lain. <br>  Lakukan tugas mereka tanpa berkomunikasi atau mengoordinasikan pekerjaan mereka dengan tim lain. <br>  Menyebarkan dan merilis produk atau layanan sesuai permintaan, terlepas dari layanan lain yang terkait dengannya. <br>  Lakukan sebagian besar tes sesuai permintaan, tanpa lingkungan uji terintegrasi. </blockquote><p>  Kami membutuhkan perangkat lunak multi-tenant cluster terpusat untuk semua tim, tetapi pada saat yang sama kami ingin mempertahankan karakteristik ini.  Kami belum mencapai yang ideal, tetapi kami berusaha sebaik mungkin: </p><br><ul><li>  Kami memiliki beberapa kelompok kerja, dan tim sendiri memilih tempat untuk menjalankan aplikasi.  Kami belum menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">federasi</a> (kami sedang menunggu dukungan AWS), tetapi kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utusan</a> untuk load balancing pada penyeimbang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ingress</a> di berbagai kluster.  Kami mengotomatiskan sebagian besar tugas ini menggunakan pipa pengiriman kontinu (kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Drone</a> ) dan layanan AWS lainnya. </li><li>  Semua cluster memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">namespace yang</a> sama.  Sekitar satu untuk setiap tim. </li><li>  Kami mengontrol akses ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang nama</a> melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RBAC</a> (kontrol akses berbasis peran).  Untuk otentikasi dan otorisasi, kami menggunakan identitas perusahaan di Active Directory. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skala cluster secara otomatis</a> , dan kami melakukan yang terbaik untuk mengoptimalkan waktu mulai dari node.  Masih membutuhkan beberapa menit, tetapi, secara umum, bahkan dengan beban kerja yang besar, kami melakukannya tanpa koordinasi. </li><li>  Skala aplikasi secara otomatis berdasarkan metrik level aplikasi dari Prometheus.  Tim pengembang mengontrol penskalaan otomatis aplikasi mereka dengan metrik kueri per detik, operasi per detik, dll. Berkat penskalaan otomatis kluster, sistem menyiapkan node ketika permintaan melebihi kemampuan cluster saat ini. </li><li>  Kami menulis Go dengan alat baris perintah bernama <strong>u</strong> yang membakukan otentikasi perintah di Kubernetes, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vault</a> , permintaan kredensial AWS sementara, dan sebagainya. </li></ul><br><p><img src="https://habrastorage.org/webt/oy/qv/bm/oyqvbm7x1orfe2kpjxubpis6r60.png"></p><br><p>  Saya tidak yakin bahwa dengan Kubernetes kami memiliki lebih banyak otonomi, tapi itu pasti tetap pada tingkat tinggi, dan pada saat yang sama kami menyingkirkan beberapa masalah. </p><br><hr><br><p>  Beralih ke Kubernetes cepat.  Diagram menunjukkan jumlah total <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang nama</a> (kira-kira sama dengan jumlah perintah) dalam kelompok kerja kami.  Yang pertama muncul pada Februari 2017. </p><br><p><img src="https://habrastorage.org/webt/ux/y_/q_/uxy_q_hravmwkjhead1bgzkspz4.png"></p><br><p>  Kami punya alasan untuk terburu-buru - kami ingin menyelamatkan tim kecil yang fokus pada produk mereka dari kekhawatiran tentang infrastruktur. </p><br><p>  Tim pertama setuju untuk beralih ke Kubernetes ketika server aplikasi mereka kehabisan ruang karena pengaturan logrotate yang tidak tepat.  Transisi hanya memakan waktu beberapa hari, dan mereka kembali ke bisnis. </p><br><p>  Baru-baru ini, tim telah beralih ke Kubetnetes untuk alat yang ditingkatkan.  Cluster Kubernetes menyederhanakan integrasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hashicorp Vault</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Cloud Trace,</a> dan alat serupa kami.  <em>Semua</em> tim kami mendapatkan fitur yang lebih efektif. </p><br><hr><br><p>  Saya sudah menunjukkan grafik dengan persentil jumlah layanan yang digunakan karyawan kami setiap minggu dari akhir 2014 hingga 2017.  Dan ini adalah kelanjutan dari diagram ini hingga hari ini. </p><br><p><img src="https://habrastorage.org/webt/o7/fa/mu/o7famum8vaa0uuuw5e2ynah0-ay.png"></p><br><p>  Kami telah membuat kemajuan dalam mengelola kerangka kerja AWS yang kompleks.  Saya senang bahwa sekarang setengah dari karyawan melakukan hal yang sama seperti pada awal 2015.  Kami memiliki 4-6 karyawan di tim komputasi awan, sekitar 10% dari jumlah total - tidak mengherankan bahwa persentil ke-90 hampir tidak bergerak.  Tetapi saya juga berharap untuk kemajuan di sini. </p><br><p>  Akhirnya, saya akan berbicara tentang bagaimana siklus pengembangan kami telah berubah, dan kembali mengingat buku Accelerate yang baru dibaca. </p><br><p>  Buku ini menyebutkan dua metrik pengembangan lean: waktu tunggu dan ukuran paket.  Waktu tunggu dipertimbangkan dari permintaan hingga pengiriman solusi yang sudah jadi.  Ukuran paket adalah jumlah pekerjaan.  Semakin kecil ukuran paket, semakin efisien pekerjaan: </p><br><blockquote>  Semakin kecil paket, semakin pendek siklus produksi, semakin sedikit variabilitas proses, lebih sedikit risiko, biaya dan biaya, kami mendapatkan umpan balik lebih cepat, bekerja lebih efisien, kami memiliki lebih banyak motivasi, kami mencoba untuk menyelesaikan lebih cepat dan menunda pengiriman lebih jarang. </blockquote><p>  Buku ini menyarankan untuk mengukur ukuran paket berdasarkan frekuensi penyebaran - semakin sering penyebarannya, semakin kecil paketnya. </p><br><p>  Kami memiliki data untuk <em>beberapa</em> penyebaran.  Data tidak sepenuhnya akurat - beberapa tim mengirim rilis langsung ke cabang utama repositori, beberapa menggunakan mekanisme lain.  Ini tidak termasuk semua aplikasi, tetapi data selama 12 bulan dapat dianggap indikatif. </p><br><p><img src="https://habrastorage.org/webt/dt/vt/53/dtvt53s-2o7-w9rs-7qx6dhnydc.png"></p><br><p>  Kegagalan di minggu ketiga puluh adalah Natal.  Untuk selebihnya, kita melihat bahwa frekuensi penyebaran meningkat, yang berarti bahwa ukuran paket menurun.  Dari Maret hingga Mei 2018, frekuensi rilis hampir dua kali lipat, dan baru-baru ini kami terkadang membuat lebih dari seratus masalah per hari. </p><br><p>  Beralih ke Kubernetes hanyalah bagian dari strategi kami untuk menstandarkan, mengotomatisasi, dan meningkatkan alat.  Kemungkinan besar, semua faktor ini mempengaruhi frekuensi rilis. </p><br><p>  Accelerate juga berbicara tentang hubungan antara frekuensi penempatan dan jumlah karyawan, dan seberapa cepat perusahaan dapat bekerja jika staf ditingkatkan.  Para penulis menekankan keterbatasan arsitektur dan tim terkait: </p><br><blockquote>  Secara tradisional diyakini bahwa memperluas tim akan meningkatkan produktivitas secara keseluruhan, tetapi menurunkan produktivitas pengembang individu. </blockquote><p>  Jika kita mengambil data yang sama tentang frekuensi penyebaran dan membuat diagram ketergantungan pada jumlah pengguna, kita dapat melihat bahwa kita dapat meningkatkan frekuensi rilis, bahkan jika kita memiliki lebih banyak orang. </p><br><p><img src="https://habrastorage.org/webt/xc/ti/xf/xctixfjqbqgkbdooamerhtg3d_e.png"></p><br><p>  Di awal artikel, saya menyebutkan buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Factfulness</a> (yang menginspirasi CTO kami).  Transisi ke Kubernetes telah menjadi konvergensi teknologi yang paling signifikan dan cepat bagi pengembang kami.  Kami bergerak dalam langkah-langkah kecil, dan mudah untuk tidak melihat seberapa banyak segalanya telah berubah menjadi lebih baik.  Adalah baik bahwa kita memiliki data, dan mereka menunjukkan bahwa kita telah mencapai apa yang kita inginkan - orang-orang kita terlibat dalam produk mereka dan membuat keputusan penting di bidang mereka. </p><br><p>  Dulu baik untuk kita.  Kami memiliki layanan microservice, AWS, tim mapan untuk produk, pengembang yang bertanggung jawab atas layanan mereka dalam produksi, tim dan arsitektur yang digabungkan secara longgar.  Saya membicarakan hal ini dalam laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Zaman Pencerahan Kita"</a> ("Zaman Pencerahan Kita") di sebuah konferensi pada tahun 2012.  Tetapi tidak ada batasan untuk kesempurnaan. </p><br><p>  Pada akhirnya, saya ingin mengutip buku lain - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scale</a> .  Saya memulainya baru-baru ini, dan ada fragmen yang menarik tentang konsumsi energi dalam sistem yang kompleks: </p><br><blockquote>  Untuk menjaga ketertiban dan struktur dalam sistem yang sedang berkembang, dibutuhkan aliran energi yang konstan, dan menciptakan kekacauan.  Karena itu, untuk mempertahankan hidup, kita harus makan setiap saat untuk mengalahkan entropi yang tak terhindarkan. <br>  Kami melawan entropi dengan memasok lebih banyak energi untuk pertumbuhan, inovasi, pemeliharaan, dan perbaikan, yang menjadi lebih sulit seiring bertambahnya usia sistem, dan pertempuran ini adalah dasar dari setiap diskusi serius tentang penuaan, kematian, keberlanjutan, dan kemandirian sistem apa pun, baik itu organisme hidup , perusahaan atau masyarakat. </blockquote><p>  Saya pikir Anda dapat menambahkan sistem TI di sini.  Saya berharap bahwa upaya terakhir kami akan tetap entropi untuk sementara waktu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427441/">https://habr.com/ru/post/id427441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427431/index.html">Bagaimana Android Bekerja, Bagian 4</a></li>
<li><a href="../id427433/index.html">Penyeimbangan lalu lintas di jaringan IP operator</a></li>
<li><a href="../id427435/index.html">STM32H7 - pengaturan jam tanpa HAL</a></li>
<li><a href="../id427437/index.html">Mengkonfigurasi server tertaut: ms sql server dan teradata</a></li>
<li><a href="../id427439/index.html">Seluruh kebenaran tentang RTOS. Artikel # 16. Sinyal</a></li>
<li><a href="../id427443/index.html">Pembedahan kesuksesan</a></li>
<li><a href="../id427447/index.html">PVS-Studio termasuk dukungan untuk GNU Arm Embedded Toolchain</a></li>
<li><a href="../id427449/index.html">Bagaimana memahami Tensorflow dan tidak mati, dan bahkan mengajarkan sesuatu tentang mobil</a></li>
<li><a href="../id427451/index.html">Hubungkan tugas phpStorm ke Bitrix24</a></li>
<li><a href="../id427453/index.html">Bagaimana saya melakukan transmisi suara pada Raspberry Pi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>