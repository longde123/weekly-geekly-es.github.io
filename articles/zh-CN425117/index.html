<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛷 ⛽️ 👸🏼 每个晶体管两位：Intel 8087浮点芯片中的高密度ROM 🧛🏾 🛋️ 👩‍❤️‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="英特尔在1980年开发了8087芯片，目的是在执行浮点运算时提高具有8086/8088线路处理器的PC（例如IBM PC）的性能。 由于第一个微处理器被设计为执行整数运算，因此浮点数运算的执行速度很慢，这就是说，诸如三角函数或对数之类的先验运算的性能。 协处理器8087大大提高了执行浮点任务的速度；...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>每个晶体管两位：Intel 8087浮点芯片中的高密度ROM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425117/"> 英特尔在1980年开发了8087芯片，目的是在执行浮点运算时提高具有8086/8088线路处理器的PC（例如IBM PC）的性能。 由于第一个微处理器被设计为执行整数运算，因此浮点数运算的执行速度很慢，这就是说，诸如三角函数或对数之类的先验运算的性能。 协处理器8087大大提高了执行浮点任务的速度；所有操作的完成速度几乎快100倍。  8087体系结构也在后来的Intel处理器中实现，而8087指令仍在现代x86 PC中使用。 英特尔于1980年推出了8087芯片，旨在提高8086和8088处理器上的浮点计算性能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/uw/rf/zauwrfyx0v8mkj7aqjq7bx0kmhw.jpeg"></div><a name="habracut"></a><br> 因为早期的微处理器仅使用整数，所以浮点运算速度很慢，并且触发器或对数之类的先验运算看起来更糟。 在系统中添加8087数学协处理器，使我们可以将浮点运算速度提高100倍。  8087体系结构成为后来的Intel处理器的一部分，而8087指令（尽管已过时）仍然是现代x86台式机的一部分。 <br><br>  8087芯片为原始IBM PC提供了快速浮点运算，并成为当今使用的x86架构的一部分。  8087的不寻常功能之一是多​​层ROM（只读存储器），每个晶体管能够存储两位，这是传统ROM的两倍。  8087 ROM中的每个单元都没有存储二进制数据，而是保存了四个不同值之一，然后将其解码为两位。 由于8087需要大量的ROM来存储微代码（1），并且芯片上的晶体管数量非常有限，因此英特尔采用了一种不寻常的技术来解决该问题。 在本文中，我将解释英特尔如何实现此分层ROM。 <br><br> 我打开了8087芯片，并用显微镜拍摄了照片，下面是照片。 在照片中，我根据自己的逆向工程表示了主要的功能块（单击以放大图像）。 处理器矩阵8087非常复杂，具有40,000个晶体管（2）。  8087使用80位浮点数：尾数保留64位，指数保留15位，另一个带符号位。  （以10为底的数字的示例：6.02×1023中，尾数为6.02，指数为23）。 在照片的底部，单词“分数处理”标记了尾数电路的一部分。 从左到右，这包括：常数存储，64位移位，64位加法器/减法器和寄存器堆栈。 处理指数的方案要高一些。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/gx/q8/hjgxq8dq_dzulzxp79by-ue27jm.jpeg"></div><br>  <i>用于主要功能模块的Intel 8087浮点运算的数学协处理器芯片</i> <br><br> 执行关于8087的指令需要几个步骤，有时甚至超过1000个步骤。8087固件使用微码来确定每一步的低级操作：移位，递增，内存采样，读取常量等。您可以将微码视为一个简单的程序，以微指令的形式编写，其中每个微指令为芯片的各个组件生成控制信号。 上面的照片显示了带有微码程序8087的ROM。ROM占据了芯片的很大一部分，清楚地说明了为什么需要紧凑的多层ROM。  ROM的左侧是启动微码程序的“引擎”，实际上是一个简单的处理器。 <br><br>  8087与8086处理器一起用作协处理器，当8086检测到特殊的浮点指令时，处理器将其忽略，并允许8087并行执行该指令。 我不会详细解释8087的内部工作原理，但是总之，浮点运算是使用整数加/减和移位运算实现的。 为了增加或减少两个浮点数，8087对数字进行了逐位移位，直到二进制定界符（即，小数点分隔符为逗号，但在二进制系统中）相等，然后再对尾数进行加或减。 乘法，除法和平方根通过重复的移位，加法或减法来执行。 先验运算（棕褐色，反正弦，对数，幂）使用CORDIC算法，该算法使用移位和特殊常数的相加，一次处理一位。  8087还遇到许多特殊情况：无穷大，溢出，NaN（非数字），非规格化数字和几种舍入模式。  ROM中存储的微码控制着所有这些操作。 <br><br><h3>  ROM实施 </h3><br>  8087芯片由一个微小的硅基体组成，在该硅基体上的各个位置都掺有杂质，以获得所需的半导体性能。 多晶硅（一种特殊类型的硅）被应用到硅表面，形成导线和晶体管。 最后，在硅树脂上的金属层完成了工作电路。 在下面的照片中，左侧显示了芯片的一小部分，因为在显微镜下可以看到它，显示出淡黄色的金属布线。 在照片的右侧，用酸去除了金属，露出了多晶硅和硅。 当多晶硅穿过硅时，形成晶体管。 粉色区域是掺杂的硅，垂直的细线是多晶硅。 小圆圈是硅和金属层之间的接触，将它们连接在一起。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/us/9j/cgus9jmdjvhec5j30deqymfz8r4.png"></div><br>  <i>英特尔8087 FPU中的ROM结构。</i>  <i>金属层显示在左侧，多晶硅和硅显示在右侧。</i> <br><br> 尽管有许多种构建ROM的方法，但是标准方法是创建一个“单元”网格，其中每个单元存储一位。 每个单元可以具有一个晶体管（表示0位），也可以不具有一个晶体管（表示1位）。 在上面的图像中，您可以看到一个带有晶体管的单元格网格（其中多晶硅应用于硅）和缺少的晶体管（硅中存在间隙）。 要从ROM读取信息，将激活一列选择线（基于地址），以选择存储在此列中的位，并从输出的每一行中获取一位。 您可以在上面的照片中看到多晶硅的垂直列选择线（列选择线）和水平金属行。 掺杂硅的垂直线接地。 <br><br> 下图（对应于4x4 ROM段）说明了ROM的功能。 每个单元都有一个晶体管（黑色），或者没有晶体管（灰色）。 当向多晶硅列选择线施加电压时，该列中的晶体管导通并接地相应的金属行。  （在这种情况下，NMOS晶体管就像一个门，如果输入为0则打开，如果输入为1则关闭。）电路的金属“行”输出存储在所选“列”中的数据。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/sl/q_/oislq_mbf-lyx6kbddwl4wxbgya.png"></div><br>  <i>方案4x4 ROM段</i> <br><br> 列选择信号由解码器电路生成。 由于此回路是由NOR阀构成的，因此我将首先说明这些阀的设计。 下图显示了一个由四个晶体管和一个上拉电阻构成的四输入或非门（尽管实际上，一个特殊的晶体管执行该电阻的功能）。 在电路的左侧，所有输入均为0，因此所有晶体管均被关闭，并且上拉电阻将输出信号保持在“高”电平。 在右侧，将1应用于输入之一，从而打开晶体管。 晶体管接地，因此输出信号现在为“低电平”。 因此，如果任何输入为高（1），则输出为低（0）。 因此，该电路实现了NOR阀。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_n/if/hi/_nifhiurrurn523sddqmq8w3eq8.png"></div><br>  <i>由NMOS晶体管构建的4路NOR门</i> <br><br> 列选择解码器电路接收输入的地址位并激活相应的选择线。 解码器的每一列包含一个8输入或非门，即每个地址包含一个或非门。 该照片显示了两个产生列选择信号的NOR元素（为简单起见，我仅显示8个输入中的四个）。 每列使用地址线和填充地址线的不同组合作为输入，选择不同的地址。 地址线位于金属层中，在下面的照片中已将其删除； 地址行以绿色突出显示。 要确定与列关联的地址，请查看与每个晶体管关联的方形引脚，并注意连接了哪些地址线。 如果连接到一列晶体管的所有地址线均为低电平（0），则“或非”门将选择该列。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/va/bt/hdvabtftpvkypgl28rpwa2ev2vy.png"></div><br>  <i>地址解码器的一部分。</i>  <i>地址解码器选择ROM中从右到左计数的奇数列。</i>  <i>顶部的数字显示与每个输出关联的地址。</i> <br><br> 下图显示了ROM解码器的一小部分，具有用于NOR门的所有8个输入。 您可以通过仔细检查地址栏中的连接来读取二进制地址。 注意二进制模式：a1在每列中连接变化值，a2每两列中连接交替，a3每四列中连接，等等。A0是固定的，因为此解码器电路选择奇数列； 一个类似的ROM电路选择偶数地址（这样的分隔对于解码器安装在芯片上是必要的，因为解码器的每一列的宽度是ROM单元的两倍）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l-/el/lv/l-ellviplb3kupadfsrcgwqp_ui.png"></div><br>  <i>ROM微码8087的地址解码器的一部分。解码器将8位地址转换为列选择信号</i> <br><br>  ROM的最后一个组件是一组多路复用器，可将64条输出线减少到8条线。 每个8对1多路复用器根据地址选择其8个输入之一。 下图显示了一个8087处理器行多路复用器之一，它由八个大型直通晶体管组成，每个晶体管都连接到“行”线之一。 所有晶体管都连接到输出，因此当选定的晶体管导通时，它将其输入传输到输出。 多路复用器晶体管比ROM中的晶体管大得多，大大减小了ROM的信号失真。 解码器（类似于先前考虑的解码器，但较小）从三个地址线生成八条多路复用器控制线。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/kx/_o/m2kx_ochmi4nes3z-bjryrrsmbq.png"></div><br>  <i>ROM中的8行多路复用器之一。</i>  <i>在这里您可以看到（多晶硅）层，金属化合物涂成橙色</i> <br><br> 总而言之，ROM将位存储在网格中。 它使用八个地址位来选择网格中的一列。 然后，地址的三位从“行”中选择所需的八个输出。 <br><br><h3> 分层ROM </h3><br> 到目前为止，我已经解释了一种典型的ROM设备，每个单元存储一位。 那么8087如何能够在每个单元中存储两位呢？ 如果仔细看，8087 ROM微码包含四种不同尺寸的晶体管-如果您将晶体管的缺失作为尺寸之一（6）。 每个晶体管有四个选项，一个单元可以编码两个比特，密度大约翻了一番（7）。 当前部分说明了四种尺寸的晶体管如何产生四个不同的电流，以及芯片的模拟和数字电路如何将这些电流转换为两位。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/fb/g2/ykfbg2a-lsfxfa2c7ijsmcjxlzk.png"></div><br>  <i>微代码ROM 8087的显微照片显示了四种不同尺寸的晶体管。</i>  <i>这允许ROM在每个单元中存储两位。</i> <br><br> 晶体管的尺寸控制流过晶体管（8）的电流。 一个重要的几何因素是硅（粉红色）的不同宽度，在这里硅与多晶硅（垂直线）相交，从而形成了具有不同栅极宽度的晶体管。 由于栅极宽度控制着流过晶体管的电流，因此晶体管的四种尺寸会产生四种不同的电流：最大的晶体管会通过大部分电流，如果没有晶体管，则根本不会流过电流。 <br><br>  ROM电流只需几步即可转换为位。 首先，上拉电阻将电流转换为电压。 然后，三个比较器将电压与参考电压进行比较以生成数字信号，确定哪个电压更高/更低。 最后，逻辑门将比较器的输出信号转换为两个输出位。 此模式重复八次，在输出处总共产生16位。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/a6/go/ada6goh-_wnbiaam90ai_nxgfdk.png"></div><br>  <i>从ROM单元读取两位的方案</i> <br><br> 上图执行了这些转换步骤。 结果，ROM晶体管之一被“列”选择线和产生四个电流之一的多路复用器（前面讨论过）选择。 然后，上拉电阻（12）将晶体管电流转换为电压，其结果是电压取决于所选晶体管的尺寸。 比较器将此电压与三个参考电压进行比较，如果ROM电压高于参考电压，则输出1。 比较器和参考电压需要仔细设计，因为ROM电压仅相差200 mV。 <br><br> 参考电压位于ROM的预期电压值之间的中间，这会引起一些电压波动。  “低” ROM电压低于所有参考电压，因此所有比较器将输出0。第二个ROM电压高于Ref 0，因此较低的比较器输出1。在第三个ROM电压下，较低的两个比较器输出1，最大所有三个比较器1的输出上的ROM电压。因此，三个比较器根据晶体管ROM产生四个不同的输出模式。 然后，逻辑元件将比较器的输出转换为两个输出位（10）。 <br><br> 比较器的设计很有趣，因为它是模拟世界和数字世界之间的桥梁，如果ROM电压高于或低于参考电压，则产生1或0。 每个比较器都包含一个差分放大器，用于放大ROM电压和参考电压之间的差异。 差分放大器的输出驱动栅极，该栅极使输出稳定，并将其转换为逻辑电平信号。 差分放大器（下）是标准的模拟电路。 电流源（下面的符号）提供直流电。 如果其中一个晶体管的输入电压高于另一个，则大部分电流会流过该晶体管。 电阻两端的压降将导致相应的输出变低，而另一个输出变高。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d6/fn/ns/d6fnnswmm1veissvrruouwjrrmi.png"></div><br>  <i>该图显示了差分对的操作。</i>  <i>大部分电流将通过具有较高输入电压的晶体管，从而导致较低的输出信号。</i>  <i>下面的双圆圈符号是直流电源I</i> <br><br> 下图显示了一个芯片上的比较器之一； 顶部有金属层，下面有晶体管。 我将只考虑这个复杂方案的要点； 有关详细信息，请参见注释12。 来自ROM和多路复用器的信号被提供给左侧。 上拉电路12将电流转换成电压。 两个大型差分放大器晶体管将ROM电压与参考电压（从上方输入）进行比较。 差分放大器的输出进入快门电路（照片中分散）； 快门输出在右下角。 差分放大器和上拉电阻的电流源由耗尽型晶体管制成。 每个输出电路中使用三个输出比较器，总共提供24个比较器。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/ec/jr/pmecjrsutl-vzf3k0qvzgw5t1cw.png"></div><br>  <i>8087中的比较器之一。该芯片包含24个比较器，用于将电压电平从多级ROM转换为二进制数据</i> <br><br> 每个参考电压由精心选择的尺寸的晶体管和上拉电路产生。 参考电压电路设计为尽可能靠近ROM的信号电路，因此芯片制造中的任何变化都会对两个元件产生同等影响。 参考电压和ROM信号使用相同的负载电路。 此外，每个参考电压电路都包括一个非常大的晶体管，与多路复用器晶体管相同，尽管参考信号电路中没有多路复用器，只是为了确保电路的“匹配”。 除了参考晶体管（9）的尺寸外，三个参考电压电路相同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/11/je/wn/11jewn6dap_lxtfqtvrh7vdzcfw.png"></div><br>  <i>产生三个参考电压的电路。</i>  <i>参考晶体管的尺寸在ROM晶体管的尺寸之间。</i>  <i>氧化层没有从基体的这一部分完全去除，这是由于照片中出现了颜色漩涡</i> <br><br> 为了组装整个拼图，下图显示了ROM微代码的组件在芯片（12）上的位置。  ROM电路的主要部分由存储数据的晶体管组成。 列解码器电路位于ROM数据的上方和下方。 为了更好的布局，一半的列选择解码器在顶部，一半在底部。 输出电路在右侧。 八个多路复用器将64行线路削减为八行。 然后，八行进入比较器，在右侧的ROM输出上产生16位。 比较器上方的参考电路产生三个参考电压。 在右下角，一个小线解码器控制多路复用器。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-q/df/9s/-qdf9s_vh19u5bxltwg59ye7_2o.png"></div><br>  <i>英特尔8087 FPU的固件ROM标有主要组件</i> <br><br> 尽管起初看起来多级ROM的容量似乎是传统ROM的一半，但由于比较器需要额外的电路，并且由于晶体管本身稍大一些（由于需要使用多种尺寸），因此效果并不那么明显。 尽管如此，多层ROM仍可节省常规ROM约40％的空间。 <br><br> 现在，我了解了ROM的结构，我可以简单（但乏味地）读取ROM的内容，只需在显微镜下查看每个晶体管的大小即可。 但是，不知道微码指令集，ROM的内容是无用的。 <br><br><h3> 结论 </h3><br>        8087    «   »     . Intel       1981     iAPX 432.11    ,           1980-    . , - , ,   ,          ,    ,    ,     (14). <br><br> ,     ,    -.  -        (13). -    4    ( 16   )   ,   (QLC, quad-level cell).  ,   1980-    ,  . <br><br>          ,     @kenshirriff      8087.     RSS-.        8087. <br><br><h3>    </h3><br><ol><li>  8087  1648   (   ),  16    ,  26368 .       ,  Intel      . </li><li>         8087: Intel ,  40 000 ,   ,  45 000.         .  ,     , PLA      ,   ,    «» ,     .       ,               . </li><li>    8086        8087  ;     .     ,  8087     8086    ,    8087.    ,  8086     ,      .  , 8087     8086 (     8088),   ,   8086.       ,  8086,     . 8087      ,        8086.  ,  8086   8087,        ,   .  , 8087    ,     ,    .  8087 ,      ,    .      8087    8087,       . </li><li> ,         ,   ,            ,     ,   .    ,    ROM,     ,         . ,     8     1/8 ,     1/8 .  , ,   (, 1  × 16)    ,        .   , «»     . ,     Intel   ; 1405  512      .     ,    «» -  20 . </li><li>   IBM       :       (  ,    ),      (link).  ,   Xerox Alto,      .     ,       .      ,       . </li><li>         ,       Hacker News ,  8087      .    ,        ,    . </li><li>       1980-       . Mostek        :        .     ,      .      Intel,      (      ),            .     (  )          .                (    ),    ,      .       Z-80     «», ,       ,   ,    .     ,  ,      Z-80      ,     ,     ,      . </li><li>          . ( —      .)   ( ,    )      ,     .   MOSFET . Wikipedia </li><li>        ,   -.    ,          .  ,  Reference 0    ,     .        ,   ,   . :    , ,    ,    .   -       ,      ,    ,       . </li><li>         :   = 00,   = 01,   = 11,   = 10.          ;         ,   ,      . (. «Two Bits Per Cell ROM», Stark). </li><li>   Intel iAPX 43203 (1981)   ,     8087.     «The interface processor for the Intel VLSI 432 32 bit computer,» J. Bayliss et al., IEEE J. Solid-State Circuits, vol. SC-16, . 522-530,  1981 .   43203   -   iAPX 432. Intel   iAPX 432  1975 ,   «»,     Intel  1980- .    iAPX 432  , Intel   8086    ,  1978 .  Intel 8086   ,        x86,  iAPX 432    1986 . </li><li>   ( «Multiple-Valued ROM Output Circuits»)       .            .      (T3, T4, T5)   . 4  5    ,      3,        (   ).       ( )  T6,     .             (). </li><li> -   SLC ( single level cell —    ), MLC (multi level cell —    ), TLC (triple level cell —    )  QLC (quad level cell —    ). , -       ,   ,     -   . </li><li>   «Electronics»     «Four-State Cell Doubles ROM Bit Capacity» (. 39, 9  1980 .),   Intel,        . Intel    «    »  COMPCON (. 209-212,  1981 .).           Intel  «Multiple-valued ROM output circuits» (Proc. 14th Int. Symp. Multivalue Logic, 1984).  ,      , — « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">A Survey of Multivalued Memories</a> » («IEEE Transactions on Computers»,  1986 ., . 99–106)  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">A review of multiple-valued memory technology</a> » (IEEE Symposium on Multivalued Logic, 1998). </li></ol><br> ,    . 你喜欢我们的文章吗？ 想看更多有趣的资料吗？ 通过下订单或将其推荐给您的朋友来支持我们， <b>为我们为您发明的入门级服务器的独特模拟，为Habr用户</b>提供<b>30％的折扣：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于VPS（KVM）E5-2650 v4（6核）的全部真相10GB DDR4 240GB SSD 1Gbps从$ 20还是如何划分服务器？</a>  （RAID1和RAID10提供选件，最多24个内核和最大40GB DDR4）。 <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  1  </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br>  <b>戴尔R730xd便宜2倍？</b> 仅<b>在荷兰和美国，</b>我们有<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2台Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100电视（249美元起）</a> ！</b> 阅读有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何构建基础架构大厦的信息。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用价格为9000欧元的Dell R730xd E5-2650 v4服务器的上等课程？</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425117/">https://habr.com/ru/post/zh-CN425117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425107/index.html">金融科技摘要：移动生物识别问题，三星手机租赁，区块链上的证券</a></li>
<li><a href="../zh-CN425109/index.html">《云中的Java》一书。 Spring Boot，Spring Cloud，Cloud Foundry»</a></li>
<li><a href="../zh-CN425111/index.html">广告招数可能会浪费您的金钱和声誉</a></li>
<li><a href="../zh-CN425113/index.html">“数字印刷术”或我在书籍移动数字化方面的经验</a></li>
<li><a href="../zh-CN425115/index.html">成熟的DevOps：三幕希腊悲剧</a></li>
<li><a href="../zh-CN425123/index.html">罗兰TR-808鼓机的神秘心脏</a></li>
<li><a href="../zh-CN425125/index.html">@Pythonetc 2018年9月</a></li>
<li><a href="../zh-CN425129/index.html">如何自动创建虚拟机？ 详细说</a></li>
<li><a href="../zh-CN425131/index.html">关于区块链技术的读物：指南，书籍和文章</a></li>
<li><a href="../zh-CN425133/index.html">跨境支付问题-为什么在这里以及如何使用区块链</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>