<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 👲 🧐 在Angular中重试失败的HTTP请求 👩🏿‍🤝‍👨🏽 🚖 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对服务器数据的访问组织是几乎所有一页应用程序的基础。 这些应用程序中的所有动态内容都是从后端下载的。 

 在大多数情况下，对服务器的HTTP请求可以可靠地工作并返回所需的结果。 但是，在某些情况下，请求可能会失败。 

 想象一下有人通过火车以每小时200公里的速度在全国各地行驶的访问点如何与您的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Angular中重试失败的HTTP请求</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459302/"> 对服务器数据的访问组织是几乎所有一页应用程序的基础。 这些应用程序中的所有动态内容都是从后端下载的。 <br><br> 在大多数情况下，对服务器的HTTP请求可以可靠地工作并返回所需的结果。 但是，在某些情况下，请求可能会失败。 <br><br> 想象一下有人通过火车以每小时200公里的速度在全国各地行驶的访问点如何与您的网站合作。 在这种情况下，网络连接可能很慢，但是尽管如此，服务器请求还是可以完成任务。 <br><br> 但是，如果火车进入隧道怎么办？ 与Internet的连接很有可能会中断，并且Web应用程序将无法“延伸”到服务器。 在这种情况下，列车离开隧道并恢复Internet连接后，用户将必须重新加载应用程序页面。 <br><br> 重新加载页面可能会影响应用程序的当前状态。 这意味着，例如，用户可能会丢失他输入到表单中的数据。 <br><br> 与其简单地与某个请求不成功这一事实相协调，不如将其重复几次并向用户显示相应的通知会更好。 使用这种方法，当用户意识到应用程序正在尝试解决该问题时，他很可能不会重新加载页面。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br> 该材料（我们今天发布的翻译）致力于分析在Angular应用程序中重复未成功请求的几种方式。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">重复失败的请求</font> </h2><br> 让我们重现火车上使用Internet工作的用户可能遇到的情况。 我们将创建一个后端，该后端在访问请求的前三次尝试期间将错误地处理该请求，仅从第四次尝试返回数据。 <br> 通常，我们使用Angular创建服务，连接<code>HttpClient</code>并使用它从后端获取数据。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br> 这里没有什么特别的。 我们插入Angular <code>HttpClient</code>模块并执行一个简单的GET请求。 如果请求返回错误，我们将执行一些代码来处理该错误，并返回一个空的<code>Observable</code> （可观察对象），以告知发起该请求的原因。 这段代码说的是：“有一个错误，但是一切正常，我可以处理。” <br><br> 大多数应用程序都以这种方式执行HTTP请求。 在上面的代码中，该请求仅执行一次。 之后，它要么返回从服务器接收到的数据，要么不成功。 <br><br> 如果端点<code>/greet</code>不可用或返回错误，如何重复请求？ 也许有合适的RxJS语句？ 当然存在。  RxJS具有所有操作符。 <br><br> 在这种情况下首先想到的是<code>retry</code> 。 让我们看一下它的定义：“返回一个播放原始Observable的Observable，但<code>error</code>除外。 如果原始Observable调用<code>error</code> ，则此方法将重新订阅原始Observable，而不是传播错误。 <br><br> 重新订阅的最大数量限制为<code>count</code> （这是传递给该方法的数字参数）。” <br><br>  <code>retry</code>与我们需要的非常相似。 因此，让我们将其嵌入到我们的链中。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br> 我们已经成功使用了<code>retry</code>运算符。 让我们看一下这如何影响在实验性应用程序中执行的HTTP请求的行为。  <a href="">这是</a>一个很大的GIF文件，显示了此应用程序的屏幕以及浏览器开发人员工具的“网络”标签。 您将在这里找到更多此类演示。 <br><br> 我们的应用程序非常简单。 单击<code>PING THE SERVER</code>按钮时，它只是发出一个HTTP请求。 <br><br> 如前所述，后端在执行前三个尝试执行对它的请求时返回错误，而当第四个请求到达时，它返回正常响应。 <br><br> 在网络开发人员的工具标签上，您可以看到<code>retry</code>解决了分配给它的任务，并重复执行了失败的请求3次。 最后一次尝试成功，应用程序收到响应，页面上显示相应的消息。 <br><br> 这一切都很好。 现在，应用程序可以重复失败的请求。 <br><br> 但是，此示例仍可以改进。 请注意，现在重复的请求将在执行失败的请求后立即执行。 系统的这种行为在我们的情况下不会带来太多好处-当火车进入隧道并且互联网连接暂时断开时。 <br><br><h2>  <font color="#3AC1EF">延迟重试失败的请求</font> </h2><br> 进入隧道的火车不会立即离开。 他在那里呆了一段时间。 因此，我们需要“延长”对服务器执行重复请求的时间。 您可以通过推迟重试来做到这一点。 <br><br> 为此，我们需要更好地控制执行重复请求的过程。 我们需要能够决定何时确切重复请求。 这意味着<code>retry</code>运算符的功能对我们而言已不再足够。 因此，我们再次转向RxJS上的文档。 <br><br> 文档包含对<code>retryWhen</code>的描述，这似乎很适合我们。 在文档中，其描述如下：“返回一个播放原始Observable的Observable，但<code>error</code>除外。 如果原始的Observable调用<code>error</code> ，则此方法将引发Throwable，从而导致错误，并从<code>notifier</code>返回的Observable。 如果此Observable调用<code>complete</code>或<code>error</code> ，则此方法将在子订阅上调用<code>complete</code>或<code>error</code> 。 否则，此方法将重新订阅原始的Observable。” <br><br> 是的，定义并不简单。 让我们用一种更易于理解的语言来描述它。 <br><br>  <code>retryWhen</code>接受返回Observable的回调。 返回的Observable根据某些规则决定<code>retryWhen</code>运算符的行为。 即，这是<code>retryWhen</code>运算符的<code>retryWhen</code> ： <br><br><ul><li> 如果返回的Observable引发错误，它将停止工作并引发错误。 </li><li> 如果返回的Observable报告完成，则退出。 </li><li> 在其他情况下，当Observable成功返回时，它将重复执行原始的Observable </li></ul><br> 仅当原始Observable首次引发错误时才调用回调。 <br><br> 现在，我们可以使用该知识通过RxJS <code>retryWhen</code>为失败的请求创建延迟的重试机制。 <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br> 如果原始的Observable（即我们的HTTP请求）返回错误，则<code>retryWhen</code>语句。 在回调中，我们可以访问导致失败的错误。 我们推迟<code>errors</code> ，减少重试次数，并返回引发错误的新Observable。 <br><br> 根据<code>retryWhen</code>的规则，此Observable由于<code>retryWhen</code> ，因此<code>retryWhen</code>请求。 如果重复多次失败，并且<code>retries</code>变量的值减小为0，则我们将以执行请求时发生的错误结束任务。 <br><br> 太好了！ 显然，我们可以将上面的代码替换为链中的<code>retry</code>运算符。 但是在这里我们放慢了一点。 <br><br> 如何<code>retries</code>可变<code>retries</code> ？ 此变量包含失败的请求重试系统的当前状态。 她在哪里宣布？ 条件何时重置？ 需要在流内部而不是外部对状态进行管理。 <br><br><h3>  <font color="#3AC1EF">▍创建自己的delayRetry语句</font> </h3><br> 通过将以上代码编写为单独的RxJS运算符，我们可以解决状态管理问题并提高代码的可读性。 <br><br> 有多种方法可以创建自己的RxJS运算符。 使用哪种方法取决于特定运算符的结构。 <br><br> 我们的运算符基于现有RxJS运算符。 结果，我们可以使用最简单的方法来创建我们自己的运算符。 在我们的例子中，RxJs运算符只是一个具有以下签名的函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br> 该语句采用原始的Observable，并返回另一个Observable。 <br><br> 由于我们的运算符允许用户指定重复请求应执行的频率以及需要执行多少次，因此我们需要将上述函数声明包装在工厂函数中，该函数需要<code>delayMs</code> （ <code>maxRetry</code>之间的延迟）和<code>maxRetry</code> （最大重复次数）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br> 如果要创建不基于现有运算符的运算符，则需要注意处理错误和订阅。 此外，您将需要扩展<code>Observable</code>类并实现<code>lift</code>功能。 <br><br> 如果您有兴趣，请在<a href="">这里</a>看看。 <br><br> 因此，基于以上代码片段，让我们编写我们自己的RxJs运算符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br> 太好了 现在，我们可以将此运算符导入客户端代码。 我们将在执行HTTP请求时使用它。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br> 我们将<code>delayedRetry</code>运算符放在链中，并传递数字1000和3作为参数，第一个参数设置<code>delayedRetry</code>重复请求之间的延迟（以毫秒为单位）。 第二个参数确定重复请求的最大数量。 <br><br> 重新启动应用程序，并<a href="">查看</a>新操作员的工作方式。 <br><br> 在使用浏览器开发人员的工具分析了程序的行为之后，我们可以看到重复执行请求的尝试的执行被延迟了一秒钟。 收到正确的请求答案后，相应的消息将出现在应用程序窗口中。 <br><br><h2>  <font color="#3AC1EF">指数请求暂停</font> </h2><br> 让我们提出延迟失败请求重试的想法。 以前，我们总是在同一时间延迟每个重复请求的执行。 <br><br> 这里我们讨论如何增加每次尝试后的延迟。 重试请求的第一次尝试是在一秒钟后进行，第二秒钟是在两秒钟后，第三遍是三秒钟。 <br><br> 创建一个新语句<code>retryWithBackoff</code> ，以实现此行为。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br> 如果在应用程序中使用此运算符并对其进行测试，则可以<a href="">看到</a>每次执行新尝试后执行重复请求的延迟如何增加。 <br><br> 每次尝试后，我们都会等待一定时间，重复请求并增加等待时间。 在这里，照常，在服务器返回正确的请求答案之后，我们在应用程序窗口中显示一条消息。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 重复失败的HTTP请求可使应用程序更稳定。 当执行非常重要的查询时，如果没有获取到的数据，应用程序将无法正常运行，这尤其重要。 例如，它可以是包含应用程序需要与之交互的服务器地址的配置数据。 <br><br> 在大多数情况下，RxJs重试<code>retry</code>不足以为失败的请求提供可靠的重试系统。  <code>retryWhen</code>为开发人员提供了对重复请求的更高级别的控制。 它允许您配置重复请求的间隔。 由于该操作员的能力，可以实现延迟重复方案或指数延迟重复。 <br><br> 在实现适合在RxJS链中重用的行为模式时，建议将其格式化为新的运算符。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/kreuzerk/">这是</a>本文中使用代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/kreuzerk/">的</a>存储库。 <br><br>  <b>亲爱的读者们！</b> 您如何解决重试失败的HTTP请求的问题？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459302/">https://habr.com/ru/post/zh-CN459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459292/index.html">移动应用测试自动化：工具比较</a></li>
<li><a href="../zh-CN459294/index.html">更重要的是：了解编程语言或能够解决业务问题？</a></li>
<li><a href="../zh-CN459296/index.html">JavaScript价格2019</a></li>
<li><a href="../zh-CN459298/index.html">Angular：2019年状态</a></li>
<li><a href="../zh-CN459300/index.html">Quasar 1.0：Vue开发人员的新实用工具，不仅限于他们</a></li>
<li><a href="../zh-CN459304/index.html">角度陷阱旁路和节省时间</a></li>
<li><a href="../zh-CN459306/index.html">无服务器环境中的服务器渲染</a></li>
<li><a href="../zh-CN459308/index.html">SEO在2019年不起作用？</a></li>
<li><a href="../zh-CN459310/index.html">测试自动化工具或移动类固醇测试仪</a></li>
<li><a href="../zh-CN459312/index.html">亲爱的敏捷，我讨厌假装</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>