<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚔️ ✔️ ☂️ Tratamos con objetos en JavaScript ▪️ ⏺️ ⛅️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, el autor, un desarrollador front-end, dio una visión general de las principales formas de crear, modificar y comparar objetos JavaSc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tratamos con objetos en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/419193/">  <i>En este artículo, el autor, un desarrollador front-end, dio una visión general de las principales formas de crear, modificar y comparar objetos JavaScript.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/em/rb/twemrbhsfbxmrw7_htw8o4mfzny.jpeg"></div><br>  Los objetos son uno de los conceptos básicos en JavaScript.  Cuando comencé a estudiarlos, me parecieron bastante simples: solo un par de claves y valores, como se describe en teoría. <br><br>  Solo después de un tiempo comencé a darme cuenta de que el tema es mucho más complicado de lo que pensaba.  Y luego comencé a estudiar información de varias fuentes.  Algunos de ellos dieron una buena idea sobre el tema, pero no pude ver la imagen completa de inmediato. <br><br>  En esta publicación, traté de cubrir todos los aspectos del trabajo con objetos en JS, sin profundizar en detalles individuales, pero sin perder detalles importantes que lo ayudarán a comprender el tema y sentirse más seguro durante su estudio posterior. <br><br>  Entonces, comencemos con lo básico. <br><br><h3>  Objeto </h3><br>  <b>Un objeto en JavaScript es simplemente una colección de propiedades, cada una de las cuales es un par clave-valor.</b>  Se puede acceder a las teclas utilizando la notación punteada ( <i>obj.a</i> ) o entre corchetes ( <i>obj ['a']</i> ). <br><br>  Recuerde que los corchetes deben usarse si la clave es: <br><br><ul><li>  no es un identificador de JavaScript válido (tiene un espacio, un guión, comienza con un número ...) </li><li>  es una variable </li></ul><br>  Una de las propiedades que obtienen los objetos en JS cuando se crean se llama <i>Prototipo</i> , y este es un concepto muy importante. <br><a name="habracut"></a><br><h3>  Prototipo </h3><br>  Cada objeto en JavaScript tiene una propiedad interna llamada <i>Prototipo</i> .  En la mayoría de los navegadores, puede referirse a él mediante la designación <i>__proto__</i> . <br><br>  <i>Prototype</i> es una forma de proporcionar herencia de propiedades en JavaScript.  Para que pueda compartir la funcionalidad sin duplicar el código en la memoria.  El método funciona creando una relación entre dos objetos. <br><br>  En pocas palabras, Prototype crea un puntero de un objeto a otro. <br><br>  <b>Cadena prototipo</b> <br><br>  Cada vez que JS busca una propiedad en el objeto y no la encuentra directamente en el propio objeto, verifica la presencia de la propiedad en el objeto prototipo.  Si no tiene ninguna propiedad, JS continuará buscando en el prototipo del objeto relacionado.  Esto continuará hasta que JS encuentre una propiedad adecuada o llegue al final de la cadena. <br><br>  Veamos un ejemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cons = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-number"><span class="hljs-number">1</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cons(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  cons.prototype.b = <span class="hljs-number"><span class="hljs-number">3</span></span>; cons.prototype.c = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  <i>cons</i> es un constructor (solo una función que se puede llamar usando el <i>nuevo</i> operador). <br><br>  En la quinta línea, creamos un nuevo objeto, una nueva copia de los <i>contras</i> .  Inmediatamente después de crear, <i>obj</i> también obtiene una propiedad prototipo. <br><br>  Y ahora agregamos propiedades ( <i>'b', 'c'</i> ) al prototipo del objeto <i>cons</i> . <br>  Considera <i>obj</i> : <br><br>  <b>obj.a // 1</b> - todo es como <i>antes</i> , <i>obj.a</i> sigue siendo 1. <br>  <b>obj.c</b> - <i>obj</i> no <i>tiene</i> propiedad <i>c</i> !  Sin embargo, como se mencionó anteriormente, JS ahora lo buscará en el prototipo <i>obj</i> y devolverá un valor de 4. <br><br>  Ahora pensemos cuál es el valor de <i>obj.b</i> y en qué se convertirá cuando eliminemos <i>obj.b.</i> <br><br>  <i>Obj.b</i> es 2. <i>Asignamos la</i> propiedad <i>b</i> , pero lo hicimos para el prototipo de <i>contras</i> , así que cuando verificamos <i>obj.b</i> , todavía obtenemos 2. Sin embargo, inmediatamente después de eliminar <i>obj.b,</i> JS ya no podrá encontrar <i>b</i> en o <i>bj</i> y, por lo tanto, continuará la búsqueda en el prototipo y devolverá el valor 3. <br><br>  A continuación, quiero hablar brevemente sobre varias formas de crear un objeto y un poco más sobre prototipos. <br><br><h3>  Creación de objetos </h3><br>  <b>Literal del objeto:</b> <i>let obj = {a: 1};</i> <br>  Creamos un objeto con la siguiente cadena de prototipo: <i>obj ---&gt; Object.prototype ---&gt; null</i> <br>  Como puede adivinar, <i>object.prototype</i> es el prototipo del objeto, así como el final de la cadena del prototipo. <br><br>  <b>Object.create ():</b> <i>var newObj = Object.create (obj);</i> <br>  <i>NewObj</i> tendrá la siguiente cadena de prototipo: <i>newObj ---&gt; obj ---&gt; Object.prototype ---&gt; null</i> <br><br>  <b>Constructor.</b>  Como en el ejemplo anterior, el constructor es solo una función JS que nos permite usar el <i>nuevo</i> operador para crear nuevas instancias del mismo. <br><br>  <b>Clases de ES6:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rectangle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } getArea() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> square = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rectangle(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  <i>Square</i> es una instancia del constructor de <i>rectángulos</i> , por lo que podemos llamar a <i>square.getArea () // 4</i> , <i>square.width</i> , así como a todas las funciones heredadas de <i>object.prototype</i> . <br><br>  ¿Qué método es mejor?  Si planea crear varias instancias, puede usar ES6 o el constructor.  Si planea crear un objeto una vez, es mejor especificar un literal, ya que esta es la forma más fácil. <br><br>  Y ahora, cuando aprendimos sobre el <i>prototipo</i> y nos familiarizamos con todas las formas de crear nuevos objetos, podemos proceder a discutir uno de los aspectos más confusos asociados con los objetos. <br><br><h3>  Comparar y modificar objetos </h3><br>  <b>En JavaScript, los objetos son de tipo de referencia</b> <br><br>  Cuando creamos un objeto, <i>dejemos obj = {a: 1};</i>  , la variable <i>obj</i> obtiene la dirección en la memoria del objeto, ¡pero no su valor!  Es imprescindible comprender esta diferencia, ya que de lo contrario pueden producirse errores.  Cuando creamos otro objeto <i>let newObj = obj</i> , en realidad creamos un <b>puntero</b> a cierta área de memoria <i>obj</i> , y no un objeto completamente nuevo. <br><br>  Esto significa que al ejecutar <i>newObj.a = 2</i> , en realidad cambiamos <i>obj</i> para que <i>obj.a se</i> convierta en 2. <br><br>  Este enfoque lleva fácilmente a la aparición de errores, por lo que muchas empresas trabajan con objetos inmutables.  En lugar de cambiar un objeto ya creado, nuevamente tendrá que crear un nuevo objeto (una copia del original) y realizar cambios en él.  Así es como funcionan las bibliotecas importantes como Redux, y en general este es uno de los conceptos básicos de la programación funcional.  Lee más <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  <b>La igualdad</b> <br><br>  De lo anterior también se deduce que dos objetos nunca pueden ser iguales, incluso si tienen las mismas propiedades.  Esto se debe al hecho de que JS, de hecho, compara la ubicación de los objetos en la memoria, y dos objetos nunca están en la misma celda de memoria. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Two distinct objects with the same properties are not equal var fruit = {name: 'apple'}; var fruitbear = {name: 'apple'}; fruit === fruitbear; // return false // here fruit and fruitbear are pointing to same object var fruit = {name: 'apple'}; var fruitbear = fruit; fruit === fruitbear; // return true</span></span></code> </pre><br>  Entonces, lo más probable es que ya se haya preguntado cómo comparar objetos o cómo realizar diversas manipulaciones con objetos, dado el requisito de su inmutabilidad. <br><br>  Considere varias posibilidades. <br><br>  <b>Cambio de objeto</b> <br><br>  Supongamos que está claro que, en el buen sentido, no deberíamos cambiar los objetos, por lo que queremos crear una copia del objeto correspondiente y cambiar sus propiedades.  <i>Object.assign ()</i> viene al <i>rescate</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj,{<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>}) <span class="hljs-comment"><span class="hljs-comment">// {a : 2, b : 2 }</span></span></code> </pre> <br>  Si queremos cambiar el valor de la propiedad a de <i>obj</i> , podemos usar <i>object.assign</i> para crear una copia de <i>obj</i> y cambiarlo. <br><br>  El ejemplo muestra que primero creamos un objeto vacío, luego copiamos los valores <i>obj</i> y hacemos nuestros cambios, y finalmente obtenemos un objeto nuevo y listo para usar. <br><br>  Tenga en cuenta que este método no funcionará para la copia profunda.  Hablando de copia profunda, queremos decir que necesita copiar un objeto con una o más propiedades. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span> : { <span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> } }; <span class="hljs-comment"><span class="hljs-comment">// b property is an object</span></span></code> </pre> <br>  <i>Object.assign ()</i> copia las propiedades del objeto, por lo que si el valor de la propiedad es un puntero a un objeto, solo se copia el puntero. <br><br>  La copia profunda requiere una operación recursiva.  Puede escribir una función aquí o simplemente usar el método <a href=""><i>_.cloneDeep</i></a> de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lodash</a> . <br><br>  <b>Comparación de objetos</b> <br><br>  Hay una forma genial de trabajar con objetos: la conversión de líneas.  En el siguiente ejemplo, convertimos ambos objetos en cadenas y los comparamos: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(obj1) === <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(obj2)</code> </pre> <br>  Este enfoque está justificado, porque al final comparamos cadenas que representan un puntero a un tipo de valor.  La mala noticia es que no siempre funciona, principalmente porque uno u otro orden de propiedades del objeto no está garantizado. <br><br>  Otra buena solución es usar el método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">_.isEqual</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lodash</a> , que realiza una comparación profunda de objetos. <br><br>  Y antes de terminar, repasemos algunas preguntas frecuentes sobre los objetos.  Esto ayudará a profundizar en el tema y poner en práctica los conocimientos adquiridos. <br><br>  Intente pensar en la solución usted mismo antes de leer la respuesta. <br><br><h3>  ¿Cómo averiguar la longitud de un objeto? </h3><br>  Para obtener la respuesta, es necesario ordenar todas las propiedades del objeto una por una y contarlas.  Hay varias formas de hacer esta iteración: <br><br><ul><li>  <i>para adentro</i> .  Este método cubre todas las propiedades contables de un objeto y su cadena prototipo.  Nos familiarizamos con el prototipo (y, espero, aprendimos el material), por lo que debe quedar claro que el uso de <i>for in</i> no siempre será cierto para obtener las propiedades del objeto. </li><li>  <i>Object.keys</i> .  Este método devuelve una matriz con las claves de <b>sus propias</b> propiedades <b>contables</b> (que pertenecen al objeto especificado).  Este enfoque es mejor, ya que solo trabajamos en las propiedades del objeto, sin recurrir a las propiedades del <i>prototipo</i> .  Sin embargo, hay situaciones en las que <i>establece el</i> atributo <i>enumerable</i> de alguna propiedad en falso, y <i>object.keys</i> finalmente lo omite y obtiene un resultado incorrecto.  Esto rara vez sucede, pero en tales casos <i>getOwnPropertyNames</i> será <i>útil</i> . </li><li>  <i>getOwnPropertyNames</i> devuelve una matriz que contiene todas las claves <b>propias</b> del objeto (contables e incontables). </li></ul><br>  También vale la pena mencionar: <br><br><ul><li>  <i>Object.values ​​itera</i> sobre sus propias propiedades de conteo y devuelve una matriz con los <b>valores</b> correspondientes. </li><li>  <i>Object.entries itera</i> sobre sus propias propiedades de conteo y devuelve una matriz <b>con claves y sus valores</b> . </li></ul><br>  Creo que notó que la mayoría de los métodos enumerados anteriormente devuelven una matriz.  Esta es una oportunidad para aprovechar al máximo los métodos de JavaScript para trabajar con matrices. <br><br>  Uno de estos métodos es <i>array.length</i> .  Al final, solo podemos escribir <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> objLength = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj).length;</code> </pre> <br><h3>  ¿Cómo verificar si un objeto está vacío? </h3><br><ol><li>  <i>JSON.stringify (myObj) === "{}"</i> .  Aquí nuevamente utilizamos la herramienta de conversión de cadenas, que facilita verificar si un objeto está vacío (comparando cadenas, no objetos). </li><li>  <i>! Object.keys (myobj) .length // verdadero</i> .  Como mencioné, convertir las claves de un objeto en una matriz puede ser muy útil.  Aquí usamos la <i>longitud de</i> propiedad conveniente heredada de <i>Array.prototype</i> , verificando con ella la longitud de las claves en la matriz.  En JS, <i>0 se</i> convierte en falso, ¡así que agrega <i>!</i>  Lo convertimos en verdad.  Cualquier otro número se convertirá en falso. </li></ol><br><h3>  En conclusión </h3><br>  Espero que ahora se sienta más seguro al crear objetos y trabajar con ellos.  Resumamos: <br><br><ul><li>  Recuerde que los objetos pertenecen al tipo de referencia, lo que significa que se recomienda trabajar con ellos sin cambiar los objetos originales. <br></li><li>  Haz amigos con la propiedad del <i>prototipo</i> y la cadena del <i>prototipo</i> . <br></li><li>  Conozca las herramientas auxiliares para trabajar con objetos.  Recuerde que puede convertir objetos en cadenas, obtener una matriz con sus claves o simplemente iterar sobre sus propiedades utilizando un conjunto de métodos que hemos conocido. <br></li></ul><br>  Buena suerte aprendiendo objetos JavaScript. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="imagen"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419193/">https://habr.com/ru/post/es419193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419179/index.html">Arquitectura pragmática pura. Lluvia de ideas</a></li>
<li><a href="../es419181/index.html">Programación del mouse: cómo nos escapamos de la rutina CRM</a></li>
<li><a href="../es419183/index.html">Demopati en Helsinki "Asamblea 2018", reportaje fotográfico, primer día</a></li>
<li><a href="../es419185/index.html">Descripción general de los protocolos actuales de creación de consenso en un entorno descentralizado</a></li>
<li><a href="../es419189/index.html">Por qué las ofertas de paquetes pronto formarán la base del comercio minorista</a></li>
<li><a href="../es419199/index.html">Informe del Club de Roma 2018, Capítulo 3.5: “Algunas historias de éxito en la agricultura”</a></li>
<li><a href="../es419201/index.html">¿Qué startups está buscando Y Combinator en 2018?</a></li>
<li><a href="../es419203/index.html">Transmisión del segundo día de Slurm: intenso en Kubernetes</a></li>
<li><a href="../es419205/index.html">¿Nueva vulnerabilidad de Mikrotik? No, pero vale la pena revisar tus dispositivos.</a></li>
<li><a href="../es419207/index.html">[Traducción] 4 formas de estilizar componentes de reacción</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>