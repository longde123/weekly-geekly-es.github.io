<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚀 💝 📒 Streaming data dari layanan REST ke antrian MQ 💉 〽️ 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Pada artikel ini, saya akan menjelaskan cara untuk mengembangkan layanan REST yang memungkinkan Anda untuk menerima file dan menyimpann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Streaming data dari layanan REST ke antrian MQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424941/">  Halo, Habr! <br><br>  Pada artikel ini, saya akan menjelaskan cara untuk mengembangkan layanan REST yang memungkinkan Anda untuk menerima file dan menyimpannya ke sistem pesan dalam mode streaming tanpa perlu menyimpan seluruh file di sisi layanan.  Skenario terbalik juga akan dijelaskan di mana klien akan menerima sebagai respons file yang terletak di sistem pesan. <br><br>  Untuk kejelasan, saya akan memberikan contoh kode layanan yang dikembangkan pada JEE7 untuk server aplikasi IBM WebSphere Liberty Server, dan IBM MQ akan bertindak sebagai sistem pengiriman pesan. <br>  Namun, metode yang dideskripsikan cocok untuk platform serupa lainnya, mis.  penyedia API JMS apa pun dapat bertindak sebagai sistem pengiriman pesan, dan server JEE apa pun (misalnya, Apache Tomcat) dapat bertindak sebagai server aplikasi. <br><a name="habracut"></a><br><h2>  Pernyataan masalah </h2><br>  Ada kebutuhan untuk mengimplementasikan solusi yang akan memungkinkan keduanya menerima file besar (&gt; 100 Mb) dari klien dan mentransfernya ke sistem lain yang jauh secara geografis, dan sebaliknya - mentransfer file dari sistem ini ke klien sebagai jawaban.  Mengingat saluran jaringan yang tidak dapat diandalkan antara jaringan klien dan jaringan aplikasi, sistem pengiriman pesan digunakan untuk memastikan pengiriman yang terjamin di antara mereka. <br><br>  Solusi tingkat atas mencakup tiga komponen: <br><br><ol><li>  Layanan REST - tugasnya adalah memberi klien kesempatan untuk mentransfer file (atau permintaan). </li><li>  MQ - bertanggung jawab untuk pengiriman pesan antar jaringan yang berbeda. </li><li>  Aplikasi - aplikasi yang bertanggung jawab untuk menyimpan file dan mengeluarkannya berdasarkan permintaan. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/9j/vt/k49jvtxkuphxkedfhlvmwswde0a.jpeg" alt="gambar"></div><br>  Dalam artikel ini, saya menjelaskan metode untuk mengimplementasikan layanan REST, tugas-tugasnya meliputi: <br><br><ul><li>  Menerima file dari klien. </li><li>  Transfer file yang diterima ke MQ. </li><li>  Mentransfer file dari MQ ke klien sebagai tanggapan. </li></ul><br><h2>  Metode solusi </h2><br>  Karena ukuran besar dari file yang ditransmisikan, tidak mungkin untuk menempatkannya sepenuhnya dalam RAM, apalagi, ada juga pembatasan di sisi MQ - ukuran maksimum satu pesan di MQ tidak dapat melebihi 100 Mb.  Dengan demikian, keputusan saya akan didasarkan pada prinsip-prinsip berikut: <br><br><ul><li>  Menerima file dan menyimpannya dalam antrian MQ harus dilakukan dalam mode streaming, tanpa menempatkan seluruh file dalam memori. </li><li>  Dalam antrian, file MQ akan ditempatkan sebagai satu set pesan kecil. </li></ul><br>  Secara grafis, alokasi file di sisi klien, layanan REST dan MQ ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/s7/fk/bas7fkcqokygdffbfaa0aebm0gi.jpeg" alt="gambar"></div><br>  Di sisi klien, file sepenuhnya terletak pada sistem file, dalam layanan REST, hanya sebagian file disimpan dalam RAM, dan di sisi MQ, setiap bagian dari file ditempatkan sebagai pesan terpisah. <br><br><h2>  Pengembangan layanan REST </h2><br>  Untuk kejelasan metode solusi yang diusulkan, layanan REST demo akan dikembangkan yang berisi dua metode: <br><br><ul><li>  unggah - menerima file dari klien dan menulisnya ke antrian MQ, mengembalikan pengidentifikasi grup pesan (dalam format base64) sebagai tanggapan. </li><li>  unduh - menerima pengidentifikasi grup pesan (dalam format base64) dari klien dan mengembalikan file yang disimpan dalam antrian MQ. </li></ul><br><h3>  Metode untuk menerima file dari klien (unggah) </h3><br>  Tugas metode ini adalah untuk mendapatkan aliran file yang masuk dan kemudian menulisnya ke antrian MQ. <br><br><h4>  Mengambil File Masuk </h4><br>  Untuk menerima file input dari klien, metode ini mengharapkan objek dengan antarmuka com.ibm.websphere.jaxrs20.multipart.IMultipartBody sebagai parameter input, yang menyediakan kemampuan untuk mendapatkan tautan ke aliran file yang masuk <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PUT</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"upload"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMultipartBody body)</span></span></span><span class="hljs-function"> </span></span>{ ... IAttachment attachment = body.getAttachment(<span class="hljs-string"><span class="hljs-string">"file"</span></span>); InputStream inputStream = attachment.getDataHandler().getInputStream(); ... }</code> </pre> <br>  Antarmuka (IMultipartBody) ini terletak di com.ibm.websphere.appserver.api.jaxrs20_1.0.21.jar arsip JAR, disertakan dengan IBM Liberty Server dan terletak di folder: &lt; <i>WLP_INSTALLATION_PATH</i> &gt; / dev / api / ibm. <br><br>  Catatan: <br><br><ul><li>  <i>WLP_INSTALLATION_PATH</i> - jalur ke direktori Profil WebSphere Liberty. </li><li>  Diharapkan klien akan mentransfer file dalam parameter bernama "file". </li><li>  Jika Anda menggunakan server aplikasi yang berbeda, Anda dapat menggunakan pustaka alternatif dari Apache CXF. </li></ul><br><h4>  Streaming menyimpan file dalam MQ </h4><br>  Metode menerima aliran file input, nama antrian MQ di mana file harus ditulis, dan pengidentifikasi grup pesan yang akan digunakan untuk mengikat pesan.  Pengenal grup dibuat di sisi layanan, misalnya, dengan utilitas org.apache.commons.lang3.RandomStringUtils: <br><br><pre> <code class="java hljs">String groupId = RandomStringUtils.randomAscii(<span class="hljs-number"><span class="hljs-number">24</span></span>);</code> </pre> <br>  Algoritma untuk menyimpan file input dalam MQ terdiri dari langkah-langkah berikut: <br><br><ol><li>  Inisialisasi objek koneksi MQ. </li><li>  Pembacaan siklus sebagian file yang masuk sampai file sepenuhnya dibaca: <ol><li>  Sepotong data file dicatat sebagai pesan terpisah di MQ. </li><li>  Setiap pesan dalam file memiliki nomor seri sendiri (properti "JMSXGroupSeq"). </li><li>  Semua pesan dalam file memiliki nilai grup yang sama (properti "JMSXGroupID"). </li><li>  Pesan terakhir memiliki tanda yang menunjukkan bahwa pesan ini bersifat final (properti "JMS_IBM_Last_Msg_In_Group"). </li><li>  Konstanta SEGMENT_SIZE berisi ukuran penyajian.  Misalnya, 1 MB. </li></ol></li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream inputStream, String queueName, String groupId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, JMSException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ( Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(); MessageProducer producer = session.createProducer(session.createQueue(queueName)); ) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[SEGMENT_SIZE]; BytesMessage message = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> readBytesSize = <span class="hljs-number"><span class="hljs-number">1</span></span>, sequenceNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>; readBytesSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; sequenceNumber++) { readBytesSize = inputStream.read(buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readBytesSize &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { message.setBooleanProperty(<span class="hljs-string"><span class="hljs-string">"JMS_IBM_Last_Msg_In_Group"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } producer.send(message); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readBytesSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { message = session.createBytesMessage(); message.setStringProperty(<span class="hljs-string"><span class="hljs-string">"JMSXGroupID"</span></span>, groupId); message.setIntProperty(<span class="hljs-string"><span class="hljs-string">"JMSXGroupSeq"</span></span>, sequenceNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readBytesSize == SEGMENT_SIZE) { message.writeBytes(buffer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.writeBytes(Arrays.copyOf(buffer, readBytesSize)); } } } } }</code> </pre><br><h3>  Metode untuk mengirim file ke klien (unduh) </h3><br>  Metode ini memperoleh pengidentifikasi sekelompok pesan dalam format base64, dimana ia membaca pesan dari antrian MQ dan mengirimkannya sebagai respons dalam mode streaming. <br><br><h4>  Mendapatkan id grup pesan </h4><br>  Metode ini menerima pengidentifikasi grup pesan sebagai parameter input. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PUT</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"download"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">download</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@QueryParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"groupId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String groupId) </span></span>{ ... }</code> </pre> <br><h4>  Streaming tanggapan ke klien </h4><br>  Untuk mentransfer file ke klien, disimpan sebagai satu set pesan terpisah di MQ, dalam mode streaming, buat kelas dengan antarmuka javax.ws.rs.core.StreamingOutput: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MQStreamingOutput</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamingOutput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String groupId; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String queueName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MQStreamingOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String groupId, String queueName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.groupId = groupId; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queueName = queueName; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutputStream outputStream)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, WebApplicationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MQWorker().read(outputStream, queueName, groupId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(NamingException | JMSException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(e); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { outputStream.flush(); outputStream.close(); } } }</code> </pre><br>  Di kelas, kami menerapkan metode menulis, yang menerima referensi input ke aliran keluar ke mana pesan dari MQ akan ditulis.  Saya juga menambahkan nama antrian dan pengenal grup yang pesannya akan dibacakan ke kelas. <br><br>  Objek kelas ini akan diteruskan sebagai parameter untuk membuat respons kepada klien: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"download"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">download</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@QueryParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"groupId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String groupId) </span></span>{ ResponseBuilder responseBuilder = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { MQStreamingOutput streamingOutput = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MQStreamingOutput(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(Utils.decodeBase64(groupId)), Utils.QUEUE_NAME); responseBuilder = Response.ok(streamingOutput); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e) { e.printStackTrace(); responseBuilder.status(Status.INTERNAL_SERVER_ERROR).entity(e.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> responseBuilder.build(); }</code> </pre> <br><h4>  Streaming membaca file dari MQ </h4><br>  Algoritma untuk membaca pesan dari MQ ke aliran keluar terdiri dari langkah-langkah berikut: <br><br><ol><li>  Inisialisasi objek koneksi MQ. </li><li>  Pembacaan siklus pesan dari MQ hingga pesan dengan tanda pengakhiran dalam grup dibaca (properti "JMS_IBM_Last_Msg_In_Group"): <br><ol><li>  Sebelum setiap pesan dibaca dari antrian, filter (messageSelector) diatur, di mana pengidentifikasi grup pesan dan nomor seri pesan dalam grup diatur. </li><li>  Isi dari pesan yang sudah dibaca ditulis ke aliran keluar. </li></ol><br></li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutputStream outputStream, String queueName, String groupId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, JMSException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>( Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(); ) { connection.start(); Queue queue = session.createQueue(queueName); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sequenceNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isMessageExist = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; isMessageExist == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; ) { String messageSelector = <span class="hljs-string"><span class="hljs-string">"JMSXGroupID='"</span></span> + groupId.replaceAll(<span class="hljs-string"><span class="hljs-string">"'"</span></span>, <span class="hljs-string"><span class="hljs-string">"''"</span></span>) + <span class="hljs-string"><span class="hljs-string">"' AND JMSXGroupSeq="</span></span> + sequenceNumber++; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>( MessageConsumer consumer = session.createConsumer(queue, messageSelector); ) { BytesMessage message = (BytesMessage) consumer.receiveNoWait(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { isMessageExist = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) message.getBodyLength()]; message.readBytes(buffer); outputStream.write(buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.getBooleanProperty(<span class="hljs-string"><span class="hljs-string">"JMS_IBM_Last_Msg_In_Group"</span></span>)) { isMessageExist = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } } } }</code> </pre> <br><h2>  Panggilan layanan REST </h2><br>  Untuk menguji layanan, saya akan menggunakan alat keriting. <br><br><h3>  Unggah file </h3><br><pre> <code class="bash hljs">curl -X PUT -F file=@&lt;__&gt; http://localhost:9080/Demo/rest/service/upload</code> </pre> <br>  Respons akan berupa string base64 yang berisi pengidentifikasi grup pesan, yang akan kami tunjukkan pada metode selanjutnya untuk mendapatkan file. <br><br><h3>  Menerima file </h3><br><pre> <code class="bash hljs">curl -X GET http://localhost:9080/Demo/rest/service/download?groupId=&lt;base64____&gt; -o &lt;_____&gt;</code> </pre> <br><h2>  Kesimpulan </h2><br>  Artikel tersebut memeriksa pendekatan untuk mengembangkan layanan REST yang memungkinkan Anda untuk melakukan streaming dan menerima data besar ke dalam antrian sistem pengiriman pesan, serta membacanya dari antrian untuk kembali sebagai respons.  Metode ini mengurangi penggunaan sumber daya, dan dengan demikian meningkatkan throughput solusi. <br><br><h2>  Bahan tambahan </h2><br>  Informasi lebih lanjut tentang antarmuka IMultipartBody yang digunakan untuk menerima aliran file masuk adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> . <br><br>  Pustaka alternatif untuk menerima file dalam mode streaming dalam layanan REST adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache CXF</a> . <br><br>  Antarmuka StreamingOutput untuk streaming tanggapan REST ke klien adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424941/">https://habr.com/ru/post/id424941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424929/index.html">Keajaiban Asia Shimano: kisah produsen peralatan sepeda legendaris</a></li>
<li><a href="../id424933/index.html">Cara kami membuat ulang prakiraan buruk menjadi prakiraan sedikit lebih baik (lanjutan)</a></li>
<li><a href="../id424935/index.html">Intisari Desain Makanan, September 2018</a></li>
<li><a href="../id424937/index.html">Acara digital di Moskow dari tanggal 1 hingga 7 Oktober</a></li>
<li><a href="../id424939/index.html">Polymorphic Quine</a></li>
<li><a href="../id424945/index.html">Smartphone mengendarai mobil mainan.</a></li>
<li><a href="../id424947/index.html">Pengenalan gerakan dengan APDS-9960</a></li>
<li><a href="../id424949/index.html">PHP Digest No. 140 (17 - 30 September 2018)</a></li>
<li><a href="../id424951/index.html">Hore! Itu bukan paranoia</a></li>
<li><a href="../id424955/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 332 (24 - 30 September 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>