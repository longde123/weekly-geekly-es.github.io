<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëï üè∑Ô∏è üîò GPU, aceleradores hexagonales y √°lgebra lineal üí£ üëÇüèæ üèÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todas estas palabras est√°n mucho m√°s relacionadas con el desarrollo m√≥vil de lo que parece a primera vista: los aceleradores hexagonales ya est√°n ayud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU, aceleradores hexagonales y √°lgebra lineal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/448222/"> Todas estas palabras est√°n mucho m√°s relacionadas con el desarrollo m√≥vil de lo que parece a primera vista: los aceleradores hexagonales ya est√°n ayudando a entrenar redes neuronales en dispositivos m√≥viles;  √°lgebra y matan son √∫tiles para conseguir un trabajo en Apple;  y la programaci√≥n de GPU no solo le permite acelerar las aplicaciones, sino que tambi√©n le ense√±a a ver la esencia de las cosas. <br><br>  En cualquier caso, as√≠ lo dice el jefe de desarrollo m√≥vil de Prisma, <b>Andrey Volodin</b> .  Y tambi√©n sobre c√≥mo las ideas fluyen hacia el desarrollo m√≥vil desde GameDev, c√≥mo difieren los paradigmas, por qu√© Android no tiene desenfoque nativo, y mucho m√°s, se ha lanzado el lanzamiento productivo de AppsCast.  Debajo del corte, hablaremos sobre el informe de Andrey sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> sin spoilers. <br><br><img src="https://habrastorage.org/webt/0q/af/fk/0qaffkk1onyogn5werp4i1_rcxg.jpeg"><br><a name="habracut"></a><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsCast</a> es el podcast de la conferencia de desarrolladores m√≥viles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> .</i>  <i>Cada n√∫mero es un nuevo invitado.</i>  <i>Cada invitado es un orador de la conferencia con quien discutimos su informe y hablamos sobre temas relacionados con √©l.</i>  <i>El podcast est√° dirigido por los miembros del comit√© del programa AppsConf Alexei Kudryavtsev y Daniil Popov.</i> <br><br>  <strong>Alexey Kudryavtsev:</strong> ¬°Hola a todos!  Andrey, cu√©ntanos tu experiencia. <br><br>  <b>Andrey Volodin</b> : Nosotros en Prisma estamos desarrollando productos que est√°n relacionados principalmente con el procesamiento de fotos y videos.  Nuestra aplicaci√≥n estrella es Prisma.  Ahora estamos haciendo otra aplicaci√≥n de Lensa para funcionalidad similar a Facetune. <br><br>  Dirijo el desarrollo m√≥vil, pero soy un entrenador de juegos.  Tengo toda la parte central, escribo tuber√≠as de GPU para todas estas aplicaciones.  Desarrollo marcos centrales para que los algoritmos y las neuronas que desarroll√≥ el equipo de I + D funcionen en dispositivos m√≥viles y funcionen en tiempo real.  En resumen, matar la inform√°tica del servidor y todo eso. <br><br>  <b>Alexei Kudryavtsev:</b> No parece un desarrollo normal de iOS. <br><br>  <b>Andrey Volodin:</b> S√≠, tengo tales detalles: escribo en Swift todos los d√≠as, pero al mismo tiempo est√° muy lejos de lo que se considera desarrollo de iOS. <br><br>  <b>Daniil Popov:</b> Usted mencion√≥ las tuber√≠as de GPU, ¬øde qu√© se trata? <br><br>  <b>Andrey Volodin:</b> Cuando haces editores de fotos, tambi√©n necesitas configurar la arquitectura y descomponer la l√≥gica, porque la aplicaci√≥n tiene diferentes herramientas.  Por ejemplo, en Lensa hay una herramienta de bokeh que difumina el fondo usando una neurona, hay una herramienta de retoque que hace que una persona sea m√°s bella.  Todo esto debe funcionar de manera m√°s eficiente en la GPU.  Adem√°s, es aconsejable no transferir datos entre el procesador y la tarjeta de video cada vez, sino pre-construir un conjunto de operaciones, realizarlas en una sola ejecuci√≥n y mostrar al usuario el resultado final. <br><br>  Las tuber√≠as de GPU son "peque√±os bultos" de los cuales se ensamblan las instrucciones para una tarjeta de video.  Luego ella hace todo esto de manera r√°pida y eficiente, y usted toma el resultado a la vez, y no despu√©s de cada instrumento.  Me aseguro de que nuestras tuber√≠as de GPU sean lo m√°s r√°pidas posible, eficientes y generalmente existan en principio. <br><br>  <b>Alexey Kudryavtsev:</b> Dime, ¬øc√≥mo llegaste a esto?  Un desarrollador habitual de iOS comienza con remaches y moldes, luego va a alg√∫n lado con la API y est√° contento.  ¬øC√≥mo sucedi√≥ que est√°s haciendo algo completamente diferente? <br><br>  <b>Andrey Volodin:</b> En su mayor parte, esto es una coincidencia.  Antes de conseguir un trabajo, hice juegos para iOS.  Siempre fue interesante para m√≠, pero entend√≠ que en Rusia especialmente no hay ning√∫n lugar para desarrollarse en esta direcci√≥n.  Dio la casualidad de que nos encontramos con Prisma.  Necesitaban un desarrollador de iOS que pueda escribir en Swift y al mismo tiempo conozca la GPU, en particular, Metal, que acaba de salir, y definitivamente encajo en esa descripci√≥n. <br><br>  Respond√≠ a la vacante, tuvimos una sinergia, y por tercer a√±o he estado profundizando cada vez m√°s en esto.  Si algo sale mal ahora, entonces ya tengo todos estos Viper y MVVM, ni siquiera s√© c√≥mo se desencripta, tendr√© que entenderlo desde el principio. <br><br><h2>  ¬øQu√© hace el ingeniero de GPU? </h2><br>  <b>Daniil Popov:</b> su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">perfil de</a> AppsConf dice la GPU Engineer.  ¬øQu√© hace la GPU Engineer la mayor parte del d√≠a adem√°s de tomar caf√©? <br><br>  <b>Andrey Volodin:</b> Aqu√≠ es necesario mencionar c√≥mo el procesador es fundamentalmente diferente de la GPU.  El procesador realiza operaciones como si fuera secuencialmente.  Incluso el subprocesamiento m√∫ltiple que tenemos a menudo es falso: el procesador se detiene y cambia para hacer peque√±as piezas de diferentes tareas, y las realiza en unos pocos segmentos.  La GPU funciona exactamente de la manera opuesta.  Hay n procesadores que realmente funcionan en paralelo, y hay paralelismo entre procesos y paralelismo dentro de la GPU. <br><br>  Mi trabajo principal, adem√°s de cosas comunes como optimizar el trabajo con memoria y organizar la reutilizaci√≥n del c√≥digo, es portar los algoritmos que est√°n escritos para la CPU a las tarjetas de video para que sean paralelos.  Esto no siempre es una tarea trivial, porque existen algoritmos muy eficientes que est√°n completamente vinculados a la ejecuci√≥n secuencial de instrucciones.  Mi trabajo es idear, por ejemplo, una aproximaci√≥n para dicho algoritmo que, tal vez, no sea exactamente lo mismo, pero visualmente el resultado no se puede distinguir.  Entonces podemos acelerar 100 veces, sacrificando un poco la calidad. <br><br>  Tambi√©n estoy portando neuronas.  Por cierto, pronto haremos un lanzamiento importante de c√≥digo abierto.  Incluso antes de que apareciera Core ML, ten√≠amos nuestra propia contraparte, y finalmente maduramos para ponerlo en c√≥digo abierto.  Su paradigma es ligeramente diferente de Core ML.  Yo, incluido, estoy desarrollando su parte central. <br><br>  En general, hago todo lo relacionado con algoritmos de computaci√≥n y computaci√≥n. <br><br>  <b>Alexey Kudryavtsev:</b> Un anuncio interesante. <br><br>  <b>Andrey Volodin:</b> Esto no es un secreto, no lo anunciaremos con alg√∫n tipo de fanfarria, solo es posible ver un ejemplo de los marcos utilizados dentro de Prisma. <br><br><h2>  ¬øPor qu√© optimizar para GPU? </h2><br>  <b>Alexei Kudryavtsev:</b> Dime, por favor, ¬øpor qu√© optimizamos los algoritmos para GPU en general?  Puede parecer que es suficiente agregar n√∫cleos al procesador u optimizar el algoritmo.  ¬øPor qu√© exactamente la GPU? <br><br>  <b>Andrey Volodin:</b> Trabajar en la GPU puede acelerar enormemente los algoritmos.  Por ejemplo, tenemos neuronas que se ejecutar√°n en el procesador central Samsung S10 durante 30 s, y en la GPU habr√° 1 fotograma, es decir, 1/60 s.  Esta es una experiencia de usuario incre√≠blemente cambiante.  No hay una pantalla de carga eterna, puede ver el resultado del algoritmo trabajando en la transmisi√≥n de video, o girar el control deslizante y ver los efectos all√≠ mismo. <br><br><blockquote>  No es que sea demasiado bueno para escribir en la CPU, por lo que reescribimos todo en la GPU.  El uso de una GPU tiene un objetivo transparente: acelerar las cosas. </blockquote><br>  <b>Alexei Kudryavtsev: La</b> GPU maneja operaciones similares entre s√≠ en paralelo.  ¬øTiene solo esas operaciones y, por lo tanto, logra alcanzar tal √©xito? <br><br>  <b>Andrey Volodin:</b> S√≠, la principal dificultad no es codificar, sino crear algoritmos que se transfieran bien a la GPU.  Esto no siempre es trivial.  Sucede que descubriste c√≥mo hacer todo bien, pero para esto necesitas demasiados puntos de sincronizaci√≥n.  Por ejemplo, escribe todo en una propiedad, y esta es una se√±al clara de que ser√° poco paralela.  Si escribe mucho en un lugar, entonces todos los hilos necesitar√°n sincronizarse para esto.  Nuestra tarea es aproximar los algoritmos para que sean paralelos bien. <br><br>  <b>Alexei Kudryavtsev:</b> Para m√≠, como desarrollador m√≥vil, suena como ciencia espacial. <br><br>  <b>Andrey Volodin:</b> En realidad, no es tan dif√≠cil.  Para m√≠, la ciencia de cohetes es VIPER. <br><br><h2>  Tercer chip </h2><br>  <b>Daniil Popov:</b> Parece que en la √∫ltima conferencia de Google I / O anunciaron un pedazo de hierro para TensorFlow y otras cosas.  ¬øCu√°ndo aparecer√° finalmente el tercer chip en tel√©fonos m√≥viles, TPU o c√≥mo se llamar√°, que tambi√©n har√° toda la magia ML en el dispositivo? <br><br>  <b>Andrey Volodin:</b> Tenemos esto mismo, se conecta a trav√©s de USB y puede controlar las neuronas de Google en √©l.  Huawei ya tiene esto, incluso escribimos software para sus aceleradores hexagonales, para que las neuronas de segmentaci√≥n persigan r√°pidamente al P20. <br><br>  Debo decir que en el iPhone ya existen.  Por ejemplo, en el √∫ltimo iPhone XS hay un coprocesador llamado NPU (Neural Processing Unit), pero hasta ahora solo Apple tiene acceso a √©l.  Este coprocesador ya est√° cortando la GPU en el iPhone.  Algunos modelos Core ML usan NPU y, por lo tanto, son m√°s r√°pidos que el Metal desnudo. <br><br>  Esto es significativo, dado que adem√°s de las neuronas de inferencia m√°s bajas, Core ML requiere mucha acci√≥n adicional.  Primero debe convertir los datos de entrada al formato Core ML, los procesar√°, luego los devolver√° a su formato; debe volver a convertirlos y solo mostrarlos al usuario.  Todo esto lleva bastante tiempo.  Escribimos canalizaciones gratuitas que funcionan desde el principio hasta el final en la GPU, mientras que los modelos Core ML son m√°s r√°pidos precisamente debido a este proceso de hardware. <br><br><blockquote>  Lo m√°s probable es que en WWDC en junio muestren un marco para trabajar con NPU. </blockquote><br>  Es decir, como dijiste, ya hay dispositivos, solo que los desarrolladores a√∫n no pueden usarlos por completo.  Mi hip√≥tesis es que las propias empresas a√∫n no entienden c√≥mo hacer esto con cuidado en forma de marco.  O simplemente no quieren regalar para tener una ventaja en el mercado. <br><br>  <b>Alexei Kudryavtsev:</b> Con el esc√°ner de huellas digitales, lo mismo sucedi√≥ en el iPhone, seg√∫n recuerdo. <br><br>  <b>Andrey Volodin:</b> √âl no es tan s√∫per asequible incluso ahora.  Puede usarlo a nivel superior, pero no puede obtener la impresi√≥n en s√≠.  Simplemente puede pedirle a Apple que permita que el usuario lo use.  Todav√≠a no es ese acceso completo al esc√°ner en s√≠. <br><br><h2>  Aceleradores Hexagonales </h2><br>  <b>Daniil Popov:</b> Usted mencion√≥ el t√©rmino aceleradores hexagonales.  Creo que no todos saben lo que es. <br><br>  <b>Andrey Volodin:</b> Esta es solo una pieza de arquitectura de hardware que utiliza Huawei.  Debo decir que es bastante sofisticada.  Pocas personas lo saben, pero en algunos Huawei estos procesadores son, pero no se usan, porque tienen un error de hardware.  Huawei los lanz√≥, y luego encontr√≥ un problema, ahora en algunos tel√©fonos los chips especiales son de peso muerto.  En versiones nuevas, todo ya funciona. <br><br>  En la programaci√≥n, existe el paradigma SIMD (Instrucci√≥n √∫nica, Datos m√∫ltiples), cuando las mismas instrucciones se ejecutan en paralelo en datos diferentes.  El chip est√° dise√±ado de tal manera que puede procesar algunas operaciones en paralelo en varios flujos de datos a la vez.  En particular, hexagonal significa que en 6 elementos en paralelo. <br><br>  <b>Alexei Kudryavtsev:</b> Pens√© que la GPU funcionaba as√≠: vectoriza una tarea y realiza la misma operaci√≥n en diferentes datos.  Cual es la diferencia <br><br>  <b>Andrey Volodin</b> : GPU es un prop√≥sito m√°s general.  A pesar de que la programaci√≥n para la GPU es bastante baja, con respecto al trabajo con coprocesadores es bastante alta.  Para programar en la GPU, se usa un lenguaje tipo C.  En iOS, el c√≥digo todav√≠a se compila con LLVM en las instrucciones de la m√°quina de todos modos.  Y estas cosas para los coprocesadores a menudo se escriben directamente en hardcore: en ensamblador, en instrucciones de la m√°quina.  Por lo tanto, all√≠ el aumento de la productividad es mucho m√°s notable, porque se agudizan para operaciones espec√≠ficas.  No puede contar con ellos para nada, pero solo puede contar para lo que fueron destinados originalmente. <br><br>  <b>Alexei Kudryavtsev:</b> ¬øY por qu√© suelen estar dise√±ados? <br><br>  <b>Andrey Volodin:</b> Ahora principalmente para las operaciones m√°s comunes en redes neuronales: convoluci√≥n - convoluci√≥n o alg√∫n tipo de activaci√≥n intermedia.  Tienen una funcionalidad precableada que funciona s√∫per r√°pido.  Por lo tanto, son mucho m√°s r√°pidos en algunas tareas que la GPU, pero en el resto simplemente no son aplicables. <br><br>  <b>Alexei Kudryavtsev:</b> Parece que los procesadores DSP, que alguna vez se usaron para audio, y todos los complementos y efectos funcionaron en ellos muy r√°pidamente.  Se vendi√≥ hardware costoso especial, pero luego los procesadores crecieron y ahora grabamos y procesamos podcasts directamente en las computadoras port√°tiles. <br><br>  <b>Andrey Volodin:</b> S√≠, casi lo mismo. <br><br><h2>  GPU no solo para gr√°ficos </h2><br>  <b>Daniil Popov:</b> ¬øEntiendo correctamente que ahora en la GPU puede procesar datos que no est√°n directamente relacionados con los gr√°ficos?  Resulta que la GPU est√° perdiendo su prop√≥sito original. <br><br>  <b>Andrey Volodin:</b> Exactamente.  A menudo hablo de esto en las conferencias.  Los primeros fueron NVidia, quienes presentaron CUDA.  Esta es una tecnolog√≠a que simplifica la GPGPU (Computaci√≥n de prop√≥sito general en unidades de procesamiento de gr√°ficos).  Puede escribir en √©l un superconjunto de algoritmos de C ++ que est√°n paralelos en la GPU. <br><br>  Pero la gente ha hecho esto antes.  Por ejemplo, los artesanos en OpenGL o en DirectX incluso m√°s antiguos simplemente escribieron datos en la textura: cada p√≠xel se interpret√≥ como datos: los primeros 4 bytes en el primer p√≠xel, los segundos 4 bytes en el segundo.  Procesaron las texturas, luego los datos de la textura fueron extra√≠dos e interpretados.  Fue muy mutilado y complicado.  Ahora las tarjetas de video admiten l√≥gica de prop√≥sito general.  Puede alimentar cualquier b√∫fer en la GPU, describir sus estructuras, incluso la jerarqu√≠a de estructuras en las que se referir√°n entre s√≠, calcular algo y devolverlo al procesador. <br><br>  <b>Daniil Popov:</b> Es decir, podemos decir que la GPU ahora es Data PU. <br><br>  <b>Andrey Volodin:</b> S√≠, los gr√°ficos en la GPU a veces se procesan menos que los c√°lculos generales. <br><br>  <b>Alexei Kudryavtsev: La</b> arquitectura de la CPU y la GPU es diferente en esencia, pero puedes considerarla all√≠ y all√°. <br><br>  <b>Andrey Volodin</b> : De hecho, en algunos aspectos la CPU es m√°s r√°pida, en algunos aspectos la GPU.  Esto no quiere decir que la GPU sea siempre m√°s r√°pida. <br><br>  <b>Daniil Popov:</b> Hasta donde recuerdo, si la tarea es calcular algo muy diferente, en la CPU puede ser mucho m√°s r√°pido. <br><br>  <b>Andrey Volodin: Tambi√©n</b> depende de la cantidad de datos.  Siempre existe la sobrecarga de transferir datos desde la CPU a la GPU y viceversa.  Si considera, por ejemplo, un mill√≥n de elementos, entonces el uso de una GPU generalmente est√° justificado.  Pero contar mil elementos en una CPU puede ser m√°s r√°pido que simplemente copiarlos en una tarjeta gr√°fica.  Por lo tanto, siempre debe elegir la tarea. <br><br>  Por cierto, Core ML lo hace.  Core ML puede ejecutar, seg√∫n Apple, para elegir d√≥nde es m√°s r√°pido calcular: en el procesador o en la tarjeta de video.  No s√© si esto funciona en realidad, pero dicen que s√≠. <br><br><h2>  Hardcore GPU Engineer conocimiento para un desarrollador m√≥vil </h2><br>  <b>Alexey Kudryavtsev:</b> Volvamos al desarrollo m√≥vil.  Eres un ingeniero de GPU, tienes toneladas de conocimiento incondicional.  ¬øC√≥mo se puede aplicar este conocimiento a un desarrollador m√≥vil?  Por ejemplo, ¬øqu√© ves en UIKit que otros no ven? <br><br>  <b>Andrey Volodin:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablar√©</a> sobre esto en detalle en AppsConf.  Puedes aplicar mucho donde.  Cuando veo, por ejemplo, c√≥mo funciona la API UIKit, puedo entender de inmediato por qu√© se hace esto y por qu√©.  Al observar la ca√≠da del rendimiento al renderizar algunas vistas, puedo entender la raz√≥n, porque s√© c√≥mo se escribe el renderizado en el interior.  Entiendo: para mostrar los efectos que el desenfoque gaussiano realmente hace en la parte superior del b√∫fer de cuadros, primero debe almacenar en cach√© toda la textura, aplicar una operaci√≥n de desenfoque intenso, devolver el resultado, terminar de renderizar el resto de las vistas y solo mostrarlo en la pantalla.  Todo esto debe caber en 1/60 de segundo, de lo contrario se ralentizar√°. <br><br>  Es absolutamente obvio para m√≠ por qu√© esto es mucho tiempo, pero para mis colegas esto no est√° claro.  Es por eso que quiero compartir los trucos de dise√±o que usamos a menudo en GameDev, y mis ideas sobre c√≥mo miro los problemas y trato de resolverlos.  Ser√° un experimento, pero creo que deber√≠a ser interesante. <br><br><h2>  Por qu√© Android no tiene desenfoque nativo </h2><br>  <b>Daniil Popov:</b> Usted mencion√≥ el desenfoque, y creo que tengo una pregunta que preocupa a todos los desarrolladores de Android: ¬øpor qu√© hay un bluer nativo en iOS y no en Android? <br><br>  <b>Andrei Volodin:</b> Creo que esto se debe a la arquitectura.  Las plataformas de Apple usan la arquitectura de representaci√≥n Tiled Shading.  Con este enfoque, no se procesa todo el marco, sino peque√±os mosaicos: cuadrados, partes de la pantalla.  Esto le permite optimizar el funcionamiento del algoritmo, ya que la ganancia de rendimiento principal cuando se utiliza la GPU proporciona un uso eficiente de la memoria cach√©.  En iOS, el marco a menudo se representa para que no ocupe nada de memoria.  Por ejemplo, en el iPhone 7 Plus, la resoluci√≥n es 1920 * 1080, que es de aproximadamente 2 millones de p√≠xeles.  Multiplicamos por 4 bytes por canal, resulta alrededor de 20 megabytes por cuadro.  20 MB para almacenar simplemente el b√∫fer de trama del sistema. <br><br>  El enfoque de sombreado en mosaico le permite dividir este b√∫fer en pedazos peque√±os y renderizarlo un poco.  Esto aumenta en gran medida el n√∫mero de accesos a la memoria cach√©, porque para difuminar, debe leer los p√≠xeles ya dibujados y calcular la distribuci√≥n gaussiana en ellos.  Si lee el fotograma completo, la velocidad de cach√© ser√° muy baja, porque cada secuencia leer√° diferentes lugares.  Pero si lee piezas peque√±as, la velocidad de cach√© ser√° muy alta y la productividad tambi√©n ser√° alta. <br><br>  Me parece que la falta de desenfoque nativo en Android est√° relacionada con caracter√≠sticas arquitect√≥nicas.  Aunque, tal vez esta sea una soluci√≥n de producto. <br><br>  <b>Daniil Popov:</b> En Android, hay RenderScript para esto, pero all√≠ debes mezclar, dibujar e incrustar con tus manos.  Esto es mucho m√°s complicado que configurar una casilla de verificaci√≥n en iOS. <br><br>  <b>Andrey Volodin:</b> Lo m√°s probable es que el rendimiento tambi√©n sea menor. <br><br>  <b>Daniil Popov:</b> S√≠, para satisfacer la lista de deseos del dise√±ador, tenemos que reducir la escala de la imagen, borrarla y luego volver a escalar para ahorrar de alguna manera. <br><br>  <b>Andrey Volodin:</b> Por cierto, con esto puedes hacer diferentes trucos.  La distribuci√≥n gaussiana es un c√≠rculo borroso.  Gauss sigma depende de la cantidad de p√≠xeles que desea que recopilen.  A menudo, como optimizaci√≥n, puede reducir la escala de la imagen y reducir un poco la sigma, y ‚Äã‚Äãcuando devuelva la escala original, no habr√° diferencia, porque la sigma depende directamente del tama√±o de la imagen.  A menudo usamos este truco para acelerar el desenfoque. <br><br>  <b>Daniil Popov:</b> Sin embargo, RenderScript en Android no le permite hacer un radio superior a 30. <br><br>  <b>Andrey Volodin:</b> En realidad, un radio de 30 es mucho.  Nuevamente, entiendo que recolectar 30 p√≠xeles usando una GPU en cada hilo es muy costoso. <br><br><h2>  ¬øCu√°les son las similitudes entre el desarrollo m√≥vil y GameDev </h2><br>  <b>Alexei Kudryavtsev:</b> En las tesis de su informe, dice que el desarrollo m√≥vil y GameDev tienen mucho en com√∫n.  Dime un poco, ¬øqu√© es exactamente? <br><br>  <b>Andrey Volodin: La</b> arquitectura de UIKit recuerda mucho a los motores de juegos y a los antiguos.  Los modernos han ido en la direcci√≥n del Sistema de Componentes de la Entidad, y esto tambi√©n estar√° en el informe.  Esto tambi√©n llega a UIKit, hay art√≠culos que escriben c√≥mo puede dise√±ar vistas en componentes.     GameDev,  Component System    Thief  98 . <br><br> , , Cocos2d,      ,  ,     ,  .  ,    Scene graph ‚Äî  ,      -,        ,    iOS  CGAffineTransform.    4*4,  ,    .     . <br><br>    ,   UIKit      .    -  ‚Äî       .    :  GameDev     ,   UIKit  setNeedsLayout, layoutIfNeeded. <br><br>        ‚Äî  ,   - ,   ,      Apple.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> . <br><br> <b> :</b> , API Cocos2d   iOS ( UI).  ,         ? <br><br> <b> :</b> ,  - . Cocos2d   2008-2009 ,  UIKit    UIKit,    .   ,  -    ,     ,     . <br><br> ,   :  core- Cocos2d    Apple,   Apple   Cocos2d,     . SpriteKit      ,    Cocos2d.    Apple   . <br><br> <b> :</b>  ,   ,   UIKit  2009,    MacOS,     .    setNeedsLayout, layoutIfNeeded ,  . <br><br> <b> :</b> ,  GameDev   ,  MacOS. <br><br> <b> :</b>  ! <br><br> <b> :</b>     Cocos2d   Apple,      ,    GameDev.   GameDev   ,   ‚Äî  .     ,  GameDev   ,    ,   .  ,  ,     . <br><br> <b> :</b> ,    - ,   ‚Äî  . <br><br> <b> </b> : ,   , ,       ,   ‚Äî  .    Protocol-Oriented Programming  Swift, ,    - .  GameDev      . <br><br> <b> :</b>  :     ,   .  ,    ,    ,     . <br><br><h2>     GameDev </h2><br> <b> :</b>    :  GameDev     ,    GameDev    ? <br><br> <b> :</b>  ,    ,     .       ¬´  ,  ¬ª.    ,     .      :    ,    ,  . <br><br> GameDev-    .     : 30  60        ,  ,   ,    .   ,      .      ‚Äî       .  --   1/60  1/30 .   ,     , ,  GPU  ,   CPU .        ,    . <br><br> <b> :</b>         ? <br><br> <b> :</b>    . -       , , ,         .     ‚Äî   .     , , ,  ‚Äî  - ,  - ,  .      ,      ,      . <br><br>      . , GPU     float,    double, -    . , ,     ,    .  CPU  ,        ,       ,   GPU     . <br><br>      ,      ,    ‚Äî     . <br><br><h2>      GameDev,    </h2><br> <b> :</b>        ,  ¬´     GameDev,   ¬ª.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>    ,     ,   .     ,  GameDev ‚Äî      .        ,  .      GameDev. <br><br> <b> :</b> , enterprise-   ,    GameDev    .      .   ,     ,    GameDev,     . <br><br> ,  .    ,      4*4.  CGAffineTransform ‚Äî    ,   -        ,   . <br><br><blockquote>        ,     ,   ,  ,    . </blockquote><br><h2>    </h2><br> <b> :</b>       ?  ,       UIKit,     ,     ?  ,   ,       ,   .   ,     ? <br><br> <b> :</b>    ‚Äî   pet project. <br><br> ,      :    GPU     ,     . iOS GPU      ,     .    iOS     ,     -  NVidia  AMD-   .    . API  ,   ,         . <br><br> <b> :</b>   API, ,   Cocos2d  Unity,      ‚Äî   - .    ,    ,   ,   UIKit    ? <br><br> <b> :</b> Cocos2d ‚Äî Open Source    .    ,      ,   ,     ,     .       objective-C,        . <br><br>      pet project,          ,   ,   API,  , , -. ,   API,   VHS-.    ,   GPU.    ,     .     ,      .      ,   : ¬´     saturation  Instagram,   lightroom!¬ª ,   ,   4      ‚Äî  . <br><br><blockquote>     ,   . </blockquote><br>         ‚Äî ,   , .     ,      ,    -  ,   ,      ,   . <br><br> <b> :</b>    ,   -  . ,  Cocos2d -  ‚Äî  5  ,       ,    ,    ,   . ,       ,   ,    .. <br><br> <b> :</b>   .       ,   .   ,         ,          ,        ,        ,    , , ,    ,     . <br><br> <b> :</b>     ,       . ,     ,    . <br><br> <b> :</b>     .    ,  ,       .       ,      Apple,   ARKit.       ,       ,    .    ,     ,        ,     ,   . <br><br> ,            ,  : ¬´,      IDE, ,   ,     ,   .        ¬ª. <br><br> <b> :</b>   ‚Äî  ? <br><br> <b> :</b> , ,    ,      . <br><br> <b> :</b>   ,   ,       . <br><br> <b> :</b> ,      ,   ,  VR   .    Project Template  Xcode,    ,   , - .    ,       . <br><br> <b> :</b>       . <br><br><h2>  </h2><br> <b> :</b>  -  ,      GameDev  GPU. <br><br> <b> :</b>    .   - ,      ,   ,  .   ,         ,   ,   ,  ,      UI: ,  , runtime Objective-C ‚Äî  ,    ,     .     .      ,     : ,  ‚Äî , X  Y, ! <br><br><blockquote>    ,  ,  - ,  GameDev  GPU- ‚Äî   . </blockquote><br> <b>        ,   .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> 22  23     .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448222/">https://habr.com/ru/post/448222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448212/index.html">Protocolo chino AIBUS y reactor qu√≠mico de laboratorio</a></li>
<li><a href="../448214/index.html">Proxies ES6 en la pr√°ctica</a></li>
<li><a href="../448216/index.html">Configure un conjunto conveniente de proyectos en Visual Studio</a></li>
<li><a href="../448218/index.html">Nueva seguridad de MFP: imageRUNNER ADVANCE III</a></li>
<li><a href="../448220/index.html">Los fundamentos del formato GLTF y GLB, parte 1</a></li>
<li><a href="../448224/index.html">AppsConf para gobernarlos a todos</a></li>
<li><a href="../448226/index.html">En busca del mismo (informe de temas para AppsConf)</a></li>
<li><a href="../448228/index.html">Tipos de modelado. Conceptos b√°sicos de escultura, retopolog√≠a y barrido</a></li>
<li><a href="../448230/index.html">Gestionar la continuidad del negocio con ClearView</a></li>
<li><a href="../448234/index.html">AI y MO: algunas tendencias y tendencias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>