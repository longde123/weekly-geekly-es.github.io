<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽 🗣️ 🤽🏼 Analyse du langage VKScript: JavaScript, êtes-vous? 🚂 👎🏿 🐏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 



 VKScript n'est pas JavaScript. La sémantique de ce langage est fondamentalement différente de la sémantique de JavaScript. Voir la conclus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse du langage VKScript: JavaScript, êtes-vous?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464099/"><h1>  TL; DR </h1><br><hr><br><p>  VKScript n'est <b>pas</b> JavaScript.  La sémantique de ce langage est fondamentalement différente de la sémantique de JavaScript.  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conclusion</a> . </p><br><a name="habracut"></a><h1>  Qu'est-ce que VKScript? </h1><br><hr><br><p> <b>VKScript</b> est un langage de programmation de script de type JavaScript utilisé dans la méthode API d' <code>execute</code> VKontakte, qui permet aux clients de télécharger exactement les informations dont ils ont besoin.  En substance, VKScript est un analogue de GraphQL utilisé par Facebook dans le même but. </p><br><p>  Comparez GraphQL et VKScript: </p><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  GraphQL </th><th>  VKScript </th></tr><tr><td>  Implémentations </td><td>  De nombreuses implémentations open source dans différents langages de programmation </td><td>  La seule implémentation au sein de l'API VK </td></tr><tr><td>  Basé sur </td><td>  Nouvelle langue </td><td>  Javascript </td></tr><tr><td>  Les possibilités </td><td>  Demande de données, filtrage limité;  les arguments de requête ne peuvent pas utiliser les résultats des requêtes précédentes </td><td>  Tout post-traitement de données à la discrétion du client;  Les requêtes API sont présentées sous forme de méthodes et peuvent utiliser toutes les données des requêtes précédentes </td></tr></tbody></table></div><br><p>  Description de VKScript à partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page de méthode dans la documentation de l'API VK</a> (la seule documentation en langue officielle): </p><br><blockquote><div class="scrollable-table"><table><tbody><tr><th>  code </th><td>  code d'algorithme en <b>VKScript</b> - un format similaire à <b>JavaScript</b> ou <b>ActionScript</b> <i>(la compatibilité avec <b>ECMAScript est</b> supposée)</i> .  L'algorithme doit se terminer par la commande <b>return% expression%</b> .  Les opérateurs doivent être séparés par des points-virgules. <br>  chaîne </td></tr></tbody></table></div><br><p>  Les éléments suivants sont pris en charge: </p><br><ul><li>  opérations arithmétiques </li><li>  opérations logiques </li><li>  création de tableaux et de listes ([X, Y]) </li><li>  <b>parseInt</b> et <b>parseDouble</b> </li><li>  concaténation (+) </li><li>  <b>si</b> construire </li><li>  filtre de tableau par paramètre (@.) </li><li>  Appels de méthode <b>API</b> , paramètre de <b>longueur</b> </li><li>  boucles utilisant l'instruction <b>while</b> </li><li>  Méthodes Javascript: <b>tranche</b> , <b>push</b> , <b>pop</b> , <b>shift</b> , <b>unshift</b> , <b>splice</b> , <b>substr</b> , <b>split</b> </li><li>  <b>supprimer l'</b> opérateur </li><li>  affectation aux éléments du tableau, par exemple: row.user.action = "test"; </li><li>  recherchez dans un tableau ou une chaîne - <b>indexOf</b> , par exemple: «123» .indexOf (2) = 1, [1, 2, 3] .indexOf (3) = 2. Renvoie -1 si l'élément n'est pas trouvé. </li></ul><br><p>  La création de fonctions n'est actuellement pas prise en charge. </p><br></blockquote><br><p>  La documentation citée indique que "la compatibilité ECMAScript est prévue."  Mais en est-il ainsi?  Essayons de comprendre comment cette langue fonctionne de l'intérieur. </p><br><br><h1>  Table des matières </h1><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Machine virtuelle VKScript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémantique des objets VKScript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ol><br><a name="vm"></a><h1>  Machine virtuelle VKScript </h1><br><hr><br><p>  Comment analyser un programme en l'absence d'une copie locale?  C'est vrai - envoyez des demandes au point de terminaison public et analysez les réponses.  Essayons, par exemple, d'exécuter le code suivant: </p><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Nous obtenons une <code>Runtime error occurred during code invocation: Too many operations</code> .  Cela suggère que dans la mise en œuvre du langage, il y a une limite au nombre d'actions effectuées.  Essayons de définir la valeur limite exacte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>Runtime error occurred during code invocation: Too many operations</code> . </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>{"response": null}</code> - Le code a été exécuté avec succès. </li></ul><br><p>  Ainsi, la limite du nombre d'opérations est d'environ 1 000 cycles «inactifs».  Mais, en même temps, il est clair qu'un tel cycle n'est probablement pas une opération «unitaire».  Essayons de trouver une opération qui n'est pas divisée par le compilateur en plusieurs plus petites. </p><br><p>  Le candidat le plus évident pour le rôle d'une telle opération est la soi-disant déclaration vide ( <code>;</code> ).  Cependant, après avoir ajouté au code avec <code>i &lt; 999</code> 50 caractères <code>;</code>  , la limite n'est pas dépassée.  Cela signifie que soit l'instruction vide est levée par le compilateur et ne gaspille pas les opérations, soit une itération de la boucle prend plus de 50 opérations (ce qui n'est probablement pas le cas). </p><br><p>  La prochaine chose qui me vient à l'esprit après <code>;</code>  - calcul d'une expression simple (par exemple, comme ceci: <code>1;</code> ).  Essayons d'ajouter certaines de ces expressions à notre code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    1; //       "Too many operations"</span></span></code> </pre> <br><p>  Ainsi, 2 opérations <code>1;</code>  dépenser plus d'opérations que 50 opérations <code>;</code>  .  Cela confirme l'hypothèse selon laquelle une instruction vide ne gaspille pas les instructions. </p><br><p>  Essayons de réduire le nombre d'itérations du cycle et ajoutons <code>1;</code> supplémentaire <code>1;</code>  .  Il est facile de remarquer que pour chaque itération il y en a 5 supplémentaires <code>1;</code>  par conséquent, une itération du cycle passe 5 fois plus d'opérations qu'une opération <code>1;</code>  . </p><br><p>  Mais y a-t-il une opération encore plus simple?  Par exemple, l'ajout de l'opérateur unaire <code>~</code> ne nécessite pas le calcul d'expressions supplémentaires, et l'opération elle-même est effectuée sur le processeur.  Il est logique de supposer que l'ajout de cette opération à l'expression augmente le nombre total d'opérations de 1. </p><br><p>  Ajoutez cet opérateur à notre code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Et oui, nous pouvons ajouter un tel opérateur et une autre expression <code>1;</code>  - plus.  Par conséquent, <code>1;</code>  n'est vraiment pas un opérateur unitaire. </p><br><p>  Similaire à l'opérateur <code>1;</code>  , nous allons réduire le nombre d'itérations de la boucle et ajouter les opérateurs <code>~</code> .  Une itération s'est avérée équivalente à 10 opérations unitaires <code>~</code> , donc, l'expression <code>1;</code>  passe 2 opérations. </p><br><p>  Notez que la limite est d'environ 1000 itérations, soit environ 10000 opérations simples.  Nous supposons que la limite est exactement de 10 000 opérations. </p><br><br><h2>  Mesurer le nombre d'opérations dans le code </h2><br><hr><br><p>  Notez que nous pouvons maintenant mesurer le nombre d'opérations dans n'importe quel code.  Pour ce faire, ajoutez ce code après la boucle et ajoutez / supprimez des itérations, des opérateurs <code>~</code> ou la dernière ligne entière, jusqu'à ce que l'erreur <code>Too many operations</code> disparaisse. </p><br><p>  Quelques résultats de mesure: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Code </th><th>  Nombre d'opérations </th></tr><tr><td> <code>1;</code> </td> <td>  2 </td></tr><tr><td> <code>~1;</code> </td> <td>  3 </td></tr><tr><td> <code>1+1;</code> </td> <td>  4 </td></tr><tr><td> <code>1+1+1;</code> </td> <td>  6 </td></tr><tr><td> <code>(true?1:1);</code> </td> <td>  5 </td></tr><tr><td> <code>(false?1:1);</code> </td> <td>  4 </td></tr><tr><td> <code>if(0)1;</code> </td> <td>  2 </td></tr><tr><td> <code>if(1)1;</code> </td> <td>  4 </td></tr><tr><td> <code>if(0)1;else 1;</code> </td> <td>  4 </td></tr><tr><td> <code>if(1)1;else 1;</code> </td> <td>  5 </td></tr><tr><td> <code>while(0);</code> </td> <td>  2 </td></tr><tr><td> <code>i=1;</code> </td> <td>  3 </td></tr><tr><td> <code>i=i+1;</code> </td> <td>  5 </td></tr><tr><td> <code>var j = 1;</code> </td> <td>  1 </td></tr><tr><td> <code>var j = 0;while(j &lt; 1)j=j+1;</code> </td> <td>  15 </td></tr></tbody></table></div><br><br><h2>  Déterminer le type de machine virtuelle </h2><br><hr><br><p>  Vous devez d'abord comprendre le fonctionnement de l'interpréteur VKScript.  Il existe deux options plus ou moins plausibles: </p><br><ul><li>  L'interpréteur parcourt récursivement l'arborescence de syntaxe et effectue une opération sur chaque nœud. </li><li>  Le compilateur traduit l'arbre de syntaxe en une séquence d'instructions que l'interprète exécute. </li></ul><br><p>  Il est facile de comprendre que VKScript utilise la deuxième option.  Considérez l'expression <code>(true?1:1);</code>  (5 opérations) et <code>(false?1:1);</code>  (4 opérations).  Dans le cas de l'exécution séquentielle d'instructions, une opération supplémentaire s'explique par une transition qui «contourne» la mauvaise option, et dans le cas d'un bypass AST récursif, les deux options sont équivalentes pour l'interpréteur.  Un effet similaire est observé dans if / else avec une condition différente. </p><br><p>  Il convient également de prêter attention à la paire <code>i = 1;</code>  (3 opérations) et <code>var j = 1;</code>  (1 opération).  La création d'une nouvelle variable ne coûte qu'une opération et l'affectation à une existante coûte 3?  Le fait que la création d'une opération à coût variable 1 (et, très probablement, soit une opération de chargement constant), dit deux choses: </p><br><ul><li>  Lors de la création d'une nouvelle variable, il n'y a pas d'allocation de mémoire explicite pour la variable. </li><li>  Lors de la création d'une nouvelle variable, la valeur n'est pas chargée dans la cellule mémoire.  Cela signifie que l'espace pour la nouvelle variable est alloué là où la valeur de l'expression a été calculée, et ensuite cette mémoire est considérée comme allouée.  Cela suggère l'utilisation d'une machine à empiler. </li></ul><br><p>  L'utilisation de la pile explique également que l'expression <code>var j = 1;</code>  s'exécute plus rapidement que l'expression <code>1;</code>  : la dernière expression dépense des instructions supplémentaires pour supprimer la valeur calculée de la pile. </p><br><br><h2>  Déterminer la valeur limite exacte </h2><br><p>  Notez que le cycle <code>var j=0;while(j &lt; 1)j=j+1;</code>  (15 opérations) est une petite copie du cycle qui a été utilisé pour les mesures: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Code </th><th>  Nombre d'opérations </th></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 + 998 * 10 = 9995 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  (limite) </td><td>  9998 </td></tr></tbody></table></div><br><p>  Arrête quoi?  Y a-t-il une limite de 9998 instructions?  Il nous manque clairement quelque chose ... </p><br><p>  Notez que le code <code>return 1;</code> est <code>return 1;</code>  effectué selon les mesures pour 0 instructions.  Cela s'explique facilement: le compilateur ajoute un <code>return null;</code> implicite <code>return null;</code> à la fin du code <code>return null;</code>  , et lors de l'ajout de son retour, il échoue.  En supposant que la limite est de 10000, nous concluons que l'opération <code>return null;</code>  prend 2 instructions (c'est probablement quelque chose comme <code>push null; return;</code> ). </p><br><br><h2>  Blocs de code imbriqués </h2><br><hr><br><p>  Prenons quelques mesures supplémentaires: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Code </th><th>  Nombre d'opérations </th></tr><tr><td> <code>{};</code> </td> <td>  0 </td></tr><tr><td> <code>{var j = 1;};</code> </td> <td>  2 </td></tr><tr><td> <code>{var j = 1, k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>{var j = 1; var k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>var j = 1; var j = 1;</code> </td> <td>  4 </td></tr><tr><td> <code>{var j = 1;}; var j = 1;</code> </td> <td>  3 </td></tr></tbody></table></div><br><p>  Prenons attention aux faits suivants: </p><br><ul><li>  L'ajout d'une variable à un bloc nécessite une opération supplémentaire. </li><li>  Lors de la "déclaration à nouveau d'une variable", la deuxième déclaration est remplie comme une affectation normale. </li><li>  Mais en même temps, la variable à l'intérieur du bloc n'est pas visible de l'extérieur (voir le dernier exemple). </li></ul><br><p>  Il est facile de comprendre qu'une opération supplémentaire est dépensée pour supprimer de la pile les variables locales déclarées dans le bloc.  Par conséquent, lorsqu'il n'y a pas de variables locales, rien ne doit être supprimé. </p><br><br><h1>  Objets, méthodes, appels API </h1><br><hr><br><div class="scrollable-table"><table><tbody><tr><th>  Code </th><th>  Nombre d'opérations </th></tr><tr><td> <code>"";</code> </td> <td>  2 </td></tr><tr><td> <code>"abcdef";</code> </td> <td>  2 </td></tr><tr><td> <code>{};</code> </td> <td>  2 </td></tr><tr><td> <code>[];</code> </td> <td>  2 </td></tr><tr><td> <code>[1, 2, 3];</code> </td> <td>  5 </td></tr><tr><td> <code>{a: 1, b: 2, c: 3};</code> </td> <td>  5 </td></tr><tr><td> <code>API.users.isAppUser(1);</code> </td> <td>  3 </td></tr><tr><td> <code>"".substr(0, 0);</code> </td> <td>  6 </td></tr><tr><td> <code>var j={};jx=1;</code> </td> <td>  6 </td></tr><tr><td> <code>var j={x:1};delete jx;</code> </td> <td>  6 </td></tr></tbody></table></div><br><p>  Analysons les résultats.  Vous remarquerez peut-être que la création d'une chaîne et d'un tableau / objet vide nécessite 2 opérations, tout comme le chargement d'un nombre.  Lors de la création d'un tableau ou d'un objet non vide, les opérations consacrées au chargement des éléments du tableau / objet sont ajoutées.  Cela suggère que la création directe d'un objet se produit en une seule opération.  Dans le même temps, aucun temps n'est perdu pour télécharger les noms de propriété; par conséquent, leur téléchargement fait partie de l'opération de création de l'objet. </p><br><p>  Avec l'appel de méthode API, tout est également assez courant - charger une unité, appeler la méthode, <code>pop</code> résultat (vous pouvez remarquer que le nom de la méthode est traité dans son ensemble, et non comme prenant des propriétés).  Mais les trois derniers exemples semblent intéressants. </p><br><ul><li> <code>"".substr(0, 0);</code>  - chargement d'une chaîne, chargement zéro, chargement zéro, résultat <code>pop</code> .  Pour une raison, il existe 2 instructions pour appeler une méthode (pour une raison quelconque, voir ci-dessous). </li><li> <code>var j={};jx=1;</code>  - création d'un objet, chargement d'un objet, chargement d'une unité, <code>pop</code> unité après affectation.  Encore une fois, il y a 2 instructions pour l'affectation. </li><li> <code>var j={x:1};delete jx;</code>  - chargement d'une unité, création d'un objet, chargement d'un objet, suppression.  Il y a 3 instructions par opération de suppression. </li></ul><br><br><a name="semantics"></a><br><h1>  Sémantique des objets VKScript </h1><br><h2>  Les chiffres </h2><br><hr><br><p>  Retour à la question d'origine: VKScript est-il un sous-ensemble de JavaScript ou d'un autre langage?  Faisons un test simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> + <span class="hljs-number"><span class="hljs-number">2000000000</span></span>;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-number"><span class="hljs-number">-1294967296</span></span>};</code> </pre> <br><p>  Comme nous pouvons le voir, l'addition d'entiers conduit à un débordement, malgré le fait que JavaScript n'a pas d'entiers en tant que tels.  Il est également facile de vérifier que la division par 0 entraîne une erreur et ne renvoie pas <code>Infinity</code> . </p><br><br><h2>  Les objets </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {};</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p>  Arrête quoi?  Nous retournons <i>un objet</i> et obtenons un <i>tableau</i> ?  Oui, ça l'est.  Dans VKScript, les tableaux et les objets sont représentés par le même type, en particulier, un objet vide et un tableau vide sont une seule et même chose.  Dans ce cas, la propriété <code>length</code> de l'objet fonctionne et renvoie le nombre de propriétés. </p><br><p>  Il est intéressant de voir comment les méthodes de liste se comportent si vous les appelez sur un objet? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  La méthode <code>pop</code> renvoie la dernière propriété déclarée, qui est cependant logique.  Modifiez l'ordre des propriétés: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Apparemment, les objets dans VKScript se souviennent de l'ordre dans lequel les propriétés sont attribuées.  Essayons d'utiliser des propriétés numériques: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Voyons maintenant comment fonctionne push: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(<span class="hljs-string"><span class="hljs-string">'d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p>  Comme vous pouvez le voir, la méthode push trie les touches numériques et ajoute une nouvelle valeur après la dernière touche numérique.  Les «trous» ne sont pas remplis dans ce cas. </p><br><p>  Essayez maintenant de combiner ces deux méthodes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(a.pop()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p>  Comme nous le voyons, l'élément n'a pas été supprimé du tableau.  Cependant, si nous mettons <code>push</code> and <code>pop</code> sur différentes lignes, le bug disparaîtra.  Nous devons aller plus loin! </p><br><br><h2>  Stockage d'objets </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = x; xy = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p>  Il s'est avéré que les objets en VKScript sont stockés par valeur, contrairement à JavaScript.  Nous voyons maintenant l'étrange comportement de la chaîne <code>a.push(a.pop());</code>  - apparemment, l'ancienne valeur du tableau a été enregistrée sur la pile, d'où elle a été prise plus tard. </p><br><p>  Cependant, comment les données sont-elles alors stockées dans l'objet si la méthode le modifie?  Apparemment, l'instruction «extra» lors de l'appel de la méthode est conçue spécifiquement pour réécrire les modifications sur l'objet. </p><br><br><h2>  Méthodes de tableau </h2><br><hr><br><div class="scrollable-table"><table><tbody><tr><th>  La méthode </th><th>  Action </th></tr><tr><td> <code>push</code> </td> <td><ul><li>  trier les clés numériques par valeur </li><li>  prendre la clé numérique maximale, en ajouter une </li><li>  écrire l'argument dans le tableau </li><li>  ajouter des clés non numériques à la fin du tableau </li></ul></td></tr><tr><td> <code>pop</code> </td> <td>  Supprimez le dernier élément du tableau (pas nécessairement avec une touche numérique) et revenez. </td></tr><tr><td>  le reste </td><td><ul><li>  trier les clés numériques par valeur, supprimer les «trous» dans le tableau </li><li>  effectuer une opération javascript appropriée </li><li>  ajouter des clés non numériques à la fin du tableau </li></ul><br><p>  Lors de l'utilisation de la méthode de tranche, les modifications ne sont pas enregistrées </p><br></td></tr></tbody></table></div><br><a name="summary"></a><h1>  Conclusion </h1><br><hr><br><p>  VKScript n'est pas JavaScript.  Contrairement à JavaScript, les objets qu'il contient sont stockés par valeur, et non par référence, et ont une sémantique complètement différente.  Cependant, lors de l'utilisation de VKScript pour l'usage auquel il est destiné, la différence n'est pas perceptible. </p><br><br><h1>  PS Sémantique des opérateurs </h1><br><hr><br><p>  Les commentaires mentionnaient la combinaison d'objets via <code>+</code> .  À cet égard, j'ai décidé d'ajouter des informations sur le travail des opérateurs. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Opératrice </th><th>  Actions </th></tr><tr><td>  + </td><td><ul><li>  Si les deux arguments sont des objets, créez une copie du premier objet et ajoutez-y les clés du second (avec remplacement). </li><li>  Si les deux arguments sont des nombres, ajoutez en tant que nombres. </li><li>  Sinon, les deux opérandes sont convertis en chaîne et ajoutés en tant que chaînes. </li></ul></td></tr><tr><td>  Autres opérateurs arithmétiques </td><td>  Les deux opérandes sont convertis en un nombre et l'opération correspondante est effectuée.  Pour les opérations sur les bits, les opérandes sont également convertis en <code>int</code> . </td></tr><tr><td>  Opérateurs de comparaison </td><td>  Si deux chaînes ou deux nombres sont comparés, ils sont comparés directement.  Si une chaîne et un nombre sont comparés et que la chaîne est une notation correcte pour le nombre, la chaîne est convertie en un nombre.  Sinon, une erreur de <code>Comparing values of different or unsupported types</code> est renvoyée. </td></tr><tr><td>  Cast to string </td><td>  Les nombres et les chaînes sont donnés comme en JavaScript.  Les objets sont répertoriés sous la forme d'une liste de valeurs séparées par des virgules dans l'ordre des clés.  <code>false</code> et <code>null</code> sont castés comme <code>""</code> , <code>true</code> casté comme <code>"1"</code> . </td></tr><tr><td>  Diffuser vers </td><td>  Si l'argument est une chaîne qui est une notation numérique valide, le nombre est renvoyé.  Sinon, une erreur <code>Numeric arguments expected</code> est renvoyée. </td></tr></tbody></table></div><br><p>  Pour les opérations avec des nombres (sauf pour les bits), si les opérandes sont <code>int</code> et <code>double</code> , <code>int</code> est <code>double</code> en <code>double</code> .  Si les deux opérandes sont <code>int</code> , une opération est effectuée sur des entiers 32 bits signés (avec débordement). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464099/">https://habr.com/ru/post/fr464099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464089/index.html">Automatiser les requêtes HTTP dans le contexte de Spring</a></li>
<li><a href="../fr464091/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 311 (du 12 au 18 août)</a></li>
<li><a href="../fr464093/index.html">Produits numériques: que faire si un client vient chercher un achat dans un an?</a></li>
<li><a href="../fr464095/index.html">Getters et Setters à Dart et Flutter</a></li>
<li><a href="../fr464097/index.html">L'évolution de l'intelligence: pourquoi les robots ont besoin d'émotions</a></li>
<li><a href="../fr464103/index.html">Projet de norme nationale IoT OpenUNB: examen critique</a></li>
<li><a href="../fr464105/index.html">Serveur natif Commento avec Docker Compose</a></li>
<li><a href="../fr464107/index.html">Événements numériques à Moscou du 19 au 25 août</a></li>
<li><a href="../fr464109/index.html">Parachutes supersoniques spatiaux</a></li>
<li><a href="../fr464111/index.html">Natas Web. Passage de la plateforme CTF visant à exploiter les vulnérabilités du Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>