<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👑 🤰🏻 🐆 Redis Scaling dan Failover untuk Layanan DirectumRX 👿 🐗 👨‍👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis adalah sistem manajemen basis data kelas NoSQL (DBMS non-relasional) yang ditempatkan seluruhnya dalam RAM. Untuk mengakses data, model "kunci" ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis Scaling dan Failover untuk Layanan DirectumRX</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/469543/">  Redis adalah sistem manajemen basis data kelas NoSQL (DBMS non-relasional) yang ditempatkan seluruhnya dalam RAM.  Untuk mengakses data, model "kunci" - "nilai" digunakan.  DBMS seperti itu sering digunakan untuk menyimpan cache dalam layanan yang skalabel, untuk menyimpan gambar dan data kecil. <br><br>  Redis DBMS banyak digunakan karena: <br><br><ul><li>  kecepatan tinggi, karena  semua data disimpan dalam RAM; </li><li>  lintas platform; </li><li>  distribusi di bawah lisensi BSD (berlaku untuk perangkat lunak open source). </li></ul><br>  Luasnya distribusi dan penerapan Redis dapat diperkirakan dengan sejumlah besar dokumentasi dengan semua jenis kasus di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi proyek</a> . <br><br>  Jika Anda menggunakan penskalaan horizontal layanan DirectumRX, Anda harus menggunakan instalasi Redis fail-safe untuk bekerja dengan benar dengan layanan penyimpanan DirectumRX dan layanan akses web DirectumRX. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/740/12b/060/74012b060e74628af35c33d4fa96b3bb.jpg" alt="gambar"><br><br>  Redis akan menyimpan data operasional, cache, dan informasi lain yang diperlukan untuk pengoperasian layanan dalam mode penskalaan sehingga proses interaksi pengguna dengan sistem tidak bergantung pada instalasi yang sedang digunakannya. <br><br>  Redis tidak akan menyimpan data sensitif dan tidak akan berada di bawah beban berat.  Tetapi jika terjadi kegagalan Redis, pengguna akan mengalami banyak kesalahan saat beralih antar instalasi. <br><br>  Di situs web resmi Redis, ada 2 cara untuk memastikan penskalaan horizontal dan toleransi kesalahan: <br><br><ol><li>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redis Sentiel</a> . </li><li>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redis Cluster</a> . </li></ol><br>  Pertimbangkan untuk menyesuaikan opsi ini. <br><br><h2>  Konfigurasikan Redis Sentiel </h2><br>  Opsi menggunakan Redis Sentiel (Redis Tracking Node) diimplementasikan dalam Redis 2.4 dan terdiri dalam menggunakan layanan Redis Sentiel tambahan untuk memantau ketersediaan wizard.  Dia juga melakukan konfigurasi node replika jika terjadi kegagalan wizard.  Menentukan node SLAVE mana yang akan menjadi MASTER dan melakukan konfigurasi ulang saat bepergian. <br><br>  Menerapkan skema klasik: <br><br><img width="467" src="https://habrastorage.org/getpro/habr/post_images/093/10e/efb/09310eefbd3eb3c05d23b9e227bb5d7a.jpg" alt="gambar"><br><br>  Mungkin ada banyak node SLAVE (hingga 1000 menurut situs resmi), untuk pekerjaan produktif disarankan untuk menggunakan setidaknya dua node SLAVE. <br><br>  Biasanya, skema dikonfigurasi sedemikian rupa sehingga layanan Redis Sentiel dikonfigurasi pada node MASTER dan SLAVE, dan jika simpul MASTER gagal, node pemantauan yang tersisa memutuskan untuk memperkenalkan MASTER baru. <br><br>  Versi Redis saat ini tersedia untuk diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi pengembang produk</a> .  Namun, situs distribusi hanya tersedia untuk Linux.  Pada suatu waktu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> Microsoft untuk porting Redis ke Windows sedang berkembang, tetapi saat ini proyek menghentikan pengembangan pada versi 3.2.100, jadi dalam artikel ini kami akan mempertimbangkan opsi penyebaran yang paling relevan - di Linux. <br><br>  Sebagai node uji, kita akan menggunakan dua host virtual redis1 dan redis2 dengan distribusi Linux yang diinstal dari Debian 10. <br><br>  Pertama, perbarui daftar paket dari repositori default dan instal Redis: <br><br><pre><code class="bash hljs">apt-get update &amp;&amp; apt-get upgrade apt install redis-server</code> </pre> <br>  Periksa versinya: <br><br><pre> <code class="bash hljs">root@redis1:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-server -v Redis server v=5.0.3 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=afa0decbb6de285f</span></span></code> </pre> <br>  Biarkan redis1 bertindak sebagai simpul MASTER dan redis2 bertindak sebagai simpul SLAVE. <br><br>  Untuk melakukan ini, kami menulis dalam konfigurasi Redis file parameter yang diperlukan yang akan memungkinkan Anda untuk membuat replika (belum toleran terhadap kesalahan). <br><br>  Untuk redis1 di file konfigurasi /etc/redis/redis.conf, tentukan: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,   MASTER     . requirepass TestPass</span></span></code> </pre> <br>  Untuk redis2 di file konfigurasi /etc/redis/redis.conf, tentukan: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   MASTER  . slaveof redis1 6379 #      . masterauth TestPass #   ,         . requirepass TestPass</span></span></code> </pre> <br>  Mulai ulang layanan redis-server di kedua node: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis1:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service.</span></span></code> </pre> <br>  Kami memeriksa pada sisi MASTER bahwa node menjadi replika dan menerima peran yang diperlukan: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:1 slave0:ip=192.168.9.96,port=6379,state=online,offset=28,lag=0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:28 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:28</span></span></code> </pre> <br>  Di sisi BUDAK, kami melihat situasi yang sama: <br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:redis1 master_port:6379 master_link_status:up master_last_io_seconds_ago:4 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14</span></span></code> </pre> <br>  Sekarang Anda perlu mengkonfigurasi replika sehingga secara otomatis dikembalikan jika salah satu node gagal.  Untuk melakukan ini, kita memerlukan layanan pelacakan Redis Sentinel. <br><br>  Berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , layanan pemantauan Redis Sentinel dapat melakukan operasi berikut: <br><br><ol><li>  Memeriksa ketersediaan node MASTER dan SLAVE dan dapat mengirim peringatan tentang tidak dapat diaksesnya node. </li><li>  Jika simpul MASTER gagal, simpul saksi dapat menempatkan simpul SLAVE dalam mode MASTER, serta mengkonfigurasi ulang simpul-simpul SLAVE yang tersisa, dan mereka mulai bekerja dengan MASTER yang baru. </li><li>  Membuat perubahan pada file konfigurasi dari MASTER dan SLAVE node. </li></ol><br>  Untuk kemurnian percobaan, kami akan menempatkan layanan saksi pada VM redis3 terpisah. <br><br>  Kami menghubungkan repositori Redis dengan cara yang sama dan menginstal paket redis-sentinel: <br><br><pre> <code class="bash hljs">apt install redis-sentinel</code> </pre> <br>  Setelah instalasi, Anda perlu membuat pengaturan dalam file konfigurasi dari node pemantauan /etc/redis/sentinel.conf: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    redis1   6379. #   1 -      , #        MASTER-. #       , #     MASTER-. sentinel monitor master01 redis1 6379 1 #  3 ,       . sentinel down-after-milliseconds master01 3000 #    MASTER- sentinel failover-timeout master01 6000 # ,  SLAVE-   . #    ,    , #      . sentinel parallel-syncs master01 1 #    . bind 192.168.9.97 127.0.0.1 ::1 #    MASTER-. sentinel auth-pass master01 TestPass</span></span></code> </pre><br>  Mulai ulang layanan setelah melakukan pengaturan: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-sentinel restart [ ok ] Restarting redis-sentinel (via systemctl): redis-sentinel.service.</span></span></code> </pre> <br>  Pastikan layanan pelacakan melihat MASTER dan SLAVE: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Kami memulai eksperimen. <br><br>  Kami mensimulasikan kegagalan, menghentikan layanan redis-server pada redis1 node dan mendapatkan informasi terkini dari node saksi: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.96:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Kami melihat MASTER telah berubah. <br><br>  Kami akan mengembalikan operasi simpul redis1 dan memeriksa kondisinya: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:192.168.9.96 master_port:6379 master_link_status:up master_last_io_seconds_ago:1 master_sync_in_progress:0 slave_repl_offset:15977 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:15977 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:15977</span></span></code> </pre> <br>  Kita melihat bahwa simpul menerima peran SLAVE, dan simpul redis2 adalah simpul MASTER. <br><br>  Mensimulasikan kegagalan simpul redis2 dan memeriksa status simpul saksi: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Dan status simpul redis1: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:0 master_replid:6e9d67d6460815b925319c2bafb58bf2c435cffb master_replid2:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_repl_offset:33610 second_repl_offset:26483 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:33610</span></span></code> </pre> <br>  Hebat, mekanismenya bekerja.  Tetapi sekarang muncul pertanyaan bagaimana kami akan menghubungkan layanan DirectumRX kami, karena mereka membutuhkan alamat node tunggal.  Kami akan mengatasi situasi menggunakan layanan HAProxy. <br><br><h2>  Redis Node Proxying </h2><br>  Layanan proxy tcp dapat bertindak sebagai proxy terbalik untuk simpul Redis.  Pada artikel ini, kami akan mempertimbangkan penggunaan HAProxy, karena ini adalah alat khusus yang dirancang untuk memberikan ketersediaan dan penyeimbangan muatan yang tinggi, dan digunakan oleh layanan online yang dikenal secara universal.  Baca lebih lanjut tentang HAProxy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di halaman pengembang</a> . <br><br>  Instal HAProxy pada simpul redis3: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># apt install haproxy</span></span></code> </pre> <br>  Dalam file konfigurasi HAProxy /etc/haproxy/haproxy.cfg, tambahkan pengaturan untuk permintaan proxy ke node Redis: <br><br><pre> <code class="bash hljs">… frontend ft_redis <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> *:6379 name redis mode tcp default_backend bk_redis backend bk_redis mode tcp option tcp-check tcp-check connect <span class="hljs-comment"><span class="hljs-comment">#  ,         . tcp-check send AUTH\ TestPass\r\n tcp-check expect string +OK tcp-check send PING\r\n tcp-check expect string +PONG tcp-check send info\ replication\r\n #    MASTER, .. SLAVE      . tcp-check expect string role:master tcp-check send QUIT\r\n tcp-check expect string +OK server Redis1 redis1:6379 check inter 3s server Redis2 redis2:6379 check inter 3s</span></span></code> </pre><br>  Dalam konfigurasi ini, diindikasikan bahwa kami akan mem-proxy setiap permintaan yang datang ke semua antarmuka mesin virtual saat ini di alamat pada port 6379. Kami akan mentransfer permintaan ke node yang akan menjawab bahwa ia memiliki peran MASTER. <br><br>  Mulai ulang layanan haproxy: <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/haproxy restart</span></span></code> </pre> <br>  Mari kita coba sambung menggunakan klien redis-cli dan buat kunci uji: <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 6379 -a TestPass Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. 127.0.0.1:6379&gt; SET TestKey "Some test string" OK 127.0.0.1:6379&gt; GET TestKey "Some test string" 127.0.0.1:6379&gt; info keyspace # Keyspace db0:keys=1,expires=0,avg_ttl=0</span></span></code> </pre> <br>  Hentikan redis1 node dan kueri lagi daftar kunci: <br><br><pre> <code class="bash hljs">127.0.0.1:6379&gt; info keyspace Error: Server closed the connection (3.01s) 127.0.0.1:6379&gt; info keyspace <span class="hljs-comment"><span class="hljs-comment"># Keyspace db0:keys=1,expires=0,avg_ttl=0 (2.01s) 127.0.0.1:6379&gt; GET TestKey "Some test string"</span></span></code> </pre><br>  Kita melihat bahwa untuk beberapa waktu koneksi terputus, tetapi kemudian koneksi dipulihkan kembali dan semua data tetap di tempatnya. <br><br>  Sekarang cukup untuk mendaftarkan alamat proxy terbalik di file konfigurasi layanan DirectumRX untuk terhubung ke Redis. <br><br><h2>  Konfigurasikan Redis Cluster </h2><br>  Opsi pengelompokan Redis Cluster, diimplementasikan untuk versi redis 3.0 dan lebih tinggi, adalah solusi untuk membuat dan mengelola sebuah cluster dengan segmentasi dan replikasi data.  Melakukan tugas-tugas manajemen simpul, replikasi, sinkronisasi data pada node dan memastikan akses aplikasi klien ke simpul MASTER dalam hal kegagalan salah satu dari beberapa simpul MASTER. <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/86e/5c6/e56/86e5c6e56fe5541c36297e978c4c34d4.png" alt="gambar"><br><br>  Redis Cluster bekerja dalam mode multimaster, setiap node MASTER dapat memiliki satu atau lebih node SLAVE (hingga 1000). <br><br>  Penskalaan adalah fungsi utama gugus.  Selain itu, cluster dapat menjamin toleransi kesalahan dari layanan Redis: <br><br><ul><li>  jika beberapa node tidak berfungsi, cluster mendistribusikan kembali beban dari mereka ke node lain; </li><li>  jika node kunci tidak berfungsi, maka seluruh cluster berakhir. </li></ul><br>  Situasi mungkin muncul ketika Klien 2 menulis ke simpul M2.  M2 menjawab "OK" dan mencoba menulis ke S2.  Pada saat yang sama, M2 tidak menunggu penyelesaian pertukaran data yang benar dengan S2, tetapi segera menanggapi klien.  Dalam hal ini, replika S2 mungkin tidak memiliki semua data.  Oleh karena itu, disarankan untuk menggunakan beberapa replika SLAVE. <br><br>  Situasi juga dapat muncul ketika M1, M3 berhenti untuk "melihat" M2, dan klien masih terus menulis data ke M2.  Jika ketidaktersediaan akan berlanjut untuk beberapa waktu (parameter cluster-node-timeout), maka dalam hal ini S2 akan dimasukkan ke mode MASTER, dan M2 akan berhenti bekerja sendiri. <br><br>  Dokumentasi resmi merekomendasikan menggunakan 6 node - satu instance Redis per node, yang memungkinkan keandalan yang lebih besar, tetapi tidak ada yang melarang menggunakan tiga node dengan topologi koneksi berikut: <br><br><img width="573" src="https://habrastorage.org/getpro/habr/post_images/3c1/56a/860/3c156a860e5728015e9631b3bb5854a1.jpg" alt="gambar"><br><br>  Jika salah satu node fisik gagal, replika SLAVE yang sesuai akan masuk ke mode MASTER, dan operasi tidak akan terganggu. <br><br>  Kami menerapkan 3 mesin virtual (redis1, redis2 dan redis3) di bangku tes, yang masing-masing akan menjalankan 2 instance Redis. <br><br>  Aplikasi klien akan terhubung ke port tertentu yang ditentukan dalam file konfigurasi klien, oleh karena itu, pasangan MASTER - SLAVE harus bekerja pada port yang sama. <br><br>  Untuk pasangan M1 - S1 kita akan menggunakan port 6381 <br>  Untuk pasangan M2 - S2 kita akan menggunakan port 6382 <br>  Untuk pasangan M3 - S3 kita akan menggunakan port 6383 <br><br>  Siapkan file konfigurasi <br><br>  Di redis1: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m1_redis.conf cp /etc/redis/redis.conf /etc/redis/s2_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  Di redis2: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m2_redis.conf cp /etc/redis/redis.conf /etc/redis/s3_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  Pada redis3: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m3_redis.conf cp /etc/redis/redis.conf /etc/redis/s1_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  Isi file konfigurasi sesuai dengan templat: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> &lt;IP- &gt; protected-mode no <span class="hljs-comment"><span class="hljs-comment">#      ,    . port &lt;&gt; pidfile /var/run/redis_&lt;&gt;.pid # &lt;yes/no&gt; -   Redis Cluster cluster-enabled yes # ,      : #  ,  ,    . #         . cluster-config-file nodes-&lt;&gt;.conf #  ,  master-   , #          slaves #    . cluster-node-timeout 15000</span></span></code> </pre> <br>  Mari kita meluncurkan node Redis: <br><br>  Node redis1: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m1_redis.conf root@redis1:/etc/redis# redis-server /etc/redis/s2_redis.conf</span></span></code> </pre> <br>  Redis2 simpul: <br><br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m2_redis.conf root@redis2:/etc/redis# redis-server /etc/redis/s3_redis.conf</span></span></code> </pre> <br>  Redis3 simpul: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m3_redis.conf root@redis3:/etc/redis# redis-server /etc/redis/s1_redis.conf</span></span></code> </pre> <br>  Untuk mengkonfigurasi cluster, Anda perlu menggunakan utilitas klien redis-cli, memberikannya daftar ip: port pasang server yang akan memainkan peran MASTER dan SLAVE: <br><br><pre> <code class="bash hljs">redis-cli --cluster create redis1-ip:6381 redis2-ip:6382 redis3-ip:6383 redis1-ip:6382 redis2-ip:6383 redis3-ip:6381 --cluster-replicas 1</code> </pre> <br>  , di mana opsi --cluster-replicas 1 memberi tahu Anda berapa banyak SLAVE yang akan dimiliki masing-masing master, dan mereka secara otomatis dipilih dari daftar replika yang ditransfer. <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli --cluster create 192.168.9.51:6381 192.168.9.52:6382 192.168.9.53:6383 192.168.9.51:6382 192.168.9.52:6383 192.168.9.53:6381 --cluster-replicas 1 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 192.168.9.52:6383 to 192.168.9.51:6381 Adding replica 192.168.9.51:6382 to 192.168.9.52:6382 Adding replica 192.168.9.53:6381 to 192.168.9.53:6383 &gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity [OK] Perfect anti-affinity obtained! M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 replicates 3a41475e1613519c3ecdec695736a898262a24a5 S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 replicates e92cb96fd6c20db7509662a248902e3751ebe95f Can I set the above configuration? (type 'yes' to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join ..... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.9.51:6381) M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master 1 additional replica(s) M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 slots: (0 slots) slave replicates e92cb96fd6c20db7509662a248902e3751ebe95f S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 slots: (0 slots) slave replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 slots: (0 slots) slave replicates 3a41475e1613519c3ecdec695736a898262a24a5 M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered.</span></span></code> </pre> <br>  Cluster dibangun dengan benar.  Kami akan menampilkan informasi tentang klaster: <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:1 cluster_stats_messages_ping_sent:1254 cluster_stats_messages_pong_sent:1243 cluster_stats_messages_sent:2497 cluster_stats_messages_ping_received:1238 cluster_stats_messages_pong_received:1254 cluster_stats_messages_meet_received:5 cluster_stats_messages_received:2497 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Untuk menguji replika tertentu, seperti Redis Sentiel, Anda dapat menggunakan perintah replikasi INFO: <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; INFO replication # Replication role:master connected_slaves:1 slave0:ip=192.168.9.53,port=6381,state=online,offset=1946,lag=0 master_replid:59cd95d394dad9d0e49042637fdfd5290db4abfe master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1946 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1946 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Mari kita coba membuat beberapa kunci dan memverifikasi bahwa kunci-kunci ini muncul di replika: <br><br><pre> <code class="bash hljs">192.168.9.51:6381&gt; SET key1 test1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 OK 192.168.9.52:6382&gt; SET key2 test2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 OK 192.168.9.51:6381&gt; SET key3 test3 OK 192.168.9.51:6381&gt;</code> </pre> <br>  Periksa M2: <br><br><pre> <code class="bash hljs">root@redis2:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.52 -p 6382 192.168.9.52:6382&gt; GET key1 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Dan di M3: <br><br><pre> <code class="bash hljs">root@redis3:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.53 -p 6383 192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Kami akan menonaktifkan redis1 node dan memeriksa cara kerja S1: <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; CLUSTER NODES &lt;b&gt;182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave,fail d499af3672b3063c7239572ec311ad3160f280ae 1569509904727 1569509900000 4 connected&lt;/b&gt; 485ffb786e9763955e6f10ffc59247690ad9bc11 &lt;i&gt;192.168.9.53:6381@16381 master&lt;/i&gt; - 0 1569510017272 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569510018274 5 connected &lt;b&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 master,fail - 1569509906731 1569509901721 1 connected&lt;/b&gt; 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569510019275 3 connected 10923-16383 d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 myself,master - 0 1569510017000 2 connected 5461-10922</code> </pre> <br>  Kami melihat informasi tentang kegagalan M1 dan S2 dan S3 telah beralih ke mode MASTER. <br><br>  Periksa di mana kunci disimpan: <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; GET key1 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6381&gt; GET key3 <span class="hljs-string"><span class="hljs-string">"test3"</span></span> 192.168.9.53:6381&gt;</code> </pre><br>  Kunci yang sebelumnya disimpan di redis1 sekarang tersedia di redis3. <br><br>  Kembalikan operasi simpul redis1 dan periksa keadaan simpul M1 dan S2: <br><br><pre> <code class="bash hljs">192.168.9.53:6381&gt; CLUSTER NODES &lt;i&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 slave 485ffb786e9763955e6f10ffc59247690ad9bc11 0 1569511658217 7 connected 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave d499af3672b3063c7239572ec311ad3160f280ae 0 1569511657000 4 connected&lt;/i&gt; d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 master - 0 1569511656000 2 connected 5461-10922 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569511656000 3 connected 10923-16383 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381@16381 myself,master - 0 1569511656000 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569511657216 5 connected</code> </pre> <br>  Kesehatan M1 dan S2 telah pulih, tetapi sekarang M1 dalam mode SLAVE. <br><br>  Dan kuncinya juga pada simpul redis3: <br><br><pre> <code class="bash hljs">192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6383&gt; GET key3 -&gt; Redirected to slot [935] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test3"</span></span></code> </pre> <br>  Cluster dikonfigurasi dan pemulihan Redis diuji. <br><br>  Untuk mengakses layanan DirectumRX, Anda juga perlu mengonfigurasi proksi terbalik, seperti dalam hal mengatur Redis Sentiel. <br><br><h2>  Alih-alih sebuah kesimpulan </h2><br>  Artikel ini tidak mempertimbangkan cara lain untuk meningkatkan toleransi kesalahan Redis - menggunakan manajer sumber daya gugus pihak ketiga, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pacemaker</a> .  Dalam hal ini, akan dimungkinkan untuk bertahan dengan dua node, namun, ada kemungkinan besar kehilangan data jika terjadi keadaan darurat. <br><br>  Untuk proksi terbalik (dalam hal ini, HAProxy), juga diinginkan untuk memberikan toleransi kesalahan, tetapi masalah ini juga di luar cakupan artikel ini.  Jika Anda tertarik dengan topik ini, opsi penyebaran ini juga dapat dipertimbangkan dalam artikel terpisah dengan penyetelan langkah-demi-langkah dan menguji hasilnya. <br><br>  Anda dapat menemukan tautan di bawah ini untuk mengetahui lebih lanjut tentang topik ini: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redis cluster tutorial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Redis Sentinel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manual Konfigurasi HAProxy</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469543/">https://habr.com/ru/post/id469543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469529/index.html">Render teks membenci Anda</a></li>
<li><a href="../id469531/index.html">“Membandingkan bahasa pemrograman dengan basis yang lebih baik-lebih buruk adalah pekerjaan yang benar-benar bodoh.”</a></li>
<li><a href="../id469533/index.html">Masalah dan ancaman identifikasi biometrik</a></li>
<li><a href="../id469537/index.html">Mengenal Swift dengan Snake</a></li>
<li><a href="../id469541/index.html">Perakitan dan penyebaran layanan microser yang sama dengan werf dan GitLab CI</a></li>
<li><a href="../id469545/index.html">Apa yang Baru di Linux kernel 5.3 - Driver Grafik, Virtualisasi, dan Modifikasi di Subsistem Jaringan</a></li>
<li><a href="../id469549/index.html">Bagaimana kami melakukan tarif untuk Windows VPS untuk 99 rubel</a></li>
<li><a href="../id469551/index.html">VDS dengan kartu video - kami tahu banyak tentang penyimpangan</a></li>
<li><a href="../id469555/index.html">Siaran: Pertemuan Kubernet Moskow # 6</a></li>
<li><a href="../id469557/index.html">Generic Recycler Lihat atau bagaimana tidak menulis kode boilerplate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>