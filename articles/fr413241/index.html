<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëò üôãüèΩ ‚úçüèø Interception de fonctions dans le noyau Linux √† l'aide de ftrace üìü ‚òîÔ∏è üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un projet li√© √† la s√©curit√© des syst√®mes Linux, nous devions intercepter les appels √† des fonctions importantes √† l'int√©rieur du noyau (telles qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interception de fonctions dans le noyau Linux √† l'aide de ftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="Pingouin Ninja, En3l" align="right" width="40%"></a>  Dans un projet li√© √† la s√©curit√© des syst√®mes Linux, nous devions intercepter les appels √† des fonctions importantes √† l'int√©rieur du noyau (telles que l'ouverture de fichiers et l'ex√©cution de processus) pour permettre de surveiller l'activit√© dans le syst√®me et bloquer pr√©ventivement l'activit√© des processus suspects. <br><br>  Au cours du processus de d√©veloppement, nous avons r√©ussi √† inventer une assez bonne approche, qui nous permet d'intercepter facilement toute fonction du noyau par son nom et d'ex√©cuter notre code autour de ses appels.  L'intercepteur peut √™tre install√© √† partir d'un module GPL chargeable, sans reconstruire le noyau.  L'approche prend en charge les noyaux version 3.19+ pour l'architecture x86_64. <br><a name="habracut"></a><br>  <font color="gray">(Image de pingouin juste au-dessus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬© En3l avec DeviantArt</a> .)</font> <br><br><h2>  Approches connues </h2><br><h3>  API de s√©curit√© Linux </h3><br>  Le plus correct serait d'utiliser l' <em>API de s√©curit√© Linux</em> - une interface sp√©ciale cr√©√©e sp√©cifiquement √† ces fins.  Dans les endroits critiques du code du noyau, les appels aux fonctions de s√©curit√© sont localis√©s, ce qui, √† son tour, appelle les rappels d√©finis par le module de s√©curit√©.  Le module de s√©curit√© peut examiner le contexte d'une op√©ration et d√©cider si elle est autoris√©e ou refus√©e. <br><br>  Malheureusement, l'API de s√©curit√© Linux pr√©sente quelques limitations importantes: <br><br><ul><li>  les modules de s√©curit√© ne peuvent pas √™tre charg√©s dynamiquement, font partie du noyau et n√©cessitent une reconstruction </li><li>  il ne peut y avoir qu'un seul module de s√©curit√© dans le syst√®me (√† quelques exceptions pr√®s) </li></ul><br>  Si la position des d√©veloppeurs du noyau est ambigu√´ quant √† la multiplicit√© des modules, alors l'interdiction du chargement dynamique est fondamentale: le module de s√©curit√© doit faire partie du noyau pour assurer une s√©curit√© constante, d√®s le chargement. <br><br>  Ainsi, pour utiliser l'API de s√©curit√©, vous devez fournir votre propre assemblage de noyau, ainsi qu'int√©grer le module compl√©mentaire avec SELinux ou AppArmor, qui sont utilis√©s par les distributions populaires.  Le client ne souhaitant pas souscrire √† de telles obligations, cet itin√©raire a donc √©t√© ferm√©. <br><br>  Pour ces raisons, l'API de s√©curit√© ne nous convenait pas, sinon ce serait une option id√©ale. <br><br><h3>  Modification de la table d'appels syst√®me </h3><br>  La surveillance √©tait n√©cessaire principalement pour les actions effectu√©es par les applications utilisateur, de sorte qu'elle pouvait en principe √™tre mise en ≈ìuvre au niveau des appels syst√®me.  Comme vous le savez, Linux stocke tous les gestionnaires d'appels syst√®me dans la table <code>sys_call_table</code> .  La substitution de valeurs dans ce tableau entra√Æne une modification du comportement de l'ensemble du syst√®me.  Ainsi, en conservant les anciennes valeurs du gestionnaire et en substituant notre propre gestionnaire dans la table, nous pouvons intercepter tout appel syst√®me. <br><br>  Cette approche pr√©sente certains avantages: <br><br><ul><li>  <strong>Contr√¥le total sur tous les appels syst√®me</strong> - la seule interface vers le noyau pour les applications utilisateur.  En l'utilisant, nous pouvons √™tre s√ªrs que nous ne manquerons aucune action importante effectu√©e par le processus utilisateur. <br></li><li>  <strong>Frais g√©n√©raux minimaux.</strong>  Il y a un investissement en capital unique lors de la mise √† jour de la table d'appels syst√®me.  Outre l'in√©vitable surveillance de la charge utile, la seule d√©pense est un appel de fonction suppl√©mentaire (pour appeler le gestionnaire d'appels syst√®me d'origine). <br></li><li>  <strong>Configuration minimale du noyau.</strong>  Si vous le souhaitez, cette approche ne n√©cessite aucune option de configuration suppl√©mentaire dans le noyau, donc en th√©orie, elle prend en charge la gamme de syst√®mes la plus large possible. <br></li></ul><br>  Cependant, il souffre √©galement de quelques d√©fauts: <br><br><ul><li>  <strong>La complexit√© technique de la mise en ≈ìuvre.</strong>  En soi, le remplacement des pointeurs dans une table n'est pas difficile.  Mais les t√¢ches connexes n√©cessitent des solutions non √©videntes et une certaine qualification: <br><ul><li>  table d'appel syst√®me de recherche </li><li>  bypass de protection de modification de table </li><li>  remplacement atomique et s√ªr </li></ul><br>  Ce sont toutes des choses int√©ressantes, mais elles n√©cessitent un temps de d√©veloppement pr√©cieux, d'abord pour la mise en ≈ìuvre, puis pour le support et la compr√©hension. <br></li><li>  <strong>Impossibilit√© d'intercepter certains gestionnaires.</strong>  Dans les noyaux ant√©rieurs √† la version 4.16, la gestion des appels syst√®me pour l'architecture x86_64 contenait un certain nombre d'optimisations.  Certains d'entre eux ont exig√© que le gestionnaire d'appels syst√®me soit un adaptateur sp√©cial impl√©ment√© dans l'assembleur.  En cons√©quence, de tels gestionnaires sont parfois difficiles, et parfois m√™me impossibles √† remplacer par les v√¥tres, √©crits en C.  De plus, diff√©rentes optimisations sont utilis√©es dans diff√©rentes versions du noyau, ce qui ajoute aux difficult√©s techniques de la tirelire. <br></li><li>  <strong>Seuls les appels syst√®me sont intercept√©s.</strong>  Cette approche vous permet de remplacer les gestionnaires d'appels syst√®me, ce qui limite les points d'entr√©e √† eux uniquement.  Toutes les v√©rifications suppl√©mentaires sont effectu√©es au d√©but ou √† la fin, et nous n'avons que les arguments de l'appel syst√®me et sa valeur de retour.  Parfois, cela conduit √† la n√©cessit√© de dupliquer les contr√¥les de l'ad√©quation des arguments et des contr√¥les d'acc√®s.  Parfois, cela entra√Æne une surcharge inutile lorsque vous devez copier la m√©moire du processus utilisateur deux fois: si l'argument est pass√© par un pointeur, nous devons d'abord le copier nous-m√™mes, puis le gestionnaire d'origine copiera √† nouveau l'argument pour lui-m√™me.  De plus, dans certains cas, les appels syst√®me fournissent une granularit√© trop faible des √©v√©nements qui doivent en outre √™tre filtr√©s du bruit. <br></li></ul><br>  Au d√©part, nous avons choisi et mis en ≈ìuvre avec succ√®s cette approche, poursuivant les avantages de la prise en charge du plus grand nombre de syst√®mes.  Cependant, √† cette √©poque, nous ne connaissions toujours pas les fonctionnalit√©s de x86_64 et les restrictions sur les appels intercept√©s.  Plus tard, il s'est av√©r√© essentiel pour nous de prendre en charge les appels syst√®me li√©s au d√©marrage de nouveaux processus - clone () et execve () - qui sont tout simplement sp√©ciaux.  C'est ce qui nous a conduit √† rechercher de nouvelles options. <br><br><h3>  Utilisation de kprobes </h3><br>  L'une des options envisag√©es √©tait l'utilisation de <em>kprobes</em> : une API sp√©cialis√©e principalement con√ßue pour le d√©bogage et le tra√ßage du noyau.  Cette interface vous permet de d√©finir des pr√©-et post-gestionnaires pour <em>toute instruction</em> dans le noyau, ainsi que des gestionnaires pour entrer et revenir d'une fonction.  Les gestionnaires ont acc√®s aux registres et peuvent les modifier.  Ainsi, nous pourrions obtenir √† la fois une surveillance et la capacit√© d'influencer la suite des travaux. <br><br>  Avantages de l'utilisation de kprobes pour intercepter: <br><br><ul><li>  <strong>API mature.</strong>  Les kprobes existent et se sont am√©lior√©s depuis des temps imm√©moriaux (2002).  Ils ont une interface bien document√©e, la plupart des √©cueils ont d√©j√† √©t√© trouv√©s, leur travail a √©t√© optimis√© autant que possible, etc.  En g√©n√©ral, toute une montagne d'avantages par rapport aux v√©los auto-fabriqu√©s exp√©rimentaux. <br></li><li>  <strong>Interception de n'importe quel endroit dans le noyau.</strong>  Les kprobes sont impl√©ment√©es √† l'aide de points d'arr√™t (instructions int3) int√©gr√©s dans le code ex√©cutable du noyau.  Cela vous permet d'installer kprobes litt√©ralement n'importe o√π dans n'importe quelle fonction, si elle est connue.  De m√™me, les kretprobes sont impl√©ment√©es en usurpant l'adresse de retour sur la pile et vous permettent d'intercepter le retour de n'importe quelle fonction (√† l'exception de celles qui en principe ne renvoient pas le contr√¥le). <br></li></ul><br>  Inconv√©nients des kprobes: <br><br><ul><li>  <strong>Difficult√© technique.</strong>  Kprobes est juste un moyen de d√©finir un point d'arr√™t n'importe o√π dans le noyau.  Pour obtenir les arguments d'une fonction ou les valeurs des variables locales, vous devez savoir dans quels registres ou o√π sur la pile ils se trouvent, et les extraire ind√©pendamment de l√†.  Pour bloquer un appel de fonction, vous devez modifier manuellement l'√©tat du processus afin que le processeur pense qu'il a d√©j√† renvoy√© le contr√¥le de la fonction. <br></li><li>  <strong>Les Jprobes sont obsol√®tes.</strong>  Jprobes est un module compl√©mentaire pour kprobes qui vous permet d'intercepter facilement les appels de fonction.  Il extraira ind√©pendamment les arguments de la fonction des registres ou de la pile et appellera votre gestionnaire, qui devrait avoir la m√™me signature que la fonction hook√©e.  Le hic, c'est que les jprobes sont obsol√®tes et coup√©s dans les noyaux modernes. <br></li><li>  <strong>Frais g√©n√©raux non triviaux.</strong>  Les points d'arr√™t sont chers, mais ponctuels.  Les points d'arr√™t n'affectent pas les autres fonctions, mais leur traitement est relativement co√ªteux.  Heureusement, l'optimisation des sauts est impl√©ment√©e pour l'architecture x86_64, ce qui r√©duit consid√©rablement le co√ªt des kprobes, mais elle reste plus que, par exemple, lors de la modification de la table d'appels syst√®me. <br></li><li>  <strong>Limitations des kretprobes.</strong>  Les kretprobes sont impl√©ment√©es en usurpant l'adresse de retour sur la pile.  En cons√©quence, ils doivent stocker l'adresse d'origine quelque part afin de pouvoir y revenir apr√®s le traitement de kretprobe.  Les adresses sont stock√©es dans un tampon de taille fixe.  En cas de d√©passement, lorsque trop d'appels simultan√©s de la fonction intercept√©e sont ex√©cut√©s dans le syst√®me, kretprobes sautera les op√©rations. <br></li><li>  <strong>Extrusion d√©sactiv√©e.</strong>  Puisque kprobes est bas√© sur des interruptions et jongle avec les registres du processeur, pour la synchronisation, tous les gestionnaires sont ex√©cut√©s avec pr√©emption d√©sactiv√©e.  Cela impose certaines restrictions aux gestionnaires: vous ne pouvez pas attendre dedans - allouer beaucoup de m√©moire, faire des E / S, dormir dans des temporisateurs et des s√©maphores, et d'autres choses connues. <br></li></ul><br>  Dans le processus de recherche sur le sujet, nos yeux sont tomb√©s sur le framework <strong>ftrace</strong> , qui peut remplacer les jprobes.  Il s'est av√©r√© que cela fonctionne mieux pour nos besoins d'interception d'appels de fonction.  Cependant, si vous devez suivre des instructions sp√©cifiques dans les fonctions, les kprobes ne doivent pas √™tre actualis√©s. <br><br><h3>  √âpissage </h3><br>  Par souci d'exhaustivit√©, il convient √©galement de d√©crire la m√©thode classique d'interception de fonctions, qui consiste √† remplacer les instructions au d√©but de la fonction par une transition inconditionnelle conduisant √† notre gestionnaire.  Les instructions d'origine sont transf√©r√©es √† un autre endroit et ex√©cut√©es avant de revenir √† la fonction intercept√©e.  √Ä l'aide de deux transitions, nous int√©grons (√©pissons) notre code suppl√©mentaire dans la fonction, par cons√©quent, cette approche est appel√©e <em>√©pissage</em> . <br><br>  C'est ainsi que l'optimisation des sauts pour kprobes est impl√©ment√©e.  En utilisant l'√©pissage, vous pouvez obtenir les m√™mes r√©sultats, mais sans co√ªts suppl√©mentaires pour les kprobes et avec un contr√¥le complet de la situation. <br><br>  Les avantages de l'√©pissage sont √©vidents: <br><br><ul><li>  <strong>Configuration minimale du noyau.</strong>  L'√©pissage ne n√©cessite aucune option sp√©ciale dans le noyau et fonctionne au d√©but de toute fonction.  Vous avez juste besoin de conna√Ætre son adresse. <br></li><li>  <strong>Frais g√©n√©raux minimaux.</strong>  Deux transitions inconditionnelles - c'est toutes les actions que le code intercept√© doit effectuer pour transf√©rer le contr√¥le au gestionnaire et vice versa.  De telles transitions sont parfaitement pr√©dites par le processeur et sont tr√®s bon march√©. <br></li></ul><br>  Cependant, le principal inconv√©nient de cette approche obscurcit s√©rieusement l'image: <br><br><ul><li>  <strong>Difficult√© technique.</strong>  Elle se retourne.  Vous ne pouvez pas simplement prendre et r√©√©crire le code machine.  Voici une liste courte et incompl√®te des t√¢ches √† r√©soudre: <br><ul><li>  synchronisation de l'installation et suppression de l'interception (que faire si la fonction est appel√©e directement dans le processus de remplacement de ses instructions?) </li><li>  contournement de la protection lors de la modification des r√©gions m√©moire avec un code </li><li>  Invalidation du cache du processeur apr√®s le remplacement des instructions </li><li>  d√©montage des instructions rempla√ßables pour les copier en entier </li><li>  v√©rification de l'absence de transitions √† l'int√©rieur de la pi√®ce remplac√©e </li><li>  v√©rifier la possibilit√© de d√©placer la pi√®ce remplac√©e vers un autre emplacement </li></ul><br>  Oui, vous pouvez espionner les kprobes et utiliser le framework intranucl√©aire livepatch, mais la solution finale est encore assez compliqu√©e.  Il est effrayant d'imaginer le nombre de probl√®mes de sommeil dans chaque nouvelle impl√©mentation. <br></li></ul><br>  En g√©n√©ral, si vous √™tes capable d'appeler ce d√©mon, subordonn√© uniquement aux initi√©s, et que vous √™tes pr√™t √† le supporter dans votre code, l'√©pissage est une approche compl√®tement fonctionnelle pour intercepter les appels de fonction.  J'avais une attitude n√©gative √† l'√©gard de l'√©criture de v√©los, donc cette option est rest√©e une sauvegarde pour nous au cas o√π il n'y aurait aucun progr√®s avec des solutions toutes faites plus faciles. <br><br><h2>  Nouvelle approche avec ftrace </h2><br>  <strong>Ftrace</strong> est un framework de tra√ßage du noyau au niveau de la fonction.  Il a √©t√© d√©velopp√© depuis 2008 et poss√®de une interface fantastique pour les programmes utilisateur.  Ftrace vous permet de suivre la fr√©quence et la dur√©e des appels de fonction, d'afficher les graphiques des appels, de filtrer les fonctions d'int√©r√™t par mod√®le, etc.  Vous pouvez commencer √† lire sur les fonctionnalit√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> ftrace √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> , puis suivre les liens et la documentation officielle. <br><br>  Il impl√©mente ftrace bas√© sur les cl√©s de compilateur <code>-pg</code> et <code>-mfentry</code> , qui ins√®rent l'appel √† la fonction de trace sp√©ciale mcount () ou __fentry __ () au d√©but de chaque fonction.  En g√©n√©ral, dans les programmes utilisateur, cette fonction de compilation est utilis√©e par les profileurs pour suivre les appels √† toutes les fonctions.  Le noyau utilise ces fonctions pour impl√©menter le framework ftrace. <br><br>  Bien s√ªr, appeler ftrace √† partir de <em>chaque</em> fonction n'est pas bon march√©, donc l'optimisation est disponible pour les architectures populaires: <em>ftrace dynamique</em> .  L'essentiel est que le noyau connaisse l'emplacement de tous les appels √† mcount () ou __fentry __ () et dans les premi√®res √©tapes du chargement remplace leur code machine par <strong>nop</strong> - une instruction sp√©ciale qui ne fait rien.  Lorsque le tra√ßage est inclus dans les fonctions requises, les appels ftrace sont rajout√©s.  Ainsi, si ftrace n'est pas utilis√©, son impact sur le syst√®me est minime. <br><br><h3>  Description des fonctions requises </h3><br>  Chaque fonction intercept√©e peut √™tre d√©crite par la structure suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  L'utilisateur doit remplir uniquement les trois premiers champs: nom, fonction, original.  Les champs restants sont consid√©r√©s comme un d√©tail d'impl√©mentation.  La description de toutes les fonctions intercept√©es peut √™tre assembl√©e dans un tableau et des macros peuvent √™tre utilis√©es pour augmenter la compacit√© du code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br>  Les wrappers sur les fonctions intercept√©es sont les suivants: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   ‚Äî  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Comme vous pouvez le voir, les fonctions intercept√©es avec un minimum de code suppl√©mentaire.  La seule chose n√©cessitant une attention particuli√®re est la signature des fonctions.  Ils doivent correspondre un √† un.  Sans cela, √©videmment, les arguments seront mal pass√©s et tout ira en descendant.  Pour intercepter les appels syst√®me, cela est moins important, car leurs gestionnaires sont tr√®s stables et, pour plus d'efficacit√©, prennent les arguments dans le m√™me ordre que le syst√®me les appelle eux-m√™mes.  Cependant, si vous pr√©voyez d'intercepter d'autres fonctions, vous devez vous rappeler qu'il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'y a pas d'interfaces stables √† l'int√©rieur du noyau</a> . <br><br><h3>  Initialisation de Ftrace </h3><br>  Tout d'abord, nous devons trouver et enregistrer l'adresse de la fonction que nous allons intercepter.  Ftrace vous permet de tracer les fonctions par leur nom, mais nous avons encore besoin de conna√Ætre l'adresse de la fonction d'origine pour l'appeler. <br><br>  Vous pouvez obtenir l'adresse en utilisant <em>kallsymes</em> - une liste de tous les caract√®res du noyau.  Cette liste comprend <em>tous les</em> caract√®res, non seulement export√©s pour les modules.  Obtenir l'adresse de la fonction hook√©e ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Ensuite, vous devez initialiser la structure <code>ftrace_ops</code> .  C'est contraignant <br>  le champ est juste <em>func</em> , indiquant un rappel, mais nous avons aussi besoin <br>  d√©finir des indicateurs importants: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> () est notre rappel que ftrace appellera lors du tra√ßage d'une fonction.  √Ä propos de lui plus tard.  Les drapeaux que nous avons mis seront n√©cessaires pour terminer l'interception.  Ils demandent √† ftrace de sauvegarder et de restaurer les registres du processeur, dont nous pouvons changer le contenu lors du rappel. <br><br>  Nous sommes maintenant pr√™ts √† activer l'interception.  Pour ce faire, vous devez d'abord activer ftrace pour la fonction qui nous int√©resse en utilisant ftrace_set_filter_ip (), puis autoriser ftrace √† appeler notre rappel en utilisant register_ftrace_function (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  L'interception est d√©sactiv√©e de la m√™me mani√®re, uniquement dans l'ordre inverse: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br>  Une fois l'appel √† unregister_ftrace_function () termin√©, l'absence d'activation du rappel install√© dans le syst√®me (et avec lui nos wrappers) est garantie.  Par cons√©quent, nous pouvons, par exemple, d√©charger le module d'intercepteur en toute s√©curit√©, sans craindre que quelque part dans le syst√®me nos fonctions soient toujours ex√©cut√©es (car si elles disparaissent, le processeur sera boulevers√©). <br><br><h3>  Ex√©cution d'un hook de fonction </h3><br>  Comment l'interception est-elle r√©ellement r√©alis√©e?  Tr√®s simple.  Ftrace vous permet de changer l'√©tat des registres apr√®s avoir quitt√© un rappel.  En modifiant le registre% rip - un pointeur sur la prochaine instruction ex√©cutable - nous modifions les instructions que le processeur ex√©cute - c'est-√†-dire que nous pouvons le forcer √† ex√©cuter une transition inconditionnelle de la fonction actuelle vers la n√¥tre.  Ainsi nous prenons le contr√¥le. <br><br>  Le rappel pour ftrace est le suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  En utilisant la macro container_of (), nous obtenons l'adresse de notre <code>struct ftrace_hook</code> √† l'adresse de la <code>struct ftrace_hook</code> incorpor√©e, apr√®s quoi nous rempla√ßons la valeur du registre% rip dans la <code>struct pt_regs</code> par l'adresse de notre gestionnaire.  C‚Äôest tout.  Pour les architectures autres que x86_64, ce registre peut √™tre appel√© diff√©remment (comme IP ou PC), mais l'id√©e leur est en principe applicable. <br><br>  Notez le <strong>qualificatif notrace</strong> ajout√© pour le rappel.  Ils peuvent signaler les entit√©s dont le suivi n'est pas autoris√© √† l'aide de ftrace.  Par exemple, c'est ainsi que les fonctions de ftrace elle-m√™me qui sont impliqu√©es dans le processus de trace sont marqu√©es.  Cela aide √† emp√™cher le syst√®me de geler dans une boucle sans fin lors du tra√ßage de toutes les fonctions dans le noyau (ftrace peut le faire). <br><br>  Le rappel ftback appelle g√©n√©ralement avec l'extrusion d√©sactiv√©e (comme kprobes).  Il peut y avoir des exceptions, mais vous ne devez pas vous y fier.  Dans notre cas, cependant, cette restriction n'est pas importante, nous rempla√ßons donc seulement huit octets dans la structure. <br><br>  La fonction wrapper, qui sera appel√©e ult√©rieurement, s'ex√©cutera dans le m√™me contexte que la fonction d'origine.  Par cons√©quent, l√†, vous pouvez faire ce qui est autoris√© √† √™tre fait dans la fonction intercept√©e.  Par exemple, si vous interceptez un gestionnaire d'interruption, vous ne pouvez toujours pas dormir dans un wrapper. <br><br><h3>  Protection d'appel r√©cursive </h3><br>     :      ,     ftrace,     ,     .     - . <br><br>   ,      ‚Äî   <code>parent_ip</code> ‚Äî    ftrace-,      ,    .         .       ,        . <br><br> ,    <code>parent_ip</code>     ,     ‚Äî -    .        ,       . <br><br>       ,       (    ).     ,        .       . <br><br> ,  ftrace-   : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  /  : <br><br><ul><li> <strong>  .</strong>      .  ,   ,   . <br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br>  :      <strong>ls</strong> ,       .   (, Bash)         <em>fork</em> () + <em>execve</em> ()     .        <strong>clone()</strong>  <strong>execve()</strong> . ,     execve(),     . <br><br>     -  : <br><br><img alt="sequence-  " src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br>   ,    ( <font color="#66B2FF"></font> )      ( <font color="#EA6B66"></font> ),   ftrace ( <font color="#A680B8"></font> )      ( <font color="#97D077"></font> ). <br><br><ol><li> <strong>   SYSCALL.</strong>                 ‚Äî <em>entry_SYSCALL_64</em> ().       64-   64- . <br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          ‚Äî       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() ‚Äî        sys_execve() ‚Äî     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip ‚Äî      ‚Äî          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        ‚Äî sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -‚Ä¶ <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong>  .</strong>  fh_sys_execve()      do_syscall_64(),  ,       .     . <br></li><li> <strong>    .</strong>     IRET ( SYSRET,   execve() ‚Äî  IRET),               .   (   ) . <br></li></ol><br><h2>    </h2><br>            ,   : <br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   ‚Äî   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong>   .</strong> ,       ftrace,            .  kprobes      ftrace. <br></li></ul><br>      ? <br><br><ul><li> <strong>   .</strong>        ftrace      : <br><ul><li>   kallsyms      </li><li>  ftrace      </li><li>  ftrace,     </li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> ‚Äî      ,    ¬´¬ª  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong>  ftrace.</strong>       <code>parent_ip</code>     ftrace   .           ,        .    ,    :  ftrace    ,          5  (  call),   ftrace  . <br></li></ul><br>    . <br><br><h3>     </h3><br>  ,    ftrace  kallsyms.       : <br><br><ul><li> CONFIG_FTRACE </li><li> CONFIG_KALLSYMS </li></ul><br> , ftrace     .      <br><br><ul><li> CONFIG_DYNAMIC_FTRACE_WITH_REGS </li></ul><br> ,       <em> 3.19  </em> ,      FTRACE_OPS_FL_IPMODIFY.         %rip,    3.19        .         ,      ‚Äî   . <br><br> ,        ftrace  :      ,    (         ).      <br><br><ul><li> CONFIG_HAVE_FENTRY </li></ul><br>  x86_64   ,   i386 ‚Äî . -   i386      ftrace   ,     ftrace     .           %eip ‚Äî     ,   ,      . <br><br>       ftrace   32-  x86.  ,           (   ¬´¬ª),      ,      ftrace. <br><br><h3>   </h3><br>         <em></em> :          . ,     ,    .        ,      . <br><br>  ,      .  -        ftrace-  <code>parent_ip</code>         . -    ,   ftrace      ,   -  . <br><br>  ,       ,    ,       .        ,       -. <br><br>    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>    ‚Äî  : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>   ,      ?              ,    .       -    ,     . <br><br> ,  ,  ,   pr_devel()   .   printk-      .        ,     ,     DEBUG.        : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br>      .       <em>  </em> (tail call optimization).             ,           .       : <br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br>   ‚Äî  : <br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br>   CALL ‚Äî     __fentry__(),      .         real_sys_execve (   )   CALL    fh_sys_execve()    RET.       real_sys_execve()    JMP. <br><br>          ¬´¬ª  ,      ,     CALL. ,         ‚Äî   <code>parent_ip</code>     .    fh_sys_execve()        ,    ‚Äî   .  <code>parent_ip</code>    ,          . <br><br>   ,       .          .          . <br><br>              -: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2>  Conclusion </h2><br>    ‚Ä¶      Linux ‚Äî  .  ,    -     ,          . <br><br>       ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413241/">https://habr.com/ru/post/fr413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413231/index.html">Introduction aux contrats intelligents</a></li>
<li><a href="../fr413233/index.html">Le service uLogin envoie les donn√©es des formulaires (courrier, t√©l√©phone) √† un site tiers et ne dit rien √† ce sujet</a></li>
<li><a href="../fr413235/index.html">Parier sur de meilleures pr√©visions: de nouvelles math√©matiques des pr√©visions m√©t√©orologiques</a></li>
<li><a href="../fr413237/index.html">Facebook nie avoir envoy√© aux fabricants d'appareils les m√™mes donn√©es que le d√©veloppeur Alexander Kogan</a></li>
<li><a href="../fr413239/index.html">Comment rendre un smartphone un peu idiot</a></li>
<li><a href="../fr413243/index.html">School of Data: comment combiner math√©matiques et affaires</a></li>
<li><a href="../fr413245/index.html">Sur les √©quipements Dolby Atmos - uniquement le son "natif". Dolby interdit le upmix non natif</a></li>
<li><a href="../fr413247/index.html">Pourquoi surveiller les syst√®mes de stockage?</a></li>
<li><a href="../fr413249/index.html">√âcriture d'un module du noyau Linux: I2C</a></li>
<li><a href="../fr413251/index.html">R√©action en cha√Æne par polym√©rase et Vladivostok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>