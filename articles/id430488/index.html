<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚖️ 🕺🏿 〽️ Pertukaran data asinkron dengan aplikasi jarak jauh melalui SSH 🚿 🤛🏽 👩🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, teman dan kolega. Nama saya masih Dmitry Smirnov, dan saya masih, sangat senang, pengembang ISPsystem. Beberapa waktu lalu, saya mulai ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pertukaran data asinkron dengan aplikasi jarak jauh melalui SSH</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/430488/">  Selamat siang, teman dan kolega.  Nama saya masih Dmitry Smirnov, dan saya masih, sangat senang, pengembang ISPsystem.  Beberapa waktu lalu, saya mulai mengerjakan proyek yang sama sekali baru, yang sangat menginspirasi saya, karena yang baru dalam kasus kami adalah kurangnya kode warisan dan dukungan untuk kompiler lama.  Halo, Boost, C ++ 17 dan semua kesenangan lain dari perkembangan modern. <br><br>  Kebetulan semua proyek masa lalu saya adalah multi-threaded, masing-masing, saya memiliki sedikit pengalaman dengan solusi asinkron.  Inilah yang menjadi yang paling menyenangkan bagi saya dalam pengembangan ini, di samping alat-alat canggih modern. <br><br>  Salah satu tugas terkait terakhir adalah kebutuhan untuk menulis pembungkus atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libssh2</a> perpustakaan dalam realitas aplikasi asinkron menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost.Asio</a> , dan mampu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memunculkan</a> tidak lebih dari dua utas.  Saya akan memberi tahu Anda tentang ini. <br><br><img src="https://habrastorage.org/webt/j2/fm/-k/j2fm-k44ityxe7_xjzcrwxwy7hw.jpeg"><br><br>  Catatan: penulis berasumsi bahwa pembaca sudah terbiasa dengan dasar-dasar pengembangan asinkron dan meningkatkan :: asio. <br><a name="habracut"></a><br><h2>  Tantangan </h2><br>  Secara umum, tugasnya adalah sebagai berikut: terhubung ke server jauh menggunakan kunci rsa atau nama pengguna dan kata sandi;  unggah skrip ke mesin jarak jauh dan jalankan;  baca jawabannya dan kirim perintah kepadanya melalui koneksi yang sama.  Dalam hal ini, tentu saja, tanpa menghalangi aliran (yang merupakan setengah dari total kumpulan mungkin). <br><br>  <b>Penafian</b> : Saya tahu bahwa Poco bekerja dengan SSH, tetapi saya tidak menemukan cara untuk menikah dengannya dengan Asio, dan lebih menarik untuk menulis sesuatu tentang saya sendiri :-). <br><br><h2>  Inisialisasi </h2><br>  Untuk menginisialisasi dan meminimalkan perpustakaan, saya memutuskan untuk menggunakan singleton biasa: <br><br><div class="spoiler">  <b class="spoiler_title">Init ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LibSSH2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LibSSH2 instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LibSSH2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (libssh2_init(<span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"libssh2 initialization failed"</span></span>); } } ~LibSSH2() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"shutdown libssh2"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; libssh2_exit(); } };</code> </pre> <br><br></div></div><br>  Tentu saja ada jebakan dalam keputusan ini, menurut buku pegangan favorit saya, "Seribu Satu Cara untuk Menembak Kaki Anda di C ++".  Jika seseorang menghasilkan aliran yang mereka lupa tusuk, dan yang utama berakhir lebih awal, efek khusus yang menarik mungkin muncul.  Tetapi dalam hal ini, saya tidak akan memperhitungkan kemungkinan ini. <br><br><h2>  Entitas Kunci </h2><br>  Setelah menganalisis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> , menjadi jelas bahwa untuk perpustakaan kecil kami, kami membutuhkan tiga entitas sederhana: soket, sesi, dan saluran.  Karena senang memiliki alat sinkronisasi, kami akan mengesampingkan Asio untuk saat ini. <br><br>  Mari kita mulai dengan soket sederhana: <br><br><div class="spoiler">  <b class="spoiler_title">Soket</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Socket</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Socket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket(AF_INET, SOCK_STREAM, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_sock == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"failed to create socket"</span></span>); } } ~Socket() { close(m_sock); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_sock = <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br></div></div><br>  Sesi sekarang: <br><br><div class="spoiler">  <b class="spoiler_title">Sesi</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Session</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> enable_compression)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(libssh2_session_init())</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_session == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"failed to create libssh2 session"</span></span>); } libssh2_session_set_blocking(m_session, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enable_compression) { libssh2_session_flag(m_session, LIBSSH2_FLAG_COMPRESS, <span class="hljs-number"><span class="hljs-number">1</span></span>); } } ~Session() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> desc = <span class="hljs-string"><span class="hljs-string">"Shutting down libssh2 session"</span></span>; libssh2_session_disconnect(m_session, desc.c_str()); libssh2_session_free(m_session); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: LIBSSH2_SESSION *m_session; }</code> </pre><br></div></div><br>  Karena sekarang kita memiliki soket dan sesi, alangkah baiknya untuk menulis fungsi tunggu untuk sebuah socket dalam realitas libssh2: <br><br><div class="spoiler">  <b class="spoiler_title">Soket menunggu</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pollfd fds{}; fds.fd = sock; fds.events = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((libssh2_session_block_directions(session) &amp; LIBSSH2_SESSION_BLOCK_INBOUND) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { fds.events |= POLLIN; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((libssh2_session_block_directions(session) &amp; LIBSSH2_SESSION_BLOCK_OUTBOUND) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { fds.events |= POLLOUT; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> poll(&amp;fds, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br></div></div><br>  Sebenarnya, ini praktis tidak berbeda dari contoh di atas, kecuali bahwa ia menggunakan pilih daripada polling. <br><br>  Saluran tetap ada.  Ada beberapa jenis saluran di libssh2: sederhana, SCP, tcp langsung.  Kami tertarik pada saluran dasar yang paling sederhana: <br><br><div class="spoiler">  <b class="spoiler_title">Saluran</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((m_channel = libssh2_channel_open_session(session) == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; GetSessionLastError() == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_channel == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Critical error while opening simple channel"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SendEof() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (libssh2_channel_send_eof(m_channel) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (libssh2_channel_wait_eof(m_channel) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } } ~SimpleChannel() { CloseChannel(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CloseChannel() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc = libssh2_channel_close(m_channel)) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } libssh2_channel_free(m_channel); } LIBSSH2_CHANNEL *m_channel; };</code> </pre> <br></div></div><br>  Sekarang semua alat dasar sudah siap, ia tetap membuat koneksi dengan host dan melakukan manipulasi yang diperlukan.  Rekaman asinkron ke saluran dan sinkron, tentu saja, akan sangat berbeda, tetapi proses membangun koneksi tidak. <br><br>  Oleh karena itu, kami menulis kelas dasar: <br><br><div class="spoiler">  <b class="spoiler_title">Koneksi dasar</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SshConnectData &amp;connect_data)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///&lt;    ,     : m_session(connect_data.enable_compression) , m_connect_data(connect_data) { LibSSH2::Init(); ConnectSocket(); HandShake(); ProcessKnownHosts(); Auth(); } ///       bool CheckSocket(int type) const { pollfd fds{}; fds.fd = m_sock; fds.events = type; return poll(&amp;fds, 1, 0) == 1; } bool WantRead() const { return CheckSocket(POLLIN); } bool WantWrite() const { return CheckSocket(POLLOUT); } /*   ,   ,       *  - . */ void ConnectSocket() {...} void HandShake() {...} void Auth() {...} class Socket m_sock; class Session m_session; class SimpleChannel; SshConnectData m_connect_data; };</span></span></span></span></code> </pre> <br></div></div><br>  Sekarang kita siap menulis kelas paling sederhana untuk terhubung ke host jarak jauh dan menjalankan perintah apa pun di atasnya: <br><br><div class="spoiler">  <b class="spoiler_title">Koneksi sinkron</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class">:</span></span>:Impl : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseConnectionImpl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SshConnectData &amp;connect_data)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(connect_data)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Begin&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteToChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LIBSSH2_CHANNEL *channel, Begin ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc = libssh2_channel_write(channel, ptr, size)) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size -= rc; ptr += rc; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size != <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;command, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;in = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">SimpleChannel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> return_code = libssh2_channel_exec(channel, command.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_code != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; return_code != LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Critical error while executing ssh command"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!in.empty()) { WriteToChannel(channel, in.c_str(), in.size()); channel.SendEof(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, 4096&gt; buffer{}; rc = libssh2_channel_read(channel, buffer.data(), buffer.size()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { boost::range::copy(boost::adaptors::slice(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, rc), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(response)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rc != LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"libssh2_channel_read error ("</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(rc) + <span class="hljs-string"><span class="hljs-string">")"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } };</code> </pre> <br></div></div><br>  Sejauh ini, semua yang kami tulis merupakan pengurangan sederhana dari contoh libssh2 ke bentuk yang lebih beradab.  Tetapi sekarang, dengan memiliki semua alat sederhana untuk menulis data ke saluran secara serempak, kita dapat beralih ke Asio. <br><br>  Memiliki soket standar adalah baik, tetapi tidak terlalu praktis jika Anda harus menunggu secara tidak sinkron untuk membaca / menulis saat melakukan bisnis Anda sendiri dalam proses.  Sini boost :: asio :: ip :: tcp :: socket datang untuk menyelamatkan, memiliki metode yang luar biasa: <br><br><pre> <code class="cpp hljs">async_wait(wait_type, WaitHandler)</code> </pre> <br>  Itu luar biasa dibangun dari soket biasa, di mana kita sudah mengatur koneksi di muka dan meningkatkan :: asio :: io_context - konteks eksekusi aplikasi kita. <br><br><div class="spoiler">  <b class="spoiler_title">Konstruktor koneksi asinkron</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncConnection</span></span></span><span class="hljs-class">:</span></span>:Impl : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseConnectionImpl, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt;AsyncConnection::Impl&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Impl(boost::asio::io_context &amp;context, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SshConnectData &amp;connect_data) : BaseConnectionImpl(connect_data) , m_tcp_socket(context, tcp::v4(), m_sock.GetSocket()) { m_tcp_socket.non_blocking(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } };</code> </pre> <br></div></div><br><br>  Sekarang kita perlu memulai eksekusi beberapa perintah pada host jarak jauh dan, segera setelah data darinya tiba, kirimkan ke beberapa panggilan balik. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncRun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;command, CallbackType &amp;&amp;callback)</span></span></span><span class="hljs-function"> </span></span>{ m_read_callback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(callback); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = libssh2_channel_exec(*m_channel, command.c_str()); TryRead(); }</code> </pre> <br>  Dengan demikian, dengan menjalankan perintah, kami mentransfer kontrol ke metode TryRead (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_read_in_progress) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_tcp_socket.async_wait(tcp::socket::wait_read, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self = shared_from_this()](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WantRead()) { ReadHandler(ec); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_complete) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TryRead(); }); }</code> </pre><br>  Pertama-tama, kami memeriksa apakah proses membaca sudah berjalan oleh beberapa panggilan sebelumnya.  Jika tidak, maka kita mulai mengharapkan kesiapan soket untuk membaca.  Lambda biasa dengan penangkapan shared_from_this () digunakan sebagai penangan menunggu. <br><br>  Perhatikan panggilan ke WantRead ().  Async_wait, ternyata, juga memiliki kekurangannya, dan dapat kembali dengan waktu habis.  Untuk menghindari tindakan yang tidak perlu dalam kasus ini, saya memutuskan untuk memeriksa soket melalui jajak pendapat tanpa batas waktu - apakah soket benar-benar ingin membaca sekarang.  Jika tidak, maka kita jalankan lagi TryRead () dan tunggu.  Jika tidak, kami segera mulai membaca dan mentransfer data ke panggilan balik. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != boost::system::errc::success) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_read_in_progress = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ec = LIBSSH2_ERROR_EAGAIN; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, 4096&gt; buffer {}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((ec = libssh2_channel_read(*m_channel, buffer.data(), buffer.size())) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp; boost::range::copy(boost::adaptors::slice(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ec), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(tmp)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_read_callback != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { m_read_callback(tmp); } } m_read_in_progress = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Dengan demikian, siklus baca asinkron tak berujung dimulai dari aplikasi yang sedang berjalan.  Langkah selanjutnya bagi kami adalah mengirimkan instruksi ke aplikasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data, WriteCallbackType &amp;&amp;callback)</span></span></span><span class="hljs-function"> </span></span>{ m_input += data; m_write_callback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(callback); TryWrite(); }</code> </pre><br>  Data dan panggilan balik yang ditransfer ke rekaman asinkron akan disimpan di dalam koneksi.  Dan jalankan siklus berikutnya, kali ini saja entri: <br><br><div class="spoiler">  <b class="spoiler_title">Siklus rekaman</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_input.empty() || m_write_in_progress) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_tcp_socket.async_wait(tcp::socket::wait_write, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self = shared_from_this()](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WantWrite()) { WriteHandler(ec); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_complete) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TryWrite(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != boost::system::errc::success) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_write_in_progress = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ec = LIBSSH2_ERROR_EAGAIN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!m_input.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = m_input.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> read_size = m_input.size(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((ec = libssh2_channel_write(*m_channel, ptr, read_size)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { read_size -= ec; ptr += ec; } AssertResult(ec); m_input.erase(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_input.size() - read_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ec == LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_input.empty() &amp;&amp; m_write_callback != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { m_write_callback(); } m_write_in_progress = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br></div></div><br>  Jadi, kami akan menulis data ke saluran sampai semuanya berhasil ditransfer.  Kemudian kami akan mengembalikan kontrol ke pemanggil sehingga sepotong data baru dapat ditransfer.  Dengan cara ini Anda tidak hanya dapat mengirim instruksi ke beberapa aplikasi pada host, tetapi juga, misalnya, mengunggah file dengan ukuran apa pun dalam porsi kecil, tanpa memblokir utas, yang penting. <br><br>  Menggunakan perpustakaan ini, saya berhasil menjalankan skrip pada server jauh yang melacak perubahan sistem file, pada saat yang sama membaca outputnya dan mengirim berbagai perintah.  Secara umum: pengalaman yang sangat berharga dalam mengadaptasi perpustakaan gaya si untuk proyek C ++ modern menggunakan Boost. <br><br>  Saya akan senang membaca tips pengguna Boost.Asio yang lebih berpengalaman untuk mempelajari lebih lanjut dan meningkatkan solusi saya :-). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430488/">https://habr.com/ru/post/id430488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430478/index.html">Trading bot untuk pasar cryptocurrency. Di mana untuk memulai?</a></li>
<li><a href="../id430480/index.html">Ketika kami menulis aplikasi di NASA Space Apps Challenge hackathon</a></li>
<li><a href="../id430482/index.html">Tema pelat baja dalam budaya Timur dan Barat</a></li>
<li><a href="../id430484/index.html">Skenario Implementasi NGFW yang tipikal</a></li>
<li><a href="../id430486/index.html">Bagaimana freelancer tinggal: dari pengembang ke copywriter teknis</a></li>
<li><a href="../id430490/index.html">Mengantisipasi, mendidik, memutuskan: bagaimana dan mengapa EPAM membangun Java Competency Center</a></li>
<li><a href="../id430492/index.html">Intel Neural Compute Stick. Artificial Mind pada USB Flash Drive - 2</a></li>
<li><a href="../id430494/index.html">Monitor Lalu Lintas InfoWatch. Di ujung bug dan fitur</a></li>
<li><a href="../id430496/index.html">NB-IoT: bagaimana cara kerjanya? Bagian 1</a></li>
<li><a href="../id430498/index.html">Lewati Kontrol Akun Pengguna (UAC) dengan meniru direktori tepercaya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>