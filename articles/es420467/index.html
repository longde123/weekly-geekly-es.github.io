<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏾 👶🏾 🔠 Contenedor C ++ para "todos" los sistemas operativos en tiempo real para CortexM4 😐 🔷 🍄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hablé sobre cómo puede usar FreeRtos para proyectos escritos en C ++ en el artículo STM32, C ++ y FreeRTOS. Desarrollo desde cero. Parte 1 Desde en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contenedor C ++ para "todos" los sistemas operativos en tiempo real para CortexM4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420467/"><img src="https://habrastorage.org/webt/s0/2o/ve/s02ovegatxm9x39z6c8x_5fydki.png" alt="imagen"><br><br>  Ya hablé sobre cómo puede usar FreeRtos para proyectos escritos en C ++ en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STM32, C ++ y FreeRTOS.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo desde cero.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a>  Desde entonces, han pasado 3 años, envejecí seriamente, perdí un montón de conexiones neuronales, así que decidí sacudir los viejos tiempos para restaurar estas conexiones y barrer el envoltorio para "cualquier" RTOS popular.  Esto es, por supuesto, una broma, deliberadamente puse "todos" entre comillas, pero hay algo de verdad en cada broma. <br><a name="habracut"></a><br>  Entonces, ¿cuál es la tarea y por qué es relevante?  Por el momento, hay un millón de sistemas operativos diferentes escritos en C: no quiero elegir para todos los gustos, pagados, gratuitos, pequeños, grandes ... Pero para los proyectos en los que participo, no se necesitan todos estos chips de diferentes sistemas operativos, la funcionalidad básica como una tarea es suficiente , eventos, notificación de tareas, sección crítica, mutexes y semáforos (aunque trato de no usarlos), colas.  Y todo esto es necesario en una forma bastante simple, sin lujos. <br><br>  En mi opinión, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>OSRV MAX</b></a> doméstico, escrito en C ++, es ideal para mis proyectos y es un placer usarlo. <br><br>  Pero el problema es que nuestros dispositivos deben cumplir con el estándar IEC_61508, uno de cuyos requisitos es la <i>aplicación E.29 de la biblioteca de destino probada en uso</i> .  Bueno, o en palabras simples, si crea un dispositivo para cumplir con el nivel <u>SIL3</u> , entonces (Recomendado más alto) use bibliotecas que correspondan a este nivel y sean probadas en el tiempo. <br><br>  Con respecto a nuestra tarea, esto significa que es posible usar el <b>MAX MAX RTOS</b> para tales dispositivos, pero no se agregarán puntos de confiabilidad.  Por lo tanto, los fabricantes de RTOS hacen versiones especiales de sus sistemas operativos que cumplen con los estándares IEC_61508, por ejemplo, <i>FreeRTOS</i> tiene un clon <i>SafeRTOS</i> y <i>embOs</i> tiene un clon <i>embOS-Safe</i> , por supuesto, los fabricantes ganan muy buen dinero en esto, porque las licencias para estos sistemas operativos cuestan varios miles, o incluso decenas mil dolares <br><br>  Por cierto, un buen ejemplo es el compilador IAR, cuya licencia cuesta alrededor de $ 1,500, pero las versiones certificadas por IAR ya cuestan alrededor de 10,000 dólares, aunque verifiqué en varios proyectos: el archivo de salida de la versión sin un certificado y con un certificado es completamente idéntico.  Bueno, entiendes que debes pagar por la paz. <br><br>  Entonces, primero usamos <i>un sistema operativo</i> , luego comencé a usar <i>FreeRTOS</i> para mis necesidades, luego cambiamos a <i>otro</i> , en general, tuvimos que reescribir constantemente el código terminado.  Además, me gustaría que se vea hermoso y simple, para que cualquiera pueda entender por código lo que está sucediendo, entonces el soporte de código será un trabajo simple para estudiantes y profesionales, y los gurús podrán continuar trabajando en dispositivos innovadores, en lugar de comprender la pila de fideos .  En general, quiero ver algo como esto fosilizado: <br><br><img src="https://habrastorage.org/webt/rc/2z/_k/rc2z_kzdcpu6isdhwojtbbi4wac.png" alt="imagen"><br><br>  Bueno, o tal ... <br><br><img src="https://habrastorage.org/webt/f7/li/48/f7li48lkaylpglvyjr-tiekmxai.png" alt="imagen"><br><br>  Por lo tanto, decidí escribir un contenedor que se adaptara a <i>FreeRTOS</i> y decir <i>embOS,</i> bueno, para todos los demás también :) y, para comenzar, determiné lo que realmente necesito para una felicidad completa: <br><br><ul><li>  Las tareas </li><li>  Secciones críticas </li><li>  Notificación de eventos y tareas </li><li>  Semáforos y mutexes </li><li>  Colas </li></ul><br>  El contenedor debe ser ideológico <u>SIL3</u> , y este nivel impone una gran cantidad de todo tipo de cosas recomendadas, y si las sigues por completo, resulta que es mejor no escribir el código. <br><br>  Pero el hecho de que el estándar rige un conjunto de reglas, o más bien recomendaciones, no significa que no se puedan violar; usted puede, pero debe seguir tantas recomendaciones como sea posible para obtener más puntos.  Por lo tanto, decidí algunas limitaciones importantes: <br><br><ul><li>  <b>sin macros</b> , bueno, excepto por la protección contra la doble inclusión de archivos de encabezado.  Las macros son malvadas, si calcula cuánto tiempo pasó buscando errores relacionados con las macros, resulta que el universo no es tan viejo, y cuánto bien podría hacerse durante este tiempo, probablemente sea mejor prohibirlos a nivel legislativo, ya que los torrentes lo prohibieron o tome un bono por cada macro que escriba </li><li>  <b>no use punteros</b> , por supuesto, siempre que sea posible.  Uno podría tratar de no usarlos en absoluto, pero todavía hay lugares donde sin ellos no hay forma.  En cualquier caso, el usuario del envoltorio, si es posible, ni siquiera debería saber qué es un puntero, ya que solo escuchó sobre ellos de su abuelo, porque ahora trabaja exclusivamente con enlaces </li><li>  <b>no usar la asignación dinámica de memoria</b> : todo está claro, solo usar un montón conduce, en primer lugar, a la necesidad de reservar RAM para este montón, y en segundo lugar, con el uso frecuente del montón, se desfragmenta y se crean nuevos objetos en él más y más tiempo más largo  Por lo tanto, de <i>hecho,</i> configuré <i>FreeRTOS</i> solo en la memoria asignada estáticamente al configurar <i>configSUPPORT_STATIC_ALLOCATION 1</i> .  Pero si quieres trabajar en modo predeterminado.  Y de forma predeterminada, <i>FreeRTOS</i> usa memoria asignada dinámicamente para crear elementos del sistema operativo; luego simplemente configure <i>configSUPPORT_STATIC_ALLOCATION 0</i> , y <br>  <i>configSUPPORT_DYNAMIC_ALLOCATION 1</i> y no olvide conectar la implementación de sus propios mallocs y callocs desde el administrador de memoria, por ejemplo, este archivo es FreeRtos / portable / MemMang / heap_1.c.  Pero tenga en cuenta que tendrá que asignar RAM con una reserva para un grupo, ya que no podrá calcular la cantidad exacta de RAM necesaria, con todas las configuraciones (Idle está activado, la tarea del temporizador del programa está activada, mis dos tareas, colas, tamaño de cola para los temporizadores 10 y etc., digamos que definitivamente no es la configuración más óptima) que funcionó cuando asigné la memoria de esta manera: <br><blockquote>  7 357 bytes de memoria de código de solo lectura <br>  535 bytes de memoria de datos de solo lectura <br>  6.053 bytes de memoria de datos readwrite </blockquote><br>  La asignación de memoria estática es "un poco" más compacta: <br><blockquote>  7.329 bytes de memoria de código de solo lectura <br>  535 bytes de memoria de datos de solo lectura <br>  3.877 bytes de memoria de datos readwrite </blockquote><br>  Puede pensar: "increíble ... usted mismo", pero ahora no estamos interesados ​​en la pregunta formulada en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Asigné hasta 3 KB al sistema operativo y lancé solo 3 tareas con una pila de 128 B, y por alguna razón ya no hay suficiente memoria para el cuarto"</a> , En esta situación, lo hice a propósito, para mayor claridad, para mostrar la diferencia entre la asignación de memoria dinámica y estática con la misma configuración. <br></li><li>  <b>No lanzar tipos</b> , si es posible.  Los tipos de imágenes fantasma a otros tipos en sí mismos significan el hecho de que algo está mal en el diseño, pero como de costumbre, a veces todavía tiene que emitir para facilitar su uso (por ejemplo, la enumeración debe convertirse a enteros), y a veces no puede prescindir esto, pero esto debe ser evitado. </li><li>  <b>simplicidad y conveniencia</b> .  Para el usuario del envoltorio, todas las dificultades deben estar ocultas, por lo que su vida no es petróleo, y no quiere complicarlo todavía: creó la tarea, implementó todo lo que se necesita en ella, la inició y se fue para disfrutar de la vida. </li></ul><br>  Comenzaremos con esto, así que nos propusimos la tarea de crear una tarea (resultó de la serie "prohibido prohibir"). <br><br><h2>  Creación de tareas </h2><br>  Según una larga investigación, científicos británicos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Toda la verdad sobre RTOS de Colin Walls. Artículo # 4. Tareas, cambio de contexto e interrupciones</a> ) (por cierto, si no lo sabían, el ensamblador de ARM también fue inventado por un científico británico, algo que tampoco me sorprendió una vez :)), y así los científicos británicos descubrieron que para la mayoría de "todos" RTOS la tarea tiene un <i>nombre</i> , una <i>pila</i> , <i>un tamaño de pila</i> , una <i>"unidad de control"</i> , un <i>identificador o un puntero a una "unidad de control"</i> , <i>prioridad</i> , una <i>función que se realiza en la tarea</i> .  Eso es todo, y fue posible agruparlo todo en una clase, pero fue correcto si escribimos un sistema operativo con usted, pero hacemos un contenedor, por lo que no tiene sentido almacenar todas estas cosas en un contenedor, todo esto lo <u>hará el</u> sistema operativo ideológico <u>SIL3</u> terminamos  De hecho, solo necesitamos una <i>función que se ejecute en la tarea</i> y una <i>estructura que almacene la “unidad de control”</i> , que se completa al crear la tarea y <i>el identificador de la tarea</i> .  Por lo tanto, la clase de tarea, llamémosla <i>Hilo,</i> puede parecer muy simple: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: tTaskHandle taskHandle ; tTaskContext context ; } ;</code> </pre> <br>  Solo quiero declarar la clase de mi tarea donde podría implementar todo lo que se necesita y luego pasar el puntero al objeto de esta clase al contenedor, lo que crearía una tarea usando la API RTOS donde lanzaría el método <i>Execute ()</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//do something.. } } ; using tMyTaskStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tMyTaskStack Stack; //!C++17 } ; MyTask myDesiredTask int main() { Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask") ; }</span></span></code> </pre> <br>  En "todos" RTOS, para que se cree la tarea, es necesario pasar un puntero a una función que será iniciada por el planificador.  En nuestro caso, esta es la función <i>Execute ()</i> , pero no puedo pasar un puntero a este método, ya que no es estático.  Por lo tanto, observamos cómo se crea una tarea en la API de "todos" los sistemas operativos y observamos que podemos crear una tarea pasando un parámetro a la función de tarea, por ejemplo, para <i>embOS</i> es: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OS_TASK_CreateEx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OS_TASK* pTask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pName, OS_PRIO Priority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*pRoutine)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pVoid ), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OS_STACKPTR *pStack, OS_UINT StackSize, OS_UINT TimeSlice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span></span>;</code> </pre><br>  <b>void * pContext</b> : esta es la clave de la solución.  Tengamos un método estático, un puntero al que pasaremos como puntero a un método llamado por el planificador, y como parámetro pasaremos un puntero a un objeto de tipo <i>Thread</i> donde podemos llamar directamente al método <i>Execute ()</i> .  Este es exactamente el momento en el que no hay forma sin puntero y conversión a tipos, pero este código estará oculto para el usuario: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Execute() ; }</code> </pre> <br>  Es decir  tal algoritmo de operación, el planificador lanza el método <i>Run</i> , un puntero a un objeto de tipo <i>Thread</i> se pasa al método <i>Run</i> .  El método <i>Run</i> llama directamente al método <i>Execute ()</i> , un objeto específico de la clase <i>Thread</i> , que es solo nuestra implementación de la tarea. <br><br>  El problema está casi resuelto, ahora necesitamos implementar los métodos.  Todos los sistemas operativos tienen API diferentes, por lo que para implementar, por ejemplo, la función de creación de tareas para <i>embOS,</i> debe llamar al <i>método</i> vacío <i>OS_TASK_CreateEx (..)</i> , y para <i>FreeRTOS</i> en el modo de asignación de memoria dinámica, esto es <i>xTaskCreate (..)</i> y aunque tienen una misma esencia igual, pero la sintaxis y los parámetros son diferentes.  Pero no queremos ejecutar los archivos y escribir código para cada uno de los métodos de la clase cada vez para un nuevo sistema operativo, por lo que debemos poner esto de alguna manera en un archivo y ... ejecutarlo en forma de macros.  Genial, pero detente, me prohibí las macros: necesito un enfoque diferente. <br><br>  Lo más simple que se me ocurrió fue crear un archivo separado para cada sistema operativo con funciones en línea.  Si queremos usar cualquier otro sistema operativo, solo necesitaremos implementar cada una de estas funciones usando la API de este sistema operativo.  El siguiente archivo <b>rtosFreeRtos.cpp</b> resultó <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For FreeRTOS functions prototypes #include &lt;FreeRTOS.h&gt; //For xTaskCreate #include &lt;task.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.taskControlBlock); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif }</span></span></span></span></code> </pre><br>  El archivo para embOS <b>rtosEmbOS.cpp</b> puede verse exactamente <b>igual</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For embOS functions prototypes #include &lt;rtos.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp;thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { constexpr OS_UINT timeSliceNull = 0 ; if (pStack != nullptr) { OS_CreateTaskEx(&amp;(thread.handle), pName, static_cast&lt;OS_PRIO&gt;(prior), Rtos::Run, pStack, ((stackSize == 0U) ? sizeof(pStack) : stackSize), timeSliceNull, &amp;thread) ; } }</span></span></span></span></code> </pre> <br>  Los tipos de sistemas operativos diferentes también son diferentes, especialmente la estructura del contexto de la tarea, así que creemos el archivo rtosdefs.hpp con nuestros propios alias de contenedor. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;FreeRTOS.h&gt; //For TaskHandle_t namespace OsWrapper { using tTaskContext = StaticTask_t; using tTaskHandle = TaskHandle_t; using tStack = StackType_t ; }</span></span></span></span></code> </pre><br>  Para <i>EmbOS,</i> podría verse así: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;rtos.h&gt; //For OS_TASK namespace OsWrapper { using tTaskContext = OS_TASK; using tTaskHandle = OS_TASK; using tStack = tU16 //   void,      tU16 ; }</span></span></span></span></code> </pre><br>  Como resultado, para alterar cualquier otro RTOS, es suficiente hacer cambios solo en estos dos archivos rtosdefs.cpp y rtos.cpp.  Ahora las clases <i>Thread</i> y <i>Rtos</i> se ven como imágenes c <br><br><img src="https://habrastorage.org/webt/gp/wq/zl/gpwqzlgnristquzlrcdbxyfm9ro.png" alt="imagen"><br><br><h2>  Lanzar OS y finalizar la tarea </h2><br>  Para Cortex M4, "todos" los sistemas operativos usan 3 interrupciones, <i>temporizador de</i> <i>marcación del sistema</i> , <i>llamada de servicio del sistema mediante instrucciones SWI</i> , <i>solicitud pendiente de interrupciones de servicio del sistema</i> , que se inventaron principalmente para el RTOS.  Algunos RTOS también usan otras interrupciones del sistema, pero serán suficientes para la mayoría de los sistemas operativos "todos".  Y si no, entonces será posible agregar, así que solo defina tres controladores para estas interrupciones y para iniciar el RTOS necesitamos otro método de inicio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvcInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSysTickInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Lo primero que necesitaba y sin lo cual no puedo vivir, lo que estoy soñando es un mecanismo de notificación para las tareas.  En general, me gusta la programación dirigida por eventos, por lo que necesito implementar rápidamente un contenedor para notificar las tareas. <br><br>  Todo resultó ser bastante simple, cualquier sistema operativo puede hacerlo, bueno, excepto tal vez <i>uc-OS-II</i> y <i>III</i> , aunque tal vez no lo leí bien, pero, en mi opinión, el mecanismo de los eventos es generalmente complicado, pero bueno, "todo" es el resto Ciertamente pueden. <br><br>  Para notificar la tarea, solo necesita enviar el evento no al vacío, sino específicamente a la tarea, para esto, el método de notificación debe tener un puntero al contexto de la tarea o al identificador de la tarea.  Solo almaceno estos en la clase <i>Thread</i> , lo que significa que la clase Thread también debería tener un método de alerta.  También debería haber un método para esperar una alerta.  Al mismo tiempo, agregamos el método <i>Sleep (..)</i> , que detiene la ejecución de la tarea de llamada.  Ahora ambas clases se ven así: <br><br><img src="https://habrastorage.org/webt/ie/r_/35/ier_35fgsut4a_gf_ismmm91tuk.png" alt="imagen"><br><br><div class="spoiler">  <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Execute() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: tTaskHandle handle ; tTaskContext context ; } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br>  Comencé a implementarlo, y aquí el primer problema me estaba esperando, resulta que "cualquier" sistema operativo llama a sus funciones de interrupciones de diferentes maneras.  Por ejemplo, <i>FreeRTOS</i> tiene implementaciones especiales de funciones para ejecutarlas desde interrupciones, por ejemplo, si hay una función <i>xTaskNotify (..)</i> , entonces no puede llamarla desde una interrupción, pero necesita llamar a <i>xTaskNotifyFromISR (..)</i> . <br>  Para <i>embOS,</i> si llama a cualquier función desde una interrupción, utilice <i>OS_InInterrupt ()</i> al ingresar una interrupción y <i>OS_LeaveInterrupt ()</i> al salir.  Tuve que hacer una clase <i>InterruptEntry</i> , que solo tiene un constructor y un destructor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wEnterInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wLeaveInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterInterrupt() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~InterruptEntry() { wLeaveInterrupt() ; } } ; } ;</code> </pre> <br>  Puedes usarlo así: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::HandleInterrupt() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OsWrapper::InterruptEntry ie; EXTI-&gt;PR = EXTI_PR_PR13 ; myDesiredTask.Signal(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> myDesiredTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WaitForSignal(<span class="hljs-number"><span class="hljs-number">100000</span></span>ms) == defaultTaskMaskBits) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; } } } ;</code> </pre> <br>  Obviamente, para <i>FreeRTOS,</i> tanto el constructor como el destructor estarán vacíos.  Y para la notificación, puede usar la función <i>xTaskNotifyFromISR (..)</i> , que no importa de dónde se llame, es un poco sobrecarga, pero no lo hará por el bien de la universalidad.  Por supuesto, puede crear métodos separados para llamar desde interrupciones, pero por ahora decidí hacerlo universalmente. <br>  El mismo truco que con <i>InterruptEntry</i> se puede hacer con la sección crítica: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterCriticalSection() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~CriticalSection() { wLeaveCriticalSection() ; } } ; } ;</code> </pre> <br>  Ahora solo agregue la implementación de funciones usando la API de <i>FreeRtos</i> al archivo y ejecute la verificación, aunque no pudo ejecutarla, por lo que está claro que funcionará :) <br><div class="spoiler">  <b class="spoiler_title">rtosFreeRtos.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : rtosFreeRtos.cpp * * Details : This file containce implementation of functions of concrete * FreeRTOS to support another RTOS create the same file with the * same functions but another name&lt; for example rtosEmbOS.cpp and * implement these functions using EmbOS API. * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../thread.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../mutex.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../rtos.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; namespace OsWrapper { /***************************************************************************** * Function Name: wCreateThread * Description: Creates a new task and passes a parameter to the task. The * function should call appropriate RTOS API function to create a task. * * Assumptions: RTOS API create task function should get a parameter to pass the * paramete to task. * Some RTOS does not use pStack pointer so it should be set to nullptr * * Parameters: [in] thread - refernce on Thread object * [in] pName - name of task * [in] prior - task priority * [in] stackDepth - size of Stack * [in] pStack - pointer on task stack * Returns: No ****************************************************************************/ void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior, const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.context); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif } /***************************************************************************** * Function Name: wStart() * Description: Starts the RTOS scheduler * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wStart() { vTaskStartScheduler() ; } /***************************************************************************** * Function Name: wHandleSvcInterrupt() * Description: Handle of SVC Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvcInterrupt() { vPortSVCHandler() ; } /***************************************************************************** * Function Name: wHandleSvInterrupt() * Description: Handle of SV Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvInterrupt() { xPortPendSVHandler() ; } /***************************************************************************** * Function Name: wHandleSysTickInterrupt() * Description: Handle of System Timer Interrupt. The function should call * appropriate RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSysTickInterrupt() { xPortSysTickHandler() ; } /***************************************************************************** * Function Name: wSleep() * Description: Suspends the calling task for a specified period of time, * or waits actively when called from main() * * Assumptions: No * Parameters: [in] timeOut - specifies the time interval in system ticks * Returns: No ****************************************************************************/ void wSleep(const tTime timeOut) { vTaskDelay(timeOut) ; } /***************************************************************************** * Function Name: wEnterCriticalSection() * Description: Basic critical section implementation that works by simply * disabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterCriticalSection() { taskENTER_CRITICAL() ; } /***************************************************************************** * Function Name: wLeaveCriticalSection() * Description: Leave critical section implementation that works by simply * enabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveCriticalSection() { taskEXIT_CRITICAL() ; } /**************************************************************************** * Function Name: wEnterInterrupt() * Description: Some RTOS requires to inform the kernel that interrupt code * is executing * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterInterrupt() { } /**************************************************************************** * Function Name: wLeaveInterrupt() * Description: Some RTOS requires to inform that the end of the interrupt r * outine has been reached; executes task switching within ISR * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveInterrupt() { } /**************************************************************************** * Function Name: wSignal() * Description: Signals event(s) to a specified task * * Assumptions: No * Parameters: [in] taskHandle - Reference to the task structure * [in] mask - The event bit mask containing the event bits, * which shall be signaled. * Returns: No ****************************************************************************/ void wSignal(tTaskHandle const &amp;taskHandle, const tTaskEventMask mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xTaskNotifyFromISR(taskHandle, mask, eSetBits, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wWaitForSignal() * Description: Waits for the specified events for a given time, and clears * the event memory when the function returns * * Assumptions: No * Parameters: [in] mask - The event bit mask containing the event bits, * which shall be waited for * [in] timeOut - Maximum time in system ticks waiting for events * to be signaled. * Returns: Set bits ****************************************************************************/ tTaskEventMask wWaitForSignal(const tTaskEventMask mask, tTime timeOut) { uint32_t ulNotifiedValue = 0U ; xTaskNotifyWait( 0U, std::numeric_limits&lt;uint32_t&gt;::max(), &amp;ulNotifiedValue, timeOut); return (ulNotifiedValue &amp; mask) ; } /**************************************************************************** * Function Name: wCreateEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] event - reference on tEvent object * * Returns: Handle of created Event ****************************************************************************/ tEventHandle wCreateEvent(tEvent &amp;event) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xEventGroupCreateStatic(&amp;event); #else return xEventGroupCreate(); #endif } /**************************************************************************** * Function Name: wDeleteEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] eventHandle - reference on tEventHandle object * * Returns: No ****************************************************************************/ void wDeleteEvent(tEventHandle &amp;eventHandle) { vEventGroupDelete(eventHandle); } /**************************************************************************** * Function Name: wSignalEvent() * Description: Sets an resumes tasks which are waiting at the event object * * Assumptions: No * Parameters: [in] event - reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * * Returns: No ****************************************************************************/ void wSignalEvent(tEventHandle const &amp;eventHandle, const tEventBits mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE; xEventGroupSetBitsFromISR(eventHandle, mask, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR(xHigherPriorityTaskWoken) ; } /**************************************************************************** * Function Name: wWaitEvent() * Description: Waits for an event and suspends the task for a specified time * or until the event has been signaled. * * Assumptions: No * Parameters: [in] event - Reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * [in] timeOut - Maximum time in RTOS system ticks until the * event must be signaled. * [in] mode - Indicate mask bit behaviour * * Returns: Set bits ****************************************************************************/ tEventBits wWaitEvent(tEventHandle const &amp;eventHandle, const tEventBits mask, const tTime timeOut, OsWrapper::EventMode mode) { BaseType_t xWaitForAllBits = pdFALSE ; if (mode == OsWrapper::EventMode::waitAnyBits) { xWaitForAllBits = pdFALSE; } return xEventGroupWaitBits(eventHandle, mask, pdTRUE, xWaitForAllBits, timeOut) ; } /**************************************************************************** * Function Name: wCreateMutex() * Description: Create an mutex. Mutexes are used for managing resources by * avoiding conflicts caused by simultaneous use of a resource. The resource * managed can be of any kind: a part of the program that is not reentrant, a * piece of hardware like the display, a flash prom that can only be written to * by a single task at a time, a motor in a CNC control that can only be * controlled by one task at a time, and a lot more. * * Assumptions: No * Parameters: [in] mutex - Reference on tMutex structure * [in] mode - Indicate mask bit behaviour * * Returns: Mutex handle ****************************************************************************/ tMutexHandle wCreateMutex(tMutex &amp;mutex) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xSemaphoreCreateMutexStatic(&amp;mutex) ; #else return xSemaphoreCreateMutex(); #endif } /**************************************************************************** * Function Name: wDeleteMutex() * Description: Delete the mutex. * * Assumptions: No * Parameters: [in] mutex - handle of mutex * * Returns: Mutex handle ****************************************************************************/ void wDeleteMutex(tMutexHandle &amp;handle) { vSemaphoreDelete(handle) ; } /**************************************************************************** * Function Name: wLockMutex() * Description: Claim the resource * * Assumptions: No * Parameters: [in] handle - handle of mutex * [in] timeOut - Maximum time until the mutex should be available * * Returns: true if resource has been claimed, false if timeout is expired ****************************************************************************/ bool wLockMutex(tMutexHandle const &amp;handle, tTime timeOut) { return static_cast&lt;bool&gt;(xSemaphoreTake(handle, timeOut)) ; } /**************************************************************************** * Function Name: wUnLockMutex() * Description: Releases a mutex currently in use by a task * * Assumptions: No * Parameters: [in] handle - handle of mutex * * Returns: No ****************************************************************************/ void wUnLockMutex(tMutexHandle const &amp;handle) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xSemaphoreGiveFromISR(handle, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wSleepUntil() * Description: Suspends the calling task until a specified time, or waits * actively when called from main() * * Assumptions: No * Parameters: [in] last - Refence to a variable that holds the time at which * the task was last unblocked. The variable must be initialised * with the current time prior to its first use * [in] timeOut - Time to delay until, the task will be unblocked * at time * * Returns: No ****************************************************************************/ void wSleepUntil(tTime &amp; last, const tTime timeOut) { vTaskDelayUntil( &amp;last, timeOut) ; } /**************************************************************************** * Function Name: wGetTicks() * Description: Returns the current system time in ticks as a native integer * value * * Assumptions: No * Parameters: No * * Returns: Current system time in ticks ****************************************************************************/ tTime wGetTicks() { return xTaskGetTickCount(); } }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/4a/sm/mm/4asmmm71hosjm510maad5hcadrm.png" alt="imagen"><br><br><h2>  Seguimos refinando la tarea. </h2><br>  La tarea ahora tiene casi todo lo que necesita, agregamos el método Sleep ().  Este método detiene la tarea durante un tiempo específico.  En la mayoría de los casos, esto es suficiente, pero si necesita un tiempo claramente determinado, Sleep () puede traerle problemas.  Por ejemplo, desea realizar algunos cálculos y parpadear el LED y hacerlo exactamente una vez cada 100 ms <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { DoCalculation(); <span class="hljs-comment"><span class="hljs-comment">//It takes about 10ms Led1.Toggle() ; Sleep(100ms) ; } }</span></span></code> </pre><br>  Este código parpadeará un LED cada 110 ms.  Pero si desea una vez cada 100 ms, puede calcular aproximadamente el tiempo de cálculo y poner Sleep (90 ms).  Pero, si el tiempo de cálculo depende de los parámetros de entrada, el parpadeo no será determinista en absoluto.  Para tales casos en "todos" los sistemas operativos, existen métodos especiales, como DelayUntil ().  Funciona de acuerdo con este principio: primero debe recordar el valor actual del contador de tics del sistema operativo, luego agregar a este valor el número de ticks para los que necesita pausar la tarea, tan pronto como el contador de ticks alcance este valor, la tarea se desbloqueará.  Por lo tanto, la tarea se bloqueará exactamente al valor que configuró y su LED parpadeará exactamente cada 100 ms, independientemente de la duración del cálculo. <br>  Este mecanismo se implementa de manera diferente en diferentes sistemas operativos, pero tiene un algoritmo.  Como resultado, el mecanismo, por ejemplo, implementado en FreeRTOS, se simplificará al estado que se muestra en la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/tg/n1/hb/tgn1hba-pczt2p5b0dzy0kut-ua.png" alt="imagen"><br><br>  Como puede ver, la lectura del estado inicial del contador de tics del sistema operativo se produce antes de ingresar a un bucle infinito, y debemos encontrar algo para implementar esto.  Una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantilla de</a> diseño viene al rescate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Método de plantilla</a> .    ,         ,    ,      ,      Execute(),     , ..    .     ,        (   ),      . <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rtos</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lastWakeTime = wGetTicks() ; Execute(); } ... tTime lastWakeTime = <span class="hljs-number"><span class="hljs-number">0</span></span>ms ; ... }</code> </pre> <br>     Run  Rtos,      Execute(),   Run()  Thread.      Rtos ,       Run()   Thread. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Run() ; }</code> </pre><br>     <i>SleepUntil()</i> ,          .  ,           ,         ,     <i>SleepUntil()</i> ,        .        : <br><img src="https://habrastorage.org/webt/aw/nx/ts/awnxtsvd-odgyfaagkl3egc_tvs.png" alt="imagen"><br><br><div class="spoiler"> <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * * Author : Sergey Kolody *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; void SleepUntil(const tTime timeOut = 1000ms) { wSleepUntil(lastWakeTime, timeOut); }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Rtos ; private: tTaskHandle handle ; tTaskContext context ; tTime lastWakeTime = 0ms ; void Run() { lastWakeTime = wGetTicks() ; Execute(); } } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Thread ; private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Run() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><br><h2>  Eventos </h2><br>  , ,    ,    ,      ,   ,     .  ,     . <br><br>         ,     ,        ,    ,     ,         ,     ,             . ,          .      ,      ,     ,            ,        . <br><br><img src="https://habrastorage.org/webt/gv/na/8k/gvna8ktlrzvrposxbpwhzpn0keq.png"><br><br>    : <br><br><pre> <code class="cpp hljs">OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  ,    10000ms,    0    1. void SomeTask::Execute() { while(true) { using OsWrapper::operator""ms ; Sleep(1000ms); event.Signal() ; //      0   1. Sleep(1000ms); event.SetMaskBits(4) //    2. event.Signal() ; //      2. } } ; void AnotherTask::Execute() { while(true) { using namespace::OsWrapper ; //,      ,    10000ms if ((event.Wait() &amp; defaultTaskMaskBits) != 0) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; } } } ;</span></span></code> </pre><br><br><h2> ,    </h2><br>         ,         ,   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub OsWrapper</a> .   ,   : <br><pre> <code class="cpp hljs">OsWrapper::MailBox&lt;tU32, <span class="hljs-number"><span class="hljs-number">10</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    10   int void ReceiveTask::Execute() { tU32 item; while(true) { using OsWrapper::operator""ms ; if (queue.Get(item, 10000ms)) { //    GPIOC-&gt;ODR ^= (1 &lt;&lt; 9); } } } ; void SendTask::Execute() { tU32 item = 0U; while(true) { queue.Put(item); item ++; SleepUntil(1000ms); } } ;</span></span></code> </pre><br><br><h2>      </h2><br>  ,       ,     ,   :  <i>LedTask</i> ,     2  ,    2     <i>myTask</i> ,   10  ,    ,    .          2 .      ,     <i>event</i> .      ,     :) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OsWrapper::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>ms ; OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OsWrapper::Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.Wait() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tMyTaskStack = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;OsWrapper::tStack, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tMyTaskStack Stack; <span class="hljs-comment"><span class="hljs-comment">//C++17   IAR 8.30 } ; class LedTask : public OsWrapper::Thread { public: virtual void Execute() override { while(true) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; using OsWrapper::operator""ms ; SleepUntil(2000ms); event.Signal() ; } } using tLedStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tLedStack Stack; //C++17   IAR 8.30 } ; MyTask myTask; LedTask ledTask; int main() { using namespace OsWrapper ; Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask", ThreadPriority::lowest, MyTask::Stack.size()) ; Rtos::CreateThread(ledTask, LedTask::Stack.data()) ; Rtos::Start(); return 0; }</span></span></code> </pre> <br><br><h2>  Conclusión </h2><br>           . ,    ++           ++ .          ++. <br>         ,   ++, ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b> </b></a> ,      ,    ,         ,    ,    .         ,       . <br><br>          ,   ,          ++ :) <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clion</a> .     ,           ,      IAR toolchain,   ,  ,   elf ,   hex , ,      GDB.     —   ,     ,      ,    2 ,      ,   ,    ,      .     ,     Clion.     ,   IAR toolchain ,  . <br><br>      IAR       8.30.1,        .   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">XNUCLEO-F411RE</a> ,  ST-Link.   ,  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clion</a> —   ,    :) <br><br><img src="https://habrastorage.org/webt/tx/m_/e8/txm_e8pms1viazgy6cypd-kjj3q.png" alt="imagen"><br><br>   <i>IAR</i>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  IAR 8.30.1</a>    ,    ,      github,   ,        ,               FreeRtos. <br><br>  Z.Y.      GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420467/">https://habr.com/ru/post/es420467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420457/index.html">Descripción general del software de impresión 3D Simplify3D</a></li>
<li><a href="../es420459/index.html">Icono con un contador en la barra de herramientas superior: un ejemplo de una variedad de enfoques para una tarea</a></li>
<li><a href="../es420461/index.html">10 citas de malos diseñadores</a></li>
<li><a href="../es420463/index.html">ICO merecidamente en declive, pero tienen la oportunidad de cambiar</a></li>
<li><a href="../es420465/index.html">Variables Nginx con njs: simple, indoloro y a través de JavaScript</a></li>
<li><a href="../es420469/index.html">Características del uso de druida en el ejemplo de compañeros de clase</a></li>
<li><a href="../es420471/index.html">Tres informes técnicos RIT 2018 de Plesk</a></li>
<li><a href="../es420473/index.html">Libros para gerentes novatos o por qué es tan importante leer</a></li>
<li><a href="../es420475/index.html">Comparación de las máquinas de corte por láser Raylogic 11G y Raylogic V12</a></li>
<li><a href="../es420477/index.html">Revisión de HyperX Cloud Stinger Core: un auricular ligero y resistente para personajes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>