<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùóÔ∏è üòé üë©üèº‚Äçüé§ Escrevendo um clone do mecanismo Doom: lendo informa√ß√µes do mapa üï¢ ‚úäüèº ‚úçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 O objetivo deste projeto √© criar um clone do mecanismo DOOM usando os recursos liberados com o Ultimate DOOM ( vers√£o do Steam ). 

 E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevendo um clone do mecanismo Doom: lendo informa√ß√µes do mapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="imagem"></div><br><h2>  1. Introdu√ß√£o </h2><br>  O objetivo deste projeto √© criar um clone do mecanismo DOOM usando os recursos liberados com o Ultimate DOOM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">vers√£o do Steam</a> ). <br><br>  Ele ser√° apresentado na forma de um tutorial - n√£o quero obter o m√°ximo desempenho no c√≥digo, mas apenas criar uma vers√£o funcional e, posteriormente, come√ßarei a aprimor√°-lo e a otimiz√°-lo. <br><br>  N√£o tenho experi√™ncia na cria√ß√£o de jogos ou mecanismos de jogos e pouca experi√™ncia na reda√ß√£o de artigos, para que voc√™ possa sugerir suas pr√≥prias altera√ß√µes ou at√© reescrever completamente o c√≥digo. <br><br>  Aqui est√° uma lista de recursos e links. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Livro Jogo Motor Black Book: DOOM Fabien Sanglar</a> .  Um dos melhores livros sobre DOOM internos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Wiki Doom</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte DOOM</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo-fonte Chocolate Doom</a> <br><a name="habracut"></a><br><h3>  Exig√™ncias </h3><br><ul><li>  Visual Studio: qualquer IDE serve;  Vou trabalhar no Visual Studio 2017. </li><li>  SDL2: bibliotecas. </li><li>  DOOM: Uma c√≥pia da vers√£o Steam do Ultimate DOOM, precisamos apenas de um arquivo WAD. </li></ul><br><h3>  Opcional </h3><br><ul><li>  Slade3: uma boa ferramenta para testar nosso trabalho. </li></ul><br><h3>  Pensamentos </h3><br>  N√£o sei, posso concluir este projeto, mas farei o meu melhor para isso. <br><br>  O Windows ser√° minha plataforma de destino, mas como eu uso o SDL, ele far√° o mecanismo funcionar em qualquer outra plataforma. <br><br>  Enquanto isso, instale o Visual Studio! <br><br>  O projeto foi renomeado de Handmade DOOM para Do It Yourself Doom com SLD (DIY Doom), para que n√£o fosse confundido com outros projetos chamados ‚ÄúHandmade‚Äù.  Existem algumas capturas de tela no tutorial, onde ainda √© chamado Handmade DOOM. <br><br><h2>  Arquivos WAD </h2><br>  Antes de iniciar a codifica√ß√£o, vamos definir metas e pensar no que queremos alcan√ßar. <br><br>  Primeiro, vamos verificar se conseguimos ler os arquivos de recursos DOOM.  Todos os recursos do DOOM est√£o no arquivo WAD. <br><br><h2>  O que √© um arquivo WAD? </h2><br>  "Onde est√£o todos os meus dados"?  ("Onde est√£o todos os meus dados?") Eles est√£o no WAD!  O WAD √© um arquivo de todos os recursos do DOOM (e jogos baseados no DOOM) localizados em um √∫nico arquivo. <br><br>  Os desenvolvedores do Doom criaram esse formato para simplificar a cria√ß√£o de modifica√ß√µes no jogo. <br><br><h2>  Anatomia do arquivo WAD </h2><br>  O arquivo WAD consiste em tr√™s partes principais: o cabe√ßalho (cabe√ßalho), as "partes" (peda√ßos) e os diret√≥rios (diret√≥rios). <br><br><ol><li>  Cabe√ßalho - cont√©m informa√ß√µes b√°sicas sobre o arquivo WAD e o deslocamento do diret√≥rio. </li><li>  N√≥dulos - aqui est√£o armazenados recursos de jogos, dados de mapas, sprites, m√∫sicas etc. </li><li>  Diret√≥rios - A estrutura organizacional para encontrar dados na se√ß√£o global. </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3>  Formato de cabe√ßalho </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tamanho do campo </th><th>  Tipo de dados </th><th>  Conte√∫do </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4 caracteres ASCII </td><td>  String ASCII (com os valores "IWAD" ou "PWAD"). </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  N√∫mero do item do diret√≥rio. </td></tr><tr><td>  0x08-0x0b </td><td>  unsigned int </td><td>  Valor de deslocamento do diret√≥rio no arquivo WAD. </td></tr></tbody></table></div><br><h3>  Formato de Diret√≥rio </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tamanho do campo </th><th>  Tipo de dados </th><th>  Conte√∫do </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  unsigned int </td><td>  O valor do deslocamento no in√≠cio dos dados fixos no arquivo WAD. </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  O tamanho da "pe√ßa" (massa) em bytes. </td></tr><tr><td>  0x08-0x0f </td><td>  8 caracteres ASCII </td><td>  ASCII contendo o nome "pe√ßa". </td></tr></tbody></table></div><br><h2>  Objetivos </h2><br><ol><li>  Crie um projeto. </li><li>  Abra o arquivo WAD. </li><li>  Leia o t√≠tulo. </li><li>  Leia todos os diret√≥rios e exiba-os. </li></ol><br><h2>  Arquitetura </h2><br>  N√£o vamos complicar nada ainda.  Crie uma classe que apenas abra e carregue WAD e chame-a de WADLoader.  Em seguida, escrevemos uma classe que √© respons√°vel pela leitura dos dados, dependendo do formato, e denominamos WADReader.  Tamb√©m precisamos de uma fun√ß√£o <code>main</code> simples que chame essas classes. <br><br>  Nota: essa arquitetura pode n√£o ser √≥tima e, se necess√°rio, a alteraremos. <br><br><h2>  Obtendo o c√≥digo </h2><br>  Vamos come√ßar criando um projeto C ++ vazio.  No Visual Studio, clique em Arquivo-&gt; Novo -&gt; Projeto.  Vamos cham√°-lo de DIYDoom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br>  Vamos adicionar duas novas classes: WADLoader e WADReader.  Vamos come√ßar com a implementa√ß√£o do WADLoader. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br>  A implementa√ß√£o do construtor ser√° simples: inicialize o ponteiro de dados e armazene uma c√≥pia do caminho transferido no arquivo WAD. <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br>  Agora vamos √† implementa√ß√£o da fun√ß√£o auxiliar de carregamento do <code>OpenAndLoad</code> : apenas tentamos abrir o arquivo como bin√°rio e, em caso de falha, exibir um erro. <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Se tudo correr bem, e podemos encontrar e abrir o arquivo, precisamos saber o tamanho do arquivo para alocar mem√≥ria para copiar o arquivo para ele. <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br>  Agora sabemos quanto espa√ßo um WAD completo ocupa e alocamos a quantidade necess√°ria de mem√≥ria. <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br>  Copie o conte√∫do do arquivo para esta mem√≥ria. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br>  Voc√™ deve ter notado que eu usei o tipo <code>m_WADData</code> como o tipo de dados para <code>unint8_t</code> .  Isso significa que eu preciso de uma matriz exata de 1 byte (1 byte * comprimento).  O uso de unint8_t garante que o tamanho seja igual a um byte (8 bits, que pode ser entendido pelo nome do tipo).  Se quis√©ssemos alocar 2 bytes (16 bits), usar√≠amos unint16_t, sobre o qual falaremos mais adiante.  Ao usar esses tipos de c√≥digo, o c√≥digo se torna independente da plataforma.  Vou explicar: se usarmos "int", o tamanho exato de int na mem√≥ria depender√° do sistema.  Se compilarmos ‚Äúint‚Äù em uma configura√ß√£o de 32 bits, obteremos um tamanho de mem√≥ria de 4 bytes (32 bits) e, ao compilar o mesmo c√≥digo em uma configura√ß√£o de 64 bits, obteremos um tamanho de mem√≥ria de 8 bytes (64 bits)!  Pior ainda, compilar o c√≥digo em uma plataforma de 16 bits (voc√™ pode ser um f√£ do DOS) nos fornecer√° 2 bytes (16 bits)! <br><br>  Vamos verificar brevemente o c√≥digo e garantir que tudo funcione.  Mas primeiro precisamos implementar o LoadWAD.  Enquanto o LoadWAD chamar√° "OpenAndLoad" <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  E vamos adicionar ao c√≥digo de fun√ß√£o principal que cria uma inst√¢ncia da classe e tenta carregar o WAD <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>Voc√™ precisar√° inserir o caminho correto para o seu arquivo WAD.</strong>  Vamos l√°! <br><br>  Ai!  Temos uma janela do console que se abre por alguns segundos!  Nada de particularmente √∫til ... o programa funciona?  A ideia!  Vamos dar uma olhada na mem√≥ria e ver o que h√° nela!  Talvez l√° encontremos algo especial!  Primeiro, coloque um ponto de interrup√ß√£o clicando duas vezes √† esquerda do n√∫mero da linha.  Voc√™ deve ver algo assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br>  Coloquei um ponto de interrup√ß√£o imediatamente ap√≥s ler todos os dados do arquivo para examinar a matriz de mem√≥ria e ver o que foi carregado nela.  Agora execute o c√≥digo novamente!  Na janela autom√°tica, vejo os primeiros bytes.  Os primeiros 4 bytes dizem "IWAD"!  √ìtimo, funciona!  Eu nunca pensei que esse dia chegaria!  Ent√£o, tudo bem, voc√™ precisa se acalmar, ainda h√° muito trabalho pela frente! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="Depurar"></div><br><h2>  Ler cabe√ßalho </h2><br>  O tamanho total do cabe√ßalho √© de 12 bytes (de 0x00 a 0x0b), esses 12 bytes s√£o divididos em 3 grupos.  Os primeiros 4 bytes s√£o um tipo de WAD, geralmente "IWAD" ou "PWAD".  O IWAD deve ser o WAD oficial lan√ßado pela ID Software, "PWAD" deve ser usado para mods.  Em outras palavras, essa √© apenas uma maneira de determinar se o arquivo WAD √© um lan√ßamento oficial ou lan√ßado por modders.  Observe que a sequ√™ncia n√£o √© terminada em NULL, portanto, tenha cuidado!  Os pr√≥ximos 4 bytes s√£o int sem sinal, que cont√©m o n√∫mero total de diret√≥rios no final do arquivo.  Os pr√≥ximos 4 bytes indicam o deslocamento do primeiro diret√≥rio. <br><br>  Vamos adicionar uma estrutura que ir√° armazenar informa√ß√µes.  Vou adicionar um novo arquivo de cabe√ßalho e denominar ‚ÄúDataTypes.h‚Äù.  Nele descreveremos todas as estruturas que precisamos. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br>  Agora precisamos implementar a classe WADReader, que ler√° os dados da matriz de bytes carregada do WAD.  Ai!  H√° um truque aqui - os arquivos WAD est√£o no formato big-endian, ou seja, precisaremos mudar os bytes para torn√°-los little-endian (hoje, a maioria dos sistemas usa little endian).  Para isso, adicionaremos duas fun√ß√µes, uma para processar 2 bytes (16 bits) e outra para processar 4 bytes (32 bits);  se precisarmos ler apenas 1 byte, nada precisar√° ser feito. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br>  Agora estamos prontos para ler o cabe√ßalho: conte os quatro primeiros bytes como char e adicione NULL a eles para simplificar nosso trabalho.  No caso do n√∫mero de diret√≥rios e seu deslocamento, voc√™ pode simplesmente usar fun√ß√µes auxiliares para convert√™-las no formato correto. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br>  Vamos juntar tudo, chamar essas fun√ß√µes e imprimir os resultados <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Execute o programa e veja se tudo funciona! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br>  √ìtimo!  A linha IWAD √© claramente vis√≠vel, mas os outros dois n√∫meros est√£o corretos?  Vamos tentar ler diret√≥rios usando essas compensa√ß√µes e ver se funciona! <br><br>  Precisamos adicionar uma nova estrutura para lidar com o diret√≥rio correspondente √†s op√ß√µes acima. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br>  Agora vamos adicionar a fun√ß√£o ReadDirectories: conte o deslocamento e produza-os! <br><br>  Em cada itera√ß√£o, multiplicamos i * 16 para ir para o incremento de deslocamento do pr√≥ximo diret√≥rio. <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Execute o c√≥digo e veja o que acontece.  Uau!  Uma grande lista de diret√≥rios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="Execu√ß√£o 2"></div><br>  A julgar pelo nome fixo, podemos assumir que conseguimos ler os dados corretamente, mas talvez haja uma maneira melhor de verificar isso.  Vamos dar uma olhada nas entradas do diret√≥rio WAD usando o Slade3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br>  Parece que o nome e o tamanho do n√≥dulo correspondem aos dados obtidos usando nosso c√≥digo.  Hoje fizemos um √≥timo trabalho! <br><br><h2>  Outras notas </h2><br><ul><li>  Em algum momento, pensei que seria bom usar o vetor para armazenar diret√≥rios.  Por que n√£o usar o mapa?  Isso ser√° mais r√°pido do que obter dados pela pesquisa vetorial linear.  Esta √© uma m√° ideia.  Ao usar o mapa, a ordem das entradas do diret√≥rio n√£o ser√° rastreada, mas precisamos dessas informa√ß√µes para obter os dados corretos. <br><br>  E outro equ√≠voco: o mapa em C ++ √© implementado como √°rvores vermelho-pretas com tempo de pesquisa O (log N), e as itera√ß√µes no mapa sempre fornecem uma ordem crescente de chaves.  Se voc√™ precisar de uma estrutura de dados que d√™ o tempo m√©dio O (1) e o pior tempo O (N), ser√° necess√°rio usar um mapa n√£o ordenado. </li><li>  <s>Carregar todos os arquivos WAD na mem√≥ria n√£o √© um m√©todo de implementa√ß√£o ideal.</s>  <s>Seria mais l√≥gico simplesmente ler os diret√≥rios no cabe√ßalho da mem√≥ria e retornar ao arquivo WAD e carregar recursos do disco.</s>  <s>Espero que um dia possamos aprender mais sobre o cache.</s> <br><br>  <strong>DOOMReboot</strong> : <em>discordo completamente.</em>  <em>Hoje em dia, 15 MB de RAM s√£o uma ninharia completa, e a leitura da mem√≥ria ser√° muito mais r√°pida que o volumoso fseek, que ter√° que ser usado ap√≥s o download de tudo o que √© necess√°rio para o n√≠vel.</em>  <em>Isso aumentar√° o tempo de download em n√£o menos de um a dois segundos (levo menos de 20 ms para baixar o tempo todo).</em>  <em>fseek usa o sistema operacional.</em>  <em>Qual arquivo √© mais prov√°vel no cache da RAM, mas talvez n√£o.</em>  <em>Mas mesmo se ele estiver l√°, √© um grande desperd√≠cio de recursos e essas opera√ß√µes confundir√£o muitas leituras do WAD em termos de cache da CPU.</em>  <em>O melhor √© que voc√™ pode criar m√©todos de inicializa√ß√£o h√≠bridos e armazenar dados WAD para um n√≠vel que se encaixe no cache L3 dos processadores modernos, onde a economia ser√° incr√≠vel.</em> </li></ul><br><h2>  C√≥digo fonte </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte</a> <br><br><h2>  Dados B√°sicos do Cart√£o </h2><br>  Tendo aprendido a ler o arquivo WAD, vamos tentar usar os dados lidos.  Ser√° √≥timo aprender a ler os dados da miss√£o (n√≠vel / mundo) e aplic√°-los.  Os "peda√ßos" dessas miss√µes (Mission Lumps) devem ser algo complexo e complicado.  Portanto, precisaremos mover e desenvolver o conhecimento gradualmente.  Como primeiro pequeno passo, vamos criar algo como um recurso Automap: um plano bidimensional de um mapa com uma vista superior.  Primeiro, vamos ver o que h√° dentro do Mission Lump. <br><br><h2>  Anatomia do cart√£o </h2><br>  Vamos come√ßar de novo: a descri√ß√£o dos n√≠veis de DOOM √© muito semelhante ao desenho 2D, no qual as paredes s√£o marcadas com linhas.  No entanto, para obter coordenadas 3D, cada parede mede a altura do piso e do teto (XY √© o plano ao longo do qual nos movemos horizontalmente e Z √© a altura que nos permite subir e descer, por exemplo, levantando em um elevador ou pulando de uma plataforma. os componentes de coordenadas s√£o usados ‚Äã‚Äãpara tornar a miss√£o como um mundo 3D, no entanto, para garantir um bom desempenho, o mecanismo tem certas limita√ß√µes: n√£o h√° salas localizadas uma acima da outra nos n√≠veis e o jogador n√£o pode olhar para cima e para baixo.  O rock, por exemplo, foguetes, ascende verticalmente para atingir um alvo localizado em uma plataforma mais alta. <br><br>  Esses recursos curiosos causaram incont√°veis ‚Äã‚Äãholivares sobre se o DOOM √© um mecanismo 2D ou 3D.  Gradualmente, foi alcan√ßado um compromisso diplom√°tico que salvou muitas vidas: as partes concordaram com a designa√ß√£o ‚Äú2.5D‚Äù aceit√°vel para ambos. <br><br>  Para simplificar a tarefa e retornar ao t√≥pico, vamos apenas tentar ler esses dados 2D e ver se eles podem ser usados ‚Äã‚Äãde alguma forma.  Mais tarde, tentaremos renderiz√°-los em 3D, mas, por enquanto, precisamos entender como as partes individuais do mecanismo funcionam juntas. <br><br>  Ap√≥s realizar pesquisas, descobri que cada miss√£o √© composta por um conjunto de "pe√ßas".  Esses "n√≥dulos" s√£o sempre representados no arquivo WAD de um jogo DOOM na mesma ordem. <br><br><ol><li>  <strong>V√©rtices: os</strong> pontos finais das paredes em 2D.  Dois VERTEXs conectados formam um LINEDEF.  Tr√™s VERTEX conectados formam duas paredes / LINEDEF, e assim por diante.  Eles podem ser simplesmente percebidos como os pontos de conex√£o de duas ou mais paredes.  (Sim, a maioria das pessoas prefere o plural "Vertices", mas John Carmack n√£o gostou. Segundo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">merriam-webster</a> , as duas op√ß√µes se aplicam. </li><li>  <strong>LINEDEFS:</strong> linhas formando juntas entre v√©rtices e formando paredes.  Nem todas as linhas (paredes) se comportam da mesma forma; existem sinalizadores que especificam o comportamento dessas linhas. </li><li>  <strong>SIDEDDEFS:</strong> na vida real, as paredes t√™m dois lados - olhamos para um, o segundo est√° do outro lado.  Os dois lados podem ter texturas diferentes, e SIDEDEFS √© o n√≥dulo que cont√©m as informa√ß√µes de textura da parede (LINEDEF). </li><li>  <strong>SETORES:</strong> setores s√£o ‚Äúsalas‚Äù obtidas pela jun√ß√£o do LINEDEF.  Cada setor cont√©m informa√ß√µes como altura do piso e do teto, texturas, valores de ilumina√ß√£o, a√ß√µes especiais, como mover pisos / plataformas / elevadores.  Alguns desses par√¢metros tamb√©m afetam a maneira como as paredes s√£o renderizadas, por exemplo, o n√≠vel de ilumina√ß√£o e o c√°lculo das coordenadas do mapeamento de textura. </li><li>  <strong>SSECTORS:</strong> (subsetores) formam √°reas convexas dentro de um setor que s√£o usadas na renderiza√ß√£o em conjunto com o desvio do BSP e tamb√©m ajudam a determinar onde um jogador est√° em um n√≠vel espec√≠fico.  Eles s√£o bastante √∫teis e costumam ser usados ‚Äã‚Äãpara determinar a posi√ß√£o vertical de um jogador.  Cada SSECTOR consiste em partes conectadas de um setor, por exemplo, de paredes formando um √¢ngulo.  Essas partes das paredes, ou "segmentos", s√£o armazenadas em seu pr√≥prio caro√ßo chamado ... </li><li>  <strong>SEGS:</strong> pe√ßas de parede / LINEDEF;  em outras palavras, esses s√£o os ‚Äúsegmentos‚Äù da parede / LINEDEF.  O mundo √© renderizado ignorando a √°rvore BSP para determinar quais paredes desenhar primeiro (as primeiras s√£o as mais pr√≥ximas).  Embora o sistema funcione muito bem, faz com que os alinhados sejam divididos em dois ou mais SEGs.  Esses SEGs s√£o ent√£o usados ‚Äã‚Äãpara renderizar paredes em vez de LINEDEF.  A geometria de cada SSECTOR √© determinada pelos segs contidos nela. </li><li>  <strong>NODES:</strong> Um n√≥ BSP √© um n√≥ de uma estrutura de √°rvore bin√°ria que armazena dados do subsetor.  √â usado para determinar rapidamente qual SSECTOR (e SEG) est√° na frente do player.  A elimina√ß√£o de SEGs localizados atr√°s do player e, portanto, invis√≠veis, permite que o mecanismo se concentre em SEGs potencialmente vis√≠veis, o que reduz significativamente o tempo de renderiza√ß√£o. </li><li>  <strong>COISAS:</strong> N√≥dulo chamado COISAS √© uma lista de atores de cen√°rios e miss√µes (inimigos, armas, etc.).  Cada elemento desse agrupamento cont√©m informa√ß√µes sobre uma inst√¢ncia do ator / conjunto, por exemplo, o tipo de objeto, o ponto de cria√ß√£o, a dire√ß√£o e assim por diante. </li><li>  <strong>REJEITAR:</strong> esse n√∫mero cont√©m dados sobre quais setores s√£o vis√≠veis de outros setores.  √â usado para determinar quando um monstro aprende sobre a presen√ßa de um jogador.  Tamb√©m √© usado para determinar a faixa de distribui√ß√£o de sons criados pelo player, por exemplo, tiros.  Quando esse som pode ser transmitido para o setor do monstro, ele pode descobrir sobre o jogador.  A tabela REJECT tamb√©m pode ser usada para acelerar o reconhecimento de colis√µes de cartuchos de armas. </li><li>  <strong>BLOCKMAP:</strong> informa√ß√µes de reconhecimento de colis√£o de jogador e movimento de COISA.  Consiste em uma grade que cobre a geometria de toda a miss√£o.  Cada c√©lula da grade cont√©m uma lista de LINEDEFs que est√£o dentro ou se cruzam com ela.  √â usado para acelerar significativamente o reconhecimento de colis√µes: as verifica√ß√µes de colis√£o s√£o necess√°rias apenas para alguns LINEDEF por jogador / COISA, o que economiza significativamente o poder de computa√ß√£o. </li></ol><br>  Ao gerar nosso mapa 2D, focaremos em VERTEXES e LINEDEFS.  Se conseguirmos desenhar os v√©rtices e conect√°-los √†s linhas dadas porlinedef, precisamos gerar um modelo 2D do mapa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="Mapa de demonstra√ß√£o"></div><br>  O cart√£o de demonstra√ß√£o mostrado acima tem as seguintes caracter√≠sticas: <br><br><ul><li>  4 picos <ul><li>  v√©rtice 1 em (10.10) </li><li>  2 principais em (10.100) </li><li>  3 principais em (100, 10) </li><li>  pico 4 in (100.100) </li></ul></li><li>  4 linhas <ul><li>  linha do topo 1 ao 2 </li><li>  linha do top 1 ao 3 </li><li>  linha do top 2 ao 4 </li><li>  linha do top 3 ao 4 </li></ul></li></ul><br><h3>  Formato de v√©rtice </h3><br>  Como voc√™ pode esperar, os dados do v√©rtice s√£o muito simples - apenas x e y (ponto) de algumas coordenadas. <br><br><div class="scrollable-table"><table><thead><tr><th>  Tamanho do campo </th><th>  Tipo de dados </th><th>  Conte√∫do </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Curto assinado </td><td>  Posi√ß√£o X </td></tr><tr><td>  0x02-0x03 </td><td>  Curto assinado </td><td>  Posi√ß√£o Y </td></tr></tbody></table></div><br><h3>  Formato Linedef </h3><br>  O Linedef cont√©m mais informa√ß√µes; descreve a linha que liga os dois v√©rtices e as propriedades dessa linha (que mais tarde se tornar√° uma parede). <br><br><div class="scrollable-table"><table><thead><tr><th>  Tamanho do campo </th><th>  Tipo de dados </th><th>  Conte√∫do </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Curto n√£o assinado </td><td>  Pico inicial </td></tr><tr><td>  0x02-0x03 </td><td>  Curto n√£o assinado </td><td>  Pico final </td></tr><tr><td>  0x04-0x05 </td><td>  Curto n√£o assinado </td><td>  Sinalizadores (veja abaixo para mais detalhes) </td></tr><tr><td>  0x06-0x07 </td><td>  Curto n√£o assinado </td><td>  Tipo de linha / a√ß√£o </td></tr><tr><td>  0x08-0x09 </td><td>  Curto n√£o assinado </td><td>  R√≥tulo do setor </td></tr><tr><td>  0x10-0x11 </td><td>  Curto n√£o assinado </td><td>  Frente e verso (0xFFFF - sem lado) </td></tr><tr><td>  0x12-0x13 </td><td>  Curto n√£o assinado </td><td>  Back sidedef (0xFFFF - sem lado) </td></tr></tbody></table></div><br><h3>  Valores do sinalizador Linedef </h3><br>  Nem todas as linhas (paredes) s√£o desenhadas.  Alguns deles t√™m um comportamento especial. <br><br><div class="scrollable-table"><table><thead><tr><th>  Bit </th><th>  Descri√ß√£o do produto </th></tr></thead><tbody><tr><td>  0 0 </td><td>  Bloqueia o caminho para jogadores e monstros </td></tr><tr><td>  1 </td><td>  Bloquear monstros </td></tr><tr><td>  2 </td><td>  Dupla face </td></tr><tr><td>  3 </td><td>  A textura superior est√° desativada (falaremos sobre isso mais tarde) </td></tr><tr><td>  4 </td><td>  A textura inferior est√° desativada (falaremos sobre isso mais tarde) </td></tr><tr><td>  5 </td><td>  Segredo (mostrado no mapa como uma parede unilateral) </td></tr><tr><td>  6 </td><td>  Obstr√≥i o som </td></tr><tr><td>  7 </td><td>  Nunca mostrado no autocard </td></tr><tr><td>  8 </td><td>  Sempre mostrado no autocard </td></tr></tbody></table></div><br><h2>  Objetivos </h2><br><ol><li>  Crie uma classe de mapa. </li><li>  Leia dados de v√©rtice. </li><li>  Leia os dados alinhados. </li></ol><br><h2>  Arquitetura </h2><br>  Primeiro, vamos criar uma classe e chamar de mapa.  Nele, armazenaremos todos os dados associados ao cart√£o. <br><br>  Por enquanto, pretendo armazenar apenas v√©rtices e alinhamentos como um vetor, para poder aplic√°-los mais tarde. <br><br>  Al√©m disso, vamos complementar o WADLoader e o WADReader para que possamos ler essas duas novas informa√ß√µes. <br><br><h2>  Codifica√ß√£o </h2><br>  O c√≥digo ser√° semelhante ao c√≥digo de leitura do WAD, adicionaremos apenas mais algumas estruturas e as preencheremos com dados do WAD.  Vamos come√ßar adicionando uma nova classe e passando o nome do mapa. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br>  Agora adicione estruturas para ler esses novos campos.  Como j√° fizemos isso v√°rias vezes, basta adicion√°-los todos de uma vez. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, precisamos de uma fun√ß√£o para l√™-los no WADReader, pois ela estar√° pr√≥xima do que fizemos anteriormente. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu acho que n√£o h√° nada novo para voc√™ aqui. </font><font style="vertical-align: inherit;">E agora precisamos chamar essas fun√ß√µes da classe WADLoader. </font><font style="vertical-align: inherit;">Deixe-me declarar os fatos: a sequ√™ncia de n√≥dulos √© importante aqui, encontraremos o nome do mapa no diret√≥rio lump, seguido por todos os n√≥dulos associados aos mapas na ordem especificada. </font><font style="vertical-align: inherit;">Para simplificar nossa tarefa e n√£o rastrear os √≠ndices de massa separadamente, adicionaremos uma enumera√ß√£o que nos permite eliminar os n√∫meros m√°gicos.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m adicionarei uma fun√ß√£o para procurar um mapa por seu nome na lista de diret√≥rios. </font><font style="vertical-align: inherit;">Posteriormente, provavelmente aumentaremos o desempenho dessa etapa usando a estrutura de dados do mapa, porque h√° um n√∫mero significativo de registros aqui, e teremos que analis√°-los com bastante frequ√™ncia, especialmente no in√≠cio do carregamento de recursos como texturas, sprites, sons etc.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uau, estamos quase terminando! </font><font style="vertical-align: inherit;">Agora, vamos apenas contar VERTEXES! </font><font style="vertical-align: inherit;">Repito, j√° fizemos isso antes, agora voc√™ deve entender isso.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, parece que estamos constantemente copiando o mesmo c√≥digo; </font><font style="vertical-align: inherit;">pode ser necess√°rio otimiz√°-lo no futuro, mas por enquanto voc√™ implementar√° o ReadMapLinedef (ou examinar√° o c√≥digo-fonte no link). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toques finais - precisamos chamar essa fun√ß√£o e passar o objeto do mapa para ela.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos mudar a fun√ß√£o principal e ver se tudo funciona. </font><font style="vertical-align: inherit;">Quero carregar o mapa "E1M1", que transferirei para o objeto de mapa.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos executar tudo. </font><font style="vertical-align: inherit;">Uau, um monte de n√∫meros interessantes, mas eles s√£o verdadeiros? </font><font style="vertical-align: inherit;">Vamos conferir! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos ver se o slade pode nos ajudar com isso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos encontrar o mapa no menu slade e ver os detalhes dos peda√ßos. </font><font style="vertical-align: inherit;">Vamos comparar os n√∫meros.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="Vertex"></div><br>  √ìtimo! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E o Linedef? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamb√©m adicionei essa enumera√ß√£o, que tentaremos usar ao renderizar o mapa. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outras notas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No processo de escrever o c√≥digo, li por engano mais bytes do que o necess√°rio e recebi valores incorretos. </font><font style="vertical-align: inherit;">Para depura√ß√£o, comecei a olhar para o deslocamento WAD na mem√≥ria para ver se estava no deslocamento certo. </font><font style="vertical-align: inherit;">Isso pode ser feito usando a janela de mem√≥ria do Visual Studio, que √© uma ferramenta muito √∫til para rastrear bytes ou mem√≥ria (voc√™ tamb√©m pode definir pontos de interrup√ß√£o nesta janela). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ n√£o vir a janela de mem√≥ria, v√° para Debug&gt; Memory&gt; Memory.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vemos os valores na mem√≥ria em hexadecimal. </font><font style="vertical-align: inherit;">Esses valores podem ser comparados com a exibi√ß√£o hexadecimal no slade clicando com o bot√£o direito do mouse em qualquer massa e exibindo-a como hexadecimal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare-os com o endere√ßo do WAD carregado na mem√≥ria. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E a √∫ltima coisa de hoje: vimos todos esses valores de v√©rtices, mas existe uma maneira f√°cil de visualiz√°-los sem escrever c√≥digo? </font><font style="vertical-align: inherit;">N√£o quero perder tempo com isso, apenas para descobrir que estamos nos movendo na dire√ß√£o errada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certamente algu√©m j√° criou um plotter. </font><font style="vertical-align: inherit;">Pesquisei no Google ‚Äúdesenhar pontos em um gr√°fico‚Äù e o primeiro resultado foi o site </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Points - Desmos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nele, voc√™ pode colar n√∫meros da √°rea de transfer√™ncia e ele os desenhar√°. </font><font style="vertical-align: inherit;">Eles devem estar no formato "(x, y)". </font><font style="vertical-align: inherit;">Para obt√™-lo, basta alterar a fun√ß√£o de sa√≠da para a tela.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uau! </font><font style="vertical-align: inherit;">J√° parece um E1M1! </font><font style="vertical-align: inherit;">Conseguimos algo!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="Pontos de plotagem E1M1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ tiver pregui√ßa de fazer isso, aqui est√° um link para um gr√°fico pontilhado: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas vamos dar mais um passo: depois de um pouco de trabalho, podemos conectar esses pontos com base em linhas alinhadas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="V√©rtice de plotagem E1M1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° o link: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E1M1 Plot Vertex</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo fonte</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Refer√™ncias </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom Wiki </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZDoom Wiki</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471552/">https://habr.com/ru/post/pt471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471538/index.html">Da id√©ia de um aplicativo m√≥vel ao MVP no qual os investidores investir√£o</a></li>
<li><a href="../pt471542/index.html">Reconhecimento de texto OCR</a></li>
<li><a href="../pt471544/index.html">Sobre o amor, ou por que o centuri√£o cossaco mudou seu uniforme para um manto uzbeque</a></li>
<li><a href="../pt471548/index.html">Os 5 principais livros a serem lidos por um artista</a></li>
<li><a href="../pt471550/index.html">Onde obter √°udio para o desenvolvimento de jogos e outros projetos comerciais? Bibliotecas com os sons da natureza</a></li>
<li><a href="../pt471554/index.html">Como reduzir os riscos de reivindica√ß√µes fiscais da venda de aplicativos e conte√∫do?</a></li>
<li><a href="../pt471556/index.html">Fujitsu World Tour 2019. Como foi a nossa maior confer√™ncia</a></li>
<li><a href="../pt471558/index.html">M√£e, eu estou na TV: como foi o final do concurso Digital Breakthrough</a></li>
<li><a href="../pt471562/index.html">Superinfec√ß√£o 2: Rubicon de problemas, o fiasco da tecnologia e uma nova esperan√ßa</a></li>
<li><a href="../pt471564/index.html">Amigos RaspberryPi com TP-Link TL-WN727N</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>