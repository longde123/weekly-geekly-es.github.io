<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏿 ™️ 🧘🏽 L'évolution de l'architecture du système de négociation et de compensation de la Bourse de Moscou. 2e partie 🧗🏻 👈🏿 🧙🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la continuation d'une longue histoire sur notre chemin épineux vers la création d'un système puissant et hautement chargé qui assure le f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'évolution de l'architecture du système de négociation et de compensation de la Bourse de Moscou. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moex/blog/444302/"><img src="https://habrastorage.org/webt/fj/7h/zk/fj7hzkntltigzuhy-4zrisejpyu.jpeg"><br><br>  Il s'agit de la continuation d'une longue histoire sur notre chemin épineux vers la création d'un système puissant et hautement chargé qui assure le fonctionnement de la Bourse.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La première partie est ici</a> . <br><a name="habracut"></a><br><h2>  Erreur mystérieuse </h2><br>  Après de nombreux tests, le système de trading et de compensation mis à jour a été mis en service et nous avons rencontré un bug sur lequel il était juste d'écrire une histoire de détective mystique. <br><br>  Peu de temps après le démarrage sur le serveur principal, l'une des transactions a été traitée avec une erreur.  Dans le même temps, tout était en ordre sur le serveur de sauvegarde.  Il s'est avéré qu'une simple opération mathématique de calcul de l'exposant sur le serveur principal a donné un résultat négatif à partir d'un argument valide!  Les relevés se sont poursuivis et dans le registre SSE2, ils ont trouvé une différence d'un bit, qui est responsable de l'arrondi lors de l'utilisation de nombres à virgule flottante. <br><br>  Ils ont écrit un utilitaire de test simple pour calculer l'exposant avec l'ensemble de bits d'arrondi.  Il s'est avéré que dans la version de RedHat Linux que nous utilisions, il y avait un bug dans le travail avec une fonction mathématique lorsque le bit malheureux a été inséré.  Nous l'avons signalé à RedHat, après un certain temps, nous avons reçu un patch de leur part et l'avons roulé.  L'erreur ne s'est plus produite, mais il n'était pas clair d'où venait ce bit?  La fonction <code>fesetround</code> de C. en était responsable Nous avons soigneusement analysé notre code à la recherche de l'erreur alléguée: vérifié toutes les situations possibles;  pris en compte toutes les fonctions utilisant l'arrondi;  essayé de jouer une session qui a échoué;  utilisé différents compilateurs avec différentes options;  utilisé l'analyse statique et dynamique. <br><br>  La cause de l'erreur est introuvable. <br><br>  Ensuite, ils ont commencé à vérifier le matériel: ils ont effectué des tests de charge des processeurs;  vérifié la RAM;  même exécuté des tests pour un scénario très improbable d'une erreur multi-bits dans une cellule.  En vain. <br><br>  En fin de compte, ils se sont installés sur des théories du monde de la physique des hautes énergies: des particules de haute énergie ont pénétré dans notre centre de données, ont traversé la paroi du boîtier, ont frappé le processeur et ont fait que le verrou de déclenchement se bloque dans le même morceau.  Cette théorie absurde était appelée "neutrino".  Si vous êtes loin de la physique des particules élémentaires: les neutrinos n'interagissent guère avec le monde extérieur, et certainement ils ne sont pas capables d'affecter le processeur. <br><br>  Puisqu'il n'a pas été possible de trouver la cause de la panne, au cas où ils auraient exclu le serveur «délinquant» de fonctionner. <br><br>  Après un certain temps, nous avons commencé à améliorer le système de redondance d'UC: nous avons introduit les soi-disant «réserves chaudes» (répliques asynchrones).  Ils ont reçu un flux de transactions pouvant se trouver dans différents centres de données, mais warm ne prend pas en charge l'interaction active avec d'autres serveurs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/4fd/67f/61c4fd67f72a529370bcc7a792ae946e.png"><br><br>  Pourquoi cela at-il été fait?  Si le serveur de sauvegarde échoue, la liaison à chaud avec le serveur principal devient la nouvelle sauvegarde.  Autrement dit, après une panne, le système ne reste pas jusqu'à la fin de la session de trading avec un serveur principal. <br><br>  Et lorsque la nouvelle version du système a été testée et mise en service, une erreur avec un bit d'arrondi s'est à nouveau produite.  De plus, avec l'augmentation du nombre de serveurs chauds, l'erreur a commencé à apparaître plus souvent.  Dans ce cas, le vendeur n'avait rien à présenter, car il n'y a aucune preuve concrète. <br><br>  Lors de la prochaine analyse de la situation, la théorie a émergé que le problème pourrait être lié à l'OS.  Nous avons écrit un programme simple qui appelle la fonction <code>fesetround</code> dans une boucle sans fin, se souvient de l'état actuel et le vérifie pendant le sommeil, et cela se fait dans de nombreux threads concurrents.  Après avoir sélectionné les paramètres de sommeil et le nombre de threads, nous avons commencé à reproduire de manière stable l'échec du bit après environ 5 minutes d'utilisation.  Cependant, le support Red Hat n'a pas pu le reproduire.  Les tests de nos autres serveurs ont montré que seuls ceux avec certains processeurs installés sont affectés par l'erreur.  Dans le même temps, la transition vers un nouveau noyau a résolu le problème.  En fin de compte, nous venons de remplacer le système d'exploitation et la véritable cause du bogue n'est toujours pas claire. <br><br>  Et soudain, l'année dernière, un article est paru sur Habré « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment j'ai trouvé un bug dans les processeurs Intel Skylake</a> ».  La situation qui y est décrite était très similaire à la nôtre, mais l'auteur a avancé plus avant dans l'enquête et avancé la théorie selon laquelle l'erreur était en microcode.  Et lors de la mise à jour des noyaux Linux, les fabricants mettent également à jour le microcode. <br><br><h2>  Poursuite du développement du système </h2><br>  Bien que nous nous soyons débarrassés de l'erreur, cette histoire nous a fait reconsidérer l'architecture du système.  Après tout, nous n'étions pas protégés contre la répétition de tels bugs. <br><br>  Les principes suivants ont constitué la base de nouvelles améliorations du système de sauvegarde: <br><br><ul><li>  Vous ne pouvez faire confiance à personne.  Les serveurs peuvent ne pas fonctionner correctement. </li><li>  Redondance majoritaire. </li><li>  Création d'un consensus.  Comme complément logique à la redondance majoritaire. </li><li>  Des doubles échecs sont possibles. </li><li>  Vitalité.  Le nouveau système de disques de rechange ne devrait pas être pire que le précédent.  Le commerce devrait se dérouler sans heurts jusqu'au dernier serveur. </li><li>  Une légère augmentation du retard.  Tout temps d'arrêt entraîne d'énormes pertes financières. </li><li>  Interaction minimale avec le réseau afin que le retard soit aussi faible que possible. </li><li>  Sélectionnez un nouveau serveur maître en quelques secondes. </li></ul><br>  Aucune des solutions disponibles sur le marché ne nous convenait, et le protocole Raft n'en était qu'à ses balbutiements, nous avons donc créé notre propre solution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/bc0/73e/d50bc073e4a2bbb805b724d0040b18f9.png"><br><br><h2>  Connectivité réseau </h2><br>  En plus du système de sauvegarde, nous avons commencé à moderniser la connectivité réseau.  Le sous-système d'E / S était une multitude de processus qui, de la pire façon, affectaient la gigue et le retard.  Ayant des centaines de processus qui traitent les connexions TCP, nous avons été obligés de basculer constamment entre eux, et à l'échelle microseconde, c'est une opération assez longue.  Mais le pire est que lorsqu'un processus a reçu un paquet à traiter, il l'a envoyé à une file d'attente SystemV, puis a attendu les événements d'une autre file d'attente SystemV.  Cependant, avec un grand nombre de nœuds, l'arrivée d'un nouveau paquet TCP dans un processus et la réception de données dans une file d'attente dans un autre représentent deux événements concurrents pour l'OS.  Dans ce cas, si aucun processeur physique n'est disponible pour les deux tâches, un sera traité et le second se trouvera dans la file d'attente.  Il est impossible de prévoir les conséquences. <br><br>  Dans de telles situations, vous pouvez appliquer un contrôle de priorité de processus dynamique, mais cela nécessitera l'utilisation d'appels système gourmands en ressources.  En conséquence, nous sommes passés à un thread en utilisant le epoll classique, ce qui a considérablement augmenté la vitesse et réduit le temps de traitement de la transaction.  Nous nous sommes également débarrassés de certains processus d'interaction réseau et d'interaction via SystemV, avons considérablement réduit le nombre d'appels système et avons commencé à contrôler les priorités des opérations.  En utilisant un seul sous-système d'E / S, il a été possible d'économiser environ 8 à 17 microsecondes, selon le scénario.  Ce schéma à thread unique a depuis été appliqué sans changement, un flux epoll avec une marge suffit pour desservir toutes les connexions. <br><br><h2>  Traitement des transactions </h2><br>  La charge croissante de notre système a nécessité la modernisation de presque tous ses composants.  Mais, malheureusement, la stagnation de l'augmentation de la vitesse d'horloge du processeur ces dernières années ne nous a plus permis de faire évoluer les processus «de front».  Par conséquent, nous avons décidé de diviser le processus Engine en trois niveaux, le plus chargé étant le système de vérification des risques, qui évalue la disponibilité des fonds dans les comptes et crée les transactions elles-mêmes.  Mais l'argent peut être dans différentes devises, et il était nécessaire de déterminer sur quel principe diviser le traitement des demandes. <br><br>  La solution logique est de diviser par devise: un serveur se négocie en dollars, un autre en livres et un troisième euro.  Mais si, avec un tel schéma, deux transactions sont envoyées pour acheter des devises différentes, alors il y aura un problème de portefeuilles désynchronisés.  Et la synchronisation est difficile et coûteuse.  Par conséquent, il sera correct de tailler séparément sur les portefeuilles et séparément sur les outils.  Soit dit en passant, dans la plupart des échanges occidentaux, la tâche de vérification des risques n'est pas aussi aiguë que la nôtre, donc le plus souvent, cela se fait hors ligne.  Nous devions mettre en place une vérification en ligne. <br><br>  Illustrons par un exemple.  Le trader veut acheter 30 $, et la demande va valider la transaction: on vérifie si ce trader est autorisé à ce mode de trading, s'il a les droits nécessaires.  Si tout est en ordre, la demande est transmise au système de vérification des risques, c'est-à-dire  vérifier la suffisance des fonds pour conclure une transaction.  Il est à noter que le montant requis est actuellement bloqué.  De plus, la demande est redirigée vers le système de trading, qui approuve ou n'approuve pas cette transaction.  Disons que la transaction est approuvée - alors le système de vérification des risques note que l'argent est débloqué et que les roubles sont convertis en dollars. <br><br>  En général, le système de vérification des risques contient des algorithmes complexes et effectue une grande quantité de calculs très gourmands en ressources, et ne vérifie pas seulement le «solde du compte», comme cela peut sembler à première vue. <br><br>  Lorsque nous avons commencé à diviser le processus Engine en niveaux, nous avons rencontré un problème: le code qui était disponible à l'époque aux étapes de validation et de vérification utilisait activement le même tableau de données, ce qui nécessitait de réécrire la base de code entière.  En conséquence, nous avons emprunté une méthodologie pour le traitement des instructions des processeurs modernes: chacun d'eux est divisé en petites étapes et plusieurs actions sont effectuées en parallèle dans un cycle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40f/d5b/011/40fd5b0119fef43d909ce33abc898ff8.png"><br><br>  Après une petite adaptation du code, nous avons créé un pipeline pour le traitement parallèle des transactions, dans lequel la transaction a été divisée en 4 étapes du pipeline: interaction réseau, validation, exécution et publication du résultat <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/90f/55b/dd690f55b9be4e03a50a9ecb3930c746.png"><br><br>  Prenons un exemple.  Nous avons deux systèmes de traitement, série et parallèle.  La première transaction arrive et dans les deux systèmes, elle est validée.  Ensuite, la deuxième transaction arrive: dans un système parallèle, elle est immédiatement mise au travail, et dans un système séquentiel, elle est mise en file d'attente en attendant que la première transaction passe par l'étape de traitement en cours.  Autrement dit, le principal avantage du pipelining est que nous traitons la file d'attente de transactions plus rapidement. <br><br>  Nous avons donc obtenu le système ASTS +. <br><br>  Certes, avec les convoyeurs aussi, tout n'est pas si lisse.  Supposons que nous ayons une transaction qui affecte les tableaux de données dans une transaction voisine, c'est une situation typique pour l'échange.  Une telle transaction ne peut pas être exécutée dans le pipeline, car elle peut affecter d'autres personnes.  Cette situation est appelée risque de données, et ces transactions sont simplement traitées séparément: lorsque les transactions «rapides» dans la file d'attente se terminent, le pipeline s'arrête, le système traite la transaction «lente», puis redémarre le pipeline.  Heureusement, la part de ces transactions dans le flux total est très faible, de sorte que le pipeline s'arrête si rarement qu'il n'affecte pas les performances globales. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e0/131/de5/0e0131de5df810723111aba61853dd77.png"><br><br>  Ensuite, nous avons commencé à résoudre le problème de la synchronisation de trois threads d'exécution.  En conséquence, un système basé sur un tampon circulaire avec des cellules de taille fixe est né.  Dans ce système, tout est soumis à la vitesse de traitement, les données ne sont pas copiées. <br><br><ul><li>  Tous les paquets réseau entrants entrent dans la phase d'allocation. </li><li>  Nous les plaçons dans un tableau et marquons qu'ils sont disponibles pour l'étape n ° 1. </li><li>  La deuxième transaction est arrivée, elle est à nouveau disponible pour l'étape n ° 1. </li><li>  Le premier flux de traitement voit les transactions disponibles, les traite et les transfère à l'étape suivante du deuxième flux de traitement. </li><li>  Ensuite, il traite la première transaction et marque la cellule correspondante avec l'indicateur <code>deleted</code> - il est maintenant disponible pour une nouvelle utilisation. </li></ul><br>  Ainsi, la file d'attente entière est traitée. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/172/d67/3a8172d67dad9c45dc21448dfb74e135.png"><br><br>  Le traitement de chaque étape prend des unités ou des dizaines de microsecondes.  Et si vous utilisez des schémas de synchronisation de système d'exploitation standard, nous perdrons plus de temps sur la synchronisation elle-même.  Par conséquent, nous avons commencé à utiliser spinlock.  Cependant, c'est une très mauvaise tonalité dans un système en temps réel, et RedHat recommande fortement de ne pas le faire, nous utilisons donc le verrouillage de spin pendant 100 ms, puis passons en mode sémaphore pour exclure la possibilité d'un blocage. <br><br>  En conséquence, nous avons atteint une performance d'environ 8 millions de transactions par seconde.  Et à peine deux mois plus tard, dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur le disjoncteur LMAX, ils ont vu la description d'un circuit avec la même fonctionnalité. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b31/498/732/b31498732113050fe76ed4dee7c9c82e.png"><br><br>  Maintenant, à un moment donné, il pourrait y avoir plusieurs fils d'exécution.  Toutes les transactions ont été traitées successivement, dans l'ordre reçu.  En conséquence, les performances de pointe sont passées de 18 000 à 50 000 transactions par seconde. <br><br><h2>  Système de gestion des risques de change </h2><br>  Il n'y a pas de limite à la perfection, et bientôt nous avons recommencé à nous moderniser: dans le cadre d'ASTS +, nous avons commencé à transférer les systèmes de gestion des risques et les opérations de règlement en composants autonomes.  Nous avons développé une architecture moderne flexible et un nouveau modèle de risque hiérarchique, essayé dans la mesure du possible d'utiliser la classe <code>fixed_point</code> au lieu de <code>double</code> . <br><br>  Mais aussitôt le problème s'est posé: comment synchroniser toute la logique métier qui fonctionne depuis de nombreuses années et la transférer vers le nouveau système?  En conséquence, la première version du prototype du nouveau système a dû être abandonnée.  La deuxième version, qui travaille actuellement en production, est basée sur le même code qui fonctionne à la fois dans la partie trading et dans la partie risque.  Pendant le développement, le plus difficile a été de faire fusionner git entre les deux versions.  Notre collègue Evgeny Mazurenok a effectué cette opération chaque semaine et maudit à chaque fois très longtemps. <br><br>  Lors de la sélection d'un nouveau système, nous avons immédiatement dû résoudre le problème d'interaction.  Lors du choix d'un bus de données, il était nécessaire d'assurer une gigue stable et un retard minimal.  Pour cela, le réseau InfiniBand RDMA est le mieux adapté: le temps de traitement moyen est 4 fois inférieur à celui des réseaux Ethernet 10 G.  Mais la vraie différence était dans les centiles - 99 et 99,9. <br><br>  Bien sûr, InfiniBand a ses propres difficultés.  Tout d'abord, une autre API est ibverbs au lieu de sockets.  Deuxièmement, il n'y a presque pas de solutions de messagerie open source largement disponibles.  Nous avons essayé de fabriquer notre prototype, mais cela s'est avéré très difficile, nous avons donc choisi une solution commerciale - Confinity Low Latency Messaging (anciennement IBM MQ LLM). <br><br>  Le problème s'est alors posé de séparer correctement le système de risques.  Si vous retirez simplement le moteur de risque et ne créez pas de nœud intermédiaire, les transactions provenant de deux sources peuvent être mélangées. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41c/b59/4c9/41cb594c970d774c5715a43f43d3f29b.png"><br><br>  Les solutions dites à très faible latence ont un mode de réorganisation: les transactions à partir de deux sources peuvent être organisées dans le bon ordre à la réception, ceci est réalisé en utilisant un canal séparé pour échanger des informations sur la séquence.  Mais nous n'appliquons pas encore ce mode: il complique tout le processus, et dans certaines solutions il n'est pas du tout supporté.  De plus, chaque transaction devrait se voir attribuer les horodatages appropriés, et dans notre schéma, ce mécanisme est très difficile à mettre en œuvre correctement.  Par conséquent, nous avons utilisé le schéma classique avec Message Broker, c'est-à-dire avec un répartiteur qui distribue les messages entre Risk Engine. <br><br>  Le deuxième problème était lié à l'accès client: s'il existe plusieurs passerelles de risque, le client doit se connecter à chacune d'entre elles, et pour cela, vous devrez apporter des modifications à la couche client.  Nous voulions nous éloigner de cela à ce stade, donc dans le schéma actuel de Risk Gateway, ils traitent l'intégralité du flux de données.  Cela limite considérablement le débit maximal, mais simplifie considérablement l'intégration du système. <br><br><h2>  Duplication </h2><br>  Notre système ne doit pas avoir un seul point de défaillance, c'est-à-dire que tous les composants doivent être dupliqués, y compris un courtier de messages.  Nous avons résolu ce problème en utilisant le système CLLM: il contient un cluster RCMS dans lequel deux répartiteurs peuvent travailler en mode maître-esclave, et quand l'un échoue, le système bascule automatiquement vers l'autre. <br><br><h2>  Travailler avec un centre de données de sauvegarde </h2><br>  InfiniBand est optimisé pour fonctionner comme un réseau local, c'est-à-dire pour connecter des équipements montés en rack, et il n'y a aucun moyen de disposer un réseau InfiniBand entre deux centres de données géographiquement distribués.  Par conséquent, nous avons implémenté un pont / répartiteur qui se connecte à la mémoire de messages via des réseaux Ethernet réguliers et relaie toutes les transactions vers le deuxième réseau IB.  Lorsque vous avez besoin d'une migration à partir du centre de données, nous pouvons choisir avec quel centre de données travailler maintenant. <br><br><h2>  Résumé </h2><br>  Tout cela n'a pas été fait en même temps, il a fallu plusieurs itérations du développement d'une nouvelle architecture.  Nous avons créé le prototype en un mois, mais il a fallu plus de deux ans pour finaliser les conditions de travail.  Nous avons essayé de trouver le meilleur compromis entre l'augmentation de la durée du traitement des transactions et l'augmentation de la fiabilité du système. <br><br>  Depuis que le système a été fortement mis à jour, nous avons implémenté la récupération de données à partir de deux sources indépendantes.  Si, pour une raison quelconque, la mémoire de messages ne fonctionne pas correctement, vous pouvez extraire le journal des transactions d'une deuxième source - à partir de Risk Engine.  Ce principe est respecté dans l'ensemble du système. <br><br>  Entre autres choses, nous avons réussi à conserver l'API client afin que ni les courtiers ni personne d'autre ne nécessitent une modification importante de la nouvelle architecture.  J'ai dû changer certaines interfaces, mais je n'ai pas eu besoin d'apporter de modifications importantes au modèle de travail. <br><br>  Nous avons appelé la version actuelle de notre plate-forme Rebus - comme abréviation pour les deux innovations les plus notables en architecture, Risk Engine et BUS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/179/4f2/bf5/1794f2bf5eb87f3ab59df9d9e0d829d8.png"><br><br>  Initialement, nous voulions mettre en évidence uniquement la partie compensation, mais le résultat était un énorme système distribué.  Désormais, les clients peuvent interagir avec Trading Gateway, ou avec compensation, ou avec les deux à la fois. <br><br>  Ce que nous avons finalement réalisé: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/6e7/d8d/2d46e7d8d73032984b0c5ecb8bc1e9e1.png"><br><br>  Réduction du niveau de retard.  Avec un petit volume de transactions, le système fonctionne de la même manière que la version précédente, mais résiste en même temps à une charge beaucoup plus élevée. <br><br>  Le pic de productivité est passé de 50 000 à 180 000 transactions par seconde.  Un autre flux d'informations entrave la poursuite de la croissance. <br><br>     :  matching      Gateway.   Gateway    ,       . <br><br>      ,   -: <br><br><ul><li>      .    . </li><li>   ,  , . ,        .   ,      . </li><li>          ,   . </li><li>          ,      . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444302/">https://habr.com/ru/post/fr444302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444290/index.html">Les bases de la programmation réactive à l'aide de RxJS. Partie 2. Opérateurs et tuyaux</a></li>
<li><a href="../fr444294/index.html">Fonctionnement de l'aviation d'affaires en Russie (centres FBO)</a></li>
<li><a href="../fr444296/index.html">6 ressources et services utiles pour les émigrants potentiels aux États-Unis, en Allemagne et au Canada</a></li>
<li><a href="../fr444298/index.html">Les scientifiques disent qu'ils peuvent remodeler les dinosaures vivants pendant 5 ans</a></li>
<li><a href="../fr444300/index.html">L'évolution de l'architecture du système de négociation et de compensation de la Bourse de Moscou. Partie 1</a></li>
<li><a href="../fr444304/index.html">Huawei et Nutanix annoncent un partenariat avec HCI</a></li>
<li><a href="../fr444306/index.html">Sexe, amour et relations à travers le prisme de l'architecture de microservices</a></li>
<li><a href="../fr444308/index.html">Nouvelles de l'industrie du jeu (11-18 mars 2019)</a></li>
<li><a href="../fr444312/index.html">Installez ReactOS à partir d'une clé USB</a></li>
<li><a href="../fr444314/index.html">Valve commence à combattre les critiques négatives en mer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>