<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚ÄçüöÄ üéß üé¨ Meta Crush Saga: Spiel zur Kompilierungszeit üë©üèº‚Äçüè´ üïú üë®‚Äçüë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf dem Weg zum lang erwarteten Titel des Lead Senior C ++ Over-Engineer habe ich mich letztes Jahr entschlossen, das Spiel, das ich w√§hrend der Arbei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: Spiel zur Kompilierungszeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="Bild"></div><br>  Auf dem Weg zum lang erwarteten Titel des <strong>Lead Senior C ++ Over-Engineer</strong> habe ich mich letztes Jahr entschlossen, das Spiel, das ich w√§hrend der Arbeitszeit entwickle (Candy Crush Saga), unter Verwendung der Quintessenz des modernen C ++ (C ++ 17) neu zu schreiben.  Und so wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta Crush Saga</a> geboren: ein <strong>Spiel, das in der Kompilierungsphase l√§uft</strong> .  Ich war sehr inspiriert von Matt Birners <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nibbler-</a> Spiel, bei dem die Metapher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mithilfe</a> der reinen Metaprogrammierung auf Vorlagen nachgebildet wurde, um die ber√ºhmte Schlange mit dem Nokia 3310 nachzubilden. <br><br>  "Was f√ºr ein <strong>Spiel l√§uft es in der Kompilierungsphase</strong> ?", "Wie sieht es aus?", "Welche Funktionalit√§t von <strong>C ++ 17</strong> haben Sie in diesem Projekt verwendet?", "Was haben Sie gelernt?"  - √Ñhnliche Fragen k√∂nnen Ihnen in den Sinn kommen.  Um sie zu beantworten, m√ºssen Sie entweder den gesamten Beitrag lesen oder sich mit Ihrer inneren Faulheit abfinden und eine Videoversion des Beitrags ansehen - mein Bericht vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meetup-Event</a> in Stockholm: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hinweis: Aus Gr√ºnden Ihrer psychischen Gesundheit und weil Sie sich <em>menschlich irren</em> , werden in diesem Artikel einige alternative Fakten aufgef√ºhrt. <br><a name="habracut"></a><br><h2>  Ein Spiel, das zur Kompilierungszeit l√§uft? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Ich denke, um zu verstehen, was ich unter dem "Konzept" eines <strong>Spiels</strong> verstehe, das <strong>in der Kompilierungsphase ausgef√ºhrt wird</strong> , m√ºssen Sie den Lebenszyklus eines solchen Spiels mit dem Lebenszyklus eines normalen Spiels vergleichen. <br><br><h3>  Der Lebenszyklus eines regul√§ren Spiels: </h3><br>  Als regelm√§√üiger Entwickler von Spielen mit normalem Leben, der an einem normalen Job mit normaler psychischer Gesundheit arbeitet, schreiben Sie normalerweise zun√§chst <strong>Spielelogik</strong> in Ihrer Lieblingssprache (nat√ºrlich in C ++!) Und f√ºhren dann den <strong>Compiler aus</strong> , um dies zu konvertieren, zu oft wie Spaghetti Logik in einer <strong>ausf√ºhrbaren Datei</strong> .  Nach einem Doppelklick auf die <strong>ausf√ºhrbare Datei</strong> (oder ausgehend von der Konsole) erzeugt das Betriebssystem einen <strong>Prozess</strong> .  Dieser <strong>Prozess</strong> f√ºhrt die <strong>Spiellogik aus</strong> , die in 99,42% der F√§lle aus einem Spielzyklus besteht.  <strong>Der Spielzyklus</strong> <strong>aktualisiert den</strong> Status des Spiels gem√§√ü bestimmten Regeln und <strong>Benutzereingaben</strong> und gibt <strong>den</strong> neu berechneten Status des Spiels immer wieder in Pixel wieder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  Der Lebenszyklus eines Spiels, das w√§hrend des Kompilierungsprozesses ausgef√ºhrt wird: </h3><br>  Als √úberentwickler, der sein neues cooles Kompilierungsspiel erstellt, verwenden Sie immer noch Ihre Lieblingssprache (nat√ºrlich immer noch C ++!), Um <strong>Spielelogik</strong> zu schreiben.  Dann geht <strong>die Kompilierungsphase</strong> nach wie vor <strong>weiter</strong> , aber es gibt eine Wendung in der Handlung: Sie <strong>f√ºhren</strong> Ihre <strong>Spielelogik</strong> in der Kompilierungsphase aus.  Sie k√∂nnen es "Ausf√ºhrung" (Kompilierung) nennen.  Und hier ist C ++ sehr n√ºtzlich;  Es verf√ºgt √ºber Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template Meta Programming (TMP)</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">constexpr</a> , mit denen Sie <strong>Berechnungen</strong> in der <strong>Kompilierungsphase durchf√ºhren k√∂nnen</strong> .  Sp√§ter werden wir die Funktionalit√§t betrachten, die daf√ºr verwendet werden kann.  Da wir zu diesem Zeitpunkt die <strong>Logik des</strong> Spiels ausf√ºhren, m√ºssen wir in diesem Moment auch <strong>die Eingabe</strong> des <strong>Spielers</strong> einf√ºgen.  Offensichtlich erstellt unser Compiler bei der Ausgabe weiterhin eine <strong>ausf√ºhrbare Datei</strong> .  Wof√ºr kann es verwendet werden?  Die ausf√ºhrbare Datei enth√§lt nicht mehr <strong>die Spielschleife</strong> , hat jedoch eine sehr einfache Aufgabe: Anzeigen eines neuen <strong>berechneten Status</strong> .  Nennen wir diese <strong>ausf√ºhrbare Datei den</strong> <strong>Renderer</strong> , und <strong>die</strong> <strong>gerenderten</strong> <strong>Daten werden</strong> <strong>gerendert</strong> .  In unserem <strong>Rendering werden</strong> weder sch√∂ne Partikeleffekte noch Umgebungsokklusionsschatten enthalten sein, es wird ASCII sein.  Das ASCII- <strong>Rendering des</strong> neuen berechneten <strong>Status</strong> ist eine praktische Eigenschaft, die dem Player leicht demonstriert werden kann. Zus√§tzlich kopieren wir sie in eine Textdatei.  Warum eine Textdatei?  Offensichtlich, weil es irgendwie mit dem <strong>Code</strong> kombiniert werden <strong>kann</strong> und alle vorherigen Schritte erneut ausf√ºhrt, wodurch eine <strong>Schleife erhalten wird</strong> . <br><br>  Wie Sie bereits verstehen k√∂nnen, besteht das <strong>w√§hrend des Kompilierungsprozesses ausgef√ºhrte</strong> Spiel aus einem <strong>Spielzyklus,</strong> in dem jeder <strong>Frame des</strong> Spiels eine <strong>Kompilierungsphase darstellt</strong> .  Jede <strong>Kompilierungsstufe</strong> berechnet einen neuen <strong>Status des</strong> Spiels, der dem Spieler angezeigt und in den n√§chsten <strong>Frame</strong> / die n√§chste <strong>Kompilierungsstufe</strong> eingef√ºgt werden kann. <br><br>  Sie k√∂nnen dieses gro√üartige Diagramm so oft betrachten, wie Sie m√∂chten, bis Sie verstehen, was ich gerade geschrieben habe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Bevor wir uns mit den Details der Implementierung eines solchen Zyklus befassen, m√∂chten Sie mir sicher die einzige Frage stellen ... <br><br><h3>  "Warum sich die M√ºhe machen, das zu tun?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  Denken Sie wirklich, dass es eine so grundlegende Frage ist, meine C ++ - Metaprogrammier-Idylle zu ruinieren?  Ja, f√ºr nichts im Leben! <br><br><ul><li>  Das erste und wichtigste ist, <strong>dass das in der Kompilierungsphase ausgef√ºhrte Spiel</strong> eine erstaunliche Ausf√ºhrungszeit aufweist, da der Gro√üteil der Berechnungen in der <strong>Kompilierungsphase ausgef√ºhrt wird</strong> .  Die Laufzeitgeschwindigkeit ist der Schl√ºssel zum Erfolg unseres AAA-Spiels mit ASCII-Grafik! </li><li>  Sie verringern die Wahrscheinlichkeit, dass Krebstiere in Ihrem Repository erscheinen, und bitten Sie, das Spiel in <strong>Rust</strong> neu zu schreiben.  Seine gut vorbereitete Rede wird auseinanderfallen, sobald Sie ihm erkl√§ren, dass zum Zeitpunkt der Kompilierung kein ung√ºltiger Zeiger vorhanden sein kann.  <strong>Die</strong> selbstbewussten Programmierer von <strong>Haskell</strong> k√∂nnen sogar die <strong>Typensicherheit</strong> in Ihrem Code best√§tigen. </li><li>  Sie werden den Respekt des <strong>Javascript-</strong> Hipster-K√∂nigreichs gewinnen, in dem jedes neu gestaltete Framework mit einem starken NIH-Syndrom herrschen kann, vorausgesetzt, es hat einen coolen Namen. </li><li>  Ein Freund von mir pflegte zu sagen, dass jede Zeile Perl-Code de facto als sehr sicheres Passwort verwendet werden kann.  Ich bin sicher, dass er nie versucht hat, Passw√∂rter aus der <strong>C ++ - Kompilierungszeit</strong> zu generieren. </li></ul><br>  Und wie?  Bist du mit meinen Antworten zufrieden?  Dann sollte Ihre Frage vielleicht lauten: "Wie schaffen Sie das √ºberhaupt?" <br><br>  Eigentlich wollte ich unbedingt mit der in <strong>C ++ 17</strong> hinzugef√ºgten Funktionalit√§t experimentieren.  Nicht wenige Funktionen sollen die Effektivit√§t der Sprache sowie die Metaprogrammierung (haupts√§chlich constexpr) erh√∂hen.  Ich dachte, anstatt kleine Codebeispiele zu schreiben, w√§re es viel interessanter, all dies in ein Spiel zu verwandeln.  Haustierprojekte sind eine gro√üartige M√∂glichkeit, Konzepte zu lernen, die Sie in Ihrer Arbeit nicht oft verwenden m√ºssen.  Die F√§higkeit, die grundlegende Spielelogik zur Kompilierungszeit erneut auszuf√ºhren, beweist, dass Vorlagen und constepxr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Turing-vollst√§ndige</a> Teilmengen der C ++ - Sprache sind. <br><br><h2>  Meta Crush Saga Game Review </h2><br><h3>  Match-3-Spiel: </h3><br>  <strong>Meta Crush Saga</strong> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiel</a> , das <strong>Bejeweled</strong> und <strong>Candy Crush Saga</strong> √§hnelt.  Der Kern der Spielregeln besteht darin, drei Kacheln mit demselben Muster zu verbinden, um Punkte zu erhalten.  Hier ist ein kurzer Blick auf den <strong>Stand des Spiels</strong> , den ich "gedumpt" habe (Dumping in ASCII ist verdammt einfach zu bekommen): <br><br><pre>  R "(
     Meta Crush Saga      
 ------------------------  
 |  | 
 |  RBGBBYGR | 
 |  | 
 |  | 
 |  YYGRBGBR | 
 |  | 
 |  | 
 |  RBYRGRYG | 
 |  | 
 |  | 
 |  RYBY (R) YGY | 
 |  | 
 |  | 
 |  BGYRYGGR | 
 |  | 
 |  | 
 |  RYBGYBBG | 
 |  | 
 ------------------------  
 &gt; Punktzahl: 9009
 &gt; bewegt sich: 27
 ) " </pre><br><br>  Das Gameplay dieses Match-3-Spiels selbst ist nicht besonders interessant, aber was ist mit der Architektur, auf der alles funktioniert?  Damit Sie es verstehen, werde ich versuchen, jeden Teil des Lebenszyklus dieses Spiels zur <strong>Kompilierungszeit</strong> in Form von Code zu erkl√§ren. <br><br><h3>  Spielstatus-Injektion: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Wenn Sie ein leidenschaftlicher C ++ - Liebhaber oder Pedant sind, haben Sie m√∂glicherweise bemerkt, dass der vorherige Spielstatus-Dump mit dem folgenden Muster beginnt: <strong>R "(</strong> . Tats√§chlich handelt es sich um ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rohes C ++ 11-Zeichenfolgenliteral</a> , was bedeutet, dass ich Sonderzeichen, z. B. <strong>√úbersetzung,</strong> nicht entkommen muss <strong>Zeichenfolgen</strong> : Das rohe Zeichenfolgenliteral wird in einer Datei namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">current_state.txt</a> gespeichert. <br><br>  Wie f√ºgen wir diesen aktuellen Status des Spiels in einen Kompilierungsstatus ein?  F√ºgen wir es einfach zu den Schleifeneing√§ngen hinzu! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  <em>Unabh√§ngig davon</em> , ob es sich um eine <em>TXT-</em> Datei oder eine <em>H-</em> Datei handelt, <em>funktioniert</em> die <strong>Include-</strong> Anweisung des C-Pr√§prozessors auf dieselbe Weise: Sie kopiert den Inhalt der Datei an ihren Speicherort.  Hier kopiere ich das Raw-String-Literal des Spielstatus in ASCII in eine Variable namens <strong>game_state_string</strong> . <br><br>  Beachten Sie, dass die Header- <a href="">Datei loop_inputs.hpp</a> auch die Tastatureingabe auf den aktuellen <a href="">Frame-</a> / Kompilierungsschritt erweitert.  Im Gegensatz zum Status des Spiels ist der Status der Tastatur recht klein und kann leicht als Definition eines Pr√§prozessors abgerufen werden. <br><br><h3>  Berechnen eines neuen Status zur Kompilierungszeit: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Nachdem wir gen√ºgend Daten gesammelt haben, k√∂nnen wir den neuen Status berechnen.  Endlich haben wir den Punkt erreicht, an dem wir die Datei <a href="">main.cpp</a> schreiben m√ºssen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Seltsam, aber dieser C ++ - Code sieht nicht so verwirrend aus, wenn man bedenkt, was er tut.  Der gr√∂√üte Teil des Codes wird in der Kompilierungsphase ausgef√ºhrt, folgt jedoch den traditionellen OOP- und prozeduralen Programmierparadigmen.  Nur die letzte Zeile - das Rendern - ist ein Hindernis, um Berechnungen zur Kompilierungszeit vollst√§ndig ausf√ºhren zu k√∂nnen.  Wie wir weiter unten sehen werden, k√∂nnen wir in C ++ 17 eine recht elegante Metaprogrammierung erzielen, wenn wir ein wenig constexpr an die richtigen Stellen werfen.  Ich finde die Freiheit, die C ++ uns bei der gemischten Ausf√ºhrung zur Laufzeit und Kompilierung gibt, sehr erfreulich. <br><br>  Sie werden auch feststellen, dass dieser Code nur einen Frame ausf√ºhrt, es gibt keine <strong>Spielschleife</strong> .  L√∂sen wir dieses Problem! <br><br><h3>  Wir kleben alles zusammen: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Wenn Sie meine Tricks mit <strong>C ++ abschrecken</strong> , dann hoffe ich, dass es Ihnen nichts ausmacht, meine <strong>Bash-</strong> F√§higkeiten zu sehen.  Tats√§chlich ist meine <strong>Spieleschleife</strong> nichts anderes als ein <a href="">Bash-Skript</a> , das st√§ndig kompiliert wird. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  Tats√§chlich hatte ich einige Probleme, Tastatureingaben von der Konsole zu erhalten.  Anfangs wollte ich parallel zur Kompilierung gehen.  Nach vielen Versuchen und Irrt√ºmern gelang es mir, etwas mehr oder weniger mit dem <code>read</code> von <strong>Bash zum Laufen zu bringen</strong> .  Ich wage es nie, den Zauberer <strong>Bash</strong> im Zweikampf zu bek√§mpfen - diese Sprache ist zu unheimlich! <br><br>  Ich muss also zugeben, dass ich zur Verwaltung des Spielzyklus auf eine andere Sprache zur√ºckgreifen musste.  Obwohl mich technisch nichts daran hinderte, diesen Teil des Codes in C ++ zu schreiben.  Dar√ºber hinaus negiert dies nicht die Tatsache, dass 90% der Logik meines Spiels im <strong>g ++ -</strong> Kompilierungsteam ausgef√ºhrt werden, was ziemlich erstaunlich ist! <br><br><h3>  Ein kleines Gameplay, um Ihren Augen eine Pause zu g√∂nnen: </h3><br>  Nachdem Sie die Qual erlebt haben, die Architektur des Spiels zu erkl√§ren, ist es an der Zeit, auff√§llige Bilder zu malen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Dieses pixelige GIF zeigt, wie ich <strong>Meta Crush Saga</strong> spiele.  Wie Sie sehen k√∂nnen, l√§uft das Spiel reibungslos genug, um in Echtzeit spielbar zu sein.  Offensichtlich ist sie nicht so attraktiv, dass ich ihr Twitch streamen und die neue Pewdiepie werden kann, aber sie arbeitet! <br><br>  Einer der unterhaltsamen Aspekte beim Speichern des <strong>Status eines Spiels</strong> in einer <em>TXT-</em> Datei ist die M√∂glichkeit, Extremf√§lle zu betr√ºgen oder extrem praktisch zu testen. <br><br>  Nachdem ich Sie kurz in die Architektur eingef√ºhrt habe, werden wir uns mit der in diesem Projekt verwendeten C ++ 17-Funktionalit√§t befassen.  Ich werde die Spielelogik nicht im Detail betrachten, da sie sich ausschlie√ülich auf Match-3 bezieht, sondern √ºber Aspekte von C ++ sprechen, die in anderen Projekten angewendet werden k√∂nnen. <br><br><h2>  Meine Tutorials zu C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  Im Gegensatz zu C ++ 14, das haupts√§chlich kleinere Korrekturen enthielt, kann uns der neue C ++ 17-Standard viel bieten.  Es gab Hoffnungen, dass endlich die lang erwarteten Funktionen (Module, Coroutinen, Konzepte ...) endlich auftauchen w√ºrden, aber ... im Allgemeinen ... erschienen sie nicht;  es hat viele von uns ver√§rgert.  Nachdem wir die Trauer beseitigt hatten, fanden wir viele kleine unerwartete Sch√§tze, die dennoch in den Standard fielen. <br><br>  Ich wage zu sagen, dass Kinder, die Metaprogrammierung lieben, dieses Jahr zu verw√∂hnt sind!  Durch separate geringf√ºgige √Ñnderungen und Erg√§nzungen der Sprache k√∂nnen Sie jetzt Code schreiben, der zur Kompilierungszeit und danach zur Laufzeit sehr gut funktioniert. <br><br><h3>  Constepxr in allen Bereichen: </h3><br>  Wie Ben Dean und Jason Turner in ihrem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht zu C ++ 14</a> vorausgesagt haben, k√∂nnen Sie mit C ++ die Kompilierung von Werten zur Kompilierungszeit mit dem allm√§chtigen Schl√ºsselwort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">constexpr</a> schnell verbessern.  Wenn Sie dieses Schl√ºsselwort an den richtigen Stellen suchen, k√∂nnen Sie dem Compiler mitteilen, dass der Ausdruck konstant ist und direkt zur Kompilierungszeit ausgewertet werden kann.  In <strong>C ++ 11 konnten</strong> wir diesen Code bereits schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Obwohl das Schl√ºsselwort <strong>constexpr</strong> sehr leistungsf√§hig ist, gibt es einige Verwendungsbeschr√§nkungen, die es schwierig machen, ausdrucksstarken Code auf diese Weise zu schreiben. <br><br>  <strong>C ++ 14 hat</strong> die Anforderungen an <strong>constexpr</strong> erheblich reduziert und ist viel nat√ºrlicher zu verwenden.  Unsere vorherige Fakult√§tsfunktion kann wie folgt umgeschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong> hat die Regel <strong>beseitigt,</strong> dass eine <strong>constexpr-Funktion</strong> nur aus einer return-Anweisung bestehen sollte, was uns gezwungen hat, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tern√§ren Operator</a> als Hauptbaustein zu verwenden.  Jetzt bringt <strong>C ++ 17</strong> noch mehr <strong>constexpr-</strong> Keyword-Anwendungen, die wir untersuchen k√∂nnen! <br><br><h4>  Verzweigung zur Kompilierungszeit: </h4><br>  Warst du jemals in einer Situation, in der du abh√§ngig von dem Vorlagenparameter, den du manipulierst, ein anderes Verhalten haben musst?  Angenommen, wir ben√∂tigen eine parametrisierte Funktion <code>serialize</code> , die <code>.serialize()</code> wenn das Objekt dies bereitstellt, andernfalls wird dazu <code>to_string</code> .  Wie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag √ºber SFINAE</a> ausf√ºhrlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erl√§utert</a> , m√ºssen Sie h√∂chstwahrscheinlich einen solchen Alien-Code schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Nur in einem Traum k√∂nnten Sie diesen h√§sslichen <strong>Trick von SFINAE-Trick</strong> zu <strong>C ++ 14</strong> in solch gro√üartigen Code umschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Als Sie aufwachten und anfingen, echten <strong>C ++ 14-Code zu</strong> schreiben, gab Ihr Compiler leider eine unangenehme Nachricht √ºber den Aufruf von <code>serialize(42);</code>  .  Es wurde erkl√§rt, dass ein <code>obj</code> Typ <code>int</code> keine Mitgliedsfunktion <code>serialize()</code> .  Egal wie w√ºtend es Sie macht, der Compiler hat Recht!  Mit diesem Code wird er immer versuchen, beide Zweige zu kompilieren - <code>return obj.serialize();</code>  und <br> <code>return std::to_string(obj);</code>  .  F√ºr <code>int</code> branch <code>return obj.serialize();</code>  Es kann sich durchaus als eine Art toter Code <code>has_serialize(obj)</code> , da <code>has_serialize(obj)</code> immer <code>false</code> <code>has_serialize(obj)</code> , der Compiler ihn jedoch weiterhin kompilieren muss. <br><br>  Wie Sie wahrscheinlich vermutet haben, <strong>bewahrt</strong> uns <strong>C ++ 17</strong> vor einer solch unangenehmen Situation, da es m√∂glich war, <strong>constexpr</strong> nach der if-Anweisung hinzuzuf√ºgen, <strong>um</strong> die Verzweigung zur Kompilierungszeit zu erzwingen und nicht verwendete Konstruktionen zu verwerfen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Dies ist offensichtlich eine enorme Verbesserung <strong>gegen√ºber dem SFINAE-Trick, den</strong> wir zuvor anwenden mussten.  Danach bekamen wir die gleiche Sucht wie Ben und Jason - wir begannen √ºberall und immer mit <strong>constexpr</strong> .  <strong>Leider</strong> gibt es einen anderen Ort, an den <strong>das</strong> Schl√ºsselwort <strong>constexpr</strong> passen w√ºrde, aber noch nicht verwendet wird: <strong>Parameter constexpr</strong> . <br><br><h4>  Constexpr-Parameter: </h4><br>  Wenn Sie vorsichtig sind, stellen Sie m√∂glicherweise ein seltsames Muster im vorherigen Codebeispiel fest.  Ich spreche von Schleifeneing√§ngen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Warum ist die Variable <strong>game_state_string</strong> in einem constexpr-Lambda eingekapselt?  Warum macht sie sie nicht zu einer <strong>globalen Variablen constexpr</strong> ? <br><br>  Ich wollte diese Variable und ihren Inhalt tief in einige Funktionen √ºbergeben.  Zum Beispiel m√ºssen <strong>Sie</strong> es an mein <strong>parse_board √ºbergeben</strong> und in einigen konstanten Ausdr√ºcken verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(‚Äú...something...‚Äù);</span></span></code> </pre> <br>  Wenn wir diesen Weg gehen, beschwert sich der m√ºrrische Compiler, dass der Parameter <strong>game_state_string</strong> kein konstanter Ausdruck ist.  Wenn ich mein Kachelarray erstelle, muss ich seine feste Kapazit√§t direkt berechnen (wir k√∂nnen zur Kompilierungszeit keine Vektoren verwenden, da sie eine Speicherzuweisung erfordern) und es als Argument an die Wertvorlage in <strong>std :: array √ºbergeben</strong> .  Daher muss der Ausdruck <strong>parse_board_size (game_state_string)</strong> ein konstanter Ausdruck sein.  Obwohl <strong>parse_board_size</strong> explizit als <strong>constexpr</strong> <strong>markiert</strong> ist, ist und kann <strong>game_state_string</strong> nicht sein!  In diesem Fall st√∂ren uns zwei Regeln: <br><br><ul><li>  Argumente einer constexpr-Funktion sind nicht constexpr! </li><li>  Und wir k√∂nnen constexpr nicht vor ihnen hinzuf√ºgen! </li></ul><br>  All dies <strong>l√§uft</strong> darauf hinaus, dass <strong>constexpr-Funktionen</strong> sowohl f√ºr die Berechnung der Laufzeit als auch der Kompilierungszeit anwendbar sein <strong>M√úSSEN</strong> .  Unter der Annahme, dass <strong>constexpr-Parameter vorhanden sind</strong> , k√∂nnen diese zur Laufzeit nicht verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Gl√ºcklicherweise gibt es eine M√∂glichkeit, dieses Problem zu l√∂sen.  Anstatt den Wert als regul√§ren Parameter einer Funktion zu akzeptieren, k√∂nnen wir diesen Wert in einen Typ einkapseln und diesen Typ als Vorlagenparameter √ºbergeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  In diesem Codebeispiel erstelle ich einen <strong>GameString-</strong> Strukturtyp mit einer statischen Elementfunktion constexpr <strong>value ()</strong> , die das Zeichenfolgenliteral zur√ºckgibt, das ich an <strong>parse_board</strong> √ºbergeben <strong>m√∂chte</strong> .  In <strong>parse_board erhalte</strong> ich diesen Typ √ºber den Vorlagenparameter <strong>GameStringType</strong> , wobei die Regeln zum Extrahieren von Vorlagenargumenten verwendet werden.  Mit einem <strong>GameStringType</strong> kann <strong>ich</strong> aufgrund der Tatsache, dass <strong>value ()</strong> constexpr ist, einfach zum richtigen Zeitpunkt den statischen Member-Funktionswert <strong>()</strong> aufrufen, um ein String-Literal auch an Stellen abzurufen, an denen konstante Ausdr√ºcke ben√∂tigt werden. <br><br>  Wir haben es geschafft, das Literal zu kapseln, um es mit <strong>constexpr</strong> irgendwie an <strong>parse_board zu</strong> √ºbergeben.  Es ist jedoch sehr √§rgerlich, jedes Mal einen neuen Typ definieren zu m√ºssen, wenn Sie ein neues <strong>parse_board-</strong> Literal senden <strong>m√ºssen</strong> : "... <strong>etwas1</strong> ...", "... <strong>etwas2</strong> ...".  Um dieses Problem in <strong>C ++ 11</strong> zu l√∂sen, k√∂nnen Sie eine h√§ssliche Makro- und indirekte Adressierung mit anonymer Union und Lambda anwenden.  Michael Park hat dieses Thema in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem seiner Beitr√§ge gut erkl√§rt</a> . <br><br>  In <strong>C ++ 17 ist die</strong> Situation noch besser.  Wenn wir die Anforderungen f√ºr die √úbergabe unseres String-Literal auflisten, erhalten wir Folgendes: <br><br><ul><li>  Funktion generiert </li><li>  Das ist constexpr </li><li>  Mit einem eindeutigen oder anonymen Namen </li></ul><br>  Diese Anforderungen sollten Ihnen einen Hinweis geben.  Was wir brauchen, ist <strong>constexpr Lambda</strong> !  Und in <strong>C ++ 17 haben sie</strong> ganz nat√ºrlich die M√∂glichkeit hinzugef√ºgt, das <strong>Schl√ºsselwort constexpr</strong> f√ºr Lambda-Funktionen zu verwenden.  Wir k√∂nnen unseren Beispielcode wie folgt umschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return ‚Äú...something...‚Äù; }); // ^    constexpr.</span></span></code> </pre> <br>  Glauben Sie mir, dies sieht bereits viel praktischer aus als das vorherige Hacken in <strong>C ++ 11</strong> mit Makros.  Ich habe diesen gro√üartigen Trick dank <strong>Bj√∂rn Fahler entdeckt</strong> , einem Mitglied der C ++ Mitap-Gruppe, an der ich teilnehme.  Lesen Sie mehr √ºber diesen Trick in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> .  Es ist auch zu ber√ºcksichtigen, dass das Schl√ºsselwort <strong>constexpr</strong> in diesem Fall tats√§chlich optional ist: Alle <strong>Lambdas</strong> mit der F√§higkeit, <strong>constexpr zu</strong> werden, sind standardm√§√üig diese.  Das explizite Hinzuf√ºgen von <strong>constexpr</strong> ist eine Signatur, die unsere Fehlerbehebung vereinfacht. <br><br>  Jetzt m√ºssen Sie verstehen, warum ich gezwungen war, ein <strong>constexpr</strong> Lambda zu verwenden, um eine Zeichenfolge weiterzugeben, die den Status des Spiels darstellt.  Schauen Sie sich diese Lambda-Funktion an und Sie werden wieder eine andere Frage haben.  Was ist dieser <strong>constexpr_string-</strong> Typ, den ich auch zum <strong>Umschlie√üen des Aktienliteral</strong> verwende? <br><br><h5>  constexpr_string und constexpr_string_view: </h5><br>  Wenn Sie mit Zeichenfolgen arbeiten, sollten Sie sie nicht im C-Stil verarbeiten. Sie m√ºssen all diese nervigen Algorithmen vergessen, die rohe Iterationen ausf√ºhren und auf Null-Vervollst√§ndigung pr√ºfen!  Die von <strong>C ++</strong> angebotene Alternative sind die allm√§chtigen <strong>Algorithmen</strong> <strong>std :: string</strong> und <strong>STL</strong> .  Leider erfordert <strong>std :: string</strong> m√∂glicherweise eine Speicherzuweisung auf dem Heap (auch bei Small String Optimization), um dessen Inhalt zu speichern.  Ein oder zwei Standards zur√ºck, wir k√∂nnten <strong>constexpr new / delete verwenden</strong> oder <strong>constexpr-Allokatoren</strong> an <strong>std :: string √ºbergeben</strong> , aber jetzt m√ºssen wir eine andere L√∂sung finden. <br><br>  Mein Ansatz war es, eine <strong>constexpr_string-</strong> Klasse mit einer festen Kapazit√§t zu schreiben.  Diese Kapazit√§t wird als Parameter an die Wertvorlage √ºbergeben.  Hier ist ein kurzer √úberblick √ºber meine Klasse: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Meine <a href="">constexpr_string-</a> Klasse versucht, die <strong>std :: string-</strong> Schnittstelle so nah wie m√∂glich zu imitieren (f√ºr die Operationen, die ich ben√∂tige): Wir k√∂nnen <strong>Iteratoren des Anfangs und des Endes</strong> anfordern, die <strong>Gr√∂√üe (Gr√∂√üe)</strong> <a href="">abrufen</a> , auf die <strong>Daten (Daten)</strong> zugreifen, einen Teil davon <strong>l√∂schen (l√∂schen)</strong> , abrufen Teilstring mit <strong>substr</strong> und so weiter.  Dies <strong>macht</strong> es sehr einfach, einen Code von <strong>std :: string</strong> in <strong>constexpr_string</strong> zu <strong>konvertieren</strong> .  Sie fragen sich vielleicht, was passiert, wenn wir Operationen verwenden m√ºssen, die normalerweise in <strong>std :: string hervorgehoben werden m√ºssen</strong> .  In solchen F√§llen musste ich sie in <strong>unver√§nderliche Operationen</strong> konvertieren, die eine neue Instanz von <strong>constexpr_string erstellen</strong> . <br><br>  Werfen wir einen Blick auf die <strong>Append-</strong> Operation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  Sie ben√∂tigen keinen Fields-Preis, um davon auszugehen, dass bei einer Zeichenfolge der Gr√∂√üe <strong>N</strong> und einer Zeichenfolge der Gr√∂√üe <strong>M</strong> eine Zeichenfolge der Gr√∂√üe <strong>N + M</strong> ausreicht, um deren Verkettung zu speichern.  Wir verschwenden m√∂glicherweise einen Teil des "Repository zur Kompilierungszeit", da beide Leitungen m√∂glicherweise nicht die gesamte Kapazit√§t nutzen, dies ist jedoch aus Bequemlichkeitsgr√ºnden ein eher geringer Preis.  <strong>Nat√ºrlich habe</strong> ich auch ein Duplikat von <strong>std :: string_view geschrieben</strong> , das <a href="">constexpr_string_view</a> hei√üt. <br><br>  Mit diesen beiden Klassen war ich bereit, eleganten Code zu schreiben, um meinen <strong>Spielstatus</strong> zu analysieren.  Denken Sie an so etwas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(‚Äú...something...‚Äù); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Es war ziemlich einfach, die Juwelen auf dem Spielfeld zu durchlaufen. Haben Sie in diesem Codebeispiel √ºbrigens eine weitere wertvolle Funktion von <strong>C ++ 17</strong> bemerkt? <br><br>  Ja!  Ich musste die Kapazit√§t von <strong>constexpr_string</strong> beim <strong>Erstellen</strong> nicht explizit angeben.  Bisher mussten wir bei der Verwendung einer <strong>Klassenvorlage</strong> deren Argumente explizit angeben.  Um diese <em>Probleme</em> zu vermeiden, erstellen wir <em>make_xxx-</em> Funktionen, da die Parameter <strong>von Funktionsvorlagen</strong> nachverfolgt werden k√∂nnen.  Sehen Sie, wie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen von Argumenten</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassenvorlagen</a> unser Leben zum Besseren ver√§ndert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  In einigen schwierigen Situationen m√ºssen Sie dem Compiler helfen, die Argumente korrekt zu berechnen.  Wenn Sie auf ein solches Problem sto√üen, lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handb√ºcher f√ºr benutzerdefinierte Argumentberechnungen</a> . <br><br><h4>  Kostenloses Essen von STL: </h4><br>  Nun, wir k√∂nnen immer alles selbst umschreiben.  Aber vielleicht haben Komiteemitglieder in der Standardbibliothek gro√üz√ºgig etwas f√ºr uns vorbereitet? <br><br><h5>  Neue Hilfstypen: </h5><br>  In <strong>C ++ 17</strong> werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: variante</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: optional</a> zu den Standardw√∂rterbuchtypen hinzugef√ºgt, basierend auf <strong>constexpr</strong> .  Das erste ist sehr interessant, weil es uns erlaubt, typsichere Assoziationen auszudr√ºcken, aber die Implementierung in der <strong>libstdc ++ - Bibliothek</strong> mit <strong>GCC 7.2</strong> hat Probleme bei der Verwendung konstanter Ausdr√ºcke.  Aus diesem Grund habe ich die Idee aufgegeben, meinem Code eine <strong>std :: -Variante</strong> hinzuzuf√ºgen und nur <strong>std :: optional zu verwenden</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen wir mit </font><strong><font style="vertical-align: inherit;">dem</font></strong><font style="vertical-align: inherit;"> Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen neuen Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">, der entweder einen Wert vom Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder nichts enthalten kann. Dies ist ziemlich √§hnlich zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aussagekr√§ftigen Typen, die einen undefinierten Wert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C # </font></font></strong><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zulassen</font></a><font style="vertical-align: inherit;"> . Schauen wir uns die Funktion </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board an</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die Position des ersten Elements in einem Feld zur√ºckgibt, das best√§tigt, dass das Pr√§dikat korrekt ist. M√∂glicherweise befindet sich kein solches Element auf dem Feld. Um diese Situation zu bew√§ltigen, muss der Positionstyp optional sein:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor mussten wir entweder auf die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semantik von Zeigern</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur√ºckgreifen </font><font style="vertical-align: inherit;">oder einen ‚Äûleeren Zustand‚Äú direkt zum Positionstyp hinzuf√ºgen oder einen Booleschen Wert zur√ºckgeben und den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabeparameter √ºbernehmen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zugegeben, das war ziemlich umst√§ndlich! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige bereits vorhandene Typen erhielten auch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterst√ºtzung </font><font style="vertical-align: inherit;">: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tupel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich werde ihre Verwendung nicht im Detail erkl√§ren, da bereits viel √ºber sie geschrieben wurde, aber ich werde eine meiner Entt√§uschungen teilen. Das Komitee f√ºgte </font><font style="vertical-align: inherit;">dem </font><font style="vertical-align: inherit;">Standard </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syntaktischen Zucker</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzu </font><font style="vertical-align: inherit;">, um die in einem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tupel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthaltenen Werte zu extrahieren </font><font style="vertical-align: inherit;">. Diese neue Art der Deklaration wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strukturierte Bindung bezeichnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verwendet Klammern, um anzugeben, in welchen Variablen das geteilte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tupel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert werden soll </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehr schlau! </font><font style="vertical-align: inherit;">Aber es ist schade, dass die Komiteemitglieder [konnten, wollten nicht, fanden nicht die Zeit, verga√üen] sie freundlich zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr machen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich w√ºrde so etwas erwarten:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir komplexe Container und Hilfstypen, aber wie k√∂nnen wir sie bequem manipulieren? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmen: </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Aktualisieren eines Containers f√ºr die Verarbeitung von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine ziemlich eint√∂nige Aufgabe. </font><font style="vertical-align: inherit;">Im Vergleich dazu </font><font style="vertical-align: inherit;">scheint es einfach genug </font><font style="vertical-align: inherit;">zu sein, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">modifizierende </font></strong><strong><font style="vertical-align: inherit;">Algorithmen zu </font></strong><strong><font style="vertical-align: inherit;">portieren</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist jedoch ziemlich seltsam, dass </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine Fortschritte in diesem Bereich gesehen haben, sondern nur in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zum Beispiel haben die wunderbaren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmen </font><font style="vertical-align: inherit;">keine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signaturen erhalten </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber keine Angst! </font><font style="vertical-align: inherit;">Wie Ben und Jason erkl√§rt haben, k√∂nnen Sie den Algorithmus leicht in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr umwandeln,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indem Sie einfach die aktuelle Implementierung kopieren (aber vergessen Sie nicht die Urheberrechte). </font><font style="vertical-align: inherit;">cppreference ist gut. </font><font style="vertical-align: inherit;">Meine Damen und Herren, ich pr√§sentiere Ihnen Ihre Aufmerksamkeit</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich kann schon von den St√§nden die Schreie der Optimierungsfans h√∂ren! </font><font style="vertical-align: inherit;">Ja, nur das Hinzuf√ºgen von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vor dem von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> freundlicherweise bereitgestellten Beispielcode f√ºhrt zur </font><strong><font style="vertical-align: inherit;">Laufzeit</font></strong><font style="vertical-align: inherit;"> m√∂glicherweise nicht zu einer idealen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir diesen Algorithmus jedoch verbessern m√ºssen, wird er f√ºr die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit bei der Kompilierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ben√∂tigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Soweit ich wei√ü, </font><font style="vertical-align: inherit;">sind einfache L√∂sungen </font><font style="vertical-align: inherit;">f√ºr die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilierungsgeschwindigkeit am</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geschwindigkeit und Fehler: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwickler eines AAA-Spiels sollten in die L√∂sung dieser Probleme investieren, oder? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geschwindigkeit: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich es schaffte, eine halb funktionierende Version von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">, verlief die Arbeit reibungsloser. Tats√§chlich habe ich </font><font style="vertical-align: inherit;">auf meinem alten Laptop mit i5, das auf 1,80 GHz √ºbertaktet wurde, </font><font style="vertical-align: inherit;">etwas mehr als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Bilder pro Sekunde) erreicht (Frequenz ist in diesem Fall wichtig). Wie in jedem Projekt wurde mir schnell klar, dass der zuvor geschriebene Code ekelhaft war, und ich begann, das Parsen des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spielzustands</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mithilfe von </font><strong><font style="vertical-align: inherit;">constexpr_string</font></strong><font style="vertical-align: inherit;"> und Standardalgorithmen </font><font style="vertical-align: inherit;">neu zu schreiben </font><font style="vertical-align: inherit;">. Obwohl dies die Wartung des Codes wesentlich komfortabler machte, wirkten sich die √Ñnderungen ernsthaft auf die Geschwindigkeit aus. Die neue Decke betr√§gt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz des alten Sprichworts √ºber C ++ sind ‚ÄûNull-Kopf-Abstraktionen‚Äú nicht f√ºr </font><strong><font style="vertical-align: inherit;">Berechnungen</font></strong><font style="vertical-align: inherit;"> zur </font><strong><font style="vertical-align: inherit;">Kompilierungszeit</font></strong><font style="vertical-align: inherit;"> anwendbar</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ziemlich logisch, wenn wir den Compiler als Interpreter eines ‚ÄûKompilierungszeitcodes‚Äú betrachten. </font><font style="vertical-align: inherit;">Verbesserungen f√ºr verschiedene Compiler sind weiterhin m√∂glich, aber es gibt auch Wachstumschancen f√ºr uns, die Autoren eines solchen Codes. </font><font style="vertical-align: inherit;">Hier ist eine unvollst√§ndige Liste von Beobachtungen und Tipps, die ich gefunden habe, m√∂glicherweise spezifisch f√ºr GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Arrays</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktionieren viel besser als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein bisschen moderne C ++ - Kosmetik auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einem Array im C-Stil,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Sie m√ºssen einen Preis daf√ºr zahlen, wenn Sie es unter solchen Bedingungen verwenden.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     ¬´¬ª. </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft hat mein Compiler schreckliche Kompilierungsfehler ausgegeben, und meine Codelogik hat darunter gelitten. Aber wie findet man den Ort, an dem sich der K√§fer versteckt? Ohne </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debugger</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf werden die</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dinge komplizierter. Wenn Ihr metaphorischer ‚ÄûBart des Programmierers‚Äú noch nicht auf die Knie gegangen ist (sowohl der metaphorische als auch der echte Bart von mir sind noch weit von diesen Erwartungen entfernt), haben Sie m√∂glicherweise keine Motivation, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Templight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu verwenden </font><font style="vertical-align: inherit;">oder den Compiler zu debuggen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser erster Freund wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert sein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was uns die M√∂glichkeit gibt, den booleschen Wert der Kompilierungszeit zu √ºberpr√ºfen. Unser zweiter Freund wird ein Makro sein, das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr aktiviert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und deaktiviert, </font><strong><font style="vertical-align: inherit;">wo</font></strong><font style="vertical-align: inherit;"> immer dies m√∂glich ist:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit diesem Makro k√∂nnen wir die Logik zur Laufzeit arbeiten lassen, was bedeutet, dass wir einen Debugger daran anh√§ngen k√∂nnen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II - strebe das Gameplay zur Laufzeit vollst√§ndig an: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlich wird </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieses Jahr nicht die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gewinnen </font><font style="vertical-align: inherit;">. Es hat gro√ües Potenzial, aber das Gameplay wird </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Zeitpunkt der Kompilierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht vollst√§ndig ausgef√ºhrt </font><font style="vertical-align: inherit;">. Dies kann Hardcore-Gamer √§rgern ... Ich kann das Bash-Skript nur loswerden, wenn jemand </font><font style="vertical-align: inherit;">in der Kompilierungsphase </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastatureingaben</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und unreine Logik </font><font style="vertical-align: inherit;">hinzuf√ºgt </font><font style="vertical-align: inherit;">(und das ist offener Wahnsinn!). Ich glaube jedoch, dass ich eines Tages die ausf√ºhrbare Datei des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderers</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vollst√§ndig verlassen </font><font style="vertical-align: inherit;">und den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status des Spiels</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilierungszeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anzeigen </font><strong><font style="vertical-align: inherit;">kann</font></strong><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Verr√ºckte mit dem Alias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saarraz hat </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC erweitert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprache das</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstrukt </font><strong><font style="vertical-align: inherit;">static_print</font></strong><font style="vertical-align: inherit;"> hinzuzuf√ºgen </font><font style="vertical-align: inherit;">. Dieses Konstrukt sollte mehrere konstante Ausdr√ºcke oder Zeichenfolgenliterale verwenden und diese in der Kompilierungsphase ausgeben. Ich w√ºrde mich freuen, wenn ein solches Tool zum Standard hinzugef√ºgt oder zumindest </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erweitert </font><strong><font style="vertical-align: inherit;">w√ºrde,</font></strong><font style="vertical-align: inherit;"> damit es konstante Ausdr√ºcke </font><strong><font style="vertical-align: inherit;">akzeptiert</font></strong><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17 kann es</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedoch eine M√∂glichkeit geben, dieses Ergebnis zu erzielen. Compiler geben bereits zwei Dinge aus - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Wenn wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> irgendwie verwalten oder </font><font style="vertical-align: inherit;">an unsere Bed√ºrfnisse anpassen k√∂nnen, erhalten wir bereits eine w√ºrdige Schlussfolgerung. Ich habe insbesondere verschiedene L√∂sungen ausprobiert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veraltetes Attribut</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Ausgabe offensichtlich vorhanden ist und analysiert werden kann, ist der Code leider nicht spielbar! </font><font style="vertical-align: inherit;">Wenn Sie zuf√§llig Mitglied einer Geheimgesellschaft von C ++ - Programmierern sind, die w√§hrend der Kompilierung Ausgaben ausf√ºhren k√∂nnen, werde ich Sie gerne in meinem Team einstellen, um die perfekte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlussfolgerungen: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende habe ich dir mein </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrugsspiel verkauft</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich hoffe, Sie finden diesen Beitrag neugierig und lernen beim Lesen etwas Neues. </font><font style="vertical-align: inherit;">Wenn Sie Fehler oder M√∂glichkeiten zur Verbesserung des Artikels finden, kontaktieren Sie mich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwedenCpp-Team</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daf√ºr </font><font style="vertical-align: inherit;">danken, </font><strong><font style="vertical-align: inherit;">dass</font></strong><font style="vertical-align: inherit;"> ich meinen Projektbericht bei einer ihrer Veranstaltungen durchf√ºhren durfte. </font><font style="vertical-align: inherit;">Dar√ºber hinaus m√∂chte ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Gurdeev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meinen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">tiefen</font></a><font style="vertical-align: inherit;"> Dank </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aussprechen</font></a><font style="vertical-align: inherit;"> , der mir geholfen hat, die wesentlichen Aspekte der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga zu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verbessern </font><font style="vertical-align: inherit;">.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414465/">https://habr.com/ru/post/de414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414451/index.html">"Testerkalender" f√ºr Juni. Der Tester muss den Fehler erkennen, Caner lesen und den Umzug organisieren.</a></li>
<li><a href="../de414453/index.html">Implementieren Sie den Pfadfinder f√ºr KI-Agenten mit NavMesh</a></li>
<li><a href="../de414455/index.html">Algorithmus zur Erzeugung von Farbpaletten</a></li>
<li><a href="../de414459/index.html">Detektoren und Deskriptoren von singul√§ren Punkten FAST, BRIEF, ORB</a></li>
<li><a href="../de414463/index.html">AI selbst hat gelernt, wie man einen Zauberw√ºrfel baut</a></li>
<li><a href="../de414467/index.html">Beitr√§ge von der Minsk C ++ Konferenz CoreHard Spring 2018</a></li>
<li><a href="../de414469/index.html">Sicherheitswoche 22: Zwei Sekunden Smart Locks</a></li>
<li><a href="../de414471/index.html">11 H√∂llenkreise f√ºr diejenigen, denen es an Erfahrung in einem neuen Job mangelt</a></li>
<li><a href="../de414473/index.html">Ninja DVR: Neoline G-Tech X27 Dual Test</a></li>
<li><a href="../de414475/index.html">"Endbenutzer - wir sind bei Ihnen": √úber die Android-Entwicklung in CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>