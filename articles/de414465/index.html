<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚀 🎧 🎬 Meta Crush Saga: Spiel zur Kompilierungszeit 👩🏼‍🏫 🕜 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf dem Weg zum lang erwarteten Titel des Lead Senior C ++ Over-Engineer habe ich mich letztes Jahr entschlossen, das Spiel, das ich während der Arbei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: Spiel zur Kompilierungszeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="Bild"></div><br>  Auf dem Weg zum lang erwarteten Titel des <strong>Lead Senior C ++ Over-Engineer</strong> habe ich mich letztes Jahr entschlossen, das Spiel, das ich während der Arbeitszeit entwickle (Candy Crush Saga), unter Verwendung der Quintessenz des modernen C ++ (C ++ 17) neu zu schreiben.  Und so wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta Crush Saga</a> geboren: ein <strong>Spiel, das in der Kompilierungsphase läuft</strong> .  Ich war sehr inspiriert von Matt Birners <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nibbler-</a> Spiel, bei dem die Metapher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mithilfe</a> der reinen Metaprogrammierung auf Vorlagen nachgebildet wurde, um die berühmte Schlange mit dem Nokia 3310 nachzubilden. <br><br>  "Was für ein <strong>Spiel läuft es in der Kompilierungsphase</strong> ?", "Wie sieht es aus?", "Welche Funktionalität von <strong>C ++ 17</strong> haben Sie in diesem Projekt verwendet?", "Was haben Sie gelernt?"  - Ähnliche Fragen können Ihnen in den Sinn kommen.  Um sie zu beantworten, müssen Sie entweder den gesamten Beitrag lesen oder sich mit Ihrer inneren Faulheit abfinden und eine Videoversion des Beitrags ansehen - mein Bericht vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meetup-Event</a> in Stockholm: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hinweis: Aus Gründen Ihrer psychischen Gesundheit und weil Sie sich <em>menschlich irren</em> , werden in diesem Artikel einige alternative Fakten aufgeführt. <br><a name="habracut"></a><br><h2>  Ein Spiel, das zur Kompilierungszeit läuft? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Ich denke, um zu verstehen, was ich unter dem "Konzept" eines <strong>Spiels</strong> verstehe, das <strong>in der Kompilierungsphase ausgeführt wird</strong> , müssen Sie den Lebenszyklus eines solchen Spiels mit dem Lebenszyklus eines normalen Spiels vergleichen. <br><br><h3>  Der Lebenszyklus eines regulären Spiels: </h3><br>  Als regelmäßiger Entwickler von Spielen mit normalem Leben, der an einem normalen Job mit normaler psychischer Gesundheit arbeitet, schreiben Sie normalerweise zunächst <strong>Spielelogik</strong> in Ihrer Lieblingssprache (natürlich in C ++!) Und führen dann den <strong>Compiler aus</strong> , um dies zu konvertieren, zu oft wie Spaghetti Logik in einer <strong>ausführbaren Datei</strong> .  Nach einem Doppelklick auf die <strong>ausführbare Datei</strong> (oder ausgehend von der Konsole) erzeugt das Betriebssystem einen <strong>Prozess</strong> .  Dieser <strong>Prozess</strong> führt die <strong>Spiellogik aus</strong> , die in 99,42% der Fälle aus einem Spielzyklus besteht.  <strong>Der Spielzyklus</strong> <strong>aktualisiert den</strong> Status des Spiels gemäß bestimmten Regeln und <strong>Benutzereingaben</strong> und gibt <strong>den</strong> neu berechneten Status des Spiels immer wieder in Pixel wieder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  Der Lebenszyklus eines Spiels, das während des Kompilierungsprozesses ausgeführt wird: </h3><br>  Als Überentwickler, der sein neues cooles Kompilierungsspiel erstellt, verwenden Sie immer noch Ihre Lieblingssprache (natürlich immer noch C ++!), Um <strong>Spielelogik</strong> zu schreiben.  Dann geht <strong>die Kompilierungsphase</strong> nach wie vor <strong>weiter</strong> , aber es gibt eine Wendung in der Handlung: Sie <strong>führen</strong> Ihre <strong>Spielelogik</strong> in der Kompilierungsphase aus.  Sie können es "Ausführung" (Kompilierung) nennen.  Und hier ist C ++ sehr nützlich;  Es verfügt über Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template Meta Programming (TMP)</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">constexpr</a> , mit denen Sie <strong>Berechnungen</strong> in der <strong>Kompilierungsphase durchführen können</strong> .  Später werden wir die Funktionalität betrachten, die dafür verwendet werden kann.  Da wir zu diesem Zeitpunkt die <strong>Logik des</strong> Spiels ausführen, müssen wir in diesem Moment auch <strong>die Eingabe</strong> des <strong>Spielers</strong> einfügen.  Offensichtlich erstellt unser Compiler bei der Ausgabe weiterhin eine <strong>ausführbare Datei</strong> .  Wofür kann es verwendet werden?  Die ausführbare Datei enthält nicht mehr <strong>die Spielschleife</strong> , hat jedoch eine sehr einfache Aufgabe: Anzeigen eines neuen <strong>berechneten Status</strong> .  Nennen wir diese <strong>ausführbare Datei den</strong> <strong>Renderer</strong> , und <strong>die</strong> <strong>gerenderten</strong> <strong>Daten werden</strong> <strong>gerendert</strong> .  In unserem <strong>Rendering werden</strong> weder schöne Partikeleffekte noch Umgebungsokklusionsschatten enthalten sein, es wird ASCII sein.  Das ASCII- <strong>Rendering des</strong> neuen berechneten <strong>Status</strong> ist eine praktische Eigenschaft, die dem Player leicht demonstriert werden kann. Zusätzlich kopieren wir sie in eine Textdatei.  Warum eine Textdatei?  Offensichtlich, weil es irgendwie mit dem <strong>Code</strong> kombiniert werden <strong>kann</strong> und alle vorherigen Schritte erneut ausführt, wodurch eine <strong>Schleife erhalten wird</strong> . <br><br>  Wie Sie bereits verstehen können, besteht das <strong>während des Kompilierungsprozesses ausgeführte</strong> Spiel aus einem <strong>Spielzyklus,</strong> in dem jeder <strong>Frame des</strong> Spiels eine <strong>Kompilierungsphase darstellt</strong> .  Jede <strong>Kompilierungsstufe</strong> berechnet einen neuen <strong>Status des</strong> Spiels, der dem Spieler angezeigt und in den nächsten <strong>Frame</strong> / die nächste <strong>Kompilierungsstufe</strong> eingefügt werden kann. <br><br>  Sie können dieses großartige Diagramm so oft betrachten, wie Sie möchten, bis Sie verstehen, was ich gerade geschrieben habe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Bevor wir uns mit den Details der Implementierung eines solchen Zyklus befassen, möchten Sie mir sicher die einzige Frage stellen ... <br><br><h3>  "Warum sich die Mühe machen, das zu tun?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  Denken Sie wirklich, dass es eine so grundlegende Frage ist, meine C ++ - Metaprogrammier-Idylle zu ruinieren?  Ja, für nichts im Leben! <br><br><ul><li>  Das erste und wichtigste ist, <strong>dass das in der Kompilierungsphase ausgeführte Spiel</strong> eine erstaunliche Ausführungszeit aufweist, da der Großteil der Berechnungen in der <strong>Kompilierungsphase ausgeführt wird</strong> .  Die Laufzeitgeschwindigkeit ist der Schlüssel zum Erfolg unseres AAA-Spiels mit ASCII-Grafik! </li><li>  Sie verringern die Wahrscheinlichkeit, dass Krebstiere in Ihrem Repository erscheinen, und bitten Sie, das Spiel in <strong>Rust</strong> neu zu schreiben.  Seine gut vorbereitete Rede wird auseinanderfallen, sobald Sie ihm erklären, dass zum Zeitpunkt der Kompilierung kein ungültiger Zeiger vorhanden sein kann.  <strong>Die</strong> selbstbewussten Programmierer von <strong>Haskell</strong> können sogar die <strong>Typensicherheit</strong> in Ihrem Code bestätigen. </li><li>  Sie werden den Respekt des <strong>Javascript-</strong> Hipster-Königreichs gewinnen, in dem jedes neu gestaltete Framework mit einem starken NIH-Syndrom herrschen kann, vorausgesetzt, es hat einen coolen Namen. </li><li>  Ein Freund von mir pflegte zu sagen, dass jede Zeile Perl-Code de facto als sehr sicheres Passwort verwendet werden kann.  Ich bin sicher, dass er nie versucht hat, Passwörter aus der <strong>C ++ - Kompilierungszeit</strong> zu generieren. </li></ul><br>  Und wie?  Bist du mit meinen Antworten zufrieden?  Dann sollte Ihre Frage vielleicht lauten: "Wie schaffen Sie das überhaupt?" <br><br>  Eigentlich wollte ich unbedingt mit der in <strong>C ++ 17</strong> hinzugefügten Funktionalität experimentieren.  Nicht wenige Funktionen sollen die Effektivität der Sprache sowie die Metaprogrammierung (hauptsächlich constexpr) erhöhen.  Ich dachte, anstatt kleine Codebeispiele zu schreiben, wäre es viel interessanter, all dies in ein Spiel zu verwandeln.  Haustierprojekte sind eine großartige Möglichkeit, Konzepte zu lernen, die Sie in Ihrer Arbeit nicht oft verwenden müssen.  Die Fähigkeit, die grundlegende Spielelogik zur Kompilierungszeit erneut auszuführen, beweist, dass Vorlagen und constepxr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Turing-vollständige</a> Teilmengen der C ++ - Sprache sind. <br><br><h2>  Meta Crush Saga Game Review </h2><br><h3>  Match-3-Spiel: </h3><br>  <strong>Meta Crush Saga</strong> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiel</a> , das <strong>Bejeweled</strong> und <strong>Candy Crush Saga</strong> ähnelt.  Der Kern der Spielregeln besteht darin, drei Kacheln mit demselben Muster zu verbinden, um Punkte zu erhalten.  Hier ist ein kurzer Blick auf den <strong>Stand des Spiels</strong> , den ich "gedumpt" habe (Dumping in ASCII ist verdammt einfach zu bekommen): <br><br><pre>  R "(
     Meta Crush Saga      
 ------------------------  
 |  | 
 |  RBGBBYGR | 
 |  | 
 |  | 
 |  YYGRBGBR | 
 |  | 
 |  | 
 |  RBYRGRYG | 
 |  | 
 |  | 
 |  RYBY (R) YGY | 
 |  | 
 |  | 
 |  BGYRYGGR | 
 |  | 
 |  | 
 |  RYBGYBBG | 
 |  | 
 ------------------------  
 &gt; Punktzahl: 9009
 &gt; bewegt sich: 27
 ) " </pre><br><br>  Das Gameplay dieses Match-3-Spiels selbst ist nicht besonders interessant, aber was ist mit der Architektur, auf der alles funktioniert?  Damit Sie es verstehen, werde ich versuchen, jeden Teil des Lebenszyklus dieses Spiels zur <strong>Kompilierungszeit</strong> in Form von Code zu erklären. <br><br><h3>  Spielstatus-Injektion: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Wenn Sie ein leidenschaftlicher C ++ - Liebhaber oder Pedant sind, haben Sie möglicherweise bemerkt, dass der vorherige Spielstatus-Dump mit dem folgenden Muster beginnt: <strong>R "(</strong> . Tatsächlich handelt es sich um ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rohes C ++ 11-Zeichenfolgenliteral</a> , was bedeutet, dass ich Sonderzeichen, z. B. <strong>Übersetzung,</strong> nicht entkommen muss <strong>Zeichenfolgen</strong> : Das rohe Zeichenfolgenliteral wird in einer Datei namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">current_state.txt</a> gespeichert. <br><br>  Wie fügen wir diesen aktuellen Status des Spiels in einen Kompilierungsstatus ein?  Fügen wir es einfach zu den Schleifeneingängen hinzu! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  <em>Unabhängig davon</em> , ob es sich um eine <em>TXT-</em> Datei oder eine <em>H-</em> Datei handelt, <em>funktioniert</em> die <strong>Include-</strong> Anweisung des C-Präprozessors auf dieselbe Weise: Sie kopiert den Inhalt der Datei an ihren Speicherort.  Hier kopiere ich das Raw-String-Literal des Spielstatus in ASCII in eine Variable namens <strong>game_state_string</strong> . <br><br>  Beachten Sie, dass die Header- <a href="">Datei loop_inputs.hpp</a> auch die Tastatureingabe auf den aktuellen <a href="">Frame-</a> / Kompilierungsschritt erweitert.  Im Gegensatz zum Status des Spiels ist der Status der Tastatur recht klein und kann leicht als Definition eines Präprozessors abgerufen werden. <br><br><h3>  Berechnen eines neuen Status zur Kompilierungszeit: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Nachdem wir genügend Daten gesammelt haben, können wir den neuen Status berechnen.  Endlich haben wir den Punkt erreicht, an dem wir die Datei <a href="">main.cpp</a> schreiben müssen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Seltsam, aber dieser C ++ - Code sieht nicht so verwirrend aus, wenn man bedenkt, was er tut.  Der größte Teil des Codes wird in der Kompilierungsphase ausgeführt, folgt jedoch den traditionellen OOP- und prozeduralen Programmierparadigmen.  Nur die letzte Zeile - das Rendern - ist ein Hindernis, um Berechnungen zur Kompilierungszeit vollständig ausführen zu können.  Wie wir weiter unten sehen werden, können wir in C ++ 17 eine recht elegante Metaprogrammierung erzielen, wenn wir ein wenig constexpr an die richtigen Stellen werfen.  Ich finde die Freiheit, die C ++ uns bei der gemischten Ausführung zur Laufzeit und Kompilierung gibt, sehr erfreulich. <br><br>  Sie werden auch feststellen, dass dieser Code nur einen Frame ausführt, es gibt keine <strong>Spielschleife</strong> .  Lösen wir dieses Problem! <br><br><h3>  Wir kleben alles zusammen: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Wenn Sie meine Tricks mit <strong>C ++ abschrecken</strong> , dann hoffe ich, dass es Ihnen nichts ausmacht, meine <strong>Bash-</strong> Fähigkeiten zu sehen.  Tatsächlich ist meine <strong>Spieleschleife</strong> nichts anderes als ein <a href="">Bash-Skript</a> , das ständig kompiliert wird. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  Tatsächlich hatte ich einige Probleme, Tastatureingaben von der Konsole zu erhalten.  Anfangs wollte ich parallel zur Kompilierung gehen.  Nach vielen Versuchen und Irrtümern gelang es mir, etwas mehr oder weniger mit dem <code>read</code> von <strong>Bash zum Laufen zu bringen</strong> .  Ich wage es nie, den Zauberer <strong>Bash</strong> im Zweikampf zu bekämpfen - diese Sprache ist zu unheimlich! <br><br>  Ich muss also zugeben, dass ich zur Verwaltung des Spielzyklus auf eine andere Sprache zurückgreifen musste.  Obwohl mich technisch nichts daran hinderte, diesen Teil des Codes in C ++ zu schreiben.  Darüber hinaus negiert dies nicht die Tatsache, dass 90% der Logik meines Spiels im <strong>g ++ -</strong> Kompilierungsteam ausgeführt werden, was ziemlich erstaunlich ist! <br><br><h3>  Ein kleines Gameplay, um Ihren Augen eine Pause zu gönnen: </h3><br>  Nachdem Sie die Qual erlebt haben, die Architektur des Spiels zu erklären, ist es an der Zeit, auffällige Bilder zu malen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Dieses pixelige GIF zeigt, wie ich <strong>Meta Crush Saga</strong> spiele.  Wie Sie sehen können, läuft das Spiel reibungslos genug, um in Echtzeit spielbar zu sein.  Offensichtlich ist sie nicht so attraktiv, dass ich ihr Twitch streamen und die neue Pewdiepie werden kann, aber sie arbeitet! <br><br>  Einer der unterhaltsamen Aspekte beim Speichern des <strong>Status eines Spiels</strong> in einer <em>TXT-</em> Datei ist die Möglichkeit, Extremfälle zu betrügen oder extrem praktisch zu testen. <br><br>  Nachdem ich Sie kurz in die Architektur eingeführt habe, werden wir uns mit der in diesem Projekt verwendeten C ++ 17-Funktionalität befassen.  Ich werde die Spielelogik nicht im Detail betrachten, da sie sich ausschließlich auf Match-3 bezieht, sondern über Aspekte von C ++ sprechen, die in anderen Projekten angewendet werden können. <br><br><h2>  Meine Tutorials zu C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  Im Gegensatz zu C ++ 14, das hauptsächlich kleinere Korrekturen enthielt, kann uns der neue C ++ 17-Standard viel bieten.  Es gab Hoffnungen, dass endlich die lang erwarteten Funktionen (Module, Coroutinen, Konzepte ...) endlich auftauchen würden, aber ... im Allgemeinen ... erschienen sie nicht;  es hat viele von uns verärgert.  Nachdem wir die Trauer beseitigt hatten, fanden wir viele kleine unerwartete Schätze, die dennoch in den Standard fielen. <br><br>  Ich wage zu sagen, dass Kinder, die Metaprogrammierung lieben, dieses Jahr zu verwöhnt sind!  Durch separate geringfügige Änderungen und Ergänzungen der Sprache können Sie jetzt Code schreiben, der zur Kompilierungszeit und danach zur Laufzeit sehr gut funktioniert. <br><br><h3>  Constepxr in allen Bereichen: </h3><br>  Wie Ben Dean und Jason Turner in ihrem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht zu C ++ 14</a> vorausgesagt haben, können Sie mit C ++ die Kompilierung von Werten zur Kompilierungszeit mit dem allmächtigen Schlüsselwort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">constexpr</a> schnell verbessern.  Wenn Sie dieses Schlüsselwort an den richtigen Stellen suchen, können Sie dem Compiler mitteilen, dass der Ausdruck konstant ist und direkt zur Kompilierungszeit ausgewertet werden kann.  In <strong>C ++ 11 konnten</strong> wir diesen Code bereits schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Obwohl das Schlüsselwort <strong>constexpr</strong> sehr leistungsfähig ist, gibt es einige Verwendungsbeschränkungen, die es schwierig machen, ausdrucksstarken Code auf diese Weise zu schreiben. <br><br>  <strong>C ++ 14 hat</strong> die Anforderungen an <strong>constexpr</strong> erheblich reduziert und ist viel natürlicher zu verwenden.  Unsere vorherige Fakultätsfunktion kann wie folgt umgeschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong> hat die Regel <strong>beseitigt,</strong> dass eine <strong>constexpr-Funktion</strong> nur aus einer return-Anweisung bestehen sollte, was uns gezwungen hat, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ternären Operator</a> als Hauptbaustein zu verwenden.  Jetzt bringt <strong>C ++ 17</strong> noch mehr <strong>constexpr-</strong> Keyword-Anwendungen, die wir untersuchen können! <br><br><h4>  Verzweigung zur Kompilierungszeit: </h4><br>  Warst du jemals in einer Situation, in der du abhängig von dem Vorlagenparameter, den du manipulierst, ein anderes Verhalten haben musst?  Angenommen, wir benötigen eine parametrisierte Funktion <code>serialize</code> , die <code>.serialize()</code> wenn das Objekt dies bereitstellt, andernfalls wird dazu <code>to_string</code> .  Wie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag über SFINAE</a> ausführlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erläutert</a> , müssen Sie höchstwahrscheinlich einen solchen Alien-Code schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Nur in einem Traum könnten Sie diesen hässlichen <strong>Trick von SFINAE-Trick</strong> zu <strong>C ++ 14</strong> in solch großartigen Code umschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Als Sie aufwachten und anfingen, echten <strong>C ++ 14-Code zu</strong> schreiben, gab Ihr Compiler leider eine unangenehme Nachricht über den Aufruf von <code>serialize(42);</code>  .  Es wurde erklärt, dass ein <code>obj</code> Typ <code>int</code> keine Mitgliedsfunktion <code>serialize()</code> .  Egal wie wütend es Sie macht, der Compiler hat Recht!  Mit diesem Code wird er immer versuchen, beide Zweige zu kompilieren - <code>return obj.serialize();</code>  und <br> <code>return std::to_string(obj);</code>  .  Für <code>int</code> branch <code>return obj.serialize();</code>  Es kann sich durchaus als eine Art toter Code <code>has_serialize(obj)</code> , da <code>has_serialize(obj)</code> immer <code>false</code> <code>has_serialize(obj)</code> , der Compiler ihn jedoch weiterhin kompilieren muss. <br><br>  Wie Sie wahrscheinlich vermutet haben, <strong>bewahrt</strong> uns <strong>C ++ 17</strong> vor einer solch unangenehmen Situation, da es möglich war, <strong>constexpr</strong> nach der if-Anweisung hinzuzufügen, <strong>um</strong> die Verzweigung zur Kompilierungszeit zu erzwingen und nicht verwendete Konstruktionen zu verwerfen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Dies ist offensichtlich eine enorme Verbesserung <strong>gegenüber dem SFINAE-Trick, den</strong> wir zuvor anwenden mussten.  Danach bekamen wir die gleiche Sucht wie Ben und Jason - wir begannen überall und immer mit <strong>constexpr</strong> .  <strong>Leider</strong> gibt es einen anderen Ort, an den <strong>das</strong> Schlüsselwort <strong>constexpr</strong> passen würde, aber noch nicht verwendet wird: <strong>Parameter constexpr</strong> . <br><br><h4>  Constexpr-Parameter: </h4><br>  Wenn Sie vorsichtig sind, stellen Sie möglicherweise ein seltsames Muster im vorherigen Codebeispiel fest.  Ich spreche von Schleifeneingängen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Warum ist die Variable <strong>game_state_string</strong> in einem constexpr-Lambda eingekapselt?  Warum macht sie sie nicht zu einer <strong>globalen Variablen constexpr</strong> ? <br><br>  Ich wollte diese Variable und ihren Inhalt tief in einige Funktionen übergeben.  Zum Beispiel müssen <strong>Sie</strong> es an mein <strong>parse_board übergeben</strong> und in einigen konstanten Ausdrücken verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(“...something...”);</span></span></code> </pre> <br>  Wenn wir diesen Weg gehen, beschwert sich der mürrische Compiler, dass der Parameter <strong>game_state_string</strong> kein konstanter Ausdruck ist.  Wenn ich mein Kachelarray erstelle, muss ich seine feste Kapazität direkt berechnen (wir können zur Kompilierungszeit keine Vektoren verwenden, da sie eine Speicherzuweisung erfordern) und es als Argument an die Wertvorlage in <strong>std :: array übergeben</strong> .  Daher muss der Ausdruck <strong>parse_board_size (game_state_string)</strong> ein konstanter Ausdruck sein.  Obwohl <strong>parse_board_size</strong> explizit als <strong>constexpr</strong> <strong>markiert</strong> ist, ist und kann <strong>game_state_string</strong> nicht sein!  In diesem Fall stören uns zwei Regeln: <br><br><ul><li>  Argumente einer constexpr-Funktion sind nicht constexpr! </li><li>  Und wir können constexpr nicht vor ihnen hinzufügen! </li></ul><br>  All dies <strong>läuft</strong> darauf hinaus, dass <strong>constexpr-Funktionen</strong> sowohl für die Berechnung der Laufzeit als auch der Kompilierungszeit anwendbar sein <strong>MÜSSEN</strong> .  Unter der Annahme, dass <strong>constexpr-Parameter vorhanden sind</strong> , können diese zur Laufzeit nicht verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Glücklicherweise gibt es eine Möglichkeit, dieses Problem zu lösen.  Anstatt den Wert als regulären Parameter einer Funktion zu akzeptieren, können wir diesen Wert in einen Typ einkapseln und diesen Typ als Vorlagenparameter übergeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  In diesem Codebeispiel erstelle ich einen <strong>GameString-</strong> Strukturtyp mit einer statischen Elementfunktion constexpr <strong>value ()</strong> , die das Zeichenfolgenliteral zurückgibt, das ich an <strong>parse_board</strong> übergeben <strong>möchte</strong> .  In <strong>parse_board erhalte</strong> ich diesen Typ über den Vorlagenparameter <strong>GameStringType</strong> , wobei die Regeln zum Extrahieren von Vorlagenargumenten verwendet werden.  Mit einem <strong>GameStringType</strong> kann <strong>ich</strong> aufgrund der Tatsache, dass <strong>value ()</strong> constexpr ist, einfach zum richtigen Zeitpunkt den statischen Member-Funktionswert <strong>()</strong> aufrufen, um ein String-Literal auch an Stellen abzurufen, an denen konstante Ausdrücke benötigt werden. <br><br>  Wir haben es geschafft, das Literal zu kapseln, um es mit <strong>constexpr</strong> irgendwie an <strong>parse_board zu</strong> übergeben.  Es ist jedoch sehr ärgerlich, jedes Mal einen neuen Typ definieren zu müssen, wenn Sie ein neues <strong>parse_board-</strong> Literal senden <strong>müssen</strong> : "... <strong>etwas1</strong> ...", "... <strong>etwas2</strong> ...".  Um dieses Problem in <strong>C ++ 11</strong> zu lösen, können Sie eine hässliche Makro- und indirekte Adressierung mit anonymer Union und Lambda anwenden.  Michael Park hat dieses Thema in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem seiner Beiträge gut erklärt</a> . <br><br>  In <strong>C ++ 17 ist die</strong> Situation noch besser.  Wenn wir die Anforderungen für die Übergabe unseres String-Literal auflisten, erhalten wir Folgendes: <br><br><ul><li>  Funktion generiert </li><li>  Das ist constexpr </li><li>  Mit einem eindeutigen oder anonymen Namen </li></ul><br>  Diese Anforderungen sollten Ihnen einen Hinweis geben.  Was wir brauchen, ist <strong>constexpr Lambda</strong> !  Und in <strong>C ++ 17 haben sie</strong> ganz natürlich die Möglichkeit hinzugefügt, das <strong>Schlüsselwort constexpr</strong> für Lambda-Funktionen zu verwenden.  Wir können unseren Beispielcode wie folgt umschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return “...something...”; }); // ^    constexpr.</span></span></code> </pre> <br>  Glauben Sie mir, dies sieht bereits viel praktischer aus als das vorherige Hacken in <strong>C ++ 11</strong> mit Makros.  Ich habe diesen großartigen Trick dank <strong>Björn Fahler entdeckt</strong> , einem Mitglied der C ++ Mitap-Gruppe, an der ich teilnehme.  Lesen Sie mehr über diesen Trick in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> .  Es ist auch zu berücksichtigen, dass das Schlüsselwort <strong>constexpr</strong> in diesem Fall tatsächlich optional ist: Alle <strong>Lambdas</strong> mit der Fähigkeit, <strong>constexpr zu</strong> werden, sind standardmäßig diese.  Das explizite Hinzufügen von <strong>constexpr</strong> ist eine Signatur, die unsere Fehlerbehebung vereinfacht. <br><br>  Jetzt müssen Sie verstehen, warum ich gezwungen war, ein <strong>constexpr</strong> Lambda zu verwenden, um eine Zeichenfolge weiterzugeben, die den Status des Spiels darstellt.  Schauen Sie sich diese Lambda-Funktion an und Sie werden wieder eine andere Frage haben.  Was ist dieser <strong>constexpr_string-</strong> Typ, den ich auch zum <strong>Umschließen des Aktienliteral</strong> verwende? <br><br><h5>  constexpr_string und constexpr_string_view: </h5><br>  Wenn Sie mit Zeichenfolgen arbeiten, sollten Sie sie nicht im C-Stil verarbeiten. Sie müssen all diese nervigen Algorithmen vergessen, die rohe Iterationen ausführen und auf Null-Vervollständigung prüfen!  Die von <strong>C ++</strong> angebotene Alternative sind die allmächtigen <strong>Algorithmen</strong> <strong>std :: string</strong> und <strong>STL</strong> .  Leider erfordert <strong>std :: string</strong> möglicherweise eine Speicherzuweisung auf dem Heap (auch bei Small String Optimization), um dessen Inhalt zu speichern.  Ein oder zwei Standards zurück, wir könnten <strong>constexpr new / delete verwenden</strong> oder <strong>constexpr-Allokatoren</strong> an <strong>std :: string übergeben</strong> , aber jetzt müssen wir eine andere Lösung finden. <br><br>  Mein Ansatz war es, eine <strong>constexpr_string-</strong> Klasse mit einer festen Kapazität zu schreiben.  Diese Kapazität wird als Parameter an die Wertvorlage übergeben.  Hier ist ein kurzer Überblick über meine Klasse: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Meine <a href="">constexpr_string-</a> Klasse versucht, die <strong>std :: string-</strong> Schnittstelle so nah wie möglich zu imitieren (für die Operationen, die ich benötige): Wir können <strong>Iteratoren des Anfangs und des Endes</strong> anfordern, die <strong>Größe (Größe)</strong> <a href="">abrufen</a> , auf die <strong>Daten (Daten)</strong> zugreifen, einen Teil davon <strong>löschen (löschen)</strong> , abrufen Teilstring mit <strong>substr</strong> und so weiter.  Dies <strong>macht</strong> es sehr einfach, einen Code von <strong>std :: string</strong> in <strong>constexpr_string</strong> zu <strong>konvertieren</strong> .  Sie fragen sich vielleicht, was passiert, wenn wir Operationen verwenden müssen, die normalerweise in <strong>std :: string hervorgehoben werden müssen</strong> .  In solchen Fällen musste ich sie in <strong>unveränderliche Operationen</strong> konvertieren, die eine neue Instanz von <strong>constexpr_string erstellen</strong> . <br><br>  Werfen wir einen Blick auf die <strong>Append-</strong> Operation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  Sie benötigen keinen Fields-Preis, um davon auszugehen, dass bei einer Zeichenfolge der Größe <strong>N</strong> und einer Zeichenfolge der Größe <strong>M</strong> eine Zeichenfolge der Größe <strong>N + M</strong> ausreicht, um deren Verkettung zu speichern.  Wir verschwenden möglicherweise einen Teil des "Repository zur Kompilierungszeit", da beide Leitungen möglicherweise nicht die gesamte Kapazität nutzen, dies ist jedoch aus Bequemlichkeitsgründen ein eher geringer Preis.  <strong>Natürlich habe</strong> ich auch ein Duplikat von <strong>std :: string_view geschrieben</strong> , das <a href="">constexpr_string_view</a> heißt. <br><br>  Mit diesen beiden Klassen war ich bereit, eleganten Code zu schreiben, um meinen <strong>Spielstatus</strong> zu analysieren.  Denken Sie an so etwas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(“...something...”); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Es war ziemlich einfach, die Juwelen auf dem Spielfeld zu durchlaufen. Haben Sie in diesem Codebeispiel übrigens eine weitere wertvolle Funktion von <strong>C ++ 17</strong> bemerkt? <br><br>  Ja!  Ich musste die Kapazität von <strong>constexpr_string</strong> beim <strong>Erstellen</strong> nicht explizit angeben.  Bisher mussten wir bei der Verwendung einer <strong>Klassenvorlage</strong> deren Argumente explizit angeben.  Um diese <em>Probleme</em> zu vermeiden, erstellen wir <em>make_xxx-</em> Funktionen, da die Parameter <strong>von Funktionsvorlagen</strong> nachverfolgt werden können.  Sehen Sie, wie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen von Argumenten</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassenvorlagen</a> unser Leben zum Besseren verändert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  In einigen schwierigen Situationen müssen Sie dem Compiler helfen, die Argumente korrekt zu berechnen.  Wenn Sie auf ein solches Problem stoßen, lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handbücher für benutzerdefinierte Argumentberechnungen</a> . <br><br><h4>  Kostenloses Essen von STL: </h4><br>  Nun, wir können immer alles selbst umschreiben.  Aber vielleicht haben Komiteemitglieder in der Standardbibliothek großzügig etwas für uns vorbereitet? <br><br><h5>  Neue Hilfstypen: </h5><br>  In <strong>C ++ 17</strong> werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: variante</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: optional</a> zu den Standardwörterbuchtypen hinzugefügt, basierend auf <strong>constexpr</strong> .  Das erste ist sehr interessant, weil es uns erlaubt, typsichere Assoziationen auszudrücken, aber die Implementierung in der <strong>libstdc ++ - Bibliothek</strong> mit <strong>GCC 7.2</strong> hat Probleme bei der Verwendung konstanter Ausdrücke.  Aus diesem Grund habe ich die Idee aufgegeben, meinem Code eine <strong>std :: -Variante</strong> hinzuzufügen und nur <strong>std :: optional zu verwenden</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können wir mit </font><strong><font style="vertical-align: inherit;">dem</font></strong><font style="vertical-align: inherit;"> Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen neuen Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">, der entweder einen Wert vom Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder nichts enthalten kann. Dies ist ziemlich ähnlich zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aussagekräftigen Typen, die einen undefinierten Wert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C # </font></font></strong><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zulassen</font></a><font style="vertical-align: inherit;"> . Schauen wir uns die Funktion </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board an</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die Position des ersten Elements in einem Feld zurückgibt, das bestätigt, dass das Prädikat korrekt ist. Möglicherweise befindet sich kein solches Element auf dem Feld. Um diese Situation zu bewältigen, muss der Positionstyp optional sein:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor mussten wir entweder auf die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semantik von Zeigern</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zurückgreifen </font><font style="vertical-align: inherit;">oder einen „leeren Zustand“ direkt zum Positionstyp hinzufügen oder einen Booleschen Wert zurückgeben und den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabeparameter übernehmen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zugegeben, das war ziemlich umständlich! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige bereits vorhandene Typen erhielten auch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterstützung </font><font style="vertical-align: inherit;">: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tupel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich werde ihre Verwendung nicht im Detail erklären, da bereits viel über sie geschrieben wurde, aber ich werde eine meiner Enttäuschungen teilen. Das Komitee fügte </font><font style="vertical-align: inherit;">dem </font><font style="vertical-align: inherit;">Standard </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syntaktischen Zucker</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzu </font><font style="vertical-align: inherit;">, um die in einem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tupel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthaltenen Werte zu extrahieren </font><font style="vertical-align: inherit;">. Diese neue Art der Deklaration wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strukturierte Bindung bezeichnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verwendet Klammern, um anzugeben, in welchen Variablen das geteilte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tupel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert werden soll </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehr schlau! </font><font style="vertical-align: inherit;">Aber es ist schade, dass die Komiteemitglieder [konnten, wollten nicht, fanden nicht die Zeit, vergaßen] sie freundlich zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr machen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich würde so etwas erwarten:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir komplexe Container und Hilfstypen, aber wie können wir sie bequem manipulieren? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmen: </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Aktualisieren eines Containers für die Verarbeitung von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine ziemlich eintönige Aufgabe. </font><font style="vertical-align: inherit;">Im Vergleich dazu </font><font style="vertical-align: inherit;">scheint es einfach genug </font><font style="vertical-align: inherit;">zu sein, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">modifizierende </font></strong><strong><font style="vertical-align: inherit;">Algorithmen zu </font></strong><strong><font style="vertical-align: inherit;">portieren</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist jedoch ziemlich seltsam, dass </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine Fortschritte in diesem Bereich gesehen haben, sondern nur in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zum Beispiel haben die wunderbaren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmen </font><font style="vertical-align: inherit;">keine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signaturen erhalten </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber keine Angst! </font><font style="vertical-align: inherit;">Wie Ben und Jason erklärt haben, können Sie den Algorithmus leicht in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr umwandeln,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indem Sie einfach die aktuelle Implementierung kopieren (aber vergessen Sie nicht die Urheberrechte). </font><font style="vertical-align: inherit;">cppreference ist gut. </font><font style="vertical-align: inherit;">Meine Damen und Herren, ich präsentiere Ihnen Ihre Aufmerksamkeit</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich kann schon von den Ständen die Schreie der Optimierungsfans hören! </font><font style="vertical-align: inherit;">Ja, nur das Hinzufügen von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vor dem von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> freundlicherweise bereitgestellten Beispielcode führt zur </font><strong><font style="vertical-align: inherit;">Laufzeit</font></strong><font style="vertical-align: inherit;"> möglicherweise nicht zu einer idealen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir diesen Algorithmus jedoch verbessern müssen, wird er für die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit bei der Kompilierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benötigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Soweit ich weiß, </font><font style="vertical-align: inherit;">sind einfache Lösungen </font><font style="vertical-align: inherit;">für die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilierungsgeschwindigkeit am</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geschwindigkeit und Fehler: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwickler eines AAA-Spiels sollten in die Lösung dieser Probleme investieren, oder? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geschwindigkeit: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich es schaffte, eine halb funktionierende Version von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">, verlief die Arbeit reibungsloser. Tatsächlich habe ich </font><font style="vertical-align: inherit;">auf meinem alten Laptop mit i5, das auf 1,80 GHz übertaktet wurde, </font><font style="vertical-align: inherit;">etwas mehr als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Bilder pro Sekunde) erreicht (Frequenz ist in diesem Fall wichtig). Wie in jedem Projekt wurde mir schnell klar, dass der zuvor geschriebene Code ekelhaft war, und ich begann, das Parsen des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spielzustands</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mithilfe von </font><strong><font style="vertical-align: inherit;">constexpr_string</font></strong><font style="vertical-align: inherit;"> und Standardalgorithmen </font><font style="vertical-align: inherit;">neu zu schreiben </font><font style="vertical-align: inherit;">. Obwohl dies die Wartung des Codes wesentlich komfortabler machte, wirkten sich die Änderungen ernsthaft auf die Geschwindigkeit aus. Die neue Decke beträgt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz des alten Sprichworts über C ++ sind „Null-Kopf-Abstraktionen“ nicht für </font><strong><font style="vertical-align: inherit;">Berechnungen</font></strong><font style="vertical-align: inherit;"> zur </font><strong><font style="vertical-align: inherit;">Kompilierungszeit</font></strong><font style="vertical-align: inherit;"> anwendbar</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ziemlich logisch, wenn wir den Compiler als Interpreter eines „Kompilierungszeitcodes“ betrachten. </font><font style="vertical-align: inherit;">Verbesserungen für verschiedene Compiler sind weiterhin möglich, aber es gibt auch Wachstumschancen für uns, die Autoren eines solchen Codes. </font><font style="vertical-align: inherit;">Hier ist eine unvollständige Liste von Beobachtungen und Tipps, die ich gefunden habe, möglicherweise spezifisch für GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Arrays</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktionieren viel besser als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein bisschen moderne C ++ - Kosmetik auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einem Array im C-Stil,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Sie müssen einen Preis dafür zahlen, wenn Sie es unter solchen Bedingungen verwenden.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     «». </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft hat mein Compiler schreckliche Kompilierungsfehler ausgegeben, und meine Codelogik hat darunter gelitten. Aber wie findet man den Ort, an dem sich der Käfer versteckt? Ohne </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debugger</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf werden die</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dinge komplizierter. Wenn Ihr metaphorischer „Bart des Programmierers“ noch nicht auf die Knie gegangen ist (sowohl der metaphorische als auch der echte Bart von mir sind noch weit von diesen Erwartungen entfernt), haben Sie möglicherweise keine Motivation, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Templight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu verwenden </font><font style="vertical-align: inherit;">oder den Compiler zu debuggen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser erster Freund wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert sein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was uns die Möglichkeit gibt, den booleschen Wert der Kompilierungszeit zu überprüfen. Unser zweiter Freund wird ein Makro sein, das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr aktiviert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und deaktiviert, </font><strong><font style="vertical-align: inherit;">wo</font></strong><font style="vertical-align: inherit;"> immer dies möglich ist:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit diesem Makro können wir die Logik zur Laufzeit arbeiten lassen, was bedeutet, dass wir einen Debugger daran anhängen können. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II - strebe das Gameplay zur Laufzeit vollständig an: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlich wird </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieses Jahr nicht die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gewinnen </font><font style="vertical-align: inherit;">. Es hat großes Potenzial, aber das Gameplay wird </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Zeitpunkt der Kompilierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht vollständig ausgeführt </font><font style="vertical-align: inherit;">. Dies kann Hardcore-Gamer ärgern ... Ich kann das Bash-Skript nur loswerden, wenn jemand </font><font style="vertical-align: inherit;">in der Kompilierungsphase </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastatureingaben</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und unreine Logik </font><font style="vertical-align: inherit;">hinzufügt </font><font style="vertical-align: inherit;">(und das ist offener Wahnsinn!). Ich glaube jedoch, dass ich eines Tages die ausführbare Datei des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderers</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vollständig verlassen </font><font style="vertical-align: inherit;">und den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status des Spiels</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilierungszeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anzeigen </font><strong><font style="vertical-align: inherit;">kann</font></strong><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Verrückte mit dem Alias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saarraz hat </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC erweitert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprache das</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstrukt </font><strong><font style="vertical-align: inherit;">static_print</font></strong><font style="vertical-align: inherit;"> hinzuzufügen </font><font style="vertical-align: inherit;">. Dieses Konstrukt sollte mehrere konstante Ausdrücke oder Zeichenfolgenliterale verwenden und diese in der Kompilierungsphase ausgeben. Ich würde mich freuen, wenn ein solches Tool zum Standard hinzugefügt oder zumindest </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erweitert </font><strong><font style="vertical-align: inherit;">würde,</font></strong><font style="vertical-align: inherit;"> damit es konstante Ausdrücke </font><strong><font style="vertical-align: inherit;">akzeptiert</font></strong><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17 kann es</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedoch eine Möglichkeit geben, dieses Ergebnis zu erzielen. Compiler geben bereits zwei Dinge aus - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Wenn wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> irgendwie verwalten oder </font><font style="vertical-align: inherit;">an unsere Bedürfnisse anpassen können, erhalten wir bereits eine würdige Schlussfolgerung. Ich habe insbesondere verschiedene Lösungen ausprobiert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veraltetes Attribut</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Ausgabe offensichtlich vorhanden ist und analysiert werden kann, ist der Code leider nicht spielbar! </font><font style="vertical-align: inherit;">Wenn Sie zufällig Mitglied einer Geheimgesellschaft von C ++ - Programmierern sind, die während der Kompilierung Ausgaben ausführen können, werde ich Sie gerne in meinem Team einstellen, um die perfekte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlussfolgerungen: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende habe ich dir mein </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrugsspiel verkauft</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich hoffe, Sie finden diesen Beitrag neugierig und lernen beim Lesen etwas Neues. </font><font style="vertical-align: inherit;">Wenn Sie Fehler oder Möglichkeiten zur Verbesserung des Artikels finden, kontaktieren Sie mich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwedenCpp-Team</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dafür </font><font style="vertical-align: inherit;">danken, </font><strong><font style="vertical-align: inherit;">dass</font></strong><font style="vertical-align: inherit;"> ich meinen Projektbericht bei einer ihrer Veranstaltungen durchführen durfte. </font><font style="vertical-align: inherit;">Darüber hinaus möchte ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Gurdeev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meinen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">tiefen</font></a><font style="vertical-align: inherit;"> Dank </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aussprechen</font></a><font style="vertical-align: inherit;"> , der mir geholfen hat, die wesentlichen Aspekte der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga zu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verbessern </font><font style="vertical-align: inherit;">.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414465/">https://habr.com/ru/post/de414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414451/index.html">"Testerkalender" für Juni. Der Tester muss den Fehler erkennen, Caner lesen und den Umzug organisieren.</a></li>
<li><a href="../de414453/index.html">Implementieren Sie den Pfadfinder für KI-Agenten mit NavMesh</a></li>
<li><a href="../de414455/index.html">Algorithmus zur Erzeugung von Farbpaletten</a></li>
<li><a href="../de414459/index.html">Detektoren und Deskriptoren von singulären Punkten FAST, BRIEF, ORB</a></li>
<li><a href="../de414463/index.html">AI selbst hat gelernt, wie man einen Zauberwürfel baut</a></li>
<li><a href="../de414467/index.html">Beiträge von der Minsk C ++ Konferenz CoreHard Spring 2018</a></li>
<li><a href="../de414469/index.html">Sicherheitswoche 22: Zwei Sekunden Smart Locks</a></li>
<li><a href="../de414471/index.html">11 Höllenkreise für diejenigen, denen es an Erfahrung in einem neuen Job mangelt</a></li>
<li><a href="../de414473/index.html">Ninja DVR: Neoline G-Tech X27 Dual Test</a></li>
<li><a href="../de414475/index.html">"Endbenutzer - wir sind bei Ihnen": Über die Android-Entwicklung in CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>