<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüéì üß• üì∫ Tingkatkan. Spirit, atau Tambahkan "Spiritualitas" ke Daftar Filter üíÜüèº ‚è´ üêà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, kolega. Saya masih seorang pengembang sistem ISP, dan nama saya masih Dmitry Smirnov. Untuk beberapa waktu (agak lama) saya tidak bisa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tingkatkan. Spirit, atau Tambahkan "Spiritualitas" ke Daftar Filter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/472004/"><p><img src="https://habrastorage.org/webt/qv/yu/6-/qvyu6-kaqci3ha5ivctj0nvbwco.png" alt="gambar"></p><br><p>  Selamat siang, kolega.  Saya masih seorang pengembang sistem ISP, dan nama saya masih Dmitry Smirnov.  Untuk beberapa waktu (agak lama) saya tidak bisa memutuskan topik publikasi berikutnya, karena banyak materi telah terakumulasi selama beberapa bulan terakhir bekerja dengan Boost.Asio.  Dan bahkan pada saat itu ketika tampaknya lebih mudah untuk melempar koin, satu tugas mengubah segalanya.  Itu perlu untuk mengembangkan alat yang memungkinkan ujung depan untuk menyaring data dalam daftar yang diminta.  Daftar itu sendiri dari backend adalah json_array biasa.  Selamat datang di kat, ada semua pasang surut beberapa hari terakhir. </p><a name="habracut"></a><br><h3 id="diskleymer">  Penafian </h3><br><p>  Saya harus segera mengatakan bahwa terakhir kali penulis "merasakan" sesuatu seperti tata bahasa bebas konteks sepuluh tahun yang lalu.  Kemudian itu tampak seperti semacam alat yang agak cadel dan tidak perlu, tetapi saya belajar tentang Boost. Perpustakaan Spirit pada hari yang sama dengan pernyataan masalah. </p><br><h3 id="zadacha">  Tantangan </h3><br><p>  Perlu mengubah kueri seperti: </p><br><pre><code class="cpp hljs">(string_field CP value AND int_field NOT LT <span class="hljs-number"><span class="hljs-number">150</span></span>) OR bool_field EQ <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Menjadi beberapa struktur yang akan memeriksa objek json dan melaporkan apakah memenuhi persyaratan atau tidak. </p><br><h3 id="pervye-shagi">  Langkah pertama </h3><br><p>  Pertama-tama, Anda perlu memutuskan antarmuka filter di masa depan.  Hal ini diperlukan untuk menghapus objek yang tidak perlu dari array, sehingga harus dikombinasikan dengan algoritma STL, khususnya std :: remove_if. </p><br><p>  Seorang functor akan sempurna, yang akan dibangun langsung dari permintaan dari depan.  Karena proyek ini menggunakan nlohmann :: json, desainnya akan cukup elegan: </p><br><pre> <code class="cpp hljs">filter = <span class="hljs-string"><span class="hljs-string">"(string_field CP value AND int_field NOT LT 150) OR bool_field EQ true"</span></span>; json.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(json.begin(), json.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::not_fn(JsonFilter{filter})), json.end());</code> </pre> <br><p>  Untuk memudahkan penggunaan filter, saya memilih untuk membagi kondisi menjadi pohon biner.  Simpul terendah harus berisi operator pembanding, tetapi sisanya harus operator logis.  Ini adalah bagaimana filter di atas akan terlihat dalam keadaan dibongkar: </p><br><p><img src="https://habrastorage.org/webt/if/yc/zk/ifyczkjiznmiebrxvof3oxgnur4.jpeg" alt="Filter Tree"></p><br><p>  Hasilnya adalah bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AST</a> , jika Anda bisa menyebutnya begitu.  Sekarang gambar dari logika yang akan datang telah mengambil bentuk, saatnya telah tiba untuk yang paling menarik dan mengerikan.  Ini harus ditulis ... On Spirit ... </p><br><h3 id="znakomstvo">  Kenalan </h3><br><p>  Pertanyaan paling sulit muncul: dari mana harus memulai?  Tidak seperti Asio, membaca header Spirit tidak memberikan petunjuk yang jelas, dengan kata lain - ada "semacam sihir."  Ini diikuti oleh studi tentang contoh-contoh dalam dokumentasi resmi tentang dorongan dan semua jenis contoh di jaringan, yang setelah beberapa waktu tidak hanya membawa buah-buahnya, tetapi solusi sedekat mungkin dengan kebutuhan saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AST kalkulator</a> </p><br><p>  Mari kita lihat tata bahasa yang disajikan dalam contoh: </p><br><div class="spoiler">  <b class="spoiler_title">Kalkulator Tata Bahasa</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArithmeticGrammar1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> qi::grammar&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator, ASTNodePtr(), qi::space_type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Iterator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator; ArithmeticGrammar1() : ArithmeticGrammar1::base_type(start) { start = (product &gt;&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span> &gt;&gt; start) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'+'</span></span>&gt;&gt; (qi::_1, qi::_2)] | product[qi::_val = qi::_1]; product = (factor &gt;&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span> &gt;&gt; product) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'*'</span></span>&gt;&gt; (qi::_1, qi::_2)] | factor[qi::_val = qi::_1]; factor = group[qi::_val = qi::_1] | qi::int_[qi::_val = phx::new_&lt;ConstantNode&gt;(qi::_1)]; group %= <span class="hljs-string"><span class="hljs-string">'('</span></span> &gt;&gt; start &gt;&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span>; } qi::rule&lt;Iterator, ASTNodePtr(), qi::space_type&gt; start, group, product, factor; };</code> </pre> </div></div><br><p>  Tata bahasa diwariskan dari basis qi :: tata bahasa.  <em>ASTNodePtr ()</em> bukan cara yang jelas, tetapi sangat nyaman untuk melewatkan objek dari hasil yang diharapkan ke objek tata bahasa. </p><br><div class="spoiler">  <b class="spoiler_title">Kalkulator simpul AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASTNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ASTNode() {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ASTNodePtr = ASTNode*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Operator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OperatorNode</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ASTNode { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OperatorNode(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASTNodePtr &amp;left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASTNodePtr &amp;right) : left(left) , right(right) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operator == <span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;evaluate() + right-&gt;evaluate(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operator == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;evaluate() * right-&gt;evaluate(); } ~OperatorNode() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> right; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ASTNodePtr left, right; <span class="hljs-comment"><span class="hljs-comment">//  }; class ConstantNode : public ASTNode { public: ConstantNode(double value) : value(value) {} double evaluate() { return value; } private: double value; };</span></span></code> </pre> </div></div><br><p>  Menggunakan perpustakaan Boost.Phoenix, Anda bisa membuat simpul AST yang sudah jadi dari satu atau beberapa non-terminal tepat selama parsing dan menulis langsung ke hasilnya.  Mari kita lihat lebih dekat apa yang terdiri dari kalkulator: </p><br><pre> <code class="cpp hljs">start = (product &gt;&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span> &gt;&gt; start)[qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'+'</span></span>&gt;&gt; (qi::_1, qi::_2)] | product[qi::_val = qi::_1];</code> </pre> <br><p>  mulai - mulai parsing kalimat.  Titik awal.  Ini dapat diekspresikan melalui jumlah produk dan mulai, atau hanya melalui produk. </p><br><p>  Catat tindakan dalam tanda kurung siku untuk setiap ekspresi.  Ini adalah tindakan yang harus dilakukan jika parsing berhasil, jika semuanya cocok.  <em>qi :: _ val</em> sebenarnya adalah <em>boost :: spirit :: qi :: _ val</em> adalah placeholder.  Dengan bantuannya, jawabannya akan dicatat dalam hasilnya.  Dalam kasus mulai, ini akan menjadi objek OperatorNode, yang argumen pertamanya akan menjadi hasil parsing produk, dan yang kedua adalah hasil parsing start. </p><br><p>  Kami melihat lebih jauh.  Misalkan kita menemukan pilihan kedua, mulai bukan jumlah, tetapi produk.  Bagaimana dia diungkapkan? </p><br><pre> <code class="cpp hljs">product = (factor &gt;&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span> &gt;&gt; product) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'*'</span></span>&gt;&gt; (qi::_1, qi::_2)] | factor[qi::_val = qi::_1];</code> </pre> <br><p>  Gambar sebelumnya diulang dengan perbedaan minimal.  Sekali lagi kita bertemu semacam ekspresi, lagi-lagi kita menulis objek OperatorNode di hasilnya, atau hanya semacam faktor.  Mari kita melihatnya. </p><br><pre> <code class="cpp hljs">factor = group[qi::_val = qi::_1] | qi::int_[qi::_val = phx::new_&lt;ConstantNode&gt;(qi::_1)];</code> </pre> <br><p>  Saat kita menempuh jalan terpendek, kita berasumsi bahwa kita bertemu tidak lain dari int.  Sekarang, jika kita menggambarkan semua langkah sebelumnya dalam pseudo-code, kita mendapatkan sesuatu yang diperluas seperti ini: </p><br><pre> <code class="cpp hljs">factor1 = ConstantNode(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,    factor2 = ConstantNode(3) product = OperatorNode&lt;'*'&gt;(factor1, factor2) start = product</span></span></code> </pre> <br><p>  Setiap node, mulai dari atas (kecuali yang terendah, yang pada dasarnya adalah bilangan bulat di sini), diekspresikan melalui node berikutnya.  Dan satu-satunya panggilan ke metode <em>evalu ()</em> pada elemen root menyelesaikan seluruh masalah, luar biasa! </p><br><p>  Kemudian <em>qi :: space_type</em> menarik perhatian Anda - argumen ini adalah daftar elemen yang diabaikan saat parsing.  Ini masih akan mempermainkan saya :-). </p><br><p>  Apa yang luar biasa di sini adalah cara untuk memprioritaskan multiplikasi daripada penambahan dengan hanya mengekspresikan awal nonterminal (hanya berisi +) melalui produk (*).  Dalam varian tata bahasa saya, karena diputuskan bahwa Dan akan menang atas Atau, saya hanya mengganti operator logis yang diperlukan di tempat yang tepat.  Jika sulit untuk membuat kesalahan dalam menulis operator matematika, maka operator logis tekstual adalah cerita yang sama sekali berbeda.  Ada keinginan untuk menyelesaikan setidaknya sebagian dari masalah yang mungkin terjadi, misalnya register.  Untuk ini, Spirit memiliki tipe <em>qi :: no_case bawaan</em> </p><br><p>  Selanjutnya, alih-alih angka, saya akan membutuhkan nama-nama bidang, jadi kami menambahkan nonterminal yang sesuai sebagai ganti built-in <em>qi :: int_</em> spirit: </p><br><pre> <code class="cpp hljs">field = qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_"</span></span>) &gt;&gt; *qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_0-9"</span></span>);</code> </pre> <br><p>  Dan kami sampai di sini ungkapan sederhana (sejauh ini tidak ada operasi semantik): </p><br><pre> <code class="plaintext hljs">start = product &gt;&gt; qi::no_case["OR"] &gt;&gt; start | product; product = factor &gt;&gt; qi::no_case["AND"] &gt;&gt; product | factor; factor = group | field; group %= '(' &gt;&gt; start &gt;&gt; ')';</code> </pre> <br><p>  Sekarang semuanya siap untuk menguraikan kalimat paling sederhana <em>"bidang Dan bidang2"</em> .  Kita mulai dan ... tidak ada yang berhasil. </p><br><p>  Masalahnya ternyata berada di tempat yang tidak terduga: <em>qi :: space_type</em> tidak hanya mengabaikan spasi, ia menghilangkannya dari kalimat sebelum parsing, dan ekspresi filter awal menjadi parsing sudah dalam bentuk: </p><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"fieldAndfield2"</span></span> \\        ,    <span class="hljs-string"><span class="hljs-string">"(5 * 5) + 11 "</span></span> \\  <span class="hljs-string"><span class="hljs-string">"(5*5)+11"</span></span></code> </pre> <br><p>  Ini hanya satu bidang tunggal.  Karena itu, Anda perlu beberapa nakhoda: </p><br><pre> <code class="cpp hljs">skipper = +qi::lit(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . ,    ,   ,  ,  C++ . start = product &gt;&gt; skipper &gt;&gt; qi::no_case["OR"] &gt;&gt; skipper &gt;&gt; start | product; ...</span></span></code> </pre> <br><p>  Setelah menganalisis bidang, dimungkinkan untuk mempelajari cara mendapatkan nilai dari ekspresi dan memahami bagaimana bidang harus divalidasi terhadap nilai.  Semua opsi perbandingan dapat diekspresikan melalui operasi berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operator</span></span></span><span class="hljs-class"> {</span></span> EQ, <span class="hljs-comment"><span class="hljs-comment">//  LT, //  GT, //  CP //  (  ) }; unary = qi::no_case["NOT"]; // ,         </span></span></code> </pre> <br><p>  Dan nilai-nilai itu sendiri diekspresikan dalam bentuk nonterminal: </p><br><pre> <code class="cpp hljs">value = qi::double_ | qi::int_ | qi::bool_ | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>) &gt;&gt; +qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z0-9_. "</span></span>) &gt;&gt; qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>);</code> </pre> <br><p>  Sekarang untuk masalah yang membawa metode semacam itu nilai.  Spirit akan mengembalikannya dalam bentuk <em>boost :: varian &lt;int, double, bool, std :: string&gt;</em> , dan ketika saatnya tiba untuk membandingkannya dengan beberapa data, diperlukan trik tertentu untuk mendapatkan nilai dari tipe yang diinginkan.  Inilah opsi yang saya datangi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = boost::variant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueGetter</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::static_visitor&lt;Json&gt; { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-function">Json </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp;value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } };</code> </pre> <br><p>  Mengapa seorang pengambil mengembalikan objek Json?  Jadi, ketika membandingkan nilai-nilai selama pemfilteran, saya akan menghindari harus mencari tahu tipe data apa yang akan dilakukan perbandingan, meninggalkan semua pekerjaan ke pustaka json. </p><br><p>  Garis finish.  Deskripsi pencocokan dirinya sendiri.  Kami akan menggunakan contoh yang sama dengan kalkulator.  Untuk memulainya, kita membutuhkan abstraksi, yang akan kita sampaikan ke dalam tata bahasa, dan Roh dengan baik hati akan mengisinya dengan kita: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractMatcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AbstractMatcher() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractMatcher() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       }; using MatcherPtr = std::shared_ptr&lt;AbstractMatcher&gt;;</span></span></code> </pre> <br><p>  Node logis lebih lanjut adalah node filter utama: </p><br><div class="spoiler">  <b class="spoiler_title">Node logis</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logic</span></span></span><span class="hljs-class"> {</span></span> AND, OR }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Logic Operator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogicNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractMatcher { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogicNode(MatcherPtr &amp;left, MatcherPtr &amp;right) : m_left(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(left)) , m_right(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(right)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Operator) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Logic::AND: m_evaluator = &amp;LogicNode::And; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Logic::OR: m_evaluator = &amp;LogicNode::Or; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke(m_evaluator, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, object); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MatcherPtr m_left; MatcherPtr m_right; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EvaluateType = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(LogicNode::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json &amp;); EvaluateType m_evaluator = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">And</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_left-&gt;evaluate(object) &amp;&amp; m_right-&gt;evaluate(object); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Or</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_left-&gt;evaluate(object) || m_right-&gt;evaluate(object); } };</code> </pre> </div></div><br><p>  Dan akhirnya, simpul bawah </p><br><div class="spoiler">  <b class="spoiler_title">Perbandingan Nilai</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractMatcher { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ObjectNode(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> field, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValueType &amp;value, boost::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; &amp;unary, Operator oper) : m_field(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(field)) , m_json_value(boost::apply_visitor(ValueGetter(), value)) , m_reject(unary.has_value()) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (oper) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::EQ: m_evaluator = &amp;ObjectNode::Equal; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::LT: m_evaluator = &amp;ObjectNode::LesserThan; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::GT: m_evaluator = &amp;ObjectNode::GreaterThan; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::CP: m_evaluator = &amp;ObjectNode::Substr; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;value = object.at(m_field); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke(m_evaluator, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_reject ? !result : result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EvaluateType = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(ObjectNode::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json &amp;); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_field; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json m_json_value; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_reject; EvaluateType m_evaluator = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json == m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LesserThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json &lt; m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json &gt; m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Substr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Str(json).find(Str(m_json_value)) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos; } };</code> </pre> </div></div><br><p>  Tinggal menyatukan semuanya: </p><br><div class="spoiler">  <b class="spoiler_title">Filter json</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonFilterGrammar</span></span></span><span class="hljs-class"> :</span></span> qi::grammar&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator, MatcherPtr()&gt; { JsonFilterGrammar() : JsonFilterGrammar::base_type(expression) { skipper = +qi::lit(<span class="hljs-string"><span class="hljs-string">' '</span></span>); unary = qi::no_case[<span class="hljs-string"><span class="hljs-string">"NOT"</span></span>]; compare.add (<span class="hljs-string"><span class="hljs-string">"eq"</span></span>, Operator::EQ) (<span class="hljs-string"><span class="hljs-string">"lt"</span></span>, Operator::LT) (<span class="hljs-string"><span class="hljs-string">"gt"</span></span>, Operator::GT) (<span class="hljs-string"><span class="hljs-string">"cp"</span></span>, Operator::CP); expression = (product &gt;&gt; skipper &gt;&gt; qi::no_case[<span class="hljs-string"><span class="hljs-string">"OR"</span></span>] &gt;&gt; skipper &gt;&gt; expression) [qi::_val = make_shared_&lt;LogicNode&lt;Logic::OR&gt;&gt;()(qi::_1, qi::_2)] | product[qi::_val = qi::_1]; product = (term &gt;&gt; skipper &gt;&gt; qi::no_case[<span class="hljs-string"><span class="hljs-string">"AND"</span></span>] &gt;&gt; skipper &gt;&gt; product) [qi::_val = make_shared_&lt;LogicNode&lt;Logic::AND&gt;&gt;()(qi::_1, qi::_2)]| term[qi::_val = qi::_1]; term = group[qi::_val = qi::_1] | (field &gt;&gt; -(skipper &gt;&gt; unary)&gt;&gt; skipper &gt;&gt; qi::no_case[compare] &gt;&gt; skipper &gt;&gt; value) [qi::_val = make_shared_&lt;ObjectNode&gt;()(qi::_1, qi::_4, qi::_2, qi::_3)]; field = qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_"</span></span>) &gt;&gt; *qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_0-9"</span></span>); value = qi::double_ | qi::int_ | qi::bool_ | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>) &gt;&gt; +qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z0-9_. \u20BD‚Ç¨$¬•-"</span></span>) &gt;&gt; qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>); group %= <span class="hljs-string"><span class="hljs-string">'('</span></span> &gt;&gt; expression &gt;&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span>; } qi::rule&lt;Iterator&gt; skipper; qi::rule&lt;Iterator, MatcherPtr()&gt; product, term, expression, group; qi::rule&lt;Iterator, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()&gt; field, unary, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; qi::rule&lt;Iterator, ValueType()&gt; value; qi::symbols&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, Operator&gt; compare; <span class="hljs-comment"><span class="hljs-comment">//      enum };</span></span></code> </pre> </div></div><br><p>  Itu saja.  Sekarang mendapatkan filter selesai telah menjadi operasi yang cukup sederhana: </p><br><pre> <code class="cpp hljs">MatcherPtr matcher; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filter = <span class="hljs-string"><span class="hljs-string">"int not LT 15"</span></span>; JsonFilterGrammar grammar; qi::parse(filter.begin(), filter.end(), grammar, matcher); <span class="hljs-comment"><span class="hljs-comment">//     matcher   .</span></span></code> </pre> <br><p>  Saya akan menghilangkan proses pembungkus tata bahasa dalam sebuah functor (saya pikir itu tidak akan menarik bagi siapa pun).  Kami akan lebih baik mempertimbangkan alat dalam aksi menggunakan contoh paling sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filter = <span class="hljs-string"><span class="hljs-string">"int not LT 15"</span></span>; Json json{ {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}} }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json.dump() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; json.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(json.begin(), json.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::not_fn(JsonFilter{filter})), json.end()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json.dump() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Berikut hasilnya: </p><br><pre> <code class="bash hljs">[{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:10},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:11},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:20},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:30},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:9}] [{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:20},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:30}]</code> </pre> <br><p>  Saya harap, para pembaca yang budiman, Anda juga tertarik untuk mengetahui dasar-dasar Roh serta saya.  Lalu saya tetap tinggal.  Sampai ketemu lagi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472004/">https://habr.com/ru/post/id472004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471992/index.html">Menerapkan fitur PEG yang tersisa</a></li>
<li><a href="../id471994/index.html">Bekerja pada PEG pada Core Developer Sprint</a></li>
<li><a href="../id471998/index.html">F # 10: Daftar</a></li>
<li><a href="../id472000/index.html">‚ÄúSangat penting bagi masyarakat untuk menetapkan standar‚Äù: Marchin Moskala tentang Kotlin</a></li>
<li><a href="../id472002/index.html">Pengemasan Paket dalam Gradle</a></li>
<li><a href="../id472006/index.html">Mengapa berguna untuk menemukan kembali roda</a></li>
<li><a href="../id472012/index.html">Kanban dalam setengah jam</a></li>
<li><a href="../id472014/index.html">OTUS. Kesalahan favorit kami</a></li>
<li><a href="../id472018/index.html">Sistem kontrol perpustakaan pada Flask-Potion, Bagian 0: menyiapkan semua yang Anda butuhkan</a></li>
<li><a href="../id472020/index.html">Top 10: laporan terbaik dari HolyJS 2019 Piter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>