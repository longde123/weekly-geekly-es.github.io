<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø üëÉüèΩ ‚ú°Ô∏è C ++: uma sess√£o de arqueologia espont√¢nea e por que voc√™ n√£o deve usar fun√ß√µes vari√°veis ‚Äã‚Äãno estilo de C ü¶à üí∂ üññüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tudo come√ßou, como sempre, com um erro. Esta √© a primeira vez que trabalhei com a Java Native Interface e, na parte C ++, envolvi uma fun√ß√£o que cria ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++: uma sess√£o de arqueologia espont√¢nea e por que voc√™ n√£o deve usar fun√ß√µes vari√°veis ‚Äã‚Äãno estilo de C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/"> Tudo come√ßou, como sempre, com um erro.  Esta √© a primeira vez que trabalhei com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Native Interface</a> e, na parte C ++, envolvi uma fun√ß√£o que cria um objeto Java.  Essa fun√ß√£o - <code>CallVoidMethod</code> - √© vari√°vel, ou seja,  al√©m de um ponteiro para o ambiente <abbr title="Interface nativa Java">JNI</abbr> , um ponteiro para o tipo de objeto a ser criado e um identificador para o m√©todo chamado (neste caso, o construtor), √© necess√°rio um n√∫mero arbitr√°rio de outros argumentos.  O que √© l√≥gico, porque  esses outros argumentos s√£o transmitidos para o m√©todo chamado no lado Java e os m√©todos podem ser diferentes, com um n√∫mero diferente de argumentos de qualquer tipo. <br><br>  Consequentemente, tamb√©m fiz minha vari√°vel wrapper.  Para passar um n√∫mero arbitr√°rio de argumentos para o <code>CallVoidMethod</code> usei <code>va_list</code> , porque √© diferente nesse caso.  Sim, foi isso que o <code>va_list</code> enviou para o <code>CallVoidMethod</code> .  E eliminou a falha de segmenta√ß√£o banal da JVM. <br><br>  Em duas horas, tentei v√°rias vers√µes da JVM, de 8 a 11, porque: em primeiro lugar, esta √© minha primeira experi√™ncia com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Java virtual machine">JVM</a> e, nesse caso, confiei no StackOverflow mais do que eu e, em segundo lugar, em algu√©m nesse caso, no StackOverflow, eu recomendei, neste caso, n√£o usar o OpenJDK, mas o OracleJDK, e n√£o 8, mas 10. E s√≥ ent√£o finalmente notei que, al√©m da vari√°vel <code>CallVoidMethod</code> h√° <code>CallVoidMethodV</code> , que recebe um n√∫mero arbitr√°rio de argumentos via <code>va_list</code> . <br><br>  O que eu mais n√£o gostei nessa hist√≥ria foi que n√£o percebi imediatamente a diferen√ßa entre as retic√™ncias ( <code>va_list</code> ) e <code>va_list</code> .  E, tendo notado, n√£o consegui explicar para mim qual era a diferen√ßa fundamental.  Portanto, precisamos lidar com retic√™ncias, e com <code>va_list</code> e (j√° que ainda estamos falando sobre C ++) com modelos de vari√°veis. <br><a name="habracut"></a><br><h3>  O que dizer das retic√™ncias e va_list √© dito no Padr√£o </h3><br>  O padr√£o C ++ descreve apenas as diferen√ßas entre seus requisitos e os do padr√£o C. As diferen√ßas em si ser√£o discutidas mais adiante, mas por enquanto explicarei brevemente o que o padr√£o C diz (come√ßando com C89). <br><br><ul><li>  Voc√™ pode declarar uma fun√ß√£o que recebe um n√∫mero arbitr√°rio de argumentos.  I.e.  uma fun√ß√£o pode ter mais argumentos que par√¢metros.  Para fazer isso, a lista de seus par√¢metros deve terminar com retic√™ncias, mas pelo menos um par√¢metro fixo <i>[C11 6.9.1 / 8]</i> tamb√©m deve estar presente: <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  As informa√ß√µes sobre o n√∫mero e os tipos de argumentos correspondentes √†s retic√™ncias n√£o s√£o passadas para a pr√≥pria fun√ß√£o.  I.e.  ap√≥s o √∫ltimo par√¢metro nomeado ( <code>parm2</code> no exemplo acima) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  Para acessar esses argumentos, voc√™ deve usar o tipo <code>va_list</code> declarado no cabe√ßalho <code>&lt;stdarg.h&gt;</code> e 4 macros (3 antes do padr√£o C11): <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> e <code>va_copy</code> (come√ßando com C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Por exemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  Sim, a fun√ß√£o n√£o sabe quantos argumentos ela possui.  Ela precisa de alguma forma passar esse n√∫mero.  Nesse caso, por meio de um √∫nico argumento nomeado (outra op√ß√£o comum √© passar <code>NULL</code> como o √∫ltimo argumento, como em <code>execl</code> ou 0). </div></div></li><li>  O √∫ltimo argumento nomeado n√£o pode ter uma classe de armazenamento de <code>register</code> , n√£o pode ser uma fun√ß√£o ou uma matriz.  Caso contr√°rio, comportamento indefinido <i>[C11 7.16.1.4/4]</i> . </li><li>  Al√©m disso, ao √∫ltimo argumento nomeado e a todos os sem nome, √© aplicada a " <i>promo√ß√£o de argumentos padr√£o</i> " ( <i>promo√ß√£o de argumentos padr√£o</i> ; se houver uma boa tradu√ß√£o desse conceito para o russo, eu o uso com prazer).  Isso significa que se o argumento tiver o tipo <code>char</code> , <code>short</code> (com ou sem um sinal) ou <code>float</code> , os par√¢metros correspondentes dever√£o ser acessados ‚Äã‚Äãcomo <code>int</code> , <code>int</code> (com ou sem um sinal) ou <code>double</code> .  Caso contr√°rio, comportamento indefinido <i>[C11 7.16.1.1/2]</i> . </li><li>  Sobre o tipo <code>va_list</code> , <code>va_list</code> -se apenas que ele √© declarado em <code>&lt;stdarg.h&gt;</code> e est√° completo (ou seja, √© conhecido o tamanho de um objeto desse tipo) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Porque  Mas porque! </h3><br>  N√£o h√° muitos tipos em C.  Por que o <code>va_list</code> √© declarado no Padr√£o, mas nada √© dito sobre sua estrutura interna? <br><br>  Por que precisamos de retic√™ncias se um n√∫mero arbitr√°rio de argumentos para uma fun√ß√£o pode ser passado atrav√©s de <code>va_list</code> ?  Pode-se dizer agora: ‚Äúcomo a√ß√∫car sint√°tico‚Äù, mas h√° 40 anos, tenho certeza, n√£o havia tempo para o a√ß√∫car. <br><br>  Philip James Plauger <i>Phillip James Plauger</i> no livro <i>The Standard C library</i> - 1992 - diz que inicialmente o C foi criado exclusivamente para computadores PDP-11.  E foi poss√≠vel classificar todos os argumentos da fun√ß√£o usando aritm√©tica simples de ponteiro.  O problema apareceu com a popularidade de C e a transfer√™ncia do compilador para outras arquiteturas.  A primeira edi√ß√£o da <i>linguagem de programa√ß√£o The C, de</i> <i>Brian Kernighan</i> e Dennis Ritchie - 1978 - afirma explicitamente: <blockquote>  A prop√≥sito, n√£o h√° maneira aceit√°vel de escrever uma fun√ß√£o port√°til de um n√∫mero arbitr√°rio de argumentos, porque  N√£o existe uma maneira port√°til para a fun√ß√£o chamada descobrir quantos argumentos foram passados ‚Äã‚Äãpara ela quando chamada.  ... <code>printf</code> , a fun√ß√£o mais t√≠pica da linguagem C de um n√∫mero arbitr√°rio de argumentos, ... n√£o √© port√°til e deve ser implementada para cada sistema. </blockquote>  Este livro descreve <code>printf</code> , mas ainda n√£o possui <code>vprintf</code> e n√£o menciona o tipo e as macros <code>va_*</code> .  Eles aparecem na segunda edi√ß√£o da linguagem de programa√ß√£o C (1988), e esse √© o m√©rito do comit√™ para o desenvolvimento do primeiro padr√£o C (C89, tamb√©m conhecido como ANSI C).  O comit√™ adicionou o <code>&lt;stdarg.h&gt;</code> ao Padr√£o, tendo como base o <code>&lt;varargs.h&gt;</code> criado por Andrew Koenig para aumentar a portabilidade do SO UNIX.  <code>va_*</code> decidido deixar <code>va_*</code> macros <code>va_*</code> como macros, para que fosse mais f√°cil para os compiladores existentes oferecerem suporte ao novo Padr√£o. <br><br>  Agora, com o advento do C89 e da fam√≠lia <code>va_*</code> , tornou-se poss√≠vel criar fun√ß√µes vari√°veis ‚Äã‚Äãport√°teis.  E embora a estrutura interna dessa fam√≠lia ainda n√£o seja descrita de maneira alguma e n√£o haja requisitos para ela, j√° est√° claro o porqu√™. <br><br>  Por pura curiosidade, voc√™ pode encontrar exemplos da implementa√ß√£o do <code>&lt;stdarg.h&gt;</code> .  Por exemplo, a mesma "Biblioteca Padr√£o C" fornece um exemplo para o <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; de Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  A muito mais recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SystemV ABI para AMD64</a> usa este tipo para <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list do SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  Em geral, podemos dizer que o tipo e as macros <code>va_*</code> fornecem uma interface padr√£o para percorrer argumentos de uma fun√ß√£o vari√°vel, e sua implementa√ß√£o por raz√µes hist√≥ricas depende do compilador, plataformas de destino e arquitetura.  Al√©m disso, uma elipse (isto √©, fun√ß√µes vari√°veis ‚Äã‚Äãem geral) apareceu em C antes de <code>va_list</code> (isto √©, o cabe√ßalho <code>&lt;stdarg.h&gt;</code> ).  E o <code>va_list</code> n√£o foi criado para substituir as retic√™ncias, mas para permitir que os desenvolvedores escrevam suas fun√ß√µes vari√°veis ‚Äã‚Äãport√°teis. <br><br>  O C ++ mant√©m amplamente a compatibilidade com vers√µes anteriores do C, portanto, todas as op√ß√µes acima se aplicam a ele.  Mas tamb√©m h√° recursos. <br><br><h3>  Fun√ß√µes vari√°veis ‚Äã‚Äãem C ++ </h3><br>  O grupo de trabalho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WG21</a> esteve envolvido no desenvolvimento do padr√£o C ++.  Em 1989, o rec√©m-criado C89 Standard foi tomado como base, que mudou gradualmente para descrever o pr√≥prio C ++.  Em 1995, a proposta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N0695 foi recebida</a> de <i>John Micco</i> , na qual o autor sugeriu alterar as restri√ß√µes para as macros <code>va_*</code> : <br><br><ul><li>  Porque  C ++, ao contr√°rio de C, permite obter o endere√ßo de <code>register</code> de vari√°veis, ent√£o o √∫ltimo argumento nomeado de uma fun√ß√£o vari√°vel pode ter essa classe de armazenamento. <br></li><li>  Porque  os links que apareceram no C ++ violam a regra n√£o escrita das fun√ß√µes da vari√°vel C - o tamanho do par√¢metro deve corresponder ao tamanho do tipo declarado -, ent√£o o √∫ltimo argumento nomeado n√£o pode ser um link.  Caso contr√°rio, comportamento vago. <br></li><li>  Porque  em C ++, n√£o h√° conceito de " <i>aumentar o tipo de argumento por padr√£o</i> ", ent√£o a frase <br><blockquote>  Se o par√¢metro <code>parmN</code> for declarado com ... um tipo que n√£o √© compat√≠vel com o tipo resultante ap√≥s a aplica√ß√£o das promo√ß√µes de argumentos padr√£o, o comportamento ser√° indefinido </blockquote>  deve ser substitu√≠do por <blockquote>  Se o par√¢metro <code>parmN</code> for declarado com ... um tipo que n√£o √© compat√≠vel com o tipo resultante ao transmitir um argumento para o qual n√£o h√° par√¢metro, o comportamento ser√° indefinido </blockquote></li></ul>  Nem traduzi o √∫ltimo ponto para compartilhar minha dor.  Primeiro, a ‚Äú <i>escala√ß√£o do tipo de argumento padr√£o</i> ‚Äù no C ++ Standard permanece <i>[C ++ 17 8.2.2 / 9]</i> .  E, em segundo lugar, fiquei intrigado por um longo tempo sobre o significado dessa frase, em compara√ß√£o com o Padr√£o C, onde tudo est√° claro.  Somente depois de ler o N0695 eu finalmente entendi: quero dizer a mesma coisa. <br><br>  No entanto, todas as tr√™s altera√ß√µes foram adotadas <i>[C ++ 98 18.7 / 3]</i> .  De volta ao C ++, o requisito de uma fun√ß√£o vari√°vel ter pelo menos um par√¢metro nomeado (nesse caso, voc√™ n√£o pode acessar os outros, mas mais sobre isso posteriormente) desapareceu, e a lista de tipos v√°lidos de argumentos n√£o nomeados foi complementada com ponteiros para membros da classe e tipos de <abbr title="Dados antigos simples">POD</abbr> . <br><br>  O padr√£o C ++ 03 n√£o trouxe altera√ß√µes nas fun√ß√µes variacionais.  O C ++ 11 come√ßou a converter um argumento sem nome do tipo <code>std::nullptr_t</code> para <code>void*</code> e permitiu que os compiladores, a seu crit√©rio, <code>std::nullptr_t</code> tipos com construtores e destruidores n√£o triviais <i>[C ++ 11 5.2.2 / 7]</i> .  O C ++ 14 permitiu o uso de fun√ß√µes e matrizes como o √∫ltimo par√¢metro nomeado <i>[C ++ 14 18.10 / 3]</i> , e o C ++ 17 proibiu o uso de expans√£o do pacote de par√¢metros ( <i>expans√£o do pacote</i> ) e vari√°veis ‚Äã‚Äãcapturadas pela lambda <i>[C ++ 17 21.10.1 / 1]</i> <br><br>  Como resultado, o C ++ adicionou fun√ß√µes variadas √†s suas armadilhas.  Somente o suporte de tipo n√£o especificado com construtores / destruidores n√£o triviais vale a pena.  A seguir, tentarei reduzir todos os recursos n√£o √≥bvios das fun√ß√µes vari√°veis ‚Äã‚Äãem uma lista e complement√°-la com exemplos espec√≠ficos. <br><br><h3>  Como usar fun√ß√µes vari√°veis ‚Äã‚Äãde maneira f√°cil e incorreta </h3><br><ol><li>  √â incorreto declarar o √∫ltimo argumento nomeado com um tipo promovido, ou seja,  <code>char</code> , <code>char</code> <code>signed char</code> , <code>signed char</code> <code>unsigned char</code> , <code>singed short</code> , <code>unsigned short</code> ou <code>float</code> .  O resultado de acordo com a Norma ser√° um comportamento indefinido. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  De todos os compiladores que eu tinha em m√£os (gcc, clang, MSVC), apenas o <b>clang</b> emitiu um aviso. <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  E, embora em todos os casos o c√≥digo compilado tenha se comportado corretamente, voc√™ n√£o deve contar com ele. <br><br><div class="spoiler">  <b class="spoiler_title">Vai dar certo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  √â incorreto declarar o √∫ltimo argumento nomeado como refer√™ncia.  Qualquer link.  O padr√£o neste caso tamb√©m promete um comportamento indefinido. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>O gcc 7.3.0</b> compilou esse c√≥digo sem um √∫nico coment√°rio.  <b>O idioma 6.0.0</b> emitiu um aviso, mas ainda o compilou. <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Nos dois casos, o programa funcionou corretamente (por sorte, voc√™ n√£o pode confiar nele).  Mas o <b>MSVC 19.15.26730 se</b> destacou - ele se recusou a compilar o c√≥digo, porque  <code>va_start</code> argumento <code>va_start</code> n√£o <code>va_start</code> ser uma refer√™ncia. <br><br><div class="spoiler">  <b class="spoiler_title">Erro do MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bem, a op√ß√£o correta se parece, por exemplo, com esta</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  √â errado solicitar ao <code>va_arg</code> aumentar o tipo - <code>char</code> , <code>short</code> ou <code>float</code> . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  √â mais interessante aqui.  <b>O gcc</b> na compila√ß√£o avisa que √© necess√°rio usar <code>double</code> vez de <code>float</code> , e se esse c√≥digo ainda for executado, o programa terminar√° com um erro. <br><br><div class="spoiler">  <b class="spoiler_title">Aviso do Gcc</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  De fato, o programa trava com uma reclama√ß√£o sobre uma instru√ß√£o inv√°lida. <br>  Uma an√°lise de despejo mostra que o programa recebeu um sinal SIGILL.  E tamb√©m mostra a estrutura do <code>va_list</code> .  Para 32 bits, isso √© <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  isto √©  <code>va_list</code> √© apenas <code>char*</code> .  Para 64 bits: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  isto √©  exatamente o que √© descrito em SystemV ABI AMD64. <br><br>  <b>clang</b> na compila√ß√£o alerta para um comportamento indefinido e tamb√©m sugere a substitui√ß√£o de <code>float</code> por <code>double</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  Mas o programa n√£o falha mais, a vers√£o de 32 bits produz: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64 bits: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>O MSVC</b> produz exatamente os mesmos resultados, apenas sem aviso, mesmo com <code>/Wall</code> . <br><br>  Aqui, pode-se supor que a diferen√ßa entre 32 e 64 bits se deve ao fato de que, no primeiro caso, a ABI passa todos os argumentos da pilha para a fun√ß√£o chamada e, no segundo, os quatro primeiros argumentos (Windows) ou seis (Linux) atrav√©s do processador registram, o restante atrav√©s pilha [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> ].  Mas n√£o, se voc√™ chamar <code>foo</code> n√£o com 4 argumentos, mas com 19, e produzi-los da mesma maneira, o resultado ser√° o mesmo: confus√£o total na vers√£o de 32 bits e zeros para todos os <code>float</code> na de 64 bits.  I.e.  o ponto est√° claro na ABI, mas n√£o no uso de registradores para passar argumentos. <br><br><div class="spoiler">  <b class="spoiler_title">Bem, √© claro, √© certo faz√™-lo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  √â incorreto passar uma inst√¢ncia de uma classe com um construtor ou destruidor n√£o trivial como um argumento sem nome.  A menos, √© claro, que o destino desse c√≥digo o excite pelo menos um pouco mais do que "compile e execute aqui e agora". <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Clang √© o mais r√≠gido de todos novamente.  Ele simplesmente se recusa a compilar esse c√≥digo porque o segundo argumento, <code>va_arg</code> n√£o <code>va_arg</code> tipo POD e alerta que o programa <code>va_arg</code> na inicializa√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  Assim ser√°, se voc√™ ainda compilar com o <code>-Wno-non-pod-varargs</code> . <br><br>  <b>A MSVC</b> adverte que o uso de tipos com construtores n√£o triviais nesse caso n√£o √© port√°til. <br><br><div class="spoiler">  <b class="spoiler_title">Aviso do MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  Mas o c√≥digo compila e executa corretamente.  O seguinte √© obtido no console: <br><br><div class="spoiler">  <b class="spoiler_title">Resultado do lan√ßamento</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  I.e.  uma c√≥pia √© criada apenas no momento da chamada <code>va_arg</code> , e o argumento, ao que parece, √© passado por refer√™ncia.  De alguma forma, n√£o √© √≥bvio, mas o Padr√£o permite. <br><br>  <b>O gcc 6.3.0 √©</b> compilado sem um √∫nico coment√°rio.  A sa√≠da √© a mesma: <br><br><div class="spoiler">  <b class="spoiler_title">Resultado do lan√ßamento</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>O gcc 7.3.0</b> tamb√©m n√£o avisa sobre nada, mas o comportamento est√° mudando: <br><br><div class="spoiler">  <b class="spoiler_title">Resultado do lan√ßamento</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  I.e.  essa vers√£o do compilador passa argumentos por valor e, quando chamada, <code>va_arg</code> faz outra c√≥pia.  Seria divertido procurar essa diferen√ßa ao alternar da sexta para a s√©tima vers√£o do gcc se os construtores / destruidores tiverem efeitos colaterais. <br><br>  A prop√≥sito, se voc√™ passar e solicitar explicitamente uma refer√™ncia √† classe: <br><br><div class="spoiler">  <b class="spoiler_title">Outro c√≥digo errado</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  todos os compiladores lan√ßar√£o um erro.  Conforme exigido pela Norma. <br><br>  Em geral, se voc√™ realmente quiser, √© melhor passar argumentos por ponteiro. <br><br><div class="spoiler">  <b class="spoiler_title">Assim</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  Resolu√ß√£o de sobrecarga e fun√ß√µes vari√°veis </h3><br>  Por um lado, tudo √© simples: combinar com uma elipse √© pior do que combinar com um argumento nomeado regular, mesmo no caso de uma convers√£o de tipo padr√£o ou definida pelo usu√°rio. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de sobrecarga</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Resultado do lan√ßamento</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  Mas isso s√≥ funciona at√© que a chamada para <code>foo</code> sem argumentos precise ser considerada separadamente. <br><br><div class="spoiler">  <b class="spoiler_title">Chame foo sem argumentos</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do compilador</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Tudo est√° de acordo com o Padr√£o: n√£o h√° argumentos - n√£o h√° compara√ß√£o com as elipses e, quando a sobrecarga √© resolvida, a fun√ß√£o variativa n√£o se torna pior que a usual. <br><br><h3>  Quando vale a pena usar fun√ß√µes vari√°veis </h3><br>  Bem, as fun√ß√µes variativas √†s vezes n√£o se comportam de maneira muito √≥bvia e, no contexto do C ++, podem facilmente ser pouco port√°teis.  Existem muitas dicas na Internet como ‚ÄúN√£o crie ou use fun√ß√µes vari√°veis ‚Äã‚Äãde C‚Äù, mas elas n√£o remover√£o seu suporte do C ++ Standard.  Portanto, h√° algum benef√≠cio nesses recursos?  Bem a√≠. <br><br><ul><li>  O caso mais comum e √≥bvio √© a compatibilidade com vers√µes anteriores.  Aqui, incluirei o uso de bibliotecas C de terceiros (meu caso com JNI) e o fornecimento da API C para a implementa√ß√£o C ++. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Falha na substitui√ß√£o n√£o √© um erro">SFINAE</a> .  √â muito √∫til aqui que, em C ++, n√£o √© necess√°rio que uma fun√ß√£o vari√°vel tenha argumentos nomeados e que, ao resolver fun√ß√µes sobrecarregadas, uma fun√ß√£o vari√°vel √© considerada a √∫ltima (se houver pelo menos um argumento).  E, como qualquer outra fun√ß√£o, uma fun√ß√£o vari√°vel s√≥ pode ser declarada, mas nunca chamada. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Embora no C ++ 14 voc√™ possa fazer um pouco diferente. <br><br><div class="spoiler">  <b class="spoiler_title">Outro exemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  E, neste caso, j√° √© necess√°rio observar com que argumentos <code>detect(...)</code> podem ser chamados.  Eu preferiria mudar algumas linhas e usar uma alternativa moderna a fun√ß√µes vari√°veis, desprovida de todas as suas defici√™ncias. <br></li></ul><br><h3>  Modelos de variantes ou como criar fun√ß√µes a partir de um n√∫mero arbitr√°rio de argumentos no C ++ moderno </h3><br>  A ideia de modelos vari√°veis ‚Äã‚Äãfoi proposta por Douglas Gregor, Jaakko J√§rvi e Gary Powell em 2004, ou seja,  7 anos antes da ado√ß√£o do padr√£o C ++ 11, no qual esses modelos de vari√°veis ‚Äã‚Äãeram oficialmente suportados.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Norma incluiu uma terceira revis√£o de sua proposta, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde o in√≠cio, modelos vari√°veis ‚Äã‚Äãforam criados para que os programadores tivessem a oportunidade de criar fun√ß√µes seguras para tipos (e port√°teis!) A partir de um n√∫mero arbitr√°rio de argumentos. </font><font style="vertical-align: inherit;">Outro objetivo √© simplificar o suporte a modelos de classe com um n√∫mero vari√°vel de par√¢metros, mas agora estamos falando apenas de fun√ß√µes vari√°veis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelos de vari√°veis ‚Äã‚Äãtrouxeram tr√™s novos conceitos para o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metros do modelo de pacote ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">template par√¢metro pacote</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - √© um modelo de par√¢metro, em vez de que √© poss√≠vel transferir qualquer (incluindo 0) n√∫mero de argumento modelo;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um pacote de par√¢metros de fun√ß√£o (pacote de par√¢metros de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - portanto, este √© um par√¢metro de fun√ß√£o que aceita qualquer n√∫mero (incluindo 0) de argumentos de fun√ß√£o;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a expans√£o do pacote ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expans√£o do pacote</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √© a √∫nica coisa que pode ser feita com o pacote de par√¢metros.</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> ‚Äî   , <code>Args ... args</code> ‚Äî   ,  <code>args...</code> ‚Äî    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma lista completa de onde e como os pacotes de par√¢metros podem ser expandidos √© fornecida no pr√≥prio Padr√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E no contexto da discuss√£o de fun√ß√µes vari√°veis, basta dizer que:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pacote de par√¢metros da fun√ß√£o pode ser expandido para a lista de argumentos de outra fun√ß√£o</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou para a lista de inicializa√ß√£o</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou para a lista de captura lambda</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outro pacote de par√¢metros de fun√ß√£o pode ser expandido em uma express√£o de convolu√ß√£o</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As convolu√ß√µes apareceram em C ++ 14 e podem ser un√°rias e bin√°rias, direita e esquerda. </font><font style="vertical-align: inherit;">A descri√ß√£o mais completa, como sempre, est√° no Padr√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os dois tipos de pacotes de par√¢metros podem ser expandidos para sizeof ... operator</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na divulga√ß√£o do pacote retic√™ncias expl√≠cita √© necess√°ria para apoiar os v√°rios modelos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padr√µes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) a divulga√ß√£o e para evitar essa ambig√ºidade.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Por exemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> ‚Äî      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> ‚Äî ,     ‚Äî   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exemplo de implementa√ß√£o de printf usando modelos vari√°veis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como j√° mencionei, os modelos de vari√°veis ‚Äã‚Äãtamb√©m foram criados como substitutos diretos das fun√ß√µes vari√°veis ‚Äã‚Äãde C. Os autores desses modelos propuseram sua vers√£o muito simples, mas segura para o tipo </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- uma das primeiras fun√ß√µes vari√°veis ‚Äã‚Äãdo C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf em modelos</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu suspeito, ent√£o esse padr√£o de enumera√ß√£o de argumentos vari√°veis ‚Äã‚Äãapareceu - atrav√©s de uma chamada recursiva de fun√ß√µes sobrecarregadas. </font><font style="vertical-align: inherit;">Mas ainda prefiro a op√ß√£o sem recurs√£o.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf em modelos e sem recurs√£o</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resolu√ß√£o de sobrecarga e fun√ß√µes de modelo vari√°vel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na resolu√ß√£o, essas fun√ß√µes variativas s√£o consideradas, depois de outras, como padr√£o e menos especializadas. </font><font style="vertical-align: inherit;">Mas n√£o h√° problema no caso de uma chamada sem argumentos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de sobrecarga</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado do lan√ßamento</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a sobrecarga √© resolvida, uma fun√ß√£o de modelo vari√°vel pode ignorar apenas uma fun√ß√£o C vari√°vel (embora por que mistur√°-las?). </font><font style="vertical-align: inherit;">Exceto - √© claro! </font><font style="vertical-align: inherit;">- ligar sem argumentos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligar sem argumentos</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado do lan√ßamento</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√° uma compara√ß√£o com uma elipse - a fun√ß√£o correspondente perde, n√£o h√° compara√ß√£o com uma elipse - e a fun√ß√£o de modelo √© inferior √† n√£o-modelo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma observa√ß√£o r√°pida sobre a velocidade das fun√ß√µes de modelo vari√°vel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em 2008, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo√Øc Joly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enviou sua proposta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao Comit√™ de Padroniza√ß√£o do C ++ </font><font style="vertical-align: inherit;">, no qual mostrou na pr√°tica que fun√ß√µes de modelo vari√°vel funcionam mais lentamente que fun√ß√µes semelhantes, cujo argumento √© a lista de inicializa√ß√£o ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">E, embora isso contradisse as justificativas te√≥ricas do pr√≥prio autor, Joli prop√¥s implement√°-lo </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi com a ajuda de listas de inicializa√ß√£o, e n√£o de modelos vari√°veis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas j√° em 2009, uma refuta√ß√£o apareceu. </font><font style="vertical-align: inherit;">Nos testes de Joli, um "erro grave" foi descoberto (parece at√© para si mesmo). </font><font style="vertical-align: inherit;">Novos testes (veja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) mostrou que as fun√ß√µes de modelo vari√°vel ainda s√£o mais r√°pidas e, √†s vezes, significativamente. </font><font style="vertical-align: inherit;">O que n√£o √© surpreendente, j√° que </font><font style="vertical-align: inherit;">a lista de inicializa√ß√£o faz c√≥pias de seus elementos e, para modelos vari√°veis, voc√™ pode contar muito no est√°gio de compila√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, no C ++ 11 e nos padr√µes subseq√ºentes </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o fun√ß√µes de modelo comuns, um n√∫mero arbitr√°rio de argumentos aos quais s√£o passados ‚Äã‚Äãpela lista de inicializa√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breve resumo e conclus√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portanto, fun√ß√µes vari√°veis ‚Äã‚Äãno estilo C: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eles n√£o sabem o n√∫mero de seus argumentos ou seus tipos. </font><font style="vertical-align: inherit;">O desenvolvedor deve usar parte dos argumentos da fun√ß√£o para passar informa√ß√µes sobre o restante.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aumente implicitamente os tipos de argumentos n√£o nomeados (e o √∫ltimo nomeado). </font><font style="vertical-align: inherit;">Se voc√™ se esquecer disso, ter√° um comportamento vago.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eles mant√™m compatibilidade com o C puro e, portanto, n√£o suportam a passagem de argumentos por refer√™ncia. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes do C ++ 11, os argumentos que n√£o </font><font style="vertical-align: inherit;">eram do tipo </font></font><abbr title="Dados antigos simples"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o </font><font style="vertical-align: inherit;">eram </font><font style="vertical-align: inherit;">suportados </font><font style="vertical-align: inherit;">e, desde o C ++ 11, o suporte para tipos n√£o triviais era deixado a crit√©rio do compilador.</font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O comportamento do c√≥digo depende do compilador e de sua vers√£o. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √∫nico uso permitido de fun√ß√µes vari√°veis ‚Äã‚Äã√© interagir com a API C no c√≥digo C ++. </font><font style="vertical-align: inherit;">Para todo o resto, incluindo </font></font><abbr title="Falha na substitui√ß√£o n√£o √© um erro"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , existem fun√ß√µes de modelo vari√°vel que:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conhe√ßa o n√∫mero e os tipos de todos os seus argumentos. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Digite safe, n√£o altere os tipos de seus argumentos. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eles suportam a passagem de argumentos de qualquer forma - por valor, por ponteiro, por refer√™ncia, por link universal. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como qualquer outra fun√ß√£o C ++, n√£o h√° restri√ß√µes nos tipos de argumentos. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As fun√ß√µes de modelo vari√°vel podem ser mais detalhadas em compara√ß√£o com suas contrapartes no estilo C e, √†s vezes, at√© exigem sua pr√≥pria vers√£o n√£o-modelo sobrecarregada (passagem de argumento recursivo). </font><font style="vertical-align: inherit;">Eles s√£o mais dif√≠ceis de ler e escrever. </font><font style="vertical-align: inherit;">Mas tudo isso √© mais do que pago pela aus√™ncia das defici√™ncias listadas e pela presen√ßa das vantagens listadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, a conclus√£o √© simples: as fun√ß√µes variadas no estilo C permanecem no C ++ apenas por causa da compatibilidade com vers√µes anteriores, e oferecem uma ampla gama de op√ß√µes para fotografar sua perna. </font><font style="vertical-align: inherit;">No C ++ moderno, √© altamente recomend√°vel n√£o escrever novos e, se poss√≠vel, n√£o usar fun√ß√µes C vari√°veis ‚Äã‚Äãexistentes. </font><font style="vertical-align: inherit;">As fun√ß√µes de modelo vari√°vel pertencem ao mundo do C ++ moderno e s√£o muito mais seguras. </font><font style="vertical-align: inherit;">Use-os.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literatura e Fontes </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, Biblioteca Padr√£o C</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan e Dennis M. Ritchie, Linguagem de Programa√ß√£o C, 1¬™ Edi√ß√£o</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan e Dennis M. Ritchie, Linguagem de Programa√ß√£o C, 2¬™ Edi√ß√£o</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norma C11, projecto N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o C ++ 98</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o C ++ 03</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o C ++ 11, rascunho N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o C ++ 14, projeto N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o C ++ 17, rascunho N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â f√°cil encontrar e baixar vers√µes eletr√¥nicas dos livros mencionados na rede. </font><font style="vertical-align: inherit;">Mas n√£o tenho certeza de que ser√° legal, ent√£o n√£o dou links.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430064/">https://habr.com/ru/post/pt430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430052/index.html">Por que √© importante que os desenvolvedores de hardware conduzam cusdev de qualidade</a></li>
<li><a href="../pt430054/index.html">HolyJS 2018 Moscow: transmiss√£o online gratuita, festa e rap de ci√™ncia e tecnologia</a></li>
<li><a href="../pt430058/index.html">Processos de onda em linhas hidr√°ulicas. O b√°sico</a></li>
<li><a href="../pt430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva - a m√°gica da programa√ß√£o</a></li>
<li><a href="../pt430062/index.html">Microsservi√ßos. Padr√µes de desenvolvimento e refatora√ß√£o com exemplos Java</a></li>
<li><a href="../pt430068/index.html">Ordem da cris√°lida</a></li>
<li><a href="../pt430070/index.html">Pilha e fila s√£o dois paradigmas ruins e o que pode ser feito sobre isso</a></li>
<li><a href="../pt430072/index.html">Swift do lado do servidor subestimado: Entrevista com Paul Hudson</a></li>
<li><a href="../pt430074/index.html">Como quase peguei um v√≠rus tentando vender botas</a></li>
<li><a href="../pt430076/index.html">Transmiss√£o gratuita do DotNext 2018 Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>