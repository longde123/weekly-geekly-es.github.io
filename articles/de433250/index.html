<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öíÔ∏è üèôÔ∏è üë®üèΩ‚Äçüéì OpenVPN mit erweiterter Authentifizierung und Autorisierung üôãüèæ üç≠ üßöüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel beschreibt die Konfiguration von OpenVPN mit zus√§tzlichen Funktionen: 



- Token-Zertifikate f√ºr die prim√§re Authentifizierung (Rutoken a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenVPN mit erweiterter Authentifizierung und Autorisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433250/">  Der Artikel beschreibt die Konfiguration von OpenVPN mit zus√§tzlichen Funktionen: <br><br><ul><li>  Token-Zertifikate f√ºr die prim√§re Authentifizierung (Rutoken als Beispiel) </li><li>  LDAP-Backend f√ºr die sekund√§re Authentifizierung (am Beispiel von ActiveDirectory) </li><li>  Filtern interner Ressourcen, die Benutzern zur Verf√ºgung stehen (√ºber iptables) </li></ul><br>  Au√üerdem wird beschrieben, wie Sie Clients f√ºr Linux, Windows und MacOS konfigurieren. <br><a name="habracut"></a><br><h3>  Server-Setup </h3><br><h4>  Installieren Sie OpenVPN </h4><br>  Nehmen Sie das Skript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nyr / openvpn-install</a> und f√ºhren Sie es von root aus. <br><br><pre><code class="plaintext hljs">git clone https://github.com/Nyr/openvpn-install.git cd openvpn-install</code> </pre> <br>  Der Startvorgang wird einige Fragen stellen. <br><br><ul><li>  udp-Protokoll </li><li>  Port 1194 </li><li>  DNS-Server - Lokal </li><li>  externe IP-Gateway-Adresse im Internet, √ºber die der VPN-Server verf√ºgbar sein wird </li></ul><br>  Es gibt auch eine sicherheitsverbesserte Version des urspr√ºnglichen Skripts - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/Angristan/OpenVPN-install</a> .  Es hat mehr Verschl√ºsselungseinstellungen mit Erkl√§rungen, warum. <br><br><h4>  Benutzerverwaltung </h4><br>  <b>Hinzuf√ºgen</b> <br>  Wenn keine Token verwendet werden, wird der Benutzer √ºber dasselbe Skript hinzugef√ºgt.  Das Skript generiert im Wesentlichen eine benutzerdefinierte ovpn-Konfiguration und f√ºgt dort ein vom Stammzertifikat signiertes Zertifikat ein. <br><br>  Wenn Token verwendet werden (siehe Abschnitt √ºber Token unten), wird das Zertifikat manuell ausgeschrieben, basierend auf der Anforderung des Zertifikats, das auf dem Token generiert wird.  Die Benutzerkonfiguration muss manuell aus der vorhandenen Vorlage erfolgen (aus derselben Vorlage, aus der das Konfigurationsskript generiert wird).  Die Vorlage finden Sie hier <code>/etc/openvpn/client-common.txt</code> .  Es ist nicht im openvpn-Paket enthalten und wird vom Skript w√§hrend des Konfigurationsprozesses generiert. <br><br>  <b>L√∂schen</b> <br>  Das Entfernen von Benutzern erfolgt √ºber dasselbe Installationsskript.  Das Zertifikat wird der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRL</a> hinzugef√ºgt, die neue CRL wird auf den VPN-Server √ºbertragen.  Der Server betrachtet alle Zertifikate in CRL als ung√ºltig und lehnt die Annahme ab. <br><br>  So widerrufen Sie ein Zertifikat manuell: <br><br><pre> <code class="plaintext hljs">cd /etc/openvpn/easyrsa #   ./easyrsa revoke $CLIENT #   crl ./easyrsa gen-crl #   crl rm -rf /etc/openvpn/crl.pem #    cp /etc/openvpn/easy-rsa/pki/crl.pem /etc/openvpn/crl.pem # openvpn    crl,       nobody chown nobody:nobody /etc/openvpn/crl.pem</code> </pre><br><h4>  Filtern verf√ºgbarer Hosts f√ºr Clients </h4><br>  Clients m√ºssen durch die Hosts eingeschr√§nkt werden, auf die sie im Netzwerk zugreifen k√∂nnen, wenn sie eine Verbindung zu openvpn herstellen. <br><br>  <b>Manuell</b> <br><br>  Die Idee ist, Pakete auch auf der <code>tun0</code> Schnittstelle <code>tun0</code> , in die sie von Clients kommen, und sie zu filtern, bevor sie in NAT gelangen.  Nach NAT gibt es keinen Grund, sie zu filtern - alle haben eine OpenVPN-Server-IP-Adresse im internen Netzwerk.  Vor dem Einstieg in NAT haben Pakete f√ºr jeden Benutzer eine eigene eindeutige IP-Adresse (Informationen zur Entsprechung von IP-Adressen und Benutzern finden Sie in der Datei <code>/etc/openvpn/ipp.txt</code> ). <br><br>  Pakete, die das System passieren (nicht direkt von ihm kommen und nicht eingehen, dh vom System weitergeleitet werden), werden von der FORWARD-Tabelle verarbeitet.  Tabellen in iptables werden von oben nach unten verarbeitet. Wenn keine der Regeln in der Tabelle zu einer Entscheidung √ºber das Schicksal des Pakets gef√ºhrt hat, wird die Standardregel ausgel√∂st. <br><br>  Vorbereiten der FORWARD-Tabelle: <br><br><pre> <code class="plaintext hljs">#   iptables -F FORWARD #     FORWARD -    iptables -P FORWARD DROP #     iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</code> </pre><br>  Beispielregeln f√ºr einen bestimmten Client.  Da die Standardregel f√ºr die Tabelle DROP ist, bleiben nur die Host + Port-Paare zul√§ssig, wo Sie k√∂nnen.  Erm√∂glichen Sie den Zugriff auf den Port auf dem Host + Pingen Sie den Host selbst an: <br><br><pre> <code class="plaintext hljs">iptables -I FORWARD -s 10.8.0.3 -i tun0 -d 10.0.2.3 -p tcp --dport 443 -j ACCEPT iptables -I FORWARD -s 10.8.0.3 -i tun0 -d 10.0.2.3 -p icmp --icmp-type echo-request -j ACCEPT</code> </pre><br>  Im obigen Beispiel kann Host 10.8.0.3 auf Port 443 von Host 10.0.2.3 zugreifen. <br><br>  So schlie√üen Sie den Zugriff: <br><br><pre> <code class="plaintext hljs">#         iptables -L FORWARD --line-numbers #     iptables -D FORWARD { }</code> </pre><br>  Dann m√ºssen Sie alle Regeln f√ºr einen bestimmten Client finden und l√∂schen. <br><br>  W√§hrend des Debuggens k√∂nnen Sie bequem √ºberpr√ºfen, welche Regeln funktionieren.  Jede Regel hat einen Z√§hler f√ºr verarbeitete Pakete. <br><br><pre> <code class="plaintext hljs">#  ,      watch iptables -nvL FORWARD #     iptables -Z FORWARD</code> </pre><br>  <b>Automatisch</b> <br><br>  Ein openvpn-Server kann Skripts f√ºr bestimmte Aktionen ausf√ºhren.  Insbesondere beim Verbinden und Trennen von Clients.  Skripte k√∂nnen auf alles geschrieben werden, wenn sie nur ausf√ºhrbar sind.  Innerhalb des Skripts √ºbergeben Umgebungsvariablen alle m√∂glichen Parameter an die aktuelle Verbindung.  Wir interessieren uns f√ºr Variablen: <br><br><ul><li>  <code>common_name</code> (Name des Inhabers des Zertifikats; was wird beim Erstellen des Zertifikats in das Feld common name <code>common_name</code> ) </li><li>  <code>ifconfig_pool_remote_ip</code> (Client-IP-Adresse auf tun0) </li><li>  <code>script_type</code> (welches Ereignis ist <code>script_type</code> - verbinden oder trennen). </li></ul><br>  Sie ben√∂tigen Root-Rechte, um iptables zu verwalten.  Openvpn setzt nach dem Verbinden die Rechte auf niemanden zur√ºck und f√ºhrt Skripte aus.  Es ist schlecht, niemandem zu erlauben, etwas unter sudo zu tun, und es ist besser, kein Sternchen in den Regeln zu verwenden, aber irgendwie muss man dem Benutzer erlauben, iptables zu steuern. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /etc/sudoers.d/50_openvpn # #    nobody ALL = NOPASSWD: /sbin/iptables -A FORWARD* #     nobody ALL = NOPASSWD: /sbin/iptables -L FORWARD* #    nobody ALL = NOPASSWD: /sbin/iptables -D FORWARD*</span></span></code> </pre><br>  In der Serverkonfiguration m√ºssen Sie die Berechtigung zum Ausf√ºhren von Dateien von Drittanbietern hinzuf√ºgen und zwei Hooks aktivieren, die f√ºr das Verbinden und Trennen des Benutzers verantwortlich sind. <br><br><pre> <code class="bash hljs">script-security 2 client-connect /etc/openvpn/bin/hosts.rb client-disconnect /etc/openvpn/bin/hosts.rb</code> </pre><br>  Das Skript selbst, das die Konfigurationen liest und die Regeln f√ºr iptables anwendet.  Das Skript funktioniert nach denselben Prinzipien wie im vorherigen Abschnitt beschrieben. <br><br><div class="spoiler">  <b class="spoiler_title">/openvpn/bin/hosts.rb</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/ruby # -*- coding: utf-8 -*- require 'pp' def log(string) puts 'hosts.rb: ' + string end def parse_config_file(name) config_path = "hosts/#{name}" unless File.exist?(config_path) puts "There is no specific configuration for #{name}." p name exit 0 end config_source = IO.read(config_path).split("\n") config = config_source.inject([]) do |result,line| ip, port, protocol = line.split(/\s+/) result &lt;&lt; { ip: ip, port: port, protocol: protocol || 'tcp' } end end def get_config(name) user_config = parse_config_file(name) if user_config everybody_config = parse_config_file('everybody') end everybody_config + user_config end def apply_rule(rule) command = "sudo iptables #{rule}" log(command) system(command) end def remove_rule(number) command = "sudo iptables -D FORWARD #{number}" log(command) system(command) end def allow_target(source_ip, options) #         . apply_rule("-A FORWARD -s #{source_ip} -i tun0 -d #{options[:ip]} -p #{options[:protocol]} --dport #{options[:port]} -j ACCEPT") #       apply_rule("-A FORWARD -s #{source_ip} -i tun0 -d #{options[:ip]} -p icmp --icmp-type echo-request -j ACCEPT") end def clear_targets(source_ip) #      FORWARD,  source_ip. rules_exist = true while rules_exist table = `sudo iptables -L FORWARD --line-number`.split("\n") the_line = table.find do |line| fields = line.split(/\s+/) ip = fields[4] ip == source_ip end if the_line number = the_line.split(/\s+/)[0] remove_rule(number) else rules_exist = false end end end ################################################################################ script_type = ENV['script_type'] log(script_type) name = ENV['common_name'] source_ip = ENV['ifconfig_pool_remote_ip'] case script_type when 'client-connect' config = get_config(name) config.each{|target| allow_target(source_ip, target)} when 'client-disconnect' clear_targets(source_ip) else puts "Unknown script type #{script_type}." end</span></span></code> </pre></div></div><br>  Regeln werden in Dateien gespeichert, die dem allgemeinen Namen der Zertifikate im Ordner <code>/etc/openvpn/hosts</code> .  Sie geben genau an, welche IP-Adressen f√ºr einen bestimmten Client verf√ºgbar sind.  Trennzeichen - eine beliebige Anzahl von Leerzeichen.  Die IP-Adresse, der Port und das Protokoll (tcp oder udp) werden √ºber das Trennzeichen geschrieben. <br><br><pre> <code class="bash hljs">10.0.0.24 53 udp 10.0.0.25 53 udp 10.0.2.3 443 tcp</code> </pre><br>  Daher sollte die folgende Struktur im Ordner <code>/etc/openvpn</code> <br><br>  Bin‚îÄ‚îÄ bin <br>  ‚îÇ ‚îî hosts.rb <br>  ‚îú‚îÄ‚îÄ Hosts <br>  ‚îÇ ‚îú Benutzer1 <br>  ‚îÇ ‚îú Benutzer2 <br>  Everybody ‚îî alle <br>  ‚îú‚îÄ‚îÄ server.conf <br>  ‚îî‚îÄ‚îÄ ... <br><br>  <code>User1</code> und <code>user2</code> sind Dateien im obigen Format.  Sie beschreiben, auf welche Hosts der Benutzer mit dem entsprechenden allgemeinen Namen Zugriff hat. <br><br>  Es gibt eine weitere zus√§tzliche Datei f√ºr alle Benutzer, die Regeln enth√§lt, die f√ºr alle Clients gelten, sofern f√ºr diese Clients eine separate Konfigurationsdatei vorhanden ist.  Das hei√üt, wenn der Benutzer eine Liste von Hosts hat, auf die er gehen kann, werden diese Liste und die Hosts, die in <code>everybody</code> angewendet.  Wenn nicht, dann <code>everybody</code> nicht <code>everybody</code> anwendbar.  Beispielsweise kann ein DNS-Server bequem in diese Datei eingef√ºgt werden. <br><br>  <b>Protokollierung</b> <br><br>  Das Installationsskript enth√§lt nur die Protokollierung aktueller Verbindungen ( <code>status)</code> .  Damit ein regul√§res Protokoll angezeigt wird, m√ºssen Sie der Serverkonfiguration ( <code>/etc/openvpn/server.conf</code> ) eine Zeile hinzuf√ºgen: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-append /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/openvpn.log</code> </pre> <br><br>  <b>LDAP</b> <br><br>  Es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">openvpn-auth-ldap-</a> Plugin, mit dem Sie einen Benutzer erneut √ºber LDAP authentifizieren k√∂nnen. <br><br>  Paket liefern: <br><br><pre> <code class="plaintext hljs">sudo yum install openvpn-auth-ldap</code> </pre> <br>  Zur server.conf hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">plugin /usr/lib64/openvpn/plugin/lib/openvpn-auth-ldap.so "/etc/openvpn/ldap.conf"</code> </pre> <br>  Erstellen Sie eine Konfiguration f√ºr ldap in <code>/etc/openvpn/ldap.conf</code> : <br><pre> <code class="plaintext hljs">&lt;LDAP&gt; URL ldaps://{LDAP_DOMAIN_HERE} Timeout 15 TLSEnable no FollowReferrals yes BindDN "BIND_DN_HERE" Password "BIND_PASSWORD_HERE" &lt;/LDAP&gt; &lt;Authorization&gt; BaseDN "{BASE_DN_HERE}" SearchFilter "(&amp;(sAMAccountName=%u)(objectClass=organizationalPerson)(objectCategory=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))" RequireGroup false &lt;/Authorization&gt;</code> </pre><br>  F√ºgen Sie die Zeile zur benutzerdefinierten ovpn-Konfiguration hinzu: <br><br><pre> <code class="plaintext hljs">auth-user-pass</code> </pre> <br>  Daher wird der Benutzer zuerst nach dem Benutzernamen und dem Kennwort der Dom√§ne und dann nach der PIN des Tokens gefragt.  Wenn einer dieser Schritte fehlschl√§gt, wird die Verbindung nicht hergestellt. <br><br>  Die Beschreibung der Optionen f√ºr ldap.conf <a href="">befindet sich im Plugin-Repository</a> .  Es unterst√ºtzt die Authentifizierung durch Gruppenmitgliedschaft, aber ich habe es nicht getestet. <br><br><h4>  Geschwindigkeit </h4><br>  Die gr√∂√üte Geschwindigkeitssteigerung ergibt den UDP-Modus.  Dies wird in allen Handb√ºchern empfohlen.  Der Punkt ist, dass es keinen Sinn macht, eine TCP-Client-Verbindung in einem TCP-Kanal zu starten.  Ein TCP auf dem Client reicht aus, um die Pakete korrekt zuzustellen.  Wenn Pakete im udp-Kanal verloren gehen, steuert die Client-TCP-Verbindung die Zustellungsanpassung. <br><br>  Die Geschwindigkeit erh√∂ht sich zumindest, weil nicht auf die Best√§tigung der Zustellung jedes Pakets im Kanal gewartet werden muss.  Es gibt ein zweites Problem mit TCP - ein Client-TCP-Paket passt h√∂chstwahrscheinlich nicht in ein Paket des VPN-Kanals.  Die MTU ist dieselbe, aber dem Client-Paket m√ºssen Header hinzugef√ºgt werden.  Infolgedessen m√ºssen Sie pro Benutzerpaket zwei Pakete innerhalb des VPN-Kanals senden. <br><br>  Die Verwendung von TCP ist sinnvoll, wenn dies auf andere Weise nicht m√∂glich ist.  Zum Beispiel, wenn VPN √ºber den SSH-Kanal arbeitet. <br><br><h4>  Beispiel einer vollst√§ndigen Serverkonfiguration </h4><br><div class="spoiler">  <b class="spoiler_title">example-server.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">port 1194 proto tcp dev tun sndbuf 0 rcvbuf 0 ca ca.crt cert server.crt key server.key dh dh.pem tls-auth ta.key 0 topology subnet server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt push "redirect-gateway def1 bypass-dhcp" push "dhcp-option DNS 10.0.0.25" push "dhcp-option DNS 10.0.0.24" keepalive 10 120 cipher AES-256-CBC comp-lzo user nobody group nobody persist-key persist-tun status openvpn-status.log verb 3 crl-verify crl.pem log-append /var/log/openvpn.log script-security 2 client-connect /etc/openvpn/bin/hosts.rb client-disconnect /etc/openvpn/bin/hosts.rb</code> </pre><br></div></div><br><h3>  Token-Setup </h3><br><h4>  PKCS # 11 Bibliothek </h4><br>  Um mit Token arbeiten zu k√∂nnen, ben√∂tigen Sie eine spezielle Bibliothek.  Die Bibliothek wird sowohl zum Erstellen von Schl√ºsselpaaren als auch f√ºr die eigentliche Verbindung ben√∂tigt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Download f√ºr alle Plattformen √ºber den Link</a> . <br><br>  √úberall dort, wo sp√§ter librtpkcs11ecp.so gefunden wird, muss genau diese Bibliothek heruntergeladen und an einem geeigneten Ort abgelegt werden. <br><br><h4>  Erstellen eines Zertifikats f√ºr ein Token </h4><br>  Generieren Sie ein Schl√ºsselpaar f√ºr das Token.  Der Parameter id ist hier die Seriennummer des Steckplatzes auf dem Token, in den das Schl√ºsselpaar passt. <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /usr/lib64/librtpkcs11ecp.so --keypairgen --key-type rsa:2048 -l --id 01</code> </pre><br>  Stellen Sie eine Zertifikatanforderung f√ºr den √∂ffentlichen Schl√ºssel.  Beim Erstellen einer Zertifikatanforderung werden die Lebensdauer des Zertifikats und der allgemeine Name festgelegt, mit denen die verf√ºgbaren IP-Adressen im Netzwerk gefiltert werden.  Der allgemeine Name muss mit der Anmeldung in ActiveDirectory √ºbereinstimmen, damit keine Verwirrung entsteht. <br><br><pre> <code class="plaintext hljs">openssl openssl&gt; engine -t dynamic -pre SO_PATH:/usr/lib64/openssl/engines/pkcs11.so -pre ID:pkcs11 -pre LIST_ADD:1 -pre LOAD -pre MODULE_PATH:/usr/lib64/librtpkcs11ecp.so openssl&gt; req -engine pkcs11 -new -key slot_0-id_01 -keyform engine -out /home/john/good.req</code> </pre><br>  Die empfangene Anfrage muss in den <code>/etc/openvpn/easy-rsa/pki/reqs/</code> .  Die Dateierweiterung muss erforderlich sein. <br>  Konvertieren einer Anfrage in ein Zertifikat: <br><br><pre> <code class="plaintext hljs">cd /etc/openvpn/easy-rsa/ ./easyrsa sign-req client good</code> </pre><br>  Danach wird im Ordner <code>/etc/openvpn/easy-rsa/pki/issued/</code> ein Zertifikat mit demselben Namen, aber der Erweiterung <code>crt</code> <code>/etc/openvpn/easy-rsa/pki/issued/</code> . <br><br>  Vor der Aufzeichnung muss das Zertifikat in DER konvertiert werden: <br><br><pre> <code class="plaintext hljs">openssl x509 -in /home/user/user-cert.pem -out /home/user/user-cert.crt -outform DER</code> </pre><br>  Schreiben eines Zertifikats f√ºr ein Token: <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /usr/lib/librtpkcs11ecp.so -l -y cert -w /home/user/user-cert.crt --id 45 --label TEST</code> </pre> <br>  Es basiert auf dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûVerwenden von Rutoken EDS mit OpenSSL (RSA)‚Äú</a> . <br><br><h4>  Token zur Authentifizierung verwenden </h4><br>  Suchen Sie die ID des Zertifikats, das dem Server pr√§sentiert werden soll: <br><br><pre> <code class="plaintext hljs">$ openvpn --show-pkcs11-ids /usr/lib64/librtpkcs11ecp.so The following objects are available for use. Each object shown below may be used as parameter to --pkcs11-id option please remember to use single quote mark. Certificate DN: /CN=User1 Serial: 490B82C4000000000075 Serialized id: aaaa/bbb/41545F5349474E415455524581D2A1A1B23C4AA4CB17FAF7A4600</code> </pre><br>  Wir sind hier an einer serialisierten ID interessiert. <br><br>  Optionen, die in der ovpn-Konfiguration eingegeben werden m√ºssen, damit Token aufgenommen werden: <br><br><pre> <code class="plaintext hljs">pkcs11-providers /usr/lib64/librtpkcs11ecp.so pkcs11-id 'aaaa/bbb/41545F5349474E415455524581D2A1A1B23C4AA4CB17FAF7A4600'</code> </pre> <br>  Die Option <code>pkcs11-id</code> <b>muss in einfache Anf√ºhrungszeichen gesetzt werden.</b> <br><br>  Dieses Handbuch ist auf allen Plattformen sinnvoll.  Sie m√ºssen den Pfad zur Bibliothek und die Zertifikat-ID auf dem Token angeben.  Die Bibliothek kann etwas anders aufgerufen werden, sei <code>.dll</code> , nicht <code>.so</code> , aber die Bedeutung ist dieselbe. <br><br>  In diesem Fall m√ºssen Sie die Abschnitte <code>cert</code> und <code>key</code> aus der ovpn-Datei entfernen, da das Zertifikat und der private Schl√ºssel dem Token entnommen werden. <br><br>  Die vollst√§ndige Client-Konfiguration (f√ºr Windows) sieht folgenderma√üen aus: <br><br><div class="spoiler">  <b class="spoiler_title">client.ovpn</b> <div class="spoiler_text"> <code>client <br> dev tun <br> proto tcp <br> sndbuf 0 <br> rcvbuf 0 <br> remote 78.47.37.247 22222 <br> resolv-retry infinite <br> nobind <br> persist-key <br> persist-tun <br> remote-cert-tls server <br> cipher AES-256-CBC <br> comp-lzo <br> setenv opt block-outside-dns <br> key-direction 1 <br> verb 3 <br> <br> pkcs11-providers "c://Windows//System32//rtPKCS11ECP.dll" <br> pkcs11-id 'Aktiv\x20Co\x2E/Rutoken\x20ECP/342b871d/Rutoken/01' <br> <br> -----BEGIN CERTIFICATE----- <br> {CERT_HERE} <br> -----END CERTIFICATE----- <br> <br> <br> &lt;tls-auth&gt; <br> # <br> # 2048 bit OpenVPN static key <br> # <br> -----BEGIN OpenVPN Static key V1----- <br> {KEY_HERE} <br> -----END OpenVPN Static key V1----- <br> &lt;/tls-auth&gt;</code> <br> </div></div><br>  Geschrieben basierend auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Hinzuf√ºgen einer Dual-Faktor-Authentifizierung zu einer OpenVPN-Konfiguration mithilfe clientseitiger Smartcards".</a> <br><br><h3>  Kundeneinrichtung </h3><br><h4>  Linux </h4><br>  Openvpn hat einen Fehler, der den Benutzer daran hindert, den PIN-Code vom Token einzugeben, wenn das Paket mit systemd-Unterst√ºtzung erstellt wird.  Da systemd in letzter Zeit √ºberall war, werden alle Pakete, die bereits in den Repositorys verf√ºgbar sind, mit seiner Unterst√ºtzung kompiliert.  Clients unter Linux m√ºssen das Paket selbst sammeln.  Hier ist eine Beispielkonfiguration, die f√ºr mich unter Arch Linux funktioniert hat: <br><br><pre> <code class="plaintext hljs">./configure \ --prefix=/usr \ --sbindir=/usr/bin \ --enable-iproute2 \ --enable-pkcs11 \ --enable-plugins \ --enable-x509-alt-username</code> </pre><br>  Mit dem folgenden Befehl k√∂nnen Sie √ºberpr√ºfen, ob openvpn mit oder ohne systemd erstellt wurde: <br><br><pre> <code class="plaintext hljs">openvpn --version | grep --color enable_systemd</code> </pre><br><h4>  Mas os </h4><br>  Unter Mac OS gibt es nur einen kostenlosen Client - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tunnelblink</a> . <br><br>  Er wei√ü nicht, wie er einen PIN-Code von einem Token von GUI eingeben soll.  Der Fehler wird zum Beispiel hier beschrieben - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://groups.google.com/forum/#!topic/tunnelblick-discuss/f_Rp_2nV-x8</a> Umgangen durch Starten von openvpn √ºber die Konsole.  Dies ist nicht √ºberraschend, da der offizielle Client f√ºr Windows dies ebenfalls nicht wei√ü. <br><br>  Auch unter Mac OS (im Gegensatz zu Windows) sind zus√§tzliche Skripte erforderlich, um das Netzwerk zu konfigurieren.  Wenn Sie openvpn einfach √ºber die Konsole ausf√ºhren, funktioniert DNS nicht (m√∂glicherweise wird nur DNS angezeigt). <br><br>  TunnelBlick verf√ºgt √ºber diese Netzwerkkonfigurationsskripts. Sie m√ºssen nur beim Herstellen und Trennen der Verbindung aufgerufen werden.  Was Sie zur ovpn-Konfiguration hinzuf√ºgen m√ºssen: <br><br><pre> <code class="bash hljs">script-security 2 up <span class="hljs-string"><span class="hljs-string">"/Applications/Tunnelblick.app/Contents/Resources/client.up.tunnelblick.sh -9 -d -f -m -w -ptADGNWradsgnw"</span></span> down <span class="hljs-string"><span class="hljs-string">"/Applications/Tunnelblick.app/Contents/Resources/client.down.tunnelblick.sh -9 -d -f -m -w -ptADGNWradsgnw"</span></span></code> </pre> <br>  Ein Beispielskript zum Starten einer openvpn-Verbindung, das auf den Desktop gestellt und mit der Maus gesto√üen werden kann: <br><br><pre> <code class="plaintext hljs">#!/bin/bash tunnelblick=/Applications/Tunnelblick.app/Contents/Resources/openvpn/openvpn-2.4.2-openssl-1.0.2k sudo $tunnelblick/openvpn --config $tunnelblick/user.ovpn</code> </pre><br><h4>  Windows </h4><br>  Unter Fenstern scheint alles zu funktionieren.  Der offizielle Client wei√ü nicht, wie er den PIN-Code vom Token eingeben soll, er schafft es, VPN von Hand √ºber die Konsole zu √∂ffnen. <br><br>  Das Wichtigste ist, alles unter dem Administrator zu erledigen.  F√ºhren Sie das Client-Installationsprogramm als Administrator aus.  Starten Sie ein Terminal, in dem openvpn auch mit Administratorrechten gestartet wird, da es sonst die Netzwerkschnittstelle nicht steuern kann. <br><br>  Unter Windows sollte der Pfad zur Bibliothek f√ºr die Arbeit mit Token √ºber doppelte Schr√§gstriche aufgezeichnet werden.  Dies gilt sowohl f√ºr die ovpn-Konfiguration als auch f√ºr die <code>--show-pkcs11-ids</code> in der Befehlszeile. <br><br><pre> <code class="bash hljs">pkcs11-providers <span class="hljs-string"><span class="hljs-string">"c://Windows//System32//rtPKCS11ECP.dll"</span></span> pkcs11-id <span class="hljs-string"><span class="hljs-string">'Aktiv\x20Co\x2E/Rutoken\x20ECP/342b871d/Rutoken/01'</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433250/">https://habr.com/ru/post/de433250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433234/index.html">Ein perfektes Kinderm√§dchen ist erforderlich; Stellen Sie sicher, dass Sie einen KI-Scan durchf√ºhren, um Respekt und gute Manieren zu beurteilen</a></li>
<li><a href="../de433236/index.html">Der Chef von Google glaubt, dass die Angst vor KI "v√∂llig gerechtfertigt" ist.</a></li>
<li><a href="../de433242/index.html">Giftige Maske</a></li>
<li><a href="../de433246/index.html">Framework: Analyse von DLT-Systemen</a></li>
<li><a href="../de433248/index.html">Analysieren der Speicherforensik mit OtterCTF und Einf√ºhrung des Volatility Framework</a></li>
<li><a href="../de433252/index.html">Schaufensterpuppe auf einem turbojetelektrischen Hybrid-Copter</a></li>
<li><a href="../de433254/index.html">Wir k√§mpfen nur gegen den Tod, und Sie? Oder Unternehmen, die fantastische Medizin entwickeln</a></li>
<li><a href="../de433256/index.html">UI-Entwicklung mit Flutter</a></li>
<li><a href="../de433258/index.html">Sie k√∂nnen elektronische Komponenten in Europa auch im Urlaub kaufen. Einkaufserlebnis bei Mouser in Bulgarien</a></li>
<li><a href="../de433260/index.html">Wochenendlesung: Materialien zur Arbeit mit PD, √úberpr√ºfungen von Eisen im Rechenzentrum und der "K√ºche" des IaaS-Anbieters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>