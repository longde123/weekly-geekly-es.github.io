<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏻 📍 🏍️ React钩子简介 👩🏼 💛 🧑🏻‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果您阅读Twitter，您很可能知道Hooks是React的新功能，但是您可能会问， 我们如何在实践中使用它们 ？ 在本文中，我们将向您展示一些使用钩子的示例。 
 要理解的关键思想之一是， 钩子使您无需编写类即可使用状态和其他React功能 。 

 背后的动机 
 尽管面向组件的体系结构允许我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React钩子简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429712/"><img src="https://habrastorage.org/webt/fi/qp/xs/fiqpxsj8dqr3mts4ayrpml4es0u.png"><br><br> 如果您阅读Twitter，您很可能知道Hooks是React的新功能，但是您可能会问， <b>我们如何在实践中使用它们</b> ？ 在本文中，我们将向您展示一些使用钩子的示例。 <br> 要理解的关键思想之一是， <b>钩子使您无需编写类即可使用状态和其他React功能</b> 。 <br><a name="habracut"></a><br><h1> 背后的动机 </h1><br> 尽管面向组件的体系结构允许我们在应用程序中重用视图，但是开发人员面临的最大问题之一是如何<b>在组件之间重用基于状态的逻辑</b> 。 当我们拥有状态逻辑相似的组件时，没有很好的解决方案来重用组件，这有时可能导致构造函数和生命周期方法中的逻辑重复。 <br> 要解决此问题，通常使用： <br><br><ul><li> 高阶组件 </li><li> 渲染道具 </li></ul><br> 但是，这两种模式都有缺点，可能会导致代码库的复杂性。 <br><br>  <b>Hooks旨在解决所有这些问题，使您无需编写类就可以编写可以访问状态，上下文，生命周期方法，ref等的功能组件。</b> <br><br><h1> 钩在阿尔法 </h1><br><blockquote> 在开始潜水之前，重要的是要提到Hooks API的开发尚未完成。 <br><br> 另外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a>非常好，我们建议您也阅读它，因为它广泛描述了引入Hooks的动机。 <br>  <b>UPD</b>最初的文章（您正在阅读的翻译）是在该API进行Alpha测试时编写的，目前React Hooks正式可以使用。 您可以在文章底部或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发行说明中</a>找到对该发行版进行的不可逆更改（与alpha相比）。 <br></blockquote><br><h2> 钩子与类的关系 </h2><br> 如果您熟悉React，了解Hooks的最好方法之一就是了解如何重现我们过去使用Hooks处理类的行为。 <br><br> 回想一下，编写组件类时，我们经常需要： <br><br><ul><li> 管理状态 </li><li> 使用生命周期方法，例如componentDidMount（）和componentDidUpdate（） </li><li> 访问上下文（静态contextType） </li></ul><br><br> 使用React Hooks，我们可以在功能组件中重现类似的行为： <br><br><ul><li> 要使用组件的状态，请使用useState（）钩子 </li><li> 代替使用诸如componentDidMount（）和componentDidUpdate（）之类的生命周期方法，请使用useEffect（）挂钩。 </li><li> 代替使用静态contextType属性，使用useContext（）挂钩。 </li></ul><br><h2> 使用Hooks需要最新版本的React </h2><br> 您可以通过将package.json中的react和react-dom的值更改为“ next”，立即开始使用Hooks。 <br><br><img src="https://habrastorage.org/webt/ys/tx/47/ystx47s3snw_tfev_vqedjlzqfe.png"><br><br><h1>  UseState（）挂钩示例 </h1><br> 状态是React不可或缺的一部分。 它允许我们声明包含数据的变量，这些变量又将在我们的应用程序中使用。 使用类，状态通常定义如下： <br><br><img src="https://habrastorage.org/webt/qs/se/7a/qsse7afsrvty1pgadlncirgnljk.png"><br><br> 在Hooks之前，状态通常仅在组件-类中使用，但是如上所述， <b>Hooks允许我们也将状态添加到功能组件中</b> 。 <br> 让我们看下面的例子。 在这里，我们构建了一个背光开关，该开关根据状态值改变颜色。 为此，我们将使用钩子useState（）。 <br> 这是完整的代码（和一个可执行的示例）-我们将在下面查看发生的情况。 通过单击图像，您可以在CodeSandBox上查看此示例。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ct/-f/xa/ct-fxahjxyoqamk8h-rkguxnfia.png"></a> <br><br><h2> 我们的组件是一个功能 </h2><br> 在上面的代码块中，我们首先从React导入<b>useState</b> 。  UseState是利用this.state可能提供的可能性的一种新方法。 <br> 然后注意，该组件<b>是一个函数，而不是一个class</b> 。 有趣！ <br><br><h2> 读写状态 </h2><br> 在此函数内部，我们调用useState创建状态为变量的变量： <br><br><img src="https://habrastorage.org/webt/mw/3n/ti/mw3ntirdvzk3oxyedpzi00q-vv0.png"><br><br>  <b>useState用于声明状态变量，</b>并可以使用任何类型的值进行初始化（与类中的状态不同，类应该是一个对象）。 <br><br> 如上所示，我们正在对useState的返回值使用解构。 <br><ul><li> 在这种情况下，light的第一个值是当前状态（例如this.state） </li><li> 第二个值是用于更新状态值（第一个值）的函数（如this.setState）。 </li></ul><br> 然后，我们创建两个函数，每个函数将状态设置为0或1的不同值。 <br><br><img src="https://habrastorage.org/webt/ma/sp/lk/masplkqh6lcp33bsywxmhs9zu7g.png"><br><br> 然后，我们将它们作为事件处理程序应用于视图中的按钮： <br><br><img src="https://habrastorage.org/webt/bu/6y/ht/bu6yhtzsnm1tory2ro257etb2yi.png"><br><br><h2> 反应跟踪状态 </h2><br> 当按下“ On”按钮时，将调用setOn函数，该函数将调用setLight（1）。 调用setLight（1） <b>更新下一个渲染的光照值</b> 。 这似乎有些神奇，但是<b>React会跟踪此变量的值，</b>并在重新渲染此组件时传递新值。 <br> 然后，我们使用当前状态（ <b>光</b> ）来确定灯是否应该点亮。 也就是说，我们根据<b>light</b>的值设置SVG的填充颜色。 如果light为0（关闭），则fillColor设置为＃000000（如果为1（on），fillColor设置为＃ffbb73）。 <br><br><h2> 多种状态 </h2><br> 尽管在上面的示例中我们没有这样做，但是您可以通过多次调用useState来创建多个状态。 例如： <br><br><img src="https://habrastorage.org/webt/f6/hc/rt/f6hcrt31natgsnrwwxznmwya2da.png"><br><br><blockquote> 注意 <br> 您应该了解使用挂钩的一些限制。 最重要的是，只应在函数的顶层调用钩子。 有关更多信息，请参见“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">挂钩规则</a> ”。 </blockquote><br><br><h2>  UseEffect（）钩子示例 </h2><br>  <b>UseEffect Hook允许您在功能组件中执行副作用</b> 。 副作用可能包括访问API，更新DOM，订阅事件处理程序-您所需要做的只是使“命令性”动作发生。 <br><br> 使用useEffect（）挂钩，React知道您要在渲染后执行特定操作。 <br><br> 让我们看下面的例子。 我们将使用useEffect（）调用API并获得响应。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/d3/s9/wm/d3s9wmjvrllc8z6xfwol0hocesg.png"></a> <br><br> 此代码示例同时使用<b>useState</b>和<b>useEffect</b> ，这是因为我们想将API调用的结果写入state。 <br><br><img src="https://habrastorage.org/webt/l_/ro/uh/l_rouhqptfnk3xxxpevplnsg8qm.png"><br><br><h2> 接收数据并更新状态 </h2><br> 要“使用效果”，我们需要将操作放入<b>useEffect</b>函数中，即，将“ action”效果作为匿名函数传递，作为<b>useEffect</b>的第一个参数。 <br> 在上面的示例中，我们指的是返回名称列表的API。 当<b>响应</b>返回时，我们将其转换为JSON，然后使用<b>setNames（数据）</b>设置状态。 <br><br><img src="https://habrastorage.org/webt/jn/2m/a6/jn2ma6v7m2cdiiy6pwxoscgdtsq.png"><br><br><h2> 使用效果时的性能问题 </h2><br><br> 但是，关于使用<b>useEffect</b>还有其他<b>要说的话</b> 。 <br><br> 首先要考虑的是，默认情况下，我们的<b>useEffect</b>将在每个渲染器上调用！ 好消息是我们不必担心过时的数据，但坏消息是我们可能不想为每个呈现都发出HTTP请求（在这种情况下）。 <br><br> 在这种情况下，您可以<b>使用第二个useEffect参数</b>跳过效果。  useEffect的第二个参数是我们要“观察”的变量列表，然后仅当这些值之一发生更改时，我们才会重新运行效果。 <br><br> 在上面的代码示例中，请注意，我们将传递<b>一个空数组</b>作为第二个参数。 告诉React的是，我们只想在安装组件时命名此效果。 <br><br><blockquote> 要了解有关效果表现的更多信息， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请查阅白皮书中的本节。</a> </blockquote><br> 此外，与useState函数一样，useEffect允许您使用多个实例，这意味着您可以具有多个useEffect函数。 <br><br><h2>  UseContext（）钩子示例 </h2><br>  <b>上下文点</b> <br><br>  React中的上下文是子组件访问父组件中的值的一种方式。 <br><br> 要了解上下文的需求：创建React应用程序时，您通常需要从React树的顶部向下传递值。 通过不使用上下文，您可以使道具通过不需要了解道具的组件。 <br><br> 将道具传递到“无关”组件的树上被亲切地称为“道具钻探”。 <br>  React Context通过允许您通过组件树与请求这些值的任何组件共享值来解决道具钻探问题。 <br><br>  <b>useContext（）简化了上下文的使用</b> <br><br> 使用useContext Hook，使用上下文比以往任何时候都容易。 <br><br>  <b>useContext（）</b>函数采用一个上下文对象，该对象最初是从<b>React.createContext（）</b>返回的，然后返回当前上下文的值。 让我们看下面的例子。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/aa/uh/w6/aauhw6dryv5g7ltu15gake6yu_a.png"></a> <br><br> 在上面的代码中，JediContext的上下文是使用React.createContext（）创建的。 <br><br> 我们在我们的App组件中使用JediContext.Provider，并将该值设置为“ Luke”。 这意味着任何需要访问上下文的组件现在都可以读取该值。 <br><br> 要在Display（）函数中读取此值，我们调用useContext并传递JediContext参数。 <br><br> 然后，我们传递从React.createContext获得的上下文对象，它会自动显示该值。 提供者值更新时，此挂钩将自动使用最后一个上下文值。 <br><br><h4> 在大型应用程序中获取指向上下文的链接 </h4><br> 上面，我们在两个组件中都创建了JediContext，但是在更大的应用程序中，Display和App将位于不同的文件中。 因此，如果您遇到类似的情况，您可能想知道：“我们如何获得文件之间的JediContext链接？” <br><br> 答案是，您需要<b>创建一个导出JediContext的新文件</b> 。 <br> 例如，您可能有一个context.js文件，其中包含以下内容： <br><br><img src="https://habrastorage.org/webt/7p/aj/8g/7paj8gv_3osxvml7qa8figr6jnk.png"><br><br> 然后在App.js（和Display.js）中，您应该编写： <br><br><img src="https://habrastorage.org/webt/3p/sp/f1/3pspf1ab9sgflp2xvfhqn_edcig.png"><br><br> 谢谢， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">戴夫</a> ） <br><br><h3>  UseRef（）挂钩示例 </h3><br>  Refs提供了一种访问在render（）方法中创建的React元素的方法。 <br> 如果您是React ref的新手，可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React ref的简介</a> 。 <br>  <b>useRef（）</b>函数返回一个ref对象。 <br><br><img src="https://habrastorage.org/webt/lx/ti/yw/lxtiywoqga-4a5mynvgtmhc9nhq.png"><br><br><h3>  useRef（）和带有输入的表格 </h3><br> 让我们来看一个使用useRef（）挂钩的示例。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/kj/5j/kv/kj5jkvt8rawy6g9relz8icq7rks.png"></a> <br><br> 在上面的示例中，我们结合使用useRef（）和useState（）将输入值呈现给p标签。 <br><br> 在nameRef变量中创建Ref。 然后，变量nameRef可以在输入中使用，以ref形式给出。 本质上，这意味着现在可以通过ref访问输入字段的内容。 <br><br> 代码中的Submit按钮具有一个名为SubmitButton的onClick事件处理程序。  SubmitButton函数调用setName（通过useState创建）。 <br><br> 正如我们已经使用hookState所做的那样，setName将用于设置状态名称。 为了从输入标签中提取名称，我们读取了nameRef.current.value的值。 <br><br> 关于useRef的另一个注意事项是，它可以比ref属性更多地使用。 <br><br><h3> 使用自定义挂钩 </h3><br>  Hook的最酷的功能之一是，您可以<b>通过创建自己的Hook</b>轻松地<b>在多个组件之间共享逻辑。</b> <br><br> 在下面的示例中，我们将创建一个自定义<b>setCounter（）</b>挂钩，该挂钩可让我们跟踪状态并提供自定义状态更新功能！ <br><br><blockquote> 另请参见，来自<a href="">use-use的</a> <b>useCounter</b> Hook和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来自Kent的useCounter</a> </blockquote><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/5j/1t/po/5j1tpoviea-npppg002j2vbyydw.png"></a> <br><br> 在上面的代码块中，我们创建了一个useCounter函数，用于存储钩子的逻辑。 <br><br> 请注意，useCounter可能会使用其他挂钩！ 让我们首先通过useState创建一个新的Hook状态。 <br><br> 然后，我们定义两个辅助函数： <b>increas</b>和<b>decrement</b> ，它们调用<b>setCount</b>并相应地调整当前<b>计数</b> 。 <br><br> 最后，我们返回与钩子交互所需的链接。 <br><br> 问：会发生什么，返回带有对象的数组？ <br> 答：嗯，就像Hooks中的大多数事情一样，API约定尚未完成。 但是我们在这里返回的是一个数组，其中： <br><br><ul><li> 第一项是挂钩的当前值。 </li><li> 第二个元素是一个对象，其中包含用于与钩子交互的功能。 </li></ul><br> 这个约定使您可以轻松地“重命名” Hook的当前值，就像我们上面对<b>myCount所做的那样</b> 。 <br><br> 但是，您可以从自定义挂钩中返回任何内容。 <br><br> 在上面的示例中，我们在视图中使用了<b>增量</b>和<b>减量</b>作为<b>onClick</b>处理程序。 当用户按下按钮时，计数器将更新并在视图中重新显示（如<b>myCount</b> ）。 <br><br><h2> 为React Hook编写测试 </h2><br> 为了编写钩子测试，我们将使用<b>react-testing-library</b>进行测试。 <br><br>  <b>react-testing-library</b>是用于测试React组件的非常轻量级的解决方案。 它是<b>react-dom</b>和<b>react-dom / test-utils</b>的扩展。 使用<b>react-testing-library</b>可确保您的测试直接与DOM节点一起使用。 <br><br> 使用测试钩子，还不是很清楚。 当前，您不能单独测试挂钩。 相反，您需要将挂钩连接到组件并测试该组件。 <br><br> 因此，下面我们将为钩子编写测试，并与我们的组件交互，而不是直接与钩子交互。 好消息是我们的测试将看起来像常规的React测试。 <br><br><h3> 测试useState（）钩子 </h3><br> 让我们看一个为<b>useState</b> Hook编写测试的<b>示例</b> 。 在上面的教程中，我们测试了上面使用的useState示例的更多变体。 我们将编写测试以确保按下“ Off”按钮将状态设置为0，并按下“ On”按钮将状态设置为1。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/y4/tc/i7/y4tci7evnak6quqqgjfp1ngdg9m.png"></a> <br><br> 在上面的代码块中，我们首先从<b>react-testing-library</b>和被测组件中导入一些帮助器。 <br><br><ul><li>  <b>render</b> ，这将有助于显示我们的组件。 将其渲染到添加到<b>document.body</b>的容器中 </li><li>  <b>getByTestId</b> <b>通过data-testid</b>获取DOM元素 </li><li>  <b>fireEvent</b> ，用于“触发” DOM事件。 例如，它通过事件委托将事件处理程序附加到<b>文档中</b>并处理一些DOM事件。 通过单击一个按钮。 </li></ul><br> 此外，在测试批准功能中，我们设置了具有<b>data-testid的</b>元素的变量值以及我们要在测试中使用的变量值。 通过链接到DOM上的元素，我们可以使用<b>fireEvent</b>方法模拟对按钮的单击。 <br><br> 该测试验证是否<b>单击</b>了<b>onButton</b> ，状态值设置为1，并且当您单击<b>offButton时</b>状态为1。 <br><br><h3> 测试useEffect（）的钩子 </h3><br> 在此示例中，我们将编写测试以使用<b>useEffect</b> Hook将产品添加到购物车。 项目数也存储在localStorage中。 下面的CodeSandbox中的index.js文件包含用于向购物车添加商品的实际逻辑。 <br><br> 我们将编写测试以确保购物车项目数的更新也反映在localStorage中，即使重新加载页面，购物车项目数也保持不变。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/74/w8/vj/74w8vjaiwkk_okdrqgrgg4s90bc.png"></a> <br><br> 在确认测试的功能中，我们首先将<b>localStorage中的</b> <b>cartItem</b>设置为0，这意味着购物车项目数为0。然后我们通过<b>构造</b>将<b>容器</b>和<b>App</b>组件重新<b>渲染</b> 。  <b>Rerender</b>允许我们模拟页面重新加载。 <br><br> 然后，我们获得了指向按钮和p标记的链接，这些标记显示了当前购物篮值并将其设置为变量。 <br><br> 完成此操作后，测试将模拟对<b>addButton</b>的单击并检查当前购物篮计数器是否为1并重新加载页面，然后检查是否将<b>localStorage</b> ， <b>cartItem</b>设置为1。然后模拟对<b>resetButton</b>和检查当前购物车项目数是否设置为0。 <br><br><h3> 测试useRef（）的钩子 </h3><br> 在此示例中，我们将测试<b>useRef</b> Hook，并将上面的原始<b>useRef</b>示例用作测试的基础。  <b>UseRef</b>用于从输入字段获取值，然后将值设置为state。 下面的<b>CodeSandbox</b>中的<b>index.js</b>文件包含用于输入值并将其发送的逻辑。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/zu/m4/yu/zum4yuqeeszwservqx8mzj8ypoy.png"></a> <br><br> 在批准测试的功能中，我们在输入字段中设置变量，显示ref的当前值的p标签和一个提交按钮。 我们还设置了要在newName变量的输入字段中输入的值。 这将用于测试中的验证。 <br><br><img src="https://habrastorage.org/webt/pj/gz/jz/pjgzjzqildkkv6tkasce6xy389c.png"><br><br>  fireEvent.change方法用于在输入字段中输入值，在这种情况下，将使用存储在常量newName中的名称，然后按下提交按钮。 <br><br> 然后，测试将检查按下按钮后的ref值是否<b>与newName的</b>值<b>匹配</b> 。 <br><br> 最后，您应该看到“没有测试崩溃，祝贺您！” 控制台中的消息。 <br><br><h3> 社区对钩的回应 </h3><br> 自从引入React Hooks以来，社区对此功能感到非常满意，并且我们已经看到了<b>许多</b>使用React Hooks的示例。 这里是一些主要的： <br><br><ul><li> 该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">站点</a>包含React Hooks的集合。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-use</a> ，一堆React Hooks附带的库。 </li><li> 此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox</a>示例演示如何使用useEffect Hook通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-spring</a>创建动画 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a> useMutableReducer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ，它允许您简单地更改状态以在化简器中对其进行更新。 </li><li> 此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a>在CodeSandbox上，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a>显示了父子通信的复杂集成用法和重发器的用法。 </li><li>  React Hooks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开关组件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React Hooks的</a>另一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集合</a> ，具有用于输入值，设备方向和文档可见性的钩子。 </li></ul><br><br><h3> 不同类型的钩子 </h3><br> 您可以在React应用程序中开始使用各种钩子。 它们在下面列出： <br><br><ul><li>  <b>useState-</b>允许我们编写具有访问状态的纯函数。 </li><li>  <b>useEffect-</b>允许我们执行副作用。 副作用可能是API调用，更新DOM，订阅事件处理程序。 </li><li>  <b>useContext-</b>允许您编写包含上下文的纯函数。 </li><li>  <b>useReducer-</b>为我们提供了一个类似于Redux的reducer的链接 </li><li>  <b>useRef-</b>允许您编写返回可变引用对象的纯函数。 </li><li> <b>useMemo</b> -      . </li><li> <b>useCallback</b> —  Hook     . </li><li> <b>useImperativeMethods</b> -   ,       ref. </li><li> <b>useMutationEffects</b> —   useEffect Hook   ,     DOM-. </li><li> <b>useLayoutEffect</b> -       DOM   -. </li><li> <b> hooks</b> -        . </li></ul><br><br><h3>  hooks </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hooks的伟大之处在于它们与现有代码并存，因此您可以缓慢地进行更改以实现Hooks。您所要做的就是将React升级到支持钩子的版本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，Hooks仍是一个实验性功能，React团队反复警告该API可能会发生变化。考虑到您被警告了。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">钩子的出现对班级意味着什么？正如React团队所报告的那样，这些类仍然存在，它们是React代码库的重要组成部分，并且很可能会持续一段时间。</font></font><br><br><blockquote>      .  Facebook      ,  , ,    ,     .    React  Hooks,          — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> </blockquote><br> <b>  API- Hooks   ,    Hooks,   ,      .</b> <br><br><h3> 其他资源 </h3><br><ul><li>  React      React Hooks,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> </li><li> API    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </li><li>    RFC,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,       </li></ul><br><br><blockquote> <b>UPD</b> <br>  : <br>      React 16.8   Hooks API.        -: <br> —  useMutationEffect. <br> —  useImperativeMethods  useImperativeHandle. <br> —         useState  useReducer Hooks. <br> —      ,   useEffect/useMemo/useCallback Hooks. <br> —  Object.is     useState  useReducer. <br> —     Strict Mode (DEV-only). <br> —  lazy initialization API  useReducer Hook. <br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429712/">https://habr.com/ru/post/zh-CN429712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429702/index.html">谷歌分析 Pixel Sync Facebook，VK，Yandex，MyTarget</a></li>
<li><a href="../zh-CN429704/index.html">将多路径LUN存储连接到Windows Server 2008和Windows Server 2012</a></li>
<li><a href="../zh-CN429706/index.html">A1：2017年-注射剂（第3部分和最后部分）</a></li>
<li><a href="../zh-CN429708/index.html">莫斯科HolyJS 2018计划的一部分</a></li>
<li><a href="../zh-CN429710/index.html">国际空间站上的二氧化碳</a></li>
<li><a href="../zh-CN429714/index.html">比MQTT容易吗？ MQTT / UDP</a></li>
<li><a href="../zh-CN429716/index.html">5个学习英语的最佳PC游戏</a></li>
<li><a href="../zh-CN429718/index.html">我想要一切！ 我们研究了频率为4000 MHz的RAM HyperX Predator DDR4 RGB</a></li>
<li><a href="../zh-CN429720/index.html">如何使新手开发人员能够在面试中生存而又不会在工作中发疯</a></li>
<li><a href="../zh-CN429722/index.html">我们如何在Yandex.Cash中通过Google Pay付款的方式[更新]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>