<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏬 🙌🏾 🙆🏾 Predicciones de matemáticos. Analizamos los principales métodos para detectar anomalías. 👩‍🏭 👨🏾‍🎓 🛀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el extranjero, el uso de inteligencia artificial en la industria para el mantenimiento predictivo de varios sistemas está ganando popularidad. El p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Predicciones de matemáticos. Analizamos los principales métodos para detectar anomalías.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/447190/">  En el extranjero, el uso de inteligencia artificial en la industria para el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mantenimiento predictivo de</a> varios sistemas está ganando popularidad.  El propósito de esta técnica es identificar el mal funcionamiento de la operación del sistema durante la fase de operación antes de que se descomponga para una respuesta oportuna. <br><br>  ¿Cuán relevante es este enfoque en nuestro país y en Occidente?  La conclusión puede hacerse, por ejemplo, en artículos sobre Habré y en Medium.  Casi no hay artículos sobre Habré sobre la resolución de problemas de mantenimiento predictivo.  En Medium hay un conjunto completo.  Aquí, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> se describe bien cuáles son los objetivos y las ventajas de este enfoque. <br><br>  De este artículo aprenderás: <br><br><ul><li>  ¿Por qué se necesita esta técnica? </li><li>  qué enfoques de aprendizaje automático se usan más comúnmente para el mantenimiento predictivo, </li><li>  cómo probé uno de los trucos con un simple ejemplo. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/2a4/888/8452a4888db8d633dd14d426f6b80cbe.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>Fuente</i></a> <br><a name="habracut"></a><br>  ¿Qué características ofrece el servicio predictivo? <br><br><ul><li>  un proceso controlado de trabajos de reparación, que se lleva a cabo según sea necesario, ahorrando dinero y sin prisas, lo que mejora la calidad de estos trabajos; </li><li>  identificación de un mal funcionamiento específico en la operación del equipo (la capacidad de comprar una pieza específica para reemplazarla cuando el equipo está en funcionamiento brinda enormes ventajas); </li><li>  optimización del funcionamiento del equipo, cargas, etc. </li><li>  reducción de costos por apagado regular de equipos. </li></ul><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siguiente artículo sobre Medium</a> describe bien las preguntas que deben responderse para comprender cómo abordar este problema en un caso particular. <br><br>  Al recopilar datos o al elegir datos para construir un modelo, es importante responder tres grupos de preguntas: <br><br><ol><li>  ¿Se pueden predecir todos los problemas del sistema?  ¿Qué predicción es especialmente importante? </li><li>  ¿Qué es un proceso de falla?  ¿Todo el sistema deja de funcionar o solo está cambiando el modo operativo?  ¿Es un proceso rápido, degradación instantánea o gradual? </li><li>  ¿El rendimiento del sistema refleja adecuadamente su rendimiento?  ¿Se relacionan con partes individuales del sistema o con el sistema en su conjunto? </li></ol><br>  También es importante comprender de antemano lo que desea predecir, lo que es posible predecir y lo que no. <br><br>  El artículo en Medium también enumera preguntas que ayudarán a determinar su objetivo específico: <br><br><ul><li>  ¿Qué se debe predecir?  El tiempo de vida restante, comportamiento anormal o no, la probabilidad de falla en las próximas N horas / días / semanas? </li><li>  ¿Hay suficientes datos históricos? </li><li>  ¿Se sabe cuándo el sistema dio lecturas anómalas y cuándo no?  ¿Es posible marcar tales indicaciones? </li><li>  ¿Qué tan lejos debe ver el modelo?  ¿Qué tan independientes son las lecturas que reflejan el funcionamiento del sistema en el intervalo de una hora / día / semana? </li><li>  ¿Qué necesitas para optimizar?  Si el modelo detecta tantas violaciones como sea posible, mientras da una falsa alarma, o es suficiente para detectar varios eventos sin falsos positivos. </li></ul><br>  Se espera que la situación mejore en el futuro.  Hasta ahora, existen dificultades en el campo del mantenimiento predictivo: hay pocos ejemplos de mal funcionamiento del sistema, o son suficientes momentos de mal funcionamiento del sistema, pero no están marcados;  El proceso de falla es desconocido. <br><br>  La forma principal de superar las dificultades en el mantenimiento predictivo es utilizar <b>métodos de búsqueda de anomalías</b> .  Dichos algoritmos no requieren marcado para el entrenamiento.  Para probar y depurar algoritmos, es necesario el marcado de una forma u otra.  Dichos métodos son limitados en el sentido de que no predecirán una falla específica, sino que solo señalarán anormalidades de los indicadores. <br><br>  Pero esto ya no está mal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/46c/6d7/84746c6d7414722b0a1b7b322000f201.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>Fuente</i></a> <br><br><h2>  Métodos </h2><br>  Ahora quiero hablar sobre algunas características de los enfoques de detección de anomalías, y luego juntos probaremos las capacidades de algunos algoritmos simples en la práctica. <br><br>  Aunque una situación particular requerirá probar varios algoritmos para buscar anomalías y elegir la mejor, es posible determinar algunas ventajas y desventajas de las principales técnicas utilizadas en esta área. <br><br>  En primer lugar, es importante comprender de antemano cuál es el porcentaje de anomalías en los datos. <br><br>  Si estamos hablando de una variación del enfoque semi-supervisado (estudiamos solo con datos "normales" y trabajamos (probamos) y luego con datos con anomalías), entonces la opción más óptima es <b>el método de vector de soporte con una clase ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SVM de una clase</a> )</b> .  Cuando se utilizan funciones de base radial como núcleo, este algoritmo construye una superficie no lineal alrededor del origen.  Cuanto más limpios sean los datos de entrenamiento, mejor funcionará. <br><br>  En otros casos, la necesidad de conocer la proporción de puntos anormales y "normales" también permanece, para determinar el umbral de corte. <br><br>  Si el número de anomalías en los datos es superior al 5% y son bastante separables de la muestra principal, se pueden utilizar métodos de búsqueda de anomalías estándar. <br><br>  En este caso, el <b>método del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bosque de aislamiento</a></b> es el más estable en términos de calidad: el <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bosque de aislamiento son</a></b> datos aleatorios.  Es más probable que una indicación más característica sea más profunda, mientras que los indicadores inusuales se separarán del resto de la muestra en las primeras iteraciones. <br><br>  Otros algoritmos funcionan mejor si se "ajustan" a los detalles de los datos. <br><br>  Cuando los datos tienen una distribución normal, el <b>método de envoltura elíptica</b> es adecuado, aproximando los datos con una distribución normal multidimensional.  Cuanto menos probable sea que el punto pertenezca a la distribución, mayor será la probabilidad de que sea anómalo. <br><br>  Si los datos se presentan de tal manera que la posición relativa de diferentes puntos refleja bien sus diferencias, entonces los métodos métricos parecen ser una buena opción: por ejemplo, <b>k vecinos más cercanos, k-ésimo vecino más cercano, ABOD (detección de valores atípicos basados ​​en ángulos) o LOF (factor de valores atípicos locales) )</b> <br><br>  Todos estos métodos sugieren que los indicadores "correctos" se concentran en un área del espacio multidimensional.  Si entre los vecinos más cercanos k (o k-ésimo) todo está lejos del objetivo, entonces el punto es una anomalía.  Para ABOD, el razonamiento es similar: si todos los k puntos más cercanos están en el mismo sector de espacio en relación con el considerado, entonces el punto es una anomalía.  Para LOF: si la densidad local (predeterminada para cada punto por k vecinos más cercanos) es menor que la de k vecinos más cercanos, entonces el punto es una anomalía. <br><br>  Si los datos están bien agrupados, los <b>métodos basados ​​en el análisis de grupos</b> son una buena opción.  Si el punto es equidistante de los centros de varios grupos, entonces es anómalo. <br><br>  Si las direcciones de la mayor variación en la varianza se distinguen bien en los datos, entonces parece ser una buena opción <b>buscar anomalías basadas en el método del componente principal</b> .  En este caso, las desviaciones del valor promedio para n1 (la mayoría de los componentes "principales") y n2 (la menor "principal") se consideran una medida de anomalía. <br><br>  Por ejemplo, se sugiere mirar el conjunto de datos de <b>The Prognostics and Health Management Society (PHM Society)</b> .  Esta organización sin fines de lucro organiza la competencia todos los años.  En 2018, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se requería predecir errores en la operación y el tiempo antes de la falla de la planta de grabado de haz de iones</a> .  Tomaremos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de datos para 2015</a> .  Contiene las lecturas de varios sensores para 30 instalaciones (muestra de entrenamiento), y se requiere para predecir cuándo y qué error ocurrirá. <br><br>  No encontré las respuestas para la muestra de prueba en la red, por lo que solo jugaremos con la capacitación. <br><br>  En general, todos los ajustes son similares, pero difieren, por ejemplo, en el número de componentes, en el número de anomalías, etc.  Por lo tanto, aprender en los primeros 20 y probar en otros no tiene mucho sentido. <br><br>  Por lo tanto, elegiremos una de las instalaciones, la cargaremos y echaremos un vistazo a estos datos.  El artículo no se referirá a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ingeniería de características</a> , por lo que no analizaremos mucho. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.covariance <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> EllipticEnvelope <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.neighbors <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LocalOutlierFactor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.ensemble <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> IsolationForest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.svm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OneClassSVM dfa=pd.read_csv(<span class="hljs-string"><span class="hljs-string">'plant_12a.csv'</span></span>,names=[<span class="hljs-string"><span class="hljs-string">'Component number'</span></span>,<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'S1'</span></span>,<span class="hljs-string"><span class="hljs-string">'S2'</span></span>,<span class="hljs-string"><span class="hljs-string">'S3'</span></span>,<span class="hljs-string"><span class="hljs-string">'S4'</span></span>,<span class="hljs-string"><span class="hljs-string">'S1ref'</span></span>,<span class="hljs-string"><span class="hljs-string">'S2ref'</span></span>,<span class="hljs-string"><span class="hljs-string">'S3ref'</span></span>,<span class="hljs-string"><span class="hljs-string">'S4ref'</span></span>]) dfa.head(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/301/77e/2bb/30177e2bb970e82495b18008b44d7ea4.jpg"></div><br>  Como puede ver, hay siete componentes para cada uno de los cuales hay lecturas de cuatro sensores que se toman cada 15 minutos.  S1ref-S4ref en la descripción de la competencia se enumeran como valores de referencia, pero los valores son muy diferentes de las lecturas de los sensores.  Para no perder el tiempo pensando en lo que significan, los eliminamos.  Si observa la distribución de valores para cada característica (S1-S4), resulta que las distribuciones son continuas para S1, S2 y S4, y discretas para S3.  Además, si observa la distribución conjunta de S2 y S4, resulta que son inversamente proporcionales. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/82b/cde/69b82bcdecdfca69128d88673b0518b4.jpg"></div><br>  Aunque una desviación de una dependencia directa puede indicar un error, no lo comprobaremos, sino que simplemente eliminaremos S4. <br><br>  Una vez más, procesamos el conjunto de datos.  Deje S1, S2 y S3.  Escale S1 y S2 con StandardScaler (restamos el promedio y dividimos por la desviación estándar), traduzca S3 en OHE (One Hot Encoding).  Cosemos lecturas de todos los componentes de instalación en una línea.  Total de 89 características.  2 * 7 = 14 - lecturas S1 y S2 para 7 componentes y 75 valores únicos de R3.  Solo 56 mil de esas líneas. <br><br>  Sube el archivo con errores. <br><br><pre> <code class="python hljs">dfc=pd.read_csv(<span class="hljs-string"><span class="hljs-string">'plant_12c.csv'</span></span>,names=[<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>, <span class="hljs-string"><span class="hljs-string">'End Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'Type'</span></span>]) dfc.head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/419/e50/3ad419e50ac870a71c153b523a22bfed.jpg"></div><br>  Antes de probar estos algoritmos en nuestro conjunto de datos, me permitiré otra pequeña digresión.  Necesitas ser probado.  Para esto, se propone tomar la hora de inicio del error y la hora de finalización.  Y todas las indicaciones dentro de este intervalo se consideran anormales y fuera de lo normal.  Este enfoque tiene muchas desventajas.  Pero especialmente uno: el comportamiento anormal probablemente ocurre antes de que se solucione el error.  Por fidelidad, cambiemos la ventana de anomalías hace media hora a tiempo.  Evaluaremos la medida F1, la precisión y el recuerdo. <br><br>  El código para distinguir características y determinar la calidad del modelo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_and_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plant_num)</span></span></span><span class="hljs-function">:</span></span>   <span class="hljs-comment"><span class="hljs-comment">#      ,       dfa=pd.read_csv('plant_{}a.csv'.format(plant_num),names=['Component number','Time','S1','S2','S3','S4','S1ref','S2ref','S3ref','S4ref'])   dfc=pd.read_csv('plant_{}c.csv'.format(plant_num),names=['Start Time','End Time','Type']).drop(0,axis=0)   N_comp=len(dfa['Component number'].unique())   #  15    dfa['Time']=pd.to_datetime(dfa['Time']).dt.round('15min')   #  6    (  ,    )   dfc=dfc[dfc['Type']!=6]   dfc['Start Time']=pd.to_datetime(dfc['Start Time'])   dfc['End Time']=pd.to_datetime(dfc['End Time'])   #      ,       OHE  3-    dfa=pd.concat([dfa.groupby('Time').nth(i)[['S1','S2','S3']].rename(columns={"S1":"S1_{}".format(i),"S2":"S2_{}".format(i),"S3":"S3_{}".format(i)}) for i in range(N_comp)],axis=1).dropna().reset_index()   for k in range(N_comp):       dfa=pd.concat([dfa.drop('S3_'+str(k),axis=1),pd.get_dummies(dfa['S3_'+str(k)],prefix='S3_'+str(k))],axis=1).reset_index(drop=True)   #          df_train,df_test=train_test_split(dfa,test_size=0.25,shuffle=False)   cols_to_scale=df_train.filter(regex='S[1,2]').columns   scaler=preprocessing.StandardScaler().fit(df_train[cols_to_scale])   df_train[cols_to_scale]=scaler.transform(df_train[cols_to_scale])   df_test[cols_to_scale]=scaler.transform(df_test[cols_to_scale])   return df_train,df_test,dfc #       def get_true_labels(measure_times,dfc,shift_delta):   idxSet=set()   dfc['Start Time']-=pd.Timedelta(minutes=shift_delta)   dfc['End Time']-=pd.Timedelta(minutes=shift_delta)   for idx,mes_time in tqdm_notebook(enumerate(measure_times),total=measure_times.shape[0]):       intersect=np.array(dfc['Start Time']&lt;mes_time).astype(int)*np.array(dfc['End Time']&gt;mes_time).astype(int)       idxs=np.where(intersect)[0]       if idxs.shape[0]:           idxSet.add(idx)   dfc['Start Time']+=pd.Timedelta(minutes=shift_delta)   dfc['End Time']+=pd.Timedelta(minutes=shift_delta)   true_labels=pd.Series(index=measure_times.index)   true_labels.iloc[list(idxSet)]=1   true_labels.fillna(0,inplace=True)   return true_labels #          def check_model(model,df_train,df_test,filt='S[123]'):   model.fit(df_train.drop('Time',axis=1).filter(regex=(filt)))   y_preds = pd.Series(model.predict(df_test.drop(['Time','Label'],axis=1).filter(regex=(filt)))).map({-1:1,1:0})   print('F1 score: {:.3f}'.format(f1_score(df_test['Label'],y_preds)))   print('Precision score: {:.3f}'.format(precision_score(df_test['Label'],y_preds)))   print('Recall score: {:.3f}'.format(recall_score(df_test['Label'],y_preds)))   score = model.decision_function(df_test.drop(['Time','Label'],axis=1).filter(regex=(filt)))   sns.distplot(score[df_test['Label']==0])   sns.distplot(score[df_test['Label']==1]) df_train,df_test,anomaly_times=load_and_preprocess(12) df_test['Label']=get_true_labels(df_test['Time'],dfc,30)</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50b/6f2/be9/50b6f2be9c3220853e92461805030e0b.jpg"></div>  <i>Resultados de la prueba para algoritmos de búsqueda de anomalías simples en el conjunto de datos PHM 2015 Data Challenge</i> <br><br>  De vuelta a los algoritmos.  Probemos One Class SVM (OCSVM), IsolationForest (IF), EllipticEnvelope (EE) y LocalOutlierFactor (LOF) en nuestros datos.  Para empezar, no estableceremos ningún parámetro.  Observo que LOF puede funcionar en dos modos.  Si novedad = Falso puede buscar anomalías solo en el conjunto de entrenamiento (solo hay fit_predict), si es Verdadero, está dirigido a buscar anomalías fuera del conjunto de entrenamiento (puede ajustarse y predecir por separado).  IF tiene un modo de comportamiento antiguo y nuevo.  Usamos nuevo.  Él da mejores resultados. <br><br>  OCSVM detecta bien las anomalías, pero hay demasiados falsos positivos.  Para otros métodos, el resultado es aún peor. <br><br>  Pero supongamos que conocemos el porcentaje de anomalías en los datos.  En nuestro caso, 27%.  OCSVM tiene nu: la estimación superior para el porcentaje de errores y la inferior para el porcentaje de vectores de soporte.  Otros métodos de contaminación tienen un porcentaje de errores de datos.  En los métodos IF y LOF, se determina automáticamente, mientras que para OCSVM y EE se establece en 0.1 de forma predeterminada.  Intentemos establecer la contaminación (nu) en 0.27.  Ahora el mejor resultado para EE. <br><br>  Código para verificar modelos: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model,df_train,df_test,filt=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'S[123]'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span>   model_type,model = model   model.fit(df_train.drop(<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,axis=<span class="hljs-number"><span class="hljs-number">1</span></span>).filter(regex=(filt)))   y_preds = pd.Series(model.predict(df_test.drop([<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],axis=<span class="hljs-number"><span class="hljs-number">1</span></span>).filter(regex=(filt)))).map({<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>})   print(<span class="hljs-string"><span class="hljs-string">'F1 score for {}: {:.3f}'</span></span>.format(model_type,f1_score(df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],y_preds)))   print(<span class="hljs-string"><span class="hljs-string">'Precision score for {}: {:.3f}'</span></span>.format(model_type,precision_score(df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],y_preds)))   print(<span class="hljs-string"><span class="hljs-string">'Recall score for {}: {:.3f}'</span></span>.format(model_type,recall_score(df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],y_preds)))   score = model.decision_function(df_test.drop([<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],axis=<span class="hljs-number"><span class="hljs-number">1</span></span>).filter(regex=(filt)))   sns.distplot(score[df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>]==<span class="hljs-number"><span class="hljs-number">0</span></span>])   sns.distplot(score[df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>])   plt.title(<span class="hljs-string"><span class="hljs-string">'Decision score distribution for {}'</span></span>.format(model_type))   plt.show()</code> </pre> <br>  Es interesante observar la distribución de los indicadores de anomalías para diferentes métodos.  Se puede ver que LOF no funciona bien para estos datos.  EE tiene puntos que el algoritmo considera extremadamente anormales.  Sin embargo, los puntos normales caen allí.  IsoFor y OCSVM muestran que la elección del umbral de corte (contaminación / nu) es importante, lo que cambiará la compensación entre precisión e integridad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/0c8/80f/a9d0c880f36fe37f1de6c9290b8cccc7.png"></div><br>  Es lógico que las lecturas de los sensores tengan una distribución cercana a la normal, cerca de valores estacionarios.  Si realmente tenemos una muestra de prueba etiquetada, y preferiblemente también una de validación, entonces el valor de contaminación puede teñirse.  La siguiente pregunta es, ¿qué errores están más orientados: falso positivo o falso negativo? <br><br>  El resultado LOF es muy bajo.  No muy impresionante  Pero recuerde que las variables OHE van a la entrada junto con las variables transformadas por StandardScaler.  Y las distancias predeterminadas son euclidianas.  Pero si solo cuenta las variables de acuerdo con S1 y S2, la situación se corrige y el resultado es comparable con otros métodos.  Sin embargo, es importante comprender que uno de los parámetros clave de los clasificadores métricos enumerados es el número de vecinos.  Afecta significativamente la calidad y debe ajustarse.  La métrica de distancia en sí también sería agradable de recoger. <br><br>  Ahora intenta combinar los dos modelos.  Al comienzo de uno, eliminamos las anomalías del conjunto de entrenamiento.  Y luego entrenaremos a OCSVM en un conjunto de entrenamiento "más limpio".  Según los resultados anteriores, observamos la mayor integridad en EE.  Borramos la muestra de entrenamiento a través de EE, entrenamos OCSVM en ella y obtenemos F1 = 0.50, Precisión = 0.34, integridad = 0.95.  No es impresionante  Pero acabamos de preguntar nu = 0.27.  Y los datos que tenemos son más o menos "limpios".  Si suponemos que la plenitud de la EE en la muestra de entrenamiento es la misma, entonces permanecerá el 5% de los errores.  Nos establecemos como nu y obtenemos F1 = 0.69, Precisión = 0.59, integridad = 0.82.  Genial  Es importante tener en cuenta que en otros métodos dicha combinación no funcionará, ya que implican que el número de anomalías en el conjunto de entrenamiento y el número de prueba es el mismo.  Al entrenar estos métodos en un conjunto de datos de entrenamiento puro, deberá especificar menos contaminación que en los datos reales y no cerca de cero, pero es mejor seleccionarlo para la validación cruzada. <br><br>  Es interesante observar el resultado de la búsqueda en la secuencia de indicaciones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/0c5/26d/2a20c526d944b55116f3fcd6af064eab.png"></div><br>  La figura muestra un segmento de las lecturas del primer y segundo sensor para 7 componentes.  En la leyenda, el color de los errores correspondientes (el principio y el final se muestran mediante líneas verticales del mismo color).  Los puntos indican las predicciones: verde - predicciones verdaderas, rojo - falso positivo, púrpura - falso negativo.  De la figura se puede ver que es difícil determinar visualmente el tiempo de error, y el algoritmo hace frente a esta tarea bastante bien.  Aunque es importante entender que las lecturas del tercer sensor no se dan aquí.  Además, hay lecturas de falsos positivos después del final del error.  Es decir  el algoritmo ve que también hay valores erróneos y marcamos esta área como libre de errores.  El lado derecho de la figura muestra el área antes del error, que marcamos como errónea (media hora antes del error), que se reconoció como libre de errores, lo que conduce a errores de modelo falso negativo.  En el centro de la figura, se reconoce una pieza coherente, reconocida como un error.  La conclusión se puede extraer de la siguiente manera: al resolver el problema de la búsqueda de anomalías, debe interactuar estrechamente con los ingenieros que entienden la esencia de los sistemas cuya salida necesita predecir, ya que verificar los algoritmos utilizados en el marcado no refleja completamente la realidad y no simula las condiciones en las que dichos algoritmos podrían ser utilizado <br><br>  Código para trazar el gráfico: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_time_course</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df_test,dfc,y_preds,start,end,vert_shift=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span>   plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>))   cols=df_train.filter(regex=(<span class="hljs-string"><span class="hljs-string">'S[12]'</span></span>)).columns   add=<span class="hljs-number"><span class="hljs-number">0</span></span>   preds_idx=y_preds.iloc[start:end][y_preds[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>].index   true_idx=df_test.iloc[start:end,:][df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>].index   tp_idx=set(true_idx.values).intersection(set(preds_idx.values))   fn_idx=set(true_idx.values).difference(set(preds_idx.values))   fp_idx=set(preds_idx.values).difference(set(true_idx.values))   xtime=df_test[<span class="hljs-string"><span class="hljs-string">'Time'</span></span>].iloc[start:end]   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cols:       plt.plot(xtime,df_test[col].iloc[start:end]+add)       plt.scatter(xtime.loc[tp_idx].values,df_test.loc[tp_idx,col]+add,color=<span class="hljs-string"><span class="hljs-string">'green'</span></span>)       plt.scatter(xtime.loc[fn_idx].values,df_test.loc[fn_idx,col]+add,color=<span class="hljs-string"><span class="hljs-string">'violet'</span></span>)       plt.scatter(xtime.loc[fp_idx].values,df_test.loc[fp_idx,col]+add,color=<span class="hljs-string"><span class="hljs-string">'red'</span></span>)       add+=vert_shift   failures=dfc[(dfc[<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>]&gt;xtime.iloc[<span class="hljs-number"><span class="hljs-number">0</span></span>])&amp;(dfc[<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>]&lt;xtime.iloc[<span class="hljs-number"><span class="hljs-number">-1</span></span>])]   unique_fails=np.sort(failures[<span class="hljs-string"><span class="hljs-string">'Type'</span></span>].unique())   colors=np.array([np.random.rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fail <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> unique_fails])   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fail_idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> failures.index:       c=colors[np.where(unique_fails==failures.loc[fail_idx,<span class="hljs-string"><span class="hljs-string">'Type'</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>]       plt.axvline(failures.loc[fail_idx,<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>],color=c)       plt.axvline(failures.loc[fail_idx,<span class="hljs-string"><span class="hljs-string">'End Time'</span></span>],color=c)   leg=plt.legend(unique_fails)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(unique_fails)):       leg.legendHandles[i].set_color(colors[i])</code> </pre> <br>  Si el porcentaje de anomalías es inferior al 5% y / o están mal separados de los indicadores "normales", los métodos anteriores funcionan mal y vale la pena usar algoritmos basados ​​en redes neuronales.  En el caso más simple, estos serían: <br><br><ul><li>  codificadores automáticos (un error alto de un codificador automático capacitado indicará una anomalía en la lectura); </li><li>  redes recurrentes (aprender por secuencia para predecir la última lectura. Si la diferencia es grande, el punto es anormal). </li></ul><br>  Por separado, vale la pena señalar los detalles de trabajar con series de tiempo.  Es importante comprender que la mayoría de los algoritmos anteriores (excepto los autocodificadores y el aislamiento de bosques) probablemente darán una peor calidad al agregar características de retraso (lecturas de puntos anteriores en el tiempo). <br><br>  Intentemos agregar características de retraso en nuestro ejemplo.  La descripción de la competencia dice que los valores 3 horas antes del error no están relacionados con el error de ninguna manera.  Luego agregue las señales en 3 horas.  Total 259 signos. <br><br>  Como resultado, los resultados para OCSVM y IsolationForest se mantuvieron casi sin cambios, mientras que los de Elliptic Envelope y LOF cayeron. <br><br>  Para usar información sobre la dinámica del sistema, se deben usar codificadores automáticos con redes neuronales recurrentes o convolucionales.  O, por ejemplo, una combinación de codificadores automáticos, información de compresión y enfoques convencionales para buscar anomalías basadas en información comprimida.  El enfoque inverso también parece prometedor.  Detección primaria de los puntos más poco característicos por algoritmos estándar, y luego entrenando el codificador automático ya en datos más limpios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/340/9e8/dbc/3409e8dbcc5e9bcac2a1acb08bc7d146.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>Fuente</i></a> <br><br>  Hay un conjunto de técnicas para trabajar con series de tiempo unidimensionales.  Todos ellos están destinados a predecir lecturas futuras, y los puntos que divergen de la predicción se consideran anomalías. <br><br><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo Holt-Winters</a> </h2><br>  El suavizado exponencial triple divide la serie en 3 componentes: nivel, tendencia y estacionalidad.  En consecuencia, si la serie se presenta de esta forma, el método funciona bien.  Facebook Prophet opera con un principio similar, pero evalúa los componentes en sí mismos de una manera diferente.  Se pueden leer más detalles, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h2>  S (ARIMA) </h2><br>  En este método, el modelo predictivo se basa en la autorregresión y la media móvil.  Si estamos hablando de la expansión de S (ARIMA), entonces nos permite evaluar la estacionalidad.  Lea más sobre el enfoque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h2>  Otros enfoques de servicio predictivo </h2><br>  Cuando se trata de series de tiempo y hay información sobre los tiempos de ocurrencia de errores, puede aplicar métodos de enseñanza con un maestro.  Además de la necesidad de datos etiquetados, en este caso es importante comprender que la predicción del error dependerá de la naturaleza del error.  Si hay muchos errores y de una naturaleza diferente, lo más probable es que sea necesario predecir cada uno por separado, lo que requerirá aún más datos etiquetados, pero las perspectivas serán más atractivas. <br><br>  Existen formas alternativas de utilizar el aprendizaje automático en el mantenimiento predictivo.  Por ejemplo, prediciendo una falla del sistema en los próximos N días (tarea de clasificación).  Es importante comprender que este enfoque requiere que la ocurrencia de un error en la operación del sistema esté precedida por un período de degradación (no necesariamente gradual).  En este caso, el enfoque más exitoso parece ser el uso de redes neuronales con capas convolucionales y / o recurrentes.  Por separado, vale la pena señalar los métodos para aumentar las series de tiempo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dos enfoques</a> me parecen los más interesantes y al mismo tiempo simples: <br><br><ul><li>  Se selecciona la parte continua de la fila (por ejemplo, 70% y se elimina el resto) y se estira al tamaño original </li><li>  Se selecciona y estira o comprime una parte continua de la fila (por ejemplo, 20%).  Después de eso, toda la fila se comprime o estira en consecuencia a su tamaño original. </li></ul><br>  También hay una opción para predecir la vida útil restante del sistema (tarea de regresión).  Aquí podemos distinguir un enfoque separado: la predicción no es de la vida útil, sino de los parámetros de distribución de Weibull. <br><br>  Puede leer sobre la distribución en sí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> sobre su uso junto con mallas recurrentes.  Esta distribución tiene dos parámetros α y β.  α indica cuándo ocurrirá el evento, y β indica qué tan seguro es el algoritmo.  Aunque la aplicación de este enfoque es prometedora, en este caso surgen dificultades para entrenar la red neuronal, ya que al principio es más fácil que el algoritmo sea inseguro que predecir una vida útil adecuada. <br><br>  Por separado, vale la pena señalar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regresión de Cox</a> .  Le permite predecir la tolerancia a fallas del sistema para cada punto en el tiempo después del diagnóstico, presentándolo como un producto de dos funciones.  Una función es la degradación del sistema, independientemente de sus parámetros, es decir.  común a cualquiera de estos sistemas.  Y el segundo es una dependencia exponencial de los parámetros de un sistema particular.  Entonces, para una persona, hay una función común asociada con el envejecimiento, más o menos la misma para todos.  Pero el deterioro de la salud también se asocia con el estado de los órganos internos, que es diferente para todos. <br><br>  Espero que ahora sepa un poco más sobre el mantenimiento predictivo.  Estoy seguro de que tendrá preguntas sobre los métodos de aprendizaje automático que se utilizan con mayor frecuencia para esta tecnología.  Estaré encantado de responder a cada uno de ellos en los comentarios.  Si está interesado en no solo preguntar sobre lo que está escrito, sino que quiere hacer algo similar, nuestro equipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CleverDATA</a> siempre está encantado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contar</a> con profesionales talentosos y entusiastas. <br><br><div class="spoiler">  <b class="spoiler_title">¿Hay vacantes?</b>  <b class="spoiler_title">Por supuesto!</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollador Java (Big Data)</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447190/">https://habr.com/ru/post/447190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447178/index.html">5 oportunidades efectivas para usar la tecnología de minería de procesos</a></li>
<li><a href="../447180/index.html">Descripción general y comparación de controladores de entrada para Kubernetes</a></li>
<li><a href="../447182/index.html">Sistemas operativos: tres piezas fáciles. Parte 3: API de proceso (traducción)</a></li>
<li><a href="../447184/index.html">¿Qué es la Oferta de intercambio inicial (IEO) y en qué se diferencia de ICO?</a></li>
<li><a href="../447186/index.html">Cómo lanzar un prototipo de ML en un día. Informe Yandex.Taxi</a></li>
<li><a href="../447192/index.html">¿Qué papel puede jugar la tecnología en el antiguo arte de mezclar especias?</a></li>
<li><a href="../447194/index.html">Funciones de renderizado en Metro: trazado de rayos Exodus c</a></li>
<li><a href="../447196/index.html">7. Check Point Getting Started R80.20. Control de acceso</a></li>
<li><a href="../447198/index.html">Misión lunar "Bereshit": aterrizaje-accidente-caída en la luna</a></li>
<li><a href="../447204/index.html">17 de abril: Conferencia abierta "El camino del desarrollador del juego: desde la idea hasta el lanzamiento" y una biblioteca de juegos en la Escuela Superior de Derecho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>