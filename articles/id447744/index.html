<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎓 🥪 🕺🏾 Climbing Elbrus - Pengintaian dalam pertempuran. Bagian Teknis 2. Mengganggu, pengecualian, pengatur waktu sistem 🤲🏻 💂 👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus menjelajahi Elbrus dengan memasukkan Embox ke dalamnya. 

 Artikel ini adalah bagian kedua dari artikel teknis tentang arsitektur Elbrus. B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Climbing Elbrus - Pengintaian dalam pertempuran. Bagian Teknis 2. Mengganggu, pengecualian, pengatur waktu sistem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Kami terus menjelajahi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elbrus</a> dengan memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embox</a> ke dalamnya. <br><br>  Artikel ini adalah bagian kedua dari artikel teknis tentang arsitektur Elbrus.  Bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> berurusan dengan tumpukan, register, dan sebagainya.  Sebelum membaca bagian ini, kami sarankan Anda mempelajari yang pertama, karena membahas tentang hal-hal dasar dalam arsitektur Elbrus.  Bagian ini akan fokus pada penghitung waktu, interupsi, dan pengecualian.  Lagi-lagi ini bukan dokumentasi resmi.  Untuk itu, Anda harus menghubungi pengembang Elbrus di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICST</a> . <a name="habracut"></a><br>  Untuk mempelajari Elbrus, kami ingin memulai timer dengan cepat, karena, seperti yang Anda tahu, preemptive multitasking tidak berfungsi tanpa itu.  Untuk melakukan ini, tampaknya cukup untuk mengimplementasikan pengontrol interupsi dan pengatur waktu itu sendiri, tetapi kami mengalami kesulitan yang <s>tidak terduga</s> , di mana kami akan pergi tanpa mereka.  Mereka mulai mencari kemampuan debugging dan menemukan bahwa para pengembang menangani ini dengan memperkenalkan beberapa perintah yang memungkinkan Anda untuk meningkatkan berbagai situasi luar biasa.  Misalnya, Anda dapat membuat pengecualian jenis khusus melalui register PSR (Processor Status Register) dan UPSR (Register status prosesor pengguna).  Untuk PSR, bit exc_last_wish adalah flag pengecualian exc_last_wish ketika kembali dari prosedur, dan untuk UPSR, exc_d_interrupt adalah flag interupsi tertunda yang dihasilkan oleh operasi VFDI (Periksa flag interrupt tertunda). <br><br>  Kode tersebut adalah sebagai berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Diluncurkan.  Tapi tidak ada yang terjadi, sistem tergantung di suatu tempat, tidak ada output ke konsol.  Sebenarnya, kami melihat ini ketika kami mencoba memulai interupsi dari penghitung waktu, tetapi kemudian ada banyak komponen, dan di sini jelas bahwa ada sesuatu yang mengganggu kemajuan berurutan dari program kami, dan kontrol dipindahkan ke tabel pengecualian (dalam hal arsitektur Elbrus, lebih tepat untuk berbicara bukan tentang tabel) interupsi dan tentang tabel pengecualian).  Kami berasumsi bahwa prosesor tetap melemparkan pengecualian, tetapi ada beberapa "sampah" di mana ia mentransfer kontrol.  Ternyata, ia mentransfer kontrol ke tempat kami meletakkan gambar Embox, yang berarti ada titik masuk - fungsi entri. <br><br>  Untuk verifikasi, kami melakukan hal berikut.  Memulai penghitungan entri pada entri ().  Awalnya, semua CPU mulai dengan interupsi dimatikan, masuk ke entri (), setelah itu kita hanya membiarkan satu inti aktif, semua sisanya masuk ke loop tanpa akhir.  Setelah penghitung sama dengan jumlah CPU, kami menganggap bahwa semua klik berikutnya dalam entri adalah pengecualian.  Saya mengingatkan Anda bahwa sebelum itu seperti yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama kami tentang Elbrus</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Melakukannya <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  Dan akhirnya kami melihat reaksi memasuki interupsi (hanya dengan bantuan printf kami mencetak garis). <br><br>  Di sini perlu dijelaskan bahwa awalnya dalam versi pertama kami diharapkan untuk menyalin tabel pengecualian, tetapi pertama-tama, ternyata itu ada di alamat kami, dan kedua, kami tidak dapat membuat salinan yang benar.  Saya harus menulis ulang skrip linker, titik masuk ke sistem, dan pengendali interupsi, yaitu, saya memerlukan bagian assembler, tentang hal itu sedikit kemudian. <br><br>  Beginilah tampilan bagian yang diubah dari skrip tautan sekarang: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  yaitu, kami menghapus bagian entri untuk tabel pengecualian.  Bagian cpu_idle juga terletak di sana untuk CPU yang tidak digunakan. <br><br>  Seperti inilah fungsi input untuk kernel aktif kami, tempat Embox akan berjalan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU “” */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Nah, pengecualian dilemparkan sesuai dengan instruksi VFDI.  Sekarang Anda perlu mendapatkan nomornya untuk memastikan bahwa ini adalah pengecualian yang benar.  Untuk ini, Elbrus memiliki register informasi interupsi TIR (register Trap Info).  Mereka berisi informasi tentang beberapa perintah terakhir, yaitu bagian akhir dari penelusuran.  Lacak kumpul selama eksekusi program dan "beku" saat memasukkan interupsi.  TIR mencakup bagian rendah (64 bit) dan tinggi (64 bit).  Kata rendah berisi bendera pengecualian, dan kata tinggi berisi pointer ke instruksi yang mengarah ke pengecualian dan nomor TIR saat ini.  Dengan demikian, dalam kasus kami, exc_d_interrupt adalah bit ke-4. <br><br>  Catatan Kami masih memiliki beberapa kesalahpahaman tentang kedalaman (jumlah) TIR.  Dokumentasi menyediakan: <br><blockquote>  “Kedalaman memori TIR, yaitu, jumlah register Info Perangkap, ditentukan <br>  TIR_NUM makro sama dengan jumlah tahapan pipa prosesor yang diperlukan untuk <br>  mengeluarkan semua situasi khusus yang mungkin terjadi.  TIR_NUM = 19; " </blockquote>  Dalam praktiknya, kami melihat kedalaman = 1, dan oleh karena itu kami hanya menggunakan register TIR0. <br><br>  Spesialis di MCST menjelaskan kepada kami bahwa semuanya benar, dan hanya akan ada TIR0 untuk gangguan "akurat", dan untuk situasi lain mungkin ada hal lain.  Tetapi karena sementara kita hanya berbicara tentang penghentian waktu, ini tidak mengganggu kita. <br><br>  Ok, sekarang mari kita lihat apa yang diperlukan untuk masuk / keluar dengan benar dari pengendali pengecualian.  Bahkan, perlu untuk menyimpan pada input dan mengembalikan 5 register berikut pada output.  Tiga register persiapan transfer kontrol adalah ctpr [1,2,3], dan dua register kontrol siklus adalah ILCR (Daftar nilai awal dari penghitung siklus) dan LSR (Daftar status siklus). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  Sebenarnya, itu saja, setelah keluar dari penangan pengecualian, Anda harus mengembalikan 5 register ini. <br><br>  Kami melakukan ini dengan makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  Penting juga untuk tidak lupa setelah pemulihan register untuk memanggil operasi DONE (Return from the hardware interrupt handler).  Operasi ini diperlukan, khususnya, agar dapat memproses operasi transfer kontrol yang terputus dengan benar.  Kami melakukan ini dengan makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  Sebenarnya, kami melakukan pengembalian dari interupsi secara langsung dalam kode C menggunakan dua makro ini. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Interupsi eksternal </h3><br>  Mari kita mulai dengan cara mengaktifkan interupsi eksternal.  Di Elbrus, APIC (atau lebih tepatnya analognya) digunakan sebagai pengontrol interupsi, Embox sudah memiliki driver ini.  Karena itu, dimungkinkan untuk mengambil pengatur waktu sistem untuk itu.  Ada dua timer, satu yang sangat mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PIT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timer LAPIC</a> lainnya, juga cukup standar, sehingga tidak masuk akal untuk membicarakannya.  Baik itu dan itu terlihat sederhana, dan itu dan itu sudah ada di Embox, tetapi driver timer LAPIC terlihat lebih perspektif, selain itu implementasi timer PIT bagi kami lebih non-standar.  Karena itu, sepertinya lebih mudah untuk diselesaikan.  Selain itu, dokumentasi resmi menggambarkan register APIC dan LAPIC, yang sedikit berbeda dari aslinya.  Membawa mereka tidak masuk akal, seperti yang Anda lihat di aslinya. <br><br>  Selain mengizinkan interupsi dalam APIC, Anda harus mengaktifkan penanganan interupsi melalui register PSR / UPSR.  Kedua register memiliki tanda untuk mengaktifkan interupsi eksternal dan interupsi non-maskable.  <i>TETAPI di</i> sini sangat penting untuk dicatat bahwa register PSR bersifat <i>lokal</i> untuk fungsi (ini telah dibahas pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teknis pertama</a> ).  Dan ini berarti bahwa jika Anda mengaturnya di dalam suatu fungsi, maka ketika Anda memanggil semua fungsi berikutnya, itu akan diwarisi, tetapi ketika Anda kembali dari fungsi, itu akan kembali ke keadaan semula.  Karena itu pertanyaannya, tetapi bagaimana mengelola interupsi? <br><br>  Kami menggunakan solusi berikut.  Register PSR memungkinkan Anda untuk mengaktifkan manajemen melalui UPSR, yang sudah bersifat global (yang kami butuhkan).  Oleh karena itu, kami mengaktifkan kontrol melalui UPSR secara langsung (penting!) Sebelum fungsi login inti Embox: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  Entah bagaimana secara kebetulan setelah refactoring saya mengambil dan meletakkan garis-garis ini ke fungsi yang terpisah ... Dan register adalah fungsi lokal.  Jelas semuanya rusak :) <br><br>  Jadi, semuanya tampaknya dihidupkan dalam prosesor, pergi ke pengontrol interupsi. <br><br>  Seperti yang telah kita lihat di atas, informasi tentang nomor pengecualian ada di register TIR.  Selanjutnya, bit ke-32 dalam register ini melaporkan bahwa gangguan eksternal telah terjadi. <br><br>  Setelah menyalakan timer, beberapa hari siksaan terjadi, karena tidak ada gangguan yang dapat diperoleh.  Alasannya cukup lucu.  Ada pointer 64-bit di Elbrus, dan alamat register di APIC masuk ke uint32_t, itu sebabnya kami menggunakannya.  Tetapi ternyata jika Anda perlu, misalnya, memberikan 0xF0000000 ke sebuah pointer, maka Anda tidak akan mendapatkan 0xF0000000, tetapi 0xFFFFFFFFF0000000.  Artinya, kompiler akan memperluas tanda int Anda yang tidak ditandatangani. <br><br>  Di sini, tentu saja, perlu menggunakan uintptr_t, karena, ternyata, dalam standar C99, jenis konversi ini didefinisikan oleh implementasi. <br><br>  Setelah kami akhirnya melihat bit ke-32 di TIR, kami mulai mencari cara mendapatkan nomor interupsi.  Ternyata cukup sederhana, meskipun tidak seperti pada x86, ini adalah salah satu perbedaan antara implementasi LAPIC.  Untuk Elbrus, untuk mendapatkan nomor interupsi, Anda harus masuk ke register LAPIC khusus: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  di mana 0xFEE00000 adalah alamat dasar register LAPIC. <br><br>  Itu saja, ternyata untuk mengambil timer sistem dan timer LAPIC. <br><br><h3>  Kesimpulan </h3><br>  Informasi yang diberikan dalam dua bagian teknis pertama artikel tentang arsitektur Elbrus cukup untuk mengimplementasikan interupsi perangkat keras dan multitasking preemptive di OS apa pun.  Sebenarnya, screenshot yang diberikan bersaksi untuk ini. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Ini bukan bagian teknis terakhir tentang arsitektur Elbrus.  Sekarang kami menguasai manajemen memori (MMU) di Elbrus, kami berharap segera membicarakannya.  Kami membutuhkan ini tidak hanya untuk implementasi ruang alamat virtual, tetapi juga untuk pekerjaan normal dengan periferal, karena melalui mekanisme ini Anda dapat menonaktifkan atau mengaktifkan caching area spesifik ruang alamat. <br><br>  Segala sesuatu yang ditulis dalam artikel dapat ditemukan di repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embox</a> .  Anda juga dapat membangun dan menjalankan, jika tentu saja ada platform perangkat keras.  Benar, kompiler diperlukan untuk ini, dan itu hanya dapat diperoleh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MCST</a> .  Dokumentasi resmi dapat diminta di sana. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447744/">https://habr.com/ru/post/id447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447732/index.html">Dog Breed Identifier: Pengembangan Siklus Penuh dari Program Keras ke Aplikasi Android. di pasar bermain</a></li>
<li><a href="../id447734/index.html">Mengapa front-end harus memahami prinsip-prinsip UI</a></li>
<li><a href="../id447736/index.html">Drone video - tren baru di jejaring sosial</a></li>
<li><a href="../id447738/index.html">Julian Assange ditangkap oleh polisi Inggris</a></li>
<li><a href="../id447742/index.html">Apa metodologi DevOps dan siapa yang membutuhkannya</a></li>
<li><a href="../id447746/index.html">Logika bisnis basis data dengan SchemaKeeper</a></li>
<li><a href="../id447754/index.html">Aplikasi menu bar untuk macOS</a></li>
<li><a href="../id447784/index.html">Musik di Hari Kosmonautika</a></li>
<li><a href="../id447786/index.html">Latar Belakang: Robot Fedor, apa yang Anda?</a></li>
<li><a href="../id447788/index.html">Kami membuat agregator berita dengan fokus pada cryptocurrency - intwt.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>