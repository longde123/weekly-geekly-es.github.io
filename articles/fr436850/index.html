<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 🕴🏾 🥙 Erreurs courantes lors de l'écriture des tests unitaires. Conférence Yandex 🛂 🎂 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous maîtrisez une petite liste d'erreurs typiques qui se produisent lors de l'écriture de tests unitaires, vous pouvez même aimer les écrire. Aujo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erreurs courantes lors de l'écriture des tests unitaires. Conférence Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/436850/">  Si vous maîtrisez une petite liste d'erreurs typiques qui se produisent lors de l'écriture de tests unitaires, vous pouvez même aimer les écrire.  Aujourd'hui, le chef de l'équipe de développement Yandex.Browser pour Android Konstantin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">kzaikin</a> Zaikin partagera son expérience avec les lecteurs Habr. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZyGZjpxF9Fo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - J'ai un rapport pratique.  J'espère que cela vous sera bénéfique à tous - ceux qui sont déjà en train de passer des tests unitaires, ceux qui pensent à écrire, ceux qui essaient et qui n'ont pas réussi. <a name="habracut"></a><br><br>  Nous avons un assez gros projet.  L'un des plus grands projets mobiles en Russie.  Nous avons beaucoup de code, beaucoup de tests.  Les tests sont poursuivis à chaque demande de pool, ils ne tombent pas en même temps. <br><br>  Qui sait quelle couverture de test il a dans le projet?  Zéro, d'accord.  Qui a des tests unitaires dans le projet?  Et qui pense que les tests unitaires ne sont pas nécessaires?  Je ne vois rien de mal à cela, il y a des gens qui en sont sincèrement convaincus, et mon histoire devrait les aider à en être convaincus. <br><br>  Heureusement, des milliers de tests écologiques - nous ne sommes pas venus tout de suite.  Il n'y a pas de solution miracle, et l'idée principale de mon rapport à l'écran: <br><br><img src="https://habrastorage.org/webt/w1/0y/wm/w10ywme1xumvi5asap7gp0a5iee.jpeg"><br><br>  Le dicton chinois est écrit en hiéroglyphes selon lequel un voyage d'un millier de personnes commence par un pas.  Il semble qu'il y ait un tel analogue de ce dicton. <br><br>  Il y a longtemps, nous avons décidé que nous devions améliorer notre produit, notre code, et nous nous dirigeons résolument vers cela.  Sur ce chemin, nous avons rencontré beaucoup de bosses, un râteau sous-marin et rassemblé avec cela quelques croyances. <br><br><img src="https://habrastorage.org/webt/ks/9z/5w/ks9z5wmzmkghfc-vireaf5rdvvg.jpeg"><br><br>  Pourquoi avons-nous besoin de tests? <br><br>  Pour que les anciennes fonctionnalités ne tombent pas lorsque nous en introduisons de nouvelles.  Pour avoir un badge sur GitHub.  Pour refactoriser les fonctionnalités existantes - une réflexion approfondie, elle doit être révélée à ceux qui n'écrivent pas de tests.  Afin que les fonctionnalités existantes ne tombent pas lors du refactoring, nous nous protégerons par des tests.  Pour que le patron envoie une demande de pool, oui. <br><br>  Mon avis - veuillez ne pas l'associer à l'avis de mon équipe - que les tests nous aident.  Ils vous permettent d'exécuter votre code sans le mettre en production, sans l'installer sur des appareils, vous le lancez et l'exécutez très rapidement.  Vous pouvez fuir tous les cas d'angle que vous n'avez pas dans la vie sur l'appareil et en production, et votre testeur ne les proposera pas.  Mais en tant que développeur, vous les inventerez, les vérifierez et corrigerez les bogues à un stade précoce. <br><br>  Très important: les tests indiquent comment, selon le développeur, le code devrait fonctionner et ce que, selon le développeur, vos méthodes devraient faire.  Ce ne sont pas des commentaires qui éloignent et après un certain temps des commentaires utiles deviennent nuisibles.  Il arrive que dans les commentaires, une chose soit écrite et que le code soit complètement différent.  Les tests unitaires dans ce sens ne peuvent pas mentir.  Si le test est vert, il documente ce qui s'y passe.  Le test a échoué - vous avez violé l'intention principale du développeur. <br><br>  Engagez des contrats.  Ce ne sont pas des contrats signés et tamponnés, mais des contrats logiciels pour le comportement de classe.  Si vous refactorisez, dans ce cas les contrats seront violés et les tests tomberont si vous les cassez.  Si les contrats sont sauvegardés, les tests resteront verts, vous aurez plus confiance que votre refactoring est correct. <br><br><img src="https://habrastorage.org/webt/pr/z0/fc/prz0fclospeod5fnxeum2bi19gw.jpeg"><br><br>  C'est l'idée générale de tout mon rapport.  Vous pouvez montrer la première ligne et partir. <br><br>  Beaucoup de gens pensent que le code de test est un code moyen, il n'est pas destiné à la production, vous pouvez donc l'écrire tel quel.  Je suis fortement en désaccord avec cela et je pense que les tests doivent d'abord être abordés de manière responsable, ainsi que le code de production.  Si vous les abordez de la même manière, les tests vous seront bénéfiques.  Sinon, ce sera un charbon. <br><br>  Plus précisément, les deux lignes ci-dessous font référence à n'importe quel code, semble-t-il. <br><br>  KISS - restez simple, stupide.  Pas besoin de compliquer.  Les tests doivent être simples.  Et le code de production doit être simple, mais les tests le sont surtout.  Si vous avez des tests faciles à lire, alors ce seront des tests qui sont très probablement bien écrits, ils sont bien exprimés, ils seront faciles à tester.  Même pendant la demande de pool, une personne qui regarde vos nouveaux tests comprendra ce que vous vouliez dire.  Et si quelque chose se casse, vous pouvez facilement comprendre ce qui s'est passé. <br><br>  SEC - ne vous répétez pas.  Dans les tests, le développeur est souvent enclin à utiliser la technique interdite que personne ne semble utiliser dans la production - copier-coller.  Dans la production d'un développeur qui copiera-collera activement, ils ne comprendront tout simplement pas.  Dans les tests, c'est malheureusement une pratique normale.  Pas besoin de le faire, car - la première ligne.  Si vous écrivez les tests honnêtement, comme du vrai bon code, les tests vous seront utiles. <br><br>  Pendant que nous développions nos centaines de milliers de lignes de code, écrivant des milliers de tests, collectant des râteaux, j'avais accumulé des commentaires typiques sur les tests.  Je suis assez paresseux, et quand je suis allé aux demandes de pool et que j'ai observé les mêmes erreurs, basé sur le principe DRY, j'ai décidé d'écrire ces problèmes typiques, et je l'ai d'abord fait sur le Wiki interne puis j'ai posté des odeurs de test pratiques sur GitHub que vous pouvez suivre lorsque vous écrivez des tests. <br><br><img src="https://habrastorage.org/webt/oj/k1/u2/ojk1u2fjmy269sioq4vin6yylua.jpeg"><br><br>  Je vais énumérer par points.  Incrémentez un compteur dans votre esprit si vous vous souvenez d'une telle odeur de test.  Si vous comptez jusqu'à cinq, vous pouvez lever la main et crier "Bingo!"  Et au final, je me demande qui a compté combien.  Mon compteur sera égal au nombre de points, je les ai tous collectés moi-même. <br><br><img src="https://habrastorage.org/webt/nm/pw/8n/nmpw8nk89hl6gmggyims0llmn28.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien GitHub</a></sub></sup> </h5><br>  La chose la plus difficile en programmation que vous connaissez.  Et dans les tests, c'est vraiment important.  Si vous ne nommez pas bien le test, vous ne pourrez probablement pas formuler ce que le test vérifie. <br><br>  Les humains sont des créatures assez simples, ils sont facilement piégés dans les noms.  Par conséquent, je vous demande de bien appeler les tests.  Formulez un test pour vérifier et suivre des règles simples. <br><br><h4>  no_action_or_assertion </h4><br>  Si le nom du test ne contient pas de description de ce que le test vérifie, par exemple, vous avez la classe Controller et vous écrivez le test testController, que vérifiez-vous?  Que devrait faire ce test?  Très probablement, rien ou trop de choses à vérifier.  Ni l'un ni l'autre ne nous conviennent.  Par conséquent, il est nécessaire d'écrire au nom du test ce que nous vérifions. <br><br><h4>  long_name </h4><br>  Vous ne pouvez pas aller à l'autre extrême.  Le nom du test doit être suffisamment court pour qu'une personne puisse facilement l'analyser.  En ce sens, Kotlin est génial car il vous permet d'écrire des noms de test entre guillemets avec des espaces en anglais normal.  Ils sont plus faciles à lire.  Mais quand même, les noms longs sentent bon. <br><br>  Si le nom de votre test est trop long, vous mettez probablement trop de méthodes de test dans une classe de test et vous devez clarifier ce que vous vérifiez.  Dans ce cas, vous devez diviser votre classe de test en plusieurs.  Pas besoin d'avoir peur de ça.  Vous aurez un nom de classe de test qui vérifie le nom de votre code de production, et il y aura des noms de test courts. <br><br><h4>  old_prefix </h4><br>  C'est de l'atavisme.  Auparavant, en Java, tout le monde testait en utilisant JUnit, où jusqu'à la quatrième version, il y avait un accord pour que les méthodes de test commencent par le mot test.  Il en est ainsi, tout le monde l'appelle toujours ainsi.  Mais il y a un problème, en anglais le mot test est le verbe «check».  Les gens sont facilement pris dans ce piège et n'écrivent plus d'autres verbes.  Écrivez testController.  Il est facile de vérifier vous-même: si vous n’avez pas écrit un verbe ce que votre classe de test devrait faire, vous n’avez probablement pas vérifié quelque chose, vous ne l’avez pas assez bien écrit.  Par conséquent, je vous demande toujours de supprimer le mot test des noms des méthodes de test. <br><br>  Je dis des choses très simples, mais curieusement, elles aident.  Si les tests sont bien appelés, très probablement sous le capot, ils auront l'air bien.  C'est très simple. <br><br><img src="https://habrastorage.org/webt/1e/_h/b3/1e_hb3te9onmzprsqcvilm2i_cc.jpeg"><br><br>  J'ai en fait lu les identifiants des odeurs de test comme sur GitHub.  Le lien est ci-dessous, vous pouvez marcher et utiliser. <br><br><h4>  multiple_asserts </h4><br>  Dans la méthode d'essai, il existe de nombreuses affirmations.  Alors peut-être ou non?  Peut-être.  Est-ce bon ou mauvais?  Je pense que c'est très mauvais.  Si vous avez écrit plusieurs assertions dans une méthode de test, vous vérifiez plusieurs déclarations.  Si vous testez votre test et que la première assertion tombe, le test atteindra-t-il la deuxième assertion?  N'atteindra pas.  Vous avez déjà après la chute de votre assemblage quelque part sur le CI que le test est tombé, allez réparer quelque chose, remplissez-le à nouveau, il tombera à l'assertion suivante.  Cela pourrait très bien l'être. <br><br>  Dans ce cas, ce serait beaucoup plus cool si vous sciez cette méthode de test en plusieurs, et toutes les méthodes avec plusieurs assertions tombaient en même temps, car elles seraient lancées indépendamment les unes des autres. <br><br>  Quelques assertions supplémentaires peuvent masquer les différentes actions effectuées avec la classe de test.  Je recommande d'écrire un test - une affirmation.  Dans le même temps, les affirmations peuvent être assez complexes.  Mon collègue, dans le tout premier rapport, a démontré un morceau de code où il a utilisé l'excellente construction assertThat et le matcher.  J'adore vraiment les rencontres chez JUnit, vous pouvez donc l'utiliser aussi.  Pour le lecteur de test, il ne s’agit que d’une courte déclaration.  GitHub a des exemples de toutes ces odeurs et comment les corriger.  Il y a un exemple de mauvais code et de bon code.  Tout cela se fait sous la forme d'un projet que vous pouvez télécharger, ouvrir, compiler et exécuter tous les tests. <br><br><h4>  many_tests_in_one </h4><br>  L'odeur suivante est étroitement liée à la précédente.  Vous faites quelque chose avec le système - vous faites une affirmation.  Faire autre chose avec le système, de longues opérations - faire une assertion - faire autre chose.  En fait, vous avez simplement vu plusieurs méthodes et vous obtenez de bonnes méthodes de test solides. <br><br><h4>  repeating_setup </h4><br>  Cela fait référence à la verbosité.  Si vous avez une classe de test et que chaque méthode de test exécute les mêmes méthodes au début. <br><br>  Une classe de test dans laquelle les mêmes méthodes sont exécutées au début.  Cela semble un peu, mais dans chaque méthode de test, ces ordures sont présentes.  Et si elle est commune à toutes les méthodes de test, pourquoi ne pas la faire glisser dans le constructeur ou le bloc <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Avant</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Avant</a> chaque bloc dans JUnit 5. Si vous faites cela, la lisibilité de chaque méthode s'améliorera, et vous vous débarrasserez du péché SEC.  Ces tests sont plus faciles à maintenir et à lire. <br><br><img src="https://habrastorage.org/webt/jz/e6/pt/jze6ptgcma9s-f62hobgcoj5jbu.jpeg"><br><br>  La fiabilité des tests est très importante.  Il y a des signes par lesquels il peut être déterminé que le test va pleurer, être vert ou rouge.  Lorsque le développeur l'écrit, il est sûr qu'il est vert, puis pour une raison quelconque, les tests deviennent verts ou rouges, ce qui nous donne la douleur et l'incertitude en général que les tests sont utiles.  Nous ne sommes pas sûrs des tests, ce qui signifie que nous ne sommes pas sûrs qu'ils soient utiles. <br><br><h4>  aléatoire </h4><br>  J'ai moi-même écrit une fois des tests contenant Math.random (), fait des nombres aléatoires, fait quelque chose avec eux.  Pas besoin de faire ça.  Nous nous attendons à ce que le système de test entre dans le système de test dans la même configuration, et la sortie de celui-ci doit également être la même.  Par conséquent, dans les tests unitaires, par exemple, vous n'avez jamais besoin d'effectuer d'opérations avec le réseau.  Parce que le serveur peut ne pas répondre, il peut y avoir différents horaires, autre chose. <br><br>  Si vous avez besoin d'un test qui fonctionne avec le réseau, faites un proxy, local, n'importe quoi, mais en aucun cas allez sur un vrai réseau.  C'est le même hasard.  Et bien sûr, vous ne pouvez pas utiliser de données aléatoires.  Si vous devez faire quelque chose, faites quelques exemples avec des conditions aux limites, avec de mauvaises conditions, mais elles devraient être codées en dur. <br><br><h4>  tread_sleep </h4><br>  Un problème classique auquel les développeurs sont confrontés lorsqu'ils essaient de tester une sorte de code asynchrone.  C'est que j'ai fait quelque chose dans le test, puis je dois attendre jusqu'à ce qu'il soit terminé.  Comment faire?  Thread.sleep (), bien sûr. <br><br>  Il y a un problème.  Lorsque vous avez développé votre test, par exemple, vous l'avez fait sur une partie de votre machine à écrire, cela fonctionne à une certaine vitesse.  Vous exécutez les tests sur une autre machine.  Et que se passera-t-il si votre système ne parvient pas à fonctionner pendant le temps Thread.sleep ()?  Le test devient rouge.  C'est inattendu.  Par conséquent, la recommandation ici est, si vous effectuez des opérations asynchrones, ne les testez pas du tout.  Presque n'importe quelle opération asynchrone peut être déployée de sorte que vous ayez une sorte de mécanisme conditionnel qui fournit un fonctionnement asynchrone et un bloc de code exécuté de manière synchrone.  Par exemple, AsyncTask à l'intérieur a un bloc de code exécuté de manière synchrone.  Vous pouvez facilement le tester de manière synchrone, sans asynchronisme.  Il n'est pas nécessaire de tester AsyncTask lui-même, c'est une classe framework, pourquoi la tester?  Accrochez-vous et votre vie sera plus facile. <br><br>  Thread.sleep () est très douloureux.  En plus du fait qu'elle aggrave la fiabilité des tests, car elle leur permet de pleurer en raison de différents timing sur les appareils, elle ralentit également l'exécution de vos tests.  Qui aimerait que ses tests unitaires, qui devraient être exécutés en millisecondes, se déroulent pendant cinq secondes, car j'ai défini le sommeil de la bande de roulement? <br><br><h4>  modify_global </h4><br>  L'odeur typique est que nous avons modifié une variable statique globale au début du test pour vérifier que notre système fonctionne correctement, mais n'est pas revenu à la fin.  Ensuite, nous obtenons une situation intéressante: sur la machine, le développeur a exécuté les tests dans une séquence, a d'abord vérifié la variable globale avec la valeur par défaut, puis l'a modifiée dans un autre test, puis a fait autre chose.  Les deux tests sont verts.  Et sur CI, c'est arrivé, les tests ont commencé dans l'ordre inverse.  Et l'un ou les deux tests seront rouges, bien qu'ils soient tous verts. <br><br>  Vous devez nettoyer après vous.  Règles de reconnaissance dans ce sens: modification de la variable globale - retour à l'état d'origine.  Mieux encore, assurez-vous que les états mondiaux ne sont pas utilisés.  Mais c'est une pensée plus profonde.  Il s'agit du fait que les tests mettent parfois en évidence des défauts d'architecture.  Si nous devons changer les états globaux et les remettre à leur état d'origine afin d'écrire des tests, sommes-nous tous bien dans notre architecture?  Avons-nous vraiment besoin de variables globales, par exemple?  En règle générale, vous pouvez vous en passer en injectant certaines classes de contextes ou quelque chose, afin de pouvoir les réinitialiser, les injecter et les réinitialiser à chaque fois dans le test. <br><br><h4>  @VisibleForTesting </h4><br>  Testez l'odeur pour avancé.  La nécessité d'utiliser une telle chose ne se pose pas le premier jour, en règle générale.  Vous avez déjà testé quelque chose, puis vous avez dû traduire la classe dans un état spécifique.  Et vous vous faites une porte dérobée.  Vous avez une classe de production, et vous créez une méthode spécifique qui ne sera jamais appelée en production, et à travers elle vous injectez quelque chose dans la classe ou changez son état.  Ainsi, brisant malicieusement l'encapsulation.  En production, votre classe fonctionne d'une manière ou d'une autre, mais dans les tests, en fait, c'est une classe différente, vous communiquez avec elle via d'autres entrées et sorties.  Et ici, vous pouvez obtenir une situation où vous modifiez la production, mais les tests ne le remarquent pas.  Les tests continuent de passer par la porte dérobée et n'ont pas remarqué que, par exemple, des exceptions ont commencé à tirer dans le constructeur, car elles passent par un autre constructeur. <br><br>  En général, vous devez tester vos classes via les mêmes entrées et sorties qu'en production.  Il ne devrait y avoir accès à aucune méthode uniquement pour les tests. <br><br><img src="https://habrastorage.org/webt/dy/sf/s0/dysfs0rl9n6ftff4nt3ftwpy988.jpeg"><br><br>  Combien de nos 15 mille tests sont effectués?  Environ 20 minutes, à chaque demande de pool, sur Team City, les développeurs sont obligés d'attendre.  Tout simplement parce que 15 000, c'est beaucoup de tests.  Et dans cette section, j'ai compilé des odeurs qui ralentissent les tests.  Bien que thread_sleep était déjà là. <br><br><h4>  inutile_android_test </h4><br>  Android a des tests d'instrumentation, ils sont beaux, ils fonctionnent sur un appareil ou un émulateur.  Cela soulèvera votre projet complètement, pour de vrai, mais ils sont très lents.  Et pour eux, vous devez même élever un émulateur entier.  Même si vous imaginez que vous avez un émulateur surélevé sur CI - il coïncide tellement que vous en avez un - alors l'exécution du test sur l'émulateur prendra beaucoup plus de temps que sur la machine hôte, par exemple, en utilisant Robolectric.  Bien qu'il existe d'autres méthodes.  C'est un tel framework qui vous permet de travailler avec des classes du framework Android sur la machine hôte, en pur Java.  Nous l'utilisons assez activement.  Auparavant, Google était plutôt cool à ce sujet, mais maintenant les googleurs eux-mêmes en parlent dans divers rapports, il est recommandé de l'utiliser. <br><br><h4>  inutile_robolectrique </h4><br>  Le framework Android de Robolectric est émulé.  Elle n'est pas complète là-bas, bien que la mise en œuvre soit la plus éloignée, la plus complète.  Il est presque réel Android, ne fonctionnant que sur votre bureau, ordinateur portable ou CI.  Mais il n'a pas non plus besoin d'être utilisé partout.  Robolectric n'est pas gratuit.  Si vous avez un test que vous avez héroïquement transféré de l'instrumentation Android vers Robolectric, vous devez penser - peut-être aller encore plus loin, se débarrasser de Robolectric, le transformer en le test JUnit le plus simple?  Les tests robotiques prennent du temps pour s'initialiser, essayer de charger des ressources, initialiser votre activité, votre application et tout le reste.  Cela prend du temps.  Ce n'est pas une seconde, c'est des millisecondes, parfois des dizaines et des centaines.  Mais quand il y a beaucoup de tests, même cela compte. <br><br>  Il existe des techniques qui se débarrassent de Robolectric.  Vous pouvez isoler votre code via des interfaces en enveloppant la partie plate-forme entière avec des interfaces.  Ensuite, il y aura juste un test d'hôte JUnit.  JUnit sur la machine hôte est très rapide, il y a une quantité minimale de surcharge, ces tests peuvent être exécutés par milliers et dizaines de milliers, ils s'exécuteront en une minute, quelques minutes.  Malheureusement, nos tests prennent beaucoup de temps car nous avons beaucoup de tests d'instrumentation Android, car nous avons une partie native dans le navigateur et nous sommes obligés de les exécuter sur un véritable émulateur ou appareil.  Pourquoi si longtemps. <br><br>  Je ne t'ennuierai plus.  Combien d'odeurs avez-vous?  Jusqu'à présent, sept au maximum.  Abonnez-vous à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne</a> , mettez les étoiles. <br><br><img src="https://habrastorage.org/webt/ph/cs/52/phcs52po2jsf1lbjumu1um2e3ha.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436850/">https://habr.com/ru/post/fr436850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436838/index.html">Comprendre les réseaux de neurones convolutifs grâce à des visualisations dans PyTorch</a></li>
<li><a href="../fr436840/index.html">Le chemin du gloss aux neurosciences: un podcast thématique sur les carrières dans les médias et le marketing de contenu</a></li>
<li><a href="../fr436842/index.html">Solution Veeam pour la sauvegarde et la restauration de machines virtuelles sur la plateforme Nutanix AHV. 2e partie</a></li>
<li><a href="../fr436846/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 348 (14-20 janvier 2019)</a></li>
<li><a href="../fr436848/index.html">La NSA annonce la sortie d'un outil interne de rétro-ingénierie</a></li>
<li><a href="../fr436852/index.html">Ralentir pour stimuler le développement</a></li>
<li><a href="../fr436854/index.html">Rust 1.32 Release</a></li>
<li><a href="../fr436856/index.html">Plan de développement informatique selon le ministère des Communications: souveraineté numérique, blockchain dans le logement et les services communaux, logiciel pour «réalité changée»</a></li>
<li><a href="../fr436858/index.html">Espéranto, elfique et klingon</a></li>
<li><a href="../fr436860/index.html">Dell et Alienware au CES 2019: un guide de toutes les innovations majeures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>