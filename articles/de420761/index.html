<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏽 👃🏿 ↩️ TypeScript 3.0 👩🏽‍🌾 🤷🏾 🤛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript 3.0! Ja, er ist herausgekommen und es gibt wirklich viele Neuerungen. Unter dem Schnitt finden Sie eine detaillierte Beschreibung aller neu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript 3.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420761/">  TypeScript 3.0!  Ja, er ist herausgekommen und es gibt wirklich viele Neuerungen.  Unter dem Schnitt finden Sie eine detaillierte Beschreibung aller neuesten Innovationen, einschließlich des Erstellungsmodus, eines neuen unbekannten Typs, wesentlicher Änderungen an der API, Leistungsverbesserungen und vielem mehr.  Jetzt mitmachen! <br><br><img src="https://habrastorage.org/webt/xl/ep/xt/xlepxtzys_k0mqm0crbje5aekvu.jpeg"><a name="habracut"></a><br><br>  TypeScript 3.0 veröffentlicht!  Ein neuer Meilenstein auf dem Weg zur Entwicklung von TypeScript, einem Assistenten für alle JavaScript-Benutzer, hat begonnen. <br><br>  Wenn Sie mit TypeScript nicht vertraut sind, ist es noch nicht zu spät, dies jetzt zu erfahren!  TypeScript ist eine JavaScript-Erweiterung, die für die Verwendung in der modernen Version dieser Sprache statischer Typen entwickelt wurde.  Der TypeScript-Compiler liest TypeScript-Code, der insbesondere Typdeklarationen und Typanmerkungen enthält, und erzeugt sauberen, einfach zu lesenden JavaScript-Code, in dem diese Konstrukte transformiert und gelöscht werden.  Der resultierende Code wird in jeder Laufzeitumgebung ausgeführt, die dem ECMAScript-Standard entspricht, z. B. in Ihrem bevorzugten Browser oder auf der Node.js-Serverplattform. <br><br>  Die Verwendung einer solchen Umgebung bedeutet, dass der Code vor dem Start durch Benutzer auf Fehler oder Tippfehler analysiert wird. Die Vorteile sind jedoch nicht darauf beschränkt.  Mit all diesen Informationen und Analyseergebnissen verbessert TimeScript die Benutzerfreundlichkeit, indem es automatische Code-Vervollständigungs- und Navigationswerkzeuge wie Alle Referenzen suchen, Zur Definition gehen und in Ihrem bevorzugten Editor umbenennen bereitstellt. . <br><br>  Folgen Sie dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link,</a> um mit der Sprache zu beginnen und weitere Informationen zu erhalten.  Wenn Sie TypeScript 3.0 jetzt ausprobieren möchten, können Sie es von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuGet</a> oder über npm herunterladen, indem Sie es eingeben <br><br><pre><code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> -g typescript</code> </pre> <br>  Darüber hinaus ist Unterstützung in den folgenden Editoren verfügbar: <br><br><ul><li>  <a href="">Visual Studio 2017</a> (Version 15.2 und höher); </li><li>  <a href="">Visual Studio 2015</a> (Update 3 erforderlich); </li><li>  Visual Studio Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie müssen eine vorläufige Version installieren</a> , während diese Funktion im Hauptmodus nicht unterstützt wird); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sublime Text 3 auf der PackageControl-Website</a> . </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere Editoren</a> werden nach ihrem eigenen Zeitplan aktualisiert, aber bald werden sie alle eine hervorragende TypeScript-Unterstützung haben. <br><br><h2>  Version 3.0 Übersicht </h2><br>  Nach der Veröffentlichung von TypeScript 2.0 gaben wir einen kurzen Überblick über den Beitrag früherer Versionen zum aktuellen Status.  Zwischen den Versionen von TypeScript 1.0 und 2.0 umfasst die Sprache Union-Typen, Type Guards, Unterstützung für den modernen ECMAScript-Standard, Typ-Aliase, JSX-Unterstützung sowie wörtliche und polymorphe Typen <code>this</code> Typen.  Wenn Sie TypeScript 2.0-Typen, die nicht null-fähig sind, Kontrollflussanalyse, Unterstützung für markierte Gewerkschaften, diese Typen und ein vereinfachtes Modell für den Empfang von <code>.d.ts</code> Dateien <code>.d.ts</code> , können wir sagen, dass dieser Zeitraum die Grundlagen vollständig bestimmt hat TypeScript funktioniert. <br><br>  Was wurde seitdem getan?  Was hat uns zu TypeScript 3.0 geführt, zusätzlich zu den neuen Funktionen des ECMAScript-Standards wie asynchrone / <code>await</code> asynchrone Funktionen, Generatoren und dem Rest / Spread-Operator? <br><br>  TypeScript 2.1 wurde zur grundlegenden Version, die ein statisches Metaprogrammierungsmodell in JavaScript einführte.  Schlüsselanforderung ( <code>keyof</code> ), <code>keyof</code> ( <code>T[K]</code> ) und Arten von zugeordneten Objekten ( <code>{ [K in keyof T]: } T[K]}</code> ) - Dies ist eine Liste von Tools, mit denen die React-, Ember-Bibliotheken effektiver modelliert wurden. Lodash und andere. <br><br>  In den Versionen TypeScript 2.2 und 2.3 wurden Mixin-Klassenvorlagen, der <code>object</code> (der ein Objekt darstellt, das kein Grundelement ist) und Standardwerte für generische Typen unterstützt.  Diese Funktionen wurden in einer Reihe von Projekten wie Angular Material und Polymer verwendet.  Darüber hinaus wurde mit TypeScript 2.3 die Möglichkeit eingeführt, <code>this</code> Typen zu <code>checkJs</code> , sodass die Sprache gut mit Bibliotheken wie Vue zusammenarbeitet. <code>checkJs</code> Flag <code>checkJs</code> wurde <code>checkJs</code> , damit Typen in JavaScript-Dateien überprüft werden können. <br><br>  TypeScript 2.4 und 2.6 setzen die Geschichte fort, den Schweregrad der Funktionsüberprüfung zu erhöhen, die mit einigen der ältesten Überprüfungen unseres Typsystems verbunden ist.  Das Flag <code>--strictFunctionTypes</code> wurde eingeführt, wodurch die Kontravarianz von Parametern <code>--strictFunctionTypes</code> wurde.  In Release 2.7 hat sich der Trend zur Strenge fortgesetzt und wurde in der Validierung in Klassen mit dem Flag <code>--strictPropertyInitialization</code> . <br><br>  TypeScript 2.8 führt bedingte Typen ein, ein leistungsstarkes Tool zum statischen Ausdrücken typbasierter Entscheidungen, und Release 2.9 verallgemeinert den Operator keyof und vereinfacht den Import für Typen. <br><br>  Und das bringt uns zu TypeScript 3.0!  Trotz der neuen Ganzzahl in der Zahl hat sich in Release 3.0 wenig geändert (was ein sehr einfaches Update impliziert).  Es bietet eine neue flexible und skalierbare Methode zur Strukturierung von Projekten, eine leistungsstarke neue Unterstützung für die Arbeit mit Parameterlisten, neue Typen für die Bereitstellung expliziter Überprüfungen, eine verbesserte JSX-Unterstützung, eine wesentlich benutzerfreundlichere Fehlerdiagnose und vieles mehr. <br><br><h2>  Was gibt's Neues? </h2><br><ul><li>  Projektverknüpfungen <br><ul><li>  <code>--build</code> </li><li>  Output Structure Management </li><li>  Zukunftspläne </li></ul></li><li>  Abrufen und Verteilen von Parameterlisten mithilfe von Tupeln </li><li>  Neue Tupeltypfunktionen </li><li>  Typ <code>unknown</code> </li><li>  Verbesserte Fehlerdiagnose und Benutzerumgebung <br><ul><li>  Zugehörige Fehlerbereiche </li><li>  Verbesserte Diagnose und Fehlerbehandlung </li></ul></li><li>  Unterstützung für die Eigenschaft <code>defaultProps</code> in JSX </li><li>  Anweisungen <code>/// &lt;reference lib="..." /&gt;</code> </li><li>  Verbesserung der Editorgeschwindigkeit <br><ul><li>  Refactoring benannter Importanweisungen </li><li>  Ende Tag Ende und Umrissrahmen </li><li>  Schnelle Korrekturen für nicht erreichbaren Code und nicht verwendete Tags </li></ul></li><li>  Kritische Veränderungen <br><ul><li>  <code>unknown</code> ist ein reservierter Typname </li><li>  API-kritische Änderungen </li></ul></li></ul><br><h2>  Projektverknüpfungen </h2><br>  Sehr oft müssen Sie zum Erstellen einer Bibliothek oder Anwendung mehrere Schritte ausführen.  Angenommen, Ihre Codebasis enthält die Verzeichnisse <code>src</code> und <code>test</code> .  Angenommen, Sie haben einen Clientordner, in dem der Code des Clientteils der Anwendung gespeichert ist, und einen Serverordner, der den Serverteilcode auf der Node.js-Plattform enthält, und jeder von ihnen nimmt einen Teil des Codes aus dem <code>shared</code> Ordner auf.  Vielleicht verwenden Sie das sogenannte „Single Repository“ und haben viele Projekte, die komplex voneinander abhängig sind. <br><br>  Eine der wichtigsten Funktionen, an denen wir bei der Veröffentlichung von TypeScript 3.0 gearbeitet haben, hieß "Projektlinks" und soll die Arbeit mit solchen Skripten vereinfachen. <br><br>  Dank Projektlinks können einige TypeScript-Projekte von anderen abhängen.  Insbesondere dürfen <code>tsconfig.json</code> Dateien auf andere <code>tsconfig.json</code> Dateien <code>tsconfig.json</code> .  Das Definieren dieser Abhängigkeiten erleichtert das Aufteilen des Codes in kleinere Projekte, da der TypeScript-Compiler (und seine Tools) die Möglichkeit erhalten, die Baugruppenreihenfolge und -struktur der Ausgabe zu verstehen.  Dies bedeutet, dass die Montage schneller und schrittweise (schrittweise) ausgeführt wird. Transparente Navigation, Bearbeitung und Umgestaltung für verschiedene Projekte werden unterstützt.  Da TypeScript 3.0 die Grundlage für das Projekt bildet und eine API bereitstellt, sollte jedes Build-Tool dies bereitstellen können. <br><br><h4>  Wie sieht es aus? </h4><br>  Hier ist eine <code>tsconfig.json</code> Datei, die als einfaches Beispiel Links zu Projekten enthält. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ./src</span></span><span class="hljs-regexp"><span class="hljs-regexp">/bar/tsconfig</span></span>.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> project references. <span class="hljs-string"><span class="hljs-string">"composite"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"declaration"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Other options... <span class="hljs-string"><span class="hljs-string">"outDir"</span></span>: <span class="hljs-string"><span class="hljs-string">"../../lib/bar"</span></span>, <span class="hljs-string"><span class="hljs-string">"strict"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"esnext"</span></span>, <span class="hljs-string"><span class="hljs-string">"moduleResolution"</span></span>: <span class="hljs-string"><span class="hljs-string">"node"</span></span>, }, <span class="hljs-string"><span class="hljs-string">"references"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"../foo"</span></span> } ] }</code> </pre> <br>  Es hat zwei neue Felder: <code>composite</code> und <code>references</code> . <br><br>  Das <code>references</code> verweist einfach auf andere <code>tsconfig.json</code> Dateien (oder die Ordner, in denen sie enthalten sind).  Jeder Link hier ist einfach ein Objekt mit einem <code>path</code> („Pfad“) und teilt dem TypeScript-Compiler mit, dass Sie zum Erstellen dieses Projekts zuerst ein anderes Projekt erstellen müssen, auf das es verweist. <br><br>  Anscheinend hat das <code>composite</code> Feld die gleiche Bedeutung.  Das <code>composite</code> Feld stellt sicher, dass bestimmte Parameter aktiviert sind, die es jedem davon abhängigen Projekt ermöglichen, darauf zu verweisen und es in inkrementelle Builds aufzunehmen.  Die Fähigkeit, intelligent und schrittweise zu erstellen, ist wichtig, da einer der Hauptgründe, warum Sie ein Projekt abbrechen können, die Erstellungsgeschwindigkeit ist. <br><br>  Wenn das <code>front-end</code> Projekt beispielsweise vom <code>shared</code> <code>shared</code> Projekt abhängt und vom Kern <code>shared</code> wird, helfen unsere APIs, die sich auf Projektverknüpfungen beziehen, Änderungen im Kern zu identifizieren, erfassen sie jedoch nur dann wieder, wenn sich die vom <code>core</code> erzeugten Typen geändert haben (d. H. <code>.d.ts</code> Dateien).  Dies bedeutet, dass eine Änderung des Kerns nicht zu einem globalen Zusammenbau aller Projekte führt.  Aus diesem Grund bewirkt das Setzen des <code>composite</code> Flags auch das Setzen des <code>declaration</code> . <br><br><h4>  - Erstellungsmodus </h4><br>  TypeScript 3.0 führt eine Reihe von APIs für Projektreferenzen ein, damit andere Tools diese schnelle inkrementelle Erstellungsmethode bereitstellen können.  Insbesondere das gulp-typescript-Plugin verwendet diese APIs bereits!  So werden spätere Links zu Projekten in die Assembly-Orchestratoren Ihrer Wahl integriert. <br><br>  Für viele einfache Anwendungen und Bibliotheken ist es jedoch ratsam, keine externen Tools zu verwenden.  Aus diesem Grund setzt der Befehl tsc jetzt ein neues Flag <code>--build</code> . <br><br>  Der <code>tsc --build</code> (oder sein Alias <code>tsc -b</code> ) nimmt eine Reihe von Projekten und erstellt sie sowie erstellte abhängige Projekte.  Wenn Sie den neuen Erstellungsmodus verwenden, muss zunächst das Flag <code>--build</code> gesetzt werden, und es kann mit einigen anderen Flags kombiniert werden: <br><ul><li>  <code>--verbose</code> : Zeigt jeden Schritt an, der für den Erstellungsprozess erforderlich ist. </li><li>  <code>--dry</code> : <code>--dry</code> ohne Ausgabedateien zu generieren (nützlich in Verbindung mit der Option <code>--verbose</code> ). </li><li>  <code>–clean</code> : <code>–clean</code> , Ausgabedateien zu löschen, die der angegebenen Eingabe entsprechen. </li><li>  <code>--force</code> : <code>--force</code> vollständige, nicht inkrementelle Erstellung des Projekts. </li></ul><br><h4>  Output Structure Management </h4><br>  Ein subtiler, aber unglaublich nützlicher Vorteil von Projektreferenzen ist die logische Fähigkeit, Eingabedateien entsprechenden Ausgabedateien zuzuordnen. <br><br>  Wenn Sie jemals versucht haben, die Client- und Serverteile der Anwendung zu trennen, können Probleme bei der Verwaltung der Ausgabestruktur auftreten. <br><br>  Wenn sich beispielsweise client / index.ts und server / index.ts für die folgenden Projekte auf shared / index.ts beziehen: <br><br><img src="https://habrastorage.org/webt/sb/wy/z4/sbwyz4hbixbmi8mnvek370pitvw.png"><br><br>  ... wenn wir dann versuchen, Client- und Serverprojekte zu erstellen, erhalten wir ... <br><br><img src="https://habrastorage.org/webt/yk/rb/ft/ykrbftrbeb_l6ca3j75g95vtdnu.png"><br><br>  …und nicht… <br><br><img src="https://habrastorage.org/webt/t3/oa/g0/t3oag0vxnflnjvvb8dqlcdgbfds.png"><br><br>  Beachten Sie, dass wir nach dem Build Kopien des freigegebenen Ordners sowohl auf dem Client als auch auf dem Server erhalten haben.  Wir haben zusätzliche Zeit für das zweimalige Erstellen der gemeinsam genutzten Assembly aufgewendet und lib / client / client und lib / server / server eine unerwünschte Verschachtelung hinzugefügt. <br><br>  Das Problem ist, dass TypeScript eifrig nach .ts-Dateien sucht und versucht, diese in diese Zusammenstellung aufzunehmen.  Im Idealfall sollte TypeScript verstanden haben, dass diese Dateien nicht an der Assembly in derselben Kompilierung teilnehmen sollten, sondern stattdessen in den .d.ts-Dateien nach Typinformationen suchen. <br><br>  Das Erstellen der Datei tsconfig.json für Shared führt genau zu diesem Ergebnis.  Es signalisiert dem TypeScript-Compiler: <br><br><ol><li>  dass das gemeinsam genutzte Projekt unabhängig erstellt werden muss </li><li>  und dass wir beim Importieren von ../shared nach .d.ts-Dateien in seinem Ausgabeverzeichnis suchen sollten. </li></ol><br>  Dadurch wird vermieden, dass eine doppelte Assembly ausgeführt wird und versehentlich alle freigegebenen Inhalte eingeschlossen werden. <br><br><h4>  Zukunftspläne </h4><br>  Um ein tieferes Verständnis der Design-Links und der Möglichkeiten ihrer Verwendung zu erhalten, lesen Sie diese im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tracker dieser Version</a> ausführlicher.  In naher Zukunft werden wir eine Dokumentation zu Projektverknüpfungen und zum Erstellungsmodus erstellen. <br><br>  Wir bemühen uns, dass Autoren anderer Programmierwerkzeuge Verweise auf Projekte beibehalten und die Bearbeitungsumgebung in Bezug auf diese Funktion weiter verbessern können.  Wir möchten sicherstellen, dass die Arbeit mit Projektverknüpfungen genauso reibungslos funktioniert wie die Entwicklung von Code mit einer einzigen tsconfig.json-Datei.  Wenn Sie irgendwann Projektlinks verwenden, sind wir für jedes Feedback dankbar. <br><br><h2>  Abrufen und Verteilen von Parameterlisten mithilfe von Tupeln </h2><br>  Wir halten dies oft für selbstverständlich, aber mit JavaScript können wir Parameterlisten als erstklassige Werte betrachten - entweder mit Argumenten oder mit Parametern vom Typ rest (z. B. ... rest). <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Beachten Sie, dass der Aufruf für Funktionen mit einer beliebigen Anzahl von Parametern funktioniert.  Im Gegensatz zu anderen Sprachen zwingt uns JavaScript nicht, call0, call1, call2 usw. wie folgt zu definieren: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>1); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1, param2)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>1, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1, param2, param3)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>1, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>2, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>3); }</code> </pre> <br>  Leider gab es für einige Zeit keine gute Möglichkeit, dies in TypeScript auszudrücken, ohne eine endliche Anzahl von Überladungen zu deklarieren: <br><br><pre> <code class="hljs powershell">// TODO (billg): <span class="hljs-number"><span class="hljs-number">5</span></span> overloads should *probably* be enough <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> anybody? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T4</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2, param3: T3, param4: T4)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param3</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param4</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T4</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2, param3: T3)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param3</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: ()</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">param1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: any[])</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[])</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Puh!  Ein weiterer Tod mit tausend Überladungen!  Oder mindestens so viele Überlastungen, wie Benutzer benötigen. <br><br>  Mit TypeScript 3.0 können Sie solche Szenarien besser simulieren, da jetzt Parameter des Resttyps universell sein können und ihr Typ als Tupel definiert ist.  Anstatt jede dieser Überladungen zu deklarieren, sollten wir den Restparameter ... args aus der Funktion fn als Typparameter verwenden, der das Array erweitert, und ihn dann für den Parameter ... args wiederverwenden, den die Aufruffunktion übergibt: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[], </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: TS)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Wenn wir die Aufruffunktion aufrufen, versucht TypeScript, eine Liste von Parametern aus dem, was wir an fn übergeben, zu extrahieren und in ein Tupel umzuwandeln: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: number, y: string)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + y).toLowerCase(); } // The `TS` type <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> is inferred as `[number, string]` call(foo, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br>  Wenn TypeScript TS als [Nummer, Zeichenfolge] definiert und wir die Wiederverwendung von TS für den Restparameter der Aufruffunktion beenden, sieht die Funktionsinstanz folgendermaßen aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: [number, string])</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">]): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br>  Und in TypeScript 3.0 wird der Parameter bei Verwendung eines Tupels in Ruhe auf den Rest der Parameterliste minimiert!  Die obige Instanz besteht aus einfachen Parametern ohne Tupel: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (arg1: number, arg2: string)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arg1</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arg2</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br>  Zusätzlich zum Abfangen von Typkonvertierungsfehlern beim Übergeben ungültiger Argumente: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[], </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: TS)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); } call((x: number, y: string) =&gt; y, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>); // ~~~~~~~ // Error! `string` isn<span class="hljs-string"><span class="hljs-string">'t assignable to `number`!</span></span></code> </pre> <br>  ... und Typdefinition aus anderen Argumenten: <br><br><pre> <code class="hljs ruby">call((x, y) =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">/* .... */</span></span> }, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ^ ^ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">`x`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`y`</span></span> have their types inferred as <span class="hljs-string"><span class="hljs-string">`string`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`number`</span></span> respectively.</code> </pre> <br>  ... wir können auch die Tupeltypen sehen, die diese Funktionen von außen definieren: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tuple</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[]&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...xs: TS)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xs; } let x = tuple(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); // has type `[number, number, string]`</code> </pre> <br>  Aber achten Sie auf eine Einschränkung.  Um all diese Arbeit zu erledigen, mussten wir die Fähigkeiten von Tupeln erweitern ... <br><br><h4>  Neue Tupeltypfunktionen </h4><br>  Um die Parameterliste als Tupel zu modellieren (wie wir gerade besprochen haben), mussten wir die Tupeltypen ein wenig überdenken.  Vor der Veröffentlichung von TypeScript 3.0 war die Reihenfolge und Länge des Parametersatzes das Beste, was mit Tupeln modelliert werden konnte. <br><br>  Parameterlisten sind jedoch nicht nur geordnete Typlisten.  Beispielsweise können die Parameter am Ende optional sein: <br><br><pre> <code class="hljs powershell">// Both `y` and `z` are optional here. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: boolean, y = 100, z?: string)</span></span></span></span> { // ... } foo(true); foo(true, undefined, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); foo(true, <span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br>  Der letzte Parameter kann ein Ruheparameter sein. <br><br><pre> <code class="hljs powershell">// `rest` accepts any number of strings - even none! <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...rest: string[])</span></span></span></span> { // ... } foo(); foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>);</code> </pre> <br>  Und schließlich gibt es eine ziemlich interessante Eigenschaft von Parameterlisten - sie können leer sein: <br><br><pre> <code class="hljs powershell">// Accepts no parameters. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { // ... } foo();</code> </pre> <br>  Damit die Tupel den Parameterlisten entsprechen, mussten wir daher jedes dieser Szenarien simulieren. <br><br>  Erstens kann es jetzt am Ende des Tupels optionale Elemente geben: <br><br><pre> <code class="hljs powershell">/** * <span class="hljs-number"><span class="hljs-number">2</span></span>D, or potentially <span class="hljs-number"><span class="hljs-number">3</span></span>D, coordinate. */ type Coordinate = [<span class="hljs-type"><span class="hljs-type">number</span></span>, <span class="hljs-type"><span class="hljs-type">number</span></span>, <span class="hljs-type"><span class="hljs-type">number</span></span>?];</code> </pre> <br>  Der Koordinatentyp erstellt ein Tupel mit einer optionalen Eigenschaft namens 2 - ein Element mit Index 2 ist möglicherweise nicht definiert!  Interessanterweise ist die Längeneigenschaft des Coodinate-Tupels vom Typ 2 |, da Tupel für ihre Längeneigenschaft einen numerischen Literaltyp verwenden  3. <br><br>  Zweitens kann das Restelement jetzt am Ende des Tupels vorhanden sein. <br><br><pre> <code class="hljs powershell">type OneNumberAndSomeStrings = [<span class="hljs-type"><span class="hljs-type">number</span></span>, <span class="hljs-type"><span class="hljs-type">...string</span></span>[]];</code> </pre> <br>  Dank der restlichen Elemente zeigen Tupel ein sehr interessantes Verhalten „unbegrenzt vom Ende“.  Für das obige Beispiel vom Typ OneNumberAndSomeStrings muss der Typ seiner ersten Eigenschaft number sein, und eine oder mehrere Eigenschaften vom Typ string sind zulässig.  Wenn Sie diesen Tupeltyp mit einer beliebigen Nummer nummerieren, wird die Typzeichenfolge | zurückgegeben  Nummer, weil der Indexwert unbekannt ist.  In ähnlicher Weise ist der Wert der Eigenschaft length einfach number, da die Länge des Tupels unbekannt ist. <br><br>  Es ist zu beachten, dass in Abwesenheit anderer Elemente das Restelement im Tupel mit sich selbst identisch ist: <br><br><pre> <code class="hljs powershell">type Foo = [<span class="hljs-type"><span class="hljs-type">...number</span></span>[]]; // Equivalent to `number[]`.</code> </pre> <br>  Endlich können Tupel jetzt leer sein!  Obwohl dies bei Verwendung außerhalb von Parameterlisten nicht sehr nützlich ist, kann ein leerer Tupeltyp wie folgt definiert werden: []: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyTuple</span></span></span><span class="hljs-class"> </span></span>= [];</code> </pre> <br>  Wie zu erwarten ist, hat ein leeres Tupel die Länge-Eigenschaft 0, und die Indizierung mit Zahl gibt den Typ nie zurück. <br><br><h2>  Verbesserte Fehlerdiagnose und Benutzerumgebung </h2><br>  Im Laufe der Zeit erhalten wir immer mehr Anfragen von Mitgliedern unserer Community bezüglich der Verbesserung von Fehlermeldungen.  Obwohl diese Arbeit noch lange nicht abgeschlossen ist, haben wir von Ihnen gehört und eine Reihe von Verbesserungen an der TypeScript 3.0-Version vorgenommen. <br><br><h4>  Zugehörige Fehlerbereiche </h4><br>  Zum Teil besteht das Ziel einer guten Fehlermeldung darin, dem Benutzer anzuzeigen, wie sie korrigiert werden soll, oder zunächst klar zu machen, warum diese Meldung angezeigt wird.  In den meisten Fällen enthält es viele Informationen oder gibt mehrere Gründe für sein Auftreten an.  Aus einer Analyse dieser Gründe können wir schließen, dass Fehler aus verschiedenen Teilen des Codes resultieren. <br><br>  Zugehörige Fehlerbereiche sind eine neue Möglichkeit, diese Informationen Benutzern bereitzustellen.  In TypeScript 3.0 können Fehlermeldungen an anderer Stelle im Code Meldungen generieren, damit Benutzer die Ursache und Wirkung des Fehlers herausfinden können. <br><br><img src="https://habrastorage.org/webt/ha/-n/h4/ha-nh4ttnfnexzsg-rj47jiu7cu.png"><br><br>  In gewissem Sinne können verwandte Fehlermeldungen dem Benutzer nicht nur eine Erklärung geben, sondern auch den Pfad zu dem Ort angeben, an dem alles schief gelaufen ist. <br><br><img src="https://habrastorage.org/webt/bf/sg/ws/bfsgws4xoje8i7_mxqpoari_wfw.png"><br><br>  Diese Intervalle werden auch im Terminalmodus angezeigt, wenn Sie den Befehl tsc mit aktiviertem --pretty-Modus ausführen. Wir arbeiten jedoch noch an der Verbesserung der Benutzeroberfläche und berücksichtigen Ihr Feedback! <br><br><h4>  Verbesserte Diagnose und Fehlerbehandlung </h4><br>  Bei der Vorbereitung der Veröffentlichung von TypeScript 2.9 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">begonnen,</a> Fehlermeldungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr Aufmerksamkeit</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schenken</a> , und in Version 3.0 haben wir wirklich versucht, die Hauptaufgaben zu lösen, die es uns ermöglichen würden, eine intelligente, klare und genaue Fehlerdiagnose durchzuführen.  Dies umfasst insbesondere die Auswahl geeigneter Typen bei Inkonsistenzen bei den Zuordnungstypen und den direkten Übergang zur Fehlerquelle für bestimmte Nachrichtentypen. <br><br>  Wir glauben, dass unsere Bemühungen gerechtfertigt waren, und als Ergebnis erhalten Sie kürzere und klarere Fehlermeldungen. <br><br><img src="https://habrastorage.org/webt/rn/fj/1a/rnfj1aowq5j-myv-1qjvdeowpui.png"><br><br><img src="https://habrastorage.org/webt/5l/tk/zu/5ltkzun56pppzlksb88k_zapume.png"><br><br><h2>  Typ unbekannt </h2><br>  Der Typ any ist ein beliebiger Typ in TypeScript, der für alles geeignet ist.  Da es die Typen aller möglichen Werte abdeckt, werden wir nicht gezwungen, Überprüfungen durchzuführen, bevor wir versuchen, ihre Eigenschaften aufzurufen, zu konstruieren oder darauf zuzugreifen.  Außerdem können Sie Variablen, die Werte eines anderen Typs erwarten, Werte vom Typ any zuweisen. <br><br>  Diese Funktion ist im Allgemeinen nützlich, kann jedoch keine ausreichende Genauigkeit bieten. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> foo: any = <span class="hljs-number"><span class="hljs-number">10</span></span>; // <span class="hljs-type"><span class="hljs-type">All</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> these will throw errors, but <span class="hljs-type"><span class="hljs-type">TypeScript</span></span> // won't complain since `foo` has the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `any`. foo.x.prop; foo.y.prop; foo.z.prop; foo(); new foo(); upperCase(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">); foo `hello world!`; function upperCase(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toUpperCase</span></span></span><span class="hljs-class">(); }</span></span></code> </pre> <br>  Manchmal möchten Sie in TypeScript einen Typ beschreiben, der für nichts geeignet ist.  Dies ist nützlich für eine API, die signalisieren möchte: "Es kann ein beliebiger Wert sein, daher müssen Sie vor der Verwendung einige Überprüfungen durchführen."  Und Benutzer sind aus Sicherheitsgründen gezwungen, Rückgabewerte zu analysieren. <br><br>  TypeScript 3.0 führt einen neuen Typ namens unknown ein, der genau das tut.  Wie bei jedem Typ wird dem unbekannten Typ ein beliebiger Wert zugewiesen. Im Gegensatz zu jedem anderen Typ kann der unbekannte Typ jedoch ohne Typanweisung fast keinem anderen Typ zugewiesen werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können weder auf Objekte unbekannten Typs zugreifen noch sie aufrufen oder konstruieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie im obigen Beispiel unbekannt durch eines ersetzen, führt alle Fälle der Verwendung des foo-Objekts zu einem Fehler:</font></font><br><br><pre> <code class="hljs powershell">let foo: unknown = <span class="hljs-number"><span class="hljs-number">10</span></span>; // Since `foo` has type `unknown`, TypeScript // errors on each of these locations. foo.x.prop; foo.y.prop; foo.z.prop; foo(); new foo(); upperCase(foo); foo `hello world!`; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upperCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.toUpperCase(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stattdessen müssen wir entweder eine Validierung durchführen oder eine Typzusicherung verwenden und das Typüberprüfungssystem davon überzeugen, dass wir besser wissen, was zu tun ist. </font></font><br><br><pre> <code class="hljs lua">let foo: unknown = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasXYZ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: any)</span></span></span></span>: obj is { x: any, y: any, z: any } { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!obj &amp;&amp; typeof obj === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj &amp;&amp; <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj &amp;&amp; <span class="hljs-string"><span class="hljs-string">"z"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj } // Using a user-defined <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> guard... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasXYZ(foo)) { // ...we<span class="hljs-string"><span class="hljs-string">'re allowed to access certain properties again. foo.x.prop; foo.y.prop; foo.z.prop; } // We can also just convince TypeScript we know what we'</span></span>re doing // by using a <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> assertion. upperCase(foo as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upperCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.toUpperCase(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Wenn Sie einen Typ wie {} | verwenden, um ein ähnliches Verhalten zu erzielen </font><font style="vertical-align: inherit;">null | </font><font style="vertical-align: inherit;">undefiniert verhält sich der unbekannte Typ in Konstruktionen wie bedingten Typen normalerweise wünschenswerter, da sich bedingte Typen auf Vereinigungstypen erstrecken:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Arrayify&lt;T&gt; = T extends <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; : never; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A = Arrayify&lt;{} | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> | undefined&gt;; // <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>[] | undefined[] | {}[] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> B = Arrayify&lt;<span class="hljs-type"><span class="hljs-type">unknown</span></span>&gt;; // <span class="hljs-type"><span class="hljs-type">unknown</span></span>[]</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterstützung für defaultProps in JSX </font></font></h2><br> <i> :  .d.ts  React    , ,     .</i> <br><br>   -     TypeScript/JavaScript   ,   ,         .           ,     .       ,      . <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> loudlyGreet(name = <span class="hljs-string"><span class="hljs-string">"world"</span></span>) { // Thanks to the default initializer, <span class="hljs-string"><span class="hljs-string">`name`</span></span> will always have <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">`string`</span></span> internally. // We don't have to check <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">`undefined`</span></span> here. console.log(<span class="hljs-string"><span class="hljs-string">"HELLO"</span></span>, name.toUpperCase()); } // Externally, <span class="hljs-string"><span class="hljs-string">`name`</span></span> is optional, and we can potentially pass <span class="hljs-string"><span class="hljs-string">`undefined`</span></span> or omit it entirely. loudlyGreet(); loudlyGreet(undefined);</code> </pre> <br>   React         (props).        React  ,  defaultProps,      props. <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> non-TypeScript JSX file <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react-dom"; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Greet extends React.Component { render() { const { <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;Hello ${<span class="hljs-type"><span class="hljs-type">name</span></span>.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { <span class="hljs-type"><span class="hljs-type">name</span></span>: "world", }; } // <span class="hljs-keyword"><span class="hljs-keyword">Notice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> `<span class="hljs-type"><span class="hljs-type">name</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> was specified! // vvvvvvvvv const result = ReactDOM.renderToString(&lt;Greet /&gt;); console.log(result);</code> </pre> <br>  ,   &lt;Greet /&gt;    name.    Greet,  name    «world»,    : Hello world!. <br><br>  , TypeScript  ,  defaultProps  -    JSX.                render: <br><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">Props</span></span> { name?: string } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;Props&gt;</span></span></span><span class="hljs-class"> </span></span>{ render() { const { name } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-comment"><span class="hljs-comment">// Notice the `!` ------v return &lt;div&gt;Hello ${name!.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { name: "world"} }</span></span></code> </pre> <br>      ,       . <br><br>    TypeScript 3.0        JSX,  LibraryManagedAttributes.    ,     ,   TypeScript,     JSX.  ,    ,      React  defaultProps ,   ,  propTypes. <br><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">Props</span></span> { name: string } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;Props&gt;</span></span></span><span class="hljs-class"> </span></span>{ render() { const { name } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;<span class="hljs-type"><span class="hljs-type">Hello</span></span> ${name.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { name: <span class="hljs-string"><span class="hljs-string">"world"</span></span>} } <span class="hljs-comment"><span class="hljs-comment">// Type-checks! No type assertions needed! let el = &lt;Greet /&gt;</span></span></code> </pre> <br>   ,   .  defaultProps,         Partial ,  -   (stateless function components, SFC),   defaultProps   Partial ,    .           defaultProps    (.  )       SFC   ES2015: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"world"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }: Props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello ${name.toUpperCase()}!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; }</code> </pre> <br>  ,   .      TypeScript,   .d.ts   DefinitelyTyped      ,  ,  @types/react     .          DefinitelyTyped,        . <br><br><h2>  /// &lt;reference lib="..." /&gt; </h2><br>   ,     ,   ,   (polyfills) — ,     API    ,      ( .d.ts),        API.   ,               TypeScript  lib.d.ts      ,   --lib  --target. ,    core-js       lib.es2015.d.ts. <br><br>     TypeScript 3.0 ,      API,   ,     : /// &lt;reference lib="..." /&gt;. <br><br> ,    Promise  ES2015      <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;reference lib="es2015.promise" /&gt;</span></span></span><span class="hljs-comment"> export {};</span></span></code> </pre> <br>    ,    TypeScript 3.0    ,      lib.es2015.promise.d.ts,    ,  Promise . <br><br><h4>      </h4><br> ,      ,  TypeScript  ,          .        TypeScript  JavaScript   ,   Visual Studio, Visual Studio Code        TypeScript.   ,    ,    ,  Go to Definition («  »)       . TypeScript 3.0    . <br><br><h4>     </h4><br>       ,    ,  . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dependency <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "./dependency"; // look at <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> this repetition! dependency.foo(); dependency.bar(); dependency.baz();</code> </pre> <br>   ,       ,   ,          ,   . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { foo, bar, baz } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./dependency"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// way lower in the file... foo(); bar(); baz();</span></span></code> </pre> <br>   ,      ,      . TypeScript 3.0   ,       . <br><br><img src="https://habrastorage.org/webt/-z/t2/fg/-zt2fg-ailzlgreoxw8jonn_b8m.png"><br><br><h4>        </h4><br>    TypeScript    ,      JSX: <br><br><ul><li>    JSX; </li><li>       JSX. </li></ul><br><img src="https://habrastorage.org/webt/6d/gv/nr/6dgvnrwu7ivqadbw5yillk1kroo.png"><br><br><h4>         </h4><br> TypeScript      —   ,    . <br><br><h2>   </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> API</a> . <br><br>  ,   TypeScript 3    ,    .       ,       API     . <br><br><h4> unknown —    </h4><br>  unknown —   ,        ,   ,    . <br><br><h4>    API </h4><br><ul><li>    LanguageService#getSourceFile  ,        . . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">#24540</a> . </li><li>   TypeChecker#getSymbolDisplayBuilder       . . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">#25331</a> .     emitter ( )  node builder. </li><li>   escapeIdentifier  unescapeIdentifier  .     API   ,        .   ,       ,      .           escapeLeadingUnderscores  unescapeLeadingUnderscores,     ,    (      «»  __String  string   ). </li><li>  TypeChecker#getSuggestionForNonexistentProperty, TypeChecker#getSuggestionForNonexistentSymbol  TypeChecker#getSuggestionForNonexistentModule  ,         API. . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">#25520</a> . </li></ul><br><h2>  Perspektiven </h2><br>    TypeScript  .     ,        ,  ,  DefinitelyTyped   ,       .     ,            . <br><br>           ,         TypeScript ( ,   ).       ,   ,           JavaScript.      ,      TypeScript,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ,      ,     ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Twitter</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> .     . <br><br> ,          TypeScript, !         .    ,  ,       TypeScript   ,  . <br><br>   ! <br>  TypeScript </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420761/">https://habr.com/ru/post/de420761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420739/index.html">Die Box ist noch im Griff: Warum müssen Sie 2018 noch selbst Sprachen lernen?</a></li>
<li><a href="../de420741/index.html">Spickzettel für Programmierer oder "Wir werden für Sie googeln"</a></li>
<li><a href="../de420749/index.html">GitLab für Continuous Delivery-Projekt auf InterSystems Technologies: Container</a></li>
<li><a href="../de420753/index.html">Microservice Frontend - ein moderner Ansatz zur Trennung der Front</a></li>
<li><a href="../de420757/index.html">Programmierwettbewerb: Handel (Ergebnisse)</a></li>
<li><a href="../de420763/index.html">KDD 2018, zweiter Tag, Workshops</a></li>
<li><a href="../de420765/index.html">Impressionen des Gemini PDA. Pocket Dual-Boot Harvester oder nutzloses Spielzeug?</a></li>
<li><a href="../de420767/index.html">Rostelecom verlangt, dass Sputnik für bankrott erklärt wird</a></li>
<li><a href="../de420769/index.html">Looking.House - mehr als 150 Spiegel auf einer Website</a></li>
<li><a href="../de420775/index.html">Eigenes Spiel in 72 Stunden: Rechen, Krücken und Alpakas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>