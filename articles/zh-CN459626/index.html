<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏽 🤽🏽 📯 Windows通知工具：记录最薄的攻击面 🧑🏽‍🤝‍🧑🏼 👣 🙍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="切下的是Alex Ionescu和Gabrielle Viala在BlackHat 2018大会上 发表的演讲 “ Windows通知功能：迄今为止最无证的内核攻击面”的翻译。 

 出版物将讨论什么 

- 什么是Windows通知功能（WNF） 
- 为什么出现WNF 
- 州名WNF 
- 使...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows通知工具：记录最薄的攻击面</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p> 切下的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alex Ionescu</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gabrielle Viala</a>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BlackHat 2018大会上</a> <strong>发表的演讲</strong> “ Windows通知功能：迄今为止最无证的内核攻击面”的翻译。 <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">出版物将讨论什么</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是Windows通知功能（WNF）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么出现WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">州名WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用WNF的系统调用</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级用户模式API（ntdll）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级内核级API（Ex）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WNF分析实用程序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WNF攻击面</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有趣且敏感的WNF状态名称</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用WNF进行过程注入</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进一步研究的方向</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf"> 什么是Windows通知功能（WNF） </h3><br><p>  Windows Notification Facility是一种通知机制（在内核和用户模式下均可用），它建立在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布者－订阅者</a>模型（ <em>pubsub</em> ，Publisher / Subscriber）上。 该机制已在Windows 8中添加：部分是为了解决OS中一些长期存在的设计限制，但它也应该作为实现类似于iOS / Android的推送通知的基础。 </p><br><p> 它的关键特征是它是一种<em>盲目</em> （大多数情况下没有注册）的模型，允许无序订阅和发布。 这意味着消费者甚至可以在通知由其来源发布之前就订阅该通知。 而且，生成事件的人不需要事先“注册”通知。 </p><br><p> 另外，该机制支持： </p><br><ul><li> 永久和临时通知 </li><li> 单调增加的唯一标识符 </li><li> 每个事件的有效负载缓冲区（最大4 KB） </li><li> 具有基于组的序列化的线程池通知模型 </li><li> 基于范围的安全模型，该模型通过标准<abbr title="自由访问控制列表">DACL</abbr> / <abbr title="系统访问控制列表">SACL</abbr>机制实现安全描述符 </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf"> 为什么出现WNF </h3><br><p> 考虑一个典型的例子：有一个驱动程序想知道已经连接了具有读写访问权限的卷。 为了通知您，Autochk（在Windows上类似于<abbr title="文件系统一致性检查">fsck</abbr> ）报告一个称为VolumesSafeForWriteAccess的事件。 但是为了报告事件，您必须首先创建事件对象本身。 </p><br><p> 我们还需要知道Autochk已经在处理该卷，但是尚未发出我们正在等待的事件的信号。 糟糕的解决方案：与sleep（）一起循环，检查事件的存在以及创建事件的时间-等待它。 </p><br><p> 但是退出Windows应用程序后，其所有描述符都将关闭。 并且当对象没有描述符时，它将被销毁。 那么谁来举办这个活动呢？ </p><br><p> 如果没有WNF，解决方案是让OS内核在加载任何驱动程序之前生成一个事件，并让Autochk像使用者一样打开它，但是它应该发信号通知该事件，而不是等待。 </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf"> 州名WNF </h3><br><p> 在WNF世界中，州名是64位数字。 但是有一个窍门-实际上这是一个编码结构。 状态名称具有<em>版本</em> ， <em>生存期</em> ， <em>范围</em> ， <em>数据持久性标志</em>和<em>唯一的序列号</em> 。 </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p> 但是只有当我们对一个带有魔术常数的64位数字进行XOR运算时，此数据才可用： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya"> 状态名称的生存期 </h4><br><p>  WNF状态名称可以是（WNF_STATE_NAME_LIFETIME）： </p><br><ul><li> 知名的 </li><li> 永久的 </li><li> 持久的 </li><li> 暂时的 </li></ul><br><p> 前三个与注册表中相应的项相关联，注册表中将存储状态信息： </p><br><ul><li>  HKLM \ SYSTEM \ CURRENTCONTROLSET \ CONTROL \通知中居住着知名的名字 </li><li> 永久名称存在于HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notifications中 </li><li> 永久名称存在于HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications中 </li></ul><br><p> 知名名称有其独特之处：无法注册。 在系统引导时，这样的名称应该已经出现在注册表中。 持久名称和持久名称需要包含的SeCreatePermanentPrivilege特权（像其他全局对象一样）才能创建它们。 永久名称不存在于注册服务商流程中，而永久名称在系统重新启动后仍然存在。 </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh"> 数据范围 </h4><br><p> 数据范围定义了WNF状态名称周围的第一个安全边界；它确定了谁可以看到它并可以访问它。 状态名称的范围可以是： </p><br><ul><li> 系统 </li><li> 汽车 </li><li> 用户会话 </li><li> 用户 </li><li> 过程 </li></ul><br><p> 除了提供安全边界，WNF范围还可用于为同一名称提供不同的数据实例。 内核（与其他安全机制一样）绕过状态访问检查。  TCB特权允许跨范围访问WNF状态名称。 </p><br><p> 范围“系统”和范围“机器”是全局范围。 它们没有自己的标识符（它们使用不同的全局容器）。 用户会话的范围使用会话标识符（会话ID）作为ID。 特定用户的范围使用该用户的SID作为标识符。  EPROCESS对象的地址是过程范围的标识符。 </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers"> 序列号 </h4><br><p> 为了确保唯一性，每个状态名称都有一个唯一的51位序列号。 众所周知的名称在其序列号中包含一个4个字符的家庭标签，其余的21位用作唯一标识符。 永久名称使用注册表值“ SequenceNumber”存储其递增编号。 持久名称和临时名称使用公共增量计数器，该计数器位于全局变量中。 此数据是针对每个容器（每个仓库）分别存储和处理的，可在PspHostSiloGlobals-&gt; WnfSiloState中获得。 </p><br><p> 在Microsoft内部，每个WNF名称都有一个在代码中使用的“友好”标识符，有时它以相同的名称存储在全局命名空间中。 例如，符号nt！WNF_BOOT_DIRTY_SHUTDOWN，其值为0x1589012fa3bc0875。 与魔常数<abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY</abbr>进行XOR之后，我们得到的值为0x544f4f4200000801，可以按位解释为： </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf"> 使用WNF的系统调用 </h3><br><p> 内核系统调用使您可以注册和删除WNF状态名称，发布和接收WNF状态名称数据，还可以接收来自WNF的各种通知。 </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf"> 注册WNF状态名称 </h4><br><p> 除了众所周知的名称（如前所述）外，可以在操作系统运行时注册WNF状态名称： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p> 有一个对称的系统调用ZwDeleteWnfStateName，您可以使用它删除已注册的状态名（同样，众所周知的名称除外）。 </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf"> 发布WNF状态数据 </h4><br><p> 要设置或更改WNF状态名称数据，可以使用ZwUpdateWnfStateData系统调用： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p> 有一个对称系统调用ZwDeleteWnfStateData来删除（清除）WNF状态名称的数据。 </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf"> 获取WNF状态数据 </h4><br><p> 为了请求WNF状态名称数据，可以使用以下系统调用（大多数参数类似于Update函数）： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p> 真正的优势在于，Update和Query API函数实际上不需要<u>注册的</u> WNF状态名称。 如果名称不是临时的（并且调用代码具有足够的特权），则可以实时注册名称实例！ </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  WNF通知 </h4><br><p> 到目前为止，我们已经假定用户知道何时调用数据获取功能。 但是，也存在<em>阻止阅读的功能</em> ，该功能可以使用通知系统（更接近真正的发布者-订阅者模型）来工作。 </p><br><p> 首先，进程必须通过调用ZwSetWnfProcessNotificationEvent函数来注册事件。 然后，您需要调用ZwSubscribeWnfStateChange函数，并指定事件掩码以获取输出上的订阅标识符。 事件可以有两种类型： </p><br><ul><li> 数据通知： <br><ul><li>  0x01-数据外观 </li><li>  0x10-名称破坏 </li></ul></li><li> 元元符号 <br><ul><li>  0x02-接收数据通知的订户的外观（数据订户） </li><li>  0x04-接收元通知的订户的外观（元订户） </li><li>  0x08-接收数据通知和元通知的订户的外观（通用订户） </li></ul></li></ul><br><p> 然后，您需要等待记录的事件。 并且每次事件变为信号时，您都需要调用ZwGetCompleteWnfStateSubscription函数，该函数返回WNF_DELIVERY_DESCRIPTOR。 </p><br><p> 但是这些低级API函数有一个问题（感谢Gabi对其进行调查）：每个进程只能有一个注册事件。 </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll"> 高级用户模式API（ntdll） </h3><br><p> 当涉及到通知时，事情变得很复杂，因此ntdll.dll的rtl层提供了一个更简单的接口： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p> 实际上，不需要直接调用系统服务：只需使用单个ntdll.dll驱动的事件队列。 </p><br><p> 在后台，WNF_DELIVERY_DESCRIPTOR的内容被转换为回调参数： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p> 对于每个新订阅，都会创建一个条目，并将其放置在全局变量RtlpWnfProcessSubscriptions指向的列表中。 该列表建立在字段WNF_NAME_SUBSCRIPTION之一（类型为LIST_ENTRY）上。 每个WNF_NAME_SUBSCRIPTION依次具有另一个LIST_ENTRY字段，用于组织带有回调和上下文的WNF_USER_SUBSCRIPTION列表。 </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex"> 高级内核级API（Ex） </h3><br><p>  WNF还为内核模式代码（可以从驱动程序使用）提供几乎相同的功能：通过导出的系统调用和运行时（Ex-layer）中的高级API函数。 </p><br><p>  ExSubscribeWnfStateChange函数接受状态名称，类型掩码和回调函数+上下文的地址作为输入，并返回订阅描述符。 回调函数接收目标名称，事件掩码，更改标签，但不接收缓冲区或其大小。 </p><br><p>  ExQueryWnfStateData函数基于传递的订阅描述符，读取当前状态数据。 实际上，每个回调最终都会调用ExQueryWnfStateData函数来获取与通知关联的数据。 </p><br><p> 对于内核模式订阅和用户模式订阅，WNF（用于跟踪订阅）都会创建WNF_SUBSCRIPTION结构的实例。 但是对于用户模式，某些字段将不会填写，例如Callback和Context，因为对于用户模式，处理程序的地址由ntdll.dll存储和处理。 </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  WNF数据结构 </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>来自翻译者</em></u> ：请参阅下一节。 </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  WNF分析实用程序 </h3><br><p>  <u><em>译者的话</em></u> ：这里值得再次回忆一下，演讲不仅是由Alex主持的，而且是由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gabrielle Viala</a>主持的。 特别是，其作者权属于下面描述的WnfCom模块。 此外，Gabrielle还充分详细地描述了WNF的内部结构（请参阅上一节中的插图）。 不幸的是，它的大多数幻灯片都不在演示文稿的pdf中（指示为原始）或仅由标题指示。 但是： </p><br><ul><li> 这是观看他们的联合性能记录的绝佳时机： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows通知功能：剥去最多未记载的内核攻击面的洋葱</a> （Gabrielle的开端〜19：27）。 除了数据结构之外，还有一个关于它们如何修复调试器扩展的故事！Wnf（扰流器-使用NT Insider中的方法- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修复损坏的调试器扩展</a> ） </li><li>  Gabrielle有另一篇好文章（详细内容，而不是作为演示文稿）- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用Windows Notification Facility（WNF）</a> ，也强烈建议阅读该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ，以供所有感兴趣的读者阅读。 </li></ul><br><p>  <u><em>并从翻译者那里</em></u> ：如果有人想用Gabrielle幻灯片的内容来补充当前的翻译，或者从演讲视频的任何部分扩展速记翻译，欢迎您。 为了方便添加/更改大块，我可以在github（或其他版本控制服务器）上发布翻译源。 </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom是一个Python模块（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github源代码</a> ），它显示了通过WNF的互操作性。 主要特点： </p><br><ul><li> 允许您从现有实例实例读取/写入数据 </li><li> 允许您创建临时状态名称（作为<em>服务器</em> ） </li><li> 允许您获取<em>客户</em>端对象的实例，该实例将处理有关更改名称的特定实例的通知 </li></ul><br><p> 用法示例： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump是用C编写的命令行实用程序。可执行文件可以通过选择所需位深度的子目录在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/ionescu007/wnfun中</a>找到。 该实用程序可用于搜索有关WNF状态名称的信息： </p><br><ul><li>  -d（转储）使用基于注册表的枚举转储所有WNF状态名称。 可以补充以下选项： <br><ul><li>  -v（ <u>V</u> erbose）详细输出，其中包括WNF状态数据的十六进制转储； </li><li>  -s（安全性）安全描述符-WNF状态名称的权限的SDDL字符串。 </li></ul></li><li>  -b（暴力）直接枚举临时WNF状态名称（有关此内容，请参见下文） </li><li>  -i（信息）显示有关单个指定的WNF状态名称的信息 </li><li>  -r（ <u>R</u> ead）从指定的WNF状态名称读取数据 </li><li>  -w（ <u>W</u> rite）将数据写入指定的WNF状态名称 </li><li>  -n（注意）为指定的WNF状态名称注册通知订户（以下将是Edge的更特定用例） </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  WNF攻击面 </h3><br><p> 本节（更确切地说是其子节）将讨论可能的攻击和有趣的敏感WNF数据。 </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh"> 特权数据披露 </h4><br><p> 读取系统中存在的数千个WNF状态名称，有几种，其中的数据看起来非常有趣。 其中一些数据可疑类似于指针或其他特权数据。 </p><br><p> 在多台机器上玩了之后，在某些情况下，可能会发现一堆，堆栈和其他特权信息，这些信息在特权边界之间公开。 错误/漏洞报告已于7月提交给MSRC，但在11月（演示后）已得到纠正。 例如：通过WNF_AUDC *事件泄漏了4 KB的堆栈！ </p><br><p> 主要问题与我们从j00ro，taviso等人的先前研究中看到的相同。 某些WNF状态名称包含带有各种填充和/或对齐问题的编码数据结构。 在某些情况下，未初始化的内存泄漏。 <br>  <u><em>从译者</em></u> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">那里：该文档的引言部分</a> <u><em>的翻译</em></u> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mateusz Jurczyk aka j00ro的x86仿真和污点跟踪检测内核内存泄露</a> 。 </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy"> 发现状态名称和权限 </h4><br><p> 第一种方法是发现所有可能被恶意操纵的状态名称。 对于知名的，永久的和永久的名称，可以通过枚举注册表项来枚举。 然后可以将找到的值与友好的标识符进行比较（可以在几个地方找到它们：） </p><br><p> 然后，我们还可以查看注册表中的安全描述符（这是数据缓冲区中的第一件事）。 安全描述符不是规范的：它没有所有者和组，因此在技术上无效。 但是用假的所有者和组来<em>修复</em>安全描述符没有问题。 </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy"> 检测临时状态名称及其权限 </h4><br><p> 但是使用临时名称，上述技巧将不起作用：它们不在注册表中。 而且只有内核将它们的数据结构（！Wnf）存储在内存中。 但是临时名称实际上并不难被强行使用： </p><br><ul><li> 版本总是很重要1 </li><li> 生命总是很重要WnfTemporaryStateName </li><li> 永久标记始终被清除（临时状态名称不能包含永久数据） </li><li> 范围（范围）可以采用4个值之一 </li></ul><br><p> 是的，但是剩余的序列号是51位！ 确实……但不要忘记序列号是单调增长的。 对于临时名称，该序列在每次引导时都会重置为0。 通常，您可以使用一百万个序列号的窗口：在循环中，通过使用请求的信息类WnfInfoStateNameExist调用ZwQueryWnfStateNameInformation来检查每个名称的存在（从0开始）（假设访问错误也表明存在名称）。 如果不存在另外一百万个名称，则可以停止搜索。 </p><br><p> 临时名称安全描述符（像其他临时名称数据一样）存储在内核中。 因此，请求它们的唯一方法是调试内核模式时的！Wnf扩展名。 但是我们可以： </p><br><ul><li> 在尝试读取数据时得出有关读取权限的结论。 </li><li> 可以得出结论，可以通过尝试写入数据来进行记录。 但是值得考虑的是，成功写入偶数0字节会破坏实际使用者尚未设法获取的数据。 再有一个窍门：我们可以应用适当的变更标记。 我们正在尝试使用标签0xFFFFFFFF进行写操作：在访问检查之后检查了标签，因此，错误值会导致写许可权泄漏。 </li></ul><br><p> 这并不能为我们提供完整的安全描述符，但是通过以不同的特权运行代码，我们可以了解不同系统帐户（低IL /用户/管理员/系统）的限制。 </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov"> 上市订户 </h4><br><p> 在WNF_PROCESS_CONTEXT结构中，字段之一是此过程的所有订阅的列表头（LIST_ENTRY）。 每个订阅都是WNF_SUBSCRIPTION的单独实例。 </p><br><p> 内核模式订户主要由系统进程拥有。 我们可以使用！List调试器命令来转储处理程序及其在WNF_SUBSCRIPTION系统进程中注册的参数。 值得注意的是，在某些情况下，使用事件聚合器（CEA.SYS），该事件聚合器在其上下文结构中隐藏了实际的回调地址。 </p><br><p> 我们可以对用户模式进程重复此方法，但是回调地址将为NULL，因为它们是用户模式订户。 因此，我们需要加入进程的用户空间，获取RtlpWnfProcessSubscriptions表，然后转储WNF_USER_SUBSCRIPTION实例的列表，每个实例已包含回调地址。 不幸的是，这个字符是静态的，这意味着它不是开放字符，但是可以通过反汇编找到。 再次值得一提的是（类似于CEA.SYS内核模式），许多用户模式处理程序使用事件聚合器（EventAggregation.dll），该事件聚合器将回调存储在其上下文中。 </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf"> 有趣且敏感的WNF状态名称 </h3><br><p> 本节将提供一些有趣的示例，说明一些WNF状态名称如何揭示系统信息。 </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf"> 使用WNF确定系统状态和用户行为 </h4><br><p> 一些WNF标识符可用于获取有关您感兴趣的计算机状态的信息： </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS-无线状态 </li><li>  WNF_BLTH_BLUETOOTH_STATUS-类似，但用于蓝牙（也是WNF_TETH_TETHERING_STATE） </li><li>  WNF_UBPM_POWER_SOURCE-显示电源（电池或电源适配器） </li><li>  WNF_SEB_BATTERY_LEVEL-包含电池电量 </li><li>  Windows Phone上的WNF_CELL_ *-包含有关以下信息：网络，号码，信号强度，EDGE或3G，... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER —   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT —    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED —    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      —       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE —     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST —   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK — ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND –   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory —    </li><li>   ( ) —               </li><li>   (Atom) —            </li><li>    —  ,   WM_COPYDATA  DDE,       </li><li> GUI  —    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="异步过程调用">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " —  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="控制流量保护">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> github</a> )   explorer (  —  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li>     WNF_USER_SUBSCRIPTION     </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459626/">https://habr.com/ru/post/zh-CN459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459616/index.html">MIPT开设了俄罗斯第一个计算机科学与软件工程高级硕士学位课程</a></li>
<li><a href="../zh-CN459618/index.html">一些鲜为人知的docker-compose功能</a></li>
<li><a href="../zh-CN459620/index.html">TDDx2，BDD，DDD，FDD，MDD和PDD，或者您想了解的有关驱动开发的任何知识</a></li>
<li><a href="../zh-CN459622/index.html">正如世嘉土星的游戏是在1995年编写的</a></li>
<li><a href="../zh-CN459624/index.html">军用无人机</a></li>
<li><a href="../zh-CN459628/index.html">开放发明网拥有三千多名被许可人-这对开源软件意味着什么</a></li>
<li><a href="../zh-CN459630/index.html">井字游戏第2部分：无状态复原/重做</a></li>
<li><a href="../zh-CN459638/index.html">建立有关电池的全球知识库</a></li>
<li><a href="../zh-CN459640/index.html">将文档作为代码。 第1部分：自动化更新</a></li>
<li><a href="../zh-CN459642/index.html">在不牺牲效率的情况下安全访问C ++中的注册字段（以CortexM为例）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>