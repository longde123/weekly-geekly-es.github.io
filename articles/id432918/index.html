<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🚒 🧘🏿 🛸 Maaf, saya merusak recovery.conf Anda 🔥 😏 🧒🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam PostgreSQL sejak zaman dahulu sudah versi 8.0, dirilis kembali pada tahun 2005, file konfigurasi khusus recovery.conf digunakan untuk mengembali...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maaf, saya merusak recovery.conf Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432918/"><img src="https://habrastorage.org/webt/fa/rt/zs/fartzsjcnmws2vzxpx4qhiw5ykq.jpeg" alt="saya merusak pemulihan Anda" align="left">  Dalam PostgreSQL sejak zaman dahulu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah versi 8.0,</a> dirilis kembali pada tahun 2005, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file konfigurasi</a> khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">recovery.conf</a> digunakan untuk mengembalikan ke titik waktu tertentu.  File yang sama kemudian mulai digunakan untuk mode siaga dan replikasi streaming. <br><br>  Namun, sejak rilis PostgreSQL 12 berikutnya, recovery.conf tidak akan berfungsi lagi: Saya memecahkannya. <br>  Tapi mengapa? <br><a name="habracut"></a><br>  Recovery.conf memiliki satu fitur: itu hanya dibaca pada awal DBMS.  Dan jika pemulihan point-in-time, yang dibutuhkan kurang dari setahun sekali, masih dapat direkonsiliasi, maka kebutuhan untuk me-restart seluruh database untuk mengubah alamat server replikasi hulu agak menyedihkan.  Saya melihat berbagai cara penyimpangan untuk menghindari pembatasan ini, seperti menggunakan perutean L3, skema replikasi cascading (sehingga tidak semua replika, tetapi setidaknya hanya sebagian, secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berurutan</a> ) dan bahkan (walaupun saya belum melihatnya dalam produksi) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">walbouncer</a> . <br><br>  Setelah dijadwalkan ulang berikutnya dari replika, hanya karena kebutuhan untuk mengubah parameter replikasi, saya memutuskan untuk mengambilnya, tetapi berapa biayanya untuk mengajar PostgreSQL untuk membaca kembali primary_conninfo di SIGHUP?  <s>Segalanya menjadi buruk.</s>  Pada prinsipnya, perlu untuk mengubah hanya satu variabel dalam proses startup dan dari sana meminta restart WalReceiver - dan hanya itu, replikasi akan melanjutkan dengan alamat baru dengan benar.  Masih menerapkan ini dengan benar.  Beberapa minggu kemudian saya menyelesaikan tambalan dengan implementasi membaca kembali recovery.conf pada sinyal SIGHUP, sementara tambalan itu tidak merusak perilaku database yang ada. <br><br>  Kemudian, dengan keberanian, <a href="">mengirimnya</a> ke milis pengembang PostgreSQL.  Apa yang Michael Paquier jawab dengan agak cepat: <br><blockquote>  Sebelum menjadikannya sebagai reloadable, mari kita beralih menjadi GUC terlebih dahulu dan tidak menemukan kembali penanganan parameter SIGHUP seperti yang dilakukan patch Anda. </blockquote>  Ups, ternyata saya salah bertanya ke mesin pencari.  Pertanyaannya bukan tentang membaca kembali recovery.conf, tetapi tentang konversi parameter dari recovery.conf yang terpisah ke infrastruktur GUC (grand unified configuration) yang digunakan untuk semua parameter DBMS lainnya.  Artinya, jelas tidak, kita tidak perlu tambalan seperti itu, kita tidak menginginkan ini.  Pertama-tama mari kita transfer semua pengaturan ini dari recovery.conf ke infrastruktur pengaturan standar kami. <br><br>  Pada berita suram ini, saya terbakar dan berpikir: "Tapi mari kita transfer!".  Saya membaca diskusi yang diarsipkan pada permintaan pencarian yang benar, membuka <a href="">diskusi</a> terakhir yang ditemukan <a href="">tentang mentransfer pengaturan</a> (tautan disediakan oleh Michael Paquier dalam jawabannya, yang saya berterima kasih padanya secara terpisah, serta atas tanggapan cepatnya).  Saat itu, pada Mei 2018, tambalan itu ditinggalkan selama lebih dari setahun.  Jadi, di sini kita mulai.  Atau lebih tepat mengatakan "lanjutkan"?  Menurut rencana hiburan: <br><br><ol><li>  baca dan daftarkan perubahan pada versi tambalan terbaru yang diterbitkan </li><li>  parsing perubahan dalam tambalan dan transfer yang diperlukan ke versi basis kode saat ini </li><li>  perbaiki semua referensi ke recovery.conf dan parameternya dalam dokumentasi </li><li>  tes perbaikan </li><li>  kirim tambalan baru ke milis </li><li>  dapatkan umpan balik </li><li>  untuk memperbaiki sesuatu sesuai dengan keinginan dan kembali ke paragraf 5 </li><li>  untuk menerima penolakan untuk menerima tambalan lagi (dalam satu setengah tahun) </li></ol><br>  Kedengarannya seperti rencana aksi?  Nah, ini dia! <br><br>  Berapa lama, secara singkat, saya sampai di titik lima dan pada 21 Juni 2018 menerbitkan versi tambalan <a href="">baru di utas diskusi baru</a> .  Kemudian 3 bulan dalam keheningan yang menindas dari keheningan dingin ikan Baskervilles.  Pada akhir September, Peter Eisentraut, salah satu pengembang Core dengan hak untuk berkomitmen, tiba-tiba menunjukkan minat pada tambalan itu.  Setelah beberapa kali koreksi, sementara saya diam-diam pergi selama beberapa hari untuk berjalan-jalan di Budapest dan melihat pemandangan, sebuah surat yang mengecewakan dari Peter Eisentraut tiba: <br><blockquote>  Saya pergi ke patch dan melakukan banyak perbaikan kecil.  Saya juga memperbarui dokumentasi secara lebih luas.  Patch yang terpasang cocok untuk saya. </blockquote>  Yaitu, Peter Eisentraut mengoreksi beberapa hal kecil lagi atas kebijakannya, memperbarui dokumentasinya, sepenuhnya membakar bagian recovery-config.sgml dan percaya bahwa dalam bentuk ini tambalan sudah dapat diterima.  Oh, dan saya pikir itu akan terjadi hanya untuk postgresql 13, bahkan jika itu sangat beruntung bahwa tambalan pada umumnya akan mencapai tingkat kesiapan untuk melakukan. <br><br>  Dan beberapa hari kemudian, yaitu pada tanggal 25 November 2018 ini, Peter Eisentraut benar-benar <a href="">menerima tambalan ini</a> : <br><blockquote>  pengaturan recovery.conf sekarang diatur dalam postgresql.conf (atau sumber GUC lainnya).  Saat ini, semua pengaturan yang terpengaruh adalah PGC_POSTMASTER;  ini bisa disempurnakan dalam kasus per kasus di masa depan. <br>  Pemulihan sekarang dimulai oleh file recovery.signal.  Mode siaga dimulai oleh file standby.signal.  Pengaturan standby_mode hilang.  Jika file recovery.conf ditemukan, kesalahan dikeluarkan. <br>  Pengaturan trigger_file telah diubah namanya menjadi promot_trigger_file sebagai bagian dari langkah tersebut. <br>  Bab dokumentasi "Konfigurasi Pemulihan" telah diintegrasikan ke dalam "Konfigurasi Server". <br>  pg_basebackup -R sekarang menambahkan pengaturan ke postgresql.auto.conf dan membuat file standby.signal. <br>  Penulis: Fujii Masao &lt;masao (dot) fujii (at) gmail (dot) com&gt; <br>  Penulis: Simon Riggs &lt;simon (at) 2ndquadrant (dot) com&gt; <br>  Penulis: Abhijit Menon-Sen &lt;ams (at) 2ndquadrant (dot) com&gt; <br>  Penulis: Sergei Kornilov &lt;sk (at) zsrv (dot) org&gt; </blockquote>  Dua minggu telah berlalu dan komit ini belum dibatalkan.  Luar biasa  Dan sepertinya mereka bahkan tidak akan melakukannya.  Luar biasa.  Tidak diketahui apakah komunitas akan memutuskan untuk mengubah perilaku ke arah mana pun lagi, terutama karena masih ada sedikit waktu sebelum fitur membekukan rilis postgresql 12 pada bulan April.  Tapi sepertinya kita tidak akan memiliki recovery.conf lagi. <br><br><h3>  Jadi apa yang berubah? </h3><br>  Pertama dan terutama, DBMS akan menolak untuk memulai jika menemukan file recovery.conf - ini dilakukan secara khusus sehingga pengguna, menggunakan salah satu dari banyak instruksi lama, tidak akan terkejut mengapa database mengabaikan konfigurasi dalam file ini. <br><br>  Pengaturan standby_mode lama hilang.  Sekarang, dan juga fakta keberadaan recovery.conf untuk mengaktifkan mode pemulihan, diganti oleh dua file (konten apa pun, biasanya kosong): <br><br><ul><li>  $ PGDATA / recovery.signal - penerus ideologis standby_mode = off, pemulihan dari arsip akan dilakukan ke titik yang ditentukan dalam konfigurasi; </li><li>  $ PGDATA / standby.signal - masing-masing, standby_mode = aktif.  Kami akan melihat file ini di semua replika. </li></ul><br>  Jika proses startup dari database menemukan kedua file, maka kami menganggap bahwa kami berada dalam mode siaga. <br><br>  Jika, untuk kejelasan, untuk mengurangi perubahan parameter ke piring: <br><table><tbody><tr><th>  recovery.conf lama <br></th><th>  PostgreSQL 12+ postgresql.conf <br></th></tr><tr><td>  primary_conninfo <br></td><td>  primary_conninfo <br></td></tr><tr><td>  primary_slot_name <br></td><td>  primary_slot_name <br></td></tr><tr><td>  trigger_file <br></td><td>  promot_trigger_file <br></td></tr><tr><td>  recovery_min_apply_delay <br></td><td>  recovery_min_apply_delay <br></td></tr><tr><td>  recovery_target <br></td><td>  recovery_target <br></td></tr><tr><td>  recovery_target_name <br></td><td>  recovery_target_name <br></td></tr><tr><td>  recovery_target_time <br></td><td>  recovery_target_time <br></td></tr><tr><td>  recovery_target_xid <br></td><td>  recovery_target_xid <br></td></tr><tr><td>  recovery_target_lsn <br></td><td>  recovery_target_lsn <br></td></tr><tr><td>  recovery_target_inclusive <br></td><td>  recovery_target_inclusive <br></td></tr><tr><td>  recovery_target_timeline <br></td><td>  recovery_target_timeline <br></td></tr><tr><td>  recovery_target_action <br></td><td>  recovery_target_action <br></td></tr><tr><td>  restore_command <br></td><td>  restore_command <br></td></tr><tr><td>  archive_cleanup_command <br></td><td>  archive_cleanup_command <br></td></tr><tr><td>  recovery_end_command <br></td><td>  recovery_end_command <br></td></tr></tbody></table><br>  Anda dapat melihat bahwa sedikit kurang dari tidak ada yang berubah.  Saat ini (dengan satu-satunya pengecualian awalan promot_ untuk promot_trigger_file), semua parameter baru dinamai sama seperti yang lama dan mengambil nilai yang mungkin sama.  Meskipun sebenarnya masih ada perubahan mengenai pengaturan target pemulihan.  Saya tidak tahu apakah ada yang menggunakan ini sebelumnya, tetapi itu adalah perilaku yang terdokumentasi dan dimungkinkan untuk menentukan beberapa recovery_target, recovery_target_lsn, recovery_target_name, recovery_target_time atau recovery_target_xid secara bersamaan.  Sebagai contoh <br><br><pre><code class="plaintext hljs">recovery_target_lsn = '1/1D9FEA00' recovery_target_xid = '5238954'</code> </pre> <br>  Baris terakhir dari recovery.conf sebenarnya digunakan untuk pemulihan.  Ini tidak lagi mungkin, tujuan pemulihan harus ditunjukkan oleh paling banyak satu.  Namun, karena logika infrastruktur GUC, Anda masih dapat menentukan parameter dengan nama yang sama beberapa kali: <br><br><pre> <code class="plaintext hljs">recovery_target_lsn = '1/1D9FEA00' recovery_target_lsn = '1/16AC7D0'</code> </pre> <br>  Ini dapat diterima, kami akan dikembalikan ke nilai pengaturan yang ditentukan terakhir. <br><br>  Dan, secara umum, ini semua yang perlu dikatakan tentang perubahan yang terlihat dari luar PostgreSQL.  pg_basebackup -R (--write-recovery-conf) tetap di tempatnya dan melakukan apa yang dimaksudkan, hanya sekarang ia akan menambahkan parameter ke postgresql.auto.conf alih-alih recovery.conf dan membuat file standby.signal <br><br>  Sayangnya, ketika saya mengatakan bahwa ini semua perubahan yang saat ini terlihat, inilah yang saya maksud.  Semua parameter baru masih ditetapkan sebagai PGC_POSTMASTER, yaitu, mereka hanya dapat diubah ketika PostgreSQL dimulai.  Seperti yang telah disebutkan, ini adalah persyaratan dari komunitas pengembang: pertama, transfer semua pengaturan, dan baru kemudian lihat apakah mereka dapat diubah pada database yang sedang berjalan.  Jadi sekarang PostgreSQL berada dalam tahap perkembangan yang menakjubkan, ketika perilaku lama telah rusak dan perubahan menjadi lebih baik belum dilakukan. <br><br>  Saya sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkan tambalan</a> yang memungkinkan perubahan primary_conninfo dan primary_slot_name dengan cepat.  Mari kita lihat apa yang terjadi. <br><br>  Maaf, saya merusak recovery.conf Anda <br><br><h3>  UPD 7 April 2019 </h3><br>  Di hari terakhir sebelum fitur membekukan versi 12, Anda dapat meringkas.  Mengubah pengaturan replikasi tidak termasuk dalam rilis.  Tentu saja, ini juga kisah yang aneh.  Sekali waktu, Simon Riggs patch yang saya ambil sebagai dasar sudah berisi suntingan untuk me-restart walreceiver ketika mengubah pengaturan koneksi.  Saya memilih mereka dalam tambalan terpisah yang dilengkapi dengan dokumentasi dan tes.  Dan setelah 6 pembaruan patch dan beberapa bulan diskusi, fakta yang jelas muncul bahwa jika Anda me-restart walreceiver, database akan mencoba untuk beralih untuk mengembalikan file dari restore_command.  Perilaku mesin negara yang cukup sederhana, dipicu dengan mematikan walreceiver karena alasan apa pun.  Tetapi ini ternyata menjadi "sesuatu yang tidak kita inginkan."  Nah, sebelumnya itu tidak mungkin dikatakan?  Ok, saya redidkan dalam beberapa cara, tetapi kalender sudah memiliki commitfest terakhir untuk versi 12 dan tidak ada yang melihat di sini.  Secara umum, ini bukan hal yang cepat, tambalan di PostgreSQL lakukan.  Tetapi saya memiliki hak untuk memasukkan diri saya ke dalam daftar orang, terima kasih kepada siapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REINDEX yang belum selesai yang belum selesai dengan CONCURRENTLY</a> dimasukkan dalam versi 12! <br><br>  Perlu disebutkan pada akhirnya bahwa sejumlah pengaturan memiliki <a href="">kesempatan</a> untuk berubah dengan cepat: archive_cleanup_command, promot_trigger_file, recovery_end_command, recovery_min_apply_delay </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432918/">https://habr.com/ru/post/id432918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432906/index.html">Mengedit file CSV agar tidak merusak data</a></li>
<li><a href="../id432908/index.html">Di Rusia, mereka berencana untuk memperkenalkan kontrol tambahan atas pembayaran di Internet</a></li>
<li><a href="../id432910/index.html">Berbahaya menganggap realitas virtual sebagai mesin empati</a></li>
<li><a href="../id432912/index.html">Cara mendapatkan magang di Google</a></li>
<li><a href="../id432914/index.html">Bot obrolan yang sangat sederhana untuk Telegram untuk yang terkecil</a></li>
<li><a href="../id432920/index.html">Faktor manusia dalam perusahaan: apakah itu berbahaya?</a></li>
<li><a href="../id432922/index.html">Bagaimana kami berburu bug NFS selama dua minggu di kernel Linux</a></li>
<li><a href="../id432924/index.html">Jalankan, Gecko, jalankan: mekanisme pergerakan air hibrida tokek</a></li>
<li><a href="../id432926/index.html">24 resep tentang bagaimana startup dapat berhasil di sebuah pameran dunia besar, menggunakan Web Summit 2018 sebagai contoh</a></li>
<li><a href="../id432928/index.html">Apa yang terjadi di Intel dan mengapa Amazon tidak akan mentransfer AWS sepenuhnya ke chip-nya meskipun ada berita utama yang keras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>