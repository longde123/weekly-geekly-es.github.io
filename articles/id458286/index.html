<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏼 #⃣ 🥚 ORM: mengapa tugas ini tidak memiliki solusi, tetapi untuk melakukannya, bagaimanapun, ada sesuatu yang perlu dilakukan 🚨 😺 🎁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teknologi informasi modern memukau dengan kekuatan mereka, mereka kewalahan oleh peluang yang terbuka, mereka tidak dianjurkan oleh kesempurnaan tekni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ORM: mengapa tugas ini tidak memiliki solusi, tetapi untuk melakukannya, bagaimanapun, ada sesuatu yang perlu dilakukan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458286/"><img src="https://habrastorage.org/webt/ih/bm/-r/ihbm-rqpvgk6lhwhg43njjt3i3c.jpeg"><br><br>  Teknologi informasi modern memukau dengan kekuatan mereka, mereka kewalahan oleh peluang yang terbuka, mereka tidak dianjurkan oleh kesempurnaan teknis yang melekat di dalamnya, tetapi ada satu titik menggelikan tentang IT yang terus-menerus mematahkan giginya.  Tunjukkan data pengguna dari database, dapatkan input darinya, masukkan kembali ke database, tunjukkan hasilnya.  Kolom input, tombol, tanda centang, prasasti - akan terlihat sangat rumit sehingga diperlukan untuk membuat konstruksi puzzle seperti kerangka kerja di atas mesin templating di atas kerangka kerja di atas transponder?  Dan mengapa, terlepas dari semua upaya luar biasa, kami memiliki fakta bahwa contoh mainan dalam tutorial, tentu saja, dibuat dengan mudah dan menyenangkan, tetapi begitu toolkit menjumpai tugas nyata dari kehidupan nyata ... bagaimana mengatakannya dengan lebih lembut ... dengan meningkatnya kompleksitas tugas yang harus diselesaikan, ada peningkatan non-linearitas yang kuat kesulitan implementasi.  Ya, itu akan menjadi pertanyaan tentang sesuatu yang benar-benar membingungkan pada tingkat fisika teoretis atau teknologi ruang angkasa, karena tidak ada yang sama - tombol dan tanda centang.  Mengapa omong kosong ini terus meracuni kehidupan warga dan kolektif kerja selama beberapa dekade? <br><br>  Alasannya, mungkin, seperti biasa, banyak.  Mungkin semuanya layak dipertimbangkan dalam satu atau lain cara, tetapi di sini dan sekarang kita akan berbicara tentang tugas Pemetaan Objek-Relasional (ORM), yang selalu di belakang beberapa "tombol dan tanda centang" dalam beberapa bentuk. <br><a name="habracut"></a><br><h4>  Apa yang kita ketahui tentang ORM </h4><br><ol><li>  Menyimpan data dalam tabel relasional bukan untuk mengatakan bahwa itu adalah masalah yang sangat sederhana, tetapi secara umum baik ide maupun cara penerapannya cukup jelas dan diteliti dengan baik. </li><li>  Dengan pemrograman objek, tidak semuanya begitu baik (ada beberapa pendekatan yang bersaing), tetapi secara umum, dengan penerapan dan penerapan teknologi, semuanya juga kurang lebih jelas. </li><li>  Baik itu, dan yang lain - tentang data, penyimpanan dan pemrosesan mereka.  Faktanya, tentang hal yang sama. </li><li>  Tampaknya logis bagi kita bahwa harus ada jembatan yang sederhana, dapat dipahami, nyaman, dapat diprediksi dan universal antara kedua dunia. </li><li>  Dan setiap kali kita menemukan jembatan ini dengan mudah, tetapi kemalangan, kesederhanaannya, kelengkapannya, kenyamanannya, kepastiannya dan universalitasnya tidak bekerja di luar contoh sederhana dari tutorial. </li><li>  Semua orang menderita: para pengembang, yang harus melakukan banyak pekerjaan yang sangat membosankan, dan para pengguna yang harus berjuang dengan perangkat lunak yang canggung, dan bisnis, realisasi kebutuhan yang tiba-tiba menjadi panjang dan mahal, dan industri secara keseluruhan tak tertahankan. </li><li>  Saya telah melihat banyak ORM yang berbeda, tetapi belum melihat yang baik.  Artinya, sesuatu yang, di luar contoh sederhana, tidak berubah menjadi beban dan tempat tidur Procrustean. </li></ol><br><h4>  Kenapa semuanya begitu aneh </h4><br>  Basis ideologis dari teori dan praktik database relasional adalah predikat kalkulus, yaitu cabang matematika.  Sedangkan untuk OOP, basis ideologis serupa kurang ada di sana.  Orang dapat mencoba merumuskan ide dasar OOP seperti ini: karena dunia terdiri dari objek, akan lebih mudah untuk memodelkannya, dunia ini, dengan membuat objek di dalam sistem perangkat lunak.  Dalam hal ini, dua kesalahan sekaligus.  Pertama, dunia itu sendiri tidak terdiri dan tidak pernah terdiri dari objek.  Kedua, saya minta maaf, tetapi mengapa program harus mensimulasikan dunia?  Yaitu, kita memiliki pernyataan yang secara konsep tidak benar, sempurna dilengkapi dengan pernyataan masalah yang tidak bermakna. <br><br>  Setiap ORM adalah upaya untuk dengan jelas meregangkan korespondensi yang disatukan antara, pada kenyataannya, cabang matematika dan serangkaian praktik yang longgar, berdasarkan pertimbangan kenyamanan, pendekatan yang ditetapkan secara historis, dan juga sering pada legenda, pendapat otoritas, dan hanya kesalahpahaman.  In vitro itu bisa dibuat untuk bekerja, tetapi in vivo itu ditakdirkan untuk terlihat menyedihkan dan membawa lebih banyak kesedihan daripada sukacita. <br><br><h4>  Pada keniscayaan orientasi objek </h4><br>  Namun demikian, kebutuhan akan orientasi objek dari perangkat lunak kami adalah kenyataan yang tidak dapat dihindari.  Keniscayaan ini didasarkan terutama pada kenyataan bahwa beroperasi dengan objek adalah esensi dan fondasi dari setiap kegiatan kita.  Dunia itu sendiri tidak terdiri dari objek, tetapi untuk memahami sesuatu di dunia ini dan melakukan sesuatu dengan dunia ini, kita sendiri menyatakan bagian-bagiannya sebagai objek, memanggil mereka nama, mencoba memahami perilaku mereka, berlaku untuk Usahanya untuk mendapatkan hasil yang diinginkan.  Ini adalah cara kami berfungsi, dan tidak mungkin untuk meninggalkannya, dan itu tidak perlu.  Segala sesuatu adalah objek, bukan karena itu benar-benar, tetapi karena kita tidak dapat melakukan sebaliknya.  Sesuatu yang sama sekali tidak dapat menjadi objek terletak sepenuhnya di luar batas kemampuan kita untuk memahami dan tidak dapat berfungsi sebagai subjek dari upaya kita. <br><br>  Sekalipun program ditulis tanpa menggunakan teknik OOP, program itu pasti mengandung objek (dalam arti luas), dengan memanipulasi pengembang yang memecahkan masalahnya - variabel, tipe data, operator, algoritma, konstruksi sintaksis, fungsi, modul.  Dari sudut pandang pengguna, program ini juga memiliki serangkaian objek yang berinteraksi - tombol, label, bidang input, halaman, situs, dan seluruh sistem. <br><br><h4>  Apa yang kami simpan di basis data kami </h4><br>  Seperti disebutkan di atas, basis data relasional didasarkan pada predikat kalkulus.  Predikat adalah fakta yang dirumuskan dan, dalam kasus kami, disimpan pada media.  Untuk jaga-jaga, saya perhatikan bahwa basis data relasional tidak hanya dan tidak begitu banyak tentang hubungan antara tabel dengan kunci asing.  Dalam terminologi yang tepat, hubungan adalah apa yang kita sebut tabel.  Artinya, bahkan jika database Anda hanya memiliki satu tabel dengan dua kolom (misalnya, nama dan nomor telepon), Anda sudah memiliki database relasional yang menetapkan hubungan antara dua set, dalam hal ini, set nama dan nomor telepon.  <i>Database relasional tidak menyimpan objek, tetapi menyimpan fakta.</i>  Fakta-fakta yang tersimpan, tentu saja, memiliki objek ("tentang fakta apa ini?"), Dan ketika kita mencoba mengajarkan sistem untuk menjawab pertanyaan ini, kita memiliki entitas, yaitu objek yang terkait dengan fakta.  Jika Anda bekerja dengan benar, struktur markas kami lahir dari serangkaian jawaban untuk pertanyaan “fakta apa yang ingin kami simpan?”, Dan hanya pada tahap berikutnya kami mendapatkan sesuatu yang menyerupai objek yang memberikan fakta pada objektivitas.  Anda dapat, tentu saja, mendesain "dari objek", tetapi saya tidak akan merekomendasikan melakukannya kecuali dalam pekerjaan laboratorium pada mata pelajaran yang tidak secara langsung terkait dengan desain database.  Bahaya kesalahan perhitungan arsitektur yang berat terlalu besar.  Selain itu, setidaknya tidak nyaman. <br><br>  <b>Penyimpangan kecil tentang database objek.</b>  Pikiran yang sangat sederhana: jika kita bosan dengan masalah ORM, maka mungkin kita harus melakukan sesuatu dengan bagian yang "R"?  Biarkan database kami tidak menjadi monster relasional yang tangguh dan menuntut, tetapi sesuatu yang modis yang dirancang khusus untuk menyimpan objek.  Beberapa jenis skema NoSQL-base, misalnya.  Tetapi pada akhirnya tiba-tiba ternyata ORM seperti NoSQL lebih canggung dan tidak alami daripada SQL-lama yang baik.  Bagaimanapun, kita dapat memiliki dan dengan senang hati untuk mengoperasikan DBMS bebas-sirkuit, tetapi tidak ada data bebas-sirkuit di alam.  Tidak ada yang lebih tak berdaya, tidak bertanggung jawab, dan tidak bermoral selain ORM untuk basis data tanpa sirkuit. <br><br><h4>  ORM bagus </h4><br>  ORM yang baik adalah ORM yang hilang.  Baik, serius.  Lihatlah salah satu sistem ORM Anda dan jujur ​​mencoba menjawab pertanyaan Anda: apa manfaat dari monster ini?  Apa alasan penggunaannya kecuali untuk janji-janji kebahagiaan yang tidak terpenuhi dan berulang kali berprasangka orang yang didiskreditkan?  Tentu saja, ada beberapa hal berguna yang berguna, tetapi apa yang mereka hadapi dengan latar belakang deformasi arsitektur yang diperkenalkan dan masalah kinerja yang terus-menerus muncul tiba-tiba? <br><br>  Sebagai aturan, API basis data “tingkat rendah” sederhana, nyaman, lengkap dan konsisten.  Biasanya cukup jari untuk mendaftar semua fitur.  Untuk mempelajarinya bukan berita dewa tugas apa. <br><br>  Saya akan mencoba untuk membuat serangkaian prinsip arsitektur yang memungkinkan Anda untuk memetakan objek ke database tanpa menggunakan ORM: <br><br><ol><li>  <i>Kami menyimpan fakta, beroperasi pada objek.</i>  Ingatlah bahwa basis data menyimpan fakta, dan model objek yang terlibat dalam pemrosesan data adalah proyeksi kumpulan fakta dari berbagai sudut pandang.  Misalnya, untuk contoh yang diberikan dengan nama dan nomor telepon, kita dapat memiliki kelas Abonent, yang beberapa nomornya dapat disimpan, dan juga kelas PhoneNumber, yang beberapa pelanggannya dapat diatur (jangan lupa bahwa selain nomor ponsel pribadi, kita memiliki di mana masih ada apartemen dan telepon kantor).  Dan tabel dalam database hanyalah salah satu yang mendefinisikan hubungan banyak-ke-banyak antara banyak nama dan nomor telepon.  Hanya dua proyeksi berbeda.  Omong-omong, pendekatan ini biasanya berskala pada kasus-kasus yang jauh lebih kompleks, memungkinkan Anda untuk memiliki kelas yang sangat berguna dalam sistem seperti, misalnya, "penjualan rata-rata untuk periode tertentu sesuai dengan kombinasi kriteria yang diberikan." </li><li>  <i>Fakta diproyeksikan menjadi objek dan sebaliknya melalui API berorientasi masalah.</i>  Tanpa menerapkan solusi yang mengaku universal.  Jika Anda masih tidak tahu cara membuat API yang nyaman, maka pelajari caranya.  Dan yang penting, ajari diri Anda untuk mendokumentasikannya segera. </li><li>  <i>Pesan di atas semuanya.</i>  Jika Anda menggunakan versi klasik dari DBMS dengan skema data yang kaku, maka skema ini dengan sendirinya mengatur pekerjaan dengan data.  Struktur ekstra yang disandikan oleh struktur objek hanya mubazir.  Jika Anda menggunakan DBMS bebas skematis, maka tentu saja Anda harus melakukan upaya untuk memastikan bahwa database Anda tidak berubah menjadi tumpukan sampah karena fakta bahwa pengembang yang berbeda memiliki ide yang berbeda tentang apa yang disimpan. </li><li>  <i>Independensi DBMS (jika perlu).</i>  Jika properti ORM yang paling menarik bagi Anda adalah independensi DBMS, maka gunakan alat khusus seperti ODBC, JDBC, ADO, atau jika ini tidak memungkinkan, buat tingkat abstraksi Anda sendiri.  Ini tidak sesulit kelihatannya pada awalnya.  Anda tidak memerlukan dukungan untuk semua kemampuan dari semua DBMS untuk tugas Anda, bukan? </li><li>  <i>Jangan lupa tentang aspek tambahan dari bekerja dengan data.</i>  Seperti, misalnya, berbagi akses ke data (yang bisa sangat rumit), pemantauan, replikasi, dan banyak lagi.  Tapi di sini saya punya kabar baik untuk Anda: karena dalam ORM favorit Anda, tambahkan.  aspek ini masih diterapkan sesuai dengan prinsip "Anda tidak akan menyenangkan semua orang, makan apa yang Anda berikan", penolakan layanan meragukan yang harus Anda tangani lebih dari bekerja sama dengan akhirnya akan terbukti menjadi keputusan yang benar secara strategis. </li></ol><br><h4>  Total </h4><br>  ORM adalah subjek yang sangat menyakitkan bagi industri kami.  Di era ketika kecerdasan buatan awan membajak kuantum blockchain, sebagian besar tenaga kerja sibuk mengacaukan logika bisnis dan antarmuka pengguna ke basis data.  Jutaan baris kode mengerikan, memaku dengan mikroskop, rasa sakit dan keputusasaan di mana-mana menyertai proses kreatif ini.  Salah satu akar dari keadaan yang menyedihkan ini adalah kesalahpahaman yang sangat kuat bahwa ORM universal pada prinsipnya memungkinkan.  Tapi itu tidak mungkin, dan ada alasan mendasar untuk ini, yang tidak bisa dihilangkan.  Kesadaran akan fakta ini adalah langkah pertama menuju keluar dari mimpi buruk ini.  Ada jalan keluar, ada alternatif, tetapi pertama-tama Anda harus menyadari, merasakan, dan belajar untuk tetap fokus pada perhatian. <br><br>  PS Saya dengan tulus meminta maaf kepada saudara-saudara dalam profesi yang telah menginvestasikan banyak waktu dan upaya dalam menciptakan banyak yang terbaik di dunia ORM.  Aku benar-benar minta maaf </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458286/">https://habr.com/ru/post/id458286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458272/index.html">Astaga! untuk pelancong - kisah satu proyek rumah</a></li>
<li><a href="../id458276/index.html">Simulasi pertama Semesta berdasarkan AI dikembangkan. Jaringan saraf melakukan tugasnya dengan sangat baik sehingga bahkan aneh</a></li>
<li><a href="../id458278/index.html">Bagaimana peretas menggunakan Microsoft Excel melawan dirinya sendiri</a></li>
<li><a href="../id458280/index.html">Langkah lain menuju akhir Hukum Moore</a></li>
<li><a href="../id458282/index.html">Sebelum Netscape: Browser Web yang Terlupakan pada Awal 1990-an</a></li>
<li><a href="../id458288/index.html">Anton Belichkov: "Cara termudah untuk memahami kekuatan OpenStreetMap adalah mulai mengedit peta sendiri"</a></li>
<li><a href="../id458290/index.html">Komputer dual-core biosintetik dalam sel hidup</a></li>
<li><a href="../id458292/index.html">PHP Digest No. 159 (17 Juni - 1 Juli 2019)</a></li>
<li><a href="../id458298/index.html">Membuat setengah roda gigi besar di panel surya untuk 250.000 rubel (2 bagian)</a></li>
<li><a href="../id458300/index.html">Evolusi alat paling populer dari setiap pengembang (dalam Visual Studio)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>