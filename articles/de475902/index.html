<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì© üìâ üìé Workflow Core - eine Business Process Engine f√ºr .Net Core üö¥üèΩ üë®üèø‚Äç‚öñÔ∏è üßòüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Wir haben uns entschlossen, das Thema der Migration des Projekts mithilfe der Windows Workflow Foundation auf .Net Core zu unter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Workflow Core - eine Business Process Engine f√ºr .Net Core</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avanpost/blog/475902/"><p><img src="https://habrastorage.org/webt/hp/ll/of/hpllof4hjsvcpfxbkl_q-epwfew.jpeg" alt="Bild"></p><br><p>  Hallo allerseits! </p><br><p>  Wir haben uns entschlossen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thema der Migration des Projekts mithilfe der Windows Workflow Foundation auf .Net Core zu unterst√ºtzen</a> , die von Kollegen von DIRECTUM gestartet wurde, da wir vor einigen Jahren mit einem √§hnlichen Problem konfrontiert waren und unseren eigenen Weg gegangen sind. </p><a name="habracut"></a><br><h2>  Beginnen wir mit der Geschichte </h2><br><p>  Unser Flaggschiffprodukt, Avanpost IDM, ist ein System f√ºr den Lebenszyklus von Konten und die Verwaltung des Mitarbeiterzugriffs.  Er wei√ü, wie der Zugriff sowohl automatisch auf der Grundlage des Rollenmodells als auch gem√§√ü den Anforderungen verwaltet wird.  Zu Beginn der Produktentstehung hatten wir ein recht einfaches Selbstbedienungssystem mit einem einfachen schrittweisen Arbeitsablauf, f√ºr den der Motor im Prinzip nicht erforderlich war. </p><br><p><img src="https://habrastorage.org/webt/hl/uo/c1/hluoc1imf_ejbdyzynpumdefmaa.png" alt="Bild"></p><br><p>  Als wir jedoch mit gro√üen Kunden konfrontiert wurden, stellten wir fest, dass ein viel flexibleres Tool erforderlich war, da deren Anforderungen an die Prozesse zur Koordinierung der Zugriffsrechte nach den Regeln eines guten, gewichtigen Workflows strebten.  Nach der Analyse der Anforderungen haben wir beschlossen, einen eigenen Prozesseditor im BPMN-Format zu entwickeln, der unseren Anforderungen entspricht.  Wir werden sp√§ter √ºber die Entwicklung des Editors mit React.js + SVG sprechen und heute das Backend-Thema diskutieren - die <strong>Workflow-Engine</strong> oder die Business Process Engine. </p><br><h2>  Anforderungen </h2><br><p>  Zu Beginn der Entwicklung des Systems hatten wir folgende Anforderungen an den Motor: </p><br><ul><li>  Unterst√ºtzung f√ºr Prozessdiagramme, ein verst√§ndliches Format, die M√∂glichkeit, von unserem Format in das Engine-Format zu senden </li><li>  Prozesszustandsspeicher </li><li>  Unterst√ºtzung f√ºr die Prozessversionierung </li><li>  Unterst√ºtzung f√ºr die parallele Ausf√ºhrung (Verzweigungen) des Prozesses </li><li>  Eine geeignete Lizenz zur Verwendung der L√∂sung in einem replizierten kommerziellen Produkt </li><li>  Unterst√ºtzung f√ºr horizontale Skalierung </li></ul><br><p>  Nach einer Marktanalyse (f√ºr 2014) haben wir uns f√ºr eine praktisch nicht alternative L√∂sung f√ºr .Net entschieden: Windows Workflow Foundation. </p><br><h2>  Windows Workflow Foundation (WWF) </h2><br><p>  WWF ist die Technologie von Microsoft zum Definieren, Ausf√ºhren und Verwalten von Workflows. </p><br><p>  Die Basis seiner Logik ist eine Reihe von Containern f√ºr Aktionen (Aktivit√§ten) und die F√§higkeit, aus diesen Containern sequentielle Prozesse zu erstellen.  Der Container kann normal sein - ein bestimmter Schritt in dem Prozess, in dem die Aktivit√§t ausgef√ºhrt wird.  Es kann ein Manager sein, der die Logik der Verzweigung enth√§lt. </p><br><p>  Sie k√∂nnen einen Prozess direkt in Visual Studio zeichnen.  Das kompilierte Gesch√§ftsprozessdiagramm ist in Haml gespeichert, was sehr praktisch ist - das Format ist beschrieben, es ist m√∂glich, einen selbstgeschriebenen Prozessdesigner zu erstellen.  Das ist auf der einen Seite.  Andererseits ist Xaml nicht das bequemste Format zum Speichern einer Beschreibung - das kompilierte Schema f√ºr einen mehr oder weniger realen Prozess erweist sich nicht zuletzt wegen der Redundanz als riesig.  Es ist sehr schwer zu verstehen, aber Sie m√ºssen es verstehen. </p><br><p>  Aber wenn man fr√ºher oder sp√§ter Zen mit Schemata verstehen und lesen lernen kann, dann tr√§gt die mangelnde Transparenz des Motors selbst zum √Ñrger bereits w√§hrend des Betriebs des Systems durch die Benutzer bei.  Wenn der Fehler aus dem Darm von Wf stammt, ist es nicht immer m√∂glich, 100% herauszufinden, was genau der Grund f√ºr den Fehler war.  Die geschlossene Quelle und die relative Monstrosit√§t helfen dem Fall nicht weiter.  Oft waren Fehlerkorrekturen auf Symptome zur√ºckzuf√ºhren. </p><br><p> Aus Gr√ºnden der Fairness sollte hier klargestellt werden, dass die oben beschriebenen Probleme uns gr√∂√ütenteils aufgrund der starken Anpassung von Wf geplagt haben.  Einer der Leser wird mit Sicherheit sagen, dass wir selbst eine Reihe von Problemen geschaffen und diese dann heldenhaft gel√∂st haben.  Es war von Anfang an notwendig, einen selbst gebauten Motor zu bauen.  Im Allgemeinen werden sie recht haben. </p><br><p>  Unter dem Strich funktionierte die L√∂sung stabil genug und ging erfolgreich in Produktion.  Aber die Umstellung unserer Produkte auf .Net Core hat uns gezwungen, den WWF aufzugeben und nach einer anderen Gesch√§ftsprozess-Engine zu suchen, weil  Bis Mai 2019 wurde die Windows Workflow Foundation nicht auf .Net Core migriert.  Als wir nach einer neuen Engine suchten - das Thema eines separaten Artikels - haben wir uns letztendlich f√ºr Workflow Core entschieden. </p><br><h2>  Workflow-Kern </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workflow Core</a> ist eine kostenlose Business Process Engine.  Es wird unter der MIT-Lizenz entwickelt, d. H. Es kann sicher in der kommerziellen Entwicklung verwendet werden. </p><br><p>  Es wird aktiv von einer Person erledigt, mehrere machen periodisch eine Pull-Anfrage.  Es gibt Ports f√ºr andere Sprachen (Java, Python und einige mehr). </p><br><p>  Der Motor ist so leicht positioniert.  Tats√§chlich ist dies nur ein Host f√ºr die sequentielle Ausf√ºhrung von Aktionen, die nach Gesch√§ftsregeln gruppiert sind. </p><br><p>  Das Projekt hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki-Dokumentation</a> .  Leider werden nicht alle Funktionen des Motors beschrieben.  Es wird jedoch unversch√§mt sein, eine vollst√§ndige Dokumentation anzufordern - das Open Source-Projekt wird von einem Enthusiasten unterst√ºtzt.  Daher ist das Wiki f√ºr den Einstieg ausreichend. </p><br><p>  Standardm√§√üig wird die Speicherung des Prozessstatus in einem externen Speicher (Persistenzspeicher) unterst√ºtzt.  Anbieter sind Standard f√ºr: </p><br><ul><li>  Mongodb </li><li>  SQL Server </li><li>  PostgreSQL </li><li>  SQLITE </li><li>  Amazon DynamoDB </li></ul><br><p>  Schreiben Sie Ihren Provider ist kein Problem.  Wir nehmen die Quellen eines Standards und dienen als Beispiel. </p><br><p>  Die horizontale Skalierung wird unterst√ºtzt, dh, Sie k√∂nnen die Engine auf mehreren Knoten gleichzeitig ausf√ºhren, w√§hrend ein Speicherpunkt f√ºr die Prozesszust√§nde vorhanden ist (ein Persistenzspeicher).  In diesem Fall sollte sich die Position der internen Task-Warteschlange der Engine im allgemeinen Speicher befinden (RabbitMQ als Option).  Um die Ausf√ºhrung einer Aufgabe durch mehrere Knoten auszuschlie√üen, wird gleichzeitig ein Sperrmanager bereitgestellt.  In Analogie zu externen Speicheranbietern gibt es Standardimplementierungen: </p><br><ul><li>  Azure-Speichervermietungen </li><li>  Redis </li><li>  AWS DynamoDB </li><li>  SQLServer (in der Quelle gibt es, aber nichts wird in der Dokumentation gesagt) </li></ul><br><p>  Das Kennenlernen von Neuem beginnt am einfachsten mit einem Beispiel.  Also lass es uns tun.  Ich werde den Aufbau eines einfachen Prozesses von Anfang an zusammen mit einer Erkl√§rung beschreiben.  Ein Beispiel mag unglaublich einfach erscheinen.  Ich stimme zu - es ist einfach.  Am Anfang. </p><br><p>  Lass uns gehen. </p><br><h4>  Schritt </h4><br><p>  Ein Schritt ist ein Schritt in dem Prozess, in dem Aktionen ausgef√ºhrt werden.  Der gesamte Prozess besteht aus einer Abfolge von Schritten.  Ein Schritt kann viele Aktionen ausf√ºhren, kann beispielsweise f√ºr ein Ereignis von au√üen wiederholt werden.  Es gibt eine Reihe von Schritten, die mit der Logik "out of the box" ausgestattet sind: </p><br><ul><li>  Warte auf </li><li>  Wenn </li><li>  W√§hrend </li><li>  Foreach </li><li>  Verz√∂gerung </li><li>  Parallel </li><li>  Zeitplan </li><li>  Recur </li></ul><br><p>  Nat√ºrlich k√∂nnen Sie den Prozess bei einigen eingebauten Grundelementen nicht aushalten.  Wir brauchen Schritte, die Gesch√§ftsaufgaben erledigen.  Legen Sie sie daher vorerst beiseite und unternehmen Sie Schritte mit unserer eigenen Logik.  Dazu m√ºssen Sie von der <strong>StepBody-</strong> Abstraktion erben. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StepBody</span></span> : <span class="hljs-title"><span class="hljs-title">IStepBody</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Die <strong>Run-</strong> Methode wird ausgef√ºhrt, wenn der Prozess in einen Schritt eintritt.  Es ist notwendig, die notwendige Logik darin zu platzieren. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StepBody</span></span> : <span class="hljs-title"><span class="hljs-title">IStepBody</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Die Schritte unterst√ºtzen die Abh√§ngigkeitsinjektion.  Dazu gen√ºgt es, sie im selben Container wie die erforderlichen Abh√§ngigkeiten zu registrieren. </p><br><p>  Offensichtlich ben√∂tigt der Prozess einen eigenen Kontext - einen Ort, an dem Zwischenergebnisse der Ausf√ºhrung hinzugef√ºgt werden k√∂nnen.  Wf core hat einen eigenen Kontext f√ºr die Ausf√ºhrung eines Prozesses, der Informationen √ºber seinen aktuellen Status speichert.  Sie k√∂nnen √ºber die <strong>Kontextvariable</strong> der Methode <strong>Run</strong> () darauf zugreifen.  Zus√§tzlich zum eingebauten k√∂nnen wir unseren Kontext verwenden. </p><br><p>  Wir werden die M√∂glichkeiten zur Beschreibung und Registrierung des Prozesses im Folgenden genauer analysieren. Zun√§chst definieren wir einfach eine bestimmte Klasse - den Kontext. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ProcessContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number1 {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number2 {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StepResult {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Number1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; Number2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><p>  In die Variablen <strong>Number</strong> schreiben wir Zahlen;  in die Variable <strong>StepResult</strong> - das Ergebnis des Schritts. </p><br><p>  Wir haben uns f√ºr den Kontext entschieden.  Sie k√∂nnen Ihren eigenen Schritt schreiben: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Input1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Input2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Action { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Result { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { _log = log; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { Result = ‚Äùnone‚Äù; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Action ==‚Äùsum‚Äù) { Result = Number1 + Number2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Action ==‚Äùdif‚Äù){ Result = Number1 - Number2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExecutionResult.Next(); } }</code> </pre> <br><p>  Die Logik ist denkbar einfach: Zwei Zahlen und der Name der Operation kommen zur Eingabe.  Das Ergebnis der Operation wird in die Ausgangsvariable <strong>Result geschrieben</strong> .  Wenn die Operation nicht definiert ist, ist das Ergebnis <em>none</em> . </p><br><p>  Wir haben uns f√ºr den Kontext entschieden, es gibt einen Schritt mit der Logik, die wir auch brauchen.  Jetzt m√ºssen wir unseren Prozess in der Engine registrieren. </p><br><h4>  Beschreibung des Prozesses.  Registrierung im Motor. </h4><br><p>  Es gibt zwei M√∂glichkeiten, einen Prozess zu beschreiben.  Die erste ist die Beschreibung im Code - der Hardcode. </p><br><p>  Der Prozess wird √ºber die <strong>fl√ºssige Schnittstelle beschrieben</strong> .  Es ist erforderlich, von der verallgemeinerten <strong>IWorkflow &lt;T&gt;</strong> -Schnittstelle zu erben, wobei T die Modellkontextklasse ist.  In unserem Fall ist dies ein <strong>ProcessContext</strong> . </p><br><p>  Es sieht so aus: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } public string Id =&gt; "SomeWorkflow"; public int Version =&gt; 1; }</span></span></code> </pre> <br><p>  Die Beschreibung selbst befindet sich in der <strong>Build-</strong> Methode.  Die Felder <strong>ID</strong> und <strong>Version</strong> sind ebenfalls erforderlich.  Wf core unterst√ºtzt die Prozessversionierung - Sie k√∂nnen n Prozessversionen mit derselben Kennung registrieren.  Dies ist praktisch, wenn Sie einen vorhandenen Prozess aktualisieren und gleichzeitig vorhandene Aufgaben "live" geben m√ºssen. </p><br><p>  Wir beschreiben einen einfachen Prozess: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { builder.StartWith&lt;CustomStep&gt;() .Input(step =&gt; step.Input1, data =&gt; data.Number1) .Input(step =&gt; step.Input2, data =&gt; data.Number2) .Input(step =&gt; step.Action, data =&gt; ‚Äúsum‚Äù) .Output(data =&gt; data.StepResult, step =&gt; step.Result) .EndWorkflow(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id =&gt; <span class="hljs-string"><span class="hljs-string">"SomeWorkflow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Version =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Wenn es in eine ‚Äûmenschliche‚Äú Sprache √ºbersetzt wird, <strong>sieht es ungef√§hr</strong> so aus: Der Prozess beginnt mit dem <strong>CustomStep-</strong> Schritt.  Der Wert des Schrittfeldes <strong>Input1</strong> wird aus dem Kontextfeld <strong>Number1 √ºbernommen</strong> , der Wert des Schrittfeldes <strong>Input2</strong> wird aus dem Kontextfeld <strong>Number2 √ºbernommen</strong> , das <strong>Aktionsfeld</strong> ist fest auf den Wert <strong>"Summe"</strong> <strong>codiert</strong> .  Die Ausgabe aus dem <strong>Ergebnisfeld wird</strong> in das <strong>StepResult-</strong> Kontextfeld geschrieben.  Schlie√üen Sie den Vorgang ab. </p><br><p>  Stimmen Sie zu, der Code erwies sich als sehr lesbar, es ist durchaus m√∂glich, es herauszufinden, auch ohne spezielle Kenntnisse in C #. </p><br><p>  F√ºgen Sie unserem Prozess einen weiteren Schritt hinzu, der das Ergebnis des vorherigen Schritts im Protokoll ausgibt: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TextToOutput { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    _log = log; } public override ExecutionResult Run(IStepExecutionContext context) { _log.Debug(TextToOutput); return ExecutionResult.Next(); } }</span></span></code> </pre> <br><p>  Und aktualisiere den Prozess: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { builder.StartWith&lt;CustomStep&gt;() .Input(step =&gt; step.Input1, data =&gt; data.Number1) .Input(step =&gt; step.Input2, data =&gt; data.Number2) .Input(step =&gt; step.Action, data =&gt; ‚Äúsum‚Äù) .Output(data =&gt; data.StepResult, step =&gt; step.Result) .Then&lt;OutputStep&gt;.Input(step =&gt; step.TextToOutput, data =&gt; data.StepResult) .EndWorkflow(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id =&gt; <span class="hljs-string"><span class="hljs-string">"SomeWorkflow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Version =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  Nach dem Schritt mit der Additionsoperation folgt nun der Schritt des Ausgebens des Ergebnisses in das Protokoll.  Als Eingabe √ºbergeben wir die Variable <strong>Result</strong> und Context, in die das Ergebnis der Ausf√ºhrung im letzten Schritt geschrieben wurde.  Ich werde mir erlauben, zu behaupten, dass eine solche Beschreibung durch einen Code (Hardcode) in realen Systemen von geringem Nutzen w√§re.  Es sei denn, f√ºr einige Office-Prozesse.  Es ist viel interessanter, die Schaltung separat speichern zu k√∂nnen.  Zumindest m√ºssen wir das Projekt nicht jedes Mal neu zusammensetzen, wenn wir etwas im Prozess √§ndern oder ein neues hinzuf√ºgen m√ºssen.  Wf Core bietet diese Funktion durch Speichern des JSON-Schemas.  Wir bauen unser Beispiel weiter aus. </p><br><h4>  Json-Prozessbeschreibung </h4><br><p>  <i>Weiterhin werde ich keine Beschreibung durch den Code liefern.</i>  <i>Dies ist nicht besonders interessant und bl√§st den Artikel nur auf.</i> </p><br><p>  Wf Core unterst√ºtzt die Schema-Beschreibung in JSON.  Meiner Meinung nach ist json visueller als xaml (ein gutes Thema f√ºr holivar in den Kommentaren :)).  Die Dateistruktur ist ziemlich einfach: </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { /*step1*/ }, { /*step2*/ } ] }</code> </pre> <br><p>  Das <strong>DataType-</strong> Feld gibt den vollst√§ndig qualifizierten Namen der Kontextklasse und den Namen der Assembly an, in der sie beschrieben wird.  <strong>Steps</strong> speichert eine Sammlung aller Schritte im Prozess.  F√ºllen Sie das <strong>Steps-</strong> Element aus: </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { "Id": "Eval", "StepType": "App.CustomStep, App", "NextStepId": "Output", "Inputs": { "Input1": "data.Number1", "Input2": "data.Number2" }, "Outputs": { "StepResult": "step.Result" } }, { "Id": "Output", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "data.StepResult" } } ] }</code> </pre> <br><p>  Schauen wir uns die Struktur der Schrittbeschreibung √ºber json genauer an. </p><br><p>  In den Feldern <strong>Id</strong> und <strong>NextStepId</strong> wird die Kennung dieses Schritts gespeichert und angezeigt, welcher Schritt der n√§chste sein kann.  Dar√ºber hinaus ist die Reihenfolge der Elemente der Sammlung unwichtig. </p><br><p>  <strong>StepType</strong> √§hnelt dem Feld <strong>DataType</strong> . Es enth√§lt den vollst√§ndig qualifizierten Klassennamen des Schritts (einen Typ, der von <strong>StepBody</strong> erbt und die Schrittlogik implementiert) und den Namen der Assembly.  Interessanter sind die <strong>Ein-</strong> und <strong>Ausg√§nge</strong> .  Sie werden in Form eines Mappings festgelegt. </p><br><p>  Bei <strong>Eingaben</strong> ist der Name des json-Elements der Name des Klassenfelds unseres Schritts.  Der Wert des Elements ist der Name des Feldes in der Klasse, der Kontext des Prozesses. </p><br><p>  Bei <strong>Ausgaben hingegen</strong> ist der Name des json-Elements der Name des Felds in der Klasse, der Kontext des Prozesses.  element value ist der Name des Klassenfeldes unseres Schritts. </p><br><p>  Warum werden Kontextfelder √ºber <em>Daten angegeben. {Feldname}</em> und bei <strong>Ausgabe</strong> <em>Schritt {Feldname}</em> ?  Da wf core der Elementwert als C # -Ausdruck ausgef√ºhrt wird (es wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dynamic Expressions-Bibliothek</a> verwendet).  Dies ist eine n√ºtzliche Sache, mit deren Hilfe Sie eine Gesch√§ftslogik direkt in das Schema einf√ºgen k√∂nnen, wenn der Architekt nat√ºrlich eine solche Schande billigt :). </p><br><p>  Wir diversifizieren das Schema mit Standardprimitiven.  F√ºgen Sie einen bedingten <strong>If-</strong> Schritt hinzu und verarbeiten Sie ein externes Ereignis. </p><br><h5>  Wenn </h5><br><p>  Primitive <strong>If</strong> .  Hier beginnen die Schwierigkeiten.  Wenn Sie es gewohnt sind, in dieser Notation Prozesse zu bpmn und zu zeichnen, finden Sie eine einfache Einrichtung.  Gem√§√ü der Dokumentation wird der Schritt wie folgt beschrieben: </p><br><pre> <code class="plaintext hljs">{ "Id": "IfStep", "StepType": "WorkflowCore.Primitives.If, WorkflowCore", "NextStepId": "nextStep", "Inputs": { "Condition": "&lt;&lt;expression to evaluate&gt;&gt;" }, "Do": [ [ { /*do1*/ }, { /*do2*/ } ] ] }</code> </pre> <br><p>  Gibt es kein Gef√ºhl, dass hier etwas nicht stimmt?  Ich habe.  Die Stufeneingabe wird auf <em>Bedingung</em> - Ausdruck gesetzt.  Als n√§chstes legen wir die Liste der Schritte innerhalb des <strong>Do-</strong> Arrays (Aktionen) fest.  Also, wo ist der <strong>falsche</strong> Zweig?  Warum gibt es kein Do-Array f√ºr False?  Eigentlich gibt es.  Es versteht sich, dass die Verzweigung <strong>Falsch</strong> lediglich einen weiteren Durchgang entlang des Prozesses darstellt, d. H. Dem Zeiger in <strong>NextStepId</strong> folgt.  Anfangs war ich deswegen st√§ndig verwirrt.  Okay, hat es gekl√§rt.  Obwohl nicht.  Wenn die Prozessaktionen im Fall von <em>True</em> in " <strong>Do" gesetzt werden m√ºssen</strong> , ist dies der "sch√∂ne" json.  Und wenn es diese gibt, <strong>wenn sie</strong> mit einem Dutzend eingeschlossen sind?  Alles wird seitw√§rts gehen.  Sie sagen auch, dass das Schema auf XAML schwer zu lesen ist.  Es gibt einen kleinen Hack.  Nehmen Sie einfach den Monitor breiter.  Es wurde ein wenig oben erw√§hnt, dass die Reihenfolge der Schritte in der Sammlung keine Rolle spielt, der √úbergang folgt den Zeichen.  Es kann verwendet werden.  F√ºgen Sie einen weiteren Schritt hinzu: </p><br><pre> <code class="plaintext hljs">{ "Id": "Jump", "StepType": "App.JumpStep, App", "NextStepId": "" }</code> </pre> <br><p>  Ratet mal, wohin ich f√ºhre?  Richtig, wir f√ºhren einen Serviceschritt ein, der den Prozess <strong>w√§hrend der √úbertragung</strong> zu einem Schritt in <strong>NextStepId f√ºhrt</strong> . </p><br><p>  Aktualisieren Sie unser Schema: </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { "Id": "Eval", "StepType": "App.CustomStep, App", "NextStepId": "MyIfStep", "Inputs": { "Input1": "data.Number1", "Input2": "data.Number2" }, "Outputs": { "StepResult": "step.Result" } }, { "Id": "MyIfStep", "StepType": "WorkflowCore.Primitives.If, WorkflowCore", "NextStepId": "OutputEmptyResult", "Inputs": { "Condition": "!String.IsNullOrEmpty(data.StepResult)" }, "Do": [ [ { "Id": "Jump", "StepType": "App.JumpStep, App", "NextStepId": "Output" } ] ] }, { "Id": "Output", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "data.StepResult" } }, { "Id": "OutputEmptyResult", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "\"Empty result\"" } } ] }</code> </pre> <br><p>  Der <strong>If-</strong> Schritt pr√ºft, ob das Ergebnis des <strong>Eval-</strong> Schritts leer ist.  Wenn es nicht leer ist, zeigen wir das Ergebnis an, wenn es leer ist, die Meldung " <em>Empty result</em> ".  Der <strong>Jump-</strong> Schritt f√ºhrt den Prozess zum <strong>Output-</strong> Schritt, der sich au√üerhalb der <strong>Do-</strong> Auflistung befindet.  Somit haben wir die ‚ÄûVertikalit√§t‚Äú des Schemas beibehalten.  Auf diese Weise kann man auch n Schritte zur√ºckspringen, d.h.  einen Zyklus organisieren.  Es gibt eingebaute Grundelemente f√ºr Schleifen im wf-Kern, aber sie sind nicht immer praktisch.  In bpmn werden beispielsweise Schleifen durch <strong>If</strong> organisiert. </p><br><p>  Verwenden Sie diesen Ansatz oder den Standard, es liegt an Ihnen.  F√ºr uns war eine solche Organisation bequemer Schritte. </p><br><h5>  Warte auf </h5><br><p>  Mit dem <strong>WaitFor-Grundelement</strong> kann die Au√üenwelt den Prozess beeinflussen, wenn er bereits ausgef√ºhrt wird.  Zum Beispiel, wenn im Stadium des Prozesses eine Genehmigung des weiteren Kurses durch einen Benutzer erforderlich ist.  Der Prozess bleibt im <strong>WaitFor-</strong> Schritt stehen, bis er ein von ihm abonniertes Ereignis empf√§ngt. </p><br><p>  Primitive Struktur: </p><br><pre> <code class="plaintext hljs">{ "Id": "Wait", "StepType": "WorkflowCore.Primitives.WaitFor, WorkflowCore", "NextStepId": "NextStep", "CancelCondition": "If(cancel==true)", "Inputs": { "EventName": "\"UserAction\"", "EventKey": "\"DoSum\"", "EffectiveDate": "DateTime.Now" } }</code> </pre> <br><p>  Ich werde die Parameter ein wenig erkl√§ren. </p><br><p>  <strong>CancelCondition</strong> - eine Bedingung zum Unterbrechen eines Wartens.  Bietet die M√∂glichkeit, das Warten auf ein Ereignis zu unterbrechen und den Prozess fortzusetzen.  Wenn ein Prozess beispielsweise gleichzeitig auf n verschiedene Ereignisse wartet (wf core unterst√ºtzt die parallele Ausf√ºhrung von Schritten), ist es nicht erforderlich, auf das <strong>Eintreffen</strong> aller Ereignisse zu warten. In diesem Fall hilft <strong>uns CancelCondition</strong> .  Wir f√ºgen den Kontextvariablen ein logisches Flag hinzu und setzen das Flag nach Erhalt des Ereignisses auf <em>true</em> - alle <strong>WaitFor-</strong> Schritte sind abgeschlossen. </p><br><p>  <strong>EventName</strong> und <strong>EventKey</strong> - Name und Schl√ºssel des Ereignisses.  Felder werden ben√∂tigt, um Ereignisse zu unterscheiden, d. H. In einem realen System mit einer gro√üen Anzahl von gleichzeitig arbeitenden Prozessen.  Damit der Motor versteht, welches Ereignis f√ºr welchen Prozess und welchen Schritt vorgesehen ist. </p><br><p>  <strong>EffectiveDate</strong> - ein optionales Feld, das einen Ereigniszeitstempel hinzuf√ºgt.  Dies kann n√ºtzlich sein, wenn Sie eine Veranstaltung ‚Äûin die Zukunft‚Äú ver√∂ffentlichen m√ºssen.  Damit es sofort ver√∂ffentlicht wird, k√∂nnen Sie den Parameter leer lassen oder die aktuelle Uhrzeit einstellen. </p><br><p>  Es ist nicht in allen F√§llen zweckm√§√üig, einen separaten Schritt zu unternehmen, um die Reaktionen von au√üen zu verarbeiten, sondern es ist sogar in der Regel √ºberfl√ºssig.  Ein zus√§tzlicher Schritt kann vermieden werden, indem die Erwartung eines externen Ereignisses und die Logik seiner Verarbeitung zum √ºblichen Schritt hinzugef√ºgt werden.  Wir <strong>erg√§nzen den CustomStep-</strong> Schritt, <strong>indem</strong> wir ein externes Ereignis abonnieren: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TextToOutput { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { _log = log; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//-  return ExecutionResult.WaitForEvent("eventName", "eventKey", DateTime.Now); } }</span></span></code> </pre> <br><p>  Wir haben die standardm√§√üige <strong>WaitForEvent () -</strong> Erweiterungsmethode verwendet.  Es akzeptiert die zuvor genannten Parameter <strong>EventName</strong> , <strong>EventKey</strong> und <strong>EffectiveDate</strong> .  Nach Abschluss der Logik eines solchen Schritts wartet der Prozess auf das beschriebene Ereignis und ruft zum Zeitpunkt der Ver√∂ffentlichung des Ereignisses im <strong>Motorbus</strong> erneut die Methode <strong>Run ()</strong> auf.  In der aktuellen Form k√∂nnen wir jedoch nicht zwischen den Zeitpunkten des ersten Eintritts in den Schritt und dem Eintrag nach dem Ereignis unterscheiden.  Aber ich m√∂chte irgendwie die Logik vorher-nachher auf der Stufenebene trennen.  Und die <strong>EventPublished-</strong> Flagge hilft uns dabei.  Es befindet sich im allgemeinen Kontext des Prozesses. Sie k√∂nnen es folgenderma√üen abrufen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ifEvent=context.ExecutionPointer.EventPublished;</code> </pre> <br><p>  Anhand dieses Flags k√∂nnen Sie die Logik sicher in vor und nach einem externen Ereignis unterteilen. </p><br><p>  Eine wichtige Klarstellung - nach der Vorstellung des Motorherstellers kann ein Schritt nur bei einem Ereignis unterschrieben werden und einmalig darauf reagieren.  F√ºr manche Aufgaben ist dies eine sehr unangenehme Einschr√§nkung.  Wir mussten sogar den Motor ‚Äûfertig machen‚Äú, um von dieser Nuance loszukommen.  Wir werden ihre Beschreibung in diesem Artikel √ºberspringen, sonst wird der Artikel niemals enden :).  Komplexere Verwendungspraktiken und Beispiele f√ºr Verbesserungen werden in den folgenden Artikeln behandelt. </p><br><h4>  Registrierungsvorgang im Motor.  Ver√∂ffentlichung der Veranstaltung im Bus. </h4><br><p>  Also, mit der Umsetzung der Logik der Schritte und Beschreibungen des Prozesses herausgefunden.  Was bleibt, ist das Wichtigste, ohne das der Prozess nicht funktioniert - die Beschreibung muss registriert werden. </p><br><p>  Wir werden die Standard-Erweiterungsmethode <strong>AddWorkflow ()</strong> verwenden, die ihre Abh√§ngigkeiten in unseren IoC-Container stellt. </p><br><p>  Es sieht so aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServiceCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWorkflow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IServiceCollection services, Action&lt;WorkflowOptions&gt; setupAction = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  <strong>IServiceCollection</strong> - Schnittstelle - ein Vertrag f√ºr eine Sammlung von Dienstbeschreibungen.  Er wohnt in DI von Microsoft (mehr dazu finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> ) </p><br><p>  <strong>WorkflowOptions</strong> - Grundeinstellungen der Engine.  Es ist nicht notwendig, diese selbst einzustellen, Standardwerte sind f√ºr den Erstkontakt durchaus akzeptabel.  Wir gehen weiter. </p><br><p>  Wenn der Vorgang in Code beschrieben wurde, erfolgt die Registrierung folgenderma√üen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = _serviceProvider.GetService&lt;IWorkflowHost&gt;(); host.RegisterWorkflow&lt;SomeWorkflow, ProcessContext&gt;();</code> </pre> <br><p>  Wenn der Prozess √ºber json beschrieben wird, muss er wie folgt registriert werden (nat√ºrlich muss die json-Beschreibung vom Speicherort vorgeladen werden): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = _serviceProvider.GetService&lt;IWorkflowHost&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> definitionLoader = _serviceProvider.GetService&lt;IDefinitionLoader&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> definition = loader.LoadDefinition({*json  *});</code> </pre> <br><p>  Au√üerdem ist der Code f√ºr beide Optionen gleich: </p><br><pre> <code class="cs hljs">host.Start(); <span class="hljs-comment"><span class="hljs-comment">//      host.StartWorkflow(definitionId, version, context); //      /// host.Stop(); / /    </span></span></code> </pre> <br><p>  Der Parameter <strong>definitionId</strong> ist die Prozesskennung.  Was ist in das Feld Prozess-ID geschrieben.  In diesem Fall ist id = <strong>SomeWorkflow</strong> . </p><br><p>  Der <strong>version-</strong> Parameter gibt an, welche Version des Prozesses ausgef√ºhrt werden soll.  Die Engine bietet die M√∂glichkeit, sofort n Prozessversionen mit einer Kennung zu registrieren.  Dies ist praktisch, wenn Sie √Ñnderungen an der Beschreibung des Prozesses vornehmen m√ºssen, ohne bereits ausgef√ºhrte Aufgaben zu unterbrechen - neue Aufgaben werden gem√§√ü der neuen Version erstellt, alte Aufgaben werden stillschweigend von der alten √ºbernommen. </p><br><p>  Der <strong>Kontextparameter</strong> ist eine Instanz des Prozesskontexts. </p><br><p>  Die <strong>Methoden host.Start ()</strong> und <strong>host.Stop ()</strong> starten und stoppen das Prozesshosting.  Wenn in der Anwendung der Start von Prozessen eine angewendete Aufgabe ist und regelm√§√üig ausgef√ºhrt wird, sollte das Hosting gestoppt werden.  Wenn die Anwendung den Schwerpunkt auf die Implementierung verschiedener Prozesse legt, kann das Hosting nicht gestoppt werden. </p><br><p>  Es gibt eine Methode zum Senden von Nachrichten von der Au√üenwelt an den Motorbus, der sie dann unter den Teilnehmern verteilt: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventKey, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventData, DateTime effectiveDate = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  Die Beschreibung der Parameter war im Artikel h√∂her ( <em>siehe WaitFor-Grundelement</em> ). </p><br><h2>  Fazit </h2><br><p>  Wir sind definitiv Risiken eingegangen, als wir uns f√ºr das Workflow Core - OpenSource-Projekt entschieden haben, das von einer Person aktiv entwickelt wird, und das auch bei sehr schlechter Dokumentation.  Und Sie werden h√∂chstwahrscheinlich keine echten Praktiken f√ºr die Verwendung von wf core in Produktionssystemen finden (au√üer unseren).  Nachdem wir eine separate Abstraktionsebene ausgew√§hlt hatten, versicherten wir uns nat√ºrlich gegen einen Misserfolg und die Notwendigkeit, zum Beispiel schnell zum WWF zur√ºckzukehren, oder gegen eine selbstgeschriebene L√∂sung, aber alles verlief recht gut und der Misserfolg kam nicht. </p><br><p>  Die Umstellung auf die OpenSource Workflow Core-Engine l√∂ste eine Reihe von Problemen, die uns daran hinderten, friedlich im WWF zu leben.  Das wichtigste davon ist nat√ºrlich die Unterst√ºtzung von .Net Core und das Fehlen eines solchen WWF, auch wenn dies geplant ist. </p><br><p>  Es folgt die Open Source.  Wenn Sie mit dem WWF zusammenarbeiten und verschiedene Fehler aus dem Darm bekommen, w√§re es sehr hilfreich, zumindest die Quelle lesen zu k√∂nnen.  Ganz zu schweigen davon, etwas an ihnen zu √§ndern.  Hier mit Workflow Core v√∂llige Freiheit (inklusive Lizenzierung - MIT).  Wenn pl√∂tzlich ein Fehler im Inneren des Motors auftritt, laden Sie einfach die Quellen von github herunter und suchen Sie in aller Ruhe nach der Ursache f√ºr das Auftreten.  Ja, allein die M√∂glichkeit, die Engine im Debug-Modus mit Haltepunkten zu starten, erleichtert den Vorgang erheblich. </p><br><p>  Nat√ºrlich hat Workflow Core zur L√∂sung einiger Probleme neue mitgebracht.  Wir mussten eine erhebliche Menge an √Ñnderungen am Motorkern vornehmen.  Aber.  Die Arbeit am "Finishing" selbst kostet weniger Zeit als die Entwicklung eines eigenen Motors von Grund auf.  Die endg√ºltige L√∂sung war in Bezug auf Geschwindigkeit und Stabilit√§t durchaus akzeptabel, sodass wir die Probleme mit dem Motor vergessen und uns auf die Entwicklung des Gesch√§ftswerts des Produkts konzentrieren konnten. </p><br><p>  <em>PS Wenn sich das Thema als interessant herausstellt, wird es weitere Artikel zu wf core geben, mit einer tieferen Analyse der Engine und L√∂sungen f√ºr komplexe Gesch√§ftsprobleme.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475902/">https://habr.com/ru/post/de475902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475888/index.html">Vorteile der Wolkengesichtserkennung</a></li>
<li><a href="../de475892/index.html">Wie wir die Bestellung des Mittagessens im B√ºro verbessert haben (ohne Zugang zum Server)</a></li>
<li><a href="../de475894/index.html">Drei-Pass-Protokolle</a></li>
<li><a href="../de475896/index.html">Voller I / O-Naked-C-Reaktor</a></li>
<li><a href="../de475900/index.html">Die 6 neuesten Azure-Kurse</a></li>
<li><a href="../de475904/index.html">5 Notizen f√ºr den neuen Manager</a></li>
<li><a href="../de475908/index.html">10 beliebtesten Microsoft-Kurse in Russisch</a></li>
<li><a href="../de475912/index.html">So bewerten und vergleichen Sie Verschl√ºsselungsger√§te f√ºr Ethernet-Netzwerke</a></li>
<li><a href="../de475916/index.html">F√ºgen Sie dem Roboter Augen hinzu</a></li>
<li><a href="../de475920/index.html">Nicht zur Laufzeit, sondern zur Entwurfszeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>