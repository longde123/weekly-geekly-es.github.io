<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÅ üîª üì¢ Furchtloser Schutz. Gewindesicherheit im Rost üèº üë©üèΩ‚Äçüåæ üëè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil der Artikelserie Fearless Protection. Im ersten haben wir √ºber Speichersicherheit gesprochen 

 Moderne Anwendungen haben meh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Furchtloser Schutz. Gewindesicherheit im Rost</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441370/">  <font color="gray"><i>Dies ist der zweite Teil der Artikelserie Fearless Protection.</i></font>  <font color="gray"><i>Im ersten haben wir √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichersicherheit gesprochen</a></i></font> <br><br>  Moderne Anwendungen haben mehrere Threads: Anstatt Aufgaben nacheinander auszuf√ºhren, verwendet das Programm Threads, um mehrere Aufgaben gleichzeitig auszuf√ºhren.  Wir alle beobachten jeden Tag <i>gleichzeitige Arbeit</i> und <i>Parallelit√§t</i> : <br><br><ul><li>  Websites werden von mehreren Benutzern gleichzeitig bereitgestellt. <br></li><li> Die Benutzeroberfl√§che f√ºhrt Hintergrundarbeiten aus, die den Benutzer nicht st√∂ren (stellen Sie sich vor, dass die Anwendung jedes Mal einfriert, wenn Sie ein Zeichen eingeben, um die Rechtschreibung zu √ºberpr√ºfen). <br></li><li>  Ein Computer kann mehrere Anwendungen gleichzeitig ausf√ºhren. </li></ul><br>  Parallele Streams beschleunigen die Arbeit, f√ºhren jedoch zu einer Reihe von Synchronisationsproblemen, n√§mlich Deadlocks und Rennbedingungen.  Warum ist uns aus Sicherheitsgr√ºnden die Thread-Sicherheit wichtig?  Weil die Sicherheit von Speicher und Threads ein und dasselbe Hauptproblem hat: unangemessene Verwendung von Ressourcen.  Angriffe haben hier die gleichen Auswirkungen wie Speicherangriffe, einschlie√ülich der Eskalation von Berechtigungen, der Ausf√ºhrung von willk√ºrlichem Code (ACE) und der Umgehung von Sicherheits√ºberpr√ºfungen. <br><a name="habracut"></a><br>  Parallelit√§tsfehler h√§ngen ebenso wie Implementierungsfehler eng mit der Programmkorrektheit zusammen.  W√§hrend Speicherschwachstellen fast immer gef√§hrlich sind, weisen Implementierungs- / Logikfehler nicht immer auf ein Sicherheitsproblem hin, wenn sie nicht in dem Teil des Codes auftreten, der sich auf die Einhaltung von Sicherheitsvertr√§gen bezieht (z. B. die Erlaubnis, eine Sicherheits√ºberpr√ºfung zu umgehen).  Parallelit√§tsfehler haben jedoch eine Besonderheit.  Wenn Sicherheitsprobleme aufgrund logischer Fehler h√§ufig neben dem entsprechenden Code auftreten, treten Parallelit√§tsfehler h√§ufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in anderen Funktionen auf und nicht in der, in der der Fehler direkt aufgetreten ist</a> , was es schwierig macht, sie zu verfolgen und zu beseitigen.  Eine weitere Schwierigkeit ist eine gewisse √úberlappung zwischen unsachgem√§√üer Speicherverarbeitung und Parallelit√§tsfehlern, die wir bei Datenrennen sehen. <br><br>  Programmiersprachen haben verschiedene Parallelit√§tsstrategien entwickelt, um Entwicklern bei der Verwaltung der Leistungs- und Sicherheitsprobleme von Multithread-Anwendungen zu helfen. <br><br><h1>  Parallelit√§tsprobleme </h1><br>  Es ist allgemein anerkannt, dass die parallele Programmierung schwieriger als gew√∂hnlich ist: Unser Gehirn ist besser an sequentielles Denken angepasst.  Paralleler Code kann unerwartete und unerw√ºnschte Interaktionen zwischen Threads aufweisen, einschlie√ülich Deadlocks, Konflikten und Datenrennen. <br><br>  <i>Ein Deadlock</i> tritt auf, wenn mehrere Threads erwarten, dass bestimmte Aktionen ausgef√ºhrt werden, um weiter zu arbeiten.  Obwohl dieses unerw√ºnschte Verhalten einen Denial-of-Service-Angriff verursachen kann, werden keine Schwachstellen wie ACE verursacht. <br><br>  <i>Eine Rennbedingung</i> ist eine Situation, in der die Zeit oder Reihenfolge der Aufgaben die Richtigkeit eines Programms beeinflussen kann.  Datenrennen treten auf, wenn mehrere Streams mit mindestens einem Schreibversuch gleichzeitig versuchen, auf denselben Speicherort zuzugreifen.  Es kommt vor, dass eine Rennbedingung und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenrennen unabh√§ngig</a> voneinander auftreten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenrennen sind jedoch immer gef√§hrlich</a> . <br><br><h3>  M√∂gliche Folgen von Parallelit√§tsfehlern </h3><br><ol><li>  Deadlock <br></li><li>  Informationsverlust: Ein anderer Thread √ºberschreibt Informationen <br></li><li>  Integrit√§tsverlust: Informationen aus mehreren Streams sind miteinander verwoben <br></li><li>  Rentabilit√§tsverlust: Leistungsprobleme aufgrund ungleichm√§√üigen Zugriffs auf gemeinsam genutzte Ressourcen </li></ol><br>  Die bekannteste Art von Parallelit√§tsangriff hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TOCTOU</a> (Zeitpunkt der √úberpr√ºfung bis zum Zeitpunkt der Verwendung): Im Wesentlichen liegt der Status eines Rennens zwischen der √úberpr√ºfung der Bedingungen (z. B. Sicherheitsanmeldeinformationen) und der Verwendung der Ergebnisse.  Ein TOCTOU-Angriff f√ºhrt zu einem Integrit√§tsverlust. <br><br>  Gegenseitige Sperren und Verlust der √úberlebensf√§higkeit werden als Leistungsprobleme und nicht als Sicherheitsprobleme betrachtet, w√§hrend Informationsverlust und Integrit√§tsverlust wahrscheinlich mit Sicherheit zusammenh√§ngen.  Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Balloon Security-Artikel</a> befasst sich mit einigen m√∂glichen Exploits.  Ein Beispiel ist eine Zeigerbesch√§digung, gefolgt von einer Eskalation von Berechtigungen oder der Ausf√ºhrung von Remotecode.  Im Exploit initiiert eine Funktion, die die gemeinsam genutzte Bibliothek ELF (Executable and Linkable Format) l√§dt, ein Semaphor erst beim ersten Aufruf korrekt und begrenzt dann die Anzahl der Threads falsch, was zu einer Besch√§digung des Kernelspeichers f√ºhrt.  Dieser Angriff ist ein Beispiel f√ºr Informationsverlust. <br><br>  Der schwierigste Teil der parallelen Programmierung ist das Testen und Debuggen, da Parallelit√§tsfehler schwer zu reproduzieren sind.  Timing von Ereignissen, Entscheidungen des Betriebssystems, Netzwerkverkehr und andere Faktoren ... all dies √§ndert das Verhalten des Programms bei jedem Start. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa1/702/1b2/aa17021b2f9cb3eb726ea37995ed4e2e.png"></a> </div><br>  <i><font color="gray">Manchmal ist es wirklich einfacher, das gesamte Programm zu entfernen, als nach einem Fehler zu suchen.</font></i>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heisenbugs</a></font></i> <br><br>  Das Verhalten √§ndert sich nicht nur bei jedem Start, sondern auch das Einf√ºgen von Ausgabe- oder Debug-Anweisungen kann das Verhalten √§ndern. Dies f√ºhrt zu ‚ÄûHeisenberg-Fehlern‚Äú (nicht deterministische, schwer reproduzierbare Fehler, die f√ºr die parallele Programmierung typisch sind), die auftreten und auf mysteri√∂se Weise verschwinden. <br><br>  Parallele Programmierung ist schwierig.  Es ist schwierig vorherzusagen, wie paralleler Code mit anderem parallelen Code interagieren wird.  Wenn Fehler auftreten, sind sie schwer zu finden und zu korrigieren.  Anstatt sich auf Tester zu verlassen, schauen wir uns M√∂glichkeiten an, Programme zu entwickeln und Sprachen zu verwenden, die das Schreiben von parallelem Code erleichtern. <br><br>  Zun√§chst formulieren wir das Konzept der "Thread-Sicherheit": <br><br><blockquote>  "Ein Datentyp oder eine statische Methode gilt als threadsicher, wenn sie sich beim Aufruf von mehreren Threads korrekt verh√§lt, unabh√§ngig davon, wie diese Threads ausgef√ºhrt werden, und keine zus√§tzliche Koordination durch den aufrufenden Code erfordert."  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT</a> </blockquote><br><h1>  Wie Programmiersprachen mit Parallelit√§t arbeiten </h1><br>  In Sprachen ohne statische Thread-Sicherheit m√ºssen Programmierer den Speicher, der f√ºr einen anderen Thread freigegeben ist, st√§ndig √ºberwachen und k√∂nnen ihn jederzeit √§ndern.  In der sequentiellen Programmierung lernen wir, globale Variablen zu vermeiden, wenn ein anderer Teil des Codes sie leise √§ndert.  Es ist unm√∂glich, Programmierer zu verpflichten, eine sichere √Ñnderung der gemeinsam genutzten Daten sowie eine manuelle Speicherverwaltung zu gew√§hrleisten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/3e3/5d2/e3e3e35d2775715a1f337d7c58aad7f7.gif"></div><br>  <i><font color="gray">"St√§ndige Wachsamkeit!"</font></i> <br><br>  In der Regel sind Programmiersprachen auf zwei Ans√§tze beschr√§nkt: <br><br><ol><li>  Einschr√§nkung der Ver√§nderlichkeit oder Einschr√§nkung des gemeinsamen Zugriffs <br></li><li>  Manuelle Gewindesicherheit (z. B. Schl√∂sser, Semaphoren) </li></ol><br>  Sprachen mit Thread-Einschr√§nkung begrenzen entweder 1 Thread f√ºr ver√§nderbare Variablen oder erfordern, dass alle gemeinsamen Variablen unver√§nderlich sind.  Beide Ans√§tze befassen sich mit dem Grundproblem des Datenrennens - falsch modifizierbare gemeinsam genutzte Daten -, aber die Einschr√§nkungen sind zu streng.  Um das Problem zu l√∂sen, haben Sprachen Synchronisationsprimitive auf niedriger Ebene erstellt, z. B. Mutexe.  Sie k√∂nnen verwendet werden, um threadsichere Datenstrukturen zu erstellen. <br><br><h3>  Python und globales Sperren durch Interpreter </h3><br>  Die Referenzimplementierung in Python und Cpython verf√ºgt √ºber eine Art Mutex namens Global Interpreter Lock (GIL), der alle anderen Threads blockiert, wenn ein Thread auf ein Objekt zugreift.  Multithreaded Python ist bekannt f√ºr seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ineffizienz</a> aufgrund der GIL-Latenz.  Daher arbeiten die meisten gleichzeitigen Python-Programme in mehreren Prozessen, sodass jedes seine eigene GIL hat. <br><br><h3>  Java- und Laufzeitausnahmen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> unterst√ºtzt die gleichzeitige Programmierung √ºber ein Shared-Memory-Modell.  Jeder Thread hat seinen eigenen Ausf√ºhrungspfad, kann jedoch auf jedes Objekt im Programm zugreifen: Der Programmierer muss den Zugriff zwischen den Threads mithilfe der integrierten Java-Grundelemente synchronisieren. <br><br>  Obwohl Java Bausteine ‚Äã‚Äãzum Erstellen threadsicherer Programme enth√§lt, wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-Sicherheit</a> <b>vom</b> Compiler <b>nicht garantiert</b> (im Gegensatz zur Speichersicherheit).  Wenn ein nicht synchronisierter Speicherzugriff auftritt (d. H. Ein Datenrennen), l√∂st Java eine Laufzeitausnahme aus, aber Programmierer m√ºssen Parallelit√§tsprimitive korrekt verwenden. <br><br><h3>  C ++ und das Gehirn des Programmierers </h3><br>  W√§hrend Python Rennbedingungen mit GIL vermeidet und Java zur Laufzeit Ausnahmen ausl√∂st, erwartet C ++, dass der Programmierer den Speicherzugriff manuell synchronisiert.  Vor C ++ 11 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">enthielt</a> die Standardbibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine Parallelit√§tsprimitive</a> . <br><br>  Die meisten Sprachen bieten Tools zum Schreiben von thread-sicherem Code, und es gibt spezielle Methoden zum Erkennen von Datenrennen und Rennstatus.  Es gibt jedoch keine Garantie f√ºr die Thread-Sicherheit und sch√ºtzt nicht vor Datenrennen. <br><br><h1>  Wie kann man das Problem von Rust l√∂sen? </h1><br>  Rust verfolgt einen facettenreichen Ansatz, um die Rennbedingungen mithilfe von Tenure-Regeln und sicheren Typen zu eliminieren und sich beim Kompilieren vollst√§ndig vor den Rennbedingungen zu sch√ºtzen. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel haben</a> wir das Konzept des Eigentums eingef√ºhrt, dies ist eines der Grundkonzepte von Rust.  Jede Variable hat einen eindeutigen Eigent√ºmer, und das Eigentum kann √ºbertragen oder ausgeliehen werden.  Wenn ein anderer Thread die Ressource √§ndern m√∂chte, √ºbertragen wir den Besitz, indem wir die Variable in einen neuen Thread verschieben. <br><br>  Beim Verschieben wird eine Ausnahme ausgel√∂st: Mehrere Threads k√∂nnen in denselben Speicher schreiben, jedoch niemals gleichzeitig.  Was passiert, wenn ein anderer Thread eine Variable ausleiht, da der Eigent√ºmer immer alleine ist? <br><br>  In Rust haben Sie entweder eine ver√§nderbare oder mehrere unver√§nderliche Anleihen.  Es ist nicht m√∂glich, ver√§nderbare und unver√§nderliche Anleihen (oder mehrere ver√§nderliche) gleichzeitig einzuf√ºhren.  In der Speichersicherheit ist es wichtig, dass Ressourcen ordnungsgem√§√ü freigegeben werden, und in der Thread-Sicherheit ist es wichtig, dass jeweils nur ein Thread das Recht hat, eine Variable zu √§ndern.  Dar√ºber hinaus beziehen sich in einer solchen Situation keine anderen Abl√§ufe auf veraltete Ausleihen: Es ist entweder eine Aufzeichnung oder eine gemeinsame Nutzung m√∂glich, jedoch nicht beides. <br><br>  Das Eigent√ºmerkonzept wurde entwickelt, um Speicherschwachstellen zu beheben.  Es stellte sich heraus, dass es auch Datenrennen verhindert. <br><br>  Obwohl viele Sprachen √ºber Speichersicherheitsmethoden verf√ºgen (z. B. Linkz√§hlung und Speicherbereinigung), basieren sie normalerweise auf manueller Synchronisierung oder auf Verboten der gleichzeitigen Freigabe, um Datenrennen zu verhindern.  Der Rust-Ansatz befasst sich mit beiden Arten von Sicherheit und versucht, das Hauptproblem der Ermittlung des akzeptablen Ressourcenverbrauchs zu l√∂sen und diese G√ºltigkeit beim Kompilieren sicherzustellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/88b/4d9/97288b4d9796a35d8cce9400c2dbfd73.png"></div><br><br><h3>  Aber warte!  Das ist noch nicht alles! </h3><br>  Eigent√ºmerregeln verhindern, dass mehrere Threads Daten in denselben Speicherort schreiben, und verhindern den gleichzeitigen Datenaustausch zwischen Threads und die Ver√§nderlichkeit. Dies bietet jedoch nicht unbedingt threadsichere Datenstrukturen.  Jede Datenstruktur in Rust ist entweder threadsicher oder nicht.  Dies wird √ºber ein Typsystem an den Compiler √ºbergeben. <br><br><blockquote>  "Ein gut getipptes Programm kann keinen Fehler machen."  - Robin Milner, 1978 </blockquote><br>  In Programmiersprachen beschreiben Typsysteme akzeptables Verhalten.  Mit anderen Worten, ein gut typisiertes Programm ist gut definiert.  Solange unsere Typen ausdrucksstark genug sind, um die beabsichtigte Bedeutung zu erfassen, verh√§lt sich ein gut typisiertes Programm wie beabsichtigt. <br><br>  Rust ist eine typsichere Sprache. Hier √ºberpr√ºft der Compiler die Konsistenz aller Typen.  Der folgende Code wird beispielsweise nicht kompiliert: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-string"><span class="hljs-string">"I am a string"</span></span>; x = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br><pre> <code class="rust hljs"> error[E0308]: mismatched types --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | x = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">// | ^ expected &amp;str, found integral variable | = note: expected type `&amp;str` found type `{integer}`</span></span></code> </pre> <br>  Alle Variablen in Rust sind vom Typ, der h√§ufig implizit ist.  Wir k√∂nnen auch neue Typen definieren und die F√§higkeiten jedes Typs mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Merkmalssystems beschreiben</a> .  Merkmale bieten eine Abstraktion der Schnittstelle.  Zwei wichtige integrierte Merkmale sind <code>Send</code> und <code>Sync</code> , die vom Compiler standardm√§√üig f√ºr jeden Typ bereitgestellt werden: <br><br><ul><li>  <code>Send</code> gibt an, dass die Struktur sicher zwischen Threads √ºbertragen werden kann (erforderlich, um den Besitz zu √ºbertragen). <br></li><li>  <code>Sync</code> zeigt an, dass Threads die Struktur sicher verwenden k√∂nnen. </li></ul><br>  Das folgende Beispiel ist eine vereinfachte Version des <a href="">Codes aus der Standardbibliothek</a> , die Threads erzeugt: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;Closure: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(closure: Closure){ ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = std::rc::Rc::new(<span class="hljs-number"><span class="hljs-number">6</span></span>); spawn(|| { x; });</code> </pre> <br>  Die <code>spawn</code> Funktion verwendet ein einzelnes Argument, das <code>closure</code> und erfordert einen Typ f√ºr letzteres, der die <code>Send</code> und <code>Fn</code> Merkmale implementiert.  Beim Versuch, einen Stream zu erstellen und den <code>closure</code> mit der Variablen <code>x</code> Compiler einen Fehler aus: <br><br><pre>  Fehler [E0277]: `std :: rc :: Rc &lt;i32&gt;` kann nicht sicher zwischen Threads gesendet werden
      -&gt; src / main.rs: 8: 1
       |
     8 |  spawn (move || {x;});
       |  ^^^^^ `std :: rc :: Rc &lt;i32&gt;` kann nicht sicher zwischen Threads gesendet werden
       |
       = help: Innerhalb von "[schloss@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]" ist das Merkmal "std :: marker :: Send" nicht implementiert f√ºr `std :: rc :: Rc &lt;i32&gt;`
       = Hinweis: Erforderlich, da es im Typ "[schlie√üung@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]" angezeigt wird
     Hinweis: Erforderlich f√ºr "Spawn" </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit den Merkmalen</a> <code>Send</code> und <code>Sync</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> das System vom Typ Rust verstehen, welche Daten gemeinsam genutzt werden k√∂nnen.  Durch die Aufnahme dieser Informationen in das Typensystem wird die Gewindesicherheit Teil der Typensicherheit.  Anstelle der Dokumentation wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-Sicherheit durch das Compiler-Gesetz implementiert</a> . <br><br>  Programmierer sehen deutlich gemeinsame Objekte zwischen Threads, und der Compiler garantiert die Zuverl√§ssigkeit dieser Installation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/af5/27e/35caf527e18989b41893e6fd37239dab.gif"></div><br><br>  Obwohl parallele Programmiertools in vielen Sprachen verf√ºgbar sind, ist es nicht einfach, Rennbedingungen zu verhindern.  Wenn Sie von Programmierern verlangen, dass sie Anweisungen komplex abwechseln und zwischen Threads interagieren, sind Fehler unvermeidlich.  Obwohl Sicherheitsverletzungen durch Threads und Speicher zu √§hnlichen Konsequenzen f√ºhren, verhindern herk√∂mmliche Speicherschutzma√ünahmen wie Linkz√§hlung und Speicherbereinigung die Rennbedingungen nicht.  Zus√§tzlich zur statischen Garantie der Speichersicherheit verhindert das Rust-Besitzmodell auch unsichere Daten√§nderungen und eine falsche gemeinsame Nutzung von Objekten zwischen Threads, w√§hrend das Typsystem die Thread-Sicherheit beim Kompilieren bietet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/429/fb9/92d429fb9c3812ddfdf115d71a3695ed.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441370/">https://habr.com/ru/post/de441370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441360/index.html">Openshift - Red-Hat-Handwerk</a></li>
<li><a href="../de441362/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 3</a></li>
<li><a href="../de441364/index.html">Konferenzprogramm Lua in Moskau 2019</a></li>
<li><a href="../de441366/index.html">Ben√∂tigt das Gesch√§ft die Erfahrung von Stylish Crossell: Retail Rocket in der Bildanalyse, um Empfehlungen zu bilden?</a></li>
<li><a href="../de441368/index.html">Wie sieht der bisher unsichtbare Mond von Neptun aus?</a></li>
<li><a href="../de441372/index.html">[Freitag] Wie man H√ºhnchen in Bezug auf die Physik br√§t</a></li>
<li><a href="../de441376/index.html">Jenseits der Reinheit: Was kann und was nicht Umkehrosmosemembran</a></li>
<li><a href="../de441378/index.html">Forscher von Google: Zum Schutz vor Spectre ist eine √Ñnderung der Prozessorarchitektur erforderlich. Software-Patches helfen nicht</a></li>
<li><a href="../de441380/index.html">7 Punkte Conversion-Wachstum oder wie man die Klickbarkeit von Schaltfl√§chen erh√∂ht</a></li>
<li><a href="../de441382/index.html">Chinesische Wissenschaftler haben einen piezoelektrischen Generator f√ºr Herzschrittmacher entwickelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>