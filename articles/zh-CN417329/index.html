<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏸 🔊 👩🏼‍🔧 你和布拉德·皮特是99％ 💞 📙 🕹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在线电影院Okko的分析部门中的我们希望尽可能自动地计算Alexander Nevsky的电影费用，并希望在空闲时间学习新事物并实现一些很酷的事物，由于某些原因，这些东西通常会转化为Telegram的机器人。 例如，在2018年FIFA世界杯开始之前，我们推出了一个机器人进行工作聊天，该机器人收集了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>你和布拉德·皮特是99％</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/417329/"><p><img src="https://habrastorage.org/webt/bg/8z/-p/bg8z-pmvxneor2kulnu9tmg3qoy.jpeg" alt="明天度假"></p><br><p> 在线电影院<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Okko</a>的分析部门中的我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">希望</a>尽可能自动地计算Alexander Nevsky的电影费用，并希望在空闲时间学习新事物并实现一些很酷的事物，由于某些原因，这些东西通常会转化为Telegram的机器人。 例如，在2018年FIFA世界杯开始之前，我们推出了一个机器人进行工作聊天，该机器人收集了关于最终位置分配的赌注，并在决赛之后根据预先制定的指标计算了结果并确定了获胜者。 克罗地亚尚未在前四名中排名第四。 </p><br><p> 最近，我们从整理TOP-10俄罗斯喜剧的空闲时间中致力于创建一个可以找到用户最喜欢的名人的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机器人</a> 。 在工作聊天中，每个人都非常欣赏这个主意，因此我们决定将其公开发布。 在本文中，我们简要回顾了这一理论，并讨论了我们的机器人的创建以及如何自己做。 </p><a name="habracut"></a><br><h1 id="nemnogo-teorii-v-osnovnom-v-kartinkah"> 一点理论（主要是图片） </h1><br><p>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前面的一篇文章中</a> ，我详细讨论了如何配置人脸识别系统。 有兴趣的读者可以点击该链接，我仅在下面概述要点。 </p><br><p> 因此，您有一张照片，其中甚至可能显示了一张脸，并且您想了解它是谁。 为此，您需要遵循4个简单的步骤： </p><br><ol><li> 选择与面部接壤的矩形。 </li><li> 突出显示面部关键点。 </li><li> 对齐并修剪脸部。 </li><li> 将面部图像转换为某种机器解释的表示形式。 </li><li> 将此视图与您可用的其他视图进行比较。 </li></ol><br><h3 id="vydelenie-lica"> 人脸选择 </h3><br><p> 尽管卷积神经网络最近学会了在图像中找到人脸，但并不比经典方法差，但是它们在速度和易用性方面仍不如经典<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HOG</a> 。 </p><br><p>  HOG-定向梯度直方图。 这个家伙将源图像的每个像素与其梯度相关联-梯度是像素亮度变化最大的方向的向量。 这种方法的优点是它不关心像素亮度的绝对值，仅它们的比率就足够了。 因此，将以近似相同的梯度直方图显示正常，变暗，光线不足和嘈杂的脸部。 </p><br><p><img src="https://habrastorage.org/webt/ke/_h/b_/ke_hb_cyd3odkvkwmqb0soancka.png" alt="定向面部粗糙度曲线直方图"></p><br><p>不必为每个像素计算梯度，而为每个小正方形<code>n</code> x <code>n</code>计算平均梯度就足够了。 然后，使用接收到的矢量场，您可以通过一个带有窗口的检测器，并为每个窗口确定面部在其中的可能性。 检测器可以是SVM，随机森林或其他任何东西。 </p><br><p><img src="https://habrastorage.org/webt/mz/hk/2y/mzhk2ycaurneywpy32a0linnm3o.png" alt="人脸检测"></p><br><h3 id="vydelenie-klyuchevyh-tochek"> 突出重点 </h3><br><p><img src="https://habrastorage.org/webt/wd/bi/dc/wdbidcix45fpf74iglc7f0f1rpg.png" alt="面子要点面子"></p><br><p> 关键点是有助于识别太空中人物的点。 虚弱和不安全的科学家通常需要68个关键点，在特别被忽视的情况下，甚至需要更多。 正常的和自信的男孩，每秒赚300k，总是有五个：眼睛和鼻子的内外角。 </p><br><p><img src="https://habrastorage.org/webt/6t/tb/-8/6ttb-8bq0ugffanbs0qcrihy2a4.jpeg" alt="老模因"></p><br><p> 这样的点可以例如通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">级联回归器</a>来提取。 </p><br><h3 id="vyravnivanie-lica"> 人脸对齐 </h3><br><p> 在儿童期应用程序胶合？ 这里的一切都完全相同：您建立仿射变换，将三个任意点转换为它们的标准位置。 鼻子可以保持原状，但眼睛可以计算其中心-这是准备好的三点。 </p><br><p><img src="https://habrastorage.org/webt/ms/3q/s7/ms3qs7hagupsaooas-eqrjjmqpy.png" alt="旋转脸"></p><br><h3 id="preobrazovanie-izobrazheniya-lica-v-vektor"> 将面部图像转换为矢量 </h3><br><p><img src="https://habrastorage.org/webt/ab/8w/jo/ab8wjody73ybfs_opnftpipbcz0.png" alt="模因少"></p><br><p> 自有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FaceNet</a>的文章发表以来已经过去了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三年</a> ，在这段时间里出现了许多有趣的训练方案和损失函数，但是在可用的OpenSource解决方案中，正是她占据了主导地位。 显然，整个过程是易于理解，实施和良好结果的结合。 至少要感谢在过去三年中将体系结构更改为ResNet的事实。 </p><br><p><img src="https://habrastorage.org/webt/af/pt/cx/afptcx5ixcu2r0_mjkckckpt2zo.jpeg" alt="新模因"></p><br><p>  FaceNet从三重示例中学习：（锚定，肯定，否定）。 锚定和正例属于一个人，而负数则被选为另一个人的脸，由于某种原因，该网络与第一个人太近。 损失函数的设计方式是纠正这种误解，将必要的示例汇总在一起，并从中删除不必要的示例。 </p><br><p><img src="https://habrastorage.org/webt/tp/yf/sw/tpyfswhgnyco4w_0ap3zy8i5zhs.png" alt="古驰网"></p><br><p><img src="https://habrastorage.org/webt/gj/fi/zq/gjfizqzcwjybnypbv-ugovr5hl0.png" alt="面部表情和德米特里·马里科夫（Dmitry Malikov）"></p><br><p> 网络最后一层的输出称为嵌入-人在特定小尺寸空间（通常为128维）中的代表表示。 </p><br><h3 id="sravnenie-lic"> 人脸比较 </h3><br><p> 训练有素的嵌入的优点在于，一个人的脸部显示在某个较小的空间邻域中，而远离其他人的脸部。 因此，对于该空间，您可以输入相似性的度量，即距离的倒数：欧几里得或余弦，具体取决于训练网络的距离。 </p><br><p><img src="https://habrastorage.org/webt/pn/u8/ba/pnu8barwdzvdryma24yezil7kvo.jpeg" alt="嵌入的完全人工样品"></p><br><p> 因此，我们事先需要为将要在其中进行搜索的所有人员建立嵌入，然后针对每个请求在其中找到最接近的向量。 或者，以另一种方式解决如果我们要使用一些更高级的业务逻辑，则找到<code>k</code>最接近的邻居的问题，其中<code>k</code>可能等于一个，也可能不等于。 拥有结果向量的人将与请求人最相似。 </p><br><p><img src="https://habrastorage.org/webt/6f/uz/nx/6fuznxdig3uiw1mjuv1eezx5h3u.jpeg" alt="面对面的相似性"></p><br><h3 id="kakuyu-biblioteku-ispolzovat"> 使用哪个库？ </h3><br><p> 选择实现管道各个部分的开放库非常棒。  <code>dlib</code>和<code>OpenCV</code>可以找到面孔和关键点，并且可以为任何大型神经网络框架找到经过预先训练的网络版本。 有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenFace</a>项目，您可以在其中选择满足速度和质量要求的体系结构。 但是只有一个库允许您在对三个高级函数的调用中实现人脸识别的所有5点： <code>dlib</code> 。 同时，它是用现代C ++编写的，使用BLAS，具有Python的包装器，不需要GPU，并且可以在CPU上快速运行。 我们的选择落在了她身上。 </p><br><h1 id="delaem-sobstvennogo-bota"> 制作自己的机器人 </h1><br><p> 在每一个有关创建机器人的指南中，都已经对这一部分进行了描述，但是一旦我们编写了相同的机器人，就必须重复一下。 我们写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@BotFather</a>并要求他为我们的新机器人添加令牌。 </p><br><p><img src="https://habrastorage.org/webt/um/qe/ew/umqeewdk64wtealh1ldudqsv0m8.png" alt="为什么使令牌xs模糊"></p><br><p> 令牌看起来像这样： <code>643075690:AAFC8ola8WRdhGbJtzjmkOhne1FGfu1BFg</code> 。 在对Telegram bot API的每个请求中，都必须授权。 </p><br><p> 我希望现阶段选择编程语言的人不会有任何疑问。 当然，您必须使用Haskell编写。 让我们从主模块开始。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Process main :: IO () main = do (<span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">handle</span></span>) &lt;- createProcess (<span class="hljs-title"><span class="hljs-title">shell</span></span> "<span class="hljs-title"><span class="hljs-title">python</span></span> <span class="hljs-title"><span class="hljs-title">bot</span></span>.<span class="hljs-title"><span class="hljs-title">py</span></span>") _ &lt;- waitForProcess handle putStrLn "Done!"</code> </pre> <br><p> 从代码中可以看到，将来我们将使用特殊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DSL</a>编写电报机器人。 该DSL上的代码写在单独的文件中。 安装域语言和所有必要的东西。 </p><br><pre> <code class="bash hljs">python -m venv .env <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> .env/bin/activate pip install python-telegram-bot</code> </pre> <br><p>  <code>python-telegram-bot</code>是目前最容易创建bot的框架。 它易于学习，灵活，可扩展，支持多线程。 不幸的是，目前还没有一个普通的异步框架，必须使用古老的线程代替神圣的协程。 </p><br><p><img src="https://habrastorage.org/webt/t2/8b/qv/t28bqvhxxznqmzsobr4hjmuxlta.jpeg" alt="初步是我唯一的神"></p><br><p> 使用<code>python-telegram-bot</code>启动<code>python-telegram-bot</code>很容易。 将以下代码添加到<code>bot.py</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def echo(bot, update): bot.send_message(chat_id=update.message.chat_id, text=update.message.text) updater = Updater(token=TOKEN) dispatcher = updater.dispatcher echo_handler = MessageHandler(Filters.text, echo) dispatcher.add_handler(echo_handler)</span></span></code> </pre> <br><p> 运行机器人。 出于调试目的，可以使用<code>python bot.py</code>完成此操作，而无需运行Haskell代码。 </p><br><p> 这种简单的漫游器能够保持最少的对话，因此，可以很容易地将其安排为前端开发人员。 </p><br><p><img src="https://habrastorage.org/webt/xs/pk/sm/xspksm1d8ehnslmqjsj33dzyekm.png" alt="与前端开发人员的典型对话"></p><br><p> 但是开发人员的前端已经太多了，因此我们将尽快将其终止，并继续实施主要功能。 为简单起见，我们的漫游器只会回复包含照片的消息，而忽略其他任何消息。 将代码更改为以下内容。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def handle_photo(bot, update): bot.send_message(chat_id=update.message.chat_id, text='nice') updater = Updater(token=TOKEN) dispatcher = updater.dispatcher photo_handler = MessageHandler(Filters.photo, handle_photo) dispatcher.add_handler(photo_handler) updater.start_polling() updater.idle()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/-8/1k/hq/-81khq5z9redcz29_ut7sunfrpg.png" alt="已经不是前端开发人员"></p><br><p> 当图片进入电报服务器时，它会自动调整为几个预定的尺寸。 该机器人又可以从<code>message.photo</code>列表中按升序排列的图像中下载任何大小的图像。 最简单的选择：拍摄最大的图像。 当然，在杂货店环境中，您需要考虑网络负载和负载时间，并选择最小尺寸的图像。 将图像下载代码添加到<code>handle_photo</code>函数的顶部。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io</code> </pre> <br><pre> <code class="python hljs">message = update.message photo = message.photo[~<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> io.BytesIO() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fd: file_id = bot.get_file(photo.file_id) file_id.download(out=fd) fd.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p> 图像已下载并在内存中。 为了解释它并以像素强度矩阵的形式呈现，我们使用<code>Pillow</code>和<code>numpy</code>库。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre> <br><p> 以下代码需要添加到<code>with</code>块中。 </p><br><pre> <code class="python hljs">image = Image.open(fd) image.load() image = np.asarray(image)</code> </pre> <br><p>  dlib的时间到了。 在功能之外，创建一个面部检测器。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib</code> </pre> <br><pre> <code class="python hljs">face_detector = dlib.get_frontal_face_detector()</code> </pre> <br><p> 在函数内部，我们使用它。 </p><br><pre> <code class="python hljs">face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p> 该功能的第二个参数表示在尝试检测面部之前必须应用的放大倍数。 它越大，检测器将能够检测到的面孔越小且越复杂，但是它将工作的时间越长。  <code>face_detects</code>以检测者对面部在其前方的信心的降序排列的面部列表。 在实际的应用程序中，您很可能希望应用一些选择主要人物的逻辑，在案例研究中，我们将仅限于选择第一个。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> face_detects: bot.send_message(chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">'no faces'</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p> 我们进入下一阶段-寻找关键点。 下载<a href="">经过训练的模型，</a>并将其负载移到功能之外。 </p><br><pre> <code class="python hljs">shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'path/to/shape_predictor_5_face_landmarks.dat'</span></span>)</code> </pre> <br><p> 找到关键点。 </p><br><pre> <code class="python hljs">landmarks = shape_predictor(image, face)</code> </pre> <br><p> 剩下的只有很小的东西：拉直脸，通过ResNet驱动脸并获得128维嵌入。 幸运的是，dlib允许您一次调用所有这些操作。 您只需要下载<a href="">预先训练的模型</a> 。 </p><br><pre> <code class="python hljs">face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'path/to/dlib_face_recognition_resnet_model_v1.dat'</span></span>)</code> </pre> <br><pre> <code class="python hljs">embedding = face_recognition_model.compute_face_descriptor(image, landmarks) embedding = np.asarray(embedding)</code> </pre> <br><p> 看看我们生活的美好时光。 卷积神经网络的整体复杂性，支持向量法以及应用于人脸识别的仿射变换都封装在三个库调用中。 </p><br><p> 由于我们尚不知道如何做有意义的事情，因此让我们将嵌入的平均值乘以一千，返回给用户。 </p><br><pre> <code class="python hljs">bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'yours embedding mean: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{embedding.mean() * </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1e3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">:</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">.2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">f}</span></span></span><span class="hljs-string">'</span></span> )</code> </pre> <br><p><img src="https://habrastorage.org/webt/ud/av/o6/udavo6i5srwrl93jbopenn84tae.png" alt="我不知道我在做什么"></p><br><p> 为了使我们的机器人能够确定用户喜欢哪些名人，我们现在需要为每个名人找到至少一张照片，在其上嵌入图片并将其保存在某处。 我们只会将10位名人添加到我们的训练机器人中，手动查找他们的照片并将其放在<code>photos</code>目录中。 它应该是这样的： </p><br><p><img src="https://habrastorage.org/webt/yz/rd/1o/yzrd1ockvqezvybwzo-yulsivqq.png" alt="看，我没有足够的钱购买MacBook。"></p><br><p> 如果您想在数据库中拥有一百万名人，那么所有内容看起来都将完全一样，只有更多的文件，而且您不太可能用手寻找它们。 现在，让我们使用我们已经知道的<code>dlib</code>调用创建<code>build_embeddings.py</code>实用程序，并将名人嵌入及其名称以二进制格式保存。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image face_detector = dlib.get_frontal_face_detector() shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'assets/shape_predictor_5_face_landmarks.dat'</span></span>) face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'assets/dlib_face_recognition_resnet_model_v1.dat'</span></span>) fs = os.listdir(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>) es = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs: print(f) image = np.asarray(Image.open(os.path.join(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>, f))) face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>] landmarks = shape_predictor(image, face) embedding = face_recognition_model.compute_face_descriptor(image, landmarks, num_jitters=<span class="hljs-number"><span class="hljs-number">10</span></span>) embedding = np.asarray(embedding) name, _ = os.path.splitext(f) es.append((name, embedding)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: pickle.dump(es, f)</code> </pre> <br><p> 将嵌入加载添加到我们的机器人代码中。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: star_embeddings = pickle.load(f)</code> </pre> <br><p> 通过详尽的搜索，我们将找出谁是我们的用户。 </p><br><pre> <code class="python hljs">ds = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> star_embeddings: distance = np.linalg.norm(embedding - emb) ds.append((name, distance)) best_match, best_distance = min(ds, key=itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>)) bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'your look exactly like *</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{best_match}</span></span></span><span class="hljs-string">*'</span></span>, parse_mode=<span class="hljs-string"><span class="hljs-string">'Markdown'</span></span> )</code> </pre> <br><p> 请注意，我们使用欧几里德距离作为距离，因为 借助dlib中的网络进行了精确的培训。 </p><br><p><img src="https://habrastorage.org/webt/yd/fl/wi/ydflwigundswx6_qbctjir_itge.png" alt="我对这篇文章感到沮丧失望"></p><br><p> 仅此而已，恭喜！ 我们创建了一个简单的机器人，可以确定用户喜欢的名人。 寻找更多照片，添加品牌，可扩展性，少量日志记录以及一切都可以在生产中发布仍然是剩下的。 所有这些主题都太多了，以致于无法与庞大的代码清单进行详细讨论，因此，我将在下一部分中以问答形式概述要点。 </p><br><p> 完整的培训机器人代码可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上获得</a> 。 </p><br><h1 id="rasskazyvaem-pro-nashego-bota"> 我们谈论我们的机器人 </h1><br><h3 id="skolko-u-vas-v-baze-znamenitostey-gde-vy-ih-nashli"> 您的数据库中有多少名人？ 您在哪里找到的？ </h3><br><p> 创建机器人时，最合乎逻辑的决定似乎是从我们内部的内容库中获取名人数据。 她以图表的形式存储电影以及与电影相关的所有实体，包括演员和导演。 对于每个人，我们都可以从iCloud，相关影片和别名中了解她的姓名，登录名和密码，这些信息可用于生成指向该网站的链接。 在清理并仅提取必要的信息之后， <code>json</code>文件仍然如下： </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"tilda-swinton"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"michael-shannon"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">22</span></span> }, ... ]</code> </pre> <br><p> 目录中有<strong>22,000个</strong>此类条目。 顺便说一句，不是目录，而是目录。 </p><br><h3 id="gde-nayti-fotografii-dlya-vseh-etih-lyudey"> 在哪里可以找到所有这些人的照片？ </h3><br><p><img src="https://habrastorage.org/webt/_n/5i/pl/_n5iplsi4yqnrm2lpvzyjwhjigm.jpeg" alt="在危险时期我们生活"></p><br><p> 好吧，你知道， <em>在这里和那里</em> 。 例如，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很棒的库</a> ，它允许您从Google上传图片查询结果。  2万2千人-人数不多，我们使用56个视频流在不到一个小时的时间内为他们下载了照片。 </p><br><p> 在下载的照片中，您需要丢弃格式错误的破碎，嘈杂的照片。 然后只留下那些有脸并且这些脸满足特定条件的脸：眼睛之间的最小距离，头的倾斜度。 所有这些给我们留下了<strong>12,000</strong>张照片。 </p><br><p> 在目前的12,000名名人中，用户仅发现2名，也就是说，大约有8,000名名人仍然与众不同。 不要就这样离开它！ 打开电报并找到它们全部。 </p><br><h3 id="kak-opredelit-procent-shozhesti-dlya-evklidovoy-distancii"> 如何确定欧几里得距离的相似度百分比？ </h3><br><p> 好问题！ 的确，与余弦相反，欧几里德距离不受限制。 因此，出现一个合理的问题，如何向用户展示比“恭喜，您的嵌入与安吉丽娜·朱莉的嵌入之间的距离是0.27635462738”更有意义？ 我们的团队成员之一提出了以下简单而巧妙的解决方案。 如果您建立嵌入之间的距离分布，那将是正常的。 因此，对于他来说，您可以计算平均值和标准偏差，然后根据这些参数，为每个用户考虑有<em>多少百分比的人不太喜欢他们的名人</em> 。 这等效于对从<code>d</code>到正无穷大的概率密度函数进行积分，其中<code>d</code>是用户与名人集会之间的距离。 </p><br><p><img src="https://habrastorage.org/webt/fh/yc/4r/fhyc4r87otryweg9v-xznackhfq.png" alt="这不是天生的"></p><br><p> 这是我们使用的确切功能： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_transform_dist_to_sim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dist)</span></span></span><span class="hljs-function">:</span></span> p = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> + erf((dist - self._dist_mean) / (self._dist_std * <span class="hljs-number"><span class="hljs-number">1.4142135623730951</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(min(<span class="hljs-number"><span class="hljs-number">1</span></span> - p, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), self._min_similarity)</code> </pre> <br><h3 id="neuzheli-nuzhno-perebirat-spisok-vseh-embedingov-chtoby-nayti-sovpadenie"> 真的有必要遍历所有工会的名单以找到匹配的人吗？ </h3><br><p> 当然不是，这不是最佳选择，并且需要很多时间。 优化计算的最简单方法是使用矩阵运算。 您可以从它们组成一个矩阵，然后从矩阵中减去一个向量，而不是彼此减去向量，然后按行计算L2范数。 </p><br><pre> <code class="python hljs">scores = np.linalg.norm(emb - embeddings, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_idx = scores.argmax()</code> </pre> <br><p> 这已经极大地提高了生产率，但是事实证明，您甚至可以更快。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nmslib</a>库会使<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">搜索</a>精度降低一些，从而可以大大加快搜索速度。 它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HNSW</a>方法近似搜索<code>k</code>最近的邻居。 对于所有可用向量，应建立一个所谓的索引，然后在其中进行搜索。 您可以如下创建并保存欧几里得距离的索引： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nmslib index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(embeddings): index.addDataPoint(idx, emb) index_time_params = { <span class="hljs-string"><span class="hljs-string">'indexThreadQty'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'skip_optimized_index'</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'delaunay_type'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'efConstruction'</span></span>: <span class="hljs-number"><span class="hljs-number">2000</span></span> } index.createIndex(index_time_params, print_progress=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) index.saveIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>)</code> </pre> <br><p> 参数<code>M</code>和<code>efConstruction</code>在<a href="">文档</a>中进行了详细描述，并根据所需的准确性，索引构建时间和搜索速度通过实验进行选择。 使用索引之前，必须下载： </p><br><pre> <code class="python hljs">index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) index.loadIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>) query_time_params = {<span class="hljs-string"><span class="hljs-string">'efSearch'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>} index.setQueryTimeParams(query_time_params)</code> </pre> <br><p>  <code>efSearch</code>参数影响查询的准确性和速度，并且可能与<code>efConstruction</code>不匹配。 现在您可以提出请求。 </p><br><pre> <code class="python hljs">ids, dists = index.knnQuery(embedding, k=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_dx = ids[<span class="hljs-number"><span class="hljs-number">0</span></span>] best_dist = dists[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p> 在我们的例子中， <code>nmslib</code>比矢量线性版本快20倍，平均处理一个请求<code>0.005</code>秒。 </p><br><h3 id="kak-sdelat-moego-bota-gotovym-k-prodakshenu"> 如何使我的机器人准备投入生产？ </h3><br><h5 id="1-asinhronnost">  1.异步 </h5><br><p> 首先，您需要使<code>handle_photo</code>函数异步。 就像我已经说过的那样， <code>python-telegram-bot</code>为此提供了多线程，并实现了一个方便的装饰器。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.dispatcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> run_async @run_async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_photo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bot, update)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br><p> 现在，框架本身将在其池中的单独线程中启动处理程序。 创建<code>Updater</code>时设置池大小。  “但是在python中没有多线程！” 你们中最不耐烦的人已经惊呼了。 这并非完全正确。 由于存在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GIL，因此</a>常规Python代码实际上不能并行执行，但是GIL被释放以等待所有IO操作，并且还可以由使用C扩展的库释放。 </p><br><p> 现在分析一下<code>handle_photo</code>函数：它仅包括等待IO操作（上传照片，发送响应，从磁盘读取照片等）以及从<code>numpy</code> ， <code>nmslib</code>和<code>Pillow</code>库调用函数。 </p><br><p> 我没有提到<code>dlib</code>是有原因的。 释放GIL不需要调用本机代码的库，而<code>dlib</code>此权利。 她不需要这个锁，她只是不放手。 作者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说</a>他会很乐意接受适当的请求，但是我太懒了。 </p><br><h5 id="2-mnogoprocessnost">  2.多重处理 </h5><br><p> 处理<code>dlib</code>的最简单方法是将模型封装在单独的实体中，然后在单独的进程中运行它。 并且更好地在过程池中。 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> model model = Model(config) model.load_state() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.process_image(image) pool = multiprocessing.Pool(<span class="hljs-number"><span class="hljs-number">8</span></span>, initializer=_worker_initialize, initargs=(config,))</code> </pre> <br><pre> <code class="python hljs">result = pool.apply(_worker_do, (image,))</code> </pre> <br><h5 id="3-zhelezo">  3.铁 </h5><br><p> 如果您的机器人需要不断从磁盘读取照片，请确保该磁盘是SSD。 甚至将它们安装到RAM中。 对电报服务器执行Ping操作，信道质量也很重要。 </p><br><h5 id="4-flood-control">  4.防洪 </h5><br><p> 电报不允许漫游器每秒发送30条以上的消息。 如果您的漫游器很流行，并且很多人同时使用它，那么很容易就可以暂停几秒钟的禁令，这对许多用户来说都是令人失望的。 为了解决这个问题， <code>python-telegram-bot</code>为我们提供了一个队列，该队列不能每秒发送超过指定的消息限制，并在发送之间保持相等的间隔。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.messagequeue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageQueue</code> </pre> <br><p> 要使用它，您需要定义自己的机器人并在创建<code>Updater</code>时将其替换。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.utils.promise <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Promise <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MQBot</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bot)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._message_queue = MessageQueue( all_burst_limit=<span class="hljs-number"><span class="hljs-number">30</span></span>, all_time_limit_ms=<span class="hljs-number"><span class="hljs-number">1000</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._message_queue.stop() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: super().__del__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> is_group = kwargs.get(<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._message_queue(Promise(super().send_message, args, kwargs), is_group)</code> </pre> <br><pre> <code class="python hljs">bot = MQBot(token=TOKEN) updater = Updater(bot=bot)</code> </pre> <br><h5 id="5-web-hooks">  5.网页挂钩 </h5><br><p> 在产品环境中，应始终使用Web Hooks代替Long Polling，以从Telegram服务器接收更新。 它的全部内容和用法可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>阅读。 </p><br><h5 id="6-melochi">  6.琐事 </h5><br><p>              <code>json</code> .    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ultrajson</a> . </p><br><p>          IO-:    ,  ,  .      ,         . </p><br><h5 id="6-analitika"> 6.  </h5><br><p>   ,   .        ,   ,  ,       .        ,        . </p><br><p> , ,      BI-tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Splunk</a>     . </p><br><p><img src="https://habrastorage.org/webt/oh/8e/ve/oh8eve_hczr4pahrzum56fonxxg.jpeg" alt="广告板（请向我们扩展许可证）"></p><br><p>   ,         .     ,                       . </p><br><p>    ,         .      ,    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@OkkoFaceBot</a> . </p><br><p><del>        </del> ,     . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417329/">https://habr.com/ru/post/zh-CN417329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417319/index.html">机箱中的系统或微处理器的实际覆盖范围</a></li>
<li><a href="../zh-CN417321/index.html">我们如何在开发人员中寻找在线课程的老师？</a></li>
<li><a href="../zh-CN417323/index.html">确保100％项目可访问性的问题</a></li>
<li><a href="../zh-CN417325/index.html">网络学开放日，数据科学主题</a></li>
<li><a href="../zh-CN417327/index.html">预算监控服务器机房中的温度（带有Linux + PRTG的MP707 + nettop）</a></li>
<li><a href="../zh-CN417331/index.html">安全周26：更新的Spectre，现在记录高雅</a></li>
<li><a href="../zh-CN417333/index.html">社会评价</a></li>
<li><a href="../zh-CN417337/index.html">原子交换的工作原理和应用特点</a></li>
<li><a href="../zh-CN417339/index.html">3DTouch-在iPhone上缩放：完成</a></li>
<li><a href="../zh-CN417345/index.html">借助思科可见性进行威胁搜寻</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>