<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº üåï üèáüèæ Usando GtkApplication. Recursos de renderiza√ß√£o Librsvg üôè üë´ ü¶è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resumo do artigo. 



- Usando GtkApplication. Aplicativo de estrutura de arame. Makefile. 
- Renderiza√ß√£o pela biblioteca librsvg. 
- Exporte uma ima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando GtkApplication. Recursos de renderiza√ß√£o Librsvg</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435564/">  Resumo do artigo. <br><br><ul><li>  Usando GtkApplication.  Aplicativo de estrutura de arame.  Makefile. </li><li>  Renderiza√ß√£o pela biblioteca librsvg. </li><li>  Exporte uma imagem para GtkImage e dimensione-a. </li><li>  Escala SVG com recursos personalizados. </li><li>  Obtendo o caminho completo nos aplicativos. </li><li>  Testes de desempenho GtkDrawingArea vs GtkImage. </li></ul><a name="habracut"></a><br>  Anteriormente, havia artigos (n√£o os meus) no hub GTK + que usavam a fun√ß√£o void gtk_main (void) nos exemplos;  A classe GtkApplication permite destacar explicitamente as fun√ß√µes de retorno de chamada application_activate e application_shutdown.  Com gtk_main, voc√™ precisa conectar explicitamente gtk_main_quit para que, ao clicar na cruz, o aplicativo seja encerrado.  GtkApplication finaliza o aplicativo clicando na cruz, o que √© mais l√≥gico.  A estrutura do aplicativo em si consiste em main.h, Makefile, string.gresource.xml, main.c. <br><br>  <b>main.h</b> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; typedef struct{ GtkApplication *restrict app; GtkWidget *restrict win; GtkBuilder *restrict builder; }appdata; appdata data; appdata *data_ptr; #endif</span></span></span></span></code> </pre> <br>  <b>Makefile</b> <br><br>  universal aqui, ele permite que voc√™ compile todos os arquivos de origem sem especificar nomes de arquivos espec√≠ficos, mas se houver arquivos extras na pasta, o compilador jurar√°. <br>  Voc√™ tamb√©m pode usar CC = g ++ -std = c ++ 11, mas colocar as fun√ß√µes de retorno de chamada <br>  externo "C". <br><br><pre> <code class="cmake hljs">CC = gcc -std=c99 PKGCONFIG = $(shell which pkg-config) CFLAGS = $(shell $(PKGCONFIG) --cflags gio-<span class="hljs-number"><span class="hljs-number">2.0</span></span> gtk+-<span class="hljs-number"><span class="hljs-number">3.0</span></span> librsvg-<span class="hljs-number"><span class="hljs-number">2.0</span></span>) -rdynamic -O3 LIBS = $(shell $(PKGCONFIG) --libs gio-<span class="hljs-number"><span class="hljs-number">2.0</span></span> gtk+-<span class="hljs-number"><span class="hljs-number">3.0</span></span> gmodule-<span class="hljs-number"><span class="hljs-number">2.0</span></span> librsvg-<span class="hljs-number"><span class="hljs-number">2.0</span></span> epoxy) -lm GLIB_COMPILE_RESOURCES = $(shell $(PKGCONFIG) --variable=glib_compile_resources gio-<span class="hljs-number"><span class="hljs-number">2.0</span></span>) SRC = $(wildcard *.c) GEN = gresources.c BIN = main ALL = $(GEN) $(SRC) OBJS = $(ALL:.c=.o) all: $(BIN) gresources.c: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.gresource.xml $(shell $(GLIB_COMPILE_RESOURCES) --sourcedir=. --generate-dependencies <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.gresource.xml) $(GLIB_COMPILE_RESOURCES) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.gresource.xml --<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>=$@ --sourcedir=. --generate-source %.o: %.c $(CC) $(CFLAGS) -c -o $(@F) $&lt; $(BIN): $(OBJS) $(CC) -o $(@F) $(OBJS) $(LIBS) clean: @rm -f $(GEN) $(OBJS) $(BIN)</code> </pre><br>  <b>string.gresource.xml</b> <br><br>  serve para incluir recursos no arquivo execut√°vel; nesse caso, √© um arquivo de descri√ß√£o da interface window.glade <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresource</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">prefix</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/com/example/YourApp"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">preprocess</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xml-stripblanks"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">compressed</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span>window.glade<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresource</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresources</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  <b>main.c</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> GtkBuilder* builder_init(void) { GError *</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = NULL; data.builder = gtk_builder_new(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!gtk_builder_add_from_resource (data.builder, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/com/example/YourApp/window.glade"</span></span></span><span class="hljs-meta">, &amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     g_critical ("   : %s", error-&gt;message); g_error_free (error); } gtk_builder_connect_signals (data.builder,NULL); return data.builder; } void application_activate(GtkApplication *application, gpointer user_data) { GtkBuilder *builder=builder_init(); data_ptr=&amp;data; data.win=GTK_WIDGET(gtk_builder_get_object(builder, "window1")); gtk_widget_set_size_request(data.win,360,240); gtk_application_add_window(data.app,GTK_WINDOW(data.win)); gtk_widget_show_all(data.win); } void application_shutdown(GtkApplication *application, gpointer user_data) { g_object_unref(data.builder); } int main (int argc, char *argv[]) { gtk_init (&amp;argc, &amp;argv); gint res; data.app = gtk_application_new("gtk.org", G_APPLICATION_FLAGS_NONE); g_signal_connect(data.app, "activate", G_CALLBACK(application_activate), NULL); g_signal_connect(data.app, "shutdown", G_CALLBACK(application_shutdown), NULL); res = g_application_run(G_APPLICATION(data.app), 0, NULL); return 0; }</span></span></span></span></code> </pre><br>  No primeiro argumento da fun√ß√£o gtk_application_new, voc√™ pode colocar qualquer texto, mas ele n√£o funcionou sem um ponto.  Este exemplo tamb√©m omite o arquivo window.glade, que pode ser criado no editor da interface do usu√°rio do Glade. <br><br>  Dividimos a janela com o cont√™iner GtkBox em 2 partes, em uma delas colocamos GtkDrawingArea, na outra: <br><br><img src="https://habrastorage.org/webt/d4/_f/qy/d4_fqyifbcg7k12sfrrrw6d-xw0.png"><br><br>  Como resultado, os dados do aplicativo ser√£o alterados <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> GtkApplication *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> app; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> win; GtkBuilder *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> builder; GtkDrawingArea *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> draw; GtkImage *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> image; GtkEventBox *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> eventbox1; RsvgHandle *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> svg_handle_image; RsvgHandle *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> svg_handle_svg; GdkPixbuf *pixbuf; <span class="hljs-keyword"><span class="hljs-keyword">cairo_t</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> cr; <span class="hljs-keyword"><span class="hljs-keyword">cairo_surface_t</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> surf; }appdata;</code> </pre><br>  E, consequentemente, inicializa√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application_activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkApplication *application, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ GtkBuilder *builder=builder_init(); data_ptr=&amp;data; data.win=GTK_WIDGET(gtk_builder_get_object(builder, <span class="hljs-string"><span class="hljs-string">"window1"</span></span>)); data.draw=GTK_DRAWING_AREA(gtk_builder_get_object(builder, <span class="hljs-string"><span class="hljs-string">"drawingarea1"</span></span>)); data.image=GTK_IMAGE(gtk_builder_get_object(builder, <span class="hljs-string"><span class="hljs-string">"image1"</span></span>)); gtk_widget_set_size_request(data.win,<span class="hljs-number"><span class="hljs-number">640</span></span>,<span class="hljs-number"><span class="hljs-number">480</span></span>); gtk_application_add_window(data.app,GTK_WINDOW(data.win)); gtk_widget_show_all(data.win); }</code> </pre><br>  Adicione o caminho #include &lt;librsvg-2.0 / librsvg / rsvg.h&gt;.  (Os pacotes librsvg e librsvg-dev devem estar instalados). <br><br>  Os nomes das fun√ß√µes de retorno de chamada s√£o retirados do arquivo .glade, a fun√ß√£o √© respons√°vel por isso <br>  gtk_builder_connect_signals (data.builder, NULL); <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawingarea1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_svg) {data.svg_handle_svg=rsvg_handle_new_from_file(<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);} gboolean result=rsvg_handle_render_cairo(data.svg_handle_svg,cr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result&amp;&amp;cr) {cairo_stroke(cr);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  Em algumas situa√ß√µes (como HMI), pode ser necess√°rio redimensionar o SVG.  Pode <br>  altere os par√¢metros de largura e altura no arquivo SVG.  Ou transfira para GtkPixbuf e j√° existe para fazer o dimensionamento.  Como o GtkImage n√£o √© herdado do GtkBin, ele n√£o pode ter seus pr√≥prios eventos do tipo ButtonClick (eventos relacionados ao cursor).  H√° um cont√™iner vazio para isso - GtkEventBox.  E o desenho em si pode ser pendurado diretamente na GtkImage. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_image) { data.svg_handle_image=rsvg_handle_new_from_file(<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); data.surf=cairo_image_surface_create_from_png(<span class="hljs-string"><span class="hljs-string">"2.png"</span></span>); data.pixbuf=rsvg_handle_get_pixbuf(data.svg_handle_image); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.pixbuf) { cairo_set_source_surface(cr,data.surf,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); GdkPixbuf *dest=gdk_pixbuf_scale_simple (data.pixbuf,<span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">250</span></span>,GDK_INTERP_BILINEAR); gtk_image_set_from_pixbuf (data.image,dest); g_object_unref(dest); cairo_paint(cr); } }</code> </pre><br>  Esta fun√ß√£o carrega a imagem de fundo (2.png), que geralmente representa <br>  Desenho 1x1 com um pixel transparente.  E ent√£o um desenho (pixbuf) √© renderizado nessa superf√≠cie e, em seguida, ocorre o zoom e a exporta√ß√£o para a imagem (imagem). <br><br>  E n√£o devemos esquecer de limpar a mem√≥ria. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application_shutdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkApplication *application, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ cairo_surface_destroy(data.surf); g_object_unref(data.svg_handle_image); g_object_unref(data.svg_handle_svg); g_object_unref(data.pixbuf); g_object_unref(data.builder); }</code> </pre><br>  O resultado √©: <br><br><img src="https://habrastorage.org/webt/hw/bn/yi/hwbnyikg3opargq5pg5pbzqnweg.png"><br>  Se os valores de largura e altura estiverem definidos nos par√¢metros SVG, a imagem poder√° ficar emba√ßada ao exportar para png. <br><br>  Voc√™ tamb√©m pode alterar programaticamente a largura e a altura.  Para isso, criei arquivos separados <br>  svg_to_pixbuf_class.c e svg_to_pixbuf_class.h.  Ou seja, o arquivo √© aberto em altera√ß√µes de largura, altura. <br><br>  Ele √© salvo em / dev / shm /.  Depois de exportar as informa√ß√µes para svg_handle, voc√™ precisa excluir o pr√≥prio arquivo e o caminho da linha para o arquivo.  Valores fracion√°rios de largura / comprimento tamb√©m s√£o suportados. <br><br><div class="spoiler">  <b class="spoiler_title">svg_to_pixbuf_class.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;gtk/gtk.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;math.h&gt; #include &lt;stdbool.h&gt; int char_to_digit(char num) { switch(num) { case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case '.': return -1; default: return -2; } } //     text double read_num_in_text(char* text) { double result=0; int i=0; bool fractional_flag=FALSE; char whole_part[16]={0}; char whole_digits=0; char fractional_part[16]={0}; char fractional_digits=0; while(char_to_digit(text[i])!=-2) { if(char_to_digit(text[i])!=-1&amp;&amp;!fractional_flag) { whole_part[whole_digits]=char_to_digit(text[i]); printf("text_num=%d|%c\n",char_to_digit(text[i]),text[i]); ++whole_digits; ++i; } else { if(char_to_digit(text[i])==-1) { printf("fractional flag is true\n"); fractional_flag=TRUE; ++i; } else { fractional_part[fractional_digits]=char_to_digit(text[i]); ++fractional_digits; printf("frac_digit=%d|%c\n",char_to_digit(text[i]),text[i]); ++i; } } } ///    i=whole_digits; result=whole_part[whole_digits]; while(i&gt;0) { --i; printf("whole=%d\n",whole_part[i]); result=result+pow(10,whole_digits-i-1)*whole_part[i]; } i=0; while(i&lt;=fractional_digits) { result=result+pow(0.1,i+1)*fractional_part[i]; ++i; } printf("result_read_num=%lf\n",result); return result; } //  ,    // int count_of_digits_for_delete(char* text) { int i=0; bool fractional_flag=FALSE; char whole_part[16]={0}; int whole_digits=0; char fractional_part[16]={0}; int fractional_digits=0; while(char_to_digit(text[i])!=-2) { if(char_to_digit(text[i])!=-1&amp;&amp;!fractional_flag) { whole_part[whole_digits]=char_to_digit(text[i]); printf("text_num=%d|%c\n",char_to_digit(text[i]),text[i]); ++whole_digits; ++i; } else { if(char_to_digit(text[i])==-1) { printf("fractional flag is true\n"); fractional_flag=TRUE; ++i; } else { fractional_part[fractional_digits]=char_to_digit(text[i]); ++fractional_digits; printf("frac_digit=%d|%c\n",char_to_digit(text[i]),text[i]); ++i; } } } if(fractional_flag) return whole_digits+1+fractional_digits; else return whole_digits; } //      /dev/shm //      char* create_dump_file(char *file_with_path) { char *file=NULL; int i=0; while(file_with_path[i]!='\0') {++i;} while(file_with_path[i]!='/'&amp;&amp;i&gt;0) {--i;} file=file_with_path+i; GString *string=g_string_new("test -f /dev/shm"); g_string_append(string,file); g_string_append(string,"|| touch /dev/shm/"); g_string_append(string,file); system(string-&gt;str); ///  -  GString *full_path=g_string_new("/dev/shm"); g_string_append(full_path,file); char *result=g_string_free(full_path,FALSE); return result; } //result must be freed with g_string_free GString* read_file_in_buffer(char *file_with_path) { FILE *input = NULL; struct stat buf; int fh, result; char *body=NULL; // GString *resultat=g_string_new(""); fh=open(file_with_path, O_RDONLY); result=fstat(fh, &amp;buf); if (result !=0) printf("  \n"); else { printf("%s",file_with_path); printf(" : %ld\n", buf.st_size); printf(" : %lu\n", buf.st_dev); printf(" : %s", ctime(&amp;buf.st_atime)); input = fopen(file_with_path, "r"); if (input == NULL) { printf("Error opening file"); } body=(char*)calloc(buf.st_size+64,sizeof(char)); //    //    if(body==NULL) { printf("      body\n"); } int size_count=fread(body,sizeof(char),buf.st_size, input); if(size_count!=buf.st_size) printf("   "); resultat=g_string_append(resultat,body); free(body); } fclose(input); return resultat; } void* write_string_to_file(char* writed_file, char* str_for_write, int lenght) { FILE * ptrFile = fopen (writed_file ,"wb"); size_t writed_byte_count=fwrite(str_for_write,1,lenght,ptrFile); //if(writed_byte_count&gt;4) return TRUE; //else return FALSE; fclose(ptrFile); } //      g_free char* get_resized_svg(char *file_with_path, int width, int height) { char *writed_file=create_dump_file(file_with_path); //       GString *body=read_file_in_buffer(file_with_path); char *start_search=NULL; char *end_search=NULL; char *width_start=NULL; char *width_end=NULL; char *height_start=NULL; char *height_end=NULL; start_search=strstr(body-&gt;str,"&lt;svg"); int j=0; //   if(start_search) { end_search=strstr(start_search,"&gt;"); if(end_search) { ///  width width_start=strstr(start_search,"width"); width_end=width_start+strlen("width"); ///   width    while(width_end[j]==0x0A||width_end[j]==0x20) ++j; if(width_end[j]=='=') ++j; while(width_end[j]==0x0A||width_end[j]==0x20) ++j; if(width_end[j]!='"') printf("   svg.     width=%c\n",width_end[j]); else ++j; ///  ///  ,   gssize size=count_of_digits_for_delete(width_end+j); ///   (1  - 1 ) gssize pos=width_end+j-body-&gt;str; ///       g_string_erase(body,pos,size); char width_new[8]; g_snprintf(width_new,8,"%d",width); g_string_insert(body, pos, width_new); ///  height height_start=strstr(start_search,"height"); height_end=height_start+strlen("height"); ///   height    j=0; while(height_end[j]==0x0A||height_end[j]==0x20) ++j; if(height_end[j]=='=') ++j; while(height_end[j]==0x0A||height_end[j]==0x20) ++j; if(height_end[j]!='"') printf("   svg. \    height=%c%c%c\n",height_end[j-1],height_end[j],height_end[j+1]); else ++j; ///  ///  ,   size=count_of_digits_for_delete(height_end+j); ///   (1  - 1 ) pos=height_end+j-body-&gt;str; ///       g_string_erase(body,pos,size); char height_new[8]; g_snprintf(height_new,8,"%d",height); g_string_insert(body, pos, height_new); ///      dev/shm/ ///   write_string_to_file(writed_file,body-&gt;str,strlen(body-&gt;str)); return writed_file; //g_free(writed_file); g_string_free(body,TRUE); } else printf(" :      svg"); } } void resized_svg_free(char *path) { if (remove (path)==-1 ) { printf("    %s\n",path); } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">svg_to_pixbuf_class.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SVG_TO_PIXBUF_CLASS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SVG_TO_PIXBUF_CLASS_H void resized_svg_free(char *path); char* get_resized_svg(char *file_with_path, int width, int height); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//result must be freed with g_free() #endif</span></span></span></span></code> </pre><br></div></div><br>  Agora redimensione o lado esquerdo (que √© GtkDrawingArea) <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawingarea1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_svg) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* path=get_resized_svg(<span class="hljs-string"><span class="hljs-string">"/home/alex/svg_habr/compassmarkings.svg"</span></span>, <span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">220</span></span>); data.svg_handle_svg=rsvg_handle_new_from_file(path,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); resized_svg_free(path); g_free(path); } gboolean result=rsvg_handle_render_cairo(data.svg_handle_svg,cr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result&amp;&amp;cr) {cairo_stroke(cr);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  Como voc√™ pode ver, h√° um recurso desagrad√°vel - o caminho completo.  Ou seja, vale a pena mover a pasta, pois a parte esquerda (que GtkDrawingArea) deixa de ser exibida.  O mesmo se aplica a todos os recursos que n√£o est√£o inclu√≠dos no arquivo execut√°vel.  Para fazer isso, escrevi uma fun√ß√£o que calcula o caminho completo para o arquivo execut√°vel, independentemente de como ele foi executado. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   data.path void get_real_path(char *argv0) { char* result=(char*)calloc(1024,sizeof(char)); char* cwd=(char*)calloc(1024,sizeof(char)); getcwd(cwd, 1024); int i=0; while(argv0[i]!='\0'&amp;&amp;i&lt;1024) ++i; while(argv0[i]!='/'&amp;&amp;i&gt;0) --i; result[i]='\0'; while(i&gt;0) { --i; result[i]=argv0[i]; } /*alex@alex-System-Product-Name:~/project_manager$ ./manager.elf argv[0]=./manager.elf path=/home/alex/project_manager*/ if(strlen(result)&lt;=strlen(cwd)) //   { free(result); strcpy(data.path,cwd); strcat(data.path,"/"); //printf("path_cwd=%s\n",cwd); free(cwd);} else { /*alex@alex-System-Product-Name:/home$ '/home/alex/project_manager/manager.elf' argv[0]=/home/alex/project_manager/manager.elf path=/home*/ free(cwd); strcpy(data.path,result); strcat(data.path,"/"); //printf("path_result=%s\n",result); free(result); } }</span></span></code> </pre><br>  Existem 2 exemplos no c√≥digo de como executar o arquivo manager.elf.  Voc√™ tamb√©m precisa colocar main () no in√≠cio da fun√ß√£o <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cwd[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; getcwd(cwd, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cwd)); get_real_path(argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br>  A fun√ß√£o de desenho assumir√° o seguinte formato <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawingarea1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_svg) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> image_path[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span>(image_path,data.path); <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span>(image_path,<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"image_path=%s\n"</span></span>,image_path); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* path=get_resized_svg(image_path, <span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">220</span></span>); data.svg_handle_svg=rsvg_handle_new_from_file(path,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); resized_svg_free(path); g_free(path); } gboolean result=rsvg_handle_render_cairo(data.svg_handle_svg,cr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result&amp;&amp;cr) {cairo_stroke(cr);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  <b>Testes de a√ß√£o r√°pida.</b> <br><br>  Temos duas fun√ß√µes de desenho (GtkDrawingArea e GtkImage). <br><br>  Colocaremos cada um deles em um design de um tipo (sem esquecer de conectar &lt;time.h&gt;) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">clock_t</span></span> tic = clock(); <span class="hljs-keyword"><span class="hljs-keyword">clock_t</span></span> toc = clock(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"image1_draw_cb elapsed : %f seconds\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(toc - tic) / CLOCKS_PER_SEC);</code> </pre><br>  E no aplicativo htop, voc√™ pode ver como o programa consome 20 a 30% de cada n√∫cleo do Athlon 2 X3 2,5 GHz. <br><br>  O erro foi encontrado rapidamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">clock_t</span></span> tic = clock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_image) { data.svg_handle_image=rsvg_handle_new_from_file(<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); data.surf=cairo_image_surface_create_from_png(<span class="hljs-string"><span class="hljs-string">"2.png"</span></span>); data.pixbuf=rsvg_handle_get_pixbuf(data.svg_handle_image); <span class="hljs-comment"><span class="hljs-comment">//} //if(data.pixbuf) // { cairo_set_source_surface(cr,data.surf,0,0); GdkPixbuf *dest=gdk_pixbuf_scale_simple (data.pixbuf,250,250,GDK_INTERP_BILINEAR); gtk_image_set_from_pixbuf (data.image,dest); g_object_unref(dest); //cairo_paint(cr); } clock_t toc = clock(); printf("image1_draw_cb elapsed : %f seconds\n", (double)(toc - tic) / CLOCKS_PER_SEC); return FALSE; }</span></span></code> </pre><br>  Como se viu, o GtkImage possui seu pr√≥prio sistema de renderiza√ß√£o, e o conte√∫do de image1_draw_cb pode ser inicializado apenas uma vez.  As linhas comentadas eram redundantes. <br><br><img src="https://habrastorage.org/webt/2s/2p/4i/2s2p4ibxxewesxsfsupstrcwzju.png"><br><br>  Como voc√™ pode ver, a primeira renderiza√ß√£o leva mais tempo com GtkImage do que com GtkDrawingArea, mas atualizar teoricamente a imagem deve ser mais r√°pido.  4 milh√µes de ciclos de processador para cada redesenho de imagem de 220px * 220px √© um pouco demais, mas voc√™ pode fazer cache apenas atrav√©s do pixbuf (pelo menos, n√£o conhe√ßo outros m√©todos). <br><br>  Obrigado pela aten√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435564/">https://habr.com/ru/post/pt435564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435552/index.html">Substitui√ß√£o de importa√ß√£o - epit√°fio da digitaliza√ß√£o</a></li>
<li><a href="../pt435556/index.html">Mudando para o data center: como foi</a></li>
<li><a href="../pt435558/index.html">Testando o PostgreSQL com HugePages no Linux</a></li>
<li><a href="../pt435560/index.html">Primeiro computador qu√¢ntico comercial - IBM</a></li>
<li><a href="../pt435562/index.html">O caminho de um fumante: como ingressar na profiss√£o de programador, se voc√™ √© humanista</a></li>
<li><a href="../pt435568/index.html">Roteador VyOS OpenSource</a></li>
<li><a href="../pt435572/index.html">Anycubic i3 Mega: remake de qualidade do Prusa i3</a></li>
<li><a href="../pt435574/index.html">Como o zig funciona?</a></li>
<li><a href="../pt435576/index.html">1C, sem dor</a></li>
<li><a href="../pt435578/index.html">Passeio espacial no Natal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>