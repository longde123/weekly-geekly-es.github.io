<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§—ğŸ¼ ğŸ‘¨ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ•’ Menyesuaikan kinerja kueri dalam PostgreSQL âŒ ğŸ“³ ğŸ•º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menyesuaikan kinerja basis data - pengembang biasanya menyukainya atau membencinya. Saya menikmati ini dan ingin berbagi beberapa metode yang saya gun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menyesuaikan kinerja kueri dalam PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461997/"><img width="40%" align="left" src="https://habrastorage.org/webt/0s/ei/zy/0seizy-vxfjf3uv8g3n_bijcwb0.jpeg">  Menyesuaikan kinerja basis data - pengembang biasanya menyukainya atau membencinya.  Saya menikmati ini dan ingin berbagi beberapa metode yang saya gunakan baru-baru ini untuk menyetel kueri yang dieksekusi dengan buruk di PostgreSQL.  Metode saya tidak lengkap, melainkan buku teks bagi mereka yang hanya kesal tentang penyetelan. <br><br><h2>  Cari permintaan lambat </h2><br>  Cara pertama yang jelas untuk mulai menyetel adalah menemukan operator tertentu yang bekerja dengan buruk. <br><br><h3>  pg_stats_statements </h3><br>  Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_stats_statements</a> adalah tempat yang tepat untuk memulai.  Itu hanya melacak statistik eksekusi pernyataan SQL dan bisa menjadi cara mudah untuk menemukan pertanyaan yang tidak efisien. <br><br>  Setelah Anda menginstal modul ini, tampilan sistem yang disebut <i>pg_stat_statements</i> akan tersedia dengan semua propertinya.  Setelah ia memiliki kesempatan untuk mengumpulkan data yang cukup, cari kueri yang memiliki nilai <i>total_time yang</i> relatif tinggi <i>.</i>  Fokus pada operator ini terlebih dahulu. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  user_id </th><th>  dbid </th><th>  kueri </th><th>  permintaan </th><th>  panggilan </th><th>  total_time </th></tr></thead><tbody><tr><td>  16384 </td><td>  16385 </td><td>  2948 </td><td>  SELECT address_1 DARI alamat a INNER GABUNG orang p ON a.person_id = p.id WHERE a.state = @state_abbrev; </td><td>  39483 </td><td>  15224.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  924 </td><td>  PILIH person_id DARI orang DI MANA nama = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">nama</a> ; </td><td>  26483 </td><td>  12225.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  395 </td><td>  PILIH _ DARI pesanan MANA ADA (pilih _ dari produk mana is_featured = benar) </td><td>  18583 </td><td>  224.67 </td></tr></tbody></table></div><br><a name="habracut"></a><br><h3>  auto_explain </h3><br>  Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">auto_explain</a> juga berguna untuk menemukan permintaan yang lambat, tetapi memiliki 2 keuntungan yang jelas: ia mendaftarkan rencana eksekusi aktual dan mendukung rekaman pernyataan bersarang menggunakan opsi <i>log_nested_statements</i> .  Pernyataan bersarang adalah pernyataan yang dieksekusi di dalam suatu fungsi.  Jika aplikasi Anda menggunakan banyak fitur, auto_explain sangat berharga untuk mendapatkan detail rencana eksekusi. <br><br>  Opsi <i>log_min_duration</i> mengontrol rencana eksekusi permintaan yang dicatat berdasarkan berapa lama mereka berjalan.  Misalnya, jika Anda menetapkan nilai ke 1000, semua catatan yang membutuhkan waktu lebih dari 1 detik akan didaftarkan. <br><br><h2>  Penyetelan Indeks </h2><br>  Strategi penyetelan penting lainnya adalah untuk memastikan bahwa indeks digunakan dengan benar.  Sebagai prasyarat, kita harus menyertakan Kolektor Statistik. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Postgres Statistics Collector</a> adalah subsistem kelas satu yang mengumpulkan semua jenis statistik kinerja yang berguna. <br><br>  Dengan mengaktifkan kolektor ini, Anda mendapatkan banyak <i>pg_stat _... tampilan</i> yang berisi semua properti.  Secara khusus, saya menemukan ini sangat berguna untuk menemukan indeks yang hilang dan tidak terpakai. <br><br><h3>  Indeks Tidak Ada </h3><br>  Indeks yang hilang mungkin merupakan salah satu solusi termudah untuk meningkatkan kinerja kueri.  Namun, mereka bukan peluru perak dan harus digunakan dengan benar (lebih lanjut tentang ini nanti).  Jika Anda memiliki pengumpul statistik yang diaktifkan, Anda dapat menjalankan kueri ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ) berikut. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname, seq_scan - idx_scan <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> too_much_seq, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> seq_scan - <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(idx_scan, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'Missing Index?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, pg_relation_size(relname::regclass) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rel_size, seq_scan, idx_scan <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> schemaname = <span class="hljs-string"><span class="hljs-string">'public'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_relation_size(relname::regclass) &gt; <span class="hljs-number"><span class="hljs-number">80000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> too_much_seq <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  Kueri menemukan tabel yang memiliki lebih banyak pemindaian berurutan (Pemindaian indeks) daripada pemindaian indeks - indikasi yang jelas bahwa indeks akan membantu.  Ini tidak akan memberi tahu Anda kolom mana yang digunakan untuk membuat indeks, sehingga akan membutuhkan sedikit lebih banyak pekerjaan.  Namun, mengetahui tabel mana yang membutuhkannya adalah langkah pertama yang baik. <br><br><h3>  Indeks yang Tidak Digunakan </h3><br>  Buat indeks semua entitas, bukan?  Tahukah Anda bahwa indeks yang tidak digunakan dapat mempengaruhi kinerja penulisan?  Alasannya adalah bahwa ketika membuat indeks Postgres, ia dibebani dengan tugas memperbarui indeks ini setelah operasi penulisan (INSERT / UPDATE / DELETE).  Dengan demikian, menambahkan indeks adalah tindakan penyeimbang, karena dapat mempercepat pembacaan data (jika itu dibuat dengan benar), tetapi itu akan memperlambat operasi penulisan.  Untuk menemukan indeks yang tidak digunakan, Anda dapat menjalankan kueri berikut. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, relid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>, <span class="hljs-string"><span class="hljs-string">'DROP INDEX '</span></span> || indexrelid::regclass || <span class="hljs-string"><span class="hljs-string">';'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> drop_statement <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_user_indexes <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (indexrelid) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> idx_scan = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> indisunique <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><h3>  Catatan tentang statistik lingkungan pengembangan </h3><br>  Mengandalkan statistik dari basis data pembangunan lokal bisa menjadi masalah.  Idealnya, Anda bisa mendapatkan statistik di atas dari mesin Anda atau menghasilkannya dari cadangan yang dipulihkan.  Mengapa  Faktor lingkungan dapat mengubah perilaku pengoptimal kueri Postgres.  Dua contoh: <br><br><ul><li>  ketika mesin memiliki lebih sedikit memori, PostgreSQL mungkin tidak dapat melakukan Hash Join, jika tidak maka akan dan akan melakukannya lebih cepat. </li><li>  jika tidak ada banyak baris dalam tabel (seperti dalam database pengembangan), PostgresSQL mungkin lebih memilih untuk melakukan pemindaian berurutan pada tabel daripada menggunakan indeks yang tersedia.  Ketika ukuran tabel kecil, Pemindaian Seq bisa lebih cepat.  (Catatan: Anda bisa berlari <pre> <code class="plaintext hljs">SET enable_seqscan = OFF</code> </pre>  dalam sesi sehingga pengoptimal memilih untuk menggunakan indeks, bahkan jika pemindaian berurutan bisa lebih cepat.  Ini berguna ketika bekerja dengan database pengembangan yang tidak memiliki banyak data) </li></ul><br><h2>  Memahami Rencana Eksekusi </h2><br>  Sekarang Anda telah menemukan beberapa pertanyaan lambat, saatnya untuk memulai kesenangan. <br><br><h3>  JELASKAN </h3><br>  Perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EXPLAIN</a> tentu diperlukan saat mengatur pertanyaan.  Dia memberi tahu Anda apa yang sebenarnya terjadi.  Untuk menggunakannya, cukup tambahkan <i>EXPLAIN</i> ke kueri dan jalankan.  PostgreSQL akan menunjukkan kepada Anda rencana eksekusi yang digunakannya. <br><br>  Saat menggunakan EXPLAIN untuk penyetelan, saya sarankan selalu menggunakan opsi <i>ANALYZE</i> ( <i>EXPLAIN ANALYZE</i> ), karena memberikan Anda hasil yang lebih akurat.  Opsi ANALYZE sebenarnya mengeksekusi pernyataan (bukan hanya mengevaluasinya), dan kemudian menjelaskannya. <br><br>  Mari kita mulai dan mulai memahami output <i>EXPLAIN</i> .  Berikut ini sebuah contoh: <br><br><img src="https://habrastorage.org/webt/ee/py/sv/eepysvoeunknfcwr9meuxa9e4y4.png"><br><br><h3>  Simpul </h3><br>  Hal pertama yang harus dipahami adalah bahwa setiap blok indentasi dengan "-&gt;" sebelumnya (bersama dengan baris teratas) disebut node.  Node adalah unit kerja logis ("langkah", jika Anda suka) dengan biaya terkait dan waktu tunggu.  Biaya dan waktu yang disajikan pada setiap simpul bersifat kumulatif dan menyatukan semua simpul anak.  Ini berarti bahwa garis paling atas (simpul) menunjukkan total biaya dan waktu aktual untuk seluruh operator.  Ini penting karena Anda dapat dengan mudah menelusuri untuk menentukan node mana yang menjadi hambatan. <br><br><h3>  Biaya </h3><br><pre> <code class="plaintext hljs">cost=146.63..148.65</code> </pre> <br>  Angka pertama adalah biaya awal (biaya memperoleh catatan pertama), dan angka kedua adalah biaya pemrosesan seluruh node (total biaya dari awal hingga selesai). <br><br>  Faktanya, ini adalah biaya yang estimasi PostgreSQL harus dipenuhi untuk menjalankan pernyataan.  Nomor ini tidak berarti berapa lama untuk menyelesaikan permintaan, meskipun biasanya ada hubungan langsung yang diperlukan untuk menyelesaikan.  Biaya adalah kombinasi dari 5 komponen kerja yang digunakan untuk mengevaluasi pekerjaan yang diperlukan: pengambilan sampel sekuensial, pengambilan sampel tidak konsisten (acak), pemrosesan baris, operator pemrosesan (fungsi) dan pencatatan indeks pemrosesan.  Biaya adalah input / output dan beban prosesor, dan penting untuk mengetahui bahwa biaya yang relatif tinggi berarti PostgresSQL percaya bahwa ia harus melakukan lebih banyak pekerjaan.  Pengoptimal memutuskan rencana eksekusi yang akan digunakan berdasarkan biaya.  Pengoptimal memilih biaya yang lebih rendah. <br><br><h3>  Waktu yang sebenarnya </h3><br><pre> <code class="plaintext hljs">actual time=55.009..55.012</code> </pre> <br>  Dalam milidetik, angka pertama adalah waktu mulai (waktu untuk mengambil catatan pertama), dan angka kedua adalah waktu yang diperlukan untuk memproses seluruh simpul (total waktu dari awal hingga selesai).  Mudah dimengerti, bukan? <br><br>  Dalam contoh di atas, butuh 55,009 ms untuk mendapatkan catatan pertama dan 55,012 ms untuk menyelesaikan seluruh node. <br><br><h3>  Pelajari lebih lanjut tentang rencana eksekusi. </h3><br>  Ada beberapa artikel yang sangat bagus untuk memahami hasil EXPLAIN.  Daripada mencoba menceritakannya kembali di sini, saya sarankan meluangkan waktu untuk benar-benar memahaminya dengan pergi ke 2 sumber daya yang luar biasa ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.depesz.com/2013/04/16/explaining-the-unexplainable/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://wiki.postgresql.org/images/4/45/Explaining_EXPLAIN.pdf</a> </li></ul><br><h2>  Minta penyetelan </h2><br>  Sekarang Anda tahu operator mana yang bekerja dengan buruk dan dapat melihat rencana eksekusi Anda, sekarang saatnya untuk mulai menyesuaikan permintaan Anda untuk meningkatkan kinerja.  Di sini Anda membuat perubahan pada permintaan Anda dan / atau menambahkan indeks untuk mencoba mendapatkan rencana eksekusi yang lebih baik.  Mulailah dengan kemacetan dan lihat apakah ada perubahan yang dapat Anda lakukan untuk mengurangi biaya dan / atau tenggang waktu. <br><br><h4>  Cache Data dan Catatan Biaya </h4><br>  Ketika membuat perubahan dan mengevaluasi rencana implementasi, untuk melihat apakah akan ada perbaikan, penting untuk mengetahui bahwa implementasi di masa depan mungkin bergantung pada caching data yang memberikan gambaran tentang hasil terbaik.  Jika Anda menjalankan permintaan satu kali, melakukan koreksi dan menjalankannya untuk kedua kalinya, kemungkinan besar itu akan berjalan lebih cepat, bahkan jika rencana eksekusi tidak lebih menguntungkan.  Ini karena PostgreSQL dapat men-cache data yang digunakan pada awal pertama, dan dapat menggunakannya pada awal kedua.  Oleh karena itu, Anda harus menyelesaikan kueri setidaknya 3 kali dan rata-rata hasilnya untuk membandingkan biaya. <br><br>  Hal yang saya pelajari dapat membantu meningkatkan rencana pelaksanaan: <br><br><ul><li>  Indeks <br><ul><li>  Kecualikan pemindaian sekuensial (Pemindaian Seq) dengan menambahkan indeks (jika ukuran tabel tidak kecil) </li><li>  Saat menggunakan indeks multi-kolom, pastikan Anda memperhatikan urutan Anda mendefinisikan kolom yang disertakan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Lebih Lanjut</a> </li><li>  Coba indeks yang sangat selektif untuk data yang sering digunakan.  Ini akan membuat penggunaannya lebih efisien. </li></ul></li><li>  Kondisi DI MANA <br><br><ul><li>  Hindari SEPERTI </li><li>  Hindari panggilan fungsi dalam klausa WHERE </li><li>  Hindari kondisi besar di () </li></ul></li><li>  BERGABUNG <br><br><ul><li>  Saat bergabung dengan tabel, coba gunakan persamaan persamaan sederhana di klausa ON (mis. A.id = b.person_id).  Ini memungkinkan Anda untuk menggunakan metode bergabung yang lebih efisien (mis., Hash Join, bukan Nested Loop Join) </li><li>  Konversikan subqueries ke GABUNG pernyataan jika memungkinkan, karena ini biasanya memungkinkan pengoptimal untuk memahami tujuan dan mungkin memilih rencana terbaik. </li><li>  Gunakan COMPOUNDS dengan benar: apakah Anda menggunakan GROUP BY atau DISTINCT hanya karena Anda mendapatkan hasil duplikat?  Ini biasanya menunjukkan penggunaan JOIN yang tidak benar dan dapat menyebabkan biaya yang lebih tinggi. </li><li>  Jika rencana eksekusi menggunakan Hash Join, bisa sangat lambat jika estimasi ukuran tabel salah.  Karena itu, pastikan statistik tabel Anda akurat dengan meninjau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strategi penghisap debu.</a> </li><li>  Hindari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">subqueries yang berkorelasi bila</a> memungkinkan;  mereka dapat secara signifikan meningkatkan biaya permintaan </li><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EXISTS</a> ketika memeriksa keberadaan string berdasarkan kriteria, karena mirip dengan korsleting (berhenti memproses ketika menemukan setidaknya satu kecocokan) </li></ul></li><li>  Rekomendasi umum <br><br><ul><li>  Lakukan lebih banyak dengan lebih sedikit;  Prosesor lebih cepat dari input / output (I / O) </li><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekspresi Tabel Umum</a> dan tabel sementara saat Anda perlu melakukan kueri dirantai. </li><li>  Hindari pernyataan LOOP dan lebih suka operasi SET </li><li>  Hindari COUNT (*) karena tabel scan PostgresSQL untuk ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hanya untuk versi &lt;= 9.1</a> ) </li><li>  Hindari PESANAN OLEH, Pisahkan, KELOMPOK OLEH, UNION bila memungkinkan, karena ini menyebabkan biaya awal yang tinggi. </li><li>  Cari perbedaan besar antara garis estimasi dan aktual dalam ekspresi <i>EXPLAIN</i> .  Jika penghitungnya sangat berbeda, statistik tabel mungkin sudah usang, dan PostgreSQL memperkirakan biayanya menggunakan statistik yang tidak akurat.  Sebagai contoh: <pre> <code class="plaintext hljs">Limit (cost=282.37..302.01 rows=93 width=22) (actual time=34.35..49.59 rows=2203 loops=1)</code> </pre>  Perkiraan jumlah garis adalah 93, dan aktual - 2203. Oleh karena itu, kemungkinan besar, ini adalah keputusan yang buruk dari rencana tersebut.  Anda harus meninjau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strategi menyedot debu</a> Anda dan memastikan bahwa ANALYZE dijalankan cukup sering. </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461997/">https://habr.com/ru/post/id461997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461983/index.html">Bagaimana kami memodifikasi produk untuk klien tertentu</a></li>
<li><a href="../id461985/index.html">Teknologi Pos - bagaimana kita mendigitalkan Pos Rusia</a></li>
<li><a href="../id461989/index.html">Pengembangan antarmuka game untuk berbagai proporsi layar</a></li>
<li><a href="../id461993/index.html">Cara menjadi bahan makanan dari "desainer biasa"</a></li>
<li><a href="../id461995/index.html">Cara menggunakan proxy penduduk untuk pemasaran dan promosi situs web</a></li>
<li><a href="../id461999/index.html">Versi lain dari lingkungan pengembangan WordPress (buruh pelabuhan, wp-cli)</a></li>
<li><a href="../id462003/index.html">Bagaimana saya memposting PWA di Svelte di Google Play</a></li>
<li><a href="../id462005/index.html">Fitur Google PageSpeed: peningkatan peringkat situs dan peringkat pencarian</a></li>
<li><a href="../id462007/index.html">Mengembangkan skrip Python yang kuat</a></li>
<li><a href="../id462009/index.html">Tren pemrograman: apa yang bisa diharapkan pada tahun 2020?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>