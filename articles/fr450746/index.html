<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👦‍👦 🏳️‍🌈 🌞 Présentation de CLI Builder 🧒🏽 👋🏼 👩🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous examinerons la nouvelle API CLI angulaire, qui vous permettra d'étendre les fonctionnalités CLI existantes et d'en ajouter de n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Présentation de CLI Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450746/"><img src="https://habrastorage.org/webt/sm/xo/kb/smxokbjs_uhwjcb1rjv7cwt5k3m.png" alt="Présentation de CLI Builder"><br><br>  Dans cet article, nous examinerons la nouvelle API CLI angulaire, qui vous permettra d'étendre les fonctionnalités CLI existantes et d'en ajouter de nouvelles.  Nous verrons comment travailler avec cette API et quels sont les points de son extension qui permettent d'ajouter de nouvelles fonctionnalités à la CLI. <br><a name="habracut"></a><br><h2>  L'histoire </h2><br>  Il y a environ un an, nous avons introduit le fichier d'espace de travail ( <i>angular.json</i> ) dans la CLI angulaire et repensé de nombreux principes de base pour implémenter ses commandes.  Nous sommes arrivés au fait d'avoir placé les équipes dans les «cases»: <br><br><ol><li> <b>Commandes schématiques - "Commandes schématiques"</b> .  À ce jour, vous avez probablement déjà entendu parler de Schematics, la bibliothèque utilisée par la CLI pour générer et modifier votre code.  Il est apparu dans la version 5 et est actuellement utilisé dans la plupart des commandes qui concernent votre code, comme <i>nouveau</i> , <i>générer</i> , <i>ajouter</i> et <i>mettre à jour</i> . </li><li>  <b>Commandes diverses - "Autres équipes"</b> .  Ce sont des commandes qui ne sont pas directement liées à votre projet: <i>aide</i> , <i>version</i> , <i>config</i> , <i>doc</i> .  Récemment, des <i>analyses</i> ont également fait leur apparition, ainsi que nos œufs de Pâques (Chut! Pas un mot à personne!). </li><li>  <b>Commandes de tâche - "Commandes de tâche"</b> .  Cette catégorie, dans l'ensemble, «lance les processus exécutés sur le code d'autres personnes».  - Par exemple, <i>build</i> est une construction de projet, <i>lint</i> débogue et <i>test</i> teste. </li></ol><br>  Nous avons commencé à concevoir <i>angular.json</i> il y a longtemps.  Initialement, il a été conçu en remplacement de la configuration Webpack.  En outre, il était censé permettre aux développeurs de choisir indépendamment la mise en œuvre de l'assemblage du projet.  En conséquence, nous avons obtenu un système de lancement de tâche de base, qui est resté simple et pratique pour nos expériences.  Nous avons appelé cette API "Architecte". <br><br>  Malgré le fait que Architect n'était pas officiellement pris en charge, il était populaire parmi les développeurs qui souhaitaient personnaliser l'assemblage des projets, ainsi que parmi les bibliothèques tierces qui devaient contrôler leur flux de travail.  Nx l'a utilisé pour exécuter les commandes Bazel, Ionic l'a utilisé pour exécuter des tests unitaires sur Jest, et les utilisateurs ont pu étendre leurs configurations Webpack en utilisant des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ngx-build-plus</a> .  Et ce n'était que le début. <br><br>  <b>Une version officiellement prise en charge, stable et améliorée de cette API est utilisée dans Angular CLI version 8.</b> <br><br><h2>  Concept </h2><br>  L'API Architect propose des outils de planification et de coordination des tâches que la CLI angulaire utilise pour implémenter ses commandes.  Il utilise des fonctions appelées <br>  «Constructeurs» - «collectionneurs» qui peuvent agir en tant que tâches ou planificateurs d'autres collectionneurs.  De plus, il utilise angular.json comme un ensemble d'instructions pour les collectionneurs eux-mêmes. <br><br>  Il s'agit d'un système très général conçu pour être flexible et extensible.  Il contient une API pour les rapports, la journalisation et les tests.  Si nécessaire, le système peut être étendu pour de nouvelles tâches. <br><br><h2>  Pickers </h2><br>  Les assembleurs sont des fonctions qui implémentent la logique et le comportement d'une tâche pouvant remplacer la commande CLI.  - Par exemple, démarrez le linter. <br><br>  La fonction de collecteur prend deux arguments: la valeur d'entrée (ou les options) et le contexte qui fournit la relation entre la CLI et le collecteur lui-même.  La répartition des responsabilités ici est la même que dans les schémas - l'utilisateur CLI définit les options, l'API est responsable du contexte et vous (le développeur) définissez le comportement nécessaire.  Le comportement peut être implémenté de manière synchrone, asynchrone ou afficher simplement un certain nombre de valeurs.  La sortie doit être de type <i>BuilderOutput</i> , qui contient le <i>succès du</i> champ logique et l' <i>erreur de</i> champ facultatif, qui contient le message d'erreur. <br><br><h2>  Fichier et tâches de l'espace de travail </h2><br>  L'API Architect repose sur <i>angular.json</i> , un fichier d'espace de travail pour stocker les tâches et leurs paramètres. <br><br>  <i>angular.json</i> divise l'espace de travail en projets et ceux-ci, à leur tour, en tâches.  Par exemple, votre application créée avec la commande <i>ng new</i> est l'un de ces projets.  L'une des tâches de ce projet sera la tâche de <i>génération</i> , qui peut être lancée à l'aide de la <i>commande ng build</i> .  Par défaut, cette tâche a trois clés: <br><br><ol><li>  <b>constructeur</b> - le nom du collecteur à utiliser pour terminer la tâche, au format <i>PACKAGE_NAME: ASSEMBLY_NAME</i> . </li><li>  <b>options</b> - paramètres utilisés lors du démarrage d'une tâche par défaut. </li><li>  <b>configurations</b> - paramètres qui seront appliqués lors du démarrage d'une tâche avec la configuration spécifiée. </li></ol><br>  Les paramètres sont appliqués comme suit: lorsque la tâche démarre, les paramètres sont extraits du bloc d'options, puis, si une configuration a été spécifiée, ses paramètres sont écrits par-dessus ceux existants.  Après cela, si des paramètres supplémentaires ont été transmis à <i>scheduleTarget ()</i> - le bloc de <i>remplacement</i> , ils seront écrits en dernier.  Lors de l'utilisation de la CLI angulaire, les arguments de ligne de commande sont passés à des <i>remplacements</i> .  Une fois tous les paramètres transférés au collecteur, il les vérifie selon son schéma, et uniquement si les paramètres y correspondent, le contexte sera créé et le collecteur commencera à fonctionner. <br><br>  Plus d'informations sur l'espace de travail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Créez votre propre collectionneur </h2><br>  Par exemple, créons un collecteur qui exécutera une commande sur la ligne de commande.  Pour créer un collecteur, utilisez la fabrique <i>createBuilder</i> et renvoyez l'objet <i>BuilderOutput</i> : <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }); });</code> </pre> <br>  Maintenant, ajoutons une logique à notre collecteur: nous voulons contrôler le collecteur via les paramètres, créer de nouveaux processus, attendre que le processus se termine, et si le processus s'est terminé avec succès (c'est-à-dire, renvoyer le code 0), signalez-le à Architect: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Traitement de sortie </h2><br>  Maintenant, la méthode d' <i>apparition</i> transmet toutes les données à la sortie standard du processus.  Nous pouvons vouloir les transférer à l' <i>enregistreur</i> - enregistreur.  Dans ce cas, d'une part, le débogage pendant les tests sera facilité, et d'autre part, Architect lui-même peut exécuter notre collecteur dans un processus séparé ou désactiver la sortie standard des processus (par exemple, dans l'application Electron). <br><br>  Pour ce faire, nous pouvons utiliser <i>Logger</i> , disponible dans l'objet <i>contextuel</i> , qui nous permettra de rediriger la sortie du processus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Rapports sur le rendement et l'état </h2><br>  La dernière partie de l'API liée à la mise en œuvre de votre propre collecteur est la progression et les rapports d'état actuels. <br><br>  Dans notre cas, la commande est terminée ou exécutée, il est donc inutile d'ajouter un rapport de progression.  Cependant, nous pouvons communiquer notre statut au collectionneur parent afin qu'il comprenne ce qui se passe. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Executing "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${options.command}</span></span></span><span class="hljs-string">"...`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Done.`</span></span>); child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br>  Pour passer un rapport de <i>progression</i> , utilisez la méthode <i>reportProgress</i> avec les valeurs actuelles et (facultativement) récapitulatives comme arguments.  <i>le total</i> peut être n'importe quel nombre.  Par exemple, si vous savez combien de fichiers vous devez traiter, vous pouvez transférer leur nombre au <i>total</i> , puis à <i>courant,</i> vous pouvez transférer le nombre de fichiers déjà traités.  C'est ainsi que <a href="">le collecteur tslint</a> rend compte de ses progrès. <br><br><h2>  Validation des entrées </h2><br>  L'objet d' <i>options</i> passé au collecteur est vérifié à l'aide du schéma JSON.  Ceci est similaire aux schémas si vous savez ce que c'est. <br><br>  Dans notre exemple de collecteur, nous nous attendons à ce que nos paramètres soient un objet qui reçoit deux clés: <i>commande</i> - commande (chaîne) et <i>args</i> - arguments (tableau de chaînes).  Notre schéma de vérification ressemblera à ceci: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://json-schema.org/schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } } }</code> </pre><br>  Les schémas sont des outils vraiment puissants qui peuvent effectuer un grand nombre de contrôles.  Pour plus d'informations sur les schémas JSON, vous pouvez vous référer au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site Web officiel du schéma JSON</a> . <br><br><h2>  Créer un package de construction </h2><br>  Il y a un fichier clé que nous devons créer pour notre propre collecteur afin de le rendre compatible avec la CLI angulaire - <i>builders.json</i> , qui est responsable de la relation entre notre implémentation du collecteur, son nom et le schéma de vérification.  Le fichier lui-même ressemble à ceci: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"implementation"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command/schema.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Runs any command line in the operating system."</span></span> } } }</code> </pre><br>  Ensuite, dans le fichier <i>package.json</i> , nous ajoutons la clé <i>builders</i> , pointant vers le fichier <i>builders.json</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Builder for Architect"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: <span class="hljs-string"><span class="hljs-string">"builders.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devDependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@angular-devkit/architect"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.0.0"</span></span> } }</code> </pre><br>  Cela indiquera à Architect où rechercher le fichier de définition du collecteur. <br><br>  Ainsi, le nom de notre collecteur est <i>"@ example / command-runner: command"</i> .  La première partie du nom, avant les deux-points (:) est le nom du package, défini à l'aide de <i>package.json</i> .  La deuxième partie est le nom du collecteur, défini à l'aide du fichier <i>builders.json</i> . <br><br><h2>  Tester vos propres constructeurs </h2><br>  La méthode recommandée pour tester les assembleurs consiste à effectuer des tests d'intégration.  En effet, la création d'un <i>contexte n'est</i> pas facile, vous devez donc utiliser le planificateur d'Architect. <br><br>  Pour simplifier les modèles, nous avons pensé à un moyen simple de créer une instance Architect: vous créez d'abord un <i>JsonSchemaRegistry</i> (pour tester le schéma), puis <i>TestingArchitectHost</i> et, enfin, une instance <i>Architect</i> .  Vous pouvez maintenant compiler le <i>fichier de</i> configuration <i>builders.json</i> . <br><br>  Voici un exemple d'exécution du collecteur, qui exécute la <i>commande ls</i> et vérifie que la commande s'est terminée avec succès.  Veuillez noter que nous utiliserons la sortie standard des processus dans l' <i>enregistreur</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Architect, ArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TestingArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect/testing'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { logging, schema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/core'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Command Runner Builder'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architect: Architect; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architectHost: ArchitectHost; beforeEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.CoreSchemaRegistry(); registry.addPostTransform(schema.transforms.addUndefinedDefaults); <span class="hljs-comment"><span class="hljs-comment">//  TestingArchitectHost –    . //     ,   . architectHost = new TestingArchitectHost(__dirname, __dirname); architect = new Architect(architectHost, registry); //      NPM-, //    package.json  . await architectHost.addBuilderFromPackage('..'); }); //      Windows it('can run ls', async () =&gt; { //  ,     . const logger = new logging.Logger(''); const logs = []; logger.subscribe(ev =&gt; logs.push(ev.message)); // "run"    ,       . const run = await architect.scheduleBuilder('@example/command-runner:command', { command: 'ls', args: [__dirname], }, { logger }); // "result" –    . //    "BuilderOutput". const output = await run.result; //  . Architect     //   ,    ,    . await run.stop(); //   . expect(output.success).toBe(true); // ,     . // `ls $__dirname`. expect(logs).toContain('index_spec.ts'); }); });</span></span></code> </pre><br>  Pour exécuter l'exemple ci-dessus, vous avez besoin du package <i>ts-node</i> .  Si vous avez l'intention d'utiliser Node, renommez <i>index_spec.ts</i> en <i>index_spec.js</i> . <br><br><h2>  Utilisation du collecteur dans un projet </h2><br>  Créons un simple angular.json qui montre tout ce que nous avons appris sur les assembleurs.  En supposant que nous avons compressé notre collecteur dans <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">exemple</a> / commande-runner</i> puis créé une nouvelle application en utilisant <i>ng new builder-test</i> , le fichier <i>angular.json</i> pourrait ressembler à ceci (une partie du contenu a été supprimé pour plus de brièveté): <br><br><pre> <code class="json hljs">{ // ...   . <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } }</code> </pre><br>  Si nous décidions d'ajouter une nouvelle tâche pour appliquer (par exemple) la commande <i>tactile</i> au fichier (met à jour la date de modification du fichier) à l'aide de notre collecteur, nous exécuterions <i>npm install <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">example</a> / command-runner</i> , puis apporterions des modifications à <i>angular.json</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"touch"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner:command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"touch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fileReplacements"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"replace"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"with"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.prod.ts"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } } } } }</code> </pre><br>  La CLI angulaire possède une commande d' <i>exécution</i> , qui est la commande principale pour exécuter les collecteurs.  Comme premier argument, il prend une chaîne de format <i>PROJECT: TASK [: CONFIGURATION]</i> .  Pour exécuter notre tâche, nous pouvons utiliser la commande <i>ng run builder-test: touch</i> . <br><br>  Maintenant, nous pouvons vouloir redéfinir certains arguments.  Malheureusement, nous ne pouvons pas redéfinir les tableaux à partir de la ligne de commande jusqu'à présent, mais nous pouvons modifier la commande elle-même pour la démonstration: <i>ng exécutez builder-test: touch --command = ls</i> .  - Cela produira le <i>fichier src / main.ts.</i> <br><br><h2>  Mode montre </h2><br>  Il est supposé que, par défaut, les collecteurs seront appelés une fois et terminés, cependant, ils peuvent retourner <i>Observable</i> pour implémenter leur propre mode d'observation (comme le <i>fait le</i> collecteur <i>Webpack</i> ).  Architect s'abonnera à l' <i>Observable</i> jusqu'à ce qu'il se termine ou s'arrête et peut à nouveau s'abonner au collecteur si le collecteur est appelé avec les mêmes paramètres (bien que cela ne soit pas garanti). <br><br><ol><li>  Le collecteur doit retourner un objet <i>BuilderOutput</i> après chaque exécution.  Une fois terminé, il peut entrer en mode d'observation provoqué par un événement externe et, s'il recommence, il devra appeler la fonction <i>context.reportRunning ()</i> pour informer l'architecte que le collecteur fonctionne à nouveau.  Cela empêchera le collecteur de l'arrêter par l'architecte lors d'un nouvel appel. </li><li>  L'architecte lui-même se désabonne d' <i>Observable</i> lorsque le collecteur s'arrête (en utilisant run.stop (), par exemple), en utilisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">logique Teardown</a> - l'algorithme de destruction.  Cela vous permettra d'arrêter et d'effacer l'assembly si ce processus est déjà en cours d'exécution. </li></ol><br>  Pour résumer ce qui précède, si votre collectionneur regarde des événements externes, cela fonctionne en trois étapes: <br><br><ol><li>  <b>Accomplissement.</b>  Par exemple, compilation de Webpack.  Cette étape se termine lorsque Webpack a terminé la construction et que votre collecteur envoie <i>BuilderOutput</i> à l' <i>Observable</i> . </li><li>  <b>Observation.</b>  - Entre deux lancements, les événements externes sont surveillés.  Par exemple, Webpack surveille le système de fichiers pour toute modification.  Cette étape se termine lorsque Webpack reprend la génération et <i>context.reportRunning () est</i> appelé.  Après cette étape, l'étape 1 recommence. </li><li>  <b>Achèvement.</b>  - La tâche est entièrement terminée (par exemple, il était prévu que Webpack démarre un certain nombre de fois) ou le démarrage du collecteur a été arrêté (à l'aide de <i>run.stop ()</i> ).  Dans ce cas, l'algorithme de destruction <i>observable</i> est exécuté et il est effacé. </li></ol><br><h2>  Conclusion </h2><br>  Voici un résumé de ce que nous avons appris dans cette publication: <br><br><ol><li>  Nous fournissons une nouvelle API qui permettra aux développeurs de modifier le comportement des commandes CLI angulaires et d'en ajouter de nouvelles à l'aide d'assembleurs qui implémentent la logique nécessaire. </li><li>  Les collecteurs peuvent être synchrones, asynchrones et sensibles aux événements externes.  Ils peuvent être appelés plusieurs fois, ainsi que par d'autres collectionneurs. </li><li>  Les paramètres que le collecteur reçoit au démarrage de la tâche sont d'abord lus dans le fichier <i>angular.json</i> , puis ils sont remplacés par les paramètres de la configuration, le cas échéant, puis remplacés par les indicateurs de ligne de commande s'ils ont été ajoutés. </li><li>  La méthode recommandée pour tester les collecteurs consiste à effectuer des tests d'intégration, mais vous pouvez effectuer des tests unitaires séparément de la logique du collecteur. </li><li>  Si le collecteur renvoie un observable, il doit être effacé après avoir traversé l'algorithme de destruction. </li></ol><br>  Dans un avenir proche, la fréquence d'utilisation de ces API augmentera.  Par exemple, l'implémentation Bazel leur est fortement associée. <br><br>  Nous voyons déjà comment la communauté crée de nouveaux collecteurs CLI à utiliser, par exemple, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jest</a></i> et <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cypress</a></i> pour les tests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450746/">https://habr.com/ru/post/fr450746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450734/index.html">Le fuzzing est une étape importante dans un développement sûr</a></li>
<li><a href="../fr450736/index.html">«Isoler Internet est beaucoup plus facile et moins cher que de lui fournir un blocage externe.»</a></li>
<li><a href="../fr450738/index.html">Robots dans le centre de données: comment l'intelligence artificielle peut-elle être utile?</a></li>
<li><a href="../fr450740/index.html">Pied de lampe intelligent REDMOND - ajouter à la maison intelligente</a></li>
<li><a href="../fr450744/index.html">Infrastructure cyclable de Minsk pour un expatrié informatique</a></li>
<li><a href="../fr450748/index.html">Certification ISTQB. Partie 1: être ou ne pas être?</a></li>
<li><a href="../fr450752/index.html">«Je n'ai qu'une seule méthode d'enseignement: juste travailler» - entretien avec Ryan Dahl (Node.js, Deno)</a></li>
<li><a href="../fr450754/index.html">Courses en fauteuil roulant: un pilote russe remporte le championnat CYBATHLON à Tokyo</a></li>
<li><a href="../fr450756/index.html">À propos des incapacités militaires</a></li>
<li><a href="../fr450758/index.html">factory_trace gem aide à nettoyer vos usines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>