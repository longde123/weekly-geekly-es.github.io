<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶‚Äçüë¶ üè≥Ô∏è‚Äçüåà üåû Pr√©sentation de CLI Builder üßíüèΩ üëãüèº üë©üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous examinerons la nouvelle API CLI angulaire, qui vous permettra d'√©tendre les fonctionnalit√©s CLI existantes et d'en ajouter de n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pr√©sentation de CLI Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450746/"><img src="https://habrastorage.org/webt/sm/xo/kb/smxokbjs_uhwjcb1rjv7cwt5k3m.png" alt="Pr√©sentation de CLI Builder"><br><br>  Dans cet article, nous examinerons la nouvelle API CLI angulaire, qui vous permettra d'√©tendre les fonctionnalit√©s CLI existantes et d'en ajouter de nouvelles.  Nous verrons comment travailler avec cette API et quels sont les points de son extension qui permettent d'ajouter de nouvelles fonctionnalit√©s √† la CLI. <br><a name="habracut"></a><br><h2>  L'histoire </h2><br>  Il y a environ un an, nous avons introduit le fichier d'espace de travail ( <i>angular.json</i> ) dans la CLI angulaire et repens√© de nombreux principes de base pour impl√©menter ses commandes.  Nous sommes arriv√©s au fait d'avoir plac√© les √©quipes dans les ¬´cases¬ª: <br><br><ol><li> <b>Commandes sch√©matiques - "Commandes sch√©matiques"</b> .  √Ä ce jour, vous avez probablement d√©j√† entendu parler de Schematics, la biblioth√®que utilis√©e par la CLI pour g√©n√©rer et modifier votre code.  Il est apparu dans la version 5 et est actuellement utilis√© dans la plupart des commandes qui concernent votre code, comme <i>nouveau</i> , <i>g√©n√©rer</i> , <i>ajouter</i> et <i>mettre √† jour</i> . </li><li>  <b>Commandes diverses - "Autres √©quipes"</b> .  Ce sont des commandes qui ne sont pas directement li√©es √† votre projet: <i>aide</i> , <i>version</i> , <i>config</i> , <i>doc</i> .  R√©cemment, des <i>analyses</i> ont √©galement fait leur apparition, ainsi que nos ≈ìufs de P√¢ques (Chut! Pas un mot √† personne!). </li><li>  <b>Commandes de t√¢che - "Commandes de t√¢che"</b> .  Cette cat√©gorie, dans l'ensemble, ¬´lance les processus ex√©cut√©s sur le code d'autres personnes¬ª.  - Par exemple, <i>build</i> est une construction de projet, <i>lint</i> d√©bogue et <i>test</i> teste. </li></ol><br>  Nous avons commenc√© √† concevoir <i>angular.json</i> il y a longtemps.  Initialement, il a √©t√© con√ßu en remplacement de la configuration Webpack.  En outre, il √©tait cens√© permettre aux d√©veloppeurs de choisir ind√©pendamment la mise en ≈ìuvre de l'assemblage du projet.  En cons√©quence, nous avons obtenu un syst√®me de lancement de t√¢che de base, qui est rest√© simple et pratique pour nos exp√©riences.  Nous avons appel√© cette API "Architecte". <br><br>  Malgr√© le fait que Architect n'√©tait pas officiellement pris en charge, il √©tait populaire parmi les d√©veloppeurs qui souhaitaient personnaliser l'assemblage des projets, ainsi que parmi les biblioth√®ques tierces qui devaient contr√¥ler leur flux de travail.  Nx l'a utilis√© pour ex√©cuter les commandes Bazel, Ionic l'a utilis√© pour ex√©cuter des tests unitaires sur Jest, et les utilisateurs ont pu √©tendre leurs configurations Webpack en utilisant des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ngx-build-plus</a> .  Et ce n'√©tait que le d√©but. <br><br>  <b>Une version officiellement prise en charge, stable et am√©lior√©e de cette API est utilis√©e dans Angular CLI version 8.</b> <br><br><h2>  Concept </h2><br>  L'API Architect propose des outils de planification et de coordination des t√¢ches que la CLI angulaire utilise pour impl√©menter ses commandes.  Il utilise des fonctions appel√©es <br>  ¬´Constructeurs¬ª - ¬´collectionneurs¬ª qui peuvent agir en tant que t√¢ches ou planificateurs d'autres collectionneurs.  De plus, il utilise angular.json comme un ensemble d'instructions pour les collectionneurs eux-m√™mes. <br><br>  Il s'agit d'un syst√®me tr√®s g√©n√©ral con√ßu pour √™tre flexible et extensible.  Il contient une API pour les rapports, la journalisation et les tests.  Si n√©cessaire, le syst√®me peut √™tre √©tendu pour de nouvelles t√¢ches. <br><br><h2>  Pickers </h2><br>  Les assembleurs sont des fonctions qui impl√©mentent la logique et le comportement d'une t√¢che pouvant remplacer la commande CLI.  - Par exemple, d√©marrez le linter. <br><br>  La fonction de collecteur prend deux arguments: la valeur d'entr√©e (ou les options) et le contexte qui fournit la relation entre la CLI et le collecteur lui-m√™me.  La r√©partition des responsabilit√©s ici est la m√™me que dans les sch√©mas - l'utilisateur CLI d√©finit les options, l'API est responsable du contexte et vous (le d√©veloppeur) d√©finissez le comportement n√©cessaire.  Le comportement peut √™tre impl√©ment√© de mani√®re synchrone, asynchrone ou afficher simplement un certain nombre de valeurs.  La sortie doit √™tre de type <i>BuilderOutput</i> , qui contient le <i>succ√®s du</i> champ logique et l' <i>erreur de</i> champ facultatif, qui contient le message d'erreur. <br><br><h2>  Fichier et t√¢ches de l'espace de travail </h2><br>  L'API Architect repose sur <i>angular.json</i> , un fichier d'espace de travail pour stocker les t√¢ches et leurs param√®tres. <br><br>  <i>angular.json</i> divise l'espace de travail en projets et ceux-ci, √† leur tour, en t√¢ches.  Par exemple, votre application cr√©√©e avec la commande <i>ng new</i> est l'un de ces projets.  L'une des t√¢ches de ce projet sera la t√¢che de <i>g√©n√©ration</i> , qui peut √™tre lanc√©e √† l'aide de la <i>commande ng build</i> .  Par d√©faut, cette t√¢che a trois cl√©s: <br><br><ol><li>  <b>constructeur</b> - le nom du collecteur √† utiliser pour terminer la t√¢che, au format <i>PACKAGE_NAME: ASSEMBLY_NAME</i> . </li><li>  <b>options</b> - param√®tres utilis√©s lors du d√©marrage d'une t√¢che par d√©faut. </li><li>  <b>configurations</b> - param√®tres qui seront appliqu√©s lors du d√©marrage d'une t√¢che avec la configuration sp√©cifi√©e. </li></ol><br>  Les param√®tres sont appliqu√©s comme suit: lorsque la t√¢che d√©marre, les param√®tres sont extraits du bloc d'options, puis, si une configuration a √©t√© sp√©cifi√©e, ses param√®tres sont √©crits par-dessus ceux existants.  Apr√®s cela, si des param√®tres suppl√©mentaires ont √©t√© transmis √† <i>scheduleTarget ()</i> - le bloc de <i>remplacement</i> , ils seront √©crits en dernier.  Lors de l'utilisation de la CLI angulaire, les arguments de ligne de commande sont pass√©s √† des <i>remplacements</i> .  Une fois tous les param√®tres transf√©r√©s au collecteur, il les v√©rifie selon son sch√©ma, et uniquement si les param√®tres y correspondent, le contexte sera cr√©√© et le collecteur commencera √† fonctionner. <br><br>  Plus d'informations sur l'espace de travail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Cr√©ez votre propre collectionneur </h2><br>  Par exemple, cr√©ons un collecteur qui ex√©cutera une commande sur la ligne de commande.  Pour cr√©er un collecteur, utilisez la fabrique <i>createBuilder</i> et renvoyez l'objet <i>BuilderOutput</i> : <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }); });</code> </pre> <br>  Maintenant, ajoutons une logique √† notre collecteur: nous voulons contr√¥ler le collecteur via les param√®tres, cr√©er de nouveaux processus, attendre que le processus se termine, et si le processus s'est termin√© avec succ√®s (c'est-√†-dire, renvoyer le code 0), signalez-le √† Architect: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Traitement de sortie </h2><br>  Maintenant, la m√©thode d' <i>apparition</i> transmet toutes les donn√©es √† la sortie standard du processus.  Nous pouvons vouloir les transf√©rer √† l' <i>enregistreur</i> - enregistreur.  Dans ce cas, d'une part, le d√©bogage pendant les tests sera facilit√©, et d'autre part, Architect lui-m√™me peut ex√©cuter notre collecteur dans un processus s√©par√© ou d√©sactiver la sortie standard des processus (par exemple, dans l'application Electron). <br><br>  Pour ce faire, nous pouvons utiliser <i>Logger</i> , disponible dans l'objet <i>contextuel</i> , qui nous permettra de rediriger la sortie du processus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Rapports sur le rendement et l'√©tat </h2><br>  La derni√®re partie de l'API li√©e √† la mise en ≈ìuvre de votre propre collecteur est la progression et les rapports d'√©tat actuels. <br><br>  Dans notre cas, la commande est termin√©e ou ex√©cut√©e, il est donc inutile d'ajouter un rapport de progression.  Cependant, nous pouvons communiquer notre statut au collectionneur parent afin qu'il comprenne ce qui se passe. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Executing "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${options.command}</span></span></span><span class="hljs-string">"...`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Done.`</span></span>); child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br>  Pour passer un rapport de <i>progression</i> , utilisez la m√©thode <i>reportProgress</i> avec les valeurs actuelles et (facultativement) r√©capitulatives comme arguments.  <i>le total</i> peut √™tre n'importe quel nombre.  Par exemple, si vous savez combien de fichiers vous devez traiter, vous pouvez transf√©rer leur nombre au <i>total</i> , puis √† <i>courant,</i> vous pouvez transf√©rer le nombre de fichiers d√©j√† trait√©s.  C'est ainsi que <a href="">le collecteur tslint</a> rend compte de ses progr√®s. <br><br><h2>  Validation des entr√©es </h2><br>  L'objet d' <i>options</i> pass√© au collecteur est v√©rifi√© √† l'aide du sch√©ma JSON.  Ceci est similaire aux sch√©mas si vous savez ce que c'est. <br><br>  Dans notre exemple de collecteur, nous nous attendons √† ce que nos param√®tres soient un objet qui re√ßoit deux cl√©s: <i>commande</i> - commande (cha√Æne) et <i>args</i> - arguments (tableau de cha√Ænes).  Notre sch√©ma de v√©rification ressemblera √† ceci: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://json-schema.org/schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } } }</code> </pre><br>  Les sch√©mas sont des outils vraiment puissants qui peuvent effectuer un grand nombre de contr√¥les.  Pour plus d'informations sur les sch√©mas JSON, vous pouvez vous r√©f√©rer au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site Web officiel du sch√©ma JSON</a> . <br><br><h2>  Cr√©er un package de construction </h2><br>  Il y a un fichier cl√© que nous devons cr√©er pour notre propre collecteur afin de le rendre compatible avec la CLI angulaire - <i>builders.json</i> , qui est responsable de la relation entre notre impl√©mentation du collecteur, son nom et le sch√©ma de v√©rification.  Le fichier lui-m√™me ressemble √† ceci: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"implementation"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command/schema.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Runs any command line in the operating system."</span></span> } } }</code> </pre><br>  Ensuite, dans le fichier <i>package.json</i> , nous ajoutons la cl√© <i>builders</i> , pointant vers le fichier <i>builders.json</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Builder for Architect"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: <span class="hljs-string"><span class="hljs-string">"builders.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devDependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@angular-devkit/architect"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.0.0"</span></span> } }</code> </pre><br>  Cela indiquera √† Architect o√π rechercher le fichier de d√©finition du collecteur. <br><br>  Ainsi, le nom de notre collecteur est <i>"@ example / command-runner: command"</i> .  La premi√®re partie du nom, avant les deux-points (:) est le nom du package, d√©fini √† l'aide de <i>package.json</i> .  La deuxi√®me partie est le nom du collecteur, d√©fini √† l'aide du fichier <i>builders.json</i> . <br><br><h2>  Tester vos propres constructeurs </h2><br>  La m√©thode recommand√©e pour tester les assembleurs consiste √† effectuer des tests d'int√©gration.  En effet, la cr√©ation d'un <i>contexte n'est</i> pas facile, vous devez donc utiliser le planificateur d'Architect. <br><br>  Pour simplifier les mod√®les, nous avons pens√© √† un moyen simple de cr√©er une instance Architect: vous cr√©ez d'abord un <i>JsonSchemaRegistry</i> (pour tester le sch√©ma), puis <i>TestingArchitectHost</i> et, enfin, une instance <i>Architect</i> .  Vous pouvez maintenant compiler le <i>fichier de</i> configuration <i>builders.json</i> . <br><br>  Voici un exemple d'ex√©cution du collecteur, qui ex√©cute la <i>commande ls</i> et v√©rifie que la commande s'est termin√©e avec succ√®s.  Veuillez noter que nous utiliserons la sortie standard des processus dans l' <i>enregistreur</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Architect, ArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TestingArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect/testing'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { logging, schema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/core'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Command Runner Builder'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architect: Architect; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architectHost: ArchitectHost; beforeEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.CoreSchemaRegistry(); registry.addPostTransform(schema.transforms.addUndefinedDefaults); <span class="hljs-comment"><span class="hljs-comment">//  TestingArchitectHost ‚Äì    . //     ,   . architectHost = new TestingArchitectHost(__dirname, __dirname); architect = new Architect(architectHost, registry); //      NPM-, //    package.json  . await architectHost.addBuilderFromPackage('..'); }); //      Windows it('can run ls', async () =&gt; { //  ,     . const logger = new logging.Logger(''); const logs = []; logger.subscribe(ev =&gt; logs.push(ev.message)); // "run"    ,       . const run = await architect.scheduleBuilder('@example/command-runner:command', { command: 'ls', args: [__dirname], }, { logger }); // "result" ‚Äì    . //    "BuilderOutput". const output = await run.result; //  . Architect     //   ,    ,    . await run.stop(); //   . expect(output.success).toBe(true); // ,     . // `ls $__dirname`. expect(logs).toContain('index_spec.ts'); }); });</span></span></code> </pre><br>  Pour ex√©cuter l'exemple ci-dessus, vous avez besoin du package <i>ts-node</i> .  Si vous avez l'intention d'utiliser Node, renommez <i>index_spec.ts</i> en <i>index_spec.js</i> . <br><br><h2>  Utilisation du collecteur dans un projet </h2><br>  Cr√©ons un simple angular.json qui montre tout ce que nous avons appris sur les assembleurs.  En supposant que nous avons compress√© notre collecteur dans <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">exemple</a> / commande-runner</i> puis cr√©√© une nouvelle application en utilisant <i>ng new builder-test</i> , le fichier <i>angular.json</i> pourrait ressembler √† ceci (une partie du contenu a √©t√© supprim√© pour plus de bri√®vet√©): <br><br><pre> <code class="json hljs">{ // ...   . <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } }</code> </pre><br>  Si nous d√©cidions d'ajouter une nouvelle t√¢che pour appliquer (par exemple) la commande <i>tactile</i> au fichier (met √† jour la date de modification du fichier) √† l'aide de notre collecteur, nous ex√©cuterions <i>npm install <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">example</a> / command-runner</i> , puis apporterions des modifications √† <i>angular.json</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"touch"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner:command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"touch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fileReplacements"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"replace"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"with"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.prod.ts"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } } } } }</code> </pre><br>  La CLI angulaire poss√®de une commande d' <i>ex√©cution</i> , qui est la commande principale pour ex√©cuter les collecteurs.  Comme premier argument, il prend une cha√Æne de format <i>PROJECT: TASK [: CONFIGURATION]</i> .  Pour ex√©cuter notre t√¢che, nous pouvons utiliser la commande <i>ng run builder-test: touch</i> . <br><br>  Maintenant, nous pouvons vouloir red√©finir certains arguments.  Malheureusement, nous ne pouvons pas red√©finir les tableaux √† partir de la ligne de commande jusqu'√† pr√©sent, mais nous pouvons modifier la commande elle-m√™me pour la d√©monstration: <i>ng ex√©cutez builder-test: touch --command = ls</i> .  - Cela produira le <i>fichier src / main.ts.</i> <br><br><h2>  Mode montre </h2><br>  Il est suppos√© que, par d√©faut, les collecteurs seront appel√©s une fois et termin√©s, cependant, ils peuvent retourner <i>Observable</i> pour impl√©menter leur propre mode d'observation (comme le <i>fait le</i> collecteur <i>Webpack</i> ).  Architect s'abonnera √† l' <i>Observable</i> jusqu'√† ce qu'il se termine ou s'arr√™te et peut √† nouveau s'abonner au collecteur si le collecteur est appel√© avec les m√™mes param√®tres (bien que cela ne soit pas garanti). <br><br><ol><li>  Le collecteur doit retourner un objet <i>BuilderOutput</i> apr√®s chaque ex√©cution.  Une fois termin√©, il peut entrer en mode d'observation provoqu√© par un √©v√©nement externe et, s'il recommence, il devra appeler la fonction <i>context.reportRunning ()</i> pour informer l'architecte que le collecteur fonctionne √† nouveau.  Cela emp√™chera le collecteur de l'arr√™ter par l'architecte lors d'un nouvel appel. </li><li>  L'architecte lui-m√™me se d√©sabonne d' <i>Observable</i> lorsque le collecteur s'arr√™te (en utilisant run.stop (), par exemple), en utilisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">logique Teardown</a> - l'algorithme de destruction.  Cela vous permettra d'arr√™ter et d'effacer l'assembly si ce processus est d√©j√† en cours d'ex√©cution. </li></ol><br>  Pour r√©sumer ce qui pr√©c√®de, si votre collectionneur regarde des √©v√©nements externes, cela fonctionne en trois √©tapes: <br><br><ol><li>  <b>Accomplissement.</b>  Par exemple, compilation de Webpack.  Cette √©tape se termine lorsque Webpack a termin√© la construction et que votre collecteur envoie <i>BuilderOutput</i> √† l' <i>Observable</i> . </li><li>  <b>Observation.</b>  - Entre deux lancements, les √©v√©nements externes sont surveill√©s.  Par exemple, Webpack surveille le syst√®me de fichiers pour toute modification.  Cette √©tape se termine lorsque Webpack reprend la g√©n√©ration et <i>context.reportRunning () est</i> appel√©.  Apr√®s cette √©tape, l'√©tape 1 recommence. </li><li>  <b>Ach√®vement.</b>  - La t√¢che est enti√®rement termin√©e (par exemple, il √©tait pr√©vu que Webpack d√©marre un certain nombre de fois) ou le d√©marrage du collecteur a √©t√© arr√™t√© (√† l'aide de <i>run.stop ()</i> ).  Dans ce cas, l'algorithme de destruction <i>observable</i> est ex√©cut√© et il est effac√©. </li></ol><br><h2>  Conclusion </h2><br>  Voici un r√©sum√© de ce que nous avons appris dans cette publication: <br><br><ol><li>  Nous fournissons une nouvelle API qui permettra aux d√©veloppeurs de modifier le comportement des commandes CLI angulaires et d'en ajouter de nouvelles √† l'aide d'assembleurs qui impl√©mentent la logique n√©cessaire. </li><li>  Les collecteurs peuvent √™tre synchrones, asynchrones et sensibles aux √©v√©nements externes.  Ils peuvent √™tre appel√©s plusieurs fois, ainsi que par d'autres collectionneurs. </li><li>  Les param√®tres que le collecteur re√ßoit au d√©marrage de la t√¢che sont d'abord lus dans le fichier <i>angular.json</i> , puis ils sont remplac√©s par les param√®tres de la configuration, le cas √©ch√©ant, puis remplac√©s par les indicateurs de ligne de commande s'ils ont √©t√© ajout√©s. </li><li>  La m√©thode recommand√©e pour tester les collecteurs consiste √† effectuer des tests d'int√©gration, mais vous pouvez effectuer des tests unitaires s√©par√©ment de la logique du collecteur. </li><li>  Si le collecteur renvoie un observable, il doit √™tre effac√© apr√®s avoir travers√© l'algorithme de destruction. </li></ol><br>  Dans un avenir proche, la fr√©quence d'utilisation de ces API augmentera.  Par exemple, l'impl√©mentation Bazel leur est fortement associ√©e. <br><br>  Nous voyons d√©j√† comment la communaut√© cr√©e de nouveaux collecteurs CLI √† utiliser, par exemple, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jest</a></i> et <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cypress</a></i> pour les tests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450746/">https://habr.com/ru/post/fr450746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450734/index.html">Le fuzzing est une √©tape importante dans un d√©veloppement s√ªr</a></li>
<li><a href="../fr450736/index.html">¬´Isoler Internet est beaucoup plus facile et moins cher que de lui fournir un blocage externe.¬ª</a></li>
<li><a href="../fr450738/index.html">Robots dans le centre de donn√©es: comment l'intelligence artificielle peut-elle √™tre utile?</a></li>
<li><a href="../fr450740/index.html">Pied de lampe intelligent REDMOND - ajouter √† la maison intelligente</a></li>
<li><a href="../fr450744/index.html">Infrastructure cyclable de Minsk pour un expatri√© informatique</a></li>
<li><a href="../fr450748/index.html">Certification ISTQB. Partie 1: √™tre ou ne pas √™tre?</a></li>
<li><a href="../fr450752/index.html">¬´Je n'ai qu'une seule m√©thode d'enseignement: juste travailler¬ª - entretien avec Ryan Dahl (Node.js, Deno)</a></li>
<li><a href="../fr450754/index.html">Courses en fauteuil roulant: un pilote russe remporte le championnat CYBATHLON √† Tokyo</a></li>
<li><a href="../fr450756/index.html">√Ä propos des incapacit√©s militaires</a></li>
<li><a href="../fr450758/index.html">factory_trace gem aide √† nettoyer vos usines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>