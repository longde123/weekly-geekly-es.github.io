<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ‘¨ğŸ¿â€ğŸ’¼ OS1ï¼šRust for x86ä¸Šçš„åŸå§‹å†…æ ¸ã€‚ ç¬¬3éƒ¨åˆ†ã€‚å­˜å‚¨å¡ï¼Œé¡µé¢é”™è¯¯å¼‚å¸¸ï¼Œå †å’Œåˆ†é… ğŸ•‰ï¸ ğŸ•³ï¸ ğŸ”¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ç¬¬ä¸€éƒ¨åˆ† 
 ç¬¬äºŒéƒ¨åˆ† 


 ä»Šå¤©çš„å¯¹è¯ä¸»é¢˜æ˜¯å¤„ç†å†…å­˜ã€‚ æˆ‘å°†è®¨è®ºåˆå§‹åŒ–é¡µé¢ç›®å½•ï¼Œæ˜ å°„ç‰©ç†å†…å­˜ï¼Œç®¡ç†è™šæ‹Ÿæœºä»¥åŠåˆ†é…å™¨çš„ç»„ç»‡å †ã€‚ 


 æ­£å¦‚æˆ‘åœ¨ç¬¬ä¸€ç¯‡æ–‡ç« ä¸­æ‰€è¯´çš„ï¼Œæˆ‘å†³å®šä½¿ç”¨4 MBé¡µé¢æ¥ç®€åŒ–æˆ‘çš„ç”Ÿæ´»ï¼Œè€Œä¸å¿…å¤„ç†åˆ†å±‚è¡¨ã€‚ å°†æ¥ï¼Œæˆ‘å¸Œæœ›åƒå¤§å¤šæ•°ç°ä»£ç³»ç»Ÿä¸€æ ·è½¬åˆ°4 KBé¡µé¢ã€‚ æˆ‘å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç°æˆçš„ï¼ˆä¾‹...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1ï¼šRust for x86ä¸Šçš„åŸå§‹å†…æ ¸ã€‚ ç¬¬3éƒ¨åˆ†ã€‚å­˜å‚¨å¡ï¼Œé¡µé¢é”™è¯¯å¼‚å¸¸ï¼Œå †å’Œåˆ†é…</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446214/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ç¬¬ä¸€éƒ¨åˆ†</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ç¬¬äºŒéƒ¨åˆ†</a> </p><br><p> ä»Šå¤©çš„å¯¹è¯ä¸»é¢˜æ˜¯å¤„ç†å†…å­˜ã€‚ æˆ‘å°†è®¨è®ºåˆå§‹åŒ–é¡µé¢ç›®å½•ï¼Œæ˜ å°„ç‰©ç†å†…å­˜ï¼Œç®¡ç†è™šæ‹Ÿæœºä»¥åŠåˆ†é…å™¨çš„ç»„ç»‡å †ã€‚ </p><br><p> æ­£å¦‚æˆ‘åœ¨ç¬¬ä¸€ç¯‡æ–‡ç« ä¸­æ‰€è¯´çš„ï¼Œæˆ‘å†³å®šä½¿ç”¨4 MBé¡µé¢æ¥ç®€åŒ–æˆ‘çš„ç”Ÿæ´»ï¼Œè€Œä¸å¿…å¤„ç†åˆ†å±‚è¡¨ã€‚ å°†æ¥ï¼Œæˆ‘å¸Œæœ›åƒå¤§å¤šæ•°ç°ä»£ç³»ç»Ÿä¸€æ ·è½¬åˆ°4 KBé¡µé¢ã€‚ æˆ‘å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç°æˆçš„ï¼ˆä¾‹å¦‚ï¼Œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">è¿™æ ·çš„å—åˆ†é…å™¨</a> ï¼‰ï¼Œä½†æ˜¯ç¼–å†™è‡ªå·±çš„ä»£ç æœ‰ç‚¹æœ‰è¶£ï¼Œå¹¶ä¸”æˆ‘æƒ³æ›´å¤šåœ°äº†è§£å†…å­˜çš„å¯¿å‘½ï¼Œæ‰€ä»¥æˆ‘æœ‰è¯è¦å‘Šè¯‰ä½ ã€‚ </p><a name="habracut"></a><br><p>ä¸Šä¸€æ¬¡æˆ‘ç¡®å®šä¸ä½“ç³»ç»“æ„ç›¸å…³çš„setup_pdæ–¹æ³•å¹¶å¸Œæœ›ç»§ç»­ä½¿ç”¨è¯¥æ–¹æ³•æ—¶ï¼Œä½†æ˜¯ï¼Œæˆ‘åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æ²¡æœ‰æ¶‰åŠæ›´å¤šç»†èŠ‚-ä½¿ç”¨Rustå’Œæ ‡å‡†printlnå®çš„VGAè¾“å‡ºã€‚ ç”±äºå®ƒçš„å®ç°æ˜¯å¾®ä¸è¶³é“çš„ï¼Œå› æ­¤æˆ‘å°†åœ¨ç ´åå™¨ä¸‹å°†å…¶åˆ é™¤ã€‚ è¯¥ä»£ç åœ¨è°ƒè¯•åŒ…ä¸­ã€‚ </p><br><div class="spoiler">  <b class="spoiler_title">å®æ‰“å°</b> <div class="spoiler_text"><pre><code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> print { ($($arg:tt)*) =&gt; ($crate::debug::_print(<span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> println { () =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)); ($($arg:tt)*) =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; vga::VGA_WRITER.lock().write_fmt(args).unwrap(); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; <span class="hljs-comment"><span class="hljs-comment">// vga::VGA_WRITER.lock().write_fmt(args).unwrap(); }</span></span></code> </pre> </div></div><br><p> ç°åœ¨ï¼Œæˆ‘æ€€ç€æ˜ç¡®çš„è‰¯çŸ¥ï¼Œå›åˆ°è®°å¿†ä¸­ã€‚ </p><br><h1 id="inicializaciya-direktorii-stranic"> é¡µé¢ç›®å½•åˆå§‹åŒ– </h1><br><p> æˆ‘ä»¬çš„kmainæ–¹æ³•é‡‡ç”¨ä¸‰ä¸ªå‚æ•°ä½œä¸ºè¾“å…¥ï¼Œå…¶ä¸­ä¹‹ä¸€æ˜¯é¡µé¢è¡¨çš„è™šæ‹Ÿåœ°å€ã€‚ è¦åœ¨ä»¥åå°†å…¶ç”¨äºåˆ†é…å’Œå†…å­˜ç®¡ç†ï¼Œæ‚¨éœ€è¦æŒ‡å®šè®°å½•å’Œç›®å½•çš„ç»“æ„ã€‚ å¯¹äºx86ï¼ŒPageç›®å½•å’ŒPageè¡¨çš„æè¿°éå¸¸å¥½ï¼Œå› æ­¤ï¼Œæˆ‘å°†ä»…ä½œä¸€ä¸ªç®€çŸ­çš„ä»‹ç»ã€‚  Pageç›®å½•æ¡ç›®æ˜¯ä¸€ä¸ªæŒ‡é’ˆå¤§å°ç»“æ„ï¼Œå¯¹æˆ‘ä»¬æ¥è¯´æ˜¯4ä¸ªå­—èŠ‚ã€‚ è¯¥å€¼åŒ…å«é¡µé¢çš„4KBç‰©ç†åœ°å€ã€‚ è®°å½•çš„æœ€ä½æœ‰æ•ˆå­—èŠ‚ä¿ç•™ç»™æ ‡å¿—ã€‚ å°†è™šæ‹Ÿåœ°å€è½¬æ¢ä¸ºç‰©ç†åœ°å€çš„æœºåˆ¶å¦‚ä¸‹æ‰€ç¤ºï¼ˆåœ¨æˆ‘çš„4 MBç²’åº¦æƒ…å†µä¸‹ï¼Œç§»ä½å‘ç”Ÿ22ä½ã€‚å¯¹äºå…¶ä»–ç²’åº¦ï¼Œç§»ä½å°†æœ‰æ‰€ä¸åŒï¼Œå¹¶ä¸”å°†ä½¿ç”¨åˆ†å±‚è¡¨ï¼ï¼‰ï¼š </p><br><blockquote> è™šæ‹Ÿåœ°å€0xC010A110-&gt;é€šè¿‡å‘å³ç§»åŠ¨22ä½åœ°å€æ¥è·å–ç›®å½•ä¸­çš„ç´¢å¼•-&gt;ç´¢å¼•0x300-&gt;é€šè¿‡ç´¢å¼•0x300è·å–é¡µé¢çš„ç‰©ç†åœ°å€ï¼Œæ£€æŸ¥æ ‡å¿—å’ŒçŠ¶æ€-&gt; 0x1000000-&gt;ä»¥è™šæ‹Ÿåœ°å€çš„åº•22ä½ä½œä¸ºåç§»é‡ï¼Œæ·»åŠ åˆ°é¡µé¢çš„ç‰©ç†åœ°å€-&gt; 0x1000000 + 0x10A110 =å†…å­˜ä¸­çš„ç‰©ç†åœ°å€0x110A110 </blockquote><p> ä¸ºäº†åŠ å¿«è®¿é—®é€Ÿåº¦ï¼Œå¤„ç†å™¨ä½¿ç”¨TLB-è½¬æ¢åå¤‡ç¼“å†²åŒºæ¥ç¼“å­˜é¡µé¢åœ°å€ã€‚ </p><br><p> å› æ­¤ï¼Œè¿™æ˜¯æˆ‘çš„ç›®å½•åŠå…¶æ¡ç›®çš„æè¿°æ–¹å¼ï¼Œå¹¶ä¸”å®ç°äº†setup_pdæ–¹æ³•ã€‚ ä¸ºäº†ç¼–å†™é¡µé¢ï¼Œå®ç°äº†â€œæ„é€ å‡½æ•°â€æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¿è¯4 KBçš„å¯¹é½æ–¹å¼å’Œè®¾ç½®æ ‡å¿—ï¼Œä»¥åŠä¸€ç§è·å–é¡µé¢ç‰©ç†åœ°å€çš„æ–¹æ³•ã€‚ ç›®å½•åªæ˜¯ç”±1024ä¸ªå››å­—èŠ‚æ¡ç›®ç»„æˆçš„æ•°ç»„ã€‚ è¯¥ç›®å½•å¯ä»¥ä½¿ç”¨set_by_addræ–¹æ³•å°†è™šæ‹Ÿåœ°å€ä¸é¡µé¢ç›¸å…³è”ã€‚ </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectoryEntry</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_phys_address</span></span></span></span>(address: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flags: PDEntryFlags) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { PDirectoryEntry((address <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &amp; ADDRESS_MASK | flags.bits()) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flags</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; PDEntryFlags { PDEntryFlags::from_bits_truncate(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_address</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp; ADDRESS_MASK } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbg</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectory</span></span></span></span> { entries: [PDirectoryEntry; <span class="hljs-number"><span class="hljs-number">1024</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectory { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_by_addr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(PDirectory::to_idx(logical_addr), entry); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] = entry; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { invalidate_page(idx); } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_logical_addr</span></span></span></span>(idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (idx &lt;&lt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_idx</span></span></span></span>(logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (logical_addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> PAGE_DIRECTORY: Mutex&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory&gt; = Mutex::new( <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC0000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory) } ); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pd</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data = PAGE_DIRECTORY.lock(); *data = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(pd <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory); }</code> </pre> <br><p> æˆ‘éå¸¸ç¬¨æ‹™åœ°å°†åˆå§‹é™æ€åˆå§‹åŒ–è®¾ç½®ä¸ºä¸å­˜åœ¨çš„åœ°å€ï¼Œå› æ­¤ï¼Œå¦‚æœæ‚¨èƒ½ç»™æˆ‘å†™ä¿¡ï¼ŒRustç¤¾åŒºä¸­å¦‚ä½•ä½¿ç”¨é“¾æ¥é‡æ–°åˆ†é…è¿›è¡Œæ­¤ç±»åˆå§‹åŒ–ï¼Œæˆ‘å°†ä¸èƒœæ„Ÿæ¿€ã€‚ </p><br><p> ç°åœ¨æˆ‘ä»¬å¯ä»¥ä»é«˜çº§ä»£ç ç®¡ç†é¡µé¢ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­ç¼–è¯‘å†…å­˜åˆå§‹åŒ–ã€‚ è¿™å°†åˆ†ä¸¤ä¸ªé˜¶æ®µè¿›è¡Œï¼šé€šè¿‡å¤„ç†ç‰©ç†å­˜å‚¨å¡å’Œåˆå§‹åŒ–è™šæ‹Ÿç®¡ç†å™¨ </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mb_magic { <span class="hljs-number"><span class="hljs-number">0x2BADB002</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"multibooted v1, yeah, reading mb info"</span></span>); boot::init_with_mb1(mb_pointer); }, . . . . . . } memory::init();</code> </pre> <br><h1 id="karta-pamyati-grub-i-karta-fizicheskoy-pamyati-os1">  GRUBå­˜å‚¨å¡å’ŒOS1ç‰©ç†å­˜å‚¨å¡ </h1><br><p> ä¸ºäº†ä»GRUBè·å–å­˜å‚¨å¡ï¼Œåœ¨å¼•å¯¼é˜¶æ®µï¼Œæˆ‘åœ¨æ ‡å¤´ä¸­è®¾ç½®äº†ç›¸åº”çš„æ ‡å¿—ï¼Œè€ŒGRUBç»™äº†æˆ‘ç»“æ„çš„ç‰©ç†åœ°å€ã€‚ æˆ‘å°†å…¶ä»<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å®˜æ–¹æ–‡æ¡£</a>ç§»æ¤åˆ°Rustè¡¨ç¤ºæ³•ï¼Œè¿˜æ·»åŠ äº†ä¸€äº›æ–¹æ³•æ¥è½»æ¾åœ°éå†å­˜å‚¨å¡ã€‚  GRUBçš„å¤§éƒ¨åˆ†ç»“æ„éƒ½ä¸ä¼šè¢«å¡«å……ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µï¼Œè¿™å¯¹æˆ‘æ¥è¯´ä¸æ˜¯å¾ˆæœ‰è¶£ã€‚ æœ€ä¸»è¦çš„æ˜¯ï¼Œæˆ‘ä¸æƒ³æ‰‹åŠ¨ç¡®å®šå¯ç”¨å†…å­˜é‡ã€‚ </p><br><p> é€šè¿‡Multibootåˆå§‹åŒ–æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆå°†ç‰©ç†åœ°å€è½¬æ¢ä¸ºè™šæ‹Ÿåœ°å€ã€‚ ä»ç†è®ºä¸Šè®²ï¼ŒGRUBå¯ä»¥å°†ç»“æ„æ”¾ç½®åœ¨ä»»ä½•ä½ç½®ï¼Œå› æ­¤ï¼Œå¦‚æœåœ°å€è¶…å‡ºé¡µé¢èŒƒå›´ï¼Œåˆ™éœ€è¦åœ¨Pageç›®å½•ä¸­åˆ†é…è™šæ‹Ÿé¡µé¢ã€‚ å®é™…ä¸Šï¼Œè¯¥ç»“æ„å‡ ä¹æ€»æ˜¯ä½äºç¬¬ä¸€ä¸ªå…†å­—èŠ‚ä¹‹åï¼Œæˆ‘ä»¬å·²ç»åœ¨å¼•å¯¼é˜¶æ®µåˆ†é…äº†è¯¥å…†å­—èŠ‚ã€‚ ä»¥é˜²ä¸‡ä¸€ï¼Œæˆ‘ä»¬æ£€æŸ¥å­˜å‚¨å¡æ˜¯å¦å­˜åœ¨å¹¶ç»§ç»­è¿›è¡Œåˆ†æã€‚ </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot2; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_pointer</span></span></span></span>(mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-comment"><span class="hljs-comment">//if in first 4 MB - map to kernel address space if mb_pointer &lt; 0x400000 { arch::KERNEL_BASE | mb_pointer } else { arch::paging::allocate_page(mb_pointer, arch::MB_INFO_BASE, arch::paging::PDEntryFlags::PRESENT | arch::paging::PDEntryFlags::WRITABLE | arch::paging::PDEntryFlags::HUGE_PAGE ); arch::MB_INFO_BASE | mb_pointer } } pub fn init_with_mb1(mb_pointer: usize) { let ln_pointer = unsafe { process_pointer(mb_pointer) }; println!("mb pointer 0x{:X}", ln_pointer); let mb_info = multiboot::from_ptr(ln_pointer); println!("mb flags: {:?}", mb_info.flags().unwrap()); if mb_info.flags().unwrap().contains(multiboot::MBInfoFlags::MEM_MAP) { multiboot::parse_mmap(mb_info); println!("Multiboot memory map parsed, physical memory map has been built"); } else { panic!("MB mmap is not presented"); } }</span></span></code> </pre> <br><p> å­˜å‚¨å¡æ˜¯ä¸€ä¸ªé“¾æ¥åˆ—è¡¨ï¼Œåœ¨åŸºæœ¬ç»“æ„ä¸­ä¸ºå…¶æŒ‡å®šäº†åˆå§‹ç‰©ç†åœ°å€ï¼ˆä¸è¦å¿˜è®°å°†æ‰€æœ‰å†…å®¹è½¬æ¢ä¸ºè™šæ‹Ÿåœ°å€ï¼‰ï¼Œå¹¶ä»¥å­—èŠ‚ä¸ºå•ä½æŒ‡å®šæ•°ç»„çš„å¤§å°ã€‚ æ‚¨å¿…é¡»æ ¹æ®æ¯ä¸ªå…ƒç´ çš„å¤§å°éå†åˆ—è¡¨ï¼Œå› ä¸º<em>ç†è®ºä¸Š</em>å®ƒä»¬çš„å¤§å°å¯ä»¥ä¸åŒã€‚ è¿™æ˜¯è¿­ä»£çš„æ ·å­ï¼š </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MultibootInfo { . . . . . . <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mmap</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry&gt; { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::arch::get_mb_pointer_base; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> base: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = get_mb_pointer_base(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry = (base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..index { iter = ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + ((*iter).size <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) - base) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_lenght) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {} } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(iter) } }</code> </pre> <br><p> è§£æå­˜å‚¨å¡æ—¶ï¼Œæˆ‘ä»¬éå†GRUBç»“æ„å¹¶å°†å…¶è½¬æ¢ä¸ºä½å›¾ï¼ŒOS1å°†ä½¿ç”¨è¯¥ä½å›¾æ¥ç®¡ç†ç‰©ç†å†…å­˜ã€‚ å°½ç®¡GRUBå’ŒBIOSæä¾›äº†æ›´å¤šé€‰é¡¹ï¼Œä½†æˆ‘å†³å®šå°†è‡ªå·±é™åˆ¶åœ¨ä¸€å°éƒ¨åˆ†å¯ç”¨çš„æ§åˆ¶å€¼ä¸Š-ç©ºé—²ï¼Œå¿™ç¢Œï¼Œä¿ç•™ï¼Œä¸å¯ç”¨ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬éå†æ˜ å°„æ¡ç›®å¹¶å°†å…¶çŠ¶æ€ä»GRUB / BIOSå€¼è½¬æ¢ä¸ºOS1çš„å€¼ï¼š </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_mmap</span></span></span></span>(mbi: &amp;MultibootInfo) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmap_opt = mbi.get_mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = mmap_opt.unwrap(); crate::memory::physical::map((*mmap).addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, (*mmap).len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, translate_multiboot_mem_to_os1(&amp;(*mmap).mtype)); mmap_opt = mbi.get_mmap(i); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mmap_opt { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, _ =&gt; i += <span class="hljs-number"><span class="hljs-number">1</span></span>, } } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate_multiboot_mem_to_os1</span></span></span></span>(mtype: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::memory::physical::{RESERVED, UNUSABLE, USABLE}; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mtype { &amp;MULTIBOOT_MEMORY_AVAILABLE =&gt; USABLE, &amp;MULTIBOOT_MEMORY_RESERVED =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_ACPI_RECLAIMABLE =&gt; RESERVED, &amp;MULTIBOOT_MEMORY_NVS =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_BADRAM =&gt; UNUSABLE, _ =&gt; UNUSABLE } }</code> </pre> <br><p> ç‰©ç†å†…å­˜åœ¨memory ::ç‰©ç†æ¨¡å—ä¸­è¿›è¡Œç®¡ç†ï¼Œä¸ºæ­¤æˆ‘ä»¬åœ¨ä¸Šé¢è°ƒç”¨äº†mapæ–¹æ³•ï¼Œå¹¶å‘å…¶ä¼ é€’åŒºåŸŸçš„åœ°å€ï¼Œå…¶é•¿åº¦å’ŒçŠ¶æ€ã€‚ ç³»ç»Ÿå¯èƒ½å¯ç”¨çš„æ‰€æœ‰4 GBå†…å­˜ï¼Œå¹¶åˆ’åˆ†ä¸º4 MBé¡µé¢ï¼Œç”±ä½å›¾ä¸­çš„ä¸¤ä½è¡¨ç¤ºï¼Œè¿™ä½¿æ‚¨å¯ä»¥ä¸º1024é¡µå­˜å‚¨4ç§çŠ¶æ€ã€‚ è¯¥æ„é€ æ€»å…±éœ€è¦256ä¸ªå­—èŠ‚ã€‚ ä½å›¾ä¼šå¯¼è‡´ä¸¥é‡çš„å†…å­˜ç¢ç‰‡ï¼Œä½†å®ƒæ˜“äºç†è§£ä¸”æ˜“äºå®ç°ï¼Œè¿™æ˜¯æˆ‘çš„ä¸»è¦ç›®æ ‡ã€‚ </p><br><p> æˆ‘å°†åˆ é™¤æ‰°æµå™¨ä¸‹çš„ä½å›¾å®ç°ï¼Œä»¥å…ä½¿æ–‡ç« æ··ä¹±ã€‚ è¯¥ç»“æ„èƒ½å¤Ÿè®¡ç®—ç±»å’Œå¯ç”¨å†…å­˜çš„æ•°é‡ï¼Œé€šè¿‡ç´¢å¼•å’Œåœ°å€æ ‡è®°é¡µé¢ï¼Œè¿˜å¯ä»¥æœç´¢å¯ç”¨é¡µé¢ï¼ˆå°†æ¥åœ¨å®ç°å †æ—¶å°†éœ€è¦ä½¿ç”¨è¯¥é¡µé¢ï¼‰ã€‚ è¯¥å¡æœ¬èº«æ˜¯ä¸€ä¸ªç”±64ä¸ªu32å…ƒç´ ç»„æˆçš„æ•°ç»„ï¼Œç”¨äºéš”ç¦»å¿…éœ€çš„ä¸¤ä¸ªä½ï¼ˆå—ï¼‰ï¼Œå¹¶è½¬æ¢ä¸ºæ‰€è°“çš„å—ï¼ˆæ•°ç»„ä¸­çš„ç´¢å¼•ï¼ŒåŒ…è£…16ä¸ªå—ï¼‰å’Œå—ï¼ˆå—ä¸­çš„ä½ä½ç½®ï¼‰ã€‚ </p><br><div class="spoiler">  <b class="spoiler_title">ç‰©ç†å†…å­˜ä½å›¾</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESERVED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UNUSABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEAD: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0xDEAD</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysMemoryInfo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> total: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, used: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, reserved: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunks: [<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PhysMemoryInfo { <span class="hljs-comment"><span class="hljs-comment">// returns (chunk, page) pub fn find_free(&amp;self) -&gt; (usize, usize) { for chunk in 0..64 { for page in 0.. 16 { if ((self.chunks[chunk] &gt;&gt; page * 2) &amp; 3) ^ 3 == 3 { return (chunk, page) } else {} } } (DEAD, 0) } // marks page to given flag and returns its address pub fn mark(&amp;mut self, chunk: usize, block: usize, flag: usize) -&gt; usize { self.chunks[chunk] = self.chunks[chunk] ^ (3 &lt;&lt; (block * 2)); let mask = (0xFFFFFFFC ^ flag).rotate_left(block as u32 * 2); self.chunks[chunk] = self.chunks[chunk] &amp; (mask as u32); if flag == USED { self.used += 1; } else if flag == UNUSABLE || flag == RESERVED { self.reserved += 1; } else { if self.used &gt; 0 { self.used -= 1; } } (chunk * 16 + block) &lt;&lt; 22 } pub fn mark_by_addr(&amp;mut self, addr: usize, flag: usize) { let block_num = addr &gt;&gt; 22; let chunk: usize = (block_num / 16) as usize; let block: usize = block_num - chunk * 16; self.mark(chunk, block, flag); } pub fn count_total(&amp; mut self) { let mut count: usize = 0; for i in 0..64 { let mut chunk = self.chunks[i]; for _j in 0..16 { if chunk &amp; 0b11 != 0b11 { count += 1; } chunk = chunk &gt;&gt; 2; } } self.total = count; } pub fn get_total(&amp;self) -&gt; usize { self.total } pub fn get_used(&amp;self) -&gt; usize { self.used } pub fn get_reserved(&amp;self) -&gt; usize { self.reserved } pub fn get_free(&amp;self) -&gt; usize { self.total - self.used - self.reserved } }</span></span></code> </pre> </div></div><br><p> ç°åœ¨æˆ‘ä»¬å¼€å§‹åˆ†æåœ°å›¾çš„ä¸€ä¸ªå…ƒç´ ã€‚ å¦‚æœåœ°å›¾å…ƒç´ æè¿°çš„å†…å­˜åŒºåŸŸå°‘äºä¸€é¡µçš„4 MBæˆ–ç­‰äº4 MBï¼Œåˆ™æˆ‘ä»¬å°†è¯¥é¡µé¢æ ‡è®°ä¸ºæ•´ä½“ã€‚ å¦‚æœæ›´å¤šï¼Œè¯·åˆ†æˆ4 MBï¼Œå¹¶é€šè¿‡é€’å½’åˆ†åˆ«æ ‡è®°æ¯ä¸ªéƒ¨åˆ†ã€‚ åœ¨ä½å›¾åˆå§‹åŒ–é˜¶æ®µï¼Œæˆ‘ä»¬è®¤ä¸ºå†…å­˜çš„æ‰€æœ‰éƒ¨åˆ†éƒ½æ— æ³•è®¿é—®ï¼Œå› æ­¤å½“å¡ç”¨å®Œæ—¶ï¼Œä¾‹å¦‚128 MBï¼Œå…¶ä½™éƒ¨åˆ†è¢«æ ‡è®°ä¸ºä¸å¯è®¿é—®ã€‚ </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> RAM_INFO: Mutex&lt;PhysMemoryInfo&gt; = Mutex::new(PhysMemoryInfo { total: <span class="hljs-number"><span class="hljs-number">0</span></span>, used: <span class="hljs-number"><span class="hljs-number">0</span></span>, reserved: <span class="hljs-number"><span class="hljs-number">0</span></span>, chunks: [<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>] }); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flag: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if len &lt;= 4MiB then mark whole page with flag if len &lt;= 4 * 1024 * 1024 { RAM_INFO.lock().mark_by_addr(addr, flag); } else { let pages: usize = len &gt;&gt; 22; for map_page in 0..(pages - 1) { map(addr + map_page &lt;&lt; 22, 4 * 1024 * 1024, flag); } map(addr + (pages &lt;&lt; 22), len - (pages &lt;&lt; 22), flag); } }</span></span></code> </pre> <br><h1 id="kucha-i-upravlenie-ey"> å †å’Œç®¡ç†å¥¹ </h1><br><p> ç›®å‰ï¼Œè™šæ‹Ÿå†…å­˜ç®¡ç†ä»…é™äºå †ç®¡ç†ï¼Œå› ä¸ºå†…æ ¸å¯¹æ­¤ä¸€æ— æ‰€çŸ¥ã€‚ å½“ç„¶ï¼Œå°†æ¥æœ‰å¿…è¦ç®¡ç†æ‰€æœ‰å†…å­˜ï¼Œå¹¶ä¸”å°†é‡å†™æ­¤å°å‹ç®¡ç†å™¨ã€‚ ä½†æ˜¯ï¼Œç›®å‰ï¼Œæˆ‘æ‰€éœ€è¦çš„åªæ˜¯é™æ€å†…å­˜ï¼ˆå…¶ä¸­åŒ…å«å¯æ‰§è¡Œä»£ç å’Œå †æ ˆï¼‰ä»¥åŠåŠ¨æ€å †å†…å­˜ï¼Œæˆ‘å°†åœ¨å…¶ä¸­åˆ†é…ç”¨äºå¤šçº¿ç¨‹çš„ç»“æ„ã€‚ æˆ‘ä»¬åœ¨å¼•å¯¼é˜¶æ®µåˆ†é…é™æ€å†…å­˜ï¼ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼Œç”±äºå†…æ ¸é€‚åˆå†…å­˜ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½åˆ†é…4 MBçš„å†…å­˜ï¼‰ï¼Œå¹¶ä¸”é€šå¸¸æ¥è¯´ç°åœ¨æ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚ å¦å¤–ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘æ²¡æœ‰DMAè®¾å¤‡ï¼Œå› æ­¤ä¸€åˆ‡éƒ½éå¸¸ç®€å•ï¼Œä½†æ˜¯å¯ä»¥ç†è§£ã€‚ </p><br><p> æˆ‘ä¸ºå †æä¾›äº†512 MBçš„æœ€é«˜å†…æ ¸å†…å­˜ç©ºé—´ï¼ˆ0xE0000000ï¼‰ï¼Œæˆ‘å°†å †ä½¿ç”¨æƒ…å†µæ˜ å°„ï¼ˆ0xDFC00000ï¼‰é™ä½äº†4 MBã€‚ æˆ‘ä½¿ç”¨ä½å›¾æ¥æè¿°çŠ¶æ€ï¼Œå°±åƒç‰©ç†å†…å­˜ä¸€æ ·ï¼Œä½†æ˜¯å…¶ä¸­åªæœ‰2ä¸ªçŠ¶æ€-å¿™/é—²ã€‚ å†…å­˜å—çš„å¤§å°ä¸º64å­—èŠ‚-å¯¹äºu32ï¼Œu8è¿™æ ·çš„å°å˜é‡æ¥è¯´ï¼Œè¿™æ˜¯å¾ˆå¤šçš„ï¼Œä½†æ˜¯ï¼Œå¯¹äºå­˜å‚¨æ•°æ®ç»“æ„è€Œè¨€ï¼Œå®ƒæ˜¯æœ€ä½³çš„ã€‚ å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¸å¤ªå¯èƒ½éœ€è¦åœ¨å †ä¸Šå­˜å‚¨å•ä¸ªå˜é‡ï¼Œå› ä¸ºå®ƒçš„ä¸»è¦ç›®çš„æ˜¯å­˜å‚¨ç”¨äºå¤šä»»åŠ¡å¤„ç†çš„ä¸Šä¸‹æ–‡ç»“æ„ã€‚ </p><br><p>  64å­—èŠ‚çš„å—è¢«åˆ†ç»„ä¸ºæè¿°æ•´ä¸ª4 MBé¡µé¢çŠ¶æ€çš„ç»“æ„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å°‘é‡å’Œå¤§é‡çš„å†…å­˜åˆ†é…ç»™å¤šä¸ªé¡µé¢ã€‚ æˆ‘ä½¿ç”¨ä»¥ä¸‹æœ¯è¯­ï¼šå—-64å­—èŠ‚ï¼ŒåŒ…-2 KBï¼ˆä¸€ä¸ªu32-64å­—èŠ‚*æ¯ä¸ªåŒ…32ä½ï¼‰ï¼Œé¡µé¢-4 MBã€‚ </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(packed)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapPageInfo</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], }</span></span></code> </pre> <br><p> ä»åˆ†é…å™¨è¯·æ±‚å†…å­˜æ—¶ï¼Œæˆ‘ä¼šæ ¹æ®ç²’åº¦è€ƒè™‘ä¸‰ç§æƒ…å†µï¼š </p><br><ul><li> åˆ†é…å™¨å‘å‡ºçš„å†…å­˜è¯·æ±‚å°‘äº2 KBã€‚ æ‚¨éœ€è¦æ‰¾åˆ°ä¸€ä¸ªåŒ…ï¼Œè¯¥åŒ…ä¸­çš„åŒ…å°†æ˜¯å…è´¹çš„[å¤§å°/ 64ï¼Œä»»ä½•éé›¶ä½™æ•°åŠ ä¸€ä¸ª]å—ï¼Œå°†è¿™äº›å—æ ‡è®°ä¸ºå¿™ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå—çš„åœ°å€ã€‚ </li><li> åˆ†é…å™¨å‘å‡ºçš„å†…å­˜å°äº4 MBä½†å¤§äº2 KBçš„è¯·æ±‚ã€‚ æ‚¨éœ€è¦æ‰¾åˆ°ä¸€ä¸ªé¡µé¢ï¼Œè¯¥é¡µé¢å…·æœ‰å…è´¹çš„[å¤§å°/ 2048ï¼Œä»»ä½•éé›¶ä½™æ•°è¿ç»­å¢åŠ ä¸€ä¸ª]åŒ…ã€‚ å°†[size / 2048]æ•°æ®åŒ…æ ‡è®°ä¸ºå¿™ï¼›å¦‚æœæœ‰å‰©ä½™ï¼Œåˆ™å°†æœ€åä¸€ä¸ªæ•°æ®åŒ…ä¸­çš„[å‰©ä½™]å—æ ‡è®°ä¸ºå¿™ã€‚ </li><li> åˆ†é…å™¨è¦æ±‚å†…å­˜å¤§äº4 MBã€‚ è¿ç»­æŸ¥æ‰¾[size / 4 Miï¼Œä»»ä½•éé›¶ä½™é¢åŠ ä¸€ä¸ª]é¡µé¢ï¼Œå¦‚æœæœ‰ä½™é¢ï¼Œåˆ™å°†[size / 4 Mi]é¡µé¢æ ‡è®°ä¸ºå¿™-å°†[balance]æ‰“åŒ…æ ‡è®°ä¸ºå¿™ã€‚ åœ¨æœ€åä¸€ä¸ªåŒ…ä¸­ï¼Œå°†å…¶ä½™å—æ ‡è®°ä¸ºå¿™ã€‚ </li></ul><br><p> å¯¹ç©ºé—²åŒºåŸŸçš„æœç´¢è¿˜å–å†³äºç²’åº¦-é€‰æ‹©ä¸€ä¸ªç”¨äºè¿­ä»£æˆ–ä½æ©ç çš„æ•°ç»„ã€‚ æ¯å½“æ‚¨å‡ºå›½æ—¶ï¼Œéƒ½ä¼šå‘ç”ŸOOMã€‚ é‡Šæ”¾æ—¶ï¼Œä½¿ç”¨ç±»ä¼¼çš„ç®—æ³•ï¼Œä»…ç”¨äºæ ‡è®°å·²é‡Šæ”¾ã€‚ é‡Šæ”¾çš„å†…å­˜ä¸ä¼šé‡ç½®ã€‚ æ•´ä¸ªä»£ç å¾ˆå¤§ï¼Œæˆ‘æŠŠå®ƒæ”¾åœ¨ç ´åè€…çš„ä¸‹é¢ã€‚ </p><br><div class="spoiler">  <b class="spoiler_title">è™šæ‹Ÿå†…å­˜ä½å›¾</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//512 MiB should be enough for kernel heap. If not - ooops... pub const KHEAP_START: usize = 0xE0000000; //I will keep 1MiB info about my heap in separate 4MiB page before heap at this point pub const KHEAP_INFO_ADDR: usize = 0xDFC00000; pub const KHEAP_CHUNK_SIZE: usize = 64; pub fn init() { KHEAP_INFO.lock().init(); } #[repr(packed)] #[derive(Copy, Clone)] struct HeapPageInfo { //every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } impl HeapPageInfo { pub fn init(&amp;mut self) { for i in 0..2048 { self._4mb_by_64b[i] = 0; } } pub fn mark_chunks_used(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] | mask; } pub fn mark_chunks_free(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] ^ mask; } pub fn empty(&amp;self) -&gt; bool { for i in 0..2048 { if self._4mb_by_64b[i] != 0 { return false } } true } } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], } impl HeapInfo { pub fn init(&amp;mut self) { for i in 0..128 { self._512mb_by_4mb[i].init(); } } // returns page number pub fn find_free_pages_of_size(&amp;self, n: usize) -&gt; usize { if n &gt;= 128 { 0xFFFFFFFF } else { let mut start_page: usize = 0xFFFFFFFF; let mut current_page: usize = 0xFFFFFFFF; for page in 0..128 { if self._512mb_by_4mb[page].empty() { if current_page - start_page == n { return start_page } if start_page == 0xFFFFFFFF { start_page = page; } current_page = page; } else { start_page = 0xFFFFFFFF; current_page = 0xFFFFFFFF; } } 0xFFFFFFFF } } // returns (page number, 32pack number) pub fn find_free_packs_of_size(&amp;self, n: usize) -&gt; (usize, usize) { if n &lt; 2048 { for page in 0..128 { let mut start_pack: usize = 0xFFFFFFFF; let mut current_pack: usize = 0xFFFFFFFF; for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; if _32pack_info == 0 { if current_pack - start_pack == n { return (page, start_pack) } if start_pack == 0xFFFFFFFF { start_pack = _32pack; } current_pack = _32pack; } else { start_pack = 0xFFFFFFFF; current_pack = 0xFFFFFFFF; } } } (0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF) } } // returns (page number, 32pack number, chunk number) pub fn find_free_chunks_of_size(&amp;self, n: usize) -&gt; (usize, usize, usize) { if n &lt; 32 { for page in 0..128 { for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n); for chunk in 0..(32-n) { if ((_32pack_info &gt;&gt; chunk) &amp; mask) ^ mask == mask { return (page, _32pack, chunk) } } } } (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } } fn mark_chunks_used(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_used(_32pack, chunk, n); } fn mark_chunks_free(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_free(_32pack, chunk, n); } fn mark_packs_used(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0xFFFFFFFF; } } fn mark_packs_free(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0; } } } use lazy_static::lazy_static; use spin::Mutex; lazy_static! { static ref KHEAP_INFO: Mutex&lt;&amp;'static mut HeapInfo&gt; = Mutex::new(unsafe { &amp;mut *(KHEAP_INFO_ADDR as *mut HeapInfo) }); } fn allocate_n_chunks_less_than_pack(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let (page, _32pack, chunk) = heap_info.find_free_chunks_of_size(n); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + _32pack * 32 * 64 + chunk * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_chunks_used(page, _32pack, chunk, n); uptr as *mut u8 } else { core::ptr::null_mut() } } } fn allocate_n_chunks_less_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let (page, pack) = heap_info.find_free_packs_of_size(packs_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + pack * 32 * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_packs_used(page, pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_used(page, pack + packs_to_alloc, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } //unsupported yet fn allocate_n_chunks_more_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let pages_n: usize = packs_to_alloc / 2048; let mut lost_packs = packs_to_alloc - pages_n * 2048; let mut pages_to_alloc = pages_n; if lost_packs != 0 { pages_to_alloc += 1; } if lost_chunks != 0 { lost_packs -= 1; } let page = heap_info.find_free_pages_of_size(pages_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B * n //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { for i in page..(page + pages_n) { heap_info.mark_packs_used(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_used(page + pages_to_alloc, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_used(page + pages_to_alloc, lost_packs, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } // returns pointer pub fn allocate_n_chunks(n: usize, align: usize) -&gt; *mut u8 { if n &lt; 32 { allocate_n_chunks_less_than_pack(n, align) } else if n &lt; 32 * 2048 { allocate_n_chunks_less_than_page(n, align) } else { allocate_n_chunks_more_than_page(n, align) } } pub fn free_chunks(ptr: usize, n: usize) { let page: usize = (ptr - KHEAP_START) / 0x400000; let _32pack: usize = ((ptr - KHEAP_START) - (page * 0x400000)) / (32 * 64); let chunk: usize = ((ptr - KHEAP_START) - (page * 0x400000) - (_32pack * (32 * 64))) / 64; let mut heap_info = KHEAP_INFO.lock(); if n &lt; 32 { heap_info.mark_chunks_free(page, _32pack, chunk, n); } else if n &lt; 32 * 2048 { let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; heap_info.mark_packs_free(page, _32pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_free(page, _32pack + packs_n, 0, lost_chunks); } } else { let packs_n: usize = n / 32; let pages_n: usize = packs_n / 2048; let lost_packs: usize = packs_n - pages_n * 2048; let lost_chunks = n - packs_n * 32; for i in page..(page + pages_n) { heap_info.mark_packs_free(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_free(page + pages_n, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_free(page + pages_n, packs_n, 0, lost_chunks); } } }</span></span></code> </pre> </div></div><br><h1 id="allokaciya-i-page-fault"> åˆ†é…å’Œé¡µé¢é”™è¯¯ </h1><br><p> ä¸ºäº†ä½¿ç”¨å †ï¼Œæ‚¨éœ€è¦ä¸€ä¸ªåˆ†é…å™¨ã€‚ æ·»åŠ å®ƒä¼šä¸ºæˆ‘ä»¬æ‰“å¼€ä¸€ä¸ªå‘é‡ï¼Œæ ‘æœ¨ï¼Œå“ˆå¸Œè¡¨ï¼Œç›’å­ç­‰ç­‰ï¼Œæ²¡æœ‰å®ƒä»¬ï¼Œå®ƒå‡ ä¹æ˜¯ä¸å¯èƒ½ç”Ÿå­˜çš„ã€‚ ä¸€æ—¦æˆ‘ä»¬æ’å…¥allocæ¨¡å—å¹¶å£°æ˜ä¸€ä¸ªå…¨å±€åˆ†é…å™¨ï¼Œç”Ÿæ´»å°±ä¼šç«‹å³å˜å¾—æ›´åŠ è½»æ¾ã€‚ </p><br><p> åˆ†é…å™¨çš„å®ç°éå¸¸ç®€å•-å®ƒåªæ˜¯å¼•ç”¨ä¸Šè¿°æœºåˆ¶ã€‚ </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::alloc::{GlobalAlloc, Layout}; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Os1Allocator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator {} <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GlobalAlloc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, layout: Layout) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, allocate_n_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } allocate_n_chunks(chunk_count, layout.align()) } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dealloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, layout: Layout) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, free_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } free_chunks(ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunk_count); } }</code> </pre> <br><p>  lib.rsä¸­çš„åˆ†é…å™¨æŒ‰ä»¥ä¸‹æ–¹å¼æ‰“å¼€ï¼š </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(alloc, alloc_error_handler)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> alloc; <span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOCATOR: memory::allocate::Os1Allocator = memory::allocate::Os1Allocator;</code> </pre> <br><p> å½“æˆ‘ä»¬å°è¯•ä»¥è¿™ç§æ–¹å¼åˆ†é…è‡ªå·±æ—¶ï¼Œä¼šå‡ºç°Page Faultå¼‚å¸¸ï¼Œå› ä¸ºæˆ‘ä»¬å°šæœªè®¡ç®—å‡ºè™šæ‹Ÿå†…å­˜çš„åˆ†é…ã€‚ å¥½å§ï¼Œæ€ä¹ˆè¿™æ ·ï¼ å¥½äº†ï¼Œæ‚¨å¿…é¡»è¿”å›ä¸Šä¸€ç¯‡æ–‡ç« çš„å†…å®¹å¹¶æ·»åŠ ä¾‹å¤–ã€‚ æˆ‘å†³å®šå®ç°è™šæ‹Ÿå†…å­˜çš„æƒ°æ€§åˆ†é…ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé¡µé¢åˆ†é…ä¸æ˜¯åœ¨å†…å­˜è¯·æ±‚æ—¶åˆ†é…çš„ï¼Œè€Œæ˜¯åœ¨å°è¯•è®¿é—®å®ƒæ—¶åˆ†é…çš„ã€‚ å¹¸è¿çš„æ˜¯ï¼Œx86å¤„ç†å™¨å…è®¸ç”šè‡³é¼“åŠ±è¿™æ ·åšã€‚   Page fault     ,   ,    ,          â€”      ,     ,    CR2 â€”  ,    . </p><br><p>    ,      .        32 (     ,     ,     32 ),    .           Rust.           ,        .  ,   ,   iret    ,    ,     Page fault   Protection fault.        Protection fault â€” ,        . </p><br><pre> <code class="plaintext hljs">eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret</code> </pre> <br><p>  Rust         ,    .     ,     .            .            . </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">bitflags!</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PFErrorCode</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PROTECTION = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 - protection caused, 0 - not present page caused const WRITE = 1 &lt;&lt; 1; //1 - write caused, 0 - read caused const USER_MODE = 1 &lt;&lt; 2; //1 - from user mode, 0 - from kernel const RESERVED = 1 &lt;&lt; 3; //1 - reserved page (PAE/PSE), 0 - not const INSTRUCTION = 1 &lt;&lt; 4; //1 - instruction fetch caused, 0 - not } } impl PFErrorCode { pub fn to_pd_flags(&amp;self) -&gt; super::super::paging::PDEntryFlags { use super::super::paging; let mut flags = paging::PDEntryFlags::empty(); if self.contains(PFErrorCode::WRITE) { flags.set(paging::PDEntryFlags::WRITABLE, true); } if self.contains(PFErrorCode::USER_MODE) { flags.set(paging::PDEntryFlags::USER_ACCESSIBLE, true); } flags } } #[no_mangle] pub unsafe extern fn kE_page_fault(ptr: usize, code: usize) { use super::super::paging; println!("Page fault occured at addr 0x{:X}, code {:X}", ptr, code); let phys_address = crate::memory::physical::alloc_page(); let code_flags: PFErrorCode = PFErrorCode::from_bits(code).unwrap(); if !code_flags.contains(PFErrorCode::PROTECTION) { //page not presented, we need to allocate the new one let mut flags: paging::PDEntryFlags = code_flags.to_pd_flags(); flags.set(paging::PDEntryFlags::HUGE_PAGE, true); paging::allocate_page(phys_address, ptr, flags); println!("Page frame allocated at Paddr {:#X} Laddr {:#X}", phys_address, ptr); } else { panic!("Protection error occured, cannot handle yet"); } }</span></span></code> </pre> <br><p>        ,   .  ,       .           .          ,      .    ,      ,        : </p><br><pre> <code class="rust hljs"> <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free()); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::vec::<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000</span></span> { vec.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec len {}, ptr is {:?}"</span></span>, vec.len(), vec.as_ptr()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works, check reusage!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec2: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { vec2.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec2 len {}, ptr is {:?}, vec is still here? {}"</span></span>, vec2.len(), vec2.as_ptr(), vec.get(<span class="hljs-number"><span class="hljs-number">1000</span></span>).unwrap()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free());</code> </pre> <br><p>     : <br><img src="https://habrastorage.org/webt/7x/y3/bs/7xy3bs8m91uxbmexphxpelzc2cs.jpeg" alt="OS1 heap"></p><br><p>  ,   ,           .          3,5  + 3 ,   .          3,5     . </p><br><p> IRQ 1    â€”        Alt + PrntScrn :) </p><br><p> ,    ,      Rust â€”       ,   â€”    ,    ! </p><br><p>       ,                . </p><br><p> æ„Ÿè°¢æ‚¨çš„å…³æ³¨ï¼ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446214/">https://habr.com/ru/post/zh-CN446214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446204/index.html">é¢„æµ‹å¦‚ä½•å…‹æœäº’è”ç½‘é™åˆ¶</a></li>
<li><a href="../zh-CN446206/index.html">Reactæ•™ç¨‹ç¬¬26éƒ¨åˆ†ï¼šåº”ç”¨ç¨‹åºä½“ç³»ç»“æ„ï¼Œå®¹å™¨/ç»„ä»¶æ¨¡å¼</a></li>
<li><a href="../zh-CN446208/index.html">Reactæ•™ç¨‹ç¬¬25éƒ¨åˆ†ï¼šè¡¨å•ç ”è®¨ä¼š</a></li>
<li><a href="../zh-CN446210/index.html">ADAM-3600-å¤šåŠŸèƒ½å·¥ä¸šæ§åˆ¶å™¨</a></li>
<li><a href="../zh-CN446212/index.html">SIEMæ·±åº¦ï¼šç°æˆçš„ç›¸å…³æ€§ã€‚ ç¬¬5éƒ¨åˆ†ã€‚å¼€å‘ç›¸å…³è§„åˆ™çš„æ–¹æ³•</a></li>
<li><a href="../zh-CN446218/index.html">æ¸¸æˆè®¾è®¡å¸ˆä¸å¿ƒç†è®¾è®¡å¸ˆå¹¶æ²¡æœ‰å¤ªå¤§åŒºåˆ«ã€‚ æˆ‘ä»¬å¦‚ä½•åˆ¶ä½œCMANæ¸¸æˆ</a></li>
<li><a href="../zh-CN446222/index.html">åˆ©ç”¨çƒ­åŠ¿è¿›è¡ŒåŒºåŸŸåˆ†æ</a></li>
<li><a href="../zh-CN446228/index.html">é€šè¿‡è¿æ¥Wikipediaæé«˜æ–‡æœ¬åˆ†ç±»çš„è´¨é‡</a></li>
<li><a href="../zh-CN446230/index.html">é€šè¿‡ç«¯å£80è¿œç¨‹ç›‘è§†å’Œç®¡ç†åŸºäºLinux / OpenWrt / Ledeçš„è®¾å¤‡</a></li>
<li><a href="../zh-CN446234/index.html">æ¥è‡ªä¸–ç•Œå„åœ°çš„å¿—æ„¿è€…å¦‚ä½•åˆ¶ä½œICPC-2019çš„ç°åœºç›´æ’­</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>