<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèº ü•ú üë©üèª‚Äçü§ù‚Äçüë®üèº Contenedores para adultos (Parte 01): una gu√≠a pr√°ctica de terminolog√≠a üßô üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Puede preguntar, ¬øpor qu√© lidiar con la terminolog√≠a si el concepto de contenedores parece bastante simple y directo? Sin embargo, con frecuencia el u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contenedores para adultos (Parte 01): una gu√≠a pr√°ctica de terminolog√≠a</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  Puede preguntar, ¬øpor qu√© lidiar con la terminolog√≠a si el concepto de contenedores parece bastante simple y directo?  Sin embargo, con frecuencia el uso incorrecto de los t√©rminos crea obst√°culos para el desarrollo de contenedores.  Por ejemplo, las personas a menudo piensan que los t√©rminos "contenedores" e "im√°genes" se usan indistintamente, aunque en realidad existen importantes diferencias conceptuales entre ellos.  Otro ejemplo: en el mundo de los contenedores, un "repositorio" no significa lo que piensas.  Adem√°s, la tecnolog√≠a de contenedores es mucho m√°s que solo docker. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Entonces, sin conocer la terminolog√≠a, ser√° dif√≠cil entender c√≥mo Docker difiere de CRI-O, rkt o lxc / lxd;  o evaluar el papel de Open Container Initiative en la estandarizaci√≥n de tecnolog√≠as de contenedores. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Comenzar con los contenedores de Linux es muy simple, pero pronto resulta que esta simplicidad es enga√±osa.  Esto suele suceder as√≠: despu√©s de pasar solo un par de minutos instalando un acoplador u otro motor de contenedor, ya ingresas tus primeros comandos.  Solo un par de minutos, y ya cre√≥ su primera imagen del contenedor y la puso en el dominio p√∫blico.  Luego, habitualmente, se pasa a la arquitectura del entorno de producci√≥n y, de repente, se da cuenta de que para esto primero necesita lidiar con la gran cantidad de t√©rminos y tecnolog√≠as que est√°n detr√°s de todo esto.  Peor a√∫n, muchos de los t√©rminos enumerados a continuaci√≥n se usan indistintamente, lo que crea mucha confusi√≥n para los principiantes. <br><br><ul><li>  Contenedor </li><li>  Imagen </li><li>  Imagen de contenedor </li><li>  Capa de imagen </li><li>  Registro </li><li>  Repositorio </li><li>  Etiqueta </li><li>  Imagen base </li><li>  Imagen de plataforma </li><li>  Capa </li></ul><br>  Una vez que domine la terminolog√≠a establecida en este documento, comprender√° mejor la base tecnol√≥gica de los contenedores.  Adem√°s, lo ayudar√° a usted y a sus colegas a hablar el mismo idioma, as√≠ como a dise√±ar consciente y resueltamente la arquitectura de los entornos de contenedores de acuerdo con los detalles de las tareas que se resuelven.  A su vez, desde el punto de vista de la comunidad de TI y la industria en general, un aumento general en la comprensi√≥n de las tecnolog√≠as de contenedores contribuye a la aparici√≥n de nuevas arquitecturas y soluciones.  Tenga en cuenta que este art√≠culo est√° destinado a un lector que ya tiene una idea de c√≥mo ejecutar contenedores. <br><br><h3>  Contenedores: b√°sicos </h3><br>  Antes de continuar con la terminolog√≠a de los contenedores, determinaremos qu√© es, de hecho, el contenedor en s√≠.  El t√©rmino "contenedor" significa dos cosas a la vez.  Al igual que un programa Linux normal, un contenedor puede estar en uno de dos estados: en funcionamiento y no en funcionamiento.  En el estado inactivo, el contenedor es un archivo o un conjunto de archivos almacenados en el disco.  A este estado se refieren los t√©rminos Imagen de contenedor y Repositorio de contenedor.  Cuando ingresa el comando de inicio del contenedor, el motor del contenedor desempaqueta los archivos y metadatos necesarios y los transfiere al kernel de Linux.  Iniciar un contenedor es muy similar a iniciar un proceso normal de Linux y requiere una llamada API al kernel de Linux.  Esta llamada a la API generalmente inicia un aislamiento adicional y monta una copia de los archivos que est√°n en la imagen del contenedor.  Una vez que se inicia el contenedor, es solo un proceso de Linux.  El procedimiento para lanzar contenedores, as√≠ como el formato de las im√°genes de los contenedores almacenados en el disco, est√°n definidos y regulados por est√°ndares. <br><br>  Existen varios formatos para im√°genes de contenedor ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LXD</a> ), pero la industria se est√° moviendo gradualmente hacia un √∫nico est√°ndar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Open Container Initiative</a> , a veces llamado Open Containers o simplemente OCI.  Este est√°ndar define la <a href="">especificaci√≥n del formato de la imagen del contenedor</a> , que define el formato de disco para almacenar im√°genes del contenedor, as√≠ como los metadatos, que, a su vez, define elementos tales como la arquitectura del hardware y el sistema operativo (Linux, Windows, etc.).  Un √∫nico formato de imagen para toda la industria es la clave para crear un ecosistema de software que permita a los desarrolladores, proyectos de c√≥digo abierto y proveedores de software crear im√°genes compatibles y diversas herramientas, como firma electr√≥nica, escaneo, ensamblaje, lanzamiento, movimiento y administraci√≥n de im√°genes de contenedores. <br><br>  Adem√°s, hay varios motores de contenedores, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LXC</a> .  El motor del contenedor toma una imagen del contenedor y lo convierte en un contenedor (es decir, un proceso en ejecuci√≥n).  El proceso de conversi√≥n tambi√©n est√° definido por el est√°ndar OCI, que incluye una especificaci√≥n de tiempo de ejecuci√≥n de contenedor y una implementaci√≥n de referencia de tiempo de ejecuci√≥n llamada RunC, que es un modelo de c√≥digo abierto que est√° regulado por la comunidad de desarrollo apropiada.  Muchos motores de contenedores utilizan este modelo para interactuar con el n√∫cleo del host al crear contenedores. <br><br>  Las herramientas que admiten las especificaciones del <a href="">formato de imagen del contenedor</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el entorno de ejecuci√≥n del contenedor del</a> est√°ndar OCI proporcionan portabilidad dentro del ecosistema de varias plataformas de contenedores, motores de contenedores y herramientas de soporte en varias plataformas de nube y arquitecturas locales.  Comprender la terminolog√≠a, los est√°ndares y la arquitectura de los sistemas de contenedores le permitir√° comunicarse fruct√≠feramente con otros especialistas y dise√±ar aplicaciones y entornos en contenedores escalables y compatibles que garanticen el uso eficiente de contenedores en los a√±os venideros. <br><br><h3>  Vocabulario b√°sico </h3><br><h4>  Imagen del contenedor </h4><br>  En su definici√≥n m√°s simple, una imagen de contenedor es un archivo que se descarga del servidor de registro y se usa localmente como punto de montaje cuando se inicia el contenedor.  A pesar de que el t√©rmino "imagen contenedor" se usa con bastante frecuencia, puede significar cosas diferentes.  El hecho es que, aunque Docker, RKT e incluso LXD funcionan de acuerdo con el principio que se acaba de describir, es decir, descargan archivos eliminados y los ejecutan como contenedores, cada una de estas tecnolog√≠as interpreta la imagen del contenedor a su manera.  LXD funciona con im√°genes monol√≠ticas (una capa), mientras que Docker y RKT usan im√°genes OCI, que pueden contener varias capas. <br><br>  Estrictamente hablando, una imagen de contenedor en un servidor de registro est√° lejos de ser un solo archivo.  Cuando las personas usan el t√©rmino "imagen del contenedor", a menudo se refieren al repositorio y a un conjunto de varias capas de la imagen del contenedor, as√≠ como a los metadatos que contienen informaci√≥n adicional sobre estas capas. <br><br>  Adem√°s, el concepto de una imagen contenedor implica impl√≠citamente la existencia de un formato para dicha imagen. <br><br><h4>  Formato de imagen de contenedor </h4><br>  Inicialmente, cada motor de contenedor, incluidos LXD, RKT y Docker, ten√≠a su propio formato de imagen.  Algunos de estos formatos permiten solo una capa, mientras que otros admiten una estructura de √°rbol de varias capas.  Hoy, casi todas las herramientas y motores principales del contenedor han cambiado al formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OCI</a> , que determina c√≥mo deben organizarse las capas y los metadatos en la imagen del contenedor.  En esencia, el formato OCI define una imagen de contenedor que consta de archivos tar separados para cada capa y un archivo manifest.json com√∫n que contiene metadatos. <br><br>  El est√°ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Open Container Initiative (OCI)</a> , que se bas√≥ originalmente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el formato de imagen Docker V2</a> , ha combinado con √©xito un gran ecosistema de motores de contenedores, plataformas y herramientas en la nube (esc√°neres de seguridad, herramientas de firma, creaci√≥n y movimiento de contenedores) y le permite proteger su inversi√≥n en conocimiento y herramientas <br><br><h4>  Motor de contenedores </h4><br>  El motor de contenedor es esa parte del software que acepta las solicitudes de los usuarios, incluidos los par√°metros de la l√≠nea de comandos, descarga im√°genes y, desde la perspectiva del usuario final, lanza contenedores.  Hay muchos motores de contenedores, incluidos docker, RKT, CRI-O y LXD.  Adem√°s, muchas plataformas en la nube, servicios de PaaS y plataformas de contenedores tienen sus propios motores que entienden las im√°genes en formato Docker u OCI.  Tener un est√°ndar de la industria para el formato de imagen garantiza la interoperabilidad de todas estas plataformas. <br><br>  Al bajar un nivel, podemos decir que la mayor√≠a de los motores de contenedores no inician los contenedores en s√≠, sino a trav√©s de un tiempo de ejecuci√≥n compatible con OCI, como runc.  Normalmente, un tiempo de ejecuci√≥n de contenedor hace lo siguiente: <br><br><ul><li>  Maneja par√°metros, entrada del usuario </li><li>  Maneja los par√°metros pasados ‚Äã‚Äãa trav√©s de la API (m√°s a menudo el sistema de orquestaci√≥n de contenedores) </li><li>  Descargar im√°genes del contenedor desde el servidor de registro </li><li>  Desempaqueta y guarda la imagen del contenedor en el disco usando Graph Driver (bloque o archivo, dependiendo del controlador) </li><li>  Prepara un punto de montaje para el contenedor, generalmente en almacenamiento de copia en escritura (nuevamente, bloque o archivo, dependiendo del controlador) </li><li>  Prepara metadatos que se pasar√°n al tiempo de ejecuci√≥n para ejecutar el contenedor correctamente usando: <br><ul><li>  Configuraciones predeterminadas espec√≠ficas que est√°n impl√≠citas para la imagen del contenedor (por ejemplo, <a href="">ArchX86</a> ) </li><li>  Entrada del usuario para anular los valores predeterminados contenidos en la imagen del contenedor (por ejemplo, CMD, ENTRYPOINT) </li><li>  Par√°metros predeterminados especificados por la imagen del contenedor (por ejemplo, reglas <a href="">SECCOM</a> ) </li></ul></li><li>  Invoca el tiempo de ejecuci√≥n del contenedor </li></ul><br><h4>  Contenedor </h4><br>  Los contenedores han existido en los sistemas operativos durante bastante tiempo, porque de hecho esto es solo una instancia en ejecuci√≥n de una imagen de contenedor.  Un contenedor es un proceso est√°ndar de Linux que generalmente se crea usando la llamada al sistema clone () en lugar de fork () o exec ().  Adem√°s, a menudo se aplican medidas de aislamiento adicionales a los contenedores que usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SELinux</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppArmor</a> . <br><br><h4>  Host de contenedores </h4><br>  Un host de contenedor es un sistema en el que se ejecutan procesos en contenedor, que a menudo se denominan contenedores por simplicidad.  Esto puede ser, por ejemplo, una m√°quina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RHEL Atomic Host</a> ubicada en una nube p√∫blica o que se ejecuta en el metal desnudo en un centro de datos corporativo.  Cuando la imagen del contenedor (en otras palabras, el repositorio) del servidor de registro se descarga al host del contenedor local, dicen que cae en el cach√© local. <br><br>  Puede determinar qu√© repositorios se sincronizan con la memoria cach√© local utilizando el siguiente comando: <br><br><pre>  [root @ rhel7 ~] # im√°genes acoplables -a<font></font>
<font></font>
 ID DE IMAGEN DE ETIQUETA DE REPOSITORIO TAMA√ëO VIRTUAL CREADO
 Registry.access.redhat.com/rhel7 √∫ltima 6883d5422f4e Hace 3 semanas 201.7 MB </pre><br><h4>  Servidor de registro </h4><br>  Un servidor de registro es esencialmente un servidor de archivos que se utiliza para almacenar repositorios de acopladores.  Como regla general, el servidor de registro se especifica mediante el nombre DNS y, opcionalmente, el n√∫mero de puerto.  La mayor√≠a de los beneficios del ecosistema docker est√°n impulsados ‚Äã‚Äãpor la capacidad de descargar y cargar repositorios en los servidores de registro. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Si el dacker de Docker no encuentra una copia del repositorio en la memoria cach√© local, la descarga autom√°ticamente del servidor de registro.  En la mayor√≠a de las distribuciones de Linux, el docker daemon usar√° el sitio docker.io para esto, pero en algunas distribuciones se puede configurar a su manera.  Por ejemplo, Red Hat Enterprise Linux primero intenta descargar desde Registry.access.redhat.com, y solo luego desde docker.io (Docker Hub). <br><br>  Debe enfatizarse aqu√≠ que el servidor de registro se considera impl√≠citamente como confiable.  Por lo tanto, debe decidir cu√°nto conf√≠a en el contenido de un registro y, respectivamente, permitirlo o denegarlo.  Adem√°s de la seguridad, hay otros aspectos que deben abordarse de antemano, por ejemplo, problemas de licencias de software o monitoreo de cumplimiento.  La simplicidad con la que Docker permite a los usuarios descargar software hace que el tema de la confianza sea extremadamente importante. <br><br>  Red Hat Enterprise Linux le permite configurar el registro docker predeterminado.  Adem√°s, RHEL7 y RHEL7 Atomic le permiten agregar o bloquear servidores de registro a trav√©s del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo de configuraci√≥n</a> : <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 y RHEL 7 Atomic utilizan el servidor de registro de Red Hat de manera predeterminada: <br><br><pre>  ADD_REGISTRY = '- agregar registro-registro.access.redhat.com'
</pre><br>  En algunos casos, por razones de seguridad, tiene sentido bloquear los registros de acopladores p√∫blicos, como DockerHub: <br><br><pre>  # BLOCK_REGISTRY = '- bloque-registro'
</pre><br>  Red Hat tambi√©n ofrece su servidor de registro integrado como parte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenShift Container Platform</a> , as√≠ como el servidor de registro corporativo independiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quay Enterprise</a> y los repositorios en la nube, privados y p√∫blicos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quay.io.</a> <br><br><h4>  Orquestaci√≥n de contenedores </h4><br>  Las personas generalmente comienzan instalando un host contenedor y primero simplemente descargando las im√°genes de contenedor que necesitan.  Luego proceden a crear sus propias im√°genes y las suben al servidor de registro para ponerlas a disposici√≥n del resto del equipo.  Despu√©s de alg√∫n tiempo, es necesario combinar varios contenedores para que puedan desplegarse como una sola unidad.  Y finalmente, en alg√∫n momento, estas unidades deben formar parte del transportador de producci√≥n (desarrollo-control de calidad-producci√≥n).  As√≠ es como las personas suelen darse cuenta de que necesitan un sistema de orquestaci√≥n. <br><br>  <b>El sistema de orquestaci√≥n de contenedores implementa solo dos cosas:</b> <br><br><ol><li>  Despacha din√°micamente cargas de contenedores a trav√©s de equipos de cl√∫ster (esto a menudo se conoce como "computaci√≥n distribuida") </li><li>  Proporciona un archivo de descripci√≥n de aplicaci√≥n est√°ndar (kube yaml, docker compose, etc.) </li></ol><br>  Estas dos cosas realmente ofrecen una variedad de beneficios: <br><br><ol><li>  La capacidad de administrar los contenedores que componen la aplicaci√≥n, independientemente uno del otro, lo que le permite resolver de manera efectiva las siguientes tareas: <br><ul><li>  Eliminaci√≥n de grandes grupos de hosts de contenedores. </li><li>  Falla a nivel de contenedores individuales (ya no responden procesos, agotamiento de memoria) </li><li>  Conmutaci√≥n por error en el nivel de host del contenedor (unidades, red, reinicio) </li><li>  Conmutaci√≥n por error en el nivel del motor del contenedor (da√±o, reinicio) </li><li>  Escalado individual de contenedores hacia arriba y hacia abajo </li></ul></li><li>  F√°cil de implementar nuevas instancias de la misma aplicaci√≥n en nuevos entornos, tanto en la nube como tradicionales, por ejemplo: <br><ul><li>  En m√°quinas desarrolladoras controladas por un sistema de orquestaci√≥n </li><li>  En un entorno de desarrollo compartido en un espacio de nombres privado </li><li>  En un entorno de desarrollo com√∫n en un espacio de nombres p√∫blico interno para garantizar la visibilidad y probar el rendimiento </li><li>  En el ambiente interno de QA </li><li>  En un entorno de carga de prueba proporcionado din√°micamente y revocado en la nube </li><li>  En un entorno de referencia para verificar la compatibilidad con el entorno de producci√≥n. </li><li>  En ambiente de producci√≥n </li><li>  En un entorno de recuperaci√≥n ante desastres. </li><li>  En un nuevo entorno de producci√≥n que contiene hosts de contenedores actualizados, motores de contenedores o herramientas de orquestaci√≥n </li><li>  En el nuevo entorno de producci√≥n, que no es diferente del principal, sino que se encuentra en una regi√≥n diferente </li></ul></li></ol><br>  Las comunidades de c√≥digo abierto y los proveedores de software ofrecen muchas herramientas de orquestaci√≥n diferentes.  Inicialmente, las tres grandes herramientas inclu√≠an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mesos</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes</a> , pero hoy Kubernetes se ha convertido en el est√°ndar de la industria, porque incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mesosphere</a> han anunciado su apoyo, sin mencionar a casi todos los principales proveedores de servicios.  Sin embargo, si est√° buscando un sistema de orquestaci√≥n corporativa, le recomendamos que eche un vistazo m√°s de cerca a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Red Hat OpenShift</a> . <br><br><h3>  Diccionario avanzado </h3><br><h4>  Tiempo de ejecuci√≥n del contenedor </h4><br>  El tiempo de ejecuci√≥n del contenedor es un componente de bajo nivel que generalmente se usa como parte de un motor de contenedor, pero tambi√©n se puede usar manualmente para probar los contenedores.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El est√°ndar OCI</a> define una implementaci√≥n de referencia del tiempo de ejecuci√≥n conocido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">runc</a> .  Esta es la implementaci√≥n m√°s utilizada, pero hay otros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempos de ejecuci√≥n</a> compatibles con OCI como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">railcar</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">katacontainers</a> .  Docker, CRI-O y muchos otros motores de contenedor usan runc. <br><br>  El tiempo de ejecuci√≥n del contenedor es responsable de lo siguiente: <br><br><ul><li>  Obtiene el punto de montaje del contenedor proporcionado por el motor del contenedor (para la prueba, podr√≠a ser solo un directorio) </li><li>  Obtiene los metadatos del contenedor proporcionados por el motor del contenedor (durante la prueba, este puede ser un archivo config.json ensamblado manualmente) </li><li>  Se comunica con el n√∫cleo del sistema operativo para iniciar procesos en contenedores (a trav√©s de la llamada al sistema de clonaci√≥n) </li><li>  Configura cgroups </li><li>  Configura la pol√≠tica de SELinux </li><li>  Configura las reglas de la armadura de la aplicaci√≥n </li></ul><br>  Una peque√±a digresi√≥n hist√≥rica: cuando apareci√≥ por primera vez el motor Docker, utilizaba el LXC como un entorno de tiempo de ejecuci√≥n.  Los desarrolladores de Docker escribieron su propia biblioteca para ejecutar contenedores llamados libcontainer.  Fue escrito en el idioma Golang y se convirti√≥ en parte del motor Docker.  Despu√©s del establecimiento de la organizaci√≥n OCI, Docker introdujo el c√≥digo fuente libcontainer en este proyecto y lanz√≥ esta biblioteca como una utilidad separada llamada runc, que luego se convirti√≥ en la implementaci√≥n de referencia del tiempo de ejecuci√≥n del contenedor dentro del est√°ndar OCI y se usa en otros motores de contenedor, como CRI-O .  Runc es una utilidad muy simple que solo espera que se le pase un punto de montaje (directorio) y metadatos (config.json).  Puede encontrar m√°s informaci√≥n sobre runc <a href="">aqu√≠</a> . <br><br>  Para una comprensi√≥n m√°s profunda, vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprensi√≥n de los est√°ndares de contenedores</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempo de ejecuci√≥n de contenedores</a> . <br><br><h4>  Capas de imagen </h4><br>  Los repositorios a menudo se denominan im√°genes o im√°genes de contenedores, aunque de hecho los repositorios consisten en una o m√°s capas.  Las capas de imagen en el repositorio est√°n interconectadas por las relaciones padre-hijo, y cada capa de imagen contiene diferencias de la capa padre. <br><br>  Veamos las capas del repositorio en el host del contenedor local.  Desde que comenz√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con la versi√≥n 1.7, Docker no tiene una herramienta integrada para ver las capas de im√°genes</a> en el repositorio local (pero hay herramientas para registros en l√≠nea), utilizaremos la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dockviz</a> .  Tenga en cuenta que cada capa tiene una etiqueta y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">identificador √∫nico universal (UUID)</a> .  Para ver los UUID abreviados que generalmente son √∫nicos dentro de la misma m√°quina, utilizamos el siguiente comando (si necesita un UUID completo, use el mismo comando con la opci√≥n -no-trunc): <br><br>  docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock nate / dockviz images -t <br><br><pre>  322332d8973c93 Tama√±o virtual: 187.7 MB
  Virtual ‚îî‚îÄea358092da77 Tama√±o virtual: 187.9 MB
  Virtual ‚îî‚îÄa467a7c6794f Tama√±o virtual: 187.9 MB
  Virtual ‚îî‚îÄca4d7b1b9a51 Tama√±o virtual: 187.9 MB
  Virtual ‚îî‚îÄ4084976dd96d Tama√±o virtual: 384.2 MB
  Virtual ‚îî‚îÄ943128b20e28 Tama√±o virtual: 386.7 MB
  Virtual ‚îî‚îÄdb20cc018f56 Tama√±o virtual: 386.7 MB
  Virtual ‚îî‚îÄ45b3c59b9130 Tama√±o virtual: 398.2 MB
  Virtual ‚îî‚îÄ91275de1a5d7 Tama√±o virtual: 422.8 MB
  Virtual ‚îî‚îÄe7a97058d51f Tama√±o virtual: 422.8 MB
  Virtual ‚îî‚îÄd5c963edfcb2 Tama√±o virtual: 422.8 MB
  Virtual ‚îî‚îÄ5cfc0ce98e02 Tama√±o virtual: 422.8 MB
  Virtual ‚îî‚îÄ7728f71a4bcd Tama√±o virtual: 422.8 MB
  Virtual ‚îî‚îÄ0542f67da01b Tama√±o virtual: 422.8 MB Etiquetas: docker.io/registry:latest
</pre><br>  Como puede ver, el repositorio docker.io/registry en realidad consta de muchas capas.  Sin embargo, lo que es m√°s importante, el usuario puede, en principio, "iniciar" el contenedor desde cualquier paso de esta escalera de pasos, por ejemplo, ingresando el comando a continuaci√≥n (es completamente correcto, pero nadie puede garantizar que se haya probado o funcionar√° correctamente).  Como regla general, el colector de im√°genes etiqueta (crea nombres) aquellas capas que deben usarse como punto de partida: <br><br><pre>  docker run -it 45b3c59b9130 bash
</pre><br>  Los repositorios se organizan de manera similar porque cada vez que el recopilador crea una nueva imagen, las diferencias se guardan como otra capa.  Hay dos formas principales de crear nuevas capas en el repositorio.  Primero, al crear una imagen manualmente, cada confirmaci√≥n de cambio crea una nueva capa.  Si el recopilador crea una imagen utilizando un archivo Docker, cada directiva del archivo crea una nueva capa.  Por lo tanto, siempre es √∫til poder ver qu√© ha cambiado en el repositorio entre capas. <br><br><h4>  Etiquetas </h4><br>  Aunque el usuario mismo puede especificar la capa de inicio para montar e iniciar el contenedor en el repositorio, no tiene que hacer esto en absoluto.  Cuando el recopilador de im√°genes crea un nuevo repositorio, generalmente marcan las capas m√°s adecuadas para este rol.  Estos marcadores se denominan etiquetas y representan una herramienta con la que el recopilador de im√°genes puede decirle al consumidor de im√°genes qu√© capas se utilizan mejor.  Normalmente, las etiquetas se usan para indicar versiones de software dentro de un repositorio.   OCI,  -       ,          .      ,         . <br><br>  ,     ‚Äì latest,     ,      .       ,     ,      . <br><br>       ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> jq</a>    ): <br><br><pre> curl -s registry.access.redhat.com/v1/repositories/rhel7/tags | jq<font></font>
 {<font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font>
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",<font></font>
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",<font></font>
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",<font></font>
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",<font></font>
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "latest": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"<font></font>
  }
</pre><br><h4>  </h4><br>    docker     ,   . ,     ¬´rhel7¬ª ‚Äì  . <br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      ¬´¬ª (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
 registry.access.redhat.com/rhel6/rhel latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
  ...
</pre><br>     ,            .      docker ( ,    )      ,      ¬´rhel7¬ª    . <br><br>         ,    docker     URL.  ,   ,   URL   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br>  ,    : <br><br><pre> REGISTRY/NAMESPACE/REPOSITORY[:TAG]
</pre><br>  URL    ,   , , .      URL   ,      docker  ,      .  ,    :            : <br><br><pre> docker pull registry.access.redhat.com/rhel7/rhel:latest<font></font>
 docker pull registry.access.redhat.com/rhel7/rhel<font></font>
 docker pull registry.access.redhat.com/rhel7<font></font>
 docker pull rhel7/rhel:latest<font></font>
</pre><br><h4>   </h4><br>   ‚Äì       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DockerHub</a>       ,     ,         . <br><br> Red Hat         ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Red Hat Federated Registry</a> .     registry.access.redhat.com  .  ,            .    ,  Red Hat   ,     -  : <br><br><pre> registry.access.redhat.com/rhel7/rhel<font></font>
registry.access.redhat.com/openshift3/mongodb-24-rhel7<font></font>
registry.access.redhat.com/rhscl/mongodb-26-rhel7<font></font>
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7<font></font>
registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0<font></font>
</pre><br>  ,    URL    .           .       fedora,         latest.           : <br><br><pre> docker pull fedora<font></font>
docker pull docker.io/fedora<font></font>
docker pull docker.io/library/fedora:latest<font></font>
</pre><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">exec()</a> .    ,       ,  docker,   docker          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clone()</a> .   clone ()     ,          ,  ,  ,  ,    .. <br><br> ,   Linux   -      ,            clone (). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b> ‚Ä¶</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416169/">https://habr.com/ru/post/es416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416157/index.html">En los brazos de Python (solo mujeres)</a></li>
<li><a href="../es416159/index.html">C√≥mo nos encargaron comparar un erizo con una serpiente</a></li>
<li><a href="../es416161/index.html">10 razones [para no] usar k8s</a></li>
<li><a href="../es416163/index.html">Aprende OpenGL. Lecci√≥n 5.6 - Mapeo de paralaje</a></li>
<li><a href="../es416167/index.html">Peter Norwig: Aprenda programaci√≥n en ... 10 a√±os</a></li>
<li><a href="../es416171/index.html">Pruebas de IU codificadas de Visual Studio: teor√≠a y pr√°ctica de aplicaci√≥n en nuestra empresa</a></li>
<li><a href="../es416175/index.html">Resultados de la competencia de j√≥venes desarrolladores de aplicaciones AR Epson Moverio BT-300</a></li>
<li><a href="../es416177/index.html">F√≥rmula Tupper e implementaci√≥n del algoritmo en Python</a></li>
<li><a href="../es416179/index.html">Una puerta que nos saluda por nombre y se abre solo para los empleados del departamento.</a></li>
<li><a href="../es416183/index.html">Prueba de datos: requisitos y niveles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>