<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😧 🙍 🙁 Bagaimana jika tidak ada analisa statis untuk bahasa favorit Anda? ✖️ 😤 🧟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nah, jika bahasa favorit Anda adalah Rusia, Inggris, dll., Maka ini adalah hub lain Dan jika bahasa pemrograman atau markup, maka tentu saja menulis p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana jika tidak ada analisa statis untuk bahasa favorit Anda?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474920/"><p>  Nah, jika bahasa favorit Anda adalah Rusia, Inggris, dll., Maka ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub lain</a>  Dan jika bahasa pemrograman atau markup, maka tentu saja menulis penganalisa sendiri!  Pada pandangan pertama, ini sangat sulit, tetapi, untungnya, ada alat multibahasa siap pakai yang relatif mudah untuk menambah dukungan untuk bahasa baru.  Hari ini saya akan menunjukkan cara menambahkan dukungan bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modelica</a> ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penganalisa PMD</a> dengan jumlah waktu yang cukup kecil. </p><br><p> Ngomong-ngomong, tahukah Anda apa yang dapat menurunkan kualitas basis kode yang diperoleh dari urutan permintaan tarikan ideal?  Fakta bahwa programmer pihak ketiga menyalin potongan-potongan kode proyek yang ada ke dalam tambalan mereka alih-alih abstraksi yang kompeten.  Anda harus mengakui bahwa, sampai taraf tertentu, bahkan lebih sulit untuk menangkap pemblokiran seperti itu daripada kode berkualitas rendah - itu berkualitas tinggi dan bahkan <strong>sudah</strong> dengan hati-hati disadap, jadi verifikasi lokal tidak cukup di sini, Anda perlu mengingat seluruh basis kode, tetapi ini tidak mudah bagi seseorang ... Jadi: jika menambahkan dukungan penuh untuk Modelica (tanpa membuat aturan khusus) ke negara "dapat menjalankan pemeriksaan primitif" membutuhkan waktu sekitar seminggu, kemudian dukungan untuk hanya detektor salin-tempel sering dapat ditambahkan dalam sehari! </p><a name="habracut"></a><br><h2 id="kakaya-eschyo-modelica">  Apa lagi Modelica? </h2><br><p> Modelica adalah, seperti namanya, bahasa untuk menulis model sistem fisik.  Bahkan, tidak hanya fisik: dimungkinkan untuk menggambarkan proses kimia, perilaku kuantitatif populasi hewan, dll - yang dijelaskan oleh sistem persamaan diferensial dari bentuk <code>der(X) = f(X)</code> , di mana <code>X</code> adalah vektor dari tidak diketahui.  Potongan kode imperatif juga didukung.  Persamaan diferensial parsial tidak didukung secara eksplisit, tetapi dimungkinkan untuk membagi area studi menjadi beberapa bagian (seperti yang mungkin kita lakukan dalam beberapa bahasa tujuan umum), dan kemudian menuliskan persamaan untuk setiap elemen, mengurangi masalah ke yang sebelumnya.  Trik Modelka adalah bahwa solusi untuk <code>der(X) = f(X)</code> ini <code>der(X) = f(X)</code> terletak pada kompiler: Anda hanya dapat mengubah pemecah <strong>dalam pengaturan</strong> , persamaannya tidak harus linier, dll. Singkatnya, ada beberapa nilai tambah (saya menulis rumus dari buku teks - dan itu berhasil), dan kontra (dengan lebih banyak abstraksi, kita mendapatkan lebih sedikit kontrol).  Pengantar Modelika adalah topik artikel terpisah (yang telah muncul beberapa kali di Habré), dan bahkan seluruh siklus, hari ini menarik minat saya sebagai terbuka dan memiliki beberapa implementasi, tetapi, sayangnya, masih merupakan standar yang lembab. </p><br><p>  Selain itu, Modelika, di satu sisi, memiliki pengetikan statis (yang akan membantu kita untuk menulis beberapa analisis bermakna lebih cepat), di sisi lain, ketika membuat contoh model, kompiler tidak diharuskan untuk sepenuhnya memeriksa seluruh perpustakaan (oleh karena itu, penganalisa statis sangat berguna untuk menangkap "tidur" bug).  Akhirnya, tidak seperti beberapa C ++, yang mana ada awan analisa statis dan kompiler dengan indah, <del>  dan yang paling penting dirinci, lihat templat C ++ </del>  diagnostik kesalahan, kompiler Model masih secara berkala menghasilkan kesalahan kompiler Internal, yang berarti bahwa ada ruang untuk membantu pengguna bahkan dengan analisa yang cukup sederhana. </p><br><h2 id="a-chto-za-pmd">  Apa itu PMD? </h2><br><p>  Saya akan menjawab <del>  lagu </del>  dengan sepeda.  Suatu kali saya ingin membuat beberapa permintaan tarik kecil ke lingkungan pengembangan untuk OpenModelica.  Melihat bagaimana penghematan model diproses di bagian lain dari kode, saya perhatikan bagian kecil dari empat baris kode yang mendukung beberapa jenis invarian.  Tidak memahami editor internal seperti apa yang berinteraksi dengannya, tetapi menyadari bahwa dari sudut pandang kode ini, tugas saya benar-benar identik, saya hanya memasukkannya ke dalam suatu fungsi sehingga saya dapat menggunakannya kembali dan tidak merusaknya.  Menteiner berkata, ini luar biasa, baru kemudian mengganti kode ini dengan pemanggilan fungsi di dua puluh tempat yang tersisa ... Saya memutuskan untuk tidak terlibat lagi, dan hanya membuat salinan lain, mencatat bahwa entah bagaimana kemudian saya perlu menyisir semuanya sekaligus tanpa mencampur dengan tambalan saat ini.  Googling, saya menemukan Copy-paste Detector (CPD) - bagian dari penganalisa statis PMD - yang mendukung lebih banyak bahasa daripada penganalisa itu sendiri.  Setelah meletakkannya di basis kode OMEdit, saya berharap melihat dua lusin potongan dari empat baris itu.  Saya tidak melihatnya (masing-masing tidak melebihi ambang batas dalam jumlah token), tetapi saya melihat, misalnya, pengulangan hampir lima puluh baris kode C ++.  Seperti yang sudah saya katakan, tidak mungkin bahwa menter hanya menyalin sepotong raksasa dari file lain.  Tapi dia bisa dengan mudah melewatkan ini di PR - karena kode, menurut definisi, sudah memenuhi semua standar proyek!  Ketika saya berbagi pengamatan dengan menter, dia setuju bahwa perlu dibersihkan sebagai bagian dari tugas terpisah. </p><br><p>  Dengan demikian, Program Detektor Kesalahan (PMD) adalah penganalisa statis yang mudah diperluas.  Mungkin dia tidak menghitung set nilai yang dapat diambil oleh variabel (meskipun siapa yang tahu ...), tetapi untuk menambahkan aturan, Anda bahkan tidak perlu tahu Java dan entah bagaimana mengubah kodenya!  Faktanya adalah bahwa hal pertama yang dia, dan tidak mengejutkan, adalah membangun file AST dengan kode sumber.  Dan seperti apa bentuk pohon parsing sumber?  Ke pohon parsing XML!  Jadi, Anda bisa menggambarkan aturan hanya sebagai permintaan XPath - yang cocok, lalu kami mengeluarkan peringatan.  Mereka bahkan memiliki debugger grafis untuk aturannya!  Aturan yang lebih kompleks, tentu saja, dapat ditulis langsung di Jawa sebagai pengunjung AST. </p><br><p>  <em><strong>Konsekuensi</strong></em> : PMD dapat digunakan tidak hanya untuk aturan yang keras dan universal yang telah dilakukan oleh programmer Java yang keras terhadap kode penganalisa, tetapi juga untuk gaya pengkodean lokal - bahkan jika Anda memasukkan ruleset.xml lokal Anda sendiri ke dalam setiap repositori! </p><br><h2 id="uroven-1-nahodim-kopipast-avtomatizirovanno">  Level 1: temukan salin-tempel secara otomatis </h2><br><p>  Pada prinsipnya, menambahkan dukungan untuk bahasa baru di CPD seringkali sangat sederhana.  Saya tidak melihat adanya akal dalam menceritakan kembali dokumentasi "bagaimana melakukan" - sangat jelas, terstruktur dan langkah-demi-langkah.  Untuk menceritakan kembali hal seperti itu - hanya bermain di telepon yang rusak.  Saya sebaiknya menjelaskan apa yang menanti Anda <em>(TLDR: tidak apa-apa)</em> : </p><br><ul><li>  Analyzer (baik PMD dan CPD) dikembangkan pada github di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori pmd / pmd</a> </li><li>  Debugger aturan visual telah dipindahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori pmd / pmd-designer yang terpisah</a> .  Harap dicatat bahwa jar-julukan jadi secara otomatis tertanam dalam <em>distribusi biner PMD</em> , yang akan dikumpulkan Gradle untuk Anda di repositori sebelumnya, Anda tidak perlu mengkloning <code>pmd-designer</code> untuk ini. </li><li>  Proyek ini memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Pengembang</a> .  Yang saya baca sangat detail.  Benar, sedikit ketinggalan jaman, tapi ini diperlakukan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan tarikan kedua</a> :) </li></ul><br><p>  Saya akan memperingatkan Anda bahwa saya sedang mengembangkan di Ubuntu.  Pada Windows, itu juga harus bekerja dengan sempurna - baik dari segi kualitas maupun dalam arti cara yang sedikit berbeda dari meluncurkan alat. </p><br><p>  Jadi, untuk menambahkan bahasa baru ke CPD, Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hanya</a> perlu ... </p><br><ul><li>  <strong>PERHATIAN:</strong> jika Anda ingin dukungan penuh untuk PMD sebelum rilis PMD 7, maka lebih baik langsung ke level 2, karena dukungan normal untuk cara mudah melalui tata bahasa Antlr siap pakai akan muncul, menurut rumor, dalam versi yang sama 7, tetapi untuk saat ini Anda hanya akan menghabiskan waktu (meskipun dan sedikit ...) </li><li>  Fork <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori pmd / pmd</a> . </li><li>  Temukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antlr / grammars-v4</a> tata bahasa yang sudah jadi untuk bahasa Anda - tentu saja, jika bahasanya internal, Anda harus menulis sendiri, tetapi untuk Modelika, misalnya, ditemukan.  Di sini, tentu saja, Anda harus mematuhi formalitas dengan lisensi - Saya bukan pengacara, tetapi setidaknya saya perlu menentukan sumber dari mana saya menyalin. </li><li>  Setelah itu, Anda perlu membuat <code>pmd-&lt;your language name&gt;</code> , menambahkannya ke Gradle dan meletakkan file tata bahasa di sana.  Selanjutnya, setelah membaca dua halaman dokumentasi yang tidak membuat stres, ulangi skrip perakitan dari modul untuk Go, beberapa kelas untuk memuat modul melalui refleksi, <em>well, ada sedikit hal ...</em> </li><li>  Perbaiki hasil referensi di salah satu tes, karena sekarang CPD mendukung satu bahasa lagi!  Bagaimana Anda menemukan tes ini?  Sangat mudah: <em>dia ingin merusak bangunan</em> . </li><li>  KEUNTUNGAN!  Ini sangat sederhana <em>asalkan ada tata bahasa yang sudah jadi</em> </li></ul><br><p>  Sekarang, dengan berada di root repositori pmd, Anda dapat mengetik <code>./mvnw clean verify</code> , sementara di <code>pmd-dist/target</code> Anda akan mendapatkan, antara lain, distribusi biner dalam bentuk arsip zip yang Anda perlu unzip dan dijalankan menggunakan <code>./bin/run.sh cpd --minimum-tokens 100 --files /path/to/source/dir --language &lt;your language name&gt;</code> dari direktori yang belum dibongkar.  Pada prinsipnya, Anda dapat melakukan <code>../mvnw clean verify</code> dari dalam modul baru Anda, yang akan secara drastis mempercepat perakitan, tetapi kemudian Anda harus benar memasukkan julukan tabung yang dirakit ke dalam distribusi biner yang belum dibongkar (misalnya, dipasang satu kali setelah mendaftar modul baru). </p><br><h2 id="uroven-2-nahodim-oshibki-i-narusheniya-style-guide">  Level 2: menemukan kesalahan dan pelanggaran panduan gaya </h2><br><p>  Seperti yang saya katakan, dukungan penuh untuk Antlr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijanjikan dalam PMD 7</a> .  Jika Anda, seperti saya, tidak ingin menunggu pelepasan laut, maka Anda harus mendapatkan deskripsi tata bahasa dari bahasa tersebut dalam format JJTree dari suatu tempat.  Mungkin Anda dapat mengeras sendiri dukungan parser yang sewenang-wenang - dokumentasi mengatakan bahwa ini mungkin, <em>tetapi mereka tidak tahu persisnya</em> ... Saya hanya mengambil <code>modelica.g4</code> dari repositori yang sama dengan tata bahasa untuk Anltr sebagai dasar, dan secara manual membuat ulang menjadi JJTree.  Secara alami, jika tata bahasa ternyata merupakan pemrosesan dari yang sudah ada, sekali lagi, tunjukkan sumbernya, verifikasi kepatuhannya dengan lisensi dan.  dll. </p><br><p>  Ngomong-ngomong, bagi seseorang yang fasih dalam semua jenis generator parser, ini sepertinya tidak mengejutkan.  Sebelum itu, saya serius menggunakannya kecuali saya sendiri menulis kombinator tetap dan parser di Scala.  Oleh karena itu, hal yang jelas, pada kenyataannya, membuat saya sedih pada awalnya: AST, tentu saja, saya akan dapatkan dari <code>modelica.g4</code> , tetapi itu tidak terlihat sangat jelas dan "dapat digunakan": akan ada awan node tambahan di dalamnya, dan jika Anda tidak melihat <strong>token</strong> , tetapi hanya di node, tidak selalu jelas di mana, misalnya, <code>then</code> cabang berakhir, dan yang <code>else</code> dimulai. </p><br><p>  Sekali lagi, saya tidak akan menceritakan kembali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi pada JJTree</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial yang bagus</a> - kali ini, bukan karena yang asli bersinar dengan detail dan kejelasan, tetapi karena saya sendiri tidak mengetahuinya sepenuhnya, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi itu dikirim kembali secara</a> tidak benar, tetapi dengan keyakinan, jelas lebih buruk daripada tidak menceritakan kembali.  Saya lebih baik meninggalkan sedikit petunjuk, ditemukan di sepanjang jalan: </p><br><ul><li>  Pertama, <strong>kode deskripsi parser JavaCC mengasumsikan memasukkan Java yang akan ditulis dalam parser yang dihasilkan</strong> </li><li>  Jangan bingung bahwa ketika membangun AST, sintaksis seperti <code>[ Expression() ]</code> berarti opsional, dan dalam konteks menggambarkan token - memilih karakter, seperti dalam ekspresi reguler.  Sejauh yang saya mengerti penjelasan dari pengembang PMD, ini adalah konstruksi serupa yang memiliki arti yang berbeda - warisan, pak ... </li><li>  Untuk simpul root (dalam kasus saya, <code>StoredDefinition</code> ), Anda harus menentukan jenisnya alih-alih <code>void</code> (mis. <code>ASTStoredDefiniton</code> ) </li><li>  Menggunakan sintaks <code>#void</code> setelah nama node, Anda dapat menyembunyikannya dari parsing tree (yaitu, itu hanya akan mempengaruhi apa sumber yang benar dan apa yang tidak, dan bagaimana node lain akan bersarang) </li><li>  Menggunakan konstruksi bentuk <code>void SimpleExpression() #SimpleExpression(&gt;1)</code> kita dapat mengatakan bahwa node harus ditampilkan di AST yang dihasilkan, jika memiliki lebih dari satu turunan.  Ini sangat nyaman ketika menggambarkan ekspresi dengan banyak operator dengan prioritas berbeda: yaitu, dari sudut pandang parser, satu-satunya yang konstan adalah sesuatu seperti <code>LogicExpression(AdditiveExpression(MultiplicativeExperssion(Constant(1))))</code> - <em>masukkan semua n level prioritas operasi</em> - tetapi kode analyzer hanya akan mendapatkan <code>Constant(1)</code> </li><li>  Node memiliki <code>image</code> variabel standar (lihat <code>getImage</code> , <code>setImage</code> ), yang biasanya <code>setImage</code> "esensi" dari node ini: misalnya, untuk node yang sesuai dengan nama variabel lokal, logis untuk menyalin token yang cocok dengan pengidentifikasi ke dalam <code>image</code> (secara default, semua token dari pohon akan dibuang, jadi ada baiknya menyalin makna yang terkandung di dalamnya, dalam hal apa pun, jika itu adalah variabel, dan bukan hanya kata kunci) </li><li>  <strong>LOOKAHEAD</strong> - well, ini adalah lagu yang terpisah, bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab terpisah</a> dalam dokumentasi dikhususkan untuk itu <br><ul><li>  secara kasar, di JavaCC, jika Anda pergi ke sebuah simpul, Anda tidak dapat melemparkannya kembali dan mencoba mengurai secara berbeda, tetapi Anda dapat melihat ke depan sebelumnya dan memutuskan apakah akan pergi atau tidak </li><li>  dalam kasus paling sederhana, setelah melihat peringatan JavaCC, <del>  Anda cukup mengatakan di header <code>LOOKAHEAD = n</code> </del>  dan Anda mendapatkan kesalahan penguraian misterius, karena dalam kasus umum, tampaknya, itu tidak dapat menyelesaikan semua masalah (kecuali, dengan menetapkan beberapa miliar token, Anda benar-benar mendapatkan pratinjau segala sesuatu, tetapi bukan fakta bahwa itu berfungsi seperti itu .. .) </li><li>  di depan nama node tertanam, Anda dapat secara eksplisit menunjukkan berdasarkan berapa banyak token di sini Anda pasti dapat membuat keputusan akhir </li><li>  jika dalam kasus umum tidak ada jumlah token yang pasti, Anda dapat mengatakan "buka di sini, jika sebelumnya, mulai dari titik ini, kami berhasil mencocokkan awalan seperti itu - dan kemudian deskripsi subtree biasa" </li><li>  hati-hati: dalam kasus umum, JavaCC tidak dapat memeriksa kebenaran arahan <code>LOOKAHEAD</code> - ini mempercayai Anda, jadi setidaknya <code>LOOKAHEAD</code> bukti matematis mengapa pencarian seperti itu cukup ... </li></ul></li></ul><br><p>  Sekarang setelah Anda memiliki deskripsi tata bahasa dalam format JJTree, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">14 langkah sederhana ini</a> akan membantu Anda menambahkan dukungan bahasa.  Kebanyakan dari mereka memiliki bentuk "buat kelas yang mirip dengan implementasi untuk java atau vm, tetapi diadaptasi."  Saya hanya akan mencatat fitur-fitur khas, beberapa di antaranya akan muncul di dokumentasi utama jika mereka menerima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan tarikan saya untuk dokumentasi</a> : </p><br><ul><li>  Mengomentari penghapusan semua file yang dihasilkan dalam skrip perakitan <code>alljavacc.xml</code> (yang ada di modul baru Anda), Anda dapat mentransfernya ke hierarki sumber dari <code>target/generated-sources</code> .  Tapi lebih baik tidak.  Kemungkinan besar, hanya sebagian kecil yang akan diubah, jadi lebih baik menghapus beberapa saja: mereka melihat perlunya mengubah implementasi default, disalin ke hierarki sumber, ditambahkan ke daftar file yang dihapus, dibangun kembali - dan sekarang Anda mengelola file - <strong>khususnya file ini</strong> .  Kalau tidak, akan sulit untuk mencari tahu apa yang sebenarnya telah diubah, dan dukungan itu hampir tidak dapat disebut menyenangkan. </li><li>  sekarang setelah Anda menerapkan mode PMD "utama", Anda dapat dengan mudah bertahan pada parser JJTree Anda yang mengikat untuk CPD juga, mirip dengan Java atau beberapa implementasi lain yang tersedia </li><li>  Ingatlah untuk mengimplementasikan metode yang mengembalikan nama host untuk permintaan XPath.  Dalam implementasi default, rekursi tak terbatas diperoleh (nama simpul melalui <code>toString</code> dan sebaliknya), atau sesuatu yang lain, secara umum, karena ini, juga tidak mungkin untuk melihat pohon di PMD Designer, dan tanpa debugging tata bahasa ini benar-benar menyedihkan </li><li>  bagian dari registrasi komponen dilakukan dengan menambahkan file teks dari titik entri nama kelas yang berkualifikasi penuh ke <code>META-INF/services</code> </li><li>  apa yang dapat dideskripsikan secara deklaratif dalam aturan (misalnya, uraian terperinci tentang pemeriksaan dan contoh kesalahan) dijelaskan tidak dalam kode, tetapi dalam <code>category/&lt;language name&gt;/&lt;ruleset&gt;.xml</code> - dalam hal apa pun, Anda harus mendaftarkan aturan Anda di sana </li><li>  ... tetapi ketika mengimplementasikan tes, tampaknya, beberapa, mungkin buatan sendiri, mekanisme penemuan otomatis aktif digunakan, oleh karena itu <br><ul><li>  jika Anda diberi tahu "tambahkan tes sepele untuk setiap versi bahasa" - lebih baik tidak berdebat, mereka mengatakan "Saya tidak membutuhkannya, itu berfungsi seperti itu" - mungkin ini adalah mekanisme penemuan otomatis </li><li>  jika Anda melihat tes untuk aturan tertentu dengan badan kelas yang hanya berisi komentar <code>// no additional unit tests</code> , maka ini bukan tes, mereka hanya terletak pada sumber daya dalam bentuk XML-deskripsi data input dan reaksi analisis yang diharapkan, segera: beberapa yang benar dan beberapa contoh yang salah. </li></ul></li></ul><br><h2 id="malenkiy-no-vazhnyy-kvest-dopili-pmd-designer">  Sebuah pencarian kecil namun penting: menyelesaikan Designer PMD </h2><br><p>  Mungkin Anda dapat men-debug semuanya tanpa visualisator.  Tapi mengapa?  Pertama, untuk menyelesaikannya sangat sederhana.  Kedua, ini akan sangat membantu pengguna Anda yang tidak terbiasa dengan Java: mereka mudah dan sederhana (jika ini berlaku untuk XPath sama sekali), baik, atau setidaknya tanpa mengkompilasi ulang PMD akan dapat menggambarkan pola-pola sederhana dari apa yang tidak mereka sukai (dalam kasus paling sederhana) - panduan gaya seperti "nama paket model selalu dimulai dengan huruf kecil"). </p><br><p>  Tidak seperti kesalahan lain yang langsung terlihat, masalah dengan PMD Designer cukup berbahaya: Anda mungkin sudah mengerti bahwa prasasti Java di sisi kanan menu bukanlah tombol, tetapi daftar drop-down dari pilihan bahasa O_o, di mana sudah muncul Modelica, karena modul baru dengan pendaftaran titik masuk telah muncul di classpath.  Tapi di sini Anda memilih bahasa Anda, unduh file tes, dan lihat AST.  Dan tampaknya menjadi kemenangan, tetapi entah bagaimana hitam dan putih, dan subtree yang disorot dapat disorot dalam teks - meskipun tidak, ada sorot, tetapi diperbarui secara bengkok - namun, bagaimana mereka tidak menebak untuk menyoroti pertandingan yang ditemukan dengan XPath ... Sudah memperkirakan jumlah pekerjaan, Anda memikirkan permintaan tarikan berikutnya, tetapi kemudian Anda secara tidak sengaja memutuskan untuk beralih bahasa ke Jawa dan mengunduh beberapa kode sumber PMD itu sendiri ... Oh!  Warnanya berwarna! .. Dan highlight subtree berfungsi!  Eh ... dan ternyata itu biasanya menyorot kecocokan yang ditemukan dan menulis potongan teks di kotak di sebelah kanan permintaan ... Rasanya seperti ketika pengecualian terjadi pada kode JavaFX saat membuat antarmuka, itu mengganggu rendering, tetapi tidak mencetak ke konsol ... </p><br><p>  Secara umum, Anda hanya perlu menambahkan kelas ma-a-scarlet untuk menyorot sintaksis berdasarkan ekspresi reguler.  Dalam kasus saya, itu <code>net.sourceforge.pmd.util.fxdesigner.util.codearea.syntaxhighlighting.ModelicaSyntaxHighlighter</code> , yang perlu didaftarkan di kelas <code>AvailableSyntaxHighlighters</code> .  Harap dicatat bahwa kedua perubahan ini terjadi di repositori <code>pmd-designer</code> , artefak perakitan yang perlu dimasukkan ke dalam distribusi biner Anda. </p><br><p>  Pada akhirnya, terlihat seperti ini (GIF diambil dari README dalam repositori Designer PMD): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/289/e3e/92b/289e3e92b353b29c696ed466434307ed.gif" alt="Desainer PMD di tempat kerja"></p><br><h2 id="promezhutochnyy-itog">  Subtotal </h2><br><p>  Jika Anda telah menyelesaikan semua level ini, maka sekarang Anda memiliki: </p><br><ul><li>  copy paste detektor </li><li>  mesin aturan </li><li>  visualizer untuk debug AST dan membawanya ke dalam bentuk yang mudah untuk analisis (seperti yang telah kita lihat, tidak semua tata bahasa dengan bahasa yang sama berguna!) </li><li>  visualisator yang sama untuk men-debug aturan XPath yang dapat ditulis pengguna Anda tanpa mengkompilasi ulang PMD dan umumnya pengetahuan tentang Java (XPath, tentu saja, juga bukan BASIC, tetapi setidaknya merupakan standar dan bukan bahasa permintaan lokal) </li></ul><br><p>  Saya harap Anda juga memiliki pemahaman tentang fakta bahwa tata bahasa sekarang menjadi API yang stabil untuk implementasi dukungan bahasa Anda - jangan mengubahnya (atau lebih tepatnya fungsi mengubah sumber menjadi AST yang dijelaskan olehnya) kecuali jika benar-benar diperlukan, dan jika Anda telah berubah, beri tahu sebagai pemecah perubahan, dan kemudian pengguna akan kecewa: kemungkinan besar, tidak semua orang akan menulis tes untuk aturan mereka, tetapi sangat menyedihkan ketika aturan memeriksa kode, dan kemudian berhenti tanpa peringatan - hampir seperti cadangan, yang tiba-tiba rusak, dan setahun yang lalu ... </p><br><p>  Ceritanya tidak berakhir di sini: setidaknya beberapa aturan yang berguna harus ditulis. </p><br><p>  Tapi itu belum semuanya: PMD secara alami mendukung cakupan dan deklarasi.  Setiap node AST memiliki cakupan yang terkait dengannya: tubuh kelas, fungsi, loop ... Seluruh file, paling buruk!  Dan di setiap ruang lingkup ada daftar definisi (deklarasi) yang dikandungnya secara langsung.  Seperti dalam kasus-kasus lain, diusulkan untuk diimplementasikan secara analogi dengan bahasa-bahasa lain, misalnya, Modelika (tetapi pada saat penulisan, logika dalam permintaan tarikan saya, sejujurnya, mentah).   scopes  declarations    visitor,  -  <code>ScopeAndDeclarationFinder</code> ,           —  ,    ,  ,  - ,  read-only    AST.        ,    . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelicaHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractLanguageVersionHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Override public VisitorStarter getSymbolFacade() { return new VisitorStarter() { @Override public void start(Node rootNode) { new SymbolFacade().initializeWith((ASTStoredDefinition) rootNode); } }; } }</span></span></code> </pre> <br><h2 id="vyvod">  Kesimpulan </h2><br><p>   PMD     .  ,     «»  Clang Static Analyzer   ,           .      ,      CPD (   ),         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474920/">https://habr.com/ru/post/id474920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474906/index.html">Xamarin.Forms - Pemetaan QRCode dekoratif dengan SkiaSharp</a></li>
<li><a href="../id474910/index.html">Apa yang harus dimainkan dengan anak-anak sebelum sekolah</a></li>
<li><a href="../id474912/index.html">Pesan dan peringatan di Android melalui JSON</a></li>
<li><a href="../id474916/index.html">Terapkan lingkungan Nix-Shell dalam Visual Studio Code</a></li>
<li><a href="../id474918/index.html">Meningkatkan desain bersama komponen elektromekanis</a></li>
<li><a href="../id474922/index.html">Cara memilih VPS</a></li>
<li><a href="../id474924/index.html">Bagaimana cara menjadi manajer yang baik? 4 cara untuk mengisi kesenjangan dalam keterampilan manajemen</a></li>
<li><a href="../id474928/index.html">Belajar mengikuti peramban Vivaldi</a></li>
<li><a href="../id474930/index.html">Leading Burning Leads: Dapatkan Streaming</a></li>
<li><a href="../id474936/index.html">15 alat hebat untuk membuat, menyimpan, dan mengelola tautan (bourget)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>