<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèæ üõ°Ô∏è üçá Jenis Referensi .NET vs Jenis Nilai. Bagian 2 üëÇüèº üòé üåç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tipe dasar objek dan implementasi antarmuka. Tinju 


 Tampaknya kami datang melalui neraka dan air yang tinggi dan dapat melakukan wawancara, bahkan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis Referensi .NET vs Jenis Nilai. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439490/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="the-object-base-type-and-implementation-of-interfaces-boxing">  Tipe dasar objek dan implementasi antarmuka.  Tinju </h2><br><p>  Tampaknya kami datang melalui neraka dan air yang tinggi dan dapat melakukan wawancara, bahkan yang untuk tim .NET CLR.  Namun, jangan terburu-buru ke microsoft.com dan mencari lowongan.  Sekarang, kita perlu memahami bagaimana tipe nilai mewarisi objek jika mereka tidak mengandung referensi ke SyncBlockIndex, bukan penunjuk ke tabel metode virtual.  Ini akan sepenuhnya menjelaskan sistem kami tentang jenis dan semua potongan puzzle akan menemukan tempat mereka.  Namun, kita akan membutuhkan lebih dari satu kalimat. </p><br><p>  Sekarang, mari kita ingat lagi bagaimana tipe nilai dialokasikan dalam memori.  Mereka mendapatkan tempat di memori tepat di tempat mereka berada.  Jenis referensi mendapatkan alokasi pada tumpukan benda kecil dan besar.  Mereka selalu memberikan referensi ke tempat di tumpukan tempat objek itu berada.  Setiap tipe nilai memiliki metode seperti ToString, Equals, dan GetHashCode.  Mereka virtual dan dapat ditimpa, tetapi tidak memungkinkan untuk mewarisi tipe nilai dengan metode utama.  Jika tipe nilai menggunakan metode yang dapat ditimpa, mereka akan membutuhkan tabel metode virtual untuk merutekan panggilan.  Ini akan mengarah pada masalah meneruskan struktur ke dunia yang tidak dikelola: ladang tambahan akan pergi ke sana.  Akibatnya, ada deskripsi metode tipe nilai di suatu tempat, tetapi Anda tidak dapat mengaksesnya secara langsung melalui tabel metode virtual. </p><br><p>  Ini mungkin membawa gagasan bahwa kurangnya warisan adalah buatan </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Ini mungkin membawa gagasan bahwa kurangnya warisan adalah buatan: </p><br><ul><li>  ada warisan dari suatu objek, tetapi tidak langsung; </li><li> ada ToString, Equals dan GetHashCode di dalam tipe dasar.  Dalam tipe nilai metode ini memiliki perilaku mereka sendiri.  Ini berarti, bahwa metode ditimpa dalam kaitannya dengan <code>object</code> ; </li><li>  selain itu, jika Anda melemparkan tipe ke <code>object</code> , Anda memiliki hak penuh untuk memanggil ToString, Equals, dan GetHashCode; </li><li>  saat memanggil metode instance untuk tipe nilai, metode tersebut mendapatkan struktur lain yang merupakan salinan asli.  Itu berarti memanggil metode contoh seperti memanggil metode statis: <code>Method(ref structInstance, newInternalFieldValue)</code> .  Memang, panggilan ini melewati <code>this</code> , dengan satu pengecualian, namun.  JIT harus mengkompilasi tubuh metode, sehingga tidak perlu mengimbangi bidang struktur, melompati pointer ke tabel metode virtual, yang tidak ada dalam struktur.  <em>Itu ada untuk tipe nilai di tempat lain</em> . </li></ul><br><p>  Tipe berbeda dalam perilaku, tetapi perbedaan ini tidak begitu besar pada tingkat implementasi dalam CLR.  Kami akan membicarakannya nanti. </p><br><p>  Mari kita tulis baris berikut di program kami: </p><br><pre> <code class="plaintext hljs">var obj = (object)10;</code> </pre> <br><p>  Ini akan memungkinkan kita untuk berurusan dengan nomor 10 menggunakan kelas dasar.  Ini disebut tinju.  Itu artinya kita memiliki VMT untuk memanggil metode virtual seperti ToString (), Equals dan GetHashCode.  Pada kenyataannya tinju menciptakan salinan tipe nilai, tetapi bukan penunjuk ke sumber asli.  Ini karena kita dapat menyimpan nilai asli di mana-mana: di stack atau sebagai bidang kelas.  Jika kita melemparkannya ke tipe objek, kita dapat menyimpan referensi ke nilai ini selama yang kita inginkan.  Ketika tinju terjadi: </p><br><ul><li>  CLR mengalokasikan ruang pada heap untuk struktur + SyncBlockIndex + VMT dari tipe nilai (untuk memanggil ToString, GetHashCode, Equals); </li><li>  itu menyalin contoh tipe nilai di sana. </li></ul><br><p>  Sekarang, kami memiliki varian referensi tipe nilai.  Suatu struktur <strong>benar-benar memiliki kumpulan bidang sistem yang sama dengan jenis referensi</strong> , <br>  menjadi tipe referensi yang lengkap setelah tinju.  Struktur menjadi kelas.  Sebut saja jungkir .NET.  Ini nama yang adil. </p><br><p>  Lihat saja apa yang terjadi jika Anda menggunakan struktur yang mengimplementasikan antarmuka menggunakan antarmuka yang sama. </p><br><pre> <code class="plaintext hljs">struct Foo : IBoo { int x; void Boo() { x = 666; } } IBoo boo = new Foo(); boo.Boo();</code> </pre> <br><p>  Ketika kita membuat instance Foo, nilainya masuk ke stack sebenarnya.  Kemudian kita menempatkan variabel ini ke dalam variabel tipe antarmuka dan struktur menjadi variabel tipe referensi.  Selanjutnya, ada tinju dan kami memiliki tipe objek sebagai output.  Tetapi ini adalah variabel tipe antarmuka.  Itu berarti kita perlu konversi jenis.  Jadi, panggilan itu terjadi dengan cara seperti ini: </p><br><pre> <code class="plaintext hljs">IBoo boo = (IBoo)(box_to_object)new Foo(); boo.Boo();</code> </pre> <br><p>  Menulis kode seperti itu tidak efektif.  Anda harus mengubah salinan alih-alih yang asli: </p><br><pre> <code class="plaintext hljs">void Main() { var foo = new Foo(); foo.a = 1; Console.WriteLite(foo.a); // -&gt; 1 IBoo boo = foo; boo.Boo(); // looks like changing foo.a to 10 Console.WriteLite(foo.a); // -&gt; 1 } struct Foo: IBoo { public int a; public void Boo() { a = 10; } } interface IBoo { void Boo(); }</code> </pre> <br><p>  Pertama kali kita melihat kode, kita tidak harus tahu apa yang kita hadapi dalam kode <em>selain</em> kode <em>kita</em> dan melihat pemain yang dilemparkan ke antarmuka IBoo.  Ini membuat kami berpikir Foo adalah kelas dan bukan struktur.  Maka tidak ada pembagian visual dalam struktur dan kelas, yang membuat kita berpikir <br>  hasil modifikasi antarmuka harus masuk ke foo, yang tidak terjadi karena boo adalah salinan foo.  Itu menyesatkan.  Menurut pendapat saya, kode ini harus mendapatkan komentar, sehingga pengembang lain dapat menghadapinya. </p><br><p>  Hal kedua berkaitan dengan pemikiran sebelumnya bahwa kita dapat melemparkan tipe dari objek ke IBoo.  Ini adalah bukti lain bahwa tipe nilai kotak adalah varian referensi dari tipe nilai.  Atau, semua tipe dalam sistem tipe adalah tipe referensi.  Kami hanya bisa bekerja dengan struktur seperti dengan tipe nilai, melewati nilainya sepenuhnya.  Mendereferensi pointer ke objek seperti yang Anda katakan di dunia C ++. </p><br><p>  Anda dapat keberatan jika itu benar, akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">var referenceToInteger = (IInt32)10;</code> </pre> <br><p>  Kami tidak hanya akan mendapatkan objek, tetapi juga referensi yang diketik untuk tipe nilai kotak.  Itu akan menghancurkan seluruh ide jenis nilai (yaitu integritas nilai mereka) yang memungkinkan untuk optimasi yang hebat, berdasarkan pada sifat mereka.  Mari kita hilangkan ide ini! </p><br><pre> <code class="plaintext hljs">public sealed class Boxed&lt;T&gt; { public T Value; [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) { return Value.Equals(obj); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() { return Value.ToString(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() { return Value.GetHashCode(); } }</code> </pre> <br><p>  Kami memiliki analog tinju lengkap.  Namun, kita dapat mengubah isinya dengan memanggil metode instan.  Perubahan ini akan memengaruhi semua bagian dengan referensi ke struktur data ini. </p><br><pre> <code class="plaintext hljs">var typedBoxing = new Boxed&lt;int&gt; { Value = 10 }; var pureBoxing = (object)10;</code> </pre> <br><p>  Varian pertama tidak terlalu menarik.  Alih-alih casting tipe kita membuat omong kosong.  Baris kedua jauh lebih baik, tetapi dua garis hampir identik.  Satu-satunya perbedaan adalah bahwa tidak ada pembersihan memori dengan nol selama tinju biasa setelah mengalokasikan memori pada heap.  Struktur yang diperlukan mengambil memori dengan segera sedangkan varian pertama perlu dibersihkan.  Ini membuatnya bekerja lebih lama dari tinju biasa sebesar 10%. </p><br><p>  Sebagai gantinya, kita dapat memanggil beberapa metode untuk nilai kotak kami. </p><br><pre> <code class="plaintext hljs">struct Foo { public int x; public void ChangeTo(int newx) { x = newx; } } var boxed = new Boxed&lt;Foo&gt; { Value = new Foo { x = 5 } }; boxed.Value.ChangeTo(10); var unboxed = boxed.Value;</code> </pre> <br><p>  Kami punya instrumen baru.  Mari kita pikirkan apa yang bisa kita lakukan dengannya. </p><br><ul><li>  Jenis <code>Boxed&lt;T&gt;</code> kami melakukan hal yang sama dengan tipe yang biasa: mengalokasikan memori pada heap, meneruskan nilai di sana dan memungkinkan untuk mendapatkannya, dengan melakukan semacam unbox; </li><li>  Jika Anda kehilangan referensi ke struktur kotak, GC akan mengumpulkannya; </li><li>  Namun, sekarang kita dapat bekerja dengan tipe kotak, yaitu memanggil metodenya; </li><li>  Juga, kita bisa mengganti instance dari tipe nilai dalam SOH / LOH untuk yang lain.  Kami tidak dapat melakukannya sebelumnya, karena kami harus melakukan unboxing, mengubah struktur ke yang lain dan melakukan boxing kembali, memberikan referensi baru kepada pelanggan. </li></ul><br><p>  Masalah utama tinju adalah menciptakan lalu lintas dalam memori.  Lalu lintas dari sejumlah objek yang tidak diketahui, yang bagiannya dapat bertahan hingga generasi satu, di mana kita mendapatkan masalah dengan pengumpulan sampah.  Akan ada banyak sampah dan kita bisa menghindarinya.  Tetapi ketika kita memiliki lalu lintas objek berumur pendek, solusi pertama adalah penyatuan.  Ini adalah akhir yang ideal dari .NET somersault. </p><br><pre> <code class="plaintext hljs">var pool = new Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000); var boxed = pool.Box(10); boxed.Value=70; // use boxed value here pool.Free(boxed);</code> </pre> <br><p>  Sekarang tinju dapat bekerja menggunakan pool, yang menghilangkan lalu lintas memori saat tinju.  Kita bahkan dapat membuat objek hidup kembali dalam metode finalisasi dan menempatkan diri kembali ke kolam.  Ini mungkin berguna ketika struktur kotak pergi ke kode asinkron selain milik Anda dan Anda tidak bisa mengerti ketika itu menjadi tidak perlu.  Dalam hal ini, ia akan kembali ke kolam selama GC. </p><br><p>  Mari kita simpulkan: </p><br><ul><li>  Jika tinju kebetulan dan tidak seharusnya terjadi, jangan mewujudkannya.  Ini dapat menyebabkan masalah dengan kinerja. </li><li>  Jika tinju diperlukan untuk arsitektur sistem, mungkin ada varian.  Jika lalu lintas struktur kotak kecil dan hampir tidak terlihat, Anda dapat menggunakan tinju.  Jika lalu lintas terlihat, Anda mungkin ingin melakukan pengumpulan tinju, menggunakan salah satu solusi yang disebutkan di atas.  Itu menghabiskan beberapa sumber daya, tetapi membuat GC bekerja tanpa kelebihan; </li></ul><br><p>  Pada akhirnya mari kita lihat kode yang sama sekali tidak praktis: </p><br><pre> <code class="plaintext hljs">static unsafe void Main() { // here we create boxed int object boxed = 10; // here we get the address of a pointer to a VMT var address = (void**)EntityPtr.ToPointerWithOffset(boxed); unsafe { // here we get a Virtual Methods Table address var structVmt = typeof(SimpleIntHolder).TypeHandle.Value.ToPointer(); // change the VMT address of the integer passed to Heap into a VMT SimpleIntHolder, turning Int into a structure *address = structVmt; } var structure = (IGetterByInterface)boxed; Console.WriteLine(structure.GetByInterface()); } interface IGetterByInterface { int GetByInterface(); } struct SimpleIntHolder : IGetterByInterface { public int value; int IGetterByInterface.GetByInterface() { return value; } }</code> </pre> <br><p>  Kode menggunakan fungsi kecil, yang bisa mendapatkan pointer dari referensi ke suatu objek.  Perpustakaan tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alamat github</a> .  Contoh ini menunjukkan bahwa tinju biasa mengubah int menjadi tipe referensi yang diketik.  Ayo pergi <br>  lihat langkah-langkah dalam proses: </p><br><ol><li>  Lakukan tinju untuk integer. </li><li>  Dapatkan alamat objek yang diperoleh (alamat Int32 VMT) </li><li>  Dapatkan VMT dari SimpleIntHolder </li><li>  Ganti VMT integer kotak ke VMT struktur. </li><li>  Buat unboxing menjadi tipe struktur </li><li>  Tampilkan nilai bidang pada layar, dapatkan Int32, itu <br>  kotak. </li></ol><br><p>  Saya melakukannya melalui antarmuka dengan sengaja karena saya ingin menunjukkan bahwa itu akan berhasil <br>  seperti itu. </p><br><h3 id="nullablet">  Tidak dapat dibatalkan \ &lt;T&gt; </h3><br><p>  Perlu disebutkan tentang perilaku tinju dengan tipe nilai Nullable.  Fitur tipe nilai Nullable ini sangat menarik karena tinju tipe nilai yang merupakan jenis null menghasilkan null. </p><br><pre> <code class="plaintext hljs">int? x = 5; int? y = null; var boxedX = (object)x; // -&gt; 5 var boxedY = (object)y; // -&gt; null</code> </pre> <br><p>  Ini membawa kita ke kesimpulan yang aneh: karena null tidak memiliki tipe, the <br>  satu-satunya cara untuk mendapatkan jenis, berbeda dari yang kotak adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">int? x = null; var pseudoBoxed = (object)x; double? y = (double?)pseudoBoxed;</code> </pre> <br><p>  Kode berfungsi hanya karena Anda dapat melemparkan tipe ke apa pun yang Anda suka <br>  dengan nol. </p><br><h2 id="going-deeper-in-boxing">  Pergi lebih dalam di tinju </h2><br><p>  Sebagai bit terakhir, saya ingin memberi tahu Anda tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis System.Enum</a> .  Logikanya ini harus menjadi tipe nilai karena ini adalah penghitungan biasa: aliasing angka ke nama dalam bahasa pemrograman.  Namun, System.Enum adalah tipe referensi.  Semua tipe data enum, didefinisikan di bidang Anda dan juga dalam .NET Framework diwarisi dari System.Enum.  Ini adalah tipe data kelas.  Selain itu, ini adalah kelas abstrak, yang diwarisi dari <code>System.ValueType</code> . </p><br><pre> <code class="plaintext hljs"> [Serializable] [System.Runtime.InteropServices.ComVisible(true)] public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible { // ... }</code> </pre> <br><p>  Apakah itu berarti bahwa semua enumerasi dialokasikan pada SOH dan ketika kami menggunakannya, kami membebani tumpukan dan GC?  Sebenarnya tidak, karena kami hanya menggunakannya.  Kemudian, kami mengira bahwa ada kumpulan enumerasi di suatu tempat dan kami hanya mendapatkan contoh mereka.  Tidak lagi  Anda dapat menggunakan enumerasi dalam struktur saat menyusun.  Enumerasi adalah angka biasa. </p><br><p>  Yang benar adalah bahwa CLR meretas struktur tipe data saat membentuknya jika ada enum <a href="">mengubah kelas menjadi tipe nilai</a> : </p><br><pre> <code class="plaintext hljs">// Check to see if the class is a valuetype; but we don't want to mark System.Enum // as a ValueType. To accomplish this, the check takes advantage of the fact // that System.ValueType and System.Enum are loaded one immediately after the // other in that order, and so if the parent MethodTable is System.ValueType and // the System.Enum MethodTable is unset, then we must be building System.Enum and // so we don't mark it as a ValueType. if(HasParent() &amp;&amp; ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) || GetParentMethodTable() == g_pEnumClass)) { bmtProp-&gt;fIsValueClass = true; HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(), g_CompilerServicesUnsafeValueTypeAttribute, NULL, NULL); IfFailThrow(hr); if (hr == S_OK) { SetUnsafeValueClass(); } }</code> </pre> <br><p>  Kenapa melakukan ini?  Secara khusus, karena gagasan pewarisan - untuk melakukan enum yang disesuaikan, Anda, misalnya, perlu menentukan nama nilai yang mungkin.  Namun, tidak mungkin mewarisi tipe nilai.  Jadi, pengembang mendesainnya menjadi tipe referensi yang dapat mengubahnya menjadi tipe nilai saat dikompilasi. </p><br><h2 id="what-if-you-want-to-see-boxing-personally">  Bagaimana jika Anda ingin melihat tinju secara pribadi? </h2><br><p>  Untungnya, Anda tidak harus menggunakan disassembler dan masuk ke hutan kode.  Kami memiliki teks-teks dari seluruh platform inti .NET dan banyak di antaranya identik dalam hal .NET Framework CLR dan CoreCLR.  Anda dapat mengklik tautan di bawah ini dan langsung melihat penerapan tinju: </p><br><ul><li>  Ada grup terpisah dari optimasi yang masing-masing menggunakan a <br>  jenis prosesor tertentu: <br><ul><li>  <em><a href="">JIT_BoxFastMP_InlineGetThread</a></em> <br>  (AMD64 - multiprosesor atau Server GC, Penyimpanan Lokal Utas implisit) </li><li>  <em><a href="">JIT_BoxFastMP</a></em> <br>  (AMD64 - multiprosesor atau Server GC) </li><li>  <em><a href="">JIT_BoxFastUP</a></em> <br>  (AMD64 - prosesor tunggal atau Workstation GC) </li><li>  <em><a href="">JIT_TrialAlloc :: GenBox (..)</a></em> <br>  (x86) terhubung melalui JitHelpers </li></ul></li><li>  Dalam kasus-kasus umum, JIT menguraikan panggilan fungsi pembantu <br>  <a href="">Compiler :: impImportAndPushBox (..)</a> </li><li>  Versi generik menggunakan kurang dioptimalkan <br>  <a href="">MethodTable :: Box (..)</a> <br><ul><li>  Akhirnya, [CopyValueClassUnchecked (..)] dipanggil <br>  ( <a href="">https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581</a> ). <br>  Kodenya menunjukkan mengapa lebih baik memilih struktur dengan ukuran hingga 8 byte. </li></ul></li></ul><br><p>  Di sini, satu-satunya metode yang digunakan untuk unboxing: <br>  <em><a href="">JIT_Unbox (..)</a></em> , yang merupakan pembungkus di sekitar <em><a href="">JIT_Unbox_Helper (..)</a></em> . </p><br><p>  Juga, menarik bahwa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right</a> ), unboxing tidak berarti menyalin. data ke heap.  Tinju berarti melewati pointer ke heap saat menguji kompatibilitas tipe.  IL opcode yang mengikuti penghapusan kotak akan menentukan tindakan dengan alamat ini.  Data mungkin disalin ke variabel lokal atau tumpukan untuk memanggil metode.  Kalau tidak, kita akan memiliki penyalinan ganda;  pertama kali menyalin dari tumpukan ke suatu tempat, dan kemudian menyalin ke tempat tujuan. </p><br><h2 id="questions">  Pertanyaan </h2><br><h3 id="why-net-clr-cant-do-pooling-for-boxing-itself">  Mengapa .NET CLR tidak dapat melakukan pooling untuk tinju itu sendiri? </h3><br><p>  Jika kami berbicara dengan pengembang Java apa pun, kami akan mengetahui dua hal: </p><br><ul><li>  Semua tipe nilai di Jawa adalah kotak, artinya pada dasarnya bukan tipe nilai.  Bilangan bulat juga kotak. </li><li>  Untuk alasan optimasi, semua bilangan bulat dari -128 ke 127 diambil dari kumpulan objek. </li></ul><br><p>  Jadi, mengapa ini tidak terjadi di. NET CLR selama tinju?  Sederhana saja.  Karena kita dapat mengubah konten dari tipe nilai kotak, yaitu kita dapat melakukan hal berikut: </p><br><pre> <code class="plaintext hljs">object x = 1; x.GetType().GetField("m_value", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138); Console.WriteLine(x); // -&gt; 138</code> </pre> <br><p>  Atau seperti ini (C ++ / CLI): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object^ obj)</span></span></span><span class="hljs-function"> </span></span>{ Int32^ i = (Int32^)obj; *i = <span class="hljs-number"><span class="hljs-number">138</span></span>; }</code> </pre> <br><p>  Jika kita berurusan dengan penyatuan, maka kita akan mengubah semua yang ada dalam aplikasi menjadi 138, yang tidak baik. </p><br><p>  Berikutnya adalah esensi tipe nilai dalam .NET.  Mereka berurusan dengan nilai, yang berarti mereka bekerja lebih cepat.  Boxing jarang terjadi dan penambahan nomor kotak milik dunia fantasi dan arsitektur yang buruk.  Ini sama sekali tidak berguna. </p><br><h3 id="why-it-is-not-possible-to-do-boxing-on-stack-instead-of-the-heap-when-you-call-a-method-that-takes-an-object-type-which-is-a-value-type-in-fact">  Mengapa tidak mungkin melakukan tinju di tumpukan alih-alih tumpukan, ketika Anda memanggil metode yang mengambil tipe objek, yang sebenarnya merupakan tipe nilai? </h3><br><p>  Jika tipe nilai tinju dilakukan pada stack dan referensi akan menuju heap, referensi di dalam metode bisa pergi ke tempat lain, misalnya metode dapat menempatkan referensi di bidang kelas.  Metode kemudian akan berhenti, dan metode yang membuat tinju juga akan berhenti.  Sebagai hasilnya, referensi akan menunjuk ke ruang mati di stack. </p><br><h3 id="why-it-is-not-possible-to-use-value-type-as-a-field">  Mengapa tidak mungkin menggunakan Tipe Nilai sebagai bidang? </h3><br><p>  Terkadang kita ingin menggunakan struktur sebagai bidang struktur lain yang menggunakan struktur pertama.  Atau lebih sederhana: gunakan struktur sebagai bidang struktur.  Jangan tanya kenapa ini bisa bermanfaat.  Tidak bisa.  Jika Anda menggunakan struktur sebagai bidangnya atau melalui ketergantungan dengan struktur lain, Anda membuat rekursi, yang berarti struktur ukuran tak terbatas.  Namun, .NET Framework memiliki beberapa tempat di mana Anda dapat melakukannya.  Contohnya adalah <code>System.Char</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang berisi dirinya sendiri</a> : </p><br><pre> <code class="plaintext hljs">public struct Char : IComparable, IConvertible { // Member Variables internal char m_value; //... }</code> </pre> <br><p>  Semua tipe primitif CLR dirancang dengan cara ini.  Kita, manusia biasa, tidak dapat menerapkan perilaku ini.  Selain itu, kita tidak memerlukan ini: ini dilakukan untuk memberikan tipe primitif semangat OOP di CLR. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Charper ini diterjemahkan dari bahasa Rusia sebagai bahasa pengarang oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami membuat versi terjemahan teks ini ke bahasa lain termasuk Cina atau Jerman menggunakan versi Rusia dan Inggris teks sebagai sumber. <br><br>  Juga, jika Anda ingin mengucapkan "terima kasih", cara terbaik yang dapat Anda pilih adalah memberi kami bintang di github atau repositori forking <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439490/">https://habr.com/ru/post/id439490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439480/index.html">Beri jalan, atau Mengapa CRM Anda (dan CRM) melambat?</a></li>
<li><a href="../id439482/index.html">devleads - (un) motivasi finansial</a></li>
<li><a href="../id439484/index.html">Mendapatkan data enum dalam perspektif Automapper</a></li>
<li><a href="../id439486/index.html">Jenis Referensi .NET vs Jenis Nilai. Bagian 1</a></li>
<li><a href="../id439488/index.html">Rekaman Video Meetup QA</a></li>
<li><a href="../id439492/index.html">10 Tips untuk Menjadi Pemimpin Teknologi yang Baik</a></li>
<li><a href="../id439496/index.html">Cara penagihan dilakukan di sana: ketika pelanggan dan pengembang berbicara bahasa yang berbeda</a></li>
<li><a href="../id439498/index.html">Pada perangkat keras mana untuk menganalisis sejumlah besar informasi?</a></li>
<li><a href="../id439500/index.html">Mengapa captcha menjadi begitu rumit</a></li>
<li><a href="../id439502/index.html">Perilaku dan kebenaran yang tidak terdefinisi tidak didefinisikan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>