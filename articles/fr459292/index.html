<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏼 🛂 👩🏻‍🍳 Automatisation des tests d'applications mobiles: comparaison d'outils 💪🏻 🏴 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'automatisation des tests permet de résoudre plusieurs problèmes à la fois, y compris en ce qui concerne les applications mobiles. Au lieu d'effectue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisation des tests d'applications mobiles: comparaison d'outils</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/459292/">  L'automatisation des tests permet de résoudre plusieurs problèmes à la fois, y compris en ce qui concerne les applications mobiles.  Au lieu d'effectuer manuellement des procédures de routine à forte intensité de main-d'œuvre, les spécialistes peuvent en déléguer une partie importante aux cadres.  L'automatisation simplifie les tests et permet d'accélérer les tests de régression, et permet également d'utiliser des types de tests auparavant inaccessibles. <br><br>  Nous comparerons plusieurs outils qui se sont établis sur le marché et continuent de se développer.  Ces connaissances vous aideront à choisir la solution à utiliser pour tester une application mobile particulière. <br><br><img src="https://habrastorage.org/webt/fh/nx/t-/fhnxt-nrmjzskbyw-vub5mtdgje.png"><a name="habracut"></a><br><br>  Il est peu probable que cet article ouvre de nouveaux horizons pour les professionnels, mais il peut être utile pour les débutants qui ont décidé d'apprendre les bases des tests mobiles et, dans une certaine mesure, les spécialistes de niveau intermédiaire. <br><br><h2>  Classification des outils </h2><br>  La première chose que vous devez construire est la plate-forme sur laquelle l'application s'exécute.  Sur cette base, nous classons la liste des outils comme suit: <br><br>  <b>Android</b> <br><br><ul><li>  Espresso </li><li>  UI Automator </li></ul><br>  <b>iOS</b> <br><br><ul><li>  XCUITest </li><li>  Earlgrey </li></ul><br>  <b>Universel</b> <br><br><ul><li>  Detox </li><li>  Appium </li><li>  Ranorex </li><li>  TestComplete Mobile </li></ul><br><h2>  Automatisation des tests d'applications Android </h2><br><h2>  UI Automator </h2><br>  Outil de test puissant avec intégration externe avancée.  Cela signifie que ce cadre vous permet non seulement de tester l'application elle-même, mais est également capable de «communiquer» avec le système d'exploitation et d'autres applications - par exemple, activer et désactiver le Wi-Fi, le GPS, ouvrir le menu des paramètres pendant le test et effectuer d'autres interactions externes. <br><br>  Le but d'UI Automator est de tester la boîte noire.  Cela signifie que l'analyse est effectuée à partir de la position d'un utilisateur externe sans accès au code. <br><br>  Les fonctionnalités clés incluent: <br><br><ul><li>  UI Automator Viewer pour suivre et analyser les composants affichés à l'écran pendant le test.  Il fournit des informations sur les éléments et leurs propriétés, ce qui facilite la création de tests plus pertinents. </li><li>  API pour obtenir des informations sur l'état de l'appareil et exécuter des processus sur celui-ci. </li><li>  API UI Automator pour les tests multiplateformes. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la documentation</a> . <br><br><h2>  Espresso </h2><br>  Un outil plus léger que UI Automator, non adapté pour interagir avec des applications externes, mais pratique pour tester une boîte blanche avec accès au code source d'une application particulière ou tester une boîte grise, qui a accès à certains processus et structures internes. <br><br>  Cependant, Espresso se démarque avec sa puissante API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/hamcrest</a> .  L'interface ajoute des méthodes pratiques pour les contrôles dans les autotests, par exemple: <br>  assert_that (1, less_or_equal (2)).  Pour tester la vue Web, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> méthodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spéciales</a> sont utilisées. <br><br>  UI Automator et Espresso sont complémentaires et peuvent être utilisés en combinaison dans le même projet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la documentation</a> . <br><br><h2>  Automatisation des tests pour les applications iOS </h2><br><h2>  XCUITest </h2><br>  Un outil pour tester la boîte noire sans accéder au code de l'application.  Cela ne fonctionne qu'avec des produits natifs - malheureusement, les tests inter-applications ne fonctionneront pas. <br><br>  D'un autre côté, la nature native du framework est un avantage du point de vue que lors de l'utilisation de XCUITest, le degré de compréhension mutuelle des développeurs et des testeurs est à un niveau beaucoup plus élevé que dans les cas où l'un et l'autre utilisent des langages différents. <br><br>  Un ajout utile est l'enregistreur de test, qui permet d'écrire des tests en enregistrant des actions dans l'application même pour ceux qui ne travaillent pas avec le code. <br><br>  L'outil vous permet d'éviter les erreurs courantes et les manipulations inutiles, inaccessibles à l'utilisateur, avec le code.  Cependant, XCUITest présente également certains inconvénients. <br><br>  XCUITest, contrairement à Espresso, fonctionne dans un fil séparé, pendant les tests, vous devez attendre l'apparition de certains éléments et paramètres.  L'état actuel de l'application n'est pas lu et les retards dans la mise à jour des données peuvent entraîner l'impossibilité de détecter les éléments demandés. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation XCTest et XCUITest</a> . <br><br><h2>  Earlgrey </h2><br>  EarlGrey met l'accent sur la reproduction de l'expérience utilisateur.  Tant que les éléments à l'écran ne sont pas présentés visuellement, la simulation du travail avec l'application ne démarre pas. <br><br>  Dans le même temps, un certain nombre de commodités et d'avantages sont notés.  Tout d'abord, les experts apprécient la façon dont le framework synchronise les requêtes, les interfaces utilisateur et les threads.  Aucune attente et attente ne sont nécessaires. <br><br>  Deuxièmement, comme déjà mentionné, une attention particulière est accordée au suivi de la visibilité des éléments.  L'outil dispose d'une couche supplémentaire pour vérifier le chargement de l'interface et reproduit les gestes de l'utilisateur - glisser, cliquer - directement au niveau de l'événement d'application. <br><br>  Liens vers le référentiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/google/EarlGrey</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">google.github.io/EarlGrey</a> . <br><br><h2>  Outils universels </h2><br>  Les outils universels (ou «combine») vous permettent de ne pas limiter votre choix uniquement à Android ou iOS, mais de travailler avec les deux plateformes. <br><br>  Ces outils sont applicables pour tester des applications des types suivants: <br><br><ul><li>  Applications natives (applications natives) - écrites directement sous le SDK Android, iOS et Windows. </li><li>  Applications Web mobiles - Disponibles via un navigateur mobile, tel que Safari ou Chrome. </li><li>  Applications hybrides (applications hybrides) - l'utilisateur travaille avec le shell de l'application Web, c'est-à-dire qu'il interagit avec le contenu Web via l'interface de l'application native. </li></ul><br><h2>  Detox </h2><br>  À notre avis, Detox est pratique pour les applications écrites en React Native.  Les tests sont écrits en JavaScript, tandis que les applications iOS et Android sont générées à partir du même code JavaScript et sont aussi similaires que possible.  Cela vous permet d'utiliser les mêmes tests pour les deux plates-formes. <br><br>  Une des principales caractéristiques de Detox est le test en boîte grise.  Dans ce cas, le framework a un certain accès aux mécanismes internes, ce qui vous permet de corréler le comportement externe de l'application avec ce qui se passe à un niveau plus profond. <br><br>  Detox peut accéder à la mémoire et suivre les processus en cours.  Le principe de la boîte grise aide à lutter contre l'instabilité, ce qui se reflète dans le fait que lors des tests de bout en bout: <br><br><ul><li>  Le test peut se bloquer de manière aléatoire même sans modification du code; </li><li>  Les résultats ne sont pas déterministes - en raison du grand nombre de fonctionnalités et de processus hétérogènes au sein de l'application, les résultats de chaque lancement peuvent différer de manière imprévisible les uns des autres. </li><li>  Les testeurs sont obligés de se synchroniser manuellement, ce qui entraîne une diminution de la fiabilité et de la qualité des résultats. </li></ul><br>  Curieusement, la «boîte grise» présente non seulement une meilleure stabilité, mais également une vitesse plus élevée par rapport à la «boîte noire».  En évitant toutes sortes de pauses, attendez jusqu'à ce que la boîte grise soit 5 à 10 fois plus rapide. <br><br>  Detox n'a pas besoin de WebDriver, travaillant avec le pilote natif via JSON.  Il utilise des méthodes natives directement sur l'appareil.  Dans ce cadre, EarlGrey pour iOS et Espresso pour Android sont utilisés. <br><br>  Le cadre fonctionne avec des émulateurs et des périphériques physiques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la documentation</a> . <br><br><h2>  Appium </h2><br>  L'avantage d'Appium est qu'il est possible d'écrire des tests pour chaque plate-forme à l'aide d'une seule API, sans avoir recours à la conversion de l'application sous une forme spéciale compatible avec le framework. <br><br>  Lors des tests, des cadres de fournisseurs sont utilisés, c'est-à-dire que vous travaillez avec l'application d'origine.  Pour Android 4.2+, respectivement, UiAutomator / UiAutomator2 est utilisé, et pour iOS 9.3+ - XCUITest.  WebDriver (alias Selenium WebDriver) est utilisé comme framework de framework. <br><br>  Principes d'Appium: <br><br><ul><li>  Pas besoin de recompiler l'application ou de la modifier pour automatiser les tests. </li><li>  Il n'est pas nécessaire d'être attaché à un seul langage ou cadre. </li><li>  Il n'est pas nécessaire de réinventer la roue en ce qui concerne les API d'automatisation. </li></ul><br>  L'utilisation d'Appium est justifiée lorsque vous avez besoin d'un outil pour automatiser les tests sur plusieurs plateformes à la fois.  Elle est utile si vous avez des spécialistes ayant une expérience dans le test d'applications Web, mais aucune expérience dans l'automatisation des tests d'applications mobiles. <br><br>  En général, il s'agit d'un outil flexible qui peut être modifié pour s'adapter aux besoins du projet sans avoir besoin de s'adapter à un ensemble limité de langages de développement. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la documentation</a> . <br><br><h2>  Ranorex </h2><br>  Outil complet payant pour tester les applications de bureau, mobiles et Web.  Il permet de tester à la fois en utilisant la programmation et sans utiliser de scripts du tout.  Offre la possibilité de tester non seulement via des émulateurs, mais également sur des appareils en direct. <br><br>  L'outil vous permet de créer et de configurer des tests, ainsi que de les gérer de manière centralisée.  Vous pouvez créer un test dans le centre de contrôle et l'exécuter dans divers environnements externes et sur n'importe quel appareil. <br><br>  S'intègre facilement à votre environnement CI existant: avec des systèmes de gestion d'applications tels que Jira et TFS, ainsi que des systèmes de contrôle de version tels que Git et SVN. <br><br>  Ranorex propose des tests basés sur les données avec chargement de données à partir de SQL, CSV et Excel. <br><br>  L'outil convient à absolument n'importe quel appareil, prend en charge les tests parallèles sur chacun d'eux. <br><br>  Il combine les trois approches de test: boîte noire, boîte blanche et boîte grise. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la documentation</a> . <br><br><h2>  Testcomplete </h2><br>  Environnement payant pour tester l'automatisation des applications mobiles, Web et de bureau.  Il prend en charge Android et iOS, et dans le contexte des types d'applications: natives, applications Web et hybrides. <br><br>  Axé principalement sur les tests fonctionnels et unitaires, l'outil offre également la possibilité d'effectuer de nombreux autres types de tests: <br><br><ul><li>  Régression; </li><li>  Tests basés sur les données; </li><li>  Tests distribués et plus encore. </li></ul><br>  Il y a un enregistreur dans TestComplete - des tests y sont créés en enregistrant des actions et en définissant des commandes dans l'éditeur.  Ils peuvent ensuite être lancés directement dans l'outil lui-même ou exportés vers des applications tierces. <br><br>  Cet outil reconnaît les objets et les contrôles en proposant des commandes spéciales pour émuler l'interaction de l'utilisateur avec eux.  S'intègre à Jenkins, Git et Jira, vous permettant d'exécuter des tests continus et continus. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la documentation</a> . <br><br><h2>  Pour résumer </h2><br>  Lorsque vous prévoyez de tester telle ou telle application mobile, faites attention aux outils répertoriés ci-dessus.  Chacun d'eux a ses propres caractéristiques, et parfois des limites. <br><br>  Regardons un exemple.  Si vous êtes confronté à la tâche de tester une petite application en peu de temps, vous devez tout d'abord tenir compte de facteurs tels que le type d'application à tester et l'expérience de vos spécialistes.  Si un développeur écrit des tests, il est préférable de choisir une langue native et un outil pour sa plateforme (voir le tableau ci-dessous).  Si les tests sont effectués par des spécialistes SDET qui connaissent bien d'autres langages (Java, JavaScript, Python, etc.) et qui ont travaillé avec Selenium, il est pratique d'utiliser Appium.  S'il n'y a pas de SDET expérimenté dans l'équipe et que des experts en assurance qualité rédigeront des tests, il est préférable de choisir des frameworks payants, car ils ont des utilitaires pour enregistrer les tests et un support technique plus stable que les frameworks open source. <br><br>  <i>De notre pratique:</i> <i><br></i>  <i>Nous avons travaillé avec une boutique en ligne, qui avait deux applications mobiles - sur iOS et Android.</i>  <i>Pour tester les principaux scénarios utilisateurs avec des tests, nous avons choisi Appium pour plusieurs raisons:</i> <i><br><br></i> <ul><li>  <i>multi-plateforme, la possibilité de réutiliser partiellement le code</i> </li><li>  <i>adapté aux tests de bout en bout, peut fonctionner avec le web</i> </li><li>  <i>la présence dans l'équipe de spécialistes qui connaissent bien le sélénium, qui sert d'enveloppe à ce cadre.</i> </li></ul> <i><br></i>  <i>En conséquence, Appium a pleinement répondu aux attentes, nous avons mené avec succès des tests pour iOS et Android.</i>  <i>Il convient de garder à l'esprit que de tels tests de bout en bout avec Appium ne sont pas effectués sur chaque demande de fusion, car cela prend beaucoup de temps.</i> <br><br>  En conclusion, nous portons à votre attention un tableau qui vous aidera à choisir l'outil pour votre projet.  Il convient de noter que dans certains cas, la division dans le tableau est conditionnelle.  Quelque part par souci de simplicité, une généralisation est faite et seuls les paramètres les plus élémentaires sont donnés.  Les outils de test évoluent constamment, donc lors du choix d'un framework, il est important de vérifier la documentation actuelle. <br><br><img src="https://habrastorage.org/webt/fi/m1/7t/fim17tgj4mzjsf1mea_mswscy7i.jpeg"><br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459292/">https://habr.com/ru/post/fr459292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459276/index.html">Epic fail resistance 2 ou pourquoi vous ne devriez pas vous impliquer dans la confidentialité avec les plugins FireFox</a></li>
<li><a href="../fr459280/index.html">Pourquoi les développeurs aiment-ils créer une application native?</a></li>
<li><a href="../fr459284/index.html">Brève introduction à la stratégie produit et à la hiérarchisation des fonctionnalités</a></li>
<li><a href="../fr459286/index.html">Tellurure de tungstène semi-métallique - le couteau suisse de la journée des nanotechnologies</a></li>
<li><a href="../fr459288/index.html">Implémentation native de la bibliothèque ECS</a></li>
<li><a href="../fr459294/index.html">Quoi de plus important: connaître un langage de programmation ou être capable de résoudre un problème métier?</a></li>
<li><a href="../fr459296/index.html">Prix ​​JavaScript 2019</a></li>
<li><a href="../fr459298/index.html">Angulaire: statut en 2019</a></li>
<li><a href="../fr459300/index.html">Quasar 1.0: un nouvel outil utile pour les développeurs de Vue et pas seulement pour eux</a></li>
<li><a href="../fr459302/index.html">Nouvelle tentative de requêtes HTTP ayant échoué dans Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>