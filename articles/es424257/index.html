<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÅ üë©üèæ‚Äç‚öïÔ∏è üçÖ Mapas de hex√°gono en Unity: partes 1-3 üåì üñïüèΩ üìì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De un traductor: este art√≠culo es el primero de una serie detallada (27 partes) de tutoriales sobre la creaci√≥n de mapas a partir de hex√°gonos. Esto e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas de hex√°gono en Unity: partes 1-3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424257/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg" alt="imagen"></div><br>  <i>De un traductor: este art√≠culo es el primero de una serie detallada (27 partes) de tutoriales sobre la creaci√≥n de mapas a partir de hex√°gonos.</i>  <i>Esto es lo que deber√≠a suceder al final de los tutoriales.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, r√≠os y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geogr√°ficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigaci√≥n de mapas, generaci√≥n de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 1: mallado de hex√°gonos </h1><br><h2>  Tabla de contenidos </h2><br><ul><li>  Convierte cuadrados en hex√°gonos. </li><li>  Triangular una cuadr√≠cula de hex√°gonos. </li><li>  Trabajamos con coordenadas c√∫bicas. </li><li>  Interactuamos con celdas de cuadr√≠cula. </li><li>  Crea un editor en el juego. </li></ul><br>  Este tutorial es el comienzo de una serie sobre tarjetas hexagonales.  Las redes hexagonales se usan en muchos juegos, especialmente en estrategias, como Age of Wonders 3, Civilization 5 y Endless Legend.  Comenzaremos con lo b√°sico, agregaremos gradualmente nuevas caracter√≠sticas y, como resultado, crearemos un relieve complejo basado en hex√°gonos. <br><a name="habracut"></a><br>  Este tutorial asume que ya has estudiado la serie <i>Mesh Basics</i> , que comienza con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuadr√≠cula de procedimientos</a> .  Fue creado en Unity 5.3.1.  La serie usa varias versiones de Unity.  La √∫ltima parte se realiza en Unity 2017.3.0p3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54e/065/633/54e065633ba41c99214f720278b68336.png"></div><br>  <i>Un mapa simple de hex√°gonos.</i> <br><br><h2>  Sobre hex√°gonos </h2><br>  ¬øPor qu√© se necesitan hex√°gonos?  Si necesitamos una cuadr√≠cula, entonces es l√≥gico usar cuadrados.  Los cuadrados son realmente f√°ciles de dibujar y colocar, pero tambi√©n tienen un inconveniente.  Mire un solo cuadrado de la cuadr√≠cula y luego a sus vecinos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/d4f/9b8/48fd4f9b87d5aa2381d9b03dbae704ae.png"></div><br>  <i>La plaza y sus vecinos.</i> <br><br>  En total, la plaza tiene ocho vecinos.  Cuatro de ellos se pueden lograr cruzando el borde del cuadrado.  Estos son vecinos horizontales y verticales.  Los otros cuatro se pueden lograr cruzando la esquina de la plaza.  Estos son vecinos diagonales. <br><br>  ¬øCu√°l es la distancia entre los centros de las celdas cuadradas adyacentes?  Si la longitud del borde es 1, entonces para vecinos horizontales y verticales la respuesta es 1. Pero para vecinos diagonales la respuesta es ‚àö2. <br><br>  La diferencia entre los dos tipos de vecinos conduce a dificultades.  Si usamos movimiento discreto, ¬øc√≥mo percibir el movimiento a lo largo de la diagonal?  ¬øDeber√≠a permitirlo?  ¬øC√≥mo hacer que la apariencia sea m√°s org√°nica?  Los diferentes juegos utilizan diferentes enfoques con sus ventajas y desventajas.  Un enfoque no es utilizar una cuadr√≠cula cuadrada, sino utilizar hex√°gonos en su lugar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/47a/9a1/77247a9a1784bdbe1b736672460b95bf.png"></div><br>  <i>Hexagon y sus vecinos.</i> <br><br>  A diferencia de un cuadrado, un hex√°gono no tiene ocho, sino seis vecinos.  Todos estos vecinos son adyacentes a los bordes, no hay vecinos de esquina.  Es decir, solo hay un tipo de vecinos, lo que simplifica mucho.  Por supuesto, una cuadr√≠cula de hex√°gonos es m√°s dif√≠cil de construir que un cuadrado, pero podemos manejarlo. <br><br>  Antes de comenzar, necesitamos determinar el tama√±o de los hex√°gonos.  Deje que la longitud del borde sea igual a 10 unidades.  Como el hex√°gono consiste en un c√≠rculo de seis tri√°ngulos equil√°teros, la distancia desde el centro a cualquier √°ngulo tambi√©n es 10. Este valor determina el radio exterior de la celda hexagonal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdb/a2f/82f/cdba2f82fb30358f0d2ca31c95f133d5.png"></div><br>  <i>El radio exterior e interior del hex√°gono.</i> <br><br>  Tambi√©n hay un radio interno, que es la distancia desde el centro a cada uno de los bordes.  Este par√°metro es importante porque la distancia entre los centros de los vecinos es igual a este valor multiplicado por dos.  El radio interno es <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;">s </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;">q </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;">r </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;">t </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;">3</font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"> 2</font></span></span></font><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mtext" id="MJXp-Span-8">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;"></font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.098ex" height="2.419ex" viewBox="0 -780.1 5209 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-74" x="1631" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-33" x="1993" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-32" x="4708" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> \ frac {\ sqrt {3}} {2} </script>  desde el radio exterior, es decir, en nuestro caso <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mn" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;">q </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;">3</font></span></span></font><span class="MJXp-mtext" id="MJXp-Span-19">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.954ex" height="2.298ex" viewBox="0 -728.2 2994 989.6" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-35" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-73" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-71" x="1220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="1680" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-74" x="2132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-33" x="2493" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 5 \ sqrt {3} </script>  .  Pongamos estos par√°metros en una clase est√°tica por conveniencia. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMetrics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo derivar el valor del radio interno?</b> <div class="spoiler_text">  Toma uno de los seis tri√°ngulos de un hex√°gono.  El radio interno es igual a la altura de este tri√°ngulo.  Esta altura se puede obtener dividiendo el tri√°ngulo en dos tri√°ngulos regulares y luego usando el teorema de Pit√°goras. <br><br>  Por lo tanto, para la longitud de la costilla <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.083ex" height="1.523ex" viewBox="0 -535.3 466.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-65" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> e </script>  radio interior es <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mtext" id="MJXp-Span-29">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">t</span><span class="MJXp-mrow" id="MJXp-Span-34"><span class="MJXp-msubsup" id="MJXp-Span-35"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-37" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">e</span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-43">2</span><span class="MJXp-msubsup" id="MJXp-Span-44"><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-46" style="vertical-align: 0.5em;">2</span></span></span><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-48">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">t</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mn" id="MJXp-Span-54">3</span><span class="MJXp-msubsup" id="MJXp-Span-55"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-57" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-58"><span class="MJXp-mo" id="MJXp-Span-59" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-60">4</span></span><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">e</span><span class="MJXp-mtext" id="MJXp-Span-63">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">t</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-mn" id="MJXp-Span-69">3</span></span><span class="MJXp-mrow" id="MJXp-Span-70"><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-72">2</span><span class="MJXp-mtext" id="MJXp-Span-73">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">x</span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mn" id="MJXp-Span-80">0.886</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="55.43ex" height="3.037ex" viewBox="0 -950 23865.4 1307.5" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-74" x="1631" y="0"></use><g transform="translate(1993,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-32" x="659" y="513"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-2212" x="1142" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-28" x="2143" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-65" x="2532" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-2F" x="2999" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-32" x="3499" y="0"></use><g transform="translate(4000,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-32" x="550" y="513"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-3D" x="7114" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-73" x="8420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-71" x="8890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="9350" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-74" x="9802" y="0"></use><g transform="translate(10163,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-32" x="659" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-2F" x="1420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-34" x="1921" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-3D" x="12863" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-65" x="13919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-73" x="14636" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-71" x="15105" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="15566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-74" x="16017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-33" x="16379" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-2F" x="16879" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-32" x="17380" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-61" x="18130" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-70" x="18660" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-72" x="19163" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-6F" x="19615" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-78" x="20100" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-2E" x="20673" y="0"></use><g transform="translate(21118,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-38" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-38" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMAIN-36" x="1780" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-65" x="23398" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> \ sqrt {e ^ 2 - (e / 2) ^ 2} = \ sqrt {3e ^ 2/4} = e \ sqrt {3} / 2 \ aprox. 0.886e </script>  . </div></div><br>  Si ya estamos haciendo esto, entonces determinemos las posiciones de las seis esquinas en relaci√≥n con el centro de la celda.  Cabe se√±alar que hay dos formas de orientar el hex√°gono: hacia arriba con un lado afilado o plano.  Pondremos la esquina.  Comencemos desde este √°ngulo y agreguemos el resto en el sentido de las agujas del reloj.  Col√≥quelos en el plano XZ para que los hex√°gonos est√©n en el suelo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b2/0eb/95a/5b20eb95ac844ed93a117b7d37f90e11.png"></div><br>  <i>Posibles orientaciones.</i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius) };</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete de la unidad</a> <br><br><h2>  Malla </h2><br>  Para construir una cuadr√≠cula de hex√°gonos, necesitamos celdas de cuadr√≠cula.  Para este prop√≥sito, cree el componente <code>HexCell</code> .  Por ahora, d√©jelo en blanco porque todav√≠a no estamos usando ninguna celda dada. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br>  Para comenzar con el m√°s simple, cree un objeto plano predeterminado, agregue un componente de celda y convi√©rtalo en un prefabricado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/f1f/3ab/b61f1f3ab3210349434c2aff8c9ac374.png"></div><br>  <i>Usando un plano como prefabricado de una celda hexagonal.</i> <br><br>  Ahora entremos a la red.  Creemos un componente simple con variables comunes de ancho de celda, altura y prefabricado.  Luego agrega un objeto de juego con este componente a la escena. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell cellPrefab; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/749/12e/cad74912e6a951918b4a3d0f4b9bb6bb.png"></div><br>  <i>Objeto de malla hexagonal.</i> <br><br>  Comencemos creando una cuadr√≠cula regular de cuadrados, porque ya sabemos c√≥mo hacerlo.  Guardemos las celdas en una matriz para poder acceder a ellas. <br><br>  Dado que los planos tienen por defecto un tama√±o de 10 por 10 unidades, desplazaremos cada celda por esta cantidad. <br><br><pre> <code class="cs hljs"> HexCell[] cells; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[height * width]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; height; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { CreateCell(x, z, i++); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = x * <span class="hljs-number"><span class="hljs-number">10f</span></span>; position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * <span class="hljs-number"><span class="hljs-number">10f</span></span>; HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/560/321/d11560321e63ac581846776aa5b658b6.png"></div><br>  <i>Cuadr√≠cula cuadrada de planos.</i> <br><br>  Entonces obtuvimos una hermosa cuadr√≠cula s√≥lida de celdas cuadradas.  ¬øPero qu√© celda es d√≥nde?  Por supuesto, esto es f√°cil de verificar, pero existen dificultades con los hex√°gonos.  Ser√≠a conveniente si pudi√©ramos ver simult√°neamente las coordenadas de todas las celdas. <br><br><h3>  Pantalla coordinada </h3><br>  Agregue lienzo a la escena seleccionando <i>GameObject / UI / Canvas</i> y <i>convi√©rtalo</i> en un elemento secundario de nuestro objeto de malla.  Dado que este lienzo es solo para informaci√≥n, eliminaremos su componente raycaster.  Tambi√©n puede eliminar el objeto del sistema de eventos, que se agreg√≥ autom√°ticamente a la escena, porque por ahora no lo necesitamos. <br><br>  Establezca el <i>Modo de renderizado</i> en <i>World Space</i> y g√≠relo 90 grados a lo largo del eje X para que el lienzo se superponga a la cuadr√≠cula.  Ajuste el pivote y la posici√≥n a cero.  Dele un ligero desplazamiento vertical para que su contenido est√© en la parte superior.  El ancho y la altura no son importantes para nosotros, porque organizamos los contenidos por nuestra cuenta.  Podemos establecer el valor en 0 para eliminar el rect√°ngulo grande en la ventana de la escena. <br><br>  Como toque final, aumente los <i>p√≠xeles din√°micos por unidad</i> a 10. Por lo tanto, garantizamos que los objetos de texto usar√°n una resoluci√≥n de textura suficiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/d5e/34e/d37d5e34e417e5d703d2915ef2e6ad19.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/c37/273/374c37273c1e8e61befc30543efca5b2.png"></div><br>  <i>Lienzo para coordenadas de cuadr√≠cula de hex√°gonos.</i> <br><br>  Para mostrar las coordenadas, cree un objeto de texto ( <i>GameObject / UI / Text</i> ) y <i>convi√©rtalo</i> en un prefabricado.  Centre sus anclajes y pivote, establezca el tama√±o en 5 por 15. El texto tambi√©n debe estar alineado horizontal y verticalmente en el centro.  Establezca el tama√±o de fuente en 4. Finalmente, no queremos usar el texto predeterminado y no usaremos <i>Texto enriquecido</i> .  Adem√°s, no nos importa si <i>Raycast Target</i> est√° activado, porque para nuestro lienzo todav√≠a no es necesario. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/c09/d55/f15c09d55444941d69d563940806340f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6d/0df/ab2/d6d0dfab20e21276e48a2ca5bdc36503.png"></div><br>  <i>Etiqueta de celda prefabricada.</i> <br><br>  Ahora tenemos que decirle a la cuadr√≠cula sobre lienzo y prefabricados.  Agregue al comienzo de su script <code>using UnityEngine.UI;</code>  para acceder c√≥modamente al tipo <code>UnityEngine.UI.Text</code> .  Una etiqueta prefabricada necesita una variable compartida, y el lienzo se puede encontrar llamando a <code>GetComponentInChildren</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text cellLabelPrefab; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fae/b30/599/faeb3059923e68e4b072a5b401086072.png"></div><br>  <i>Conexi√≥n de etiquetas prefabricadas.</i> <br><br>  Despu√©s de conectar la etiqueta prefabricada, podemos crear instancias y mostrar las coordenadas de la celda.  Entre X y Z, inserte un car√°cter de nueva l√≠nea para que aparezcan en l√≠neas separadas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = x.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e8/1e2/9b0/0e81e29b0fd80afb2f7056a5b8ed829d.png"></div><br>  <i>Visualizaci√≥n coordinada.</i> <br><br><h3>  Posiciones Hexagonales </h3><br>  Ahora que podemos reconocer visualmente cada celda, comencemos a moverlas.  Sabemos que la distancia entre las celdas hexagonales adyacentes en la direcci√≥n X es igual al doble del radio interno.  Lo usaremos  Adem√°s, la distancia a la siguiente fila de celdas debe ser 1,5 veces mayor que el radio exterior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/269/f40/6e4269f40ead27d2ddb0dd75a1154d99.png"></div><br>  <i>Geometr√≠a de hex√°gonos vecinos.</i> <br><br><pre> <code class="cs hljs"> position.x = x * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ca/d03/034/5cad03034d4aacacf5ccd49dccf0af3a.png"></div><br>  <i>Aplicamos distancias entre hex√°gonos sin compensaciones.</i> <br><br>  Por supuesto, las filas ordinales de los hex√°gonos no se encuentran exactamente una encima de la otra.  Cada fila est√° desplazada a lo largo del eje X por el valor del radio interno.  Este valor se puede obtener agregando la mitad de Z a X, y luego multiplicar por dos veces el radio interno. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/e06/f65/75ce06f65db02737bddf223d45f6b8f3.png"></div><br>  <i>La colocaci√≥n adecuada de los hex√°gonos crea una cuadr√≠cula en forma de diamante.</i> <br><br>  Aunque as√≠ es como colocamos las celdas en las posiciones correctas de los hex√°gonos, nuestra cuadr√≠cula ahora llena el rombo en lugar del rect√°ngulo.  Estamos mucho m√°s c√≥modos trabajando con cuadr√≠culas rectangulares, as√≠ que hagamos que las celdas vuelvan a funcionar.  Esto se puede hacer moviendo hacia atr√°s parte del desplazamiento.  En cada segunda fila, todas las celdas deben desplazarse un paso adicional.  Para hacer esto, necesitamos restar el resultado de la divisi√≥n entera de Z por 2 antes de multiplicar. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/429/30a/51942930aa48daab518847429e4c8b74.png"></div><br>  <i>La ubicaci√≥n de los hex√°gonos en un √°rea rectangular.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Render Hexagonal </h2><br>  Habiendo colocado las celdas correctamente, podemos proceder a mostrar los hex√°gonos reales.  Primero necesitamos deshacernos de los planos, por lo que eliminaremos todos los componentes, excepto <code>HexCell</code> de la celda <code>HexCell</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/32a/214/48f32a214e6ef61f580a0147a5f310da.png"></div><br>  <i>No hay m√°s aviones.</i> <br><br>  Al igual que en los tutoriales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mesh Basics</a> , utilizamos una malla para representar la malla completa.  Sin embargo, esta vez no preestableceremos el n√∫mero de v√©rtices y tri√°ngulos requeridos.  En cambio, usaremos listas. <br><br>  Cree un nuevo componente <code>HexMesh</code> que cuide nuestra malla.  Necesitar√° un filtro de malla y un procesador, tiene una malla y listas para v√©rtices y tri√°ngulos. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMesh</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Mesh hexMesh; List&lt;Vector3&gt; vertices; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } }</code> </pre> <br>  Cree un nuevo objeto hijo para esta malla con este componente.  Recibir√° autom√°ticamente un renderizador de malla, pero no se le asignar√° ning√∫n material.  Por lo tanto, agregue el material predeterminado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/831/2ab/f2a8312ab61274a7563aeeb7860c3609.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/bf1/710/8abbf17103e93485e696daf3a94bb277.png"></div><br>  <i>Objeto de malla hexagonal.</i> <br><br>  <code>HexGrid</code> ahora podr√° recuperar su malla hexagonal de la misma manera que encontr√≥ el lienzo. <br><br><pre> <code class="cs hljs"> HexMesh hexMesh; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ }</code> </pre> <br>  Despu√©s de la malla despierta, debe ordenar que la malla triangule sus celdas.  Necesitamos estar seguros de que esto suceder√° despu√©s del componente Despierto de la malla hexagonal.  Como se llama a <code>Start</code> m√°s tarde, inserte el c√≥digo apropiado all√≠. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br>  Se puede llamar a este m√©todo <code>HexMesh.Triangulate</code> en cualquier momento, incluso si las celdas ya se han triangulado anteriormente.  Por lo tanto, debemos comenzar limpiando los datos antiguos.  Al recorrer todas las celdas, las triangulamos individualmente.  Despu√©s de completar esta operaci√≥n, asignamos los v√©rtices y tri√°ngulos generados a la malla, y terminamos recalculando las normales de la malla. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); triangles.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } hexMesh.vertices = vertices.ToArray(); hexMesh.triangles = triangles.ToArray(); hexMesh.RecalculateNormals(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Como los hex√°gonos est√°n compuestos de tri√°ngulos, creemos un m√©todo conveniente para agregar un tri√°ngulo basado en las posiciones de tres v√©rtices.  Solo agregar√° v√©rtices en orden.  Tambi√©n agrega los √≠ndices de estos v√©rtices para formar un tri√°ngulo.  El √≠ndice del primer v√©rtice es igual a la longitud de la lista de v√©rtices antes de agregarle nuevos v√©rtices.  No te olvides de esto cuando agregues v√©rtices. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Ahora podemos triangular nuestras c√©lulas.  Comencemos con el primer tri√°ngulo.  Su primer pico est√° en el centro del hex√°gono.  Los otros dos v√©rtices son los √°ngulos primero y segundo relativos al centro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">0</span></span>], center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/d2b/ca3/860d2bca3ec0d1c95bd66082735021f7.png"></div><br>  <i>El primer tri√°ngulo de cada celda.</i> <br><br>  Esto funcion√≥, as√≠ que recorramos los seis tri√°ngulos. <br><br><pre> <code class="cs hljs"> Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øSe pueden compartir los picos?</b> <div class="spoiler_text">  Si puedes.  De hecho, podemos hacerlo a√∫n mejor y usar solo cuatro en lugar de seis tri√°ngulos para renderizar.  Pero al abandonar esto, simplificaremos nuestro trabajo, y ser√° correcto, porque en los siguientes tutoriales todo se vuelve m√°s complicado.  Optimizar v√©rtices y tri√°ngulos en esta etapa nos obstaculizar√° en el futuro. </div></div><br>  Desafortunadamente, este proceso dar√° como resultado una <code>IndexOutOfRangeException</code> .  Esto se debe a que el √∫ltimo tri√°ngulo est√° tratando de obtener la s√©ptima esquina, que no existe.  Por supuesto, debe regresar y usarlo como el √∫ltimo v√©rtice de la primera esquina.  O podemos duplicar la primera esquina en <code>HexMetrics.corners</code> para no ir m√°s all√° de los l√≠mites. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8d/277/e13/c8d277e139df24953e9b381fabca2a42.png"></div><br>  <i>Hex√°gonos por completo.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Coordenadas hexagonales </h2><br>  Veamos nuevamente las coordenadas de las celdas, ahora en el contexto de una cuadr√≠cula de hex√°gonos.  La coordenada Z se ve bien, y la coordenada X zigzaguea.  Este es un efecto secundario del desplazamiento de l√≠nea para cubrir un √°rea rectangular. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/745/502/73f745502f1d8d20245bd22edc99a3ce.png"></div><br>  <i>Coordenadas desplazadas con l√≠neas cero resaltadas.</i> <br><br>  Cuando se trabaja con hex√°gonos, tales coordenadas de desplazamiento no son f√°ciles de manejar.  <code>HexCoordinates</code> una estructura <code>HexCoordinates</code> , que se puede usar para convertir a otro sistema de coordenadas.  Hag√°moslo serializable para que Unity pueda almacenarlo y experimente la recompilaci√≥n en el modo Play.  Tambi√©n hacemos que estas coordenadas sean inmutables utilizando las propiedades p√∫blicas de solo lectura. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { X = x; Z = z; } }</code> </pre> <br>  Agregue un m√©todo est√°tico para crear un conjunto de coordenadas a partir de coordenadas de desplazamiento ordinarias.  Por ahora, simplemente copiaremos estas coordenadas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z); } }</code> </pre> <br>  Tambi√©n agregamos m√©todos convenientes de conversi√≥n de cadenas.  El m√©todo <code>ToString</code> por defecto devuelve un nombre de tipo struct, que no es muy √∫til para nosotros.  Lo redefinimos para que devuelva las coordenadas en una l√≠nea.  Tambi√©n agregaremos un m√©todo para mostrar coordenadas en l√≠neas separadas, porque ya usamos dicho esquema. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br>  Ahora podemos pasar muchas coordenadas a nuestro componente <code>HexCell</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; }</code> </pre> <br>  Cambie <code>HexGrid.CreateCell</code> para que pueda usar las nuevas coordenadas. <br><br><pre> <code class="cs hljs"> HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines();</code> </pre> <br>  Ahora vamos a rehacer estas coordenadas X para que est√©n alineadas a lo largo de un eje recto.  Esto se puede hacer cancelando el desplazamiento horizontal.  El resultado resultante generalmente se llama coordenadas axiales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x - z / <span class="hljs-number"><span class="hljs-number">2</span></span>, z); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/1bf/29d/4331bf29dbf016e466a3636b5cd90311.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ab/03d/7af/4ab03d7afdef480fe4657ae86901fd1a.png"></div><br>  <i>Coordenadas axiales</i> <br><br>  Este sistema de coordenadas bidimensional nos permite describir secuencialmente el movimiento de desplazamiento en cuatro direcciones.  Sin embargo, las dos direcciones restantes a√∫n requieren atenci√≥n especial.  Esto nos hace darnos cuenta de que hay una tercera dimensi√≥n.  Y, de hecho, si volte√°ramos horizontalmente la dimensi√≥n de X, obtendr√≠amos la dimensi√≥n faltante de Y. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32c/39b/9b7/32c39b9b7705099d7bcb8e525aa6fe48.png"></div><br>  <i>Aparece la medida Y.</i> <br><br>  Dado que estas medidas de X e Y son copias especulares entre s√≠, la adici√≥n de sus coordenadas siempre da el mismo resultado si Z permanece constante.  De hecho, si suma las tres coordenadas, siempre obtendremos cero.  Si aumenta una coordenada, debe reducir la otra.  Y, de hecho, esto nos da seis posibles direcciones de movimiento.  Tales coordenadas generalmente se llaman c√∫bicas, porque son tridimensionales y la topolog√≠a se asemeja a un cubo. <br><br>  Como la suma de todas las coordenadas es cero, siempre podemos obtener cualquiera de las coordenadas de las otras dos.  Como ya almacenamos las coordenadas X y Z, no necesitamos almacenar la coordenada Y. <br>  Podemos agregar una propiedad que la eval√∫a si es necesario y usarla en m√©todos de cadena. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -X - Z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c36/ad9/d32/c36ad9d322193e811fd6c59b5d76249a.png"></div><br>  <i>Coordenadas c√∫bicas</i> <br><br><h3>  Inspector Coordina </h3><br>  En el modo de reproducci√≥n, seleccione una de las celdas de la cuadr√≠cula.  Resulta que el inspector no muestra sus coordenadas, solo se <code>HexCell.coordinates</code> etiqueta de prefijo <code>HexCell.coordinates</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/a1d/a0e/d02a1da0e906223abcb9aeeb46ce7477.png"></div><br>  <i>El inspector no muestra las coordenadas.</i> <br><br>  Aunque no hay un gran problema con esto, ser√≠a genial mostrar las coordenadas.  Unity no muestra coordenadas porque no est√°n marcadas como campos serializables.  Para mostrarlos, debe especificar expl√≠citamente campos serializables para X y Z. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, z; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ea/264/fff/5ea264fffa724e10205c41c8191ad78b.png"></div><br>  Las coordenadas X y Z ahora se muestran, pero se pueden cambiar.  No necesitamos esto, porque las coordenadas deben ser fijas.  Tampoco es muy bueno que se muestren uno debajo del otro. <br><br>  Podemos hacerlo mejor: definir nuestro propio caj√≥n de propiedades para el tipo <code>HexCoordinates</code> .  Cree un script <code>HexCoordinatesDrawer</code> y p√©guelo en la carpeta <i>Editor</i> , porque este script es solo para el editor. <br><br>  La clase debe extender <code>UnityEditor.PropertyDrawer</code> y necesita el atributo <code>UnityEditor.CustomPropertyDrawer</code> para asociarlo con un tipo adecuado. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(HexCoordinates))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCoordinatesDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { }</code> </pre> <br>  Los cajones de propiedades muestran su contenido utilizando el m√©todo <code>OnGUI</code> .  Este m√©todo permiti√≥ dibujar datos de propiedad serializables y la etiqueta del campo al que pertenecen dentro del rect√°ngulo de la pantalla. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Extraemos los valores de x y z de la propiedad, y luego los usamos para crear un nuevo conjunto de coordenadas.  Luego dibuje la etiqueta GUI en la posici√≥n seleccionada utilizando nuestro m√©todo <code>HexCoordinates.ToString</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates( property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"x"</span></span>).intValue, property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"z"</span></span>).intValue ); GUI.Label(position, coordinates.ToString()); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d6/d0f/852/1d6d0f852f744b6b5080a54478a3f4bf.png"></div><br>  <i>Coordenadas sin una etiqueta de prefijo.</i> <br><br>  Esto mostrar√° las coordenadas, pero ahora nos falta el nombre del campo.  Estos nombres generalmente se representan utilizando el m√©todo <code>EditorGUI.PrefixLabel</code> .  Como beneficio adicional, devuelve un rect√°ngulo alineado que coincide con el espacio a la derecha de esta etiqueta. <br><br><pre> <code class="cs hljs"> position = EditorGUI.PrefixLabel(position, label); GUI.Label(position, coordinates.ToString());</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6c/d34/856/a6cd348569c891e063c6fc515d075d04.png"></div><br>  <i>Coordina con una etiqueta.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  C√©lulas t√°ctiles </h2><br>  Una cuadr√≠cula de hex√°gonos no es muy interesante si no podemos interactuar con ella.  La interacci√≥n m√°s simple es tocar la celda, as√≠ que agreguemos soporte para ella.  Por ahora, simplemente <code>HexGrid</code> este c√≥digo directamente en <code>HexGrid</code> .  Cuando comience a funcionar, lo trasladaremos a otro lugar. <br><br>  Para tocar una celda, puede emitir rayos en la escena desde la posici√≥n del cursor del mouse.  Podemos usar el mismo enfoque que en el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deformaci√≥n de malla</a> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { TouchCell(hit.point); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + position); }</code> </pre> <br>  Hasta ahora, el c√≥digo no est√° haciendo nada.  Necesitamos agregar un colisionador a la cuadr√≠cula para que el rayo pueda colisionar con algo.  Por lo tanto, le daremos la malla del colisionador <code>HexMesh</code> . <br><br><pre> <code class="cs hljs"> MeshCollider meshCollider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); ‚Ä¶ }</code> </pre> <br>  Una vez completada la triangulaci√≥n, asigne una malla al colisionador. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øNo podemos usar el colisionador de cajas?</b> <div class="spoiler_text">  Podemos, pero no coincidir√° exactamente con el contorno de nuestra cuadr√≠cula.  S√≠, y nuestra cuadr√≠cula no permanecer√° plana por mucho tiempo, pero este es un tema para futuros tutoriales. </div></div><br>  ¬°Ahora podemos tocar la cuadr√≠cula!  ¬øPero qu√© celda tocamos?  Para averiguarlo, necesitamos convertir la posici√≥n t√°ctil a las coordenadas de los hex√°gonos.  Esto es un trabajo para <code>HexCoordinates</code> , por lo que declararemos que tiene un m√©todo est√°tico <code>FromPosition</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + coordinates.ToString()); }</code> </pre> <br>  ¬øC√≥mo determinar√° este m√©todo qu√© coordenada pertenece a la posici√≥n?  Podemos comenzar dividiendo x por el ancho horizontal del hex√°gono.  Y dado que la coordenada Y es una imagen especular de la coordenada X, una x negativa nos da y. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -x; }</code> </pre> <br>  Por supuesto, esto nos dar√≠a las coordenadas correctas si Z fuera cero.  Debemos movernos nuevamente cuando nos movemos a lo largo de Z. Cada dos l√≠neas, debemos mover hacia la izquierda una unidad. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = position.z / (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">3f</span></span>); x -= offset; y -= offset;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, nuestros valores x e y resultan ser enteros en el centro de cada celda. </font><font style="vertical-align: inherit;">Por lo tanto, redonde√°ndolos al entero m√°s cercano, debemos obtener las coordenadas. </font><font style="vertical-align: inherit;">Tambi√©n calculamos Z y as√≠ obtenemos las coordenadas finales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iX = Mathf.RoundToInt(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iY = Mathf.RoundToInt(y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iZ = Mathf.RoundToInt(-x -y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los resultados parecen prometedores, pero ¬øson correctas estas coordenadas? </font><font style="vertical-align: inherit;">Con un estudio cuidadoso, puede encontrar que a veces obtenemos las coordenadas, ¬°cuya suma no es igual a cero! </font><font style="vertical-align: inherit;">Activemos la notificaci√≥n para asegurarnos de que esto realmente est√© sucediendo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"rounding error!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En realidad recibimos notificaciones. </font><font style="vertical-align: inherit;">¬øC√≥mo solucionamos este error? </font><font style="vertical-align: inherit;">Surge solo al lado de los bordes entre los hex√°gonos. </font><font style="vertical-align: inherit;">Es decir, el redondeo de coordenadas causa problemas. </font><font style="vertical-align: inherit;">¬øQu√© coordenada se redondea en la direcci√≥n incorrecta? </font><font style="vertical-align: inherit;">Cuanto m√°s nos alejamos del centro de la celda, m√°s redondeo obtenemos. </font><font style="vertical-align: inherit;">Por lo tanto, es l√≥gico suponer que la coordenada redondeada sobre todo es incorrecta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, la soluci√≥n es soltar la coordenada con el delta de redondeo m√°s grande y recrearla a partir de los valores de los otros dos. </font><font style="vertical-align: inherit;">Pero como solo necesitamos X y Z, no podemos molestarnos en recrear Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dX = Mathf.Abs(x - iX); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dY = Mathf.Abs(y - iY); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dZ = Mathf.Abs(-x -y - iZ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt; dY &amp;&amp; dX &gt; dZ) { iX = -iY - iZ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dZ &gt; dY) { iZ = -iX - iY; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> P√°gina para colorear de hex√°gonos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que podemos tocar la celda correcta, ha llegado el momento de una interacci√≥n real. </font><font style="vertical-align: inherit;">Cambiemos el color de cada celda en la que nos metemos. </font><font style="vertical-align: inherit;">Agregue los </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colores personalizados de la celda predeterminada y la celda afectada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color defaultColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color touchedColor = Color.magenta;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/89a/d05/33d89ad0522ace10075800607aac71b2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecci√≥n de color de celda. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar al </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de color general.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignarlo </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al color predeterminado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n necesitamos agregar a </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la informaci√≥n de color.</font></font><br><br><pre> <code class="cs hljs"> List&lt;Color&gt; colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); ‚Ä¶ hexMesh.vertices = vertices.ToArray(); hexMesh.colors = colors.ToArray(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, al triangular, debemos agregar datos de color a cada tri√°ngulo. </font><font style="vertical-align: inherit;">Para este prop√≥sito crearemos un m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De vuelta a </font></font><code>HexGrid.TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, convierta las coordenadas de la celda al √≠ndice correspondiente de la matriz. </font><font style="vertical-align: inherit;">Para una cuadr√≠cula cuadrada, esto ser√≠a solo X m√°s Z veces el ancho, pero en nuestro caso, tambi√©n tendremos que agregar un desplazamiento de la mitad Z. Luego tomamos la celda, cambiamos su color y triangulamos la malla nuevamente.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øRealmente necesitamos volver a triangular toda la malla?</font></font></b> <div class="spoiler_text">    ,       .       .    ,    ,     .       . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = touchedColor; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque ahora podemos colorear las celdas, los cambios visuales a√∫n no son visibles. </font><font style="vertical-align: inherit;">Esto se debe a que el sombreador no usa colores de v√©rtice de manera predeterminada. </font><font style="vertical-align: inherit;">Tenemos que escribir el nuestro. </font><font style="vertical-align: inherit;">Cree un nuevo sombreador predeterminado ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activos / Crear / Sombreador / Sombreador de superficie predeterminado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Solo se necesitan hacer dos cambios. </font><font style="vertical-align: inherit;">Primero, agregue datos de color a su estructura de entrada. </font><font style="vertical-align: inherit;">En segundo lugar, multiplique el albedo por este color. </font><font style="vertical-align: inherit;">Solo nos interesan los canales RGB, porque el material es opaco.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/VertexColors" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un nuevo material con este sombreador y luego haga que la malla de malla use este material. </font><font style="vertical-align: inherit;">Gracias a esto, aparecer√°n los colores de las celdas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/efe/be1/223efebe1bdda83c9b383dac32197c6e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√©lulas de colores.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Obtengo extra√±os artefactos de sombra!</font></font></b> <div class="spoiler_text">    Unity        .          ,   ,   Z-.            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editor de mapas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que sabemos c√≥mo cambiar los colores, creemos un editor simple en el juego. </font><font style="vertical-align: inherit;">Esta funcionalidad no se aplica a las capacidades </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que la convertiremos </font></font><code>TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un m√©todo general con un par√°metro de color adicional. </font><font style="vertical-align: inherit;">Tambi√©n elimine el campo </font></font><code>touchedColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Color color</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = color; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un componente </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y mueva los m√©todos </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">a </font><font style="vertical-align: inherit;">√©l </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agregue un campo com√∫n para referirse a la cuadr√≠cula de hex√°gonos, una matriz de colores y un campo privado para rastrear el color activo. </font><font style="vertical-align: inherit;">Finalmente, agregue un m√©todo general para seleccionar un color y haga que inicialmente seleccione el primer color.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color activeColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SelectColor(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { hexGrid.ColorCell(hit.point, activeColor); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeColor = colors[index]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue otro lienzo, esta vez manteniendo la configuraci√≥n predeterminada. </font><font style="vertical-align: inherit;">Agregue un componente </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, defina varios colores y con√©ctelo a una cuadr√≠cula de hex√°gonos. </font><font style="vertical-align: inherit;">Esta vez necesitamos un objeto de sistema de eventos, y se cre√≥ autom√°ticamente de nuevo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/0d6/be4/d180d6be4c656688f4ec6c4f5789bdba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de mapas hexagonales de cuatro colores. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un panel al lienzo para almacenar selectores de color ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Panel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Agregue su grupo de alternar ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componentes / UI / Grupo de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alternar </font><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Haga el panel peque√±o y col√≥quelo en la esquina de la pantalla.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/b05/4db/63fb054dbb5c64fce6c4671283df6e6a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panel de color con grupo de alternar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora llene el panel con interruptores para cada color ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Toggle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Mientras no nos molestemos en crear una IU compleja, basta con una configuraci√≥n manual simple.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/40e/ffc/eef40effcb9510ba924186b766a1fee0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/0e4/595/d580e45954552b134082a9379af2eb8c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un interruptor para cada color. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encienda el primer interruptor. </font><font style="vertical-align: inherit;">Adem√°s, haga que todos los interruptores formen parte del grupo de alternancia para que solo se pueda seleccionar uno de ellos a la vez. </font><font style="vertical-align: inherit;">Finalmente, con√©ctelos al m√©todo de </font></font><code>SelectColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuestro editor. </font><font style="vertical-align: inherit;">Esto se puede hacer usando el bot√≥n "+" UI del evento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Seleccione el objeto del editor de mapas, luego seleccione el m√©todo deseado de la lista desplegable.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/e05/0af/7b4e050afca862a244607248834676aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer cambio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este evento pasa un argumento booleano que determina si el interruptor se enciende cada vez que se cambia. </font><font style="vertical-align: inherit;">Pero no nos importa. </font><font style="vertical-align: inherit;">En su lugar, tendremos que pasar manualmente un argumento entero correspondiente al √≠ndice de color que queremos usar. </font><font style="vertical-align: inherit;">Por lo tanto, deje el valor 0 para el primer interruptor, establezca el valor 1 en el segundo, y as√≠ sucesivamente.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°ndo se llama al m√©todo de evento de cambio?</font></font></b> <div class="spoiler_text">       .      ,    ,   . <br><br>      ,         ,    .  ,  <code>SelectColor</code>   .  ,      . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/0bb/8f4/35a0bb8f4425b0c821836f9aa9afda16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colorear en varios colores. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la interfaz de usuario funciona, hay un detalle molesto. </font><font style="vertical-align: inherit;">Para verlo, mueva el panel de modo que cubra la cuadr√≠cula de hex√°gonos. </font><font style="vertical-align: inherit;">Al elegir un nuevo color, tambi√©n colorearemos las celdas debajo de la interfaz de usuario. </font><font style="vertical-align: inherit;">Es decir, estamos interactuando simult√°neamente con la interfaz de usuario y con la cuadr√≠cula. </font><font style="vertical-align: inherit;">Este es un comportamiento indeseable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se puede solucionar preguntando al sistema de eventos si determin√≥ la ubicaci√≥n del cursor sobre alg√∫n objeto. </font><font style="vertical-align: inherit;">Como solo conoce los objetos de la interfaz de usuario, esto nos dir√° que estamos interactuando con la interfaz de usuario. </font><font style="vertical-align: inherit;">Por lo tanto, necesitaremos procesar la entrada nosotros mismos solo si esto no sucede.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 2: mezclar colores de celda </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tabla de contenidos </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conecta a los vecinos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolar los colores entre los tri√°ngulos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear √°reas de fusi√≥n. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifica la geometr√≠a. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte anterior, sentamos las bases de la cuadr√≠cula y agregamos la capacidad de editar celdas. </font><font style="vertical-align: inherit;">Cada celda tiene su propio color s√≥lido y los colores en los bordes de las celdas cambian dram√°ticamente. </font><font style="vertical-align: inherit;">En este tutorial, crearemos zonas de transici√≥n que mezclan los colores de las celdas vecinas.</font></font><br><cut></cut><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/518/132/8ca518132084099a6159027d4a345710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transiciones suaves entre las c√©lulas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√©lulas vecinas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de realizar el suavizado entre los colores de las celdas, necesitamos descubrir cu√°les de las celdas est√°n adyacentes entre s√≠. </font><font style="vertical-align: inherit;">Cada celda tiene seis vecinos que pueden identificarse en las direcciones de los puntos cardinales. </font><font style="vertical-align: inherit;">Obtendremos las siguientes direcciones: noreste, este, sureste, suroeste, oeste y noroeste. </font><font style="vertical-align: inherit;">Vamos a crear una enumeraci√≥n para ellos y pegarla en un archivo de script separado.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es la enumeraci√≥n?</font></font></b> <div class="spoiler_text"> <code>enum</code>     ,     .            .      ,      .  ,        . <br><br>  enum     .   ,     integer  .   ,    -  ,    integer. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/e0e/37f/181e0e37fdd59ab37214cc909409351c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seis vecinos, seis direcciones. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para almacenar estos vecinos, agregue a la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz. </font><font style="vertical-align: inherit;">Aunque podemos hacerlo general, en cambio lo haremos privado y brindaremos acceso a los m√©todos usando instrucciones. </font><font style="vertical-align: inherit;">Tambi√©n lo hacemos serializable para que los enlaces no se pierdan al volver a compilar.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] HexCell[] neighbors;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNecesitamos almacenar todas las conexiones con los vecinos?</font></font></b> <div class="spoiler_text">       ,       .     ‚Äî    ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora la matriz de vecinos se muestra en el inspector. </font><font style="vertical-align: inherit;">Como cada celda tiene seis vecinos, para nuestro prefabricado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> establecemos el tama√±o de la matriz 6.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/8c1/a2e/6ef8c1a2ee9478b007faefcef2516934.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay espacio para seis vecinos en nuestra casa prefabricada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora agreguemos un m√©todo general para obtener una celda vecina en una direcci√≥n. </font><font style="vertical-align: inherit;">Dado que el valor de la direcci√≥n siempre est√° en el rango de 0 a 5, no necesitamos verificar si el √≠ndice est√° dentro de la matriz.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue un m√©todo para especificar un vecino. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las relaciones de vecinos son bidireccionales. </font><font style="vertical-align: inherit;">Por lo tanto, cuando se establece un vecino en una direcci√≥n, ser√≠a l√≥gico establecer inmediatamente un vecino en la direcci√≥n opuesta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; cell.neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction.Opposite()] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b86/616/15c/b8661615ceece04f7f4c16fa1c032be4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vecinos en direcciones opuestas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esto sugiere que podemos solicitar indicaciones para el vecino opuesto. </font><font style="vertical-align: inherit;">Podemos implementar esto creando un m√©todo de extensi√≥n para </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para obtener la direcci√≥n opuesta, debe agregar al original 3. Sin embargo, esto solo funciona para las tres primeras direcciones, para el resto debe restar 3.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexDirectionExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Opposite</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> ? (direction + <span class="hljs-number"><span class="hljs-number">3</span></span>) : (direction - <span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es un m√©todo de extensi√≥n?</font></font></b> <div class="spoiler_text">   ‚Äî      ,       - .       ‚Äî , , ,    .         <code>this</code> .      ,     . <br><br>        ? ,  ,       ,      .    ?    ‚Äî .  ,      ,        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conexi√≥n vecina </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos inicializar el enlace de vecinos en </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al atravesar celdas l√≠nea por l√≠nea, de izquierda a derecha, sabemos qu√© celdas ya se han creado. </font><font style="vertical-align: inherit;">Estas son las c√©lulas con las que podemos conectarnos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√°s simple es el compuesto E - W. </font><font style="vertical-align: inherit;">La primera celda de cada fila no tiene un vecino oriental. </font><font style="vertical-align: inherit;">Pero todas las otras c√©lulas lo tienen. </font><font style="vertical-align: inherit;">Y estos vecinos se crean antes de la celda con la que estamos trabajando actualmente. </font><font style="vertical-align: inherit;">Por lo tanto, podemos conectarlos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/3bf/16f/7873bf16fdecde4ff216cc30b206ce89.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conexi√≥n de E a W durante la creaci√≥n de c√©lulas.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.color = defaultColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/560/08e/8b6/56008e8b6b2c16f3da710a2cedebb7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los vecinos orientales y occidentales est√°n conectados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos crear dos conexiones bidireccionales m√°s. </font><font style="vertical-align: inherit;">Dado que estas son las conexiones entre diferentes l√≠neas de la cuadr√≠cula, solo podemos comunicarnos con la l√≠nea anterior. </font><font style="vertical-align: inherit;">Esto significa que debemos omitir por completo la primera l√≠nea.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como las l√≠neas son en zigzag, deben procesarse de manera diferente. </font><font style="vertical-align: inherit;">Primero tratemos con l√≠neas pares. </font><font style="vertical-align: inherit;">Dado que todas las celdas en tales filas tienen un vecino en SE, podemos conectarlas a √©l.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/e56/419/7d5e56419ed4a0fb7b2c506061543561.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexi√≥n de NO a SE para l√≠neas uniformes.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hace z &amp; 1?</font></font></b> <div class="spoiler_text"> <code>&amp;&amp;</code> ‚Äî    ,  <code>&amp;</code> ‚Äî    .     ,         .      1,      1. , <code>10101010 &amp; 00001111</code>  <code>00001010</code> . <br><br>     .    0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,         0. <br><br>      ,  ,    .    0,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos conectarnos con vecinos en el SW, excepto por la primera celda de cada fila que no lo tiene. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed1/f7a/73c/ed1f7a73c9e09970a041e4596668626b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexi√≥n de NE a SW para l√≠neas uniformes.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las l√≠neas impares siguen la misma l√≥gica, pero en una imagen especular. </font><font style="vertical-align: inherit;">Despu√©s de completar este proceso, todos los vecinos de nuestra red est√°n conectados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; width - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/eee/ff1/00beeeff163b36232bd37f6076c34c90.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los vecinos est√°n conectados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, no todas las celdas est√°n conectadas a exactamente seis vecinos. </font><font style="vertical-align: inherit;">Las celdas en el l√≠mite de la cuadr√≠cula tienen al menos dos y no m√°s de cinco vecinos. </font><font style="vertical-align: inherit;">Y esto debe tenerse en cuenta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/4a9/1c5/e7a4a91c55e7cc2574eed105f7b9a110.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vecinos para cada celda. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mezcla de colores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mezcla de colores complicar√° la triangulaci√≥n de cada celda. </font><font style="vertical-align: inherit;">Por lo tanto, separemos el c√≥digo de triangulaci√≥n en una parte separada. </font><font style="vertical-align: inherit;">Como ahora tenemos direcciones, us√©moslas en lugar de √≠ndices num√©ricos para indicar partes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction], center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora, cuando usamos direcciones, ser√≠a conveniente obtener √°ngulos con direcciones, y no realizar la conversi√≥n a √≠ndices. </font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, debe agregar </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos m√©todos est√°ticos. </font><font style="vertical-align: inherit;">Como beneficio adicional, esto nos permite hacer que la matriz de √°ngulos sea privada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varios colores en un triangulo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, el m√©todo </font></font><code>HexMesh.AddTriangleColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo tiene un argumento de color. </font><font style="vertical-align: inherit;">Solo puede crear un tri√°ngulo con color s√≥lido. </font><font style="vertical-align: inherit;">Creemos una alternativa que admita colores separados para cada v√©rtice.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora podemos comenzar a mezclar colores! </font><font style="vertical-align: inherit;">Comencemos simplemente usando el color vecino para los otros dos v√©rtices.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) ); HexCell neighbor = cell.GetNeighbor(direction); AddTriangleColor(cell.color, neighbor.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, esto lleva a </font></font><code>NullReferenceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque las celdas en la frontera no tienen seis vecinos. </font><font style="vertical-align: inherit;">¬øQu√© debemos hacer cuando hay escasez de un vecino? </font><font style="vertical-align: inherit;">Seamos pragm√°ticos y usemos la c√©lula como reemplazo.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hace el operador?</font></font></b> <div class="spoiler_text">    null-coalescing operator.   ,  <code>a ?? b</code> ‚Äî      <code>a != null ? a : b</code> . <br><br>   ,     -   Unity   .           <code>null</code> .        . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/558/667/3755586675e7126b25e776f1283ec8b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay una mezcla de colores, pero se hace incorrectamente.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øA d√≥nde fueron las etiquetas de coordenadas?</font></font></b> <div class="spoiler_text">   ,       UI. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promedio de color </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mezcla de colores funciona, pero los resultados son obviamente incorrectos. </font><font style="vertical-align: inherit;">El color en los bordes de los hex√°gonos debe ser el promedio de dos celdas adyacentes.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Color edgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddTriangleColor(cell.color, edgeColor, edgeColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/079/b26/aff079b261e39c1959d004c0ddf3a58f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezclando en las costillas. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque estamos mezclando en los bordes, todav√≠a obtenemos bordes de color n√≠tidos. </font><font style="vertical-align: inherit;">Esto sucede porque cada v√©rtice del hex√°gono es compartido por tres hex√°gonos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/8f2/507/19e8f2507f011213c1514ea20ce04906.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres vecinos, cuatro colores. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto significa que tambi√©n debemos considerar a los vecinos en las instrucciones anteriores y siguientes. </font><font style="vertical-align: inherit;">Es decir, obtenemos cuatro colores en dos conjuntos de tres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos </font></font><code>HexDirectionExtensions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos m√©todos de adici√≥n para una transici√≥n conveniente a las instrucciones anteriores y siguientes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NE ? HexDirection.NW : (direction - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NW ? HexDirection.NE : (direction + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos obtener los tres vecinos y realizar mezclas de tres v√≠as. </font></font><br><br><pre> <code class="cs hljs"> HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/b19/778/430b197786bb2bde51fb528946561733.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezclar en las esquinas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces obtenemos las transiciones de color correctas, con la excepci√≥n del borde de malla. </font><font style="vertical-align: inherit;">Las celdas del borde no son consistentes con los colores de los vecinos que faltan, por lo que aqu√≠ todav√≠a vemos bordes afilados. </font><font style="vertical-align: inherit;">Sin embargo, en general, nuestro enfoque actual no da buenos resultados. </font><font style="vertical-align: inherit;">Necesitamos una mejor estrategia. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Åreas de mezcla </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezclar sobre toda la superficie del hex√°gono conduce a un caos borroso. </font><font style="vertical-align: inherit;">No podemos ver claramente las c√©lulas individuales. </font><font style="vertical-align: inherit;">Los resultados pueden mejorarse enormemente al mezclar solo al lado de los bordes de los hex√°gonos. </font><font style="vertical-align: inherit;">En este caso, la regi√≥n interna de los hex√°gonos retendr√° un color s√≥lido.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/82a/ff6/53e82aff62f060a51ef5645accd45d03.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombreado continuo de centavos con √°reas de mezcla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°l deber√≠a ser el tama√±o de la regi√≥n s√≥lida en comparaci√≥n con la regi√≥n de mezcla? </font><font style="vertical-align: inherit;">Diferentes distribuciones conducen a resultados diferentes. </font><font style="vertical-align: inherit;">Definiremos esta √°rea como una fracci√≥n del radio exterior. </font><font style="vertical-align: inherit;">Que sea igual al 75%. </font><font style="vertical-align: inherit;">Esto nos llevar√° a dos nuevas m√©tricas, que suman 100%.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - solidFactor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al crear este nuevo factor de relleno s√≥lido, podemos escribir m√©todos para obtener los √°ngulos de hex√°gonos internos s√≥lidos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * solidFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * solidFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, c√°mbielo </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que use estos √°ngulos de sombreado s√≥lidos en lugar de los √°ngulos originales. </font><font style="vertical-align: inherit;">Dejamos los colores iguales por ahora.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d40/eb5/326/d40eb5326b0e0457e55ae2752897efc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex√°gonos s√≥lidos sin bordes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n de √°reas de mezcla. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos completar el espacio vac√≠o que creamos reduciendo los tri√°ngulos. </font><font style="vertical-align: inherit;">En cada direcci√≥n, este espacio tiene la forma de un trapecio. </font><font style="vertical-align: inherit;">Para cubrirlo, puede usar el cuadr√°ngulo (quad). </font><font style="vertical-align: inherit;">Por lo tanto, crearemos m√©todos para agregar un cuadr√°ngulo y sus colores.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/bc9/ce5/c2fbc9ce504e0e8df61b194f20c83f3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costilla trapezoidal.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3, Color c4</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); colors.Add(c4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo rehacemos </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que el tri√°ngulo reciba un color, y el cuadr√°ngulo realiza una mezcla entre un color s√≥lido y los colores de dos √°ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); Vector3 v3 = center + HexMetrics.GetFirstCorner(direction); Vector3 v4 = center + HexMetrics.GetSecondCorner(direction); AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor( cell.color, cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aea/8de/d01/aea8ded01fc8928ec64293b11b335a91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezcla con costillas trapezoidales.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puentes entre costillas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La imagen est√° mejorando, pero el trabajo a√∫n no est√° terminado. </font><font style="vertical-align: inherit;">La mezcla de colores entre dos vecinos est√° contaminada por c√©lulas vecinas. </font><font style="vertical-align: inherit;">Para evitar esto, necesitamos cortar las esquinas del trapecio y convertirlo en un rect√°ngulo. </font><font style="vertical-align: inherit;">Despu√©s de eso, crear√° un puente entre la celda y su vecino, dejando espacios a los lados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/acf/602/b76acf602ad32b7001117a17c0e6c72f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El puente entre las costillas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos encontrar nuevas posiciones </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comenzando con </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego avanzando a lo largo del puente hasta el borde de la celda. </font><font style="vertical-align: inherit;">¬øCu√°l ser√° el desplazamiento del puente? </font><font style="vertical-align: inherit;">Podemos encontrarlo tomando el punto medio entre los dos √°ngulos correspondientes y luego aplicando el coeficiente de mezcla. </font><font style="vertical-align: inherit;">Esto se dedica </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * blendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volviendo a </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ahora ser√° l√≥gico agregar una opci√≥n </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que requiera solo dos colores.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c1); colors.Add(c2); colors.Add(c2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°mbielo </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que cree puentes correctamente mezclados entre vecinos.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor(cell.color, (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/0bd/fb3/2880bdfb3ae5b97a5907164fc8b71774.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puentes pintados correctamente con espacios en las esquinas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llenando los huecos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hemos formado un espacio triangular en la uni√≥n de tres celdas. </font><font style="vertical-align: inherit;">Obtuvimos estas brechas cortando los lados triangulares del trapecio. </font><font style="vertical-align: inherit;">Recuperemos estos tri√°ngulos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, considere un tri√°ngulo que se conecta a un vecino anterior. </font><font style="vertical-align: inherit;">Su primer v√©rtice tiene un color de celda. </font><font style="vertical-align: inherit;">El color del segundo pico ser√° una mezcla de tres colores. </font><font style="vertical-align: inherit;">Y el √∫ltimo pico tendr√° el mismo color que el punto en el medio del puente.</font></font><br><br><pre> <code class="cs hljs"> Color bridgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddQuadColor(cell.color, bridgeColor); AddTriangle(v1, center + HexMetrics.GetFirstCorner(direction), v3); AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, bridgeColor );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/d75/a50/b7fd75a50368ba2bcb79595fa1c58329.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi todo est√° listo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro tri√°ngulo funciona de la misma manera, excepto que el puente no toca el tercero, sino el segundo pico.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, center + HexMetrics.GetSecondCorner(direction)); AddTriangleColor( cell.color, bridgeColor, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/7b2/d71/9a57b2d71d5db4aa2c22a2aba954babe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloraci√≥n completa </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos hermosas √°reas de mezcla que podemos dar a cualquier tama√±o. </font><font style="vertical-align: inherit;">Los bordes se pueden hacer borrosos o n√≠tidos a su gusto. </font><font style="vertical-align: inherit;">Pero puede ver que la combinaci√≥n cerca del borde de malla todav√≠a no se implementa correctamente. </font><font style="vertical-align: inherit;">Y nuevamente lo dejaremos para m√°s tarde, enfoc√°ndonos en otro tema por ahora.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero las transiciones entre colores siguen siendo feas.</font></font></b> <div class="spoiler_text">     .            .            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costilla Fusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eche un vistazo a la topolog√≠a de nuestra cuadr√≠cula. </font><font style="vertical-align: inherit;">¬øQu√© formas son notables aqu√≠? </font><font style="vertical-align: inherit;">Si no presta atenci√≥n a la frontera, podemos distinguir tres tipos diferentes de formas. </font><font style="vertical-align: inherit;">Hay hex√°gonos de un color, rect√°ngulos de dos colores y tri√°ngulos de tres colores. </font><font style="vertical-align: inherit;">Todos estos tres colores aparecen en la uni√≥n de las tres celdas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a27/370/ae7/a27370ae7474595516c3186adb393590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres estructuras visuales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, cada dos hex√°gonos est√°n conectados por un puente rectangular. </font><font style="vertical-align: inherit;">Y cada tres hex√°gonos est√°n conectados por un tri√°ngulo. </font><font style="vertical-align: inherit;">Sin embargo, realizamos una triangulaci√≥n m√°s compleja. </font><font style="vertical-align: inherit;">Ahora usamos dos cuadr√°ngulos en lugar de uno para conectar un par de hex√°gonos. </font><font style="vertical-align: inherit;">Y para conectar los tres hex√°gonos, usamos seis tri√°ngulos. </font><font style="vertical-align: inherit;">Esto es demasiado redundante. </font><font style="vertical-align: inherit;">Adem√°s, si tuvi√©ramos que conectarnos directamente a una forma, entonces no necesitar√≠amos promediar ning√∫n color. </font><font style="vertical-align: inherit;">Por lo tanto, podr√≠amos sobrevivir con menos complejidad, menos trabajo y menos tri√°ngulos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/448/ef3/e5d448ef31208fd42f3e7e73138c3b48.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s duro de lo necesario.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© necesitamos esto?</font></font></b> <div class="spoiler_text"> ,        .   ,     ,   .   ,        ,     .       ,   ,   . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puente directo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora nuestros puentes entre las costillas consisten en dos cuadr√°ngulos. Para extenderlos al siguiente hex√°gono, necesitamos duplicar la longitud del puente. Esto significa que ya no necesitamos promediar dos √°ngulos </font></font><code>HexMetrics.GetBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En cambio, simplemente los agregamos y luego multiplicamos por el factor de mezcla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * blendFactor; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/8d6/33f/f168d633fff07b5ecd6bf361e14e0edd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los puentes atravesaban toda la longitud y se superpon√≠an entre s√≠. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los puentes ahora crean conexiones directas entre hex√°gonos. </font><font style="vertical-align: inherit;">Pero a√∫n generamos dos cuadr√°ngulos por conexi√≥n, uno en cada direcci√≥n. </font><font style="vertical-align: inherit;">Es decir, solo uno de ellos deber√≠a crear puentes entre dos celdas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifiquemos primero nuestro c√≥digo de triangulaci√≥n. </font><font style="vertical-align: inherit;">Eliminaremos todo lo relacionado con los tri√°ngulos de los bordes y la mezcla de colores. </font><font style="vertical-align: inherit;">Luego mueva el c√≥digo que agrega el cuadr√°ngulo del puente al nuevo m√©todo. </font><font style="vertical-align: inherit;">Pasamos los dos primeros v√©rtices a este m√©todo para que no tengamos que volver a calcularlos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); TriangulateConnection(direction, cell, v1, v2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos limitar f√°cilmente la triangulaci√≥n de compuestos. </font><font style="vertical-align: inherit;">Para comenzar, agregaremos el puente solo cuando trabajemos con la conexi√≥n NE.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == HexDirection.NE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/7ac/53f/cfa7ac53f3fbab322c4c481f29ec1cac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los puentes son solo en direcci√≥n a NE. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que podemos cubrir todos los compuestos triangul√°ndolos solo en las tres primeras direcciones: NE, E y SE.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/568/698/e07/568698e079839a5ff4108083c6f71d8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los puentes internos y puentes en las fronteras. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cubrimos todas las conexiones entre dos celdas vecinas. </font><font style="vertical-align: inherit;">Pero tambi√©n tenemos algunos puentes que conducen desde la celda a ninguna parte. </font><font style="vertical-align: inherit;">Vamos a deshacernos de ellos, salir </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando los vecinos est√©n fuera. </font><font style="vertical-align: inherit;">Es decir, ya no necesitamos reemplazar a los vecinos desaparecidos con la celda misma.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/54c/21d/5a254c21d71cf66817a1ee42b7f02ddd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo puentes internos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Articulaciones triangulares </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos cerrar los huecos triangulares nuevamente. </font><font style="vertical-align: inherit;">Hagamos esto para un tri√°ngulo que se conecta al pr√≥ximo vecino. </font><font style="vertical-align: inherit;">Y esto nuevamente debe hacerse solo cuando existe un vecino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°l ser√° la posici√≥n del tercer pico? </font><font style="vertical-align: inherit;">Insert√© como reemplazo </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero esto obviamente es incorrecto. </font><font style="vertical-align: inherit;">Como cada borde de estos tri√°ngulos est√° conectado al puente, podemos encontrarlo caminando a lo largo del puente hasta el pr√≥ximo vecino.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/256/bde/b5c256bde3a05d41287ca96007e208f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos haciendo triangulaci√≥n completa de nuevo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hemos terminado? </font><font style="vertical-align: inherit;">Todav√≠a no, porque ahora estamos creando tri√°ngulos superpuestos. </font><font style="vertical-align: inherit;">Dado que las tres celdas tienen una conexi√≥n triangular com√∫n, necesitamos agregarlas solo para dos conexiones. </font><font style="vertical-align: inherit;">Por lo tanto, NE y E. lo har√°n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next())); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 3: alturas </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tabla de contenidos </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar celdas de altura. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangular las pendientes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inserte las repisas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combina repisas y acantilados. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En esta parte del tutorial, agregaremos soporte para diferentes niveles de altura y crearemos transiciones especiales entre ellos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/24a/e1f/8da24ae1f70e4770264ed0ab05d183ef.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alturas y repisas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altura de la celda </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dividimos nuestro mapa en celdas separadas que cubren un √°rea plana. </font><font style="vertical-align: inherit;">Ahora le daremos a cada celda su propio nivel de altura. </font><font style="vertical-align: inherit;">Utilizaremos niveles de elevaci√≥n discretos para almacenarlos como un campo entero en </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tan grande puede ser cada nivel posterior de altura? </font><font style="vertical-align: inherit;">Podemos usar cualquier valor, as√≠ que configur√©moslo como otra constante </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usaremos un paso de cinco unidades para que las transiciones sean claramente visibles. </font><font style="vertical-align: inherit;">En un juego real, usar√≠a un paso m√°s peque√±o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar celdas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, solo pod√≠amos cambiar el color de la celda, pero ahora podemos cambiar su altura. </font><font style="vertical-align: inherit;">Por lo tanto, el m√©todo </font></font><code>HexGrid.ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no es suficiente </font><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">nosotros. </font><font style="vertical-align: inherit;">Adem√°s, en el futuro, podemos agregar otras opciones de edici√≥n de celdas, por lo que necesitamos un nuevo enfoque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar el nombre </font></font><code>ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y hacer de modo que en su lugar devolver√° celular color de referencia de una celda en una posici√≥n predeterminada. </font><font style="vertical-align: inherit;">Dado que este m√©todo no cambia nada m√°s, necesitamos triangular inmediatamente las celdas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[index]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el editor se ocupar√° del cambio de celda. </font><font style="vertical-align: inherit;">Despu√©s de completar el trabajo, la cuadr√≠cula necesita ser triangulada nuevamente. </font><font style="vertical-align: inherit;">Para hacer esto, agregue un m√©todo general </font></font><code>HexGrid.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que pueda trabajar con nuevos m√©todos. </font><font style="vertical-align: inherit;">Vamos a darle un nuevo m√©todo </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se ocupar√° de todos los cambios en la celda, despu√©s de lo cual actualizar√° la cuadr√≠cula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCell(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos cambiar las alturas simplemente asignando a la celda deseada el nivel de altura deseado. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con los colores, necesitamos un m√©todo para establecer el nivel de altura activo, que asociaremos con la interfaz de usuario. </font><font style="vertical-align: inherit;">Para seleccionar valores del intervalo de altura, utilizamos el control deslizante. </font><font style="vertical-align: inherit;">Dado que los controles deslizantes funcionan con flotante, nuestro m√©todo requiere un par√°metro de tipo flotante. </font><font style="vertical-align: inherit;">Simplemente lo convertiremos a entero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation</span></span></span><span class="hljs-function">)</span></span> { activeElevation = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)elevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un control deslizante ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / Create / Slider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">al lienzo </font><font style="vertical-align: inherit;">y col√≥quelo debajo de la barra de colores. </font><font style="vertical-align: inherit;">Lo hacemos vertical, de abajo hacia arriba, para que visualmente corresponda a los niveles de altura. </font><font style="vertical-align: inherit;">Lo limitamos a enteros y creamos un intervalo adecuado, por ejemplo, de 0 a 6. Luego adjuntamos su evento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al m√©todo del </font></font><code>SetElevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El m√©todo debe seleccionarse de la lista din√°mica para que se llame con el valor del control deslizante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05f/6c5/93c/05f6c593cc553c4f4a86f9c2e9012156.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/0a5/e8b/7c60a5e8bfebd2ec87d2daaeeb148be6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de altura.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizaci√≥n de la altura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al cambiar una celda, ahora establecemos tanto el color como la altura. </font><font style="vertical-align: inherit;">Aunque en el inspector podemos ver que la altura realmente cambia, el proceso de triangulaci√≥n a√∫n la ignora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es suficiente para nosotros cambiar la posici√≥n local vertical de la celda al cambiar la altura. </font><font style="vertical-align: inherit;">Por conveniencia, hagamos que el m√©todo sea </font></font><code>HexCell.elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privado y agreguemos una propiedad general </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos cambiar la posici√≥n vertical de la celda al editar la altura. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esto requiere peque√±os cambios en </font></font><code>HexMapEditor.EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/5de/6eb/6525de6ebae59208507af3e8b744bab5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√©lulas con diferentes alturas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEl colisionador de malla cambia para adaptarse a la nueva altura?</font></font></b> <div class="spoiler_text">    Unity          mesh collider  null.  ,    ,      null    .   .     (     )  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las alturas de las celdas ahora son visibles, pero hay dos problemas. </font><font style="vertical-align: inherit;">Primero de todo </font><font style="vertical-align: inherit;">Las etiquetas de las celdas desaparecen debajo de las celdas elevadas. </font><font style="vertical-align: inherit;">En segundo lugar, las conexiones entre celdas ignoran la altura. </font><font style="vertical-align: inherit;">Vamos a arreglarlo</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar la posici√≥n de las etiquetas de celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualmente, las etiquetas de IU para las celdas se crean y colocan solo una vez, despu√©s de lo cual nos olvidamos de ellas. </font><font style="vertical-align: inherit;">Para actualizar sus posiciones verticales, necesitamos rastrearlos. </font><font style="vertical-align: inherit;">D√©mosle a todos un </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace a </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sus etiquetas de IU para que pueda actualizarlo m√°s tarde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform uiRect;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignarlos al final </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.uiRect = label.rectTransform; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos expandir la propiedad </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que tambi√©n cambie la posici√≥n de la interfaz de usuario de la celda. </font><font style="vertical-align: inherit;">Dado que el lienzo de la cuadr√≠cula hexagonal se gira, las etiquetas deben moverse en la direcci√≥n negativa a lo largo del eje Z y no en el lado positivo del eje Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = elevation * -HexMetrics.elevationStep; uiRect.localPosition = uiPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/b81/c97/c72b81c970b2bddfe2b2ce6d22471dc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etiquetas con altura.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creaci√≥n de pistas. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos convertir las conexiones de celda plana en pendientes. </font><font style="vertical-align: inherit;">Esto se hace en </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En el caso de las conexiones de borde, necesitamos redefinir la altura del otro extremo del puente.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En el caso de las juntas de esquina, debemos hacer lo mismo con el puente al pr√≥ximo vecino. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; AddTriangle(v2, v4, v5); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49b/548/792/49b5487921c6844b7a282e049a97bbd9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexi√≥n teniendo en cuenta la altura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos soporte para c√©lulas a diferentes alturas con las juntas inclinadas correctas entre ellas. </font><font style="vertical-align: inherit;">Pero no nos quedemos ah√≠. </font><font style="vertical-align: inherit;">Haremos que estas pendientes sean m√°s interesantes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costillas con repisas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las pendientes rectas no se ven muy atractivas. </font><font style="vertical-align: inherit;">Podemos dividirlos en varios pasos agregando pasos. </font><font style="vertical-align: inherit;">Este enfoque se utiliza en el juego Endless Legend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, podemos insertar dos repisas en cada pendiente. </font><font style="vertical-align: inherit;">Como resultado, una pendiente grande se convierte en tres peque√±as, entre las cuales hay dos √°reas planas. </font><font style="vertical-align: inherit;">Para triangular dicho esquema, tendremos que separar cada conexi√≥n en cinco etapas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce3/08b/82d/ce308b82db1bb0c72c387cc9da480d54.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dos repisas en la ladera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos establecer el n√∫mero de pasos para la pendiente </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y calcular el n√∫mero de etapas en funci√≥n de esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terracesPerSlope = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terraceSteps = terracesPerSlope * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, podr√≠amos simplemente interpolar cada paso a lo largo de la pendiente. </font><font style="vertical-align: inherit;">Pero esto no es del todo trivial, porque la coordenada Y solo deber√≠a cambiar en etapas impares. </font><font style="vertical-align: inherit;">De lo contrario, no obtendremos repisas planas. </font><font style="vertical-align: inherit;">Agreguemos un m√©todo de interpolaci√≥n especial para esto </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La interpolaci√≥n horizontal es simple si conocemos el tama√±o del paso de interpolaci√≥n. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> horizontalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / terraceSteps; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funciona la interpolaci√≥n entre dos valores?</font></font></b> <div class="spoiler_text">     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-82"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj3yMiVagbAp9qNgBsy83rQT-rmWg#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">a</script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">b</span></span></span><script type="math/tex" id="MathJax-Element-6">b</script>      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">t</span></span></span><script type="math/tex" id="MathJax-Element-7">t</script>  .  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">t</span></span></span><script type="math/tex" id="MathJax-Element-8">t</script>  0,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">a</span></span></span><script type="math/tex" id="MathJax-Element-9">a</script>  .    1,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">b</span></span></span><script type="math/tex" id="MathJax-Element-10">b</script>  .  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">t</span></span></span><script type="math/tex" id="MathJax-Element-11">t</script>  -  0  1, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">a</span></span></span><script type="math/tex" id="MathJax-Element-12">a</script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">b</span></span></span><script type="math/tex" id="MathJax-Element-13">b</script>  .       : <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mo" id="MJXp-Span-101" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-102">1</span><span class="MJXp-mo" id="MJXp-Span-103" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104">t</span><span class="MJXp-mo" id="MJXp-Span-105" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">a</span><span class="MJXp-mo" id="MJXp-Span-107" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">b</span></span></span><script type="math/tex" id="MathJax-Element-14">(1 - t)a + tb</script>  . <br><br>  ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mo" id="MJXp-Span-111" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-112">1</span><span class="MJXp-mo" id="MJXp-Span-113" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-114">t</span><span class="MJXp-mo" id="MJXp-Span-115" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-116">a</span><span class="MJXp-mo" id="MJXp-Span-117" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">b</span><span class="MJXp-mo" id="MJXp-Span-120" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">a</span><span class="MJXp-mo" id="MJXp-Span-122" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">a</span><span class="MJXp-mo" id="MJXp-Span-125" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">b</span><span class="MJXp-mo" id="MJXp-Span-128" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">a</span><span class="MJXp-mo" id="MJXp-Span-130" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">t</span><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">b</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-135">a</span><span class="MJXp-mo" id="MJXp-Span-136" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-15">(1 - t)a + tb = a - ta + tb = a + t(b - a)</script>  .        <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-137"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">a</span></span></span><script type="math/tex" id="MathJax-Element-16">a</script>  en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-139"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">b</span></span></span><script type="math/tex" id="MathJax-Element-17">b</script>   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-141"><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">b</span><span class="MJXp-mo" id="MJXp-Span-144" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">a</span><span class="MJXp-mo" id="MJXp-Span-146" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-18">(b - a)</script>  .  ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para cambiar Y solo en etapas impares, podemos usar </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-147"><span class="MJXp-mo" id="MJXp-Span-148" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-150"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-152"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mo" id="MJXp-Span-153" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-155" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-156"><span class="MJXp-mo" id="MJXp-Span-157" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-158"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19">(step + 1) / 2</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si usamos la divisi√≥n de enteros, convertir√° las series 1, 2, 3, 4 en 1, 1, 2, 2. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> verticalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (terracesPerSlope + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = ((step + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.verticalTerraceStepSize; ay += (<span class="hljs-keyword"><span class="hljs-keyword">by</span></span> - ay) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos tambi√©n un m√©todo para interpolar cornisas para colores. </font><font style="vertical-align: inherit;">Simplemente interpolarlos como si las conexiones fueran planas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color a, Color b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Color.Lerp(a, b, h); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medida que la triangulaci√≥n de la conexi√≥n de borde se vuelve m√°s complicada, eliminamos el c√≥digo correspondiente </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y lo colocamos en un m√©todo separado. </font><font style="vertical-align: inherit;">En los comentarios, guardar√© el c√≥digo fuente para consultarlo en el futuro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep; TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color); ‚Ä¶ } void TriangulateEdgeTerraces ( Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell ) { AddQuad(beginLeft, beginRight, endLeft, endRight); AddQuadColor(beginCell.color, endCell.color); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos desde el primer paso del proceso. </font><font style="vertical-align: inherit;">Utilizaremos nuestros m√©todos especiales de interpolaci√≥n para crear el primer quad. </font><font style="vertical-align: inherit;">En este caso, se debe crear una pendiente corta, m√°s pronunciada que la original.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/434/174/aea/434174aea469a4ba7da285ff02d4467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer paso para crear una repisa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora procederemos inmediatamente a la √∫ltima etapa, omitiendo todo lo que se encuentre en el medio. </font><font style="vertical-align: inherit;">Esto completar√° la conexi√≥n de los bordes, aunque hasta ahora con una forma irregular.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/1be/b3e/c6f1beb3ee6663cf8984130dc3d9378e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫ltimo paso para crear una repisa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se pueden agregar pasos intermedios a trav√©s del bucle. </font><font style="vertical-align: inherit;">En cada etapa, los dos √∫ltimos v√©rtices anteriores se convierten en los nuevos primero. </font><font style="vertical-align: inherit;">Lo mismo vale para el color. </font><font style="vertical-align: inherit;">Despu√©s de calcular los nuevos vectores y colores, se agrega otro quad.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c2; v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, i); v4 = HexMetrics.TerraceLerp(beginRight, endRight, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2); } AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/20f/64c/e6d20f64c28feaa5329f085d8a5b673a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los pasos intermedios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora todas las juntas de borde tienen dos repisas, o cualquier otro n√∫mero que especifique </font></font><code>HexMetrics.terracesPerSlope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por supuesto, hasta que hayamos creado repisas para las esquinas, dejaremos esto para m√°s adelante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/37b/4f9/4f337b4f9ba0092144e1148b10a4970b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las juntas de los bordes tienen repisas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipos de conexi√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convertir todas las juntas de borde en repisas no es una buena idea. </font><font style="vertical-align: inherit;">Solo se ven bien cuando la diferencia de altura es solo de un nivel. </font><font style="vertical-align: inherit;">Pero con una diferencia m√°s grande, se crean repisas estrechas con grandes espacios entre ellas, y esto no se ve muy hermoso. </font><font style="vertical-align: inherit;">Adem√°s, no necesitamos crear repisas para todas las juntas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formalicemos esto y definamos tres tipos de aristas: un plano, una pendiente y un acantilado. </font><font style="vertical-align: inherit;">Vamos a crear una enumeraci√≥n para esto.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexEdgeType { Flat, Slope, Cliff }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo determinar con qu√© tipo de conexi√≥n estamos tratando? </font><font style="vertical-align: inherit;">Para hacer esto, podemos agregar a un </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que usa dos niveles de altura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si las alturas son las mismas, tendremos una costilla plana. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la diferencia en los niveles es igual a un paso, entonces esta es una pendiente. </font><font style="vertical-align: inherit;">No importa si sube o baja. </font><font style="vertical-align: inherit;">En todos los dem√°s casos, tenemos un descanso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = elevation2 - elevation1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">1</span></span> || delta == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Slope; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Cliff; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos tambi√©n un m√©todo conveniente </font></font><code>HexCell.GetEdgeType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obtener el tipo de borde de celda en una determinada direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction].elevation ); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo necesitamos comprobar si existe un vecino en esta direcci√≥n?</font></font></b> <div class="spoiler_text">   ,       ,     .      ,    <code>NullReferenceException</code> .       ,    ,    - .    ,     .       . <br><br> ,        ,  ,       .    - ,   <code>NullReferenceException</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear repisas solo para pendientes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que podemos determinar el tipo de conexi√≥n, podemos decidir si insertar repisas. </font><font style="vertical-align: inherit;">Cambie </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que cree repisas solo para las pendientes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En este punto, podemos descomentar el c√≥digo comentado previamente para que pueda manejar planos y recortes. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/bb8/1e6/15abb81e60a35fb6383ff8be8b0a17dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los pasos se crean solo en las pendientes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repisas con repisas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las juntas de esquina son m√°s complejas que las juntas de borde porque est√°n involucradas no en dos, sino en tres celdas. </font><font style="vertical-align: inherit;">Cada esquina est√° conectada a tres bordes, que pueden ser planos, pendientes o acantilados. </font><font style="vertical-align: inherit;">Por lo tanto, hay muchas configuraciones posibles. </font><font style="vertical-align: inherit;">Al igual que con las costillas, es mejor agregar </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triangulaci√≥n </font><font style="vertical-align: inherit;">al </font><font style="vertical-align: inherit;">nuevo m√©todo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro nuevo m√©todo requerir√° los v√©rtices de un tri√°ngulo angular y celdas conectadas. </font><font style="vertical-align: inherit;">Para mayor comodidad, organicemos las conexiones para saber qu√© celda tiene la altura m√°s peque√±a. </font><font style="vertical-align: inherit;">Despu√©s de eso, podemos comenzar a trabajar desde la parte inferior izquierda y derecha.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b24/351/681/b243516810fc9f0e8c44a5cb12f74cff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Articulaci√≥n de esquina.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debo determinar cu√°l de las celdas es la m√°s baja. </font><font style="vertical-align: inherit;">Primero verificamos si la celda triangulada est√° por debajo de sus vecinos o est√° en el mismo nivel con el m√°s bajo. </font><font style="vertical-align: inherit;">Si es as√≠, entonces podemos usarlo como la celda m√°s baja.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si falla la verificaci√≥n m√°s profunda, esto significa que el pr√≥ximo vecino es la celda m√°s baja. </font><font style="vertical-align: inherit;">Para una orientaci√≥n adecuada, debemos rotar el tri√°ngulo en sentido antihorario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la primera prueba falla, entonces necesita comparar dos celdas vecinas. </font><font style="vertical-align: inherit;">Si el vecino de la costilla es el m√°s bajo, entonces debe girar en sentido horario, de lo contrario, en sentido antihorario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v4, neighbor, v5, nextNeighbor, v2, cell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8a/736/794/f8a736794c4e52c54ab018dcd55feba0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gire en sentido antihorario, sin giro, rotaci√≥n en sentido horario.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n de pendiente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para saber c√≥mo triangular un √°ngulo, necesitamos entender con qu√© tipos de aristas estamos tratando. </font><font style="vertical-align: inherit;">Para simplificar esta tarea, agreguemos a </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otro m√©todo conveniente para reconocer la pendiente entre dos celdas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell otherCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, otherCell.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos este nuevo m√©todo </font></font><code>HexMesh.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar los tipos de bordes izquierdo y derecho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ambas costillas son inclinadas, tendremos salientes tanto a la izquierda como a la derecha. </font><font style="vertical-align: inherit;">Adem√°s, dado que la celda inferior es la m√°s baja, sabemos que estas pendientes se elevan. </font><font style="vertical-align: inherit;">Adem√°s, las celdas izquierda y derecha tienen la misma altura, es decir, la conexi√≥n del borde superior es plana. </font><font style="vertical-align: inherit;">Podemos designar este caso como "pendiente-pendiente-plano", o MTP.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b75/4a3/f9e/b754a3f9eccdb6baada2a51fef2c4301.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dos pendientes y un avi√≥n, SSP.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comprobaremos si estamos en esta situaci√≥n, y si es as√≠, llamaremos a un nuevo m√©todo </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Despu√©s de eso, volveremos del m√©todo. </font><font style="vertical-align: inherit;">Inserte esta verificaci√≥n antes del antiguo c√≥digo de triangulaci√≥n para que reemplace el tri√°ngulo original.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no estamos haciendo nada en el interior </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, algunos cruces de esquina con dos pendientes se convertir√°n en vac√≠os. </font><font style="vertical-align: inherit;">Si la conexi√≥n se vac√≠a o no depende de cu√°l de las celdas es m√°s baja.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/a54/2ea/26ba542eaed793e064e478cbdbc5f109.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay un vac√≠o </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para llenar el vac√≠o, necesitamos conectar la repisa izquierda y derecha a trav√©s de un espacio. </font><font style="vertical-align: inherit;">El enfoque aqu√≠ es el mismo que para unir bordes, pero dentro de un tri√°ngulo de tres colores en lugar de un cuadril√°tero de dos colores. </font><font style="vertical-align: inherit;">Comencemos nuevamente con la primera etapa, que ahora es un tri√°ngulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebf/a76/823/ebfa76823e5dba45fd97daa1f052b1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera etapa del tri√°ngulo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y nuevamente vamos directamente a la √∫ltima etapa. </font><font style="vertical-align: inherit;">Este es el cuadr√°ngulo que forma un trapecio. </font><font style="vertical-align: inherit;">La √∫nica diferencia con las conexiones de borde aqu√≠ es que no estamos tratando con dos, sino con cuatro colores.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/ab2/20b/99eab220bcbdda36896dbb1640995b33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima etapa del cuadr√°ngulo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las etapas entre ellos tambi√©n son cuadr√°ngulos.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2, c3, c4); } AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b46/8bb/c69/b468bbc6989ae33c9a810f5e641f2446.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las etapas</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dos variaciones de pendiente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El caso con dos pendientes tiene dos variaciones con diferentes orientaciones, dependiendo de cu√°l de las celdas es la parte inferior. </font><font style="vertical-align: inherit;">Podemos encontrarlos comprobando combinaciones izquierda-derecha para pendiente-plano y plano-pendiente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b17/736/3ca/b177363ca9391a96905ce2a0717020d9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATP y MSS. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el borde derecho es plano, entonces deber√≠amos comenzar a crear repisas a la izquierda, y no a la parte inferior. </font><font style="vertical-align: inherit;">Si el borde izquierdo es plano, debe comenzar por el derecho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debido a esto, las repisas ir√°n alrededor de las celdas sin interrupci√≥n hasta que lleguen al acantilado o al final del mapa. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/359/68c/4d835968ce882e260a2b4f7ec23979ab.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repisas s√≥lidas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fusi√≥n de laderas y acantilados. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hay de conectar la pendiente y el acantilado? </font><font style="vertical-align: inherit;">Si sabemos que el borde izquierdo es una pendiente y el derecho es un acantilado, ¬øcu√°l ser√° el borde superior? </font><font style="vertical-align: inherit;">No puede ser plano, pero puede ser una pendiente o un acantilado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/6bc/0d3/dd96bc0d3fb89e029687c7b9c9312cc5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/07d/d22/04907dd22fc5da80ba59fa2dbb6abb82.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/463/24c/c57/46324cc57e9c3e79a21378c932e09ed9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOS y COO. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos un nuevo m√©todo para manejar todos los casos de pendiente-acantilado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deber√≠a llamarse como la √∫ltima opci√≥n </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando el borde izquierdo es una pendiente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo triangulamos esto? </font><font style="vertical-align: inherit;">Esta tarea se puede dividir en dos partes: inferior y superior.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte inferior </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La parte inferior tiene repisas a la izquierda y un acantilado a la derecha. </font><font style="vertical-align: inherit;">Necesitamos combinarlos de alguna manera. </font><font style="vertical-align: inherit;">La forma m√°s f√°cil de hacer esto es apretando las repisas para que se encuentren en la esquina derecha. </font><font style="vertical-align: inherit;">Esto elevar√° las repisas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/8e7/d53/d118e7d538c25cba75a31ca37c6096cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi√≥n de repisas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, de hecho, no queremos que se re√∫nan en la esquina derecha, porque esto interferir√° con las repisas que puedan existir arriba. </font><font style="vertical-align: inherit;">Adem√°s, podemos lidiar con un acantilado muy alto, debido al cual obtenemos tri√°ngulos que caen muy finos y delgados. </font><font style="vertical-align: inherit;">En cambio, los comprimiremos hasta un punto l√≠mite que se encuentra a lo largo de un acantilado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df5/131/efa/df5131efa8069569630306b4cc8eb9b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi√≥n en la frontera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloquemos el punto l√≠mite un nivel por encima de la celda inferior. </font><font style="vertical-align: inherit;">Puede encontrarlo por interpolaci√≥n en funci√≥n de la diferencia de altura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para asegurarnos de que lo tenemos correctamente, cubrimos toda la parte inferior con un tri√°ngulo. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); AddTriangle(begin, left, boundary); AddTriangleColor(beginCell.color, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03e/534/ab9/03e534ab927d5709aca721ccfd9bdc80.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri√°ngulo inferior </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de colocar el borde en el lugar correcto, podemos proceder a la triangulaci√≥n de las repisas. </font><font style="vertical-align: inherit;">Comencemos de nuevo solo desde la primera etapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c2/4fc/3c1/6c24fc3c19580573b89d3259b855a692.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera etapa de compresi√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta vez, la √∫ltima etapa tambi√©n ser√° un tri√°ngulo.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/6db/5cb/0356db5cbaf4bd936ea4235af34eb1d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima etapa de compresi√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y todos los pasos intermedios tambi√©n son tri√°ngulos.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/987/744/6e698774450ec3502f52537936d8a29e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repisas comprimidas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo podemos mantener el nivel de la repisa?</font></font></b> <div class="spoiler_text"> ,     ,       ,       .         .        ,          .    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminaci√≥n de la esquina </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo terminado la parte inferior, puedes ir a la parte superior. </font><font style="vertical-align: inherit;">Si el borde superior es una pendiente, entonces nuevamente tendremos que conectar las repisas y el acantilado. </font><font style="vertical-align: inherit;">As√≠ que vamos a mover este c√≥digo a un m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora completar la parte superior ser√° f√°cil. </font><font style="vertical-align: inherit;">Si tenemos una pendiente, entonces agregue el tri√°ngulo girado del borde. </font><font style="vertical-align: inherit;">De lo contrario, un tri√°ngulo simple es suficiente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/ed2/8fb/bc5ed28fbb4a1a1f0015dafac63f5ec0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59c/45b/241/59c45b2413d30e196fc195796e4b07e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulaci√≥n completa de ambas partes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estuches reflejados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinamos los casos de "pendiente-acantilado". </font><font style="vertical-align: inherit;">Tambi√©n hay dos cajas de espejo, cada una de las cuales tiene un acantilado a la izquierda.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c00/726/f4f/c00726f4fc6ef078b33782047f4e6b4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS y CCA. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizaremos el enfoque anterior, con ligeras diferencias debido a un cambio de orientaci√≥n. </font><font style="vertical-align: inherit;">Lo copiamos </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y lo cambiamos en consecuencia.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, left, b); Color boundaryColor = Color.Lerp(beginCell.color, leftCell.color, b); TriangulateBoundaryTriangle( right, rightCell, begin, beginCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue estos casos a </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/a9b/7e6/3d9a9b7e606cefd475ca14f53a48a683.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/495/6f4/3234956f44e8bcbd63d055a9a7f89c36.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS triangulado y CCA.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acantilados dobles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los √∫nicos casos no planos restantes son las celdas inferiores con acantilados en ambos lados. </font><font style="vertical-align: inherit;">En este caso, la costilla superior puede ser cualquiera: plana, inclinada o acantilada. </font><font style="vertical-align: inherit;">Solo nos interesa el caso ‚Äúacantilado-acantilado-pendiente‚Äù, porque solo tendr√° repisas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, hay dos versiones diferentes de "acantilado-acantilado-pendiente", dependiendo de qu√© lado es m√°s alto. </font><font style="vertical-align: inherit;">Son im√°genes especulares el uno del otro. </font><font style="vertical-align: inherit;">Vamos a designarlos como OOSP y OOSL.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/038/df7/b9f038df7a7d23da542430652adbd038.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/0b2/013/3c30b2013db25c9288ad551ec529c07b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/e0d/151/7aee0d1512d324b1bd3c8e91f1b4134d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOSP y OOSL. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos cubrir ambos casos </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamando a m√©todos </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con diferentes rotaciones de c√©lulas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esto crea una triangulaci√≥n extra√±a. </font><font style="vertical-align: inherit;">Esto se debe a que ahora estamos triangulando de arriba a abajo. </font><font style="vertical-align: inherit;">Debido a esto, nuestra frontera se interpola como negativa, lo cual es incorrecto. </font><font style="vertical-align: inherit;">La soluci√≥n aqu√≠ es tener siempre interpoladores positivos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/f3d/bf8/ae8f3dbf8d5e2781cff2437d8ce4ad70.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/710/922/0aa/7109220aa668eae0d9904f48d7bd30ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOSP triangulado y OOSL.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Examinamos todos los casos que requieren un manejo especial para garantizar la triangulaci√≥n correcta de las repisas. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/280/86f/dc228086f73f694a351ec127e0e75e45.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulaci√≥n completa con repisas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos limpiar un poco </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deshaci√©ndonos de los operadores </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usando bloques en su lugar </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫ltimo bloque </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cubre todos los casos restantes que a√∫n no se han cubierto. </font><font style="vertical-align: inherit;">Estos casos son RFP (plane-plane-plane), OOP, LLC y LLC. </font><font style="vertical-align: inherit;">Todos ellos est√°n cubiertos por un tri√°ngulo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/4da/58b/9444da58b33b9558b88fa8bb80102e34.png"></div><br> <i>  .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">unitypackage</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424257/">https://habr.com/ru/post/es424257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424245/index.html">Escribir un cliente de Telegram es f√°cil</a></li>
<li><a href="../es424247/index.html">KotlinConf 2018 Live - vea la transmisi√≥n del 4 al 5 de octubre</a></li>
<li><a href="../es424249/index.html">Materiales de la reuni√≥n #RuPostgres - videos, presentaciones, an√°lisis de cuestionarios y reportaje fotogr√°fico</a></li>
<li><a href="../es424251/index.html">Consideramos estad√≠sticas sobre experimentos en hh.ru</a></li>
<li><a href="../es424255/index.html">C√≥mo usar el an√°lisis est√°tico correctamente</a></li>
<li><a href="../es424259/index.html">Semana de la seguridad 36: Telnet deber√≠a estar cerrado</a></li>
<li><a href="../es424261/index.html">C√≥mo resolver cualquier problema de programaci√≥n</a></li>
<li><a href="../es424263/index.html">Actualizaci√≥n de IDA Pro. Arreglamos jambas de m√≥dulos de procesador</a></li>
<li><a href="../es424265/index.html">Revisi√≥n de la bicicleta el√©ctrica Twitter Mantis E-1</a></li>
<li><a href="../es424267/index.html">¬øC√≥mo depuramos un ECS auto-escrito en un navegador en un servidor de juegos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>