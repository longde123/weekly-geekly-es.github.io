<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤝 👌🏻 👩🏼‍🏭 نهج الجشع وفتحات الآلات. تحليل مهام ML المسار من بطولة البرمجة 🤵🏾 ✋🏻 ↗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="نواصل نشر تحليلات المهام التي تم اقتراحها في البطولة الأخيرة. التالي في السطر هي المهام التي اتخذت من جولة التأهيل لأخصائيي التعلم الآلي. هذا هو المسا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>نهج الجشع وفتحات الآلات. تحليل مهام ML المسار من بطولة البرمجة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/461273/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sd/i7/yd/sdi7ydyv5yabtpudjamnnmm2dge.jpeg"><br><br>  نواصل نشر تحليلات المهام التي تم اقتراحها في البطولة الأخيرة.  التالي في السطر هي المهام التي اتخذت من جولة التأهيل لأخصائيي التعلم الآلي.  هذا هو المسار الثالث من أربعة (الخلفية ، الواجهة الأمامية ، ML ، التحليلات).  يحتاج المشاركون إلى صنع نموذج لتصحيح الأخطاء المطبعية في النصوص ، واقتراح استراتيجية للعب على ماكينات القمار ، ووضع نظام توصيات للمحتوى ، وإنشاء عدة برامج أخرى. <br><br><a name="habracut"></a><h2 style=";text-align:right;direction:rtl">  أ. الأخطاء المطبعية </h2><br><h4 style=";text-align:right;direction:rtl">  حالة </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td></td><td>  <b>كل اللغات</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  المهلة </td><td>  1 ثانية </td><td>  5 ق </td><td>  5 ق </td></tr><tr><td>  حد الذاكرة </td><td>  64 ميغابايت </td><td>  256 ميغابايت </td><td>  256 ميغابايت </td></tr><tr><td>  دخول </td><td colspan="3">  المدخلات القياسية أو المدخلات </td></tr><tr><td>  استنتاج </td><td colspan="3">  الإخراج القياسي أو الإخراج </td></tr></tbody></table></div>  (الكتابة) (من منتدى واحد) <br>  - من يتكون هذا الهراء؟ <br>  - علماء الفيزياء الفلكية.  هم الناس أيضا. <br>  - لقد ارتكبت 10 أخطاء في كلمة "الصحفيين". <br><br>  يرتكب العديد من المستخدمين أخطاء في الكتابة ، بعضها بسبب ضرب المفاتيح ، والبعض الآخر بسبب أميتهم.  نريد التحقق مما إذا كان المستخدم يمكن أن يعني في الواقع كلمة أخرى غير الكلمة التي كتبها. <br><br>  بشكل أكثر رسمية ، افترض أن نموذج الخطأ التالي يحدث: يبدأ المستخدم بكلمة يريد كتابتها ، ثم يقوم بعد ذلك بعدد من الأخطاء فيها.  كل خطأ هو استبدال لبعض سلسلة فرعية من الكلمة لسلسلة فرعية أخرى.  خطأ واحد يتوافق مع استبدال فقط في موقف واحد (أي إذا كان المستخدم يريد أن يرتكب خطأ واحد من قبل القاعدة "abc" → "cba" ، ثم من سلسلة "abcabc" يمكنه الحصول على "cbaabc" أو "abccba").  بعد كل خطأ ، تتكرر العملية.  يمكن استخدام نفس القاعدة عدة مرات في خطوات مختلفة (على سبيل المثال ، في المثال أعلاه ، يمكن الحصول على "cbacba" في خطوتين). <br><br>  يجب تحديد الحد الأدنى لعدد الأخطاء التي يمكن أن يرتكبها المستخدم إذا كان يفكر في كلمة معينة وكتب كلمة أخرى. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تنسيقات I / O ومثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><h4 style=";text-align:right;direction:rtl">  تنسيق الإدخال </h4><br>  يحتوي السطر الأول على الكلمة التي ، حسب افتراضنا ، كان المستخدم في ذهنه (تتكون من أحرف الأبجدية اللاتينية في الأحرف الصغيرة ، لا يتجاوز الطول 20). <br><br>  يحتوي السطر الثاني على الكلمة التي كتبها بالفعل (وهي تتألف أيضًا من أحرف الأبجدية اللاتينية في الأحرف الصغيرة ، لا يتجاوز الطول 20). <br><br>  يحتوي السطر الثالث على رقم واحد N (N &lt;50) - هو عدد البدائل التي تصف الأخطاء المختلفة. <br><br>  تحتوي الأسطر N التالية على بدائل محتملة في تنسيق &amp; lt "الحروف" التسلسل &amp; gt &lt;space&gt; &lt;تسلسل الحروف "الخاطئة"&gt;.  التسلسلات لا يزيد طولها عن 6 أحرف. <br><br><h4 style=";text-align:right;direction:rtl">  تنسيق الإخراج </h4><br>  يجب طباعة رقم واحد - وهو الحد الأدنى لعدد الأخطاء التي قد يرتكبها المستخدم.  إذا تجاوز هذا الرقم 4 أو كان من المستحيل الحصول على آخر من كلمة واحدة ، فقم بطباعة -1. <br><br><h4 style=";text-align:right;direction:rtl">  مثال </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td><code>mlax <br> drum <br> 50 <br> lr <br> mlax gtwt <br> md <br> mlax ujoc <br> ml pq <br> mf <br> ml bf <br> mlax aruq <br> mlax nqdd <br> mlax fglm <br> mlax bfit <br> mlax mziq <br> mla hlb <br> au <br> mlax vmpa <br> mw <br> aw <br> ax ok <br> mla kqf <br> me <br> xx <br> ml if <br> ml gk <br> le <br> mla xrh <br> mj <br> ac <br> ab <br> mq <br> ax fr <br> ml sb <br> mlax gxxx <br> xm <br> mlax hczx <br> lq <br> la sv <br> lg <br> ax eh <br> lax mjh <br> la ec <br> la pv <br> ml iq <br> aq <br> lax jrs <br> la qn <br> lax bjo <br> lo <br> az <br> ln <br> ac</code> </td> <td> <code>4</code> </td> </tr></tbody></table></div></div></div><br><h4 style=";text-align:right;direction:rtl">  قرار </h4><br>  دعنا نحاول إنشاء كل الكلمات الممكنة من الإملاء الصحيح دون أكثر من 4 أخطاء.  في أسوأ الحالات ، قد يكون هناك O ((L﹒N) <sup>4</sup> ).  في حدود المشكلة ، هذا عدد كبير إلى حد ما ، لذلك تحتاج إلى معرفة كيفية الحد من التعقيد.  بدلاً من ذلك ، يمكنك استخدام خوارزمية الالتقاء في الوسط: إنشاء كلمات لا تزيد عن 2 أخطاء ، وكذلك الكلمات التي يمكنك من خلالها الحصول على كلمة مكتوبة بواسطة المستخدم مع عدم وجود أكثر من خطأين.  لاحظ أن حجم كل مجموعة من هذه المجموعات لن يتجاوز 10 <sup>6</sup> .  إذا لم يتجاوز عدد الأخطاء التي ارتكبها المستخدم 4 ، فسوف تتقاطع هذه المجموعات.  وبالمثل ، يمكننا التحقق من أن عدد الأخطاء لا يتجاوز 3 و 2 و 1. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; applyRule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; word, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromTo &amp;fromTo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from = word.find(fromTo.from, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos, {}}; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = from + fromTo.from.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cpy = word; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { cpy[i] = fromTo.to[i - from]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {from, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cpy)}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverseRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt; &amp;rules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; rule: rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(rule.from, rule.to); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordOrig, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordMissprinted, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt;&amp; replaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mapping; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; mappingInverse; mapping.emplace(wordOrig, <span class="hljs-number"><span class="hljs-number">0</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, wordOrig); mapping.emplace(wordMissprinted, <span class="hljs-number"><span class="hljs-number">1</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">1</span></span>, wordMissprinted); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buildGraph = [&amp;edges, &amp;mapping, &amp;mappingInverse](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startId, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FromTo&gt;&amp; replaces, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dir) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer0; mappingLayer0 = {startId}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: mappingLayer0) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; word = mappingInverse.at(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; fromTo: replaces) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> from = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [tmp, wordCpy] = applyRule(word, fromTo, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } from = tmp + <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = mapping.size(); mapping.emplace(wordCpy, w); w = mapping.at(wordCpy); mappingInverse.emplace(w, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wordCpy)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir) { edges[v].emplace(w); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edges[w].emplace(v); } mappingLayer1.emplace(w); } } } } mappingLayer0 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mappingLayer1); } }; buildGraph(<span class="hljs-number"><span class="hljs-number">0</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); inverseRules(replaces); buildGraph(<span class="hljs-number"><span class="hljs-number">1</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; q; q.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; mask(mapping.size(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (q.size()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [w, level] = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[w]) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } mask[w] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mappingInverse.at(w) == wordMissprinted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: edges[w]) { q.emplace(v, level + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  B. العصابات المسلحة </h2><br><h4 style=";text-align:right;direction:rtl">  حالة </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  المهلة </td><td>  2 ثانية </td></tr><tr><td>  حد الذاكرة </td><td>  64 ميغابايت </td></tr><tr><td>  دخول </td><td>  المدخلات القياسية </td></tr><tr><td>  استنتاج </td><td>  الإخراج القياسي </td></tr></tbody></table></div>  هذه مهمة تفاعلية. <br><br>  أنت نفسك لا تعرف كيف حدث ذلك ، ولكنك وجدت نفسك في قاعة بها آلات القمار مع حقيبة كاملة من الرموز.  للأسف ، في شباك التذاكر ، يرفضون قبول الرموز المميزة ، وقررت تجربة حظك.  هناك العديد من ماكينات القمار في القاعة التي يمكنك لعبها.  لعبة واحدة مع فتحة آلة تستخدم رمز واحد.  في حالة الفوز ، يمنحك الجهاز دولارًا واحدًا ، في حالة الخسارة - لا شيء.  كل جهاز لديه احتمالية ثابتة للفوز (لا تعرفه) ، لكنه يختلف عن الأجهزة المختلفة.  بعد دراسة موقع الشركة المصنعة لهذه الآلات ، اكتشفت أن احتمال الفوز لكل جهاز يتم اختياره عشوائيًا في مرحلة التصنيع من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">توزيع بيتا</a> مع بعض المعلمات. <br><br>  تريد زيادة أرباحك المتوقعة إلى الحد الأقصى. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تنسيقات I / O ومثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><h4 style=";text-align:right;direction:rtl">  تنسيق الإدخال </h4><br>  قد يتكون تنفيذ واحد من عدة اختبارات. <br><br>  يبدأ كل اختبار بحقيقة أن البرنامج على الخط يحتوي على عددين صحيحين مفصولين بمسافة: الرقم N هو عدد الرموز في حقيبتك ، و M هو عدد الآلات في القاعة (N ≤ 10 <sup>4</sup> ، M ≤ min (N ، 100) ).  يحتوي السطر التالي على رقمين حقيقيين α و β (1 ≤ α و β ≤ 10) - معلمات التوزيع التجريبي لاحتمال الفوز. <br><br>  بروتوكول الاتصال مع نظام التحقق هو هذا: يمكنك تقديم طلبات N بالضبط.  لكل طلب ، اطبع في سطر منفصل رقم الجهاز الذي ستلعبه (من 1 إلى M ضمناً).  كإجابة ، في سطر منفصل سيكون هناك إما "0" أو "1" ، وهذا يعني على التوالي خسارة وفوز في لعبة مع آلة القمار المطلوبة. <br><br>  بعد الاختبار الأخير ، بدلاً من الأرقام N و M ، سيكون هناك صفرين. <br><br><h4 style=";text-align:right;direction:rtl">  تنسيق الإخراج </h4><br>  سيتم اعتبار المهمة مكتملة إذا لم يكن قرارك أسوأ من قرار لجنة التحكيم.  إذا كان قرارك أسوأ بكثير من قرار هيئة المحلفين ، فستتلقى الحكم "إجابة خاطئة". <br><br>  من المضمون أنه إذا كان قرارك ليس أسوأ من قرار هيئة المحلفين ، فإن احتمال تلقي الحكم "إجابة خاطئة" لا يتجاوز <sup>10-6</sup> . <br><br><h4 style=";text-align:right;direction:rtl">  الملاحظات </h4><br>  مثال التفاعل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">____________________  <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> ____________________ ____________________   <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4 style=";text-align:right;direction:rtl">  قرار </h4><br>  هذه المشكلة معروفة جيدًا ، ويمكن حلها بطرق مختلفة.  طبق القرار الرئيسي لهيئة المحلفين استراتيجية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أخذ عينات Thompson</a> ، ولكن نظرًا لأن عدد الخطوات كان معروفًا في بداية البرنامج ، فهناك استراتيجيات أكثر مثالية (على سبيل المثال ، UCB1).  علاوة على ذلك ، يمكن للمرء حتى الحصول على مع استراتيجية الجشع epsilon: مع وجود احتمال معين ، تلعب آلة عشوائية ومع الاحتمال (1 - ε) تلعب آلة مع أفضل إحصائيات النصر. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SolverFromStdIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.regrets = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.total_win = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.moves = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampling</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SolverFromStdIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bandits_total, init_a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, init_b=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" init_a (int): initial value of a in Beta(a, b). init_b (int): initial value of b in Beta(a, b). """</span></span> SolverFromStdIn.__init__(self) self.n = bandits_total self.alpha = init_a self.beta = init_b self._as = [init_a] * self.n <span class="hljs-comment"><span class="hljs-comment"># [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self._bs = [init_b] * self.n # [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self.last_move = -1 random.seed(int(time.time())) def move(self): samples = [random.betavariate(self._as[x], self._bs[x]) for x in range(self.n)] self.last_move = max(range(self.n), key=lambda x: samples[x]) self.moves.append(self.last_move) return self.last_move def set_reward(self, reward): i = self.last_move r = reward self._as[i] += r self._bs[i] += (1 - r) return i, r while True: n, m = map(int, sys.stdin.readline().split()) if n == 0 and m == 0: break alpha, beta = map(float, sys.stdin.readline().split()) solver = ThompsonSampling(m) for _ in range(n): print &gt;&gt; sys.stdout, solver.move() + 1 sys.stdout.flush() reward = int(sys.stdin.readline()) solver.set_reward(reward)</span></span></code> </pre> <br><h2 style=";text-align:right;direction:rtl">  C. محاذاة الجمل </h2><br><h4 style=";text-align:right;direction:rtl">  حالة </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  المهلة </td><td>  2 ثانية </td></tr><tr><td>  حد الذاكرة </td><td>  64 ميغابايت </td></tr><tr><td>  دخول </td><td>  المدخلات القياسية أو المدخلات </td></tr><tr><td>  استنتاج </td><td>  الإخراج القياسي أو الإخراج </td></tr></tbody></table></div>  واحدة من أهم المهام لتدريب نموذج الترجمة الآلية الجيدة هي حالة جيدة من الجمل المتوازية.  عادةً ما يكون مصدر العروض المتوازية مستندات موازية.  اتضح أنه في كثير من الأحيان لبناء مجموعة معينة من الجمل المتوازية ، لا تحتاج إلى معرفة أي شيء سوى أطوالها.  على وجه الخصوص ، قد تلاحظ أنه كلما طالت مدة الجملة في لغة المصدر ، كلما تمت ترجمتها على الأرجح.  تكمن بعض الصعوبات في حقيقة أنه أثناء الترجمة يمكن أن يتغير عدد الجمل في النص: في بعض الأحيان يمكن دمج جملتين متجاورتين في الترجمة في جملة واحدة ، أو العكس - يمكن تقسيم جملة واحدة إلى جملتين.  في بعض الحالات النادرة ، قد يتم حذف الجمل بالكامل في الترجمة ، أو قد تظهر الترجمة في الترجمة التي لم تكن بالأصل. <br><br>  بشكل أكثر رسمية ، افترض أن النموذج التوليفي التالي للمرفقات الموازية صحيح.  في كل خطوة ، نقوم بأحد الإجراءات التالية: <br><br>  <b>1. <i>توقف</i></b> <br><br>  مع الاحتمال p <sub>h ،</sub> ينتهي توليد الأجسام. <br><br>  <b>2. [1-0] <i>تخطي العروض</i></b> <br><br>  مع الاحتمال p <sub>d</sub> نسند جملة واحدة إلى النص الأصلي.  نحن لا ننسب أي شيء للترجمة.  يتم تحديد طول الجملة باللغة الأصلية L ≥ 1 من التوزيع المنفصل: <br><br><img src="https://habrastorage.org/webt/bm/pe/t_/bmpet_y_ksvwgbohazpgctekbks.png" width="350">  . <br><br>  فيما يلي معلمات التوزيع ، و <i>α <sub>s</sub></i> هي معامل التطبيع المختار بحيث <img src="https://habrastorage.org/webt/fm/ae/ns/fmaensnvy1nauvywiluibhryr6s.png" width="100">  . <br><br>  <b>3. [0-1] <i>أدخل الاقتراح</i></b> <br><br>  مع الاحتمال p <sub>i</sub> نخصص جملة واحدة للترجمة.  نحن لا ننسب أي شيء إلى الأصل.  يتم تحديد طول الجملة في لغة الترجمة L ≥ 1 من توزيع منفصل: <br><br><img src="https://habrastorage.org/webt/yl/yn/kr/ylynkr3cs_t7dpedebtzqj3uryk.png" width="350">  . <br><br>  هنا، <i><sub>t</sub></i> ، <i>σ <sub>t</sub></i> هي معلمات التوزيع ، و <i>α <sub>t</sub></i> هي معامل التطبيع المختار بحيث <img src="https://habrastorage.org/webt/bq/-k/p3/bq-kp37k-c-k5fpq9jrz4r8rkvy.png" width="100">  . <br><br>  <b>4. <i>الترجمة</i></b> <br><br>  مع الاحتمال (1 - p <sub>d</sub> - p <sub>i</sub> - p <sub>h</sub> ) نأخذ طول الجملة باللغة الأصلية L <sub>s</sub> ≥ 1 من التوزيع p <sub>s</sub> (مع التقريب لأعلى).  بعد ذلك ، نقوم بإنشاء طول الجملة في لغة الترجمة L <sub>t</sub> ≥ 1 من التوزيع المنفصل الشرطي: <br><br><img src="https://habrastorage.org/webt/ae/b6/mx/aeb6mx4cols1jplbs-di9emhxf8.png" width="500">  . <br><br>  هنا <i>α <sub>st</sub></i> هو معامل التطبيع ، ويتم وصف المعلمات المتبقية في الفقرات السابقة. <br><br>  التالي هو خطوة أخرى: <br><br>  1. [2-1] مع الاحتمال p <sub>split s ، تنقسم</sub> الجملة المولدة في اللغة الأصلية إلى كلمتين غير فارغتين ، بحيث يزيد العدد الإجمالي للكلمات <b><i>بواحدة</i></b> .  احتمال أن تنفصل جملة الطول L <sub>s</sub> إلى أجزاء من الطول L <sub>1</sub> و L <sub>2</sub> (أي L <sub>1</sub> + L <sub>2</sub> = L <sub>s</sub> + 1) تتناسب مع P <sub>s</sub> (L <sub>1</sub> ) ⋅ P <sub>s</sub> (L <sub>2</sub> ). <br><br>  2. [1-2] مع وجود الاحتمال p <sub>split t ، تنقسم</sub> الجملة التي تم إنشاؤها في اللغة الهدف إلى جملتين غير فارغتين ، بحيث يزيد العدد الإجمالي للكلمات بحرف واحد.  احتمال أن تنفصل جملة الطول L <sub>t</sub> إلى أجزاء من الطول L1 و L2 (أي L <sub>1</sub> + L <sub>2</sub> = L <sub>t</sub> + 1) تتناسب مع P <sub>t</sub> (L <sub>1</sub> ) ⋅ P <sub>t</sub> (L <sub>2</sub> ). <br><br>  3. 3. [1-1] مع احتمال (1 - p <sub>split s</sub> - p <sub>split t</sub> ) ، لن يتحلل أي من الجمل المتولدة. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">I / O التنسيقات والأمثلة والملاحظات</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><h4 style=";text-align:right;direction:rtl">  تنسيق الإدخال </h4><br>  يحتوي السطر الأول من الملف على معلمات التوزيع: p <sub>h</sub> ، p <sub>d</sub> ، p <sub>i</sub> ، p <sub>split s</sub> ، p <sub>split t</sub> ،، <sub>s</sub> ، σ <sub>s</sub> ، μ <sub>t</sub> ، σ <sub>t</sub> .  0.1 ≤ σ <sub>s</sub> &lt;σ <sub>t</sub> ≤ 3. 0 ≤ μ <sub>s</sub> ، μ <sub>t</sub> ≤ 5. <br><br>  يحتوي السطر التالي على الأرقام N <sub>s</sub> و N <sub>t</sub> - عدد الجمل في الحالة باللغة الأصلية وباللغة الهدف ، على التوالي (1 ≤ N <sub>s</sub> و N <sub>t</sub> ≤ 1000). <br><br>  يحتوي السطر التالي على أعداد صحيحة N - أطوال الجمل في اللغة الأصلية.  يحتوي السطر التالي على أعداد صحيحة N <sub>t</sub> - أطوال الجمل في اللغة الهدف. <br><br>  يحتوي السطر التالي على رقمين: j و k (1 ≤ j ≤ N <sub>s</sub> ، 1 ≤ k ≤ N <sub>t</sub> ). <br><br><h4 style=";text-align:right;direction:rtl">  تنسيق الإخراج </h4><br>  من الضروري اشتقاق احتمال أن تكون الجمل ذات الفهارس j و k في النصوص ، على التوالي ، متوازية (أي ، يتم إنشاؤها في خطوة واحدة من الخوارزمية وليس أي منها ناتج عن الانحلال). <br><br>  سيتم قبول إجابتك إذا كان الخطأ المطلق لا يتجاوز <sup>10-4</sup> . <br><br><h4 style=";text-align:right;direction:rtl">  مثال 1 </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>0.05 0.08 0.07 0.15 0.1 1 0.3 3 0.5 <br> 1 1 <br> 4 <br> 20 <br> 1 1</code> </td> <td> <code>0.975037457809</code> </td> </tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  مثال 2 </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>0.1 0.2 0.3 0.25 0.3 1 0.3 3 0.5 <br> 2 1 <br> 3 4 <br> 20 <br> 2 1</code> </td> <td> <code>0.247705779810</code> </td> </tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  مثال 3 </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>0.2 0.2 0.2 0.3 0.3 3 0.3 1 1 <br> 5 3 <br> 16 35 24 19 23 <br> 5 6 7 <br> 2 1</code> </td> <td> <code>0.200961101684</code> </td> </tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  الملاحظات </h4><br>  في المثال الأول ، يمكن الحصول على التسلسل الأولي للأرقام بثلاث طرق: <br><br>  • أولاً ، مع الاحتمال p <sub>d</sub> أضف جملة واحدة إلى النص الأصلي ، ثم مع الاحتمال p <sub>i</sub> أضف جملة واحدة إلى الترجمة ، ثم مع الاحتمال p <sub>h</sub> أنهي التوليد. <br><br>  احتمال هذا الحدث هو P <sub>1</sub> = p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>h</sub> . <br><br>  • أولاً ، مع الاحتمال p <sub>d</sub> أضف جملة واحدة إلى النص الأصلي ، ثم مع الاحتمال p <sub>i</sub> أضف جملة واحدة إلى الترجمة ، ثم مع الاحتمال p <sub>h</sub> أنهي التوليد. <br><br>  احتمال هذا الحدث يساوي P <sub>2</sub> = p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>h</sub> . <br><br>  • مع الاحتمال (1 - p <sub>h</sub> - p <sub>d</sub> - p <sub>i</sub> ) قم بإنشاء جملتين ، ثم مع الاحتمال (1 - p <sub>split s</sub> - p <sub>split t</sub> ) اترك كل شيء كما هو (أي ، لا تقسم الأصل أو الترجمة إلى جملتين ) وبعد ذلك مع الاحتمال p <sub>h</sub> ينهي الجيل. <br><br>  احتمال هذا الحدث هو <br><img src="https://habrastorage.org/webt/xw/ka/ys/xwkayskmtg4g3tkt9pb3n-ieyoa.png" width="550">  . <br><br>  نتيجة لذلك ، يتم حساب الإجابة كـ <img src="https://habrastorage.org/webt/zm/tw/xk/zmtwxkdjhhctfrcbiqsc0tur6g0.png" width="100">  . </div></div><br><h4 style=";text-align:right;direction:rtl">  قرار </h4><br>  المهمة هي حالة خاصة من المحاذاة باستخدام نماذج Markov المخفية (محاذاة HMM).  الفكرة الرئيسية هي أنه يمكنك حساب احتمال إنشاء زوج معين من المستندات باستخدام هذا النموذج <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وخوارزمية إعادة التوجيه</a> : في هذه الحالة ، تكون الحالة عبارة عن بادئات من المستندات.  وفقًا لذلك ، يمكن حساب الاحتمال المطلوب لمحاذاة زوج معين من الجمل المتوازية بواسطة خوارزمية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأمام والخلف</a> . <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">قانون</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;vector&gt; double p_h, p_d, p_i, p_tr, p_ss, p_st, mu_s, sigma_s, mu_t, sigma_t; double lognorm_cdf(double x, double mu, double sigma) { if (x &lt; 1e-9) return 0.0; double res = std::log(x) - mu; res /= std::sqrt(2.0) * sigma; res = 0.5 * (1 + std::erf(res)); return res; } double length_probability(int l, double mu, double sigma) { return lognorm_cdf(l, mu, sigma) - lognorm_cdf(l - 1, mu, sigma); } double translation_probability(int ls, int lt) { double res = length_probability(ls, mu_s, sigma_s); double mu = mu_t - mu_s + std::log(ls); double sigma = std::sqrt(sigma_t * sigma_t - sigma_s * sigma_s); res *= length_probability(lt, mu, sigma); return res; } double split_probability(int l1, int l2, double mu, double sigma) { int l_sum = l1 + l2; double total_prob = 0.0; for (int i = 1; i &lt; l_sum; ++i) { total_prob += length_probability(i, mu, sigma) * length_probability(l_sum - i, mu, sigma); } return length_probability(l1, mu, sigma) * length_probability(l2, mu, sigma) / total_prob; } double log_prob10(int ls) { return std::log(p_d * length_probability(ls, mu_s, sigma_s)); } double log_prob01(int lt) { return std::log(p_i * length_probability(lt, mu_t, sigma_t)); } double log_prob11(int ls, int lt) { return std::log(p_tr * (1 - p_ss - p_st) * translation_probability(ls, lt)); } double log_prob21(int ls1, int ls2, int lt) { return std::log(p_tr * p_ss * split_probability(ls1, ls2, mu_s, sigma_s) * translation_probability(ls1 + ls2 - 1, lt)); } double log_prob12(int ls, int lt1, int lt2) { return std::log(p_tr * p_st * split_probability(lt1, lt2, mu_t, sigma_t) * translation_probability(ls, lt1 + lt2 - 1)); } double logsum(double v1, double v2) { double res = std::max(v1, v2); v1 -= res; v2 -= res; v1 = std::min(v1, v2); if (v1 &lt; -30) { return res; } return res + std::log(std::exp(v1) + 1.0); } double loginc(double* to, double from) { *to = logsum(*to, from); } constexpr double INF = 1e25; int main(void) { using std::cin; using std::cout; cin &gt;&gt; p_h &gt;&gt; p_d &gt;&gt; p_i &gt;&gt; p_ss &gt;&gt; p_st &gt;&gt; mu_s &gt;&gt; sigma_s &gt;&gt; mu_t &gt;&gt; sigma_t; p_tr = 1.0 - p_h - p_d - p_i; int Ns, Nt; cin &gt;&gt; Ns &gt;&gt; Nt; using std::vector; vector&lt;int&gt; ls(Ns), lt(Nt); for (int i = 0; i &lt; Ns; ++i) cin &gt;&gt; ls[i]; for (int i = 0; i &lt; Nt; ++i) cin &gt;&gt; lt[i]; vector&lt; vector&lt; double&gt; &gt; fwd(Ns + 1, vector&lt;double&gt;(Nt + 1, -INF)), bwd = fwd; fwd[0][0] = 0; bwd[Ns][Nt] = 0; for (int i = 0; i &lt;= Ns; ++i) { for (int j = 0; j &lt;= Nt; ++j) { if (i &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j] + log_prob10(ls[i - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j] + log_prob10(ls[Ns - i])); } if (j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i][j - 1] + log_prob01(lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i][Nt - j + 1] + log_prob01(lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 1] + log_prob11(ls[i - 1], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 1] + log_prob11(ls[Ns - i], lt[Nt - j])); } if (i &gt;= 2 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 2][j - 1] + log_prob21(ls[i - 1], ls[i - 2], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 2][Nt - j + 1] + log_prob21(ls[Ns - i], ls[Ns - i + 1], lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 2) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 2] + log_prob12(ls[i - 1], lt[j - 1], lt[j - 2])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 2] + log_prob12(ls[Ns - i], lt[Nt - j], lt[Nt - j + 1])); } } } int j, k; cin &gt;&gt; j &gt;&gt; k; double rlog = fwd[j - 1][k - 1] + bwd[j][k] + log_prob11(ls[j - 1], lt[k - 1]) - bwd[0][0]; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12) &lt;&lt; std::exp(rlog) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><h2 style=";text-align:right;direction:rtl">  الشريط من التوصيات </h2><br><h4 style=";text-align:right;direction:rtl">  حالة </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  المهلة </td><td>  2 ثانية </td></tr><tr><td>  حد الذاكرة </td><td>  64 ميغابايت </td></tr><tr><td>  دخول </td><td>  المدخلات القياسية أو المدخلات </td></tr><tr><td>  استنتاج </td><td>  الإخراج القياسي أو الإخراج </td></tr></tbody></table></div>  النظر في موجز للتوصيات لمحتوى غير متجانسة.  يمزج الكائنات من أنواع مختلفة (الصور ومقاطع الفيديو والأخبار وما إلى ذلك).  عادةً ما يتم ترتيب هذه الكائنات حسب صلتها بالمستخدم: كلما كان الكائن (المستخدم) الأكثر صلة بالموضوع ، كلما اقتربنا من أعلى قائمة التوصيات.  ومع ذلك ، مع مثل هذا الترتيب ، تنشأ مواقف غالبًا تظهر فيها عدة كائنات من نفس النوع في قائمة التوصيات.  يؤدي هذا إلى تفاقم التنوع الخارجي لتوصياتنا إلى حد كبير وبالتالي لا يحب المستخدمون ذلك.  من الضروري تنفيذ خوارزمية ، وفقًا لقائمة التوصيات ، ستشكل قائمة جديدة ستكون خالية من هذه المشكلة وستكون ذات صلة. <br><br>  اسمح بقائمة أولية من التوصيات: = [a <sub>0</sub> ، a <sub>1</sub> ، ...، <sub>n - 1</sub> ] من الطول n&gt; 0. كائن برقم <sub>i</sub> كتبته بالرقم b <sub>i</sub> 0 {0، ...، m - 1}.  بالإضافة إلى ذلك ، يوجد كائن تحت الرقم i ذو صلة r (a <sub>i</sub> ) = 2 <sub>−i</sub> .  النظر في القائمة التي تم الحصول عليها من القائمة الأولية عن طريق اختيار مجموعة فرعية من الكائنات والتقليب: x = [a <sub>i <sub>0</sub></sub> ، <sub>i i <sub>1</sub></sub> ، ...، <sub>i <sub>k - 1</sub></sub> ] من الطول k (0 ≤ k ≤ n).  تُدعى قائمة مقبولة إذا لم يتزامن وجود كائنين متتاليين في النوع ، أي ، b <sub>i <sub>j</sub></sub> ≠ b <sub>i <sub>j + 1</sub></sub> للجميع j = 0 ، ... ، k - 2.  يتم احتساب أهمية القائمة من خلال الصيغة <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.112ex" height="3.503ex" viewBox="0 -987.6 7367.6 1508.3" role="img" focusable="false" style="vertical-align: -1.209ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-6D" x="0" y="0"></use><g transform="translate(878,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-6A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-3D" x="412" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-30" x="1191" y="0"></use></g></g><g transform="translate(3543,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-6A" x="778" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-72" x="4986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-28" x="5437" y="0"></use><g transform="translate(5827,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMATHI-6A" x="488" y="-213"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhjDtsBiwHp0muew7_BXTZADrlF_Ag#MJMAIN-29" x="6978" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ sum_ {j = 0} ^ {k-1} 2 _ {- j} r (a_ {i_j}) </script>  .  تحتاج إلى العثور على قائمة الصلة القصوى بين جميع صالحة. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">I / O التنسيقات والأمثلة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><h4 style=";text-align:right;direction:rtl">  تنسيق الإدخال </h4><br>  في السطر الأول ، تتم كتابة الأرقام n و m بمسافة (1 ≤ n ≤ 100000 ، 1 ≤ m ≤ n).  تحتوي الأسطر n التالية على الأرقام b <sub>i</sub> لـ i = 0 ، ... ، n - 1 (0 ≤ b <sub>i</sub> ≤ m - 1). <br><br><h4 style=";text-align:right;direction:rtl">  تنسيق الإخراج </h4><br>  اكتب ، بمسافة ، عدد الكائنات في القائمة النهائية: i <sub>0</sub> ، i <sub>1</sub> ، ... ، i <sub>k - 1</sub> . <br><br><h4 style=";text-align:right;direction:rtl">  مثال 1 </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>1 1 <br> 0</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  مثال 2 </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>2 2 <br> 1 <br> 1</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  مثال 3 </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>10 2 <br> 1 <br> 1 <br> 1 <br> 0 <br> 0 <br> 1 <br> 0 <br> 1 <br> 1 <br> 1</code> </td> <td> <code>0 3 1 4 2 6 5</code> </td> </tr></tbody></table></div></div></div><br><h4 style=";text-align:right;direction:rtl">  قرار </h4><br>  باستخدام حسابات رياضية بسيطة ، يمكن إثبات أن المشكلة يمكن حلها من خلال نهج "جشع" ، أي في القائمة المثلى للتوصيات ، كل عنصر لديه الكائن الأكثر صلة بكل ما هو صالح في بداية نفس القائمة.  تنفيذ هذا النهج بسيط: نأخذ الأشياء على التوالي ونضيفها إلى الإجابة ، إن أمكن.  عندما تتم مصادفة كائن غير صالح (يتزامن نوعه مع نوع العنصر السابق) ، فإننا نضعه جانباً في قائمة انتظار منفصلة ، نقوم بإدخاله في الاستجابة في أقرب وقت ممكن.  لاحظ أنه في كل لحظة من الزمن ، سيكون لكل الكائنات في قائمة الانتظار نوع مطابق.  في النهاية ، قد تبقى عدة كائنات في قائمة الانتظار ، ولن يتم تضمينها في الاستجابة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; blend(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; types) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; repeated; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.empty() || types[result.back()] != types[i]) { result.push_back(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!repeated.empty() &amp;&amp; types[repeated.front()] != types[result.back()]) { result.push_back(repeated.front()); repeated.pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { repeated.push(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  D. تجميع تسلسل الأحرف </h2><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td></td><td>  <b>كل اللغات</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  المهلة </td><td>  1 ثانية </td><td>  6 ق </td><td>  6 ق </td></tr><tr><td>  حد الذاكرة </td><td>  64 ميغابايت </td><td>  64 ميغابايت </td><td>  64 ميغابايت </td></tr><tr><td>  دخول </td><td colspan="3">  المدخلات القياسية أو المدخلات </td></tr><tr><td>  استنتاج </td><td colspan="3">  الإخراج القياسي أو الإخراج </td></tr></tbody></table></div>  هناك أبجدية محددة A = {a <sub>1</sub> ، a <sub>2</sub> ، ...، <sub>K - 1</sub> ، a <sub>K</sub> = S}، a ∈ {a، b، ...، z}، S هي نهاية السطر. <br><br>  النظر في الطريقة التالية لإنشاء سلاسل عشوائية على الأبجدية A: <br><br>  1. الحرف الأول x <sub>1</sub> هو متغير عشوائي مع التوزيع P (x <sub>1</sub> = a <sub>i</sub> ) = q <sub>i</sub> (من المعروف أن q <sub>K</sub> = 0). <br>  2. يتم إنشاء كل حرف تالي بناءً على الحرف السابق وفقًا للتوزيع الشرطي P (x <sub>i</sub> = a <sub>j</sub> || x <sub>i - 1</sub> = a <sub>l</sub> ) = p <sub>jl</sub> . <br>  3. إذا كانت x <sub>i</sub> = S ، يتوقف الجيل وتكون النتيجة x <sub>1</sub> × <sub>2</sub> ... x <sub>i - 1</sub> . <br><br>  يتم توفير مجموعة من الخطوط الناتجة من مزيج من نموذجين الموصوفة مع معلمات مختلفة.  من الضروري أن يعطي كل صف فهرس السلسلة التي تم إنشاؤه منها. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تنسيقات I / O ، مثال ، وملاحظات</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><h4 style=";text-align:right;direction:rtl">  تنسيق الإدخال </h4><br>  يحتوي السطر الأول على رقمين 1000 ≤ N ≤ 2000 و 3 ≤ K ≤ 27 - عدد الخطوط وحجم الأبجدية ، على التوالي. <br><br>  يحتوي السطر الثاني على سطر يتكون من K - 1 بأحرف صغيرة مختلفة من الأبجدية اللاتينية ، يشير إلى العناصر K - 1 الأولى من الأبجدية. <br><br>  يتم إنشاء كل سطر من الأسطر N التالية وفقًا للخوارزمية الموضحة في الشرط. <br><br><h4 style=";text-align:right;direction:rtl">  تنسيق الإخراج </h4><br>  أسطر N ، يحتوي السطر i على رقم الكتلة (0/1) للتسلسل على السطر i + 1-th لملف الإدخال.  يجب أن تكون مصادفة الإجابة الحقيقية 80٪ على الأقل. <br><br><h4 style=";text-align:right;direction:rtl">  مثال </h4><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>دخول</b> </td><td>  <b>استنتاج</b> </td></tr><tr><td> <code>100 3 <br> a <br> a <br> aa <br> a <br> aaa <br> a <br> aaaaaa <br> aa <br> a <br> a <br> a <br> aaa <br> a <br> a <br> aaa <br> aa <br> aaaa <br> aaa <br> a <br> aaaaa <br> aa <br> a <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaaa <br> aaa <br> a <br> aa <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaa <br> aaa <br> a <br> a <br> bbb <br> bb <br> bb <br> bbbbbbb <br> bb <br> bbb <br> b <br> bbbbbbb <br> bbbb <br> bbb <br> bb <br> bbb <br> bb <br> bb <br> bbb <br> bbbbbb <br> bbb <br> b <br> bbbbbb <br> b <br> bbbbb <br> b <br> b <br> bb <br> b <br> bb <br> bb <br> b <br> b <br> b <br> b <br> bb <br> bb <br> bb <br> b <br> b <br> b <br> bb <br> b <br> bbb <br> bb <br> b <br> bbbbbb <br> b <br> bb <br> bb <br> bb <br> b <br> bb <br> bbb</code> </td> <td> <code>0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1</code> </td> </tr></tbody></table></div><h4 style=";text-align:right;direction:rtl">  الملاحظات </h4><br>  ملاحظة للاختبار من الشرط: فيه يتم إنشاء الخطوط 50 الأولى من التوزيع <br>  P (x <sub>i</sub> = a | x <sub>i - 1</sub> = a) = 0.5، P (x <sub>i</sub> = S | x <sub>i - 1</sub> = a) = 0.5، P (x <sub>1</sub> = a) = 1؛  50 الثانية - من التوزيع <br>  P (x <sub>i</sub> = b | x <sub>i - 1</sub> = b) = 0.5، P (x <sub>i</sub> = S | x <sub>i - 1</sub> = b) = 0.5، P (x <sub>1</sub> = b) = 1. </div></div><br><h4 style=";text-align:right;direction:rtl">  قرار </h4><br>  تم حل المشكلة باستخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">خوارزمية EM</a> : من المفترض أن يتم إنشاء العينة المقدمة من خليط من اثنين من سلاسل Markov التي يتم استعادة المعلمات أثناء التكرار.  تم وضع قيود بنسبة 80٪ من الإجابات الصحيحة بحيث لا تتأثر صحة الحل بأمثلة ذات احتمال كبير في كلتا السلسلتين.  لذلك ، عند استعادة هذه الأمثلة بشكل صحيح ، يمكن تعيينها إلى سلسلة غير صحيحة من حيث الاستجابة التي تم إنشاؤها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math EPS = <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, cols)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [empty_row(cols) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span><span class="hljs-function">:</span></span> row_sum = sum(row) + EPS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x / row_sum <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mtx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [normalized_row(r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mtx] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphabet, string_samples)</span></span></span><span class="hljs-function">:</span></span> n_tokens = len(alphabet) n_samples = len(string_samples) samples = [tuple([alphabet.index(token) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] + [n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>, n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string_samples] probs = [random.random() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_samples)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>): old_probs = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> probs] <span class="hljs-comment"><span class="hljs-comment"># probs fixed p0, A = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) q0, B = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) for prob, sample in zip(probs, samples): p0[sample[0]] += prob q0[sample[0]] += 1 - prob for t1, t2 in zip(sample[:-1], sample[1:]): A[t1][t2] += prob B[t1][t2] += 1 - prob A, p0 = normalized_matrix(A), normalized_row(p0) B, q0 = normalized_matrix(B), normalized_row(q0) trans_log_diff = [ [math.log(b + EPS) - math.log(a + EPS) for b, a in zip(B_r, A_r)] for B_r, A_r in zip(B, A) ] # A, p0, B, q0 fixed probs = empty_row(n_samples) for i, sample in enumerate(samples): value = math.log(q0[sample[0]] + EPS) - math.log(p0[sample[0]] + EPS) for t1, t2 in zip(sample[:-1], sample[1:]): value += trans_log_diff[t1][t2] probs[i] = 1.0 / (1.0 + math.exp(value)) if max(abs(x - y) for x, y in zip(probs, old_probs)) &lt; 1e-9: break return [int(x &gt; 0.5) for x in probs] def main(): N, K = list(map(int, input().split())) string_samples = [] alphabet = list(input().strip()) + [''] for _ in range(N): string_samples.append(input().rstrip()) result = restore_params(alphabet, string_samples) for r in result: print(r) if __name__ == '__main__': main()</span></span></code> </pre> <br><hr><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar461273/">https://habr.com/ru/post/ar461273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar461261/index.html">قائمة التحقق من ندوات RRC مفيدة على منتجات RRC</a></li>
<li><a href="../ar461265/index.html">حول إساءة استخدام نظام التشغيل في مشاريع ميكروكنترولر</a></li>
<li><a href="../ar461267/index.html">تقنيات إنتل الجديدة لتغليف الرقائق</a></li>
<li><a href="../ar461269/index.html">حل المشكلة مع pwnable.kr 08 هو الساق و 10 هو الصدمة. مجمع أرمينيا. باش الضعف</a></li>
<li><a href="../ar461271/index.html">كيفية الترويج لتطبيق الهاتف المحمول في 2019: 4 طرق عملية + أدوات مفيدة</a></li>
<li><a href="../ar461277/index.html">نظرة عامة على أداة SQLIndexManager المجانية</a></li>
<li><a href="../ar461279/index.html">كيفية إنشاء خدمة microservice بسيطة على Golang و gRPC وحاوياتها باستخدام Docker</a></li>
<li><a href="../ar461281/index.html">تجول لإعداد خادم BIND DNS في بيئة chroot لـ Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../ar461283/index.html">هندسة البرمجيات وتصميم النظام: The Big Picture and Resource Guide</a></li>
<li><a href="../ar461285/index.html">5 خوارزميات أخذ العينات الرئيسية</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>