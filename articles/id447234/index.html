<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗞️ ➗ ⛱️ Cara menulis program polimorfik menggunakan Arrow 🤹 🥥 🏧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Nama saya Artyom Dobrovinsky, saya bekerja untuk Finch . Saya sarankan membaca artikel oleh salah satu bapak perpustakaan pemrograman f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menulis program polimorfik menggunakan Arrow</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447234/"><img src="https://habrastorage.org/webt/va/-y/jh/va-yjhqxdrghleli7gqzgt553r0.png"><br><br>  Halo, Habr! <br><br>  Nama saya Artyom Dobrovinsky, saya bekerja untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Finch</a> .  Saya sarankan membaca artikel oleh salah satu bapak perpustakaan pemrograman fungsional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Arrow</code></a> tentang cara menulis program polimorfik.  Seringkali orang yang baru mulai menulis dengan gaya fungsional tidak terburu-buru berpisah dengan kebiasaan lama, dan bahkan menulis imperatif yang sedikit lebih elegan, dengan wadah DI dan pewarisan.  Gagasan menggunakan kembali fungsi terlepas dari jenis yang mereka gunakan mungkin mendorong banyak orang untuk berpikir ke arah yang benar. <br><p>  Selamat menikmati! </p><a name="habracut"></a><br><h3>  *** </h3><br><p>  Bagaimana jika kita dapat menulis aplikasi tanpa memikirkan jenis data yang akan digunakan dalam runtime, tetapi cukup jelaskan bagaimana data ini akan diproses? </p><br><p>  Bayangkan kita memiliki aplikasi yang bekerja dengan tipe <code>Observable</code> dari perpustakaan RxJava.  Jenis ini memungkinkan kita untuk menulis rantai panggilan dan manipulasi dengan data, tetapi pada akhirnya, akankah <code>Observable</code> ini tidak hanya menjadi wadah dengan properti tambahan? </p><br><p>  Kisah yang sama dengan tipe-tipe seperti <code>Flowable</code> , <code>Deferred</code> (Coroutines), <code>Future</code> , <code>IO</code> , dan banyak lainnya. </p><br><p>  Secara konseptual, semua jenis ini mewakili operasi (sudah dilakukan atau direncanakan untuk diimplementasikan di masa depan) yang mendukung manipulasi seperti melemparkan nilai internal ke jenis lain ( <code>map</code> ), menggunakan <code>flatMap</code> untuk membuat rantai operasi dari jenis yang sama, menggabungkan dengan contoh lain dari jenis yang sama ( <code>zip</code> ), dll. </p><br><p>  Untuk menulis program berdasarkan perilaku ini, sambil mempertahankan deskripsi deklaratif, dan juga untuk membuat program Anda independen dari tipe data spesifik seperti Dapat <code>Observable</code> cukup bahwa tipe data yang digunakan sesuai dengan kontrak tertentu, seperti <code>map</code> , <code>flatMap</code> , dan lain-lain . </p><br><p>  Pendekatan semacam itu mungkin terlihat aneh atau terlalu rumit, tetapi memiliki keuntungan menarik.  Pertama, pertimbangkan contoh sederhana, dan kemudian bicarakan. </p><cut></cut><br><h3 id="kanonicheskaya-problema">  Masalah kanonik </h3><br><p>  Misalkan kita memiliki aplikasi dengan to-do list, dan kami ingin mengekstraksi daftar objek bertipe <code>Task</code> dari cache lokal.  Jika tidak ditemukan di penyimpanan lokal, kami akan mencoba untuk menanyakannya melalui jaringan.  Kami membutuhkan kontrak tunggal untuk kedua sumber data sehingga keduanya bisa mendapatkan daftar objek bertipe <code>Task</code> untuk objek <code>User</code> sesuai, terlepas dari sumbernya: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Di sini, untuk kesederhanaan, kami mengembalikan <code>Observable</code> , tetapi dapat berupa <code>Single</code> , <code>Maybe</code> , <code>Flowable</code> , <code>Deferred</code> - apa pun yang cocok untuk mencapai tujuan. </p><br><p>  Tambahkan beberapa implementasi sumber data moka, satu untuk <code></code> dan satu untuk <code></code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val localCache: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cachedUser = localCache[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(cachedUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInLocalStorage(user)) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val internetStorage: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> networkUser = internetStorage[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (networkUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(networkUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInRemoteStorage(user)) } } }</code> </pre> <br><p>  Implementasi dari kedua sumber data hampir identik.  Ini hanyalah versi tiruan dari sumber-sumber ini yang idealnya menarik data dari penyimpanan lokal atau API jaringan.  Dalam kedua kasus, <code>Map&lt;User, List&lt;Task&gt;&gt;</code> digunakan untuk menyimpan data. </p><br><p>  Karena  kami memiliki dua sumber data, kami perlu mengoordinasikannya.  Buat repositori: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = localDS.allTasksByUser(user) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.computation()) .onErrorResumeNext { _: Throwable -&gt; remoteDS.allTasksByUser(user) } }</code> </pre> <br><p>  Itu hanya mencoba memuat <code>List&lt;Task&gt;</code> dari <code>LocalDataSource</code> , dan jika tidak ditemukan, ia mencoba untuk meminta mereka dari jaringan menggunakan <code>RemoteDataSource</code> . </p><br><p>  Mari kita membuat modul sederhana untuk menyediakan dependensi tanpa menggunakan kerangka kerja untuk injeksi dependensi (DI): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource = LocalDataSource() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource = RemoteDataSource() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository = TaskRepository(localDataSource, remoteDataSource) }</code> </pre> <br><p>  Dan akhirnya, kita membutuhkan tes sederhana yang menjalankan seluruh tumpukan operasi: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dependenciesModule = Module() dependenciesModule.run { repository.allTasksByUser(user1).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user2).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user3).subscribe({ println(it) }, { println(it) }) } } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semua kode di atas dapat ditemukan di github</a> . </p><br><p>  Program ini menyusun rantai eksekusi untuk tiga pengguna, kemudian berlangganan <code>Observable</code> dihasilkan. </p><br><p>  Dua objek pertama dari tipe <code>User</code> tersedia, dengan ini kami beruntung.  <code>User1</code> tersedia di <code>DataSource</code> lokal, dan <code>User2</code> tersedia di remote. </p><br><p>  Tetapi ada masalah dengan <code>User3</code> , karena tidak tersedia di penyimpanan lokal.  Program akan mencoba mengunduhnya dari layanan jarak jauh - tetapi tidak juga ada di sana.  Pencarian akan gagal, dan kami akan menampilkan pesan kesalahan di konsol. </p><br><p>  Inilah yang akan ditampilkan di konsol untuk ketiga kasus: </p><br><pre> <code class="plaintext hljs">&gt; [Task(value=LocalTask assigned to user1)] &gt; [Task(value=Remote Task assigned to user2)] &gt; UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Kita selesai dengan sebuah contoh.  Sekarang mari kita coba program logika ini dengan gaya <code> </code> . </p><br><h3 id="abstragirovanie-tipov-dannyh">  Abstraksi Tipe Data </h3><br><p>  Sekarang kontrak untuk antarmuka <code>DataSource</code> akan terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Semuanya tampak serupa, tetapi ada dua perbedaan penting: </p><br><ul><li>  Ada ketergantungan pada tipe umum (generik) <code>F</code> </li><li>  Jenis yang dikembalikan oleh fungsi sekarang adalah <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </li></ul><br><p>  <code>Kind</code> adalah bagaimana Panah mengkodekan apa yang biasa disebut <code>  (higher kind)</code> . <br>  Saya akan menjelaskan konsep ini dengan contoh sederhana. </p><br><p>  <code>Observable&lt;A&gt;</code> memiliki 2 bagian: </p><br><ul><li>  <code>Observable</code> : wadah, tipe tetap. </li><li>  <code>A</code> : argumen tipe generik.  Sebuah abstraksi yang dapat dilewati oleh tipe lain. </li></ul><br><p>  Kita terbiasa mengambil tipe generik seperti <code>A</code> sebagai abstraksi.  Tetapi tidak banyak orang yang tahu bahwa kita juga bisa mengabstraksikan jenis wadah seperti <code>Observable</code> .  Untuk ini, ada tipe yang tinggi. </p><br><p>  Idenya adalah bahwa kita dapat memiliki konstruktor seperti <code>F&lt;A&gt;</code> di mana <code>F</code> dan <code>A</code> dapat menjadi tipe generik.  Sintaks ini belum didukung oleh kompiler Kotlin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masih?</a> ), Jadi kami akan menirunya dengan pendekatan yang sama. </p><br><p>  Panah mendukung ini melalui penggunaan antarmuka meta perantara <code>Kind&lt;F, A&gt;</code> , yang berisi tautan ke kedua jenis, dan juga menghasilkan konverter di kedua arah selama kompilasi sehingga Anda dapat mengikuti jalur dari <code>Kind&lt;Observable, List&lt;Task&gt;&gt;</code> ke <code>Observable&lt;List&lt;Task&gt;&gt;</code> dan sebaliknya.  Bukan solusi yang ideal, tetapi solusi yang berhasil. </p><br><p>  Jadi sekali lagi, lihat antarmuka repositori kami: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Fungsi <code>DataSource</code> mengembalikan tipe tinggi: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  Ini diterjemahkan ke <code>F&lt;List&lt;Task&gt;&gt;</code> , di mana <code>F</code> tetap digeneralisasi. </p><br><p>  Kami hanya menangkap <code>List&lt;Task&gt;</code> di tanda tangan.  Dengan kata lain, kami tidak peduli jenis wadah <code>F</code> apa yang akan digunakan, asalkan berisi <code>List&lt;Task&gt;</code> .  Kami dapat mengirimkan wadah data yang berbeda ke fungsi.  Sudah jelas?  Silakan. </p><br><p>  Mari kita lihat <code>DataSource</code> diimplementasikan dengan cara ini, tetapi kali ini untuk masing-masing individu.  Pertama ke lokal: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  Banyak hal baru telah ditambahkan, kami akan menganalisis semuanya langkah demi langkah. </p><br><p>  <code>DataSource</code> ini mempertahankan tipe <code>F</code> generik karena mengimplementasikan <code>DataSource&lt;F&gt;</code> .  Kami ingin menjaga kemungkinan mentransmisikan jenis ini dari luar. </p><br><p>  Sekarang, lupakan <code>ApplicativeError</code> mungkin tidak dikenal di konstruktor dan fokus pada fungsi <code>allTasksByUser()</code> .  Dan kami akan kembali ke <code>ApplicativeError</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } )</code> </pre> <br><p>  Dapat dilihat bahwa ia mengembalikan <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  Kami masih tidak peduli apa wadah <code>F</code> asalkan berisi <code>List&lt;Task&gt;</code> . </p><br><p>  Tapi ada masalah.  Bergantung pada apakah kita dapat menemukan daftar objek <code>Task</code> untuk pengguna yang diinginkan di penyimpanan lokal atau tidak, kami ingin melaporkan kesalahan (tidak ada <code>Task</code> ditemukan) atau mengembalikan <code>Task</code> sudah dibungkus dalam <code>F</code> ( <code>Task</code> ditemukan). </p><br><p>  Dan untuk kedua kasus, kami harus mengembalikan: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </p><br><p>  Dengan kata lain: ada tipe yang tidak kita ketahui tentang ( <code>F</code> ), dan kita perlu cara untuk mengembalikan kesalahan yang terbungkus dalam tipe itu.  Plus, kita membutuhkan cara untuk membuat instance dari tipe ini, di mana nilai yang diperoleh setelah fungsi yang berhasil diselesaikan akan dibungkus.  Kedengarannya seperti sesuatu yang mustahil? </p><br><p>  Mari kita kembali ke deklarasi kelas dan perhatikan bahwa <code>ApplicativeError</code> diteruskan ke konstruktor dan kemudian digunakan sebagai delegasi untuk kelas ( <code>by A</code> ). </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ApplicativeError</code></a> diwarisi dari <code>Applicative</code> , keduanya adalah kelas tipe. </p><br><p>  Tipe kelas mendefinisikan perilaku (kontrak).  Mereka dikodekan sebagai antarmuka yang bekerja dengan argumen dalam bentuk tipe generik, seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Monad&lt;F&gt;</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Functor&lt;F&gt;</code></a> dan banyak lainnya.  <code>F</code> ini adalah tipe data.  Dengan cara ini, kita dapat melewatkan tipe seperti <code>Either</code> , <code>Option</code> , <code>IO</code> , <code>Observable</code> , <code>Flowable</code> dan banyak lagi. </p><br><p>  Jadi, kembali ke dua masalah kita: </p><br><ul><li>  Bungkus nilai yang diperoleh setelah fungsi selesai dengan sukses di <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  Untuk ini, kita dapat menggunakan kelas jenis <code>Applicative</code> .  Karena <code>ApplicativeError</code> diwarisi darinya, kami dapat mendelegasikan propertinya. </p><br><p>  <code>Applicative</code> hanya menyediakan fungsi <code>just(a)</code> .  <code>just(a)</code> membungkus nilai dalam konteks tipe tinggi apa pun.  Jadi, jika kita memiliki <code>Applicative&lt;F&gt;</code> , itu bisa memanggil <code>just(a)</code> untuk membungkus nilai dalam wadah <code>F</code> , apa pun nilainya.  Katakanlah kita menggunakan <code>Observable</code> , kita akan memiliki <code>Applicative&lt;Observable&gt;</code> yang tahu cara membungkus suatu <code>Observable</code> , sehingga kita mendapatkan <code>Observable.just(a)</code> . </p><br><ul><li>  Bungkus kesalahan dalam contoh <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  Untuk ini kita dapat menggunakan <code>ApplicativeError</code> .  Ini menyediakan fungsi <code>raiseError(e)</code> , yang membungkus kesalahan dalam wadah tipe <code>F</code>  Sebagai contoh yang <code>Observable</code> , kesalahan akan membuat sesuatu seperti <code>Observable.error&lt;A&gt;(t)</code> , di mana <code>t</code> adalah <code>Throwable</code> , karena kami menyatakan jenis kesalahan kami sebagai kelas tipe <code>ApplicativeError&lt;F, Throwable&gt;</code> . </p><br><p>  Lihatlah implementasi abstrak dari <code>LocalDataSource&lt;F&gt;</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  <code>Map&lt;User, List&lt;Task&gt;&gt;</code> tersimpan dalam memori tetap sama, tetapi sekarang fungsinya melakukan beberapa hal yang mungkin baru bagi Anda: </p><br><ul><li><p>  Dia mencoba memuat daftar <code>Task</code> dari cache lokal, dan karena nilai kembali mungkin <code>null</code> ( <code>Task</code> mungkin tidak ditemukan), kami memodelkan ini dengan menggunakan <code>Option</code> .  Jika tidak jelas cara kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Option</code></a> , maka ia memodelkan ada atau tidaknya nilai yang dibungkus di dalamnya. </p><br></li><li><p>  Setelah menerima nilai opsional, kami menyebutnya <code>fold</code> di atasnya.  Ini sama dengan menggunakan <code>when</code> atas nilai opsional.  Jika nilainya hilang, maka <code>Option</code> membungkus kesalahan dalam tipe data <code>F</code> (lambda pertama berlalu).  Dan jika nilainya ada, <code>Option</code> membuat instance wrapper untuk tipe data <code>F</code> (lambda kedua).  Dalam kedua kasus, properti <code>ApplicativeError</code> yang disebutkan sebelumnya digunakan: <code>raiseError()</code> dan <code>just()</code> . </p><br></li></ul><br><p>  Dengan demikian, kami mengabstraksi implementasi sumber data menggunakan kelas sehingga mereka tidak tahu wadah mana yang akan digunakan untuk tipe <code>F</code> . </p><br><p>  Menerapkan jaringan <code>DataSource</code> terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) : DataSource&lt;F&gt;, Async&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> internetStorage: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) } }</code> </pre> <br><p>  Tetapi ada satu perbedaan kecil: alih-alih mendelegasikan ke instance <code>ApplicativeError</code> , kita menggunakan kelas lain seperti: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Async</code></a> . </p><br><p>  Ini karena panggilan jaringan bersifat tidak sinkron.  Kami ingin menulis kode yang akan dieksekusi secara tidak sinkron, adalah logis untuk menggunakan kelas tipe yang dirancang untuk ini. </p><br><p>  <code>Async</code> digunakan untuk mensimulasikan operasi asinkron.  Itu dapat mensimulasikan operasi panggilan balik.  Perhatikan bahwa kita masih tidak tahu tipe data spesifik, kita cukup menggambarkan operasi yang asinkron. </p><br><p>  Pertimbangkan fungsi berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) }</code> </pre> <br><p>  Kita dapat menggunakan fungsi <code>async {}</code> , yang disediakan kelas tipe <code>Async</code> untuk mensimulasikan operasi dan membuat turunan dari jenis <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> yang akan dibuat secara tidak sinkron. </p><br><p>  Jika kami menggunakan tipe data tetap seperti <code>Observable</code> , <code>Async.async {}</code> akan setara dengan <code>Observable.create()</code> , i.e.  membuat operasi yang dapat dipanggil dari kode sinkron atau asinkron, seperti <code>Thread</code> atau <code>AsyncTask</code> . </p><br><p>  Parameter <code>callback</code> digunakan untuk menghubungkan panggilan balik yang dihasilkan dengan konteks wadah <code>F</code> , yang merupakan tipe tinggi. </p><br><p>  Dengan demikian, <code>RemoteDataSource</code> kami diabstraksikan dan tergantung pada wadah tipe <code>F</code> masih belum diketahui <code>F</code> </p><br><p>  Mari kita naik ke level abstraksi dan melihat lagi di repositori kami.  Jika Anda ingat, pertama-tama kita perlu mencari objek <code>Task</code> di <code>LocalDataSource</code> , dan hanya kemudian (jika mereka tidak ditemukan secara lokal) untuk meminta mereka dari <code>RemoteLocalDataSource</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource&lt;F&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource&lt;F&gt;, AE: ApplicativeError&lt;F, Throwable&gt;) : ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> AE { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } } }</code> </pre> <br><p>  <code>ApplicativeError&lt;F, Throwable&gt;</code> ada bersama kami lagi!  Ini juga menyediakan fungsi <code>handleErrorWith()</code> yang bekerja di atas semua penerima kelas atas. </p><br><p>  Ini terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> Kind</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;F, A&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">E</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; Kind&lt;F, A&gt;): Kind&lt;F, A&gt;</code> </pre> <br><p>  Karena  <code>localDS.allTasksByUser(user)</code> mengembalikan <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> , yang dapat dianggap sebagai <code>F&lt;List&lt;Task&gt;&gt;</code> , di mana <code>F</code> tetap menjadi tipe generik, kita dapat memanggil <code>handleErrorWith()</code> di atasnya. </p><br><p>  <code>handleErrorWith()</code> memungkinkan Anda untuk merespons kesalahan menggunakan lambda yang diteruskan.  Mari kita lihat lebih dekat fungsi: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } }</code> </pre> <br><p>  Dengan demikian, kami mendapatkan hasil dari operasi pertama, kecuali ketika pengecualian dilemparkan.  Pengecualian akan ditangani oleh lambda.  Jika kesalahan itu milik tipe <code>UserNotInLocalStorage</code> , kami akan mencoba untuk menemukan objek jenis <code>Tasks</code> di <code>UserNotInLocalStorage</code> jarak jauh.  Dalam semua kasus lain, kami membungkus kesalahan yang tidak diketahui dalam wadah tipe <code>F</code> </p><br><p>  Modul dependensi tetap sangat mirip dengan versi sebelumnya: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource&lt;F&gt; = LocalDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource&lt;F&gt; = RemoteDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository&lt;F&gt; = TaskRepository(localDataSource, remoteDataSource, A) }</code> </pre> <br><p>  Satu-satunya perbedaan adalah bahwa sekarang abstrak dan tergantung pada <code>F</code> , yang tetap polimorfik.  Saya sengaja tidak memperhatikan hal ini untuk mengurangi tingkat kebisingan, tetapi <code>Async</code> diwarisi dari <code>ApplicativeError</code> , oleh karena itu ia dapat digunakan sebagai contohnya di semua tingkat pelaksanaan program. </p><br><h3 id="testiruya-polimorfizm">  Menguji polimorfisme </h3><br><p>  Akhirnya, aplikasi kita sepenuhnya diabstraksi dari penggunaan tipe data spesifik untuk container ( <code>F</code> ) dan kita bisa fokus pada pengujian polyformism di runtime.  Kami akan menguji bagian kode yang sama dengan meneruskan berbagai jenis data ke tipe <code>F</code>  Skenarionya sama dengan ketika kita menggunakan <code>Observable</code> . </p><br><p>  Program ini ditulis sedemikian rupa sehingga kami sepenuhnya menghilangkan batasan abstraksi dan dapat menyampaikan detail implementasi yang diinginkan. </p><br><p>  Pertama, mari kita coba menggunakan <code>F</code> <code>Single</code> dari RxJava sebagai wadah. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> singleModule = Module(SingleK.async()) singleModule.run { repository.allTasksByUser(user1).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().single.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Untuk kompatibilitas, Arrow menyediakan pembungkus untuk tipe data perpustakaan yang terkenal.  Misalnya, ada pembungkus <code>SingleK</code> praktis.  Wrappers ini memungkinkan Anda untuk menggunakan kelas tipe bersama dengan tipe data sebagai tipe tinggi. </p><br><p>  Berikut ini akan ditampilkan di konsol: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Hasil yang sama akan jika menggunakan <code>Observable</code> . </p><br><p>  Sekarang mari kita bekerja dengan <code>Maybe</code> , untuk itu <code>MaybeK</code> bungkus <code>MaybeK</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> maybeModule = Module(MaybeK.async()) maybeModule.run { repository.allTasksByUser(user1).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().maybe.subscribe(::println, ::println) } }</code> </pre> <br><p>  Hasil yang sama akan ditampilkan di konsol, tetapi sekarang menggunakan tipe data yang berbeda: </p><br><pre> <code class="kotlin hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Bagaimana dengan <code>ObservableK</code> / <code>FlowableK</code> ? <br>  Mari kita coba: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observableModule = Module(ObservableK.async()) observableModule.run { repository.allTasksByUser(user1).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().observable.subscribe(::println, ::println) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> flowableModule = Module(FlowableK.async()) flowableModule.run { repository.allTasksByUser(user1).fix().flowable.subscribe(::println) repository.allTasksByUser(user2).fix().flowable.subscribe(::println) repository.allTasksByUser(user3).fix().flowable.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Kita akan melihat di konsol: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))) [Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Semuanya berfungsi seperti yang diharapkan. </p><br><p>  Mari kita coba gunakan <code>DeferredK</code> , pembungkus untuk tipe <code>kotlinx.coroutines.Deferred</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModule = Module(DeferredK.async()) deferredModule.run { runBlocking { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { println(repository.allTasksByUser(user1).fix().deferred.await()) println(repository.allTasksByUser(user2).fix().deferred.await()) println(repository.allTasksByUser(user3).fix().deferred.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: UserNotInRemoteStorage) { println(e) } } } } }</code> </pre> <br><p>  Seperti yang Anda ketahui, penanganan pengecualian saat menggunakan corutin harus ditentukan secara eksplisit.   ,        ,        . </p><br><p>   —   : </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Arrow   API     <code>DeferredK</code> .     <code>runBlocking</code>     : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModuleAlt = Module(DeferredK.async()) deferredModuleAlt.run { println(repository.allTasksByUser(user1).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user2).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user3).fix().unsafeAttemptSync()) } } }</code> </pre> <br><p>      [ <code>Try</code> ]({{ '/docs/arrow/core/try/ru' | relative_url }}) (..,   <code>Success</code>  <code>Failure</code> ). </p><br><pre> <code class="plaintext hljs">Success(value=[Task(value=LocalTask assigned to user1)]) Success(value=[Task(value=Remote Task assigned to user2)]) Failure(exception=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> ,          ,  <code>IO</code> . <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>IO</code></a> ,   in/out ,      ,       . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ioModule = Module(IO.async()) ioModule.run { println(repository.allTasksByUser(user1).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user2).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user3).fix().attempt().unsafeRunSync()) } } }</code> </pre> <br><pre> <code class="plaintext hljs">Right(b=[Task(value=LocalTask assigned to user1)]) Right(b=[Task(value=Remote Task assigned to user2)]) Left(a=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> <code>IO</code> —  .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Either&lt;L,R&gt;</code></a> (   ).  , ""  <code>Either</code>    ,  ""    ,    .          <code>Right(...)</code> ,  ,  <code>Left(...)</code> . </p><br><p>      . </p><br><p> ,   .   ,         ,      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">       </a> . </p><br><h3 id="vsyo-eto-otlichno-zvuchitno-stoit-li-ono-togo">    …     ? </h3><br><p>    ,    ,      .     . </p><br><ul><li><p>       : ,      (,  ),   — .  ,     . </p><br></li><li><p>         ,    .         .        ()   (   )  ,   . </p><br></li><li><p>      (),   ,          ().         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> . </p><br></li><li><p>   ,         . ,            (      ). </p><br></li><li><p>       ,      API     .       (        <code>map</code> , <code>flatMap</code> , <code>fold</code> ,        ). ,     ,       Kotlin,  Arrow —   . </p><br></li><li><p>          DI ( ), ..,    DI " ".         ,         ,              .        DI, ..,     ,        . </p><br></li><li><p>   ,     ,     .      , ..,    ,         . </p><br></li></ul><br><h3 id="dopolnitelno">  </h3><br><p>       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> . <br>   ,         ,   ,      ,   . </p><br><p>   ,    .     —   Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@JorgeCastilloPR</a> . </p><br><p>     (,  )    : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin Functional Programming: Does it make sense?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jorge Castillo</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin purity and Function Memoization</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jorge Castillo</a> </li></ul><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FP to the max</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John De Goes</a>     <code>FpToTheMax.kt</code> ,    <code>arrow-examples</code> .          ,   ,          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447234/">https://habr.com/ru/post/id447234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447218/index.html">JPoint 2019 parsing</a></li>
<li><a href="../id447220/index.html">Dasar-dasar mesin JavaScript: bentuk umum dan cache inline. Bagian 2</a></li>
<li><a href="../id447222/index.html">Pencarian Linux. Selamat kepada pemenang dan berbicara tentang pemecahan masalah</a></li>
<li><a href="../id447226/index.html">Wawancara dengan popularizer sains, kepala satu-satunya sekolah astronomi swasta di Rusia, Pavel Skripnichenko</a></li>
<li><a href="../id447232/index.html">Pengalaman pribadi Bagaimana kami menghubungkan telepon internasional: perbandingan 6 pertukaran virtual</a></li>
<li><a href="../id447236/index.html">Membuat tambak perangkat Android menggunakan Open STF</a></li>
<li><a href="../id447240/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 10</a></li>
<li><a href="../id447242/index.html">Otomatisasi server Jenkins SQL: mengembalikan hasilnya dengan indah</a></li>
<li><a href="../id447244/index.html">C301 dan miniOTP-3, token baru yang dapat diprogram dari Token2</a></li>
<li><a href="../id447246/index.html">Prototipe dalam 1 hari, bukan 2-3 minggu: Pencetakan 3D dalam masalah Okeanpribor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>