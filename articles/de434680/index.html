<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÄ üìø üë† Task Scheduler Evolution ü§¥üèæ üññüèΩ üÉè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die iFunny-Anwendung, an der wir arbeiten, ist seit mehr als f√ºnf Jahren im Handel erh√§ltlich. W√§hrend dieser Zeit musste das mobile Team viele versch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Task Scheduler Evolution</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/434680/"><img src="https://habrastorage.org/webt/bv/mr/ps/bvmrpspwu-kyhojb5tiu4lqbdi8.jpeg"><br><br>  Die iFunny-Anwendung, an der wir arbeiten, ist seit mehr als f√ºnf Jahren im Handel erh√§ltlich.  W√§hrend dieser Zeit musste das mobile Team viele verschiedene Ans√§tze und Migrationen zwischen Tools durchlaufen, und vor einem Jahr gab es eine Zeit, von einer selbstgeschriebenen L√∂sung zu wechseln und in Richtung etwas ‚ÄûModischeres‚Äú und Verbreiteteres zu schauen.  Dieser Artikel ist ein kleiner √úberblick dar√ºber, was untersucht wurde, welche L√∂sungen gepr√ºft wurden und was daraus entstanden ist. <a name="habracut"></a><br><br>  <b>Warum brauchen wir das alles?</b> <br><br>  Lassen Sie uns sofort entscheiden, was dieser Artikel ist und warum sich dieses Thema f√ºr das Android-Entwicklungsteam als wichtig herausgestellt hat: <br><br><ol><li>  Es gibt viele Szenarien, in denen Sie Aufgaben au√üerhalb des Frameworks der aktiven Benutzeroberfl√§che ausf√ºhren m√ºssen. </li><li>  Das System unterwirft dem Start solcher Aufgaben eine Vielzahl von Einschr√§nkungen. </li><li>  Es stellte sich als ziemlich schwierig heraus, zwischen vorhandenen L√∂sungen zu w√§hlen, da jedes Tool seine Vor- und Nachteile hat. </li></ol><br><h3>  <b>Chronologie der Entwicklung der Ereignisse</b> </h3><br>  <b>Android 0</b> <b><br></b> <h3>  AlarmManager, Handler, Service </h3><br>  Zun√§chst wurden ihre L√∂sungen implementiert, um auf Diensten basierende Hintergrundaufgaben zu starten.  Es gab auch einen Mechanismus, der Aufgaben mit dem Lebenszyklus verkn√ºpfte und sie abbrechen und wiederherstellen konnte.  Dies passte lange Zeit zum Team, da die Plattform solchen Aufgaben keine Einschr√§nkungen auferlegte. <br>  Google hat empfohlen, dies anhand des folgenden Diagramms zu tun: <br><br><img src="https://habrastorage.org/webt/e-/46/zn/e-46znleyxvynpm35pbebgrkdhk.png"><br><br>  Ende 2018 macht es keinen Sinn, dies zu verstehen, es reicht aus, das Ausma√ü der Katastrophe einzusch√§tzen. <br>  Tats√§chlich k√ºmmerte es niemanden, wie viel Arbeit im Hintergrund passiert.  Anwendungen machten, was sie wollten und wann sie wollten. <br><br>  <i><b>Vorteile</b> :</i> <i><br></i>  <i>√ºberall verf√ºgbar;</i> <i><br></i>  <i>f√ºr alle zug√§nglich.</i> <i><br><br></i>  <i><b>Nachteile</b> :</i> <i><br></i>  <i>Das System schr√§nkt die Arbeit in jeder Hinsicht ein.</i> <i><br></i>  <i>keine Starts nach Bedingung;</i> <i><br></i>  <i>Die API ist minimal und Sie m√ºssen viel Code schreiben.</i> <i><br></i> <br>  <b>Android 5. Lutscher</b> <b><br></b> <h3>  Jobcheduler </h3><br>  Nach 5 (!) Jahren, n√§her an 2015, stellte Google fest, dass Aufgaben ineffizient gestartet werden.  Benutzer beschwerten sich regelm√§√üig dar√ºber, dass ihre Telefone knapp wurden, indem sie einfach auf einem Tisch oder in der Tasche lagen. <br><br>  Mit der Ver√∂ffentlichung von Android 5 ist ein Tool wie JobScheduler erschienen.  Dies ist ein Mechanismus, mit dessen Hilfe es m√∂glich ist, verschiedene Arbeiten im Hintergrund auszuf√ºhren, deren Beginn aufgrund des zentralisierten Systems zum Starten dieser Aufgaben und der M√∂glichkeit, Bedingungen f√ºr diesen Start festzulegen, optimiert und vereinfacht wurde. <br><br>  Im Code sieht das alles ganz einfach aus: Es wird ein Dienst angek√ºndigt, bei dem die Start- und Endereignisse eintreten. <br>  Aus den Nuancen: Wenn Sie asynchron arbeiten m√∂chten, m√ºssen Sie von onStartJob aus den Stream starten.  Die Hauptsache ist, nicht zu vergessen, die jobFinished-Methode am Ende der Arbeit aufzurufen. Andernfalls l√§sst das System WakeLock nicht los, Ihre Aufgabe wird nicht als erledigt betrachtet und geht verloren. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Von √ºberall in der Anwendung k√∂nnen Sie diese Arbeit initiieren.  Aufgaben werden in unserem Prozess ausgef√ºhrt, aber auf IPC-Ebene initiiert.  Es gibt einen zentralen Mechanismus, der ihre Ausf√ºhrung steuert und die Anwendung nur zu den daf√ºr erforderlichen Zeitpunkten aktiviert.  Sie k√∂nnen auch verschiedene Triggerbedingungen festlegen und Daten √ºber das Bundle √ºbertragen. <br><br><pre> <code class="java hljs">JobInfo task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(JOB_ID, serviceName) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE); scheduler.schedule(task);</code> </pre> <br>  Im Allgemeinen war dies im Vergleich zu nichts bereits etwas.  Dieser Mechanismus ist jedoch nur mit API 21 verf√ºgbar, und zum Zeitpunkt der Ver√∂ffentlichung von Android 5.0 w√§re es seltsam, die Unterst√ºtzung aller alten Ger√§te einzustellen (3 Jahre sind vergangen, und wir unterst√ºtzen immer noch vier). <br><br>  <i><b>Vorteile</b> :</i> <i><br></i>  <i>Die API ist einfach;</i> <i><br></i>  <i>Startbedingungen.</i> <i><br></i> <br>  <b><i>Nachteile</i></b> : <br>  <s>Verf√ºgbar ab API 21</s> <br>  in der Tat nur mit API 23; <br>  leicht einen Fehler zu machen. <br><br>  <b>Android 5. Lutscher</b> <b><br></b> <h3>  <b>Gcm Netzwerkmanager</b> </h3><br>  Ein Analogon von JobScheduler - GCM Network Manager wurde ebenfalls vorgestellt.  Dies ist eine Bibliothek, die √§hnliche Funktionen bietet, aber bereits mit API 9 funktioniert. Richtig, daf√ºr sind Google Play Services erforderlich.  Anscheinend wurde die f√ºr JobScheduler erforderliche Funktionalit√§t nicht nur √ºber die Android-Version, sondern auch auf GPS-Ebene bereitgestellt.  Es sollte beachtet werden, dass die Entwickler des Frameworks ihre Meinung sehr schnell ge√§ndert haben und beschlossen haben, ihre Zukunft nicht mit GPS zu verbinden.  Danke ihnen daf√ºr. <br><br>  Alles sieht absolut identisch aus.  Gleicher Service: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmNetworkManagerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmTaskService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskParams taskParams)</span></span></span><span class="hljs-function"> </span></span>{ doWork(taskParams); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Der gleiche Aufgabenstart: <br><br><pre> <code class="java hljs">OneoffTask task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OneoffTask.Builder() .setService(GcmNetworkManagerService.class) .setTag(TAG) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); GcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mGcmNetworkManager.schedule(task);</code> </pre> <br>  Diese √Ñhnlichkeit der Architektur wurde durch die ererbte Funktionalit√§t und den Wunsch nach einer einfachen Migration zwischen Tools bestimmt. <br><br>  <i><b>Vorteile</b> :</i> <i><br></i>  <i>API √§hnlich wie JobScheduler;</i> <i><br></i>  <i>Verf√ºgbar ab API 9.</i> <i><br><br></i>  <i><b>Nachteile</b> :</i> <i><br></i>  <i>Sie m√ºssen √ºber Google Play Services verf√ºgen</i> <i><br></i>  <i>leicht einen Fehler zu machen.</i> <br><br>  <b>Android 5. Lutscher</b> <b><br></b> <h3>  <b>WakefulBroadcastReceiver</b> </h3><br>  Als n√§chstes werde ich ein paar Worte √ºber einen der grundlegenden Mechanismen schreiben, die in JobScheduler verwendet werden und Entwicklern direkt zur Verf√ºgung stehen.  Dies ist WakeLock und sein WakefulBroadcastReceiver. <br><br>  Mit WakeLock k√∂nnen Sie verhindern, dass das System in Suspend bleibt, dh das Ger√§t aktiv bleibt.  Dies ist notwendig, wenn wir wichtige Arbeit leisten wollen. <br>  Beim Erstellen von WakeLock k√∂nnen Sie dessen Einstellungen festlegen: Halten Sie die CPU, den Bildschirm oder die Tastatur gedr√ºckt. <br><br><pre> <code class="java hljs">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE) PowerManager.WakeLock wl = pm.newWakeLock(PARTIAL_WAKE_LOCK, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) wl.acquire(timeout);</code> </pre> <br>  Basierend auf diesem Mechanismus funktioniert der WakefulBroadcastReceiver.  Wir starten den Service und halten WakeLock. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleWakefulReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakefulBroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Intent service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, SimpleWakefulService.class); startWakefulService(context, service); } }</code> </pre> <br>  Nachdem der Service die erforderlichen Arbeiten abgeschlossen hat, geben wir ihn mit √§hnlichen Methoden frei. <br><br>  In 4 Versionen wird dieser BroadcastReceiver veraltet und die folgenden Alternativen werden auf developer.android.com beschrieben: <br><br><ul><li>  JobScheduler; </li><li>  Syncadapter </li><li>  DownloadManager </li><li>  FLAG_KEEP_SCREEN_ON f√ºr Window. </li></ul><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>DozeMode: Unterwegs schlafen</b> </h3><br>  Dann begann Google, verschiedene Optimierungen f√ºr Anwendungen anzuwenden, die auf dem Ger√§t ausgef√ºhrt werden.  Was f√ºr den Benutzer jedoch eine Optimierung ist, ist eine Einschr√§nkung f√ºr den Entwickler. <br><br>  Der erste Schritt war DozeMode, der das Ger√§t in den Ruhemodus versetzt, wenn es f√ºr eine bestimmte Zeit im Leerlauf liegt.  In den ersten Versionen dauerte es eine Stunde, in den nachfolgenden Versionen wurde die Schlafdauer auf 30 Minuten reduziert.  In regelm√§√üigen Abst√§nden wacht das Telefon auf, f√ºhrt alle anstehenden Aufgaben aus und schl√§ft wieder ein.  Das DozeMode-Fenster wird exponentiell erweitert.  Alle √úberg√§nge zwischen Modi k√∂nnen √ºber adb verfolgt werden. <br><br>  Wenn DozeMode auftritt, gelten f√ºr die Anwendung die folgenden Einschr√§nkungen: <br><br><ul><li>  Das System ignoriert alle WakeLock. </li><li>  AlarmManager ist verz√∂gert; </li><li>  JobScheduler funktioniert nicht; </li><li>  SyncAdapter funktioniert nicht. </li><li>  Der Netzwerkzugriff ist begrenzt. </li></ul><br>  Sie k√∂nnen Ihre Anwendung auch zur Whitelist hinzuf√ºgen, damit sie nicht unter die Einschr√§nkungen von DozeMode f√§llt, aber Samsung hat diese Liste zumindest vollst√§ndig ignoriert. <br><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>AppStandby: Inaktive Anwendungen</b> </h3><br>  Das System identifiziert inaktive Anwendungen und legt ihnen dieselben Einschr√§nkungen wie in DozeMode auf. <br>  Eine Anwendung wird an die Isolation gesendet, wenn: <br><br><ul><li>  hat keinen Prozess im Vordergrund; </li><li>  hat keine aktive Benachrichtigung; </li><li>  nicht zur Ausschlussliste hinzugef√ºgt. </li></ul><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>Hintergrundoptimierungen.</b>  <b>Svelte</b> </h3><br>  Svelte ist ein Projekt, in dem Google versucht, den RAM-Verbrauch durch Anwendungen und das System selbst zu optimieren. <br>  In Android 7 wurde im Rahmen dieses Projekts entschieden, dass implizite Broadcasts nicht sehr effektiv sind, da sie von einer gro√üen Anzahl von Anwendungen abgeh√∂rt werden und das System bei Auftreten dieser Ereignisse eine gro√üe Menge an Ressourcen verbraucht.  Daher wurden die folgenden Arten von Ereignissen f√ºr die Deklaration im Manifest verboten: <br><br><ul><li>  CONNECTIVITY_ACTION; </li><li>  ACTION_NEW_PICTURE; </li><li>  ACTION_NEW_VIDEO. </li></ul><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>FirebaseJobDispatcher</b> </h3><br>  Gleichzeitig wurde eine neue Version des Task-Start-Frameworks ver√∂ffentlicht - FirebaseJobDispatcher.  Tats√§chlich war es der fertige GCM NetworkManager, der etwas aufger√§umt und etwas flexibler gemacht wurde. <br><br>  Optisch sah alles genau gleich aus.  Gleicher Service: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Der einzige Unterschied zwischen ihm war die M√∂glichkeit, seinen Treiber zu installieren.  Ein Treiber ist die Klasse, die f√ºr die Task-Startstrategie verantwortlich war. <br><br>  Der Start von Aufgaben selbst hat sich im Laufe der Zeit nicht ge√§ndert. <br><br><pre> <code class="java hljs">FirebaseJobDispatcher dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirebaseJobDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GooglePlayDriver(context)); Job task = dispatcher.newJobBuilder() .setService(FirebaseJobDispatcherService.class) .setTag(TAG) .setConstraints(Constraint.ON_UNMETERED_NETWORK, Constraint.DEVICE_IDLE) .build(); dispatcher.mustSchedule(task);</code> </pre><br>  <i><b>Vorteile</b> :</i> <i><br></i>  <i>API √§hnlich wie JobScheduler;</i> <i><br></i>  <i>Verf√ºgbar ab API 9.</i> <i><br><br></i>  <i><b>Nachteile</b> :</i> <i><br></i>  <i>Sie m√ºssen √ºber Google Play Services verf√ºgen</i> <i><br></i>  <i>leicht einen Fehler zu machen.</i> <i><br></i> <br>  Es war ermutigend, meinen Treiber zu installieren, um GPS loszuwerden.  Wir haben sogar gesucht, aber schlie√ülich Folgendes gefunden: <br><br><img src="https://habrastorage.org/webt/3n/39/ua/3n39uanajermu--vb5qrzgfl8jq.png"><br><br><img src="https://habrastorage.org/webt/zm/rq/i3/zmrqi3pnt_0hx8lcspdy8k6xio8.png"><br><br>  Google wei√ü das, aber diese Aufgaben bleiben mehrere Jahre offen. <br><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>Android Job von Evernote</b> </h3><br>  Infolgedessen konnte die Community es nicht ertragen, und eine selbst erstellte L√∂sung erschien in Form einer Bibliothek von Evernote.  Es war nicht die einzige, aber es war die L√∂sung von Evernote, die sich etablieren und ‚Äûin die Menschen hineinkommen‚Äú konnte. <br><br>  In architektonischer Hinsicht war diese Bibliothek praktischer als ihre Vorg√§nger. <br>  Die f√ºr das Erstellen von Aufgaben verantwortliche Entit√§t wurde angezeigt.  Im Fall von JobScheduler wurden sie durch Reflexion erstellt. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJobCreator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobCreator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: String)</span></span></span><span class="hljs-function">: Job? </span></span>{ when (tag) { SendLogsJob.TAG -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendLogsJob() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  Es gibt eine separate Klasse, die die Aufgabe selbst ist.  In JobScheduler wurde dies alles in einem Schalter in onStartJob gespeichert. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Params)</span></span></span><span class="hljs-function">: Result </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doWork(params) } }</code> </pre> <br>  Der Start von Aufgaben ist identisch, aber zus√§tzlich zu den geerbten Ereignissen hat Evernote auch eigene hinzugef√ºgt, z. B. das Starten von t√§glichen Aufgaben, eindeutigen Aufgaben und das Starten innerhalb des Fensters. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobRequest.Builder(JOB_ID) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED) .build() .scheduleAsync();</code> </pre> <br>  <i><b>Vorteile</b> :</i> <i><br></i>  <i>bequeme API;</i> <i><br></i>  <i>wird in allen Versionen unterst√ºtzt;</i> <i><br></i>  <i>Ben√∂tigen Sie keine Google Play Services.</i> <i><br><br></i>  <i><b>Nachteile</b> :</i> <i><br></i>  <i>Drittanbieterl√∂sung.</i> <i><br></i> <br>  Die Jungs haben ihre Bibliothek aktiv unterst√ºtzt.  Obwohl es einige kritische Probleme gab, funktionierte es auf allen Versionen und auf allen Ger√§ten.  Aus diesem Grund hat sich unser Android-Team letztes Jahr f√ºr eine L√∂sung von Evernote entschieden, da die Bibliotheken von Google eine gro√üe Anzahl von Ger√§ten geschnitten haben, die sie nicht unterst√ºtzen k√∂nnen. <br>  Im Inneren arbeitete sie im Extremfall an L√∂sungen von Google - mit AlarmManager. <br><br>  <b>Android 8. Oreo</b> <b><br></b> <h3>  <b>Hintergrundausf√ºhrungsgrenzen</b> </h3><br>  Kehren wir zu unseren Grenzen zur√ºck.  Mit dem Aufkommen des neuen Android sind neue Optimierungen gekommen.  Die Jungs von Google haben ein anderes Problem gefunden.  Diesmal stellte sich heraus, dass das Ganze in Diensten und Sendungen zu sehen war (ja, nichts Neues). <br><br><ul><li>  <s>startService wenn Anwendungen im Hintergrund</s> </li><li>  <s>implizite Ausstrahlung im Manifest</s> </li></ul><br>  Erstens war es verboten, Dienste im Hintergrund zu starten.  Im "Rahmen des Gesetzes" blieben nur Vordergrundleistungen.  Services k√∂nnen jetzt als veraltet bezeichnet werden. <br>  Die zweite Einschr√§nkung ist dieselbe Sendung.  Diesmal war es verboten, ALLE impliziten Broadcasts im Manifest zu registrieren.  Implizite Sendung ist eine Sendung, die nicht nur f√ºr unsere Anwendung bestimmt ist.  Beispielsweise gibt es die Aktion ACTION_PACKAGE_REPLACED und die Aktion ACTION_MY_PACKAGE_REPLACED.  Der erste ist also implizit. <br><br>  Jede Sendung kann jedoch weiterhin √ºber Context.registerBroadcast registriert werden. <br><br>  <b>Android 9. Pie</b> <b><br></b> <h3>  <b>Arbeitsmanager</b> </h3><br>  Auf diese Optimierung hat noch aufgeh√∂rt.  Vielleicht fingen die Ger√§te an, schnell und sorgf√§ltig im Hinblick auf den Energieverbrauch zu arbeiten.  Vielleicht haben sich die Benutzer weniger dar√ºber beschwert. <br>  In Android 9 n√§herten sich die Entwickler des Frameworks dem Tool zum Starten von Aufgaben gr√ºndlich.  Um alle dringenden Probleme zu l√∂sen, wurde in Google I / O eine Bibliothek zum Starten der Hintergrundaufgaben von WorkManager eingef√ºhrt. <br><br>  Google hat k√ºrzlich versucht, seine Vision von der Architektur der Android-Anwendung zu gestalten, und bietet Entwicklern die daf√ºr erforderlichen Tools.  Es gab also Architekturkomponenten mit LiveData, ViewModel und Room.  WorkManager scheint eine vern√ºnftige Erg√§nzung zu ihrem Ansatz und Paradigma zu sein. <br><br>  Wenn wir dar√ºber sprechen, wie der WorkManager im Inneren angeordnet ist, gibt es keinen technologischen Durchbruch.  Tats√§chlich ist dies ein Wrapper bestehender L√∂sungen: JobScheduler, FirebaseJobDispatcher und AlarmManager. <br><br><div class="spoiler">  <b class="spoiler_title">createBestAvailableBackgroundScheduler</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBestAvailableBackgroundScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, WorkManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= MIN_JOB_SCHEDULER_API_LEVEL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemJobScheduler(context, workManager); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tryCreateFirebaseJobScheduler(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemAlarmScheduler(context); } }</code> </pre> <br></div></div><br>  Der Auswahlcode ist ziemlich einfach.  Es sollte jedoch beachtet werden, dass JobScheduler ab API 21 verf√ºgbar ist, diese jedoch nur mit API 23 verwenden, da die ersten Versionen eher instabil waren. <br><br>  Wenn die Version niedriger als 23 ist, versuchen wir durch Reflexion, FirebaseJobDispatcher zu finden, andernfalls verwenden wir AlarmManager. <br><br>  Es ist erw√§hnenswert, dass der Wrapper ziemlich flexibel herauskam.  Diesmal haben die Entwickler alles in separate Einheiten aufgeteilt, und architektonisch sieht es praktisch aus: <br><br><ul><li>  Arbeiter - Arbeitslogik; </li><li>  WorkRequest - Logik des Taskstarts; </li><li>  WorkRequest.Builder - Parameter; </li><li>  Einschr√§nkungen - Bedingungen; </li><li>  WorkManager - ein Manager, der Aufgaben verwaltet; </li><li>  WorkStatus - Aufgabenstatus. </li></ul><br><br><img src="https://habrastorage.org/webt/n_/ts/xi/n_tsxiw0wsxv6a5abotzdzokcba.png"><br><br>  Die Startbedingungen wurden von JobScheduler √ºbernommen. <br>  Es ist zu beachten, dass der Ausl√∂ser zum √Ñndern des URI nur mit API 23 angezeigt wurde. Dar√ºber hinaus k√∂nnen Sie die √Ñnderung nicht nur eines bestimmten URI, sondern auch aller darin verschachtelten URIs mithilfe des Flags in der Methode abonnieren. <br><br>  Wenn wir √ºber uns sprechen, wurde in der Alpha-Phase beschlossen, auf WorkManager umzusteigen. <br>  Daf√ºr gibt es mehrere Gr√ºnde.  Evernote weist einige kritische Fehler auf, die die Entwickler der Bibliothek beim √úbergang zu einer Version mit integriertem WorkManager beheben m√∂chten.  Und sie selbst sind sich einig, dass die Entscheidung von Google die Vorteile von Evernote zunichte macht.  Dar√ºber hinaus passt diese L√∂sung gut zu unserer Architektur, da wir Architekturkomponenten verwenden. <br><br>  Dar√ºber hinaus m√∂chte ich anhand eines einfachen Beispiels zeigen, wie wir versuchen, diesen Ansatz zu verwenden.  Gleichzeitig ist es nicht sehr wichtig, ob Sie einen WorkManager oder einen JobScheduler haben. <br><br><img src="https://habrastorage.org/webt/ox/yd/0p/oxyd0pizr6h8tx4egaz_kub5wqy.png" width="300" height="430"><img src="https://habrastorage.org/webt/6m/ec/hd/6mechdqawzamahgaij7df-isocg.png" width="300" height="430"><br><br>  Schauen wir uns ein Beispiel mit einem sehr einfachen Fall an: Klicken Sie auf Neu ver√∂ffentlichen oder √Ñhnliches. <br><br>  Jetzt versuchen alle Anwendungen, Anfragen an das Netzwerk nicht zu blockieren, da dies den Benutzer nerv√∂s macht und ihn warten l√§sst, obwohl er zu diesem Zeitpunkt innerhalb der Anwendung Eink√§ufe t√§tigen oder Anzeigen ansehen kann. <br><br>  In solchen F√§llen √§ndern sich zuerst die lokalen Daten - der Benutzer sieht sofort das Ergebnis seiner Aktion.  Dann gibt es im Hintergrund eine Anfrage an den Server. Wenn dies fehlschl√§gt, werden die Daten auf ihren Ausgangszustand zur√ºckgesetzt. <br><br>  Als n√§chstes werde ich ein Beispiel zeigen, wie es bei uns aussieht. <br><br>  JobRunner enth√§lt die Logik zum Starten von Aufgaben.  Seine Methoden beschreiben die Konfiguration von Aufgaben und √ºbergeben Parameter. <br><br><div class="spoiler">  <b class="spoiler_title">JobRunner.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">likePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: IFunnyContent)</span></span></span><span class="hljs-function"> </span></span>{ val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val input = Data.Builder() .putString(LikeContentJob.ID, content.id) .build() val request = OneTimeWorkRequest.Builder(LikeContentJob::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setInputData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setConstraints</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constraints</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getInstance</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enqueue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br></div></div><br>  Die Aufgabe selbst im WorkManager lautet wie folgt: Wir nehmen die ID aus den Parametern und rufen die Methode auf dem Server auf, um diesen Inhalt zu m√∂gen. <br><br>  Wir haben eine Basisklasse, die die folgende Logik enth√§lt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>{ val workerInjector = WorkerInjectorProvider.injector() workerInjector.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performJob(inputData) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Data)</span></span></span><span class="hljs-function">: Result }</span></span></code> </pre><br>  Erstens k√∂nnen Sie sich ein wenig vom expliziten Wissen von Worker entfernen.  Es enth√§lt auch die Abh√§ngigkeitsinjektionslogik √ºber WorkerInjector. <br><br><div class="spoiler">  <b class="spoiler_title">WorkerInjectorImpl.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Ovierride</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Worker job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AppCrashedEventSendJob) { Injector.getAppComponent().inject((AppCrashedEventSendJob) job); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CheckNativeCrashesJob) { Injector.getAppComponent().inject((CheckNativeCrashesJob) job); } } }</code> </pre><br></div></div><br>  Es √ºbertr√§gt einfach Anrufe an Dagger, hilft uns jedoch beim Testen: Wir ersetzen Injektorimplementierungen und implementieren die erforderliche Umgebung in Aufgaben. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testRegisterPushProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WorkManagerTestInitHelper.initializeTestWorkManager(context) val testDriver = WorkManagerTestInitHelper.getTestDriver() WorkerInjectorProvider.setInjector(TestInjector()) <span class="hljs-comment"><span class="hljs-comment">// mock dependencies val id = jobRunner.runPushRegisterJob() testDriver.setAllConstraintsMet(id) Assert.assertTrue(‚Ä¶) }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jobRunner</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobRunner</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ iFunnyContentDao.like(getContent().id) jobRunner.likePost(getContent()) } }</code> </pre> <br>  Interactor ist die Entit√§t, die der ViewController abruft, um die √úbergabe des Skripts zu initiieren (in diesem Fall √§hnlich).  Wir markieren den Inhalt lokal als "hochgeladen" und senden die Aufgabe zur Ausf√ºhrung.  Wenn die Aufgabe fehlschl√§gt, wird das Gleiche entfernt. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class">() </span></span>{ val likeState = MediatorLiveData&lt;Boolean&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentId = MutableLiveData&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentState: LiveData&lt;IFunnyContent&gt; = attachLiveDataToContentId(); init { likeState.addSource(iFunnyContentState) { likeState.postValue(it!!.hasLike) } } }</code> </pre> <br>  Wir verwenden die Architekturkomponenten von Google: ViewModel und LiveData.  So sieht unser ViewModel aus.  Hier verbinden wir die Aktualisierung des Objekts im DAO mit dem Status like. <br><br><div class="spoiler">  <b class="spoiler_title">IFunnyContentViewController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">likePostInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: View)</span></span></span><span class="hljs-function"> </span></span>{ viewModel.likeState.observe(lifecycleOwner, { updateLikeView(it!!) }) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLikePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ likePostInteractor.setContent(getContent()) likePostInteractor.execute() } }</code> </pre> <br></div></div><br>  ViewController abonniert einerseits das √Ñndern des Status von √Ñhnlichem und initiiert andererseits die √úbergabe des Skripts, das wir ben√∂tigen. <br><br>  Und das ist praktisch der gesamte Code, den wir ben√∂tigen.  Es bleibt, das Verhalten der Ansicht selbst mit dem Gleichen und der Implementierung Ihres DAO hinzuzuf√ºgen;  Wenn Sie Room verwenden, registrieren Sie einfach die Felder im Objekt.  Es sieht ziemlich einfach und effektiv aus. <br><br><h3>  <b>Zusammenfassend</b> </h3><br>  <b>JobScheduler, GCM Network Manager, FirebaseJobDispatcher:</b> <br><br><ul><li>  benutze sie nicht </li><li>  Lies keine Artikel mehr dar√ºber </li><li>  Berichte nicht ansehen </li><li>  Ich denke nicht, welches ich w√§hlen soll. </li></ul><br>  <b>Android Job von Evernote:</b> <br><br><ul><li>  Im Inneren verwenden sie den WorkManager. </li><li>  Kritische Fehler verschwimmen zwischen den L√∂sungen. </li></ul><br>  <b>WorkManager:</b> <br><br><ul><li>  API LEVEL 9+; </li><li>  unabh√§ngig von Google Play Services; </li><li>  Verkettung / InputMergers; </li><li>  reaktiver Ansatz; </li><li>  Unterst√ºtzung von Google (ich m√∂chte es glauben). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434680/">https://habr.com/ru/post/de434680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434670/index.html">Jahresberichterstattung Habrapost - 2018</a></li>
<li><a href="../de434672/index.html">Fintech Digest: Die beliebtesten Produkte des Jahres 2018: Verdoppelung des √úberweisungsvolumens von Karte zu Karte, Besteuerung der Kryptow√§hrung</a></li>
<li><a href="../de434674/index.html">Wir reagieren schnell, √ºberall und ohne physische Fallen auf Kabelvandalismus</a></li>
<li><a href="../de434676/index.html">TOP-10 - was 2019 zu lernen ist</a></li>
<li><a href="../de434678/index.html">Admin-Morgen: F√ºgen Sie auf Dutzenden von Servern Platz f√ºr Kaffee hinzu</a></li>
<li><a href="../de434682/index.html">Pers√∂nlicher Stadtteleportator</a></li>
<li><a href="../de434684/index.html">Rost 2019 und dar√ºber hinaus: Wachstumsbeschr√§nkungen</a></li>
<li><a href="../de434686/index.html">Vorlesung √ºber JavaScript und Node.js in KPI</a></li>
<li><a href="../de434688/index.html">FreeBSD plant, zu ZFSonLinux zu wechseln</a></li>
<li><a href="../de434690/index.html">Haiku-Betriebssystem: Portieren von Anwendungen und Erstellen von Paketen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>