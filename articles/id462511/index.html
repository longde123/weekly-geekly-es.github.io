<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👤 🤰 🧝🏻 Google Play Instan. Refactoring seumur hidup 🦑 🧝🏿 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika Anda terlibat dalam Program Akses Awal, Anda tidak pernah tahu sebelumnya apa yang akan terjadi pada akhirnya. Tentu saja, Anda berharap bahwa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Play Instan. Refactoring seumur hidup</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462511/">  Ketika Anda terlibat dalam Program Akses Awal, Anda tidak pernah tahu sebelumnya apa yang akan terjadi pada akhirnya.  Tentu saja, Anda berharap bahwa teknologi akan lepas landas, dan aplikasi Anda akan maju dari pasar dan mendapatkan sebagian PR di Google I / O.  Dan ini adalah motivasi yang baik untuk membaca kode sumber alih-alih dokumentasi pada tahap awal, yang, apalagi, harus diunduh dari arsip rahasia. <br><br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf,</a> Evgeny Saturov menunjukkan keikutsertaan apa dalam Early Access dengan mengembangkan aplikasi dengan peluncuran instan, menjelaskan semua fitur Google Play Instan di sepanjang jalan.  Dalam menguraikan laporannya, kami akan mencari tahu dari mana Bundel Aplikasi Android berasal, dan apa kaitannya dengan Pengiriman Dinamis, berkenalan dengan plug-in Gradle baru, dan belajar bagaimana menghadapi kejutan yang telah disiapkan oleh para pengembang SDK untuk kami. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-KUj_Kp_Xcg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>Tentang pembicara:</strong> Evgeny Saturov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">saturovv</a> ) bekerja untuk Surf, sebuah perusahaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">berspesialisasi</a> dalam pengembangan Android dan iOS khusus, dan baru-baru ini, pengembangan Flutter.  Eugene Flutter adalah penggila dan pendiri FlutterDevPodcast. <br><br><h2>  Sebuah perjalanan singkat ke dalam sejarah </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/nw/zr/lonwzrpjzpi7m-nosk3wy3gndzw.png" width="300"></div><br>  Dua tahun yang lalu, seorang pria yang luar biasa datang kepada kami di Surf dan berkata: “Kami memiliki teknologi yang sejauh ini hanya sedikit orang ketahui.  Dan Anda memiliki pelanggan dan kasing yang menarik.  Mari, kami akan memberi Anda teknologi kami, Anda mengintegrasikannya di suatu tempat, dan Anda mendapatkan simbiosis keren.  Kami akan mempromosikan ini di Google I / O dan semua orang akan baik-baik saja. " <br><br>  Bahkan, <b>bekerja dengan Program Akses Awal adalah babi di ladang</b> .  Anda harus bekerja dengan kode mentah, yang, tentu saja, tidak selalu berfungsi sebagaimana dimaksud dan dijelaskan.  Dalam kasus kami: <br><br><ul><li>  Semua artefak dikirim dalam bentuk arsip ZIP, yang harus diunduh setiap beberapa hari dari penyimpanan super rahasia dan diperbarui pada mesin lokal hanya secara manual. </li><li>  Anda hanya dapat bekerja di "kenari". </li><li>  Hampir tidak ada dokumentasi, hanya tersebar Google Docs tidak terstruktur, lebih sering mirip dengan aliran pemikiran pengembang. </li><li>  Menyebarkan dalam makanan, tentu saja, tidak mungkin - ini hanya mungkin setelah teknologi masuk ke rilis publik.  Artinya, seluruh penyebaran hanya di jalur alpha. </li><li>  Kemungkinan setelah rilis publik, ternyata SDK telah sepenuhnya ditulis ulang tanpa dukungan kompatibilitas mundur.  Anda mendapatkan antarmuka dan API yang sama sekali berbeda - Anda harus mengulang semuanya kembali. </li></ul><br>  Ini adalah ringkasan singkat tentang bagaimana kami berpartisipasi dalam Program Akses Awal. <br><br>  Semua ini menjadi mungkin berkat mitra reguler kami - perusahaan Labyrinth - toko buku dan alat tulis online terbesar di Rusia.  Mereka bergabung dengan proyek, bahkan tidak yakin apakah akan ada manfaat pada akhirnya.  Dan fakta bahwa pada 2017 Surf, sebagai studio, adalah bagian dari Program Google Certified Agency.  Sayangnya, program ini ditutup tahun ini. <br><br><h3>  Aplikasi Instan Android </h3><br>  Pada 2017, agar aplikasi dapat berjalan tanpa instalasi, itu harus digergaji ke dalam modul dengan benar. <br><br><img src="https://habrastorage.org/webt/fq/qz/d7/fqqzd7dexvnj3d6ojcpi7nunhrw.png"><br><br>  Kami memiliki plugin Gradle baru yang menghasilkan artefak yang sesuai: <br><br><ul><li>  Modul Aplikasi Instan - sebuah plugin aplikasi yang menghasilkan arsip ZIP dengan APK, satu untuk setiap modul fitur aplikasi; </li><li>  Installable App Module - Generated APK. </li></ul><br>  Hierarki dua tingkat dari modul fitur telah muncul.  Selalu ada hanya satu modul fitur dasar dan berisi semua kode dasar yang tersedia untuk semua fitur, sumber daya, dependensi, dll.  Modul Fitur tingkat atas berisi implementasi layar tertentu. <br><br>  Tapi <strong>itu panjang dan mahal</strong> karena sejumlah alasan: <br><br><ul><li>  Struktur modular yang kaku per se adalah batasan besar.  Sulit membayangkan bahwa perusahaan besar mana pun akan mengubah aplikasi yang sedang berkembang dan berfungsi sempurna menjadi setumpuk modul merokok selama bertahun-tahun hanya untuk mendukung teknologi baru yang masih belum diketahui apakah akan lepas landas atau tidak. </li><li>  Pembatasan ketat pada ukuran perakitan, yaitu, satu fitur tidak boleh melebihi 4 MB.  Ini adalah batas yang obyektif kecil, dan kadang-kadang benar-benar tidak dapat dicapai, misalnya, karena ketergantungan berat atau sesuatu seperti itu. </li><li>  Pastikan untuk menggunakan AppLinks, karena ini adalah satu-satunya cara untuk masuk ke dalam Aplikasi Instan.  Pengguna mengklik tautan dari mail, messenger, hasil pencarian dan sampai ke layar Anda melalui intersepsi tautan. </li><li>  Akhirnya, sejumlah besar keterbatasan teknis.  Pada awalnya bahkan tidak mungkin menggunakan NDK.  Anda tidak dapat mengirim pemberitahuan push, menerima data sensitif, mengubah pengaturan perangkat, dan memulai proses latar belakang.  Layanan, Penerima Siaran, dan Penyedia Konten tidak dapat digunakan.  Hanya Aktivitas. </li></ul><br>  Misi utama App Instan hanyalah demonstrasi dari UI dan tidak lebih.  Refactoring sangat menyakitkan, dan karena itu kisah ini hampir tidak pernah ditemukan dalam produksi. <br><br>  Namun secara adil, penerapan Aplikasi Instan di Labirin memberikan peningkatan pembelian 5% melalui klien seluler. <br><br><h2>  2019. Google Play Instan </h2><br>  Dua tahun telah berlalu, di halaman 2019 - Aplikasi Instan masih ada, tetapi bukan sebagai teknologi independen.  Ini masih sangat jarang dalam produksi, saya belum sengaja mencarinya, tetapi saya hanya tahu beberapa contoh: Sports.ru, Vimeo.  Tidak mungkin Google mengandalkan hasil seperti itu ketika mengumumkan teknologi ini. <br><br>  Sekarang Aplikasi Instan disebut berbeda - Google Play Instan.  Pergantian nama membantu menghilangkan dokumentasi yang tidak relevan.  Jika Anda melihat Aplikasi Instan Android, segera jelas bahwa ini tidak lagi relevan. <br><br>  Selain namanya, semuanya telah berubah, termasuk struktur modular.  <strong>Tuntutan menjadi lebih loyal</strong> .  Teknologi ini terintegrasi dengan cara yang benar-benar berbeda ke dalam proyek dan tidak memerlukan refactoring yang menyakitkan, yang tentu saja baik. <blockquote>  Tetapi yang kurang jelas dan, menurut saya, jauh lebih penting adalah bahwa teknologi ini, yang masih sangat unik dan langka, telah menjadi nenek moyang dari seluruh keluarga teknologi, yang saat ini dipasoknya. </blockquote>  Awalnya, Google memposisikan Aplikasi Instan sebagai teknologi yang menarik orang ke bisnis, bukan aplikasi.  Ada pedoman desain yang melarang aplikasi Landing dengan satu tombol “Unduh aplikasi lengkap”.  Tetapi masalah mendasar lainnya diselesaikan secara sampingan, dan saya menduga ini terjadi secara tidak sengaja. <br><br>  Pada bulan Februari tahun ini, perangkat luar biasa Samsung Galaxy S10 + dengan memori 1 TB terpasang.  Coba pikirkan - satu terabyte!  Mengapa Anda sangat membutuhkan ?! <br><br>  Menurut statistik resmi Google, selama 7 tahun terakhir, ukuran rata-rata APK telah meningkat 5,5 kali. <br><br><img src="https://habrastorage.org/webt/n1/fj/gi/n1fjgis20pkxen7kpz7h1mqavte.png"><br><br>  Ukuran build sangat penting, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelitian pada</a> statistik ini menunjukkan: <br><br><ul><li>  setiap tambahan 6 Mb unit mengurangi konversi dalam instalasi sebesar 1%; </li><li>  70% pengguna memeriksa ukuran aplikasi sebelum mengunduh; </li><li>  50% pengguna tertarik pada seberapa banyak ruang yang dibutuhkan aplikasi pada perangkat setelah instalasi. </li></ul><br>  Ini bahkan lebih penting jika audiens target Anda adalah orang-orang berusia lanjut, atau dengan pendapatan yang tidak terlalu tinggi, atau ini adalah pasar negara berkembang. <br><br>  Yang terakhir ini semakin sulit untuk diabaikan, karena pada tahun 2018 India yang menunjukkan peningkatan instalasi yang luar biasa. <br><br><img src="https://habrastorage.org/webt/w8/l5/sc/w8l5sclkeutjcit1oweqt3t4n1q.jpeg"><br><br>  Harap dicatat bahwa ada sangat sedikit iOS, dan jumlah total pemasangan aplikasi Android melebihi gabungan di AS, Brasil, dan Indonesia. <br><br>  Sekarang sudah jelas masalah apa yang bisa diselesaikan dengan Google Play Instan.  Anda dapat pergi ke istilah yang tidak bisa dimengerti. <br><br><h2>  Bundel Aplikasi Android </h2><br>  Bundel Aplikasi Android - format baru untuk menerbitkan aplikasi di Google Play.  Di dalam, semuanya tidak jauh berbeda dari APK: semua file dex, manifes, sumber daya, aset, dll. Yang sama  dll.  Tetapi ada Metadata, yang tidak sampai ke perangkat pengguna. <br><br><img src="https://habrastorage.org/webt/bb/ut/jt/bbutjtxukmhiiflwbngb_ivjae0.png"><br><br>  Metadata diwakili oleh tiga file: resources.pb, assets.pb, native.pb.  Bahkan, ini adalah tabel korespondensi sumber daya yang ada di pengaturan perakitan dan konfigurasi perangkat. <br><br><h2>  Pengiriman Dinamis Android </h2><br>  Semua orang tahu tentang keberadaan Penandatanganan Aplikasi oleh Google Play.  Tetapi tidak semua orang siap untuk menyimpan kunci rilis aplikasi mereka di Google Play, karena tidak akan ada jalan untuk kembali.  <b>Keluar dari Aplikasi Menandatangani oleh Google Play tidak mungkin.</b> <br><br>  Setelah pernah memberikan kunci rilis ke Google Play, maka Anda tidak pernah dapat menandatangani aplikasi Anda seperti sebelumnya, di sisi Anda.  Tetapi sebagai gantinya, Anda dapat memanfaatkan sepenuhnya Bundel Aplikasi Android sebagai format.  Dan proses penandatanganan perakitan sekarang akan terlihat sedikit berbeda. <br><br><img src="https://habrastorage.org/webt/bc/lx/mw/bclxmwzyamlhlisvggnyrori7gk.png"><br><br>  Anda masih akan menandatangani rakitan sebelum rilis di Google Play, tetapi Anda akan menandatanganinya dengan kunci unggah, yang tidak unik.  Itu dapat ditarik dari konsol, dirilis ulang jika dikompromikan atau hilang.  Anda memberikan kunci rilis Anda ke konsol dan mengucapkan selamat tinggal padanya - Google sekarang akan menandatangani perakitan untuk Anda dan bersumpah bahwa itu akan menjaga kunci Anda aman. <br><br>  Namun, jika Anda tidak memberikan kunci rilis ke Google Play, maka Anda tidak akan dapat menggunakan apa pun dalam proyek Anda yang akan dibahas lebih lanjut.  Google mengencangkan sekrup, dan bahkan Aplikasi Instan, tanpa memberikan kunci, sekarang akan gagal untuk digunakan. <br><br>  Faktanya, ini sama sekali tidak lucu, karena orang-orang yang membeli promosi Aplikasi Instan dan masuk ke keseluruhan cerita mem-refactored aplikasi mereka, tetapi untuk beberapa alasan mereka tidak dapat memberikan kunci mereka ke Google Play (atau departemen keamanan pasti menentang atau karena alasan obyektif lainnya) menemukan diri mereka dalam situasi di mana mereka tidak dapat lagi mendukung keputusan ini.  Ratusan jam kerja sebenarnya dibuang ke tempat sampah. <br><br><h3>  2014. Split APK Dukungan Muncul di Android Lollipop </h3><br>  Karena kami bernostalgia hari ini, kami akan kembali lebih awal ke masa lalu - pada tahun 2014. <br><br>  Saya masih ingat bagaimana pada NEXUS 5 saya, ponsel terbaik di dunia, perakitan Android Lollipop terbang dengan desain material yang luar biasa yang tampak seperti bom.  Tetapi ada perubahan yang tidak diperhatikan oleh banyak orang - ini adalah dukungan untuk APK Split. <br><br>  Split APK - mekanisme yang memungkinkan Anda untuk membagi aplikasi menjadi APK kecil dan, menginstal pada satu perangkat, membuatnya berperilaku sebagai satu aplikasi. <br><br>  Ingat ini, dan lanjutkan. <br><br>  Android Dynamic Delivery adalah format distribusi aplikasi baru di Google Play. <br><br><img src="https://habrastorage.org/webt/pg/yk/85/pgyk85hx5b1ymk2ryhbek8ssmhi.png"><br><br>  Kami dulu memiliki APK, sekarang Bundel Aplikasi Android muncul, sejauh alternatif.  AAB bertindak sebagai generator inkubator APK yang sangat terpisah ini.  AAB meluncurkan roti APK, yang kemudian dapat digunakan sebagai aplikasi biasa dengan menginstalnya secara paralel. <br><br>  Mari kita lihat seperti apa APK itu. <br><br><img src="https://habrastorage.org/webt/ku/7k/e5/ku7ke5ykakq3mewuawg5jrcnf-k.png"><br><br>  Paling tidak, ini adalah APK dasar, yang memainkan peran yang sama seperti di Aplikasi Instan: ini adalah kode dasar, sumber daya dasar, dan logika bisnis yang digeledah di antara semua fitur. <br><br>  Juga muncul: <br><br><ul><li>  APKs, yang namanya mirip dengan awalan pengubah sumber daya grafis (baris teratas dalam diagram). </li><li>  Keluarga APK lainnya mengingatkan kita pada arsitektur prosesor. </li><li>  APK Pelokalan. </li></ul><br>  Sekitar dua tahun yang lalu, ketika grafik vektor tidak begitu luas, banyak aplikasi yang mengandung sebagian besar sumber daya raster, yang dipotong dengan kerapatan piksel yang berbeda pada layar.  Perakitan bisa menjadi sangat berat.  Pengguna mengunduh semua sumber daya ini, dan sebagian besar disimpan di perangkat dengan bobot mati. <br><br>  Sekarang mekanisme semacam itu memungkinkan pengguna untuk hanya menerima serangkaian sumber daya yang diperlukan khusus untuk perangkatnya.  Seseorang datang ke Google Play, memilih aplikasi, Google Play memahami karakteristik perangkat pengguna, dan memberikan set APK APK yang diperlukan - satu APK dari setiap kategori. <br><br>  Jenis Pengiriman Dinamis APK: <br><br><ul><li>  Satu dan hanya satu Base APK. </li><li>  Configuration APK adalah maksimal tiga jenis: <em>res * x, aset * y, lib * z.</em>  Di sini: x adalah jumlah pengubah sumber daya yang digunakan;  y adalah jumlah jenis arsitektur yang digunakan;  z adalah jumlah lokalisasi bahasa.  Jika, misalnya, proyek tidak menggunakan kode asli dan pustaka asli, maka tidak akan ada kategori yang terkait dengan kode asli, dan dua APK akan tetap. </li><li>  Fitur Dinamis Tanpa Batas APK. </li></ul><br>  Fitur Dinamis APK akan dibahas lebih terinci di bawah ini.  Tapi pertama-tama, kami akan mengucapkan selamat tinggal pada blok Split. <br><br><h3>  Selamat tinggal Split </h3><br>  Anda dapat berargumen bahwa sebelumnya dimungkinkan untuk melakukan sesuatu yang serupa, secara manual menghasilkan banyak APK dengan sumber daya yang tepat, kemudian semuanya dikerahkan secara manual ke Google Play. <br><br><pre><code class="java hljs">android { splits { density { enable <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exclude <span class="hljs-string"><span class="hljs-string">"ldpi"</span></span>, <span class="hljs-string"><span class="hljs-string">"xxhdpi"</span></span>, <span class="hljs-string"><span class="hljs-string">"xxxhdpi"</span></span> compatibleScreens <span class="hljs-string"><span class="hljs-string">'small'</span></span>, <span class="hljs-string"><span class="hljs-string">'normal'</span></span>, <span class="hljs-string"><span class="hljs-string">'large'</span></span>, <span class="hljs-string"><span class="hljs-string">'xlarge'</span></span> } } }</code> </pre> <br>  Usaha ini sendiri agak diragukan, dan sekarang semua ini diabaikan begitu saja.  Jika Anda membangun Bundel Aplikasi Android, sebuah blok Bundel muncul, yang memungkinkan Anda untuk menonaktifkan pemisahan proyek secara manual menjadi salah satu kategori. <br><br><pre> <code class="java hljs">android { bundle { language { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } density { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } abi { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } }</code> </pre> <br>  Anda dapat menentukan bahwa aplikasi mendukung, misalnya, hanya Rusia atau hanya Inggris, dan lewati langkah ini selama perakitan. <br><br>  Yang paling penuh perhatian, mungkin, sekarang berpikir tentang apa yang harus dilakukan dengan preLollipop.  Hanya di Android 5 muncul dukungan untuk APK Split.  Kita perlu entah bagaimana keluar dari situasi ini, karena Min SDK tidak berarti yang ke-21. <br><br>  Untuk preLollipop, situasinya cukup canggung, tetapi hanya mungkin.  Google Play mengumpulkan Multi-APK untuk preLollipop, yang mencakup semua jenis kombinasi APK konfigurasi.  Hanya ada satu APK, tetapi ada banyak opsi. <br><br><h3>  Bundel Aplikasi Android Mengubah Kehidupan Kita </h3><br>  Dan sangat signifikan.  Pertama, mungkin akan jauh lebih mudah untuk membangun sebuah proyek, terutama jika Anda terbiasa membangun APK Split.  Tetapi menurut pengamatan saya tidak banyak orang seperti itu. <br><br>  Kedua, Anda tidak lagi berisiko kehilangan atau membahayakan kunci rilis.  Tidak akan ada tragedi besar, jika Anda kehilangan Kunci Unggah Anda, Anda dapat mengingat dan menerbitkannya kembali. <br><br>  Kami tidak akan menunjuk jari - di bagian atas Google Play Rusia ada aplikasi yang memiliki kunci rilis untuk waktu yang lama di w3bsit3-dns.com, semua majelis kustom ditandatangani dengan kunci rilis, dan tidak ada yang bisa dilakukan dengan ini dalam lima tahun ke depan.  Masih menunggu transisi ke Signing V3, yang muncul dengan hanya 28 API. <br><blockquote>  Keuntungan yang tidak diragukan dari Bundel Aplikasi Android: pengguna berhenti menghabiskan lalu lintas dan ruang disk pada sumber daya yang tidak mereka butuhkan.  Ini sangat meningkatkan retensi aplikasi. </blockquote>  Tetapi jika Anda memiliki semua grafik dalam vektor, dua pelokalan dan tidak ada perpustakaan asli, maka manfaatnya akan mikroskopis. <br><br><h2>  Modul Fitur Dinamis </h2><br>  Modul Fitur Dinamis adalah modul fungsional yang tidak disediakan saat memasang aplikasi, tetapi diunduh dari Google Play dan diinstal hanya berdasarkan permintaan. <br><br>  Modul semacam itu setara dengan APK dasar. <br><br><img src="https://habrastorage.org/webt/hp/ho/2v/hpho2vlpy2bawtztyql8r58aruu.png"><br><br>  Adalah penting bahwa masing-masing modul fitur itu sendiri juga mengandung satu set konfigurasi APK Split.  Dengan demikian, jumlah APK dapat meningkat melebihi batas.  Tapi ini sama sekali bukan urusanmu, Google Play melakukan ini. <br><br><h3>  Aplikasi untuk Modul Fitur Dinamis: </h3><br>  <strong>Fitur yang digunakan oleh persentase yang sangat kecil dari audiens</strong> , tetapi tetap penting untuk produk Anda.  Misalnya, ini adalah aplikasi hiburan konten, dan 95% penggunanya mengonsumsi konten.  Tetapi ada sedikit sekali editor yang menghasilkan konten.  Bagi mereka ada editor video keren yang benar-benar berat, bekerja sangat keren.  Maka tidak masuk akal untuk mempertimbangkan perakitan untuk semua orang dan semua orang, Anda dapat memasukkan fitur ini ke Modul Fitur Dinamis, dan menyediakannya hanya untuk mereka yang membutuhkannya, mengunduhnya nanti. <br><br>  <strong>Fitur berat yang tidak terkait dengan skenario penggunaan aplikasi utama.</strong>  Misalnya, navigasi AR di layanan peta.  Setiap fitur AR adalah yang paling banyak dimasukkan ke Modul Fitur Dinamis. <br><br>  <strong>Fitur yang harus tersedia bagi pengguna tanpa menginstal aplikasi itu sendiri</strong> (misalnya, memilih produk dalam katalog dan melakukan pemesanan).  Benar, ini adalah sesuatu yang sangat mencurigakan mengingatkan segalanya. <br><blockquote>  Android Instant Apps sekarang menjadi Modul Fitur Dinamis Diaktifkan Instan. <br></blockquote>  Dengan demikian, ternyata ada dua jenis Modul Fitur Dinamis: <br><br><ul><li>  Modul Fitur Dinamik Umum adalah modul fungsi yang diunduh dan diinstal pada perangkat secara terpisah dari aplikasi utama.  Mereka tinggal di sana selama aplikasi itu sendiri hidup.  Sampai Anda menghapusnya, Modul Fitur Dinamis akan menjadi. </li><li>  Instant-Diaktifkan Dynamic Feature Module - modul fungsi yang tersedia untuk dijalankan tanpa menginstal pada perangkat.  Modul ini hidup untuk waktu yang terbatas. </li></ul><br>  Jenis aplikasi kedua di Google Play dapat dibedakan dengan keberadaan tombol Coba.  Ketika Anda mengkliknya, URL default diganti dan Anda dapat melihat bagaimana aplikasi terlihat setidaknya sebagai contoh dari satu fitur utama. <br><br>  Ini sering ditemukan di bagian permainan.  Ini nyaman dan bahkan lebih dapat diterapkan daripada aplikasi, karena Anda dapat mengunduh sebagian kecil permainan sebagai demo dan melihat apa itu semua, apakah layak untuk menghabiskan lalu lintas dan waktu Anda. <br><br><h2>  Struktur modular </h2><br>  Saya sudah mengatakan bahwa struktur modular telah disederhanakan.  Mari kita lihat caranya. <br><br>  Awalnya, kami memiliki struktur yang cukup mengerikan.  Antara lain, ia memiliki modul kosong, misalnya, Modul Aplikasi Instan selalu kosong, tidak memiliki kode, tidak ada sumber daya, tetapi hanya file build.gradle dan hanya itu. <br><br>  Para pengembang berpikir, mengapa kemudian menghasilkan modul tambahan hanya untuk mengumpulkan artefak dari jenis tertentu.  Dan mereka menggergaji itu, dan fungsinya dipindahkan ke Modul Aplikasi. <br><br>  Tetapi kemudian mereka melangkah lebih jauh dan berpikir - mengapa kita membutuhkan Modul Fitur Dasar?  Ada beberapa masalah darinya, karena kami menginisialisasi semuanya di sana, dan ID Aplikasi-nya berbeda.  Kruk berasal dari sini, misalnya, mentransfer ID Aplikasi dari Modul Aplikasi ke Modul Fitur Dasar, dan menggantinya sebagai ID Aplikasi nyata dari aplikasi sehingga semuanya melacak dalam Crashlytics, dll. <br><br>  Hasilnya, ternyata begini. <br><br><img src="https://habrastorage.org/webt/s5/ld/ys/s5ldysjxqmlmuqm8axqd70lxyq0.png"><br><br>  Mereka meninggalkan Modul Aplikasi, terpasang di atasnya Modul Fitur - dan hanya itu! <br><br>  Jangan sampaikan emosi saya ketika saya mengetahui hal ini.  Orang-orang dari panggung besar mengatakan bahwa mereka memiliki teknologi keren: "Mari kita semua memotong aplikasi ke struktur ini!"  Tetapi ini tidak bekerja selama 5 menit, tetapi bekerja dengan konsekuensi besar. <br><br>  Pada 2017, memiliki aplikasi monolitik belum memalukan.  Labirin itu hanya seperti itu, maka itu bahkan belum mencapai rilis publik, tetapi dalam versi beta.  Pada saat kami terlibat dalam Program Akses Awal, sudah ada sekitar 90 layar di sana.  Kami menghabiskan dua bulan tambahan untuk refactor, menguji dan memastikan bahwa semuanya benar-benar berfungsi. <br><br>  Dan setelah itu mereka berkata: <strong>"Kami terlalu pintar, itu bisa dilakukan dengan lebih mudah</strong> . <strong>"</strong> <br><br>  Tapi kembali ke prosa. <br><br><h3>  Konfigurasi Gradle </h3><br>  Untuk mendukung konfigurasi baru, pertama-tama kita harus mendaftar semua Modul Fitur Dinamis dalam file build.gradle dari modul aplikasi di blok Android: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  build.gradle app- android { dynamicFeatures = [":dynamic_feature", M:dynamic_feature2M] }</span></span></code> </pre> <br>  Setelah itu, dalam file build.gradle dari masing-masing Modul Fitur Dinamis, tulis ketergantungan pada modul aplikasi: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  build.gradle  dynamic feature- dependencies { implementation project(':app') }</span></span></code> </pre> <br>  Pada prinsipnya, tidak ada yang rumit.  Tetapi ada juga konfigurasi manifes. <br><br><h3>  Konfigurasi manifes </h3><br>  Dalam manifes modul aplikasi, kita dapat mengatur flag sebenarnya untuk menunjukkan bahwa setidaknya ada satu Fitur yang Diaktifkan Instan dalam aplikasi ini: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   app- &lt;dist:module dist:instant="true|false" /&gt;</span></span></code> </pre> <br>  Jika bendera ini tidak ada, tidak mungkin untuk menyematkan dirinya di trek yang sesuai di Google Play. <br><br>  Selain itu, ada juga konfigurasi manifes untuk setiap Modul Fitur Dinamis secara terpisah, di mana terdapat lebih banyak pengaturan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    dynamic feature- &lt;dist:module dist:instant="true|false" // Instant-Enabled  dist:onDemand="false|true" // ,         dist:title="@string/feature_modulejnstall_name"&gt; //   &lt;dist:fusing dist:include="true |false" /&gt; //,      APK  preLollipop &lt;/dist:module&gt;</span></span></code> </pre> <br>  Dua flag pertama sedikit saling eksklusif, karena <code>onDemand</code> adalah fitur dasar yang biasa, dan <code>instant</code> adalah fitur Installable yang sama. <br><br>  Judul - nama teknis dari modul tersebut, yang menurut yang kemudian, setelah dikodekan dalam aplikasi kami, kami akan memompa modul ini dari Google Play. <br><br>  Parameter <code>include</code> adalah parameter untuk preLollipop.  Jika Anda mengaturnya ke false, maka pengguna preLollipops tidak akan pernah melihat fitur ini dan tidak akan dapat menggunakannya. <br><br><h3>  Konfigurasi proyek gradle </h3><br>  Kehidupan plugin instantapp dan plugin fitur cukup singkat tetapi bersemangat.  Mereka bertahan kurang dari dua tahun.  Sejak Maret tahun ini, mereka tidak lagi didukung. <br><br>  Sekarang hanya ada satu Modul Fitur Dinamis yang kami gunakan: <br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.dynamic-feature'</span></span></code> </pre> <br><h3>  Konfigurasi proyek dalam modul aplikasi saja </h3><br><blockquote>  Poin penting: semua pengaturan tentang tanda tangan (konfigurasi penandatanganan), perakitan (konfigurasi ProGuard), versionCode dan versionName hanya perlu dilakukan dalam modul aplikasi build.gradle. </blockquote>  Kalau tidak, mereka akan diabaikan.  Hindari menentukan salah satu dari blok konfigurasi ini di file build.gradle dari modul fitur dinamis. <br><br><h2>  Google play instan </h2><br>  Sekarang kita memiliki yang berikut ini. <br><br>  <strong>Persyaratan untuk struktur modular telah disederhanakan sebanyak mungkin.</strong>  Ini benar-benar kabar baik bagi mereka yang belum terlibat.  Sekarang Anda dapat mencoba, bahkan jika Anda memiliki aplikasi dengan strukturnya sendiri.  Ini tidak akan memengaruhi Anda sama sekali, Anda hanya dapat memasang modul di atas, dan semuanya akan berfungsi dengan baik. <br><br>  <strong>Pembatasan ukuran perakitan menjadi lebih loyal.</strong>  Jika sebelumnya 4 MB, sekarang: <br><br><ul><li>  Modul Fitur Dinamis pada umumnya tidak terbatas ukurannya; </li><li>  Modul Fitur Dinamis Diaktifkan Instan dapat memakan waktu hingga 10 MB. </li></ul><br>  Tetapi sekarang ada skala progresif. <br><br><img src="https://habrastorage.org/webt/hn/xq/rg/hnxqrghmprre_roahys7gkwquhu.png"><br><br>  Jika fitur Anda: <br><br><ul><li>  lebih dari 10 MB, maka saya minta maaf; </li><li>  dari 4 hingga 10 Mb - dapat diakses oleh tombol "Coba" dari Google Play dan hanya itu; </li><li>  kurang dari 4 MB - semua cara untuk menarik pengguna ke modul Diaktifkan Instan tersedia (diluncurkan dari iklan, dengan tautan, dari pesan, dll.). </li></ul><br>  <strong>Muncul mekanisme untuk memuat modul - Play Core API.</strong>  Hanya sedikit orang yang tahu bahwa Aplikasi Instan dulu diinstal melalui Chrome. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybeLaunchInstantApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tab tab, String url, String referrerUrl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isIncomingRedirect)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tab == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || tab.getWebContents() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; InstantAppsHandler handler = InstantAppsHandler.getInstance(); Intent intent = tab.getTabRedirectHandler() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? tab.getTabRedirectHandler().getInitialIntent() : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIncomingRedirect &amp;&amp; intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; intent.getAction() == Intent.ACTION_VIEW) { Intent resolvedIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(intent); resolvedIntent.setData(Uri.parse(url)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler.handleIncomingIntent(getAvailableContext(), resolvedIntent, ChromeLauncherActivity.isCustomTabIntent(resolvedIntent)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Ini adalah kode nyata dari Chrome untuk Android, yang mencegat tautan ke Aplikasi Instan Anda, pergi ke Google Play dan menggantikan Aplikasi Instan dari sana.  Jika Aplikasi Instan terdeteksi, entah bagaimana itu membuka aktivitas, dari mana Aplikasi Instan kemudian diluncurkan. <br><br>  Karenanya ada masalah besar dengan menggulirkan fitur ini.  Dengan Samsung, ini adalah cerita yang sama sekali berbeda, saya curiga bahwa browser bawaan mereka memiliki sedikit lebih banyak keistimewaan daripada Chrome.  Aplikasi Instan tidak berfungsi di sana hingga yang terakhir. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Play Core Library</strong></a> <strong>memungkinkan Anda melupakan masalah pengiriman.</strong>  Anda cukup mencolokkannya sebagai sebuah paket: <br><br><pre> <code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">'com.google.android.play:core:1.4.0'</span></span></code> </pre> <br>  Dan unduh modul fitur yang Anda butuhkan dari Google Play. <br><br>  Perpustakaan memiliki sintaks yang cukup fungsional yang memungkinkan Anda mengunduh modul satu per satu: <br><br><pre> <code class="java hljs">val splitInstallManager = SplitInstallManagerFactory.create(context)</code> </pre> <br>  Atau segera bungkus beberapa: <br><br><pre> <code class="java hljs">val request = SplitInstallRequest .newBuilder() .addModule(<span class="hljs-string"><span class="hljs-string">"feature1"</span></span>) .addModule(<span class="hljs-string"><span class="hljs-string">"feature2"</span></span>) .build()</code> </pre> <br>  Pendengar terputus: <br><br><pre> <code class="java hljs">splitInstallManager .startInstall(request) .addOnSuccessListener { sessionId -&gt; ... } .addOnFailureListener { exception -&gt; ... }</code> </pre> <br><br>  Perlihatkan ini di UI dan bereaksi terhadap fakta bahwa modul telah diinstal. <br><br>  Play Core Library adalah awal yang baik: <br><br><ul><li>  Akhirnya, Anda bisa berhenti berharap mungkin di hadapan Google Chrome. </li><li>  Anda dapat menunjukkan pemuatan modul pada UI seperti yang Anda inginkan. </li><li>  Dimungkinkan untuk memuat modul fitur dalam batch. </li><li>  Ada cara untuk secara fleksibel menangani kesalahan yang terjadi saat mengunduh dan memasang modul fitur. </li><li>  Anda bahkan tidak perlu me-restart aplikasi setelah fitur diinstal, karena ada <code>SplitCompat.install()</code> - panggil dan Anda dapat langsung mengakses kelas dari fitur yang baru diinstal langsung dengan cepat. </li></ul><br>  Tetapi saya akan menipu Anda jika saya mengatakan bahwa Play Core Library tidak akan membuat Anda menderita: <br><br><ul><li>  Kode ini dikaburkan dan tidak didokumentasikan dengan cara apa pun. </li><li>  Acara dari semua sesi pemuatan aktif datang ke satu <code>SplitInstallStateUpdatedListener</code> - Anda perlu mengurutkannya secara manual.  Diperlukan untuk menyimpan ID sesi di suatu tempat sebelumnya, yang akhirnya menghasilkan kode yang tidak terlalu indah. </li><li>  Manajemen negara yang kikuk, redundan, dan penanganan kesalahan: 9 kemungkinan kondisi, 10 kemungkinan kesalahan.  Kombinasi dari kesalahan dan status ini dapat diartikan berbeda, semua status dan kesalahan dikembalikan sebagai int. </li><li>  Tidak ada kemungkinan pengujian normal mengunduh dan memasang fitur pada perangkat lokal - ini tidak mungkin. </li></ul><br>  Satu-satunya opsi adalah menyematkan bangunan Anda di Google Play ke Saluran Pengujian Internal dan mencoba apa yang terjadi.  Jika Anda menemukan beberapa jenis bug, kemudian mulai seluruh proses dari awal lagi, gunakan pembaruan dan coba lebih lanjut.  Jika Anda ingin memeriksa cara kerjanya tanpa membangun, Anda mendapatkan kesalahan "-2" dan Anda hanya bisa menebak artinya.  Ini adalah masalah paling umum di repositori dengan sampel resmi dari Google Dynamic Features. <br><br>  <strong>Tidak ada praktik yang baik untuk menavigasi antara modul fitur.</strong>  Dalam contoh resmi, yang menunjukkan bagaimana interaksi antara modul fitur terjadi, mereka menyarankan agar situasi diselesaikan dengan cukup sederhana: nyalakan ketergantungan dari satu modul ke modul lainnya.  Setiap arah memiliki ketergantungannya sendiri, mengapa kembali? <br><br><img src="https://habrastorage.org/webt/yr/xh/vx/yrxhvxc_6mdbpre9ppka5-telrq.png"><br><br>  Tetapi kemudian semua manfaat pemisahan menjadi modul hilang.  Kami beralih ke modul jauh sebelum kebutuhan muncul untuk menyelesaikan masalah tersebut.  Dan mereka melakukan ini sebagian karena menyederhanakan pekerjaan dengan basis kode untuk pengembang yang tidak berpengalaman yang, karena tidak berpengalaman, dapat menggunakan aktivitas penandatanganan dengan aktivitas dasar - kemudian mencarinya untuk tinjauan kode. <br><br>  Jika Anda menghubungkan semua modul dengan dependensi ke atas dan ke bawah, maka hanya Google yang akan bagus dalam hal ini, yang tidak perlu memikirkan apa pun tentang navigasi. <br><br>  Kami sudah lama berpikir apa yang harus dilakukan dengan ini, dan pada akhirnya kami menentukan solusi yang masih membuat saya menggigil.  Ini disebut <code>Class.forName</code> - instantiating kelas menggunakan <code>ClassPath</code> penuh, yang dipecah oleh setiap nama kelas dari paket apa pun dari jalurnya, dll. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityCrossFeatureRoute</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: Context)</span></span></span><span class="hljs-function">: Intent? </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Intent(context, Class.forName(targetClassPath())) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: ClassNotFoundException) { Logger.e(<span class="hljs-string"><span class="hljs-string">"Activity with the following classpath was not found in the current "</span></span> + <span class="hljs-string"><span class="hljs-string">"application: ${targetClassPath()}. If this activity is the part of Dynamic Feature, "</span></span> + <span class="hljs-string"><span class="hljs-string">"please check if this Dynamic Feature is downloaded and installed on the device"</span></span> + <span class="hljs-string"><span class="hljs-string">"successfully."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  Saya malu untuk memberitahu siapa pun tentang hal ini sampai saya pergi ke repositori aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plaid</a> dan melihat bahwa mereka telah menyelesaikan masalah navigasi dengan cara yang sama dan menyarankan semua orang untuk melakukannya di Stack Overflow. <br><br>  Plaid adalah salah satu case show paling keren, dengan mereka Google mencoba semua tren terbaru, animasi keren, trik desain, komponen UI terbaru dan, khususnya, modularitas. <br><br>  <strong>Banyak, benar-benar banyak bug, rekayasa, kekasaran.</strong>  Anda tidak harus mencari bug untuk waktu yang lama. <br><br><ul><li>  Akses ke sumber daya dari modul aplikasi hanya dimungkinkan di sepanjang jalur lengkap. </li></ul><br>  Alih-alih menulis seperti ini: <code>R.string.primaryColor</code> , Anda harus menulis seperti ini setiap kali dalam kode: <code>ru.appname.package.R.string.primaryColor</code> .  Dengan cara yang berbeda, build tidak akan berfungsi, dan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke pelacak isu resmi. <br><br><ul><li>  Masalah dengan menjalankan JobScheduler di perangkat O +.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi resmi</a> adalah untuk meluncurkan secara manual <code>TestJobSchedulerService</code> : </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { Intent serviceIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, TestJobSchedulerService.class); startService(serviceIntent); }</code> </pre> <br><ul><li>  Kesalahan pembekuan manifes saat menghubungkan pustaka pihak ketiga, misalnya, Firebase, Fabric, paket AndroidX, dll. </li></ul><br>  Semuanya menggunakan ID aplikasi placeholder dalam manifes.  ID Aplikasi salah dimasukkan di sana, karena manifes tidak membeku, Android Studio tidak dapat menemukan aktivitas default, dan Anda mencari masalah untuk waktu yang lama sampai Anda menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saran</a> di pelacak masalah resmi - mendefinisikan kembali semua penyedia dan menentukan ID Aplikasi Anda di sana. <br><br><pre> <code class="java hljs">&lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"com.crashlytics.android.CrashlyticsInitProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.crashlyticsinitprovider"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt; &lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"com.google.firebase.provider.FirebaseInitProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.firebaseinitprovider"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt; &lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"androidx.core.content.FileProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.fileprovide"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt;</code> </pre> <br><ul><li>  Ketidakmungkinan beberapa dependensi pada paket pihak ketiga adalah salah satu poin favorit saya. </li></ul><br>  Misalkan dua modul fitur tergantung pada satu perpustakaan pihak ketiga.  Tetapi Anda tidak dapat membuat ketergantungan langsung karena Anda mendapatkan: <code>org.gradle.api.GradleException: [:feature1, :feature2] all package the same library [com.lib.Name:VeryGoodLib]</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jawaban resmi</a> : bagaimana jika dalam modul-modul ini berbagai versi perpustakaan ditunjukkan. <br><br>  Pengembang menyarankan: menambahkan modul fitur ke hierarki, di mana tidak ada yang lain selain ketergantungan pada perpustakaan pihak ketiga, dan membuatnya bergantung pada dua modul fitur sumber. <br><br><ul><li>  Cache panggilan InstantApps.isInstantApp (konteks) di attachBaseContext (). </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh kode</a> dari dokumentasi untuk Pengembang Android <code>attachBaseContext()</code> , hanya karena mereka menawarkan <code>attachBaseContext()</code> untuk mengakses konteks melalui <code>this</code> , dan jika <code>context==null</code> , Anda bahkan tidak dapat memeriksa apakah InstantApps sedang berjalan atau tidak. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachBaseContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base: Context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.attachBaseContext(base) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!InstantApps.isInstantApp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) { SplitCompat.install(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre> <br><ul><li>  <code>ConstraintLayout</code> menampilkan <code>ConstraintLayout</code> saat menggunakan <code>Groups</code> dan <code>Barriers</code> . </li></ul><br>  Bayangkan Anda telah melalui semua hal: merakit unit, menduga bahwa itu harus tertanam di saluran uji di Google Play, Google Play tidak menampilkan dialog merah.  Dengan tangan gemetar, Anda memasang unit ini di perangkat, menginstal fitur, pergi ke layar - dan Anda melihat bahwa seluruh tata letak telah berkumpul di tumpukan di sudut kiri atas.  Ini karena jika Anda menggunakan <code>Groups</code> dan <code>Barriers</code> , ada metode <code>getPackageName</code> luar <code>getPackageName</code> , yang karena beberapa alasan salah.  Akibatnya, semua tampilan Anda tidak diposisikan.  Semua kendala melayang, dan semuanya terletak di layar dengan sembarangan. <br><br>  Akhirnya, setelah Anda mengatasi ini, Anda akan menemukan bahwa ... <br><br>  <strong>Fitur Dinamis masih dalam Beta!</strong>  Anda tidak bisa terjebak dalam produksi - Anda telah menjadi penguji gratis untuk Google selama ini! <br><br><img src="https://habrastorage.org/webt/ry/ct/i6/rycti6op3z_5tkbmn0b5dv77psk.png"><br><br>  Tapi tidak menurut Google.  Jika Anda ingin menjadi satu, Anda dapat mengisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Formulir Bunga</a> dan mungkin Anda akan beruntung dan Anda akan diberikan akses untuk dikunci dalam produksi. <br><blockquote>  <em>Dipercaya</em> bahwa Aplikasi Instan kehilangan pertempuran ini.  Tidak mungkin bahwa ini akan diumumkan di tahun-tahun mendatang, tetapi peningkatan aktivitas informasi di sekitar AMP secara diam-diam menegaskan hal ini. </blockquote>  Pikiran bahwa saya ingin mengingatkan Anda dan saya sendiri - <strong>menulis untuk orang-orang</strong> .  Berpikir tiga kali sebelum mengambil keputusan, terutama jika Anda mengembangkan alat yang akan digunakan pengembang lain.  Setiap keputusan dan tindakan Anda akan memengaruhi seseorang dan, mungkin, memanjakannya sedikit darah.  <strong>Saya tidak ingin menyebabkan gangguan bagi seseorang.</strong> <br><br><h3>  Tautan yang bermanfaat </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/topic/google-play-instant/overview</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/guide/app-bundle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/studio/proiects/dvnamic-delivery</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/guide/app-bundle/playcore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bundling Aplikasi dalam Instan (Android Dev Summit '18)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/googlesamples/android-instant-apps</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/googlesamples/android-dynamic-features</a> </li></ul><br><blockquote>  Kami membuat program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saint AppsConf</a> , yang sudah 21-22 Oktober di St. Petersburg, bahkan lebih penting dan beragam daripada di musim semi.  Lihat itu! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau berlangganan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buletin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegram</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - di sana kita berbicara tentang laporan individu dan persiapan untuk konferensi.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462511/">https://habr.com/ru/post/id462511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462501/index.html">Mengapa saya memerlukan otoritas sertifikasi saya sendiri</a></li>
<li><a href="../id462503/index.html">Untuk apa "sinyal emas" pemantauan dan SRE?</a></li>
<li><a href="../id462505/index.html">Jangan membodohi saya dengan pemrograman fungsional Anda</a></li>
<li><a href="../id462507/index.html">Saat pengiriman surat: melawan hilangnya pemberitahuan push di iOS</a></li>
<li><a href="../id462509/index.html">Product Fest - konferensi manajemen produk TI yang ingin Anda kunjungi</a></li>
<li><a href="../id462513/index.html">Relokasi: persiapan, pemilihan, pengembangan wilayah</a></li>
<li><a href="../id462515/index.html">Bug saat bekerja dengan keyboard sistem</a></li>
<li><a href="../id462519/index.html">Buku "Layanan Mikro. Pengembangan dan pola refactoring »</a></li>
<li><a href="../id462523/index.html">Server Otorisasi Dua-faktor LinOTP</a></li>
<li><a href="../id462525/index.html">3CX Meluncurkan Softphones SIP Baru untuk iOS dan Android dengan Enkripsi Suara ujung ke ujung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>