<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗻 ⛵️ 🐘 您将为一切做出回答！ 通过开发商的眼光看消费者驱动的合同 🎅 👦🏻 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将讨论消费者驱动的合同解决的问题，并展示如何使用带有Node.js和Spring Boot的Pact示例来应用它。 并讨论这种方法的局限性。 


 发行 
 在测试产品时，通常使用场景测试，其中检查了系统在特定选择的环境中各个组件的集成。 这种对实时服务的测试给出了最可靠的结果（不包...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>您将为一切做出回答！ 通过开发商的眼光看消费者驱动的合同</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/452960/"> 在本文中，我们将讨论消费者驱动的合同解决的问题，并展示如何使用带有Node.js和Spring Boot的Pact示例来应用它。 并讨论这种方法的局限性。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/vg/za/guvgzadja02vflw5bi8mgh_wbbo.png"></div><br><h2> 发行 </h2><br> 在测试产品时，通常使用场景测试，其中检查了系统在特定选择的环境中各个组件的集成。 这种对实时服务的测试给出了最可靠的结果（不包括战斗中的测试）。 但同时，它们是最昂贵的之一。 <br><a name="habracut"></a><br><ul><li> 人们常常错误地认为集成环境不应容错。  SLA，很少说出对此类环境的保证，但是如果没有保证，团队必须要么推迟发布，要么希望取得最好的成绩，并在没有测试的情况下投入战斗。 尽管所有人都知道<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">希望不是战略</a> 。 而新型的基础架构技术只会使集成环境的工作复杂化。 </li><li>  <b>另一个麻烦是处理测试数据</b> 。 许多场景需要系统的某种状态，即灯具。 它们应与数据打多近？ 如何在测试前更新它们并在完成后进行清洁？ </li><li> <b>测试太不稳定了</b> 。 不仅因为我们在第一段中提到的基础架构。 该测试可能会失败，因为附近的团队启动了自己的检查，从而破坏了系统的预期状态！ 许多错误的否定检查和<code>@Ignored</code>测试在<code>@Ignored</code>结束了他们的生命。 同样，集成的不同部分可能由不同的团队支持。 他们推出了一个新的有错误的候选版本-他们破坏了所有消费者。 有人用专用的测试循环解决了这个问题。 但是以增加支持成本为代价。 </li><li>  <b>这样的测试需要很多时间</b> 。 即使考虑到自动化，也可以期待数小时的结果。 </li><li> 最重要的是，如果测试确实正确，那么始终无法立即找到问题的原因。 它可以隐藏在集成层的深处。 也可能是许多系统组件的状态意外组合的结果。 </li></ul><br> 在集成环境中进行稳定的测试需要QA，dev甚至ops投入大量资金。 难怪它们处于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试金字塔</a>的最顶端。 这样的测试很有用，但是资源经济不允许他们检查所有内容。 其价值的主要来源是环境。 <br><br> 在同一金字塔下面是其他测试，在这些测试中，我们使用隔离检查来换取较小的支持难题。 粒度越大，测试规模越小，对外部环境的依赖性就越小。 金字塔的最底部是单元测试。 我们检查各个功能，类，我们所进行的操作不像商业语义那样，而是针对特定实现的构造。 这些测试可提供快速反馈。 <br><br> 但是，一旦我们走下金字塔，就必须用某种东西来代替环境。 存根出现-作为整个服务以及编程语言的单个实体。 借助插头，我们可以隔离测试组件。 但是它们也会降低检查的有效性。 如何确保存根返回正确的数据？ 如何保证其质量？ <br><br>  <b>该解决方案可以是全面的文档</b> ，描述了各种情况以及系统组件的可能状态。 但是任何表述仍然保留解释的自由。 因此，良好的文档记录是一个生动的工件，随着团队对问题领域的了解，它会不断提高。 然后如何确保符合文档存根？ <br><br> 在许多项目中，您可以观察到存根由开发测试工件的同一个人编写的情况。 例如，移动应用程序的开发人员自己为测试创建存根。 结果，程序员可以以自己的方式理解文档（这是完全正常的），使存根具有错误的预期行为，根据存根编写代码（带有绿色测试），并且在真正的集成过程中会发生错误。 <br><br> 此外，文档通常向下游移动-客户端使用服务规范（在这种情况下，另一个服务可以是该服务的客户端）。 它没有表达消费者<strong>如何</strong>使用数据，根本需要什么数据，他们对该数据做出什么假设。 这种无知的结果是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">希律</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定律</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ek/bh/ho/ekbhhofe0ox95w50drdg8tybsbi.png" width="300"></div><br><br>  Hyrum Wright长期以来一直在Google内部开发公共工具，并观察到最小的变化如何导致使用其库的隐式（未记录）功能的客户崩溃。 这种隐藏的连接使API的发展变得复杂。 <br><br> 使用消费者驱动的合同可以在某种程度上解决这些问题。 像任何方法和工具一样，它具有一定的适用性和成本，我们还将考虑这些范围。 这种方法的实施已经达到足够的成熟度，可以尝试他们的项目。 <br><br><h2> 什么是CDC？ </h2><br> 三个关键要素： <br><br><ul><li>  <b>合同</b> 。 使用某些DSL描述，取决于实现。 它以交互场景的形式包含对API的描述：如果特定请求到达，则客户端应收到特定响应。 </li><li>  <b>客户测试</b> 。 此外，他们使用存根，该存根是从合同自动生成的。 </li><li>  <b>测试API</b> 。 它们也是从合同生成的。 </li></ul><br> 因此，合同是可执行的。 该方法的主要特点是，对API行为的要求从客户端到服务器都<b>向上游移动</b> 。 <br><br> 合同侧重于对消费者<strong>真正</strong>重要的行为。 使有关API的假设明确。 <br><br>  CDC的主要目标是使开发人员和客户开发人员对API行为有所了解。 这种方法与BDD很好地结合在一起，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三个好友的会议上，</a>您可以草拟合同的空白。 最终，该合同还有助于改善沟通； 在问题区域内达成共识，并在团队内部和团队之间实施解决方案。 <br><br><h2> 契约 </h2><br> 考虑使用CDC作为其实施之一的Pact的示例。 假设我们为会议参与者创建了一个Web应用程序。 在下一次迭代中，团队将制定演示时间表-到目前为止，还没有投票或注释之类的故事，仅是报告网格的输出。 示例的源代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 <br><br> 在<s>三</s>四分之三的会议上，产品，测试人员，后端开发人员和移动应用程序举行了会议。 他们说 <br><br><ul><li> 带有文本的列表将显示在UI中：报告标题+发言人+日期和时间。 </li><li> 为此，后端必须返回数据，如下例所示。 </li></ul><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }</code> </pre> <br> 之后，前端开发人员开始编写客户端代码（前端的后端）。 他在项目中安装了契约合同库： <br><br><pre> <code class="bash hljs">yarn add --dev @pact-foundation/pact</code> </pre> <br> 并开始编写测试。 它配置本地存根服务器，该服务器将使用报告计划模拟服务： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pact({ <span class="hljs-comment"><span class="hljs-comment">//      consumer: "schedule-consumer", provider: "schedule-producer", // ,     port: pactServerPort, //  pact     log: path.resolve(process.cwd(), "logs", "pact.log"), // ,     dir: path.resolve(process.cwd(), "pacts"), logLevel: "WARN", //  DSL  spec: 2 });</span></span></code> </pre> <br> 合同是一个JSON文件，描述了客户端与服务交互的场景。 但是您不需要手动描述它，因为它是由代码中存根的设置形成的。 测试前的开发人员描述以下行为。 <br><br><pre> <code class="javascript hljs">provider.setup().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> provider .addInteraction({ <span class="hljs-attr"><span class="hljs-attr">uponReceiving</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">withRequest</span></span>: { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">willRespondWith</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] } } }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()) );</code> </pre> <br> 在此示例中，我们指定了特定的预期服务请求，但是pact-js还支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几种用于确定match的方法</a> 。 <br><br> 最后，程序员对使用此存根的那部分代码进行测试。 在下面的示例中，为简单起见，我们将直接调用它。 <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"fetches schedule"</span></span>, done =&gt; { fetch(<span class="hljs-string"><span class="hljs-string">`http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pactServerPort}</span></span></span><span class="hljs-string">/schedule`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">json</span></span></span><span class="hljs-function"> =&gt;</span></span> expect(json).toStrictEqual({ <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] })) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()); });</code> </pre> <br> 在实际项目中，这可以是单独的响应解释功能的快速单元测试，也可以是用于显示从服务接收的数据的慢速UI测试。 <br><br> 在测试运行期间，pact验证存根是否接收到测试中指定的请求。 差异可以在pact.log文件中视为diff。 <br><br><pre> <code class="plaintext hljs">E, [2019-05-21T01:01:55.810194 #78394] ERROR -- : Diff with interaction: "a request for schedule" Diff -------------------------------------- Key: - is expected + is actual Matching keys and values are not shown { "headers": { - "Accept": "application/json" + "Accept": "*/*" } } Description of differences -------------------------------------- * Expected "application/json" but got "*/*" at $.headers.Accept</code> </pre> <br><br> 如果测试成功，将以JSON格式生成合同。 它描述了API的预期行为。 <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"consumer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-consumer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"provider"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-producer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"interactions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Accept"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }}} ], <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pactSpecification"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0.0"</span></span> } } }</code> </pre> <br> 他将此合同交给后端开发人员。 假设该API在Spring Boot上。  Pact有一个可以与MockMVC一起使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pact-jvm-provider-spring</a>库。 但是，我们将看一下Spring Cloud Contract，它在Spring生态系统中实现了CDC。 它使用自己的合同格式，但还有一个扩展点，用于连接其他格式的转换器。 它的本机合同格式仅受Spring Cloud Contract本身支持-与Pact不同，Pact具有针对JVM，Ruby，JS，Go，Python等的库。 <br><br> 假设在我们的示例中，后端开发人员使用Gradle构建服务。 它连接以下依赖项： <br><br><pre> <code class="plaintext hljs">buildscript { // ... dependencies { classpath "org.springframework.cloud:spring-cloud-contract-pact:2.1.1.RELEASE" } } plugins { id "org.springframework.cloud.contract" version "2.1.1.RELEASE" // ... } // ... dependencies { // ... testImplementation 'org.springframework.cloud:spring-cloud-starter-contract-verifier' }</code> </pre> <br> 并将从frotender收到的Pact合同放入<code>src/test/resources/contracts</code>目录。 <br><br> 默认情况下，spring-cloud-contract插件会从中减去合同。 在组装期间，执行generateContractTests gradle任务，该任务在build / generate-test-sources目录中生成以下测试。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// given: MockMvcRequestSpecification request = given() .header("Accept", "application/json"); // when: ResponseOptions response = given().spec(request) .get("/scheduler"); // then: assertThat(response.statusCode()).isEqualTo(200); assertThat(response.header("Content-Type")).isEqualTo("application/json;charset=UTF-8"); // and: DocumentContext parsedJson = JsonPath.parse(response.getBody().asString()); assertThatJson(parsedJson).array("['talks']").array("['speakers']").contains("['name']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['time']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['title']").isEqualTo( /*...*/ ); } }</span></span></code> </pre> <br><br> 开始此测试时，我们将看到一个错误： <br><br><pre> <code class="plaintext hljs">java.lang.IllegalStateException: You haven't configured a MockMVC instance. You can do this statically</code> </pre> <br> 由于我们可以使用不同的工具进行测试，因此我们需要告诉插件我们已经配置了哪个工具。 这是通过基类完成的，该基类将继承合同生成的测试。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ScheduleController scheduleController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScheduleController(); <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RestAssuredMockMvc.standaloneSetup(scheduleController); } }</code> </pre> <br><br> 要在生成过程中使用此基类，您需要配置spring-cloud-contract gradle插件。 <br><br><pre> <code class="plaintext hljs">contracts { baseClassForTests = 'ru.example.schedule.ContractsBaseTest' }</code> </pre> <br><br> 现在，我们生成了以下测试： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br> 测试成功启动，但失败，并显示验证错误-开发人员尚未编写该服务的实现。 但是现在他可以根据合同了。 他可以确保他能够处理客户的请求并返回预期的响应。 <br><br> 服务开发人员通过合同知道他需要做什么，要执行什么行为。 <br><br> 契约可以更深入地集成到开发过程中。 您可以部署一个Pact-broker来聚合此类合同，支持它们的版本控制，并可以显示依赖关系图。 <br><br><img src="https://habrastorage.org/webt/dq/pd/v0/dqpdv0c4qk89kboewjxrafys1iq.png"><br><br> 在构建客户端时，可以在步骤CI中将新生成的合同上载到代理。 并在服务器代码中通过URL指示合同的动态加载。  Spring Cloud Contract也支持这一点。 <br><br><h2>  CDC适用性 </h2><br> 消费者驱动合同的局限性是什么？ <br><br> 要使用此方法， <b>您必须使用附加工具（</b>例如契约） <b>付费</b> 。 合同本身是一个额外的工件，这是另一个抽象，必须仔细维护并有意识地对其应用工程实践。 <br><br>  <b>它们不会代替e2e测试</b> ，因为存根仍然是存根-实际系统组件的模型，虽然可能有点，但并不符合实际情况。 通过它们，无法验证复杂的方案。 <br><br> 而且， <b>CDC不能替代API功能测试</b> 。 与普通的旧单元测试相比，它们的支持成本更高。 契约开发人员建议使用以下试探法-如果您删除合同并且这不会导致客户端出错或误解，则不需要此方法。 例如，如果客户端以相同的方式处理它们，则不必通过合同来绝对描述所有API错误代码。 换句话说，合同<strong>仅为</strong>服务描述<strong>对其客户重要的内容</strong> 。 不多，但不少。 <br><br> 太多的合同也使API的发展变得复杂。  <b>每增加一份合同都是进行红色测试的机会</b> 。 设计CDC的方式必须使每次失败测试都承载有用的语义负载，而语义负载要超过其支持成本。 例如，如果合同确定了对消费者无动于衷的某个文本字段的最小长度（他使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Toleran Reader</a>技术），那么每次更改此最小值都会破坏合同，并破坏周围的人的神经。 这种检查需要转移到API本身的级别并根据限制的来源来实施。 <br><br><h2> 结论 </h2><br>  CDC通过明确描述集成行为来提高产品质量。 它可以帮助客户和服务开发人员达成共识，使您可以通过代码进行交谈。 但这是以增加工具，引入新的抽象和团​​队成员的额外行动为代价的。 <br><br> 同时，CDC工具和框架正在积极开发中，并且已经可以在您的项目上进行测试。 测试:) <br><br><blockquote> 在5月27日至28日举行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QualityConf</a>会议上，Andrei Markelov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将讨论</a>基于产品的测试技术，而Arthur Khineltsev将讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">监视</a>高负载的前端，即使很小的错误的代价也要成千上万悲伤用户。 <br><br> 快来聊天吧！ </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452960/">https://habr.com/ru/post/zh-CN452960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452946/index.html">重读Lou Greenaw的“ Windows 95 / NT编程哲学”</a></li>
<li><a href="../zh-CN452952/index.html">圣彼得堡的JetBrains开放日</a></li>
<li><a href="../zh-CN452954/index.html">建立时间，网络速度和路由：我们如何改进网状网络以及有关神经网络的一些知识</a></li>
<li><a href="../zh-CN452956/index.html">Istio和Linkerd的CPU消耗基准</a></li>
<li><a href="../zh-CN452958/index.html">JMAP-交换电子邮件时，开放协议取代IMAP</a></li>
<li><a href="../zh-CN452962/index.html">数据中心事故的主要原因是计算机和椅子之间的铺设</a></li>
<li><a href="../zh-CN452964/index.html">黎曼假设的负担得起的解释</a></li>
<li><a href="../zh-CN452966/index.html">正念神话：冥想的“神经中心”观点</a></li>
<li><a href="../zh-CN452968/index.html">PostgreSQL中的索引-10（Bloom）</a></li>
<li><a href="../zh-CN452974/index.html">异步编程（完整课程）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>