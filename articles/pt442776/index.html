<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêê ü•ë üçµ √çndices no PostgreSQL - 3 (Hash) üò∂ üåâ ‚è¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O primeiro artigo descreveu o mecanismo de indexa√ß√£o do PostgreSQL , o segundo tratou da interface dos m√©todos de acesso e agora estamos prontos para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 3 (Hash)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442776/">  O primeiro artigo descreveu o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de indexa√ß√£o do PostgreSQL</a> , o segundo tratou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da interface dos m√©todos de acesso</a> e agora estamos prontos para discutir tipos espec√≠ficos de √≠ndices.  Vamos come√ßar com o √≠ndice de hash. <br><br><h1>  Hash </h1><br><h2>  Estrutura </h2><br><h3>  Teoria geral </h3><br>  Muitas linguagens de programa√ß√£o modernas incluem tabelas de hash como o tipo de dados base.  Do lado de fora, uma tabela de hash se parece com uma matriz regular indexada com qualquer tipo de dados (por exemplo, string) e n√£o com um n√∫mero inteiro.  O √≠ndice de hash no PostgreSQL √© estruturado de maneira semelhante.  Como isso funciona? <br><br>  Como regra, os tipos de dados t√™m intervalos muito grandes de valores permitidos: quantas seq√º√™ncias diferentes podemos imaginar em uma coluna do tipo "texto"?  Ao mesmo tempo, quantos valores diferentes s√£o realmente armazenados em uma coluna de texto de alguma tabela?  Normalmente, n√£o muitos deles. <br><br>  A id√©ia do hash √© associar um n√∫mero pequeno (de 0 a <em>N</em> -1, <em>N</em> valores no total) a um valor de qualquer tipo de dado.  Uma associa√ß√£o como essa √© chamada de <em>fun√ß√£o hash</em> .  O n√∫mero obtido pode ser usado como um √≠ndice de uma matriz regular, onde as refer√™ncias √†s linhas da tabela (TIDs) ser√£o armazenadas.  Os elementos dessa matriz s√£o chamados de <em>buckets da tabela de hash</em> - um bucket pode armazenar v√°rios TIDs se o mesmo valor indexado aparecer em linhas diferentes. <br><br>  Quanto mais uniformemente uma fun√ß√£o hash distribuir valores de origem por buckets, melhor ela √©.  Mas mesmo uma boa fun√ß√£o de hash √†s vezes produz resultados iguais para diferentes valores de origem - isso √© chamado de <em>colis√£o</em> .  Portanto, um dep√≥sito pode armazenar TIDs correspondentes a chaves diferentes e, portanto, os TIDs obtidos no √≠ndice precisam ser verificados novamente. <br><a name="habracut"></a><br>  Apenas por exemplo: em que fun√ß√£o de hash para strings podemos pensar?  Deixe o n√∫mero de buckets ser 256. Ent√£o, por exemplo, um n√∫mero de buckets, podemos pegar o c√≥digo do primeiro caractere (assumindo uma codifica√ß√£o de caracteres de byte √∫nico).  Essa √© uma boa fun√ß√£o de hash?  Evidentemente, n√£o: se todas as seq√º√™ncias come√ßarem com o mesmo caractere, todas elas entrar√£o em um balde, ent√£o a uniformidade est√° fora de quest√£o, todos os valores precisar√£o ser verificados novamente e o hash n√£o far√° nenhum sentido.  E se somarmos c√≥digos de todos os caracteres do m√≥dulo 256?  Isso ser√° muito melhor, mas longe de ser o ideal.  Se voc√™ est√° interessado nas caracter√≠sticas internas de uma fun√ß√£o hash no PostgreSQL, consulte a defini√ß√£o de hash_any () no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hashfunc.c</a> . <br><br><h3>  Estrutura de √≠ndice </h3><br>  Vamos voltar ao √≠ndice de hash.  Para um valor de algum tipo de dado (uma chave de √≠ndice), nossa tarefa √© encontrar rapidamente o TID correspondente. <br><br>  Ao inserir no √≠ndice, vamos calcular a fun√ß√£o hash da chave.  As fun√ß√µes de hash no PostgreSQL sempre retornam o tipo "n√∫mero inteiro", que est√° na faixa de 2 <sup>32</sup> ‚âà 4 bilh√µes de valores.  O n√∫mero de buckets inicialmente √© igual a dois e aumenta dinamicamente para se ajustar ao tamanho dos dados.  O n√∫mero do bucket pode ser calculado a partir do c√≥digo hash usando a aritm√©tica de bits.  E este √© o balde onde colocaremos nossa TID. <br><br>  Mas isso √© insuficiente, pois os TIDs correspondentes a chaves diferentes podem ser colocados no mesmo bucket.  O que devemos fazer?  √â poss√≠vel armazenar o valor de origem da chave em um bucket, al√©m do TID, mas isso aumentaria significativamente o tamanho do √≠ndice.  Para economizar espa√ßo, em vez de uma chave, o bucket armazena o c√≥digo de hash da chave. <br><br>  Ao pesquisar no √≠ndice, calculamos a fun√ß√£o hash da chave e obtemos o n√∫mero do intervalo.  Agora, resta analisar o conte√∫do do bucket e retornar apenas os TIDs correspondentes aos c√≥digos de hash apropriados.  Isso √© feito com efici√™ncia, pois os pares armazenados "c√≥digo de hash - TID" s√£o solicitados. <br><br>  No entanto, duas chaves diferentes podem acontecer n√£o apenas para entrar em um dep√≥sito, mas tamb√©m para ter os mesmos c√≥digos de hash de quatro bytes - ningu√©m eliminou a colis√£o.  Portanto, o m√©todo de acesso solicita ao mecanismo de indexa√ß√£o geral que verifique cada TID, verificando novamente a condi√ß√£o na linha da tabela (o mecanismo pode fazer isso junto com a verifica√ß√£o de visibilidade). <br><br><h3>  Mapeando estruturas de dados para p√°ginas </h3><br>  Se observarmos um √≠ndice como exibido pelo gerenciador de cache de buffer, e n√£o da perspectiva do planejamento e execu√ß√£o de consultas, acontece que todas as informa√ß√µes e todas as linhas de √≠ndice devem ser compactadas em p√°ginas.  Essas p√°ginas de √≠ndice s√£o armazenadas no cache do buffer e removidas de l√° exatamente da mesma maneira que as p√°ginas da tabela. <br><br><img src="https://habrastorage.org/web/aa7/83b/c8c/aa783bc8cbfc4be49baec029339eb539.png"><br><br>  O √≠ndice de hash, conforme mostrado na figura, usa quatro tipos de p√°ginas (ret√¢ngulos cinza): <br><br><ul><li>  Meta p√°gina - n√∫mero da p√°gina zero, que cont√©m informa√ß√µes sobre o que est√° dentro do √≠ndice. </li><li>  P√°ginas de intervalo - p√°ginas principais do √≠ndice, que armazenam dados como pares "c√≥digo de hash - TID". </li><li>  P√°ginas excedentes - estruturadas da mesma maneira que as p√°ginas de intervalo e usadas quando uma p√°gina √© insuficiente para um intervalo. </li><li>  P√°ginas de bitmap - que acompanham as p√°ginas de estouro que est√£o limpas no momento e podem ser reutilizadas para outros buckets. </li></ul><br>  As setas para baixo que come√ßam nos elementos da p√°gina de √≠ndice representam TIDs, ou seja, refer√™ncias √†s linhas da tabela. <br><br>  Cada vez que o √≠ndice aumenta, o PostgreSQL cria instantaneamente o dobro de buckets (e, portanto, p√°ginas) que foram criados pela √∫ltima vez.  Para evitar a aloca√ß√£o desse n√∫mero potencialmente grande de p√°ginas de uma s√≥ vez, a vers√£o 10 fez o tamanho aumentar mais suavemente.  Quanto √†s p√°ginas excedentes, elas s√£o alocadas conforme a necessidade e s√£o rastreadas em p√°ginas de bitmap, que tamb√©m s√£o alocadas conforme a necessidade. <br><br>  Observe que o √≠ndice de hash n√£o pode diminuir de tamanho.  Se excluirmos algumas das linhas indexadas, as p√°ginas alocadas n√£o ser√£o retornadas ao sistema operacional, mas ser√£o reutilizadas apenas para novos dados ap√≥s VACUUMING.  A √∫nica op√ß√£o para diminuir o tamanho do √≠ndice √© reconstru√≠-lo do zero usando o comando REINDEX ou VACUUM FULL. <br><br><h2>  Exemplo </h2><br>  Vamos ver como o √≠ndice de hash √© criado.  Para evitar a cria√ß√£o de nossas pr√≥prias tabelas, a partir de agora usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o banco</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados demo</a> de transporte a√©reo e, desta vez, consideraremos a tabela de voos. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> hash(flight_no);</code> </pre> <pre> <code class="plaintext hljs">WARNING: hash indexes are not WAL-logged and their use is discouraged CREATE INDEX</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0001'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (flight_no = 'PG0001'::bpchar) -&gt; Bitmap Index Scan on flights_flight_no_idx Index Cond: (flight_no = 'PG0001'::bpchar) (4 rows)</code> </pre><br>  O que √© inconveniente na implementa√ß√£o atual do √≠ndice de hash √© que as opera√ß√µes com o √≠ndice n√£o s√£o registradas no log write-ahead (do qual o PostgreSQL avisa quando o √≠ndice √© criado).  Em conseq√º√™ncia, os √≠ndices de hash n√£o podem ser recuperados ap√≥s a falha e n√£o participam de replica√ß√µes.  Al√©m disso, o √≠ndice de hash est√° muito abaixo da "√°rvore B" em versatilidade, e sua efici√™ncia tamb√©m √© question√°vel.  Portanto, agora √© impratic√°vel usar esses √≠ndices. <br><br>  No entanto, isso mudar√° j√° neste outono (2017) quando a vers√£o 10 do PostgreSQL for lan√ßada.  Nesta vers√£o, o √≠ndice de hash finalmente conseguiu suporte para o log write-ahead;  Al√©m disso, a aloca√ß√£o de mem√≥ria foi otimizada e o trabalho simult√¢neo tornado mais eficiente. <br><br><blockquote>  Isso √© verdade.  Desde o PostgreSQL 10, os √≠ndices de hash t√™m suporte total e podem ser usados ‚Äã‚Äãsem restri√ß√µes.  O aviso n√£o √© mais exibido. <br></blockquote><br><h2>  Sem√¢ntica hash </h2><br>  Mas por que alguma vez o √≠ndice de hash sobreviveu quase desde o nascimento do PostgreSQL at√© o 9.6 ser inutiliz√°vel?  O fato √© que o DBMS faz uso extensivo do algoritmo de hash (especificamente, para jun√ß√µes e agrupamentos de hash), e o sistema deve estar ciente de qual fun√ß√£o de hash se aplica a quais tipos de dados.  Mas essa correspond√™ncia n√£o √© est√°tica e n√£o pode ser definida de uma vez por todas, pois o PostgreSQL permite que novos tipos de dados sejam adicionados em tempo real.  E este √© um m√©todo de acesso por hash, onde essa correspond√™ncia √© armazenada, representada como uma associa√ß√£o de fun√ß√µes auxiliares com fam√≠lias de operadores. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_name, amproc.amproc::<span class="hljs-type"><span class="hljs-type">regproc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_procedure <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amproc amproc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amproc.amprocfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_procedure;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_procedure --------------------+-------------------- abstime_ops | hashint4 aclitem_ops | hash_aclitem array_ops | hash_array bool_ops | hashchar ...</code> </pre><br>  Embora essas fun√ß√µes n√£o estejam documentadas, elas podem ser usadas para calcular o c√≥digo de hash para um valor do tipo de dados apropriado.  Por exemplo, a fun√ß√£o "hashtext" se usada para a fam√≠lia de operadores "text_ops": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'one'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 127722028 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'two'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 345620034 (1 row)</code> </pre><br><h2>  Propriedades </h2><br>  Vejamos as propriedades do √≠ndice de hash, onde esse m√©todo de acesso fornece ao sistema informa√ß√µes sobre ele mesmo.  Fornecemos consultas da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltima vez</a> .  Agora n√£o vamos al√©m dos resultados: <br><br><pre> <code class="plaintext hljs"> name | pg_indexam_has_property ---------------+------------------------- can_order | f can_unique | f can_multi_col | f can_exclude | t name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | t name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Uma fun√ß√£o de hash n√£o ret√©m a rela√ß√£o de ordem: se o valor de uma fun√ß√£o de hash para uma chave for menor que para a outra, √© imposs√≠vel tirar conclus√µes sobre como as pr√≥prias chaves s√£o ordenadas.  Portanto, em geral, o √≠ndice de hash pode suportar a √∫nica opera√ß√£o "igual": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_name, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_operator ---------------+---------------------- abstime_ops | =(abstime,abstime) aclitem_ops | =(aclitem,aclitem) array_ops | =(anyarray,anyarray) bool_ops | =(boolean,boolean) ...</code> </pre><br>  Conseq√ºentemente, o √≠ndice de hash n√£o pode retornar dados ordenados ("can_order", "orderable").  O √≠ndice de hash n√£o manipula NULLs pelo mesmo motivo: a opera√ß√£o "igual" n√£o faz sentido para NULL ("search_nulls"). <br><br>  Como o √≠ndice de hash n√£o armazena chaves (mas apenas seus c√≥digos de hash), ele n√£o pode ser usado para acesso somente ao √≠ndice ("retorn√°vel"). <br><br>  Este m√©todo de acesso tamb√©m n√£o suporta √≠ndices com v√°rias colunas ("can_multi_col"). <br><br><h2>  Internals </h2><br>  A partir da vers√£o 10, ser√° poss√≠vel procurar internals no √≠ndice de hash por meio da extens√£o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pageinspect</a> ".  √â assim que ser√°: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  A p√°gina meta (obtemos o n√∫mero de linhas no √≠ndice e o n√∫mero m√°ximo de buckets usados): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- metapage (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ntuples, maxbucket <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> ntuples | maxbucket ---------+----------- 33121 | 127 (1 row)</code> </pre><br>  Uma p√°gina de intervalo (obtemos o n√∫mero de tuplas ativas e mortas, ou seja, aquelas que podem ser aspiradas): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- bucket (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> live_items, dead_items <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_page_stats(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> live_items | dead_items ------------+------------ 407 | 0 (1 row)</code> </pre><br>  E assim por diante  Mas dificilmente √© poss√≠vel descobrir o significado de todos os campos dispon√≠veis sem examinar o c√≥digo-fonte.  Se voc√™ deseja fazer isso, comece com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">README</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442776/">https://habr.com/ru/post/pt442776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442760/index.html">Um artigo sobre como o CommVault faz backup do PostgreSQL</a></li>
<li><a href="../pt442762/index.html">O estagi√°rio Vasya e suas hist√≥rias sobre a API de idempot√™ncia</a></li>
<li><a href="../pt442764/index.html">Resumo do Gerenciamento de Produto. O que excita produtos e profissionais de marketing em 2019</a></li>
<li><a href="../pt442770/index.html">Vis√£o geral dos scanners de c√≥digo de barras JavaScript</a></li>
<li><a href="../pt442772/index.html">Matem√°tica para cientista de dados: se√ß√µes necess√°rias</a></li>
<li><a href="../pt442778/index.html">Learning Go: uma sele√ß√£o de relat√≥rios de v√≠deo</a></li>
<li><a href="../pt442780/index.html">Equ√≠vocos mais comuns na f√≠sica popular</a></li>
<li><a href="../pt442782/index.html">VShard - escala horizontal em Tarantool</a></li>
<li><a href="../pt442784/index.html">Seq√ºestro de BGP adicionando a v√≠tima AS ao AS-SET do atacante</a></li>
<li><a href="../pt442786/index.html">7 dicas √∫teis para usar o quarto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>