<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⤴️ 🤛🏻 🚑 Familiaridade com testes em Python. Parte 1 🧓🏽 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👩🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia a todos! 

 Da nossa mesa para a sua ... Ou seja, do nosso curso "Desenvolvedor Python", apesar da rápida aproximação do Ano Novo, preparamos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Familiaridade com testes em Python. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/433358/"> Bom dia a todos! <br><br>  <s>Da nossa mesa para a sua ...</s> Ou seja, do nosso curso "Desenvolvedor Python", apesar da rápida aproximação do Ano Novo, preparamos uma tradução interessante para você sobre vários métodos de teste em Python. <br><br>  Este guia é para aqueles que já escreveram um aplicativo Python legal, mas ainda não o escreveram para <br>  eles testes. <br><br>  Testar em Python é um tópico extenso com várias sutilezas, mas não é necessário complicar as coisas.  Em algumas etapas simples, você pode criar testes simples para o aplicativo, aumentando gradualmente a complexidade com base neles. <br><br>  Neste guia, você aprenderá como criar um teste básico, executá-lo e encontrar todos os erros antes que os usuários o façam!  Você aprenderá sobre as ferramentas disponíveis para escrever e executar testes, verificar o desempenho do aplicativo e até mesmo examinar problemas de segurança. <br><br><img src="https://habrastorage.org/webt/kh/va/x5/khvax5ew8tluy6c9muhw-oei7cm.png"><br><a name="habracut"></a><br>  <b>Teste de código</b> <br><br>  Você pode testar o código de várias maneiras.  Neste guia, você aprenderá sobre os métodos, do mais simples ao mais avançado. <br><br>  <i><b>Automatizado vs.</b></i>  <i><b>Teste manual</b></i> <i><br></i> <br>  Boas notícias!  Provavelmente você já fez o teste, mas ainda não o realizou.  Lembra como você iniciou o aplicativo e o usou?  Você já testou as funções e fez experiências com elas?  Esse processo é chamado de teste exploratório e é uma forma de teste manual. <br><br>  Teste de pesquisa - teste feito sem um plano.  Durante o teste de pesquisa, você pesquisa o aplicativo. <br><br>  Para criar uma lista completa de testes manuais, basta fazer uma lista de todas as funções do aplicativo, os vários tipos de entrada que ele aceita e os resultados esperados.  Agora, toda vez que você altera algo no código, é necessário verificar novamente cada um dos elementos nesta lista. <br><br>  Parece sombrio, certo? <br><br>  Portanto, são necessários testes automáticos.  Teste automático - a execução do plano de teste (partes do aplicativo que exigem teste, a ordem dos testes e os resultados esperados) usando um script, e não por mãos humanas.  O Python já possui um conjunto de ferramentas e bibliotecas para ajudá-lo a criar testes automatizados para o seu aplicativo.  Vejamos essas ferramentas e bibliotecas em nosso tutorial. <br><br>  <i><b>Testes de Unidade VS.</b></i>  <i><b>Testes de integração</b></i> <br><br>  O mundo dos testes é cheio de termos e, agora, conhecendo a diferença entre testes manuais e automatizados, desceremos um nível mais profundo. <br><br>  Pense em como você pode testar os faróis de um carro?  Você acende os faróis (vamos chamá-lo de etapa de teste), saia do carro ou peça a um amigo para verificar se os faróis estão acesos (e isso é uma proposta de teste).  Testar vários componentes é chamado teste de integração. <br><br>  Pense em todas as coisas que devem funcionar corretamente para que uma tarefa simples produza o resultado correto.  Esses componentes são semelhantes às partes do seu aplicativo: todas essas classes, funções, módulos que você escreveu. <br><br>  A principal dificuldade do teste de integração surge quando o teste de integração não fornece o resultado correto.  É difícil avaliar o problema, não sendo possível isolar a parte quebrada do sistema.  Se os faróis não estiverem acesos, as lâmpadas podem estar quebradas.  Ou talvez a bateria esteja fraca?  Ou talvez o problema esteja no gerador?  Ou até mesmo uma falha no computador da máquina? <br><br>  Os próprios carros modernos notificarão você sobre uma lâmpada quebrada.  Isso é determinado usando um teste de unidade. <br><br>  O teste de unidade (teste de unidade) é um pequeno teste que verifica a operação correta de um componente individual.  O teste de unidade ajuda a isolar a avaria e corrigi-la mais rapidamente. <br><br>  Nós conversamos sobre dois tipos de testes: <br><br><ol><li>  Um teste de integração que verifica os componentes do sistema e sua interação entre si; </li><li>  Um teste de unidade que testa um único componente de um aplicativo. </li><li>  Você pode criar os dois testes em Python.  Para escrever um teste para a função sum () interna, você precisa comparar a saída de sum () com valores conhecidos. </li></ol><br>  Por exemplo, dessa maneira, você pode verificar se a soma dos números (1, 2, 3) é 6: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Os valores estão corretos, portanto, nada será emitido para o REPL.  Se o resultado de <code>sum()</code> incorreto, um <code>AssertionError</code> será <code>AssertionError</code> com a mensagem "Deve ser 6".  Verifique a instrução novamente, mas agora com valores inválidos para obter um <code>AssertionError</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  No REPL, você verá <code>AssertionError</code> pois o <code>sum()</code> não é 6. <br><br>  Em vez de REPL, coloque isso em um novo arquivo Python chamado <code>test_sum.py</code> e execute-o novamente: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre> <br>  Agora você tem um caso de teste escrito (caso de teste), instrução e ponto de entrada (linha de comando).  Agora isso pode ser feito na linha de comando: <br><br><pre> <code class="python hljs">$ python test_sum.py Everything passed</code> </pre> <br>  Você vê o resultado bem-sucedido, "Tudo passou". <br><br>  <code>sum()</code> em Python aceita qualquer iterável como o primeiro argumento.  Você verificou a lista.  Vamos tentar testar a tupla.  Crie um novo arquivo chamado <code>test_sum_2.py</code> com o seguinte código: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() test_sum_tuple() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre><br>  <code>test_sum_2.py</code> , o script gerará <code>test_sum_2.py</code> erro, pois s <code>um() (1, 2, 2)</code> deve ser 5, e não 6. Como resultado, o script fornece uma mensagem de erro, uma linha de código e um retorno: <br><br><pre> <code class="python hljs">$ python test_sum_2.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; test_sum_tuple() File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Você pode ver como um erro no código causa um erro no console com informações sobre onde ocorreu e qual foi o resultado esperado. <br><br>  Esses testes são adequados para verificação simples, mas e se houver mais erros do que em um?  Os corredores de teste vêm ao resgate.  O Test Executor é um aplicativo especial projetado para realizar testes, verificar dados de saída e fornecer ferramentas para depuração e diagnóstico de testes e aplicativos. <br><br>  <i><b>Escolhendo um executor de teste</b></i> <br><br>  Existem muitos corredores de teste disponíveis para Python.  Por exemplo, o unittest é incorporado à biblioteca padrão do Python.  Neste guia, usaremos casos de teste e executores de teste mais unittest.  Os princípios operacionais mais unittest são facilmente adaptáveis ​​a outras estruturas.  Listamos os executores de teste mais populares: <br><br><ul><li>  mais unittest; </li><li>  nariz ou nariz2; </li><li>  pytest. </li></ul><br>  É importante escolher um contratado de teste que atenda aos seus requisitos e experiência. <br><br>  <b>mais unittest</b> <br><br>  O unittest foi integrado à biblioteca padrão do Python desde a versão 2.1.  Você provavelmente o encontrará em aplicativos comerciais Python e em projetos de código aberto. <br>  O Unittest possui uma estrutura de teste e um executor de teste.  Ao escrever e executar testes, você precisa seguir alguns requisitos importantes. <br><br>  unittest requer: <br><br><ul><li>  Coloque testes em classes como métodos; </li><li>  Use métodos especiais de aprovação.  A classe TestCase, em vez da expressão de declaração interna usual. </li></ul><br><br>  Para transformar um exemplo escrito anteriormente em um caso de teste mais unívoco, você deve: <br><br><ol><li>  Importar unittest da biblioteca padrão; </li><li>  Crie uma classe chamada <code>TestSum</code> que herdará a classe <code>TestCase</code> ; </li><li>  Converta funções de teste em métodos adicionando <code>self</code> como o primeiro argumento; </li><li>  Modifique as instruções adicionando o uso do método <code>self.assertEqual()</code> na classe <code>TestCase</code> ; </li><li>  Altere o ponto de entrada na linha de comando para chamar <code>unittest.main()</code> . </li></ol><br>  Seguindo estas etapas, crie um novo arquivo test_sum_unittest.py com este código: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Ao fazer isso na linha de comando, você obterá uma conclusão bem-sucedida (indicada por.) E outra sem êxito (indicada por F): <br><br><pre> <code class="python hljs">$ python test_sum_unittest.py .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Assim, você executou dois testes usando o corredor de teste mais unittest. <br><br>  <i>Nota: Se você estiver escrevendo casos de teste para Python 2 e 3, tenha cuidado.</i>  <i>Nas versões do Python 2.7 e abaixo, o unittest é chamado unittest 2. Quando você importa do unittest, você obtém versões diferentes com funções diferentes no Python 2 e Python 3.</i> <br><br>  Para saber mais sobre o unittest, leia a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação unittest</a> . <br><br>  <b>nariz</b> <br><br>  Com o tempo, depois de escrever centenas ou mesmo milhares de testes para um aplicativo, torna-se cada vez mais difícil entender e usar dados de saída mais unidos. <br><br>  O nariz é compatível com todos os testes escritos com uma estrutura mais unida e pode substituir seu executor de teste.  O desenvolvimento do nariz, como um aplicativo de código aberto, começou a desacelerar e o nariz2 foi criado.  Se você estiver começando do zero, é recomendável usar o nariz2. <br><br>  Para começar com o nose2, você precisa instalá-lo no PyPl e executá-lo na linha de comando.  O nose2 tentará encontrar todos os scripts de teste com <code>test*.py</code> no nome e todos os casos de teste herdados do unittest.TestCase no seu diretório atual: <br><br><pre> <code class="python hljs">$ pip install nose2 $ python -m nose2 .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  É assim que o teste criado em <code>test_sum_unittest.py</code> partir do executor de testes do nose2.  O nose2 fornece muitos sinalizadores de linha de comando para filtrar testes executáveis.  Para mais informações, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nose 2</a> . <br><br>  <b>pytest</b> <br><br>  pytest suporta casos de teste mais unittest.  Mas a vantagem real do pytest é seus casos de teste.  Os casos de teste pytest são uma série de funções em um arquivo Python com test_ no início do nome. <br><br>  Existem outros recursos úteis: <br><br><ul><li>  Suporte para expressões de declaração internas em vez de usar métodos self.assert * () especiais; </li><li>  Suporte para filtragem de casos de teste; </li><li>  A capacidade de reiniciar a partir do último teste com falha; </li><li>  Um ecossistema de centenas de plugins que ampliam a funcionalidade. </li></ul><br>  Um exemplo de caso de teste TestSum para pytest terá a seguinte aparência: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Você se livrou do TestCase, usando classes e pontos de entrada da linha de comando. <br>  Mais informações podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site de documentação</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pytest</a> . <br><br>  <b>Escrevendo o primeiro teste</b> <br><br>  Combine tudo o que já aprendemos e, em vez da função interna <code>sum()</code> , testamos uma implementação simples com os mesmos requisitos. <br><br>  Crie uma nova pasta para o projeto, dentro da qual crie uma nova pasta chamada my_sum.  Dentro de my_sum, crie um arquivo vazio chamado <code>_init_.py</code> .  A presença desse arquivo significa que a pasta my_sum pode ser importada como um módulo do diretório pai. <br><br>  A estrutura da pasta ficará assim: <br><br> <code>project/ <br> │ <br> └── my_sum/ <br> └── __init__.py</code> <br> <br>  Abra <code>my_sum/__init__.py</code> e crie uma nova função chamada <code>sum()</code> , que recebe entradas <code>my_sum/__init__.py</code> (lista, tupla, conjunto) e adiciona os valores. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arg: total += val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total</code> </pre> <br>  Este exemplo cria uma variável chamada <code>total</code> , itera sobre todos os valores em <code>arg</code> e adiciona ao <code>total</code> .  Em seguida, após a conclusão da iteração, o resultado é retornado. <br><br>  <b>Onde escrever um teste</b> <br><br>  Você pode começar a escrever um teste criando um arquivo <code>test.py</code> que conterá seu primeiro caso de teste.  Para testar, o arquivo deve poder importar seu aplicativo, então coloque <code>test.py</code> na pasta acima do pacote.  A árvore de diretórios ficará assim: <br><br> <code>project/ <br> │ <br> ├── my_sum/ <br> │ └── __init__.py <br> | <br> └── test.py</code> <br> <br>  Você notará que, à medida que adiciona novos testes, seu arquivo se torna mais pesado e difícil de manter; portanto, recomendamos criar a pasta <code>tests/</code> e dividir os testes em vários arquivos.  Verifique se os nomes de todos os arquivos começam com <code>test_</code> , para que os <code>test_</code> compreendam que os arquivos Python contêm testes que precisam ser executados.  Em projetos grandes, os testes são divididos em vários diretórios, dependendo de sua finalidade ou uso. <br><br>  <i>Nota: E qual é o seu aplicativo é um único script?</i> <i><br></i>  <i>Você pode importar qualquer atributo de script: classes, funções ou variáveis, usando a função <code>__import__()</code> .</i>  <i>Em vez da <code>from my_sum import sum</code> escreva o seguinte:</i> <br><br><pre> <code class="python hljs">target = __import__(<span class="hljs-string"><span class="hljs-string">"my_sum.py"</span></span>) sum = target.sum</code> </pre> <br>  <i>Ao usar <code>__import__()</code> você não precisa transformar a pasta do projeto em um pacote e pode especificar o nome do arquivo.</i>  <i>Isso é útil se o nome do arquivo entrar em conflito com os nomes das bibliotecas de pacotes padrão.</i>  <i>Por exemplo, se <code>math.py</code> entrar em conflito com o módulo de matemática.</i> <br><br>  <b>Como estruturar um teste simples</b> <br><br>  Antes de escrever testes, você precisa resolver algumas perguntas: <br><br><ol><li>  O que você quer testar? </li><li>  Você está escrevendo um teste de unidade ou de integração? </li></ol><br>  Você está testando <code>sum()</code> .  Você pode testar diferentes comportamentos, por exemplo: <br><br><ul><li>  É possível resumir uma lista de números inteiros? </li><li>  É possível resumir uma tupla ou um conjunto? </li><li>  Posso resumir uma lista de números de ponto flutuante? </li><li>  O que acontece se você atribuir um valor ruim à entrada: um único número inteiro ou uma string? </li><li>  O que acontece se um dos valores for negativo? </li></ul><br>  A maneira mais fácil de testar é uma lista de números inteiros.  Crie um arquivo <code>test.py</code> com o seguinte código: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  O código neste exemplo: <br><br><ul><li>  Importa <code>sum()</code> do pacote <code>my_sum()</code> que você criou; </li><li>  Define uma nova classe de caso de teste chamada TestSum que herda <code>unittest.TestCase</code> ; </li><li>  Define um método test <code>.test_list_int()</code> para testar uma lista inteira.  O método <code>.test_list_int()</code> fará o seguinte </li></ul>  : <br><ol><li>  Declara uma variável de <code>data</code> com uma lista de valores <code>(1, 2, 3)</code> ; </li><li>  <code>my_sum.sum(data)</code> valor <code>my_sum.sum(data)</code> <code>result</code> <code>my_sum.sum(data)</code> variável; </li><li>  Determina que o valor do resultado seja 6 usando o método <code>.assertEqual()</code> na classe <code>unittest.TestCase</code> . </li></ol><br><ul><li>  Define um ponto de entrada da linha de comando que inicia o executor de teste <code>.main()</code> . </li></ul><br>  Se você não souber o que é, ou como <code>.assertEqual()</code> é definido, poderá atualizar seu conhecimento de programação orientada a objetos com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programação Orientada a Objetos do Python 3</a> . <br><br>  <b>Como escrever instruções</b> <br><br>  A etapa final ao escrever um teste é verificar se a saída corresponde aos valores conhecidos.  Isso é chamado de afirmação.  Existem várias diretrizes gerais para escrever declarações: <br><br><ul><li>  Verifique se os testes são repetíveis e execute-os várias vezes para garantir que eles apresentem os mesmos resultados a cada vez; </li><li>  Verifique e confirme os resultados que se aplicam à sua entrada - verifique se o resultado é realmente a soma dos valores no exemplo <code>sum()</code> . </li></ul><br>  O Unittest possui muitos métodos para confirmar os valores, tipos e existência de variáveis.  Aqui estão alguns dos métodos mais usados: <br><br><table><tbody><tr><th>  Método </th><th>  Equivalente </th></tr><tr><td>  .assertEqual (a, b) </td><td>  a == b </td></tr><tr><td>  .assertTrue (x) </td><td>  bool (x) é True </td></tr><tr><td>  .assertFalse (x) </td><td>  bool (x) é False </td></tr><tr><td>  .assertIs (a, b) </td><td>  a é b </td></tr><tr><td>  .assertIsNone (x) </td><td>  x é nenhum </td></tr><tr><td>  .assertIn (a, b) </td><td>  a em b </td></tr><tr><td>  .assertIsInstance (a, b) </td><td>  instância (a, b) </td></tr></tbody></table><br><br>  <code>.assertIs()</code> , <code>.assertIsNone()</code> , <code>.assertIn()</code> e <code>.assertIsInstance()</code> têm métodos opostos chamados <code>.assertIsNot()</code> e assim por diante. <br><br>  <b>Efeitos colaterais</b> <br><br>  Escrever testes é mais difícil do que apenas observar o valor de retorno de uma função.  Frequentemente, a execução do código altera outras partes do ambiente: atributos de classe, arquivos do sistema de arquivos, valores no banco de dados.  Essa é uma parte importante do teste, chamada de efeitos colaterais.  Decida se você está testando um efeito colateral antes de incluí-lo em sua lista de reivindicações. <br><br>  Se você achar que existem muitos efeitos colaterais no bloco de código que deseja testar, estará violando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Princípio da responsabilidade exclusiva</a> .  Violar o princípio da única responsabilidade significa que um pedaço de código faz muitas coisas e requer refatoração.  Seguir o princípio da responsabilidade exclusiva é uma ótima maneira de projetar código para o qual não será difícil escrever testes de unidade simples e repetíveis e, finalmente, criar aplicativos confiáveis. <br><br>  <b>Lançamento do primeiro teste</b> <br><br>  Você criou o primeiro teste e agora precisa tentar executá-lo.  É claro que será aprovado, mas antes de criar testes mais complexos, você precisa garantir que mesmo esses testes sejam bem-sucedidos. <br><br>  <b>Executando Executores de Teste</b> <br><br>  Executor de teste - um aplicativo Python que executa o código de teste, valida asserções e exibe os resultados do teste no console.  No final do test.py, adicione este pequeno pedaço de código: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Este é o ponto de entrada da linha de comandos.  Se você executar esse script executando python <code>test.py</code> na linha de comando, ele chamará <code>unittest.main()</code> .  Isso inicia o <code>unittest.TestCase</code> teste detectando todas as classes neste arquivo <code>unittest.TestCase</code> do <code>unittest.TestCase</code> . <br><br>  Essa é uma das muitas maneiras de executar o corredor de teste mais unittest.  Se você tiver um único arquivo de teste chamado <code>test.py</code> , chamar python test.py é uma ótima maneira de começar. <br><br>  Outra maneira é usar a linha de comando mais unittest.  Vamos tentar: <br><br><pre> <code class="python hljs">$ python -m unittest test</code> </pre> <br>  Isso executará o mesmo módulo de teste (chamado <code>test</code> ) através da linha de comando.  Você pode adicionar parâmetros adicionais para alterar a saída.  Um deles é -v para detalhado.  Vamos tentar o seguinte: <br><br><pre> <code class="bash hljs">$ python -m unittest -v <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test_list_int (test.TestSum) ... ok ---------------------------------------------------------------------- Ran 1 tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.000s</code> </pre><br>  Executamos um teste no test.py e exibimos os resultados no console.  O modo detalhado listou os nomes dos testes realizados e os resultados de cada um deles. <br><br>  Em vez de fornecer o nome do módulo que contém os testes, você pode solicitar a descoberta automática usando o seguinte: <br><br><pre> <code class="python hljs">$ python -m unittest discover</code> </pre> <br>  Este comando procurará no diretório atual arquivos com <code>test*.py</code> no nome para testá-los. <br><br>  Se você tiver vários arquivos de teste e seguir o padrão de nomeação <code>test*.py</code> , poderá passar o nome do diretório usando o sinalizador -s e o nome da pasta. <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests</code> </pre> <br>  O unittest executará todos os testes em um único plano de teste e produzirá os resultados. <br>  Por fim, se o código-fonte não estiver no diretório raiz, mas em um subdiretório, por exemplo, em uma pasta chamada src /, você poderá dizer a unittest onde executar os testes usando o sinalizador -t para importar corretamente os módulos: <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests -t src</code> </pre> <br>  O unittest encontrará todos <code>test*.py</code> arquivos <code>test*.py</code> no diretório <code>src/</code> dentro dos <code>tests</code> e os executa. <br><br>  <b>Compreendendo os resultados do teste</b> <b><br></b> <br>  Este foi um exemplo muito simples, onde tudo correu bem, então vamos tentar entender a saída de um teste que falhou. <br><br>  <code>sum()</code> deve aceitar outras listas de um tipo numérico, por exemplo, frações. <br><br>  No início do código em <code>test.py</code> adicione uma expressão para importar o tipo de <code>fractions</code> módulo de <code>fractions</code> da biblioteca padrão. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fractions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fraction</code> </pre> <br>  Agora adicione um teste com uma instrução, esperando um valor incorreto.  No nosso caso, esperamos que a soma de ¼, ¼ e ⅖ seja igual a 1: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_fraction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of fractions """</span></span> data = [Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre><br>  Se você executar os testes novamente com o teste unittest python -m, faça o seguinte: <br><br><pre> <code class="python hljs">$ python -m unittest test F. ====================================================================== FAIL: test_list_fraction (test.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_list_fraction self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) AssertionError: Fraction(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Nesta saída, você vê o seguinte: <br><br><ul><li>  A primeira linha mostra os resultados de todos os testes: um falhou (F), um passou (.); </li><li>  FAIL mostra alguns detalhes do teste que falhou: </li></ul><br><ol><li>  O nome do método de teste ( <code>test_list_fraction</code> ); </li><li>  Módulo de <code>test</code> ( <code>test</code> ) e caso de teste ( <code>TestSum</code> ); </li><li>  Traceback strings com um erro; </li><li>  Detalhes da declaração com o resultado esperado (1) e o resultado real (Fração (9, 10)) </li></ol><br>  Lembre-se de que você pode adicionar informações adicionais à saída de teste usando o sinalizador -v no <code>python -m unittest</code> . <br><br>  <b>Executando testes do PyCharm</b> <br><br>  Se você estiver usando o PyCharm IDE, poderá executar o unittest ou o pytest seguindo estas etapas: <br><br><ol><li>  Na janela da ferramenta Projeto, selecione o diretório de testes. </li><li>  No menu de contexto, selecione o comando de execução mais unittest.  Por exemplo, 'Unittests in my Tests ...'. </li></ol><br>  Isso será executado unittest na janela de teste e retornará os resultados no PyCharm: <br><br><img src="https://habrastorage.org/webt/i0/5e/xv/i05exvqd-ph8-jisw2a1ejgop_c.png"><br><br>  Mais informações estão disponíveis no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do PyCharm</a> . <br><br>  <b>Executando testes do código do Visual Studio</b> <br><br>  Se você usa o IDE do Microsoft Visual Studio Code, o suporte para unittest, nose e pytest já está incorporado no plug-in Python. <br><br>  Se você o tiver instalado, poderá configurar a configuração de teste abrindo a Paleta de Comandos com Ctrl + Shift + P e escrevendo "Teste Python".  Você verá uma lista de opções: <br><br><img src="https://habrastorage.org/webt/b1/zs/10/b1zs10n-ydybrqz62ywpknjp89q.png"><br><br>  Selecione Depurar todos os testes de unidade, após o qual o VSCode enviará uma solicitação para configurar a estrutura de teste.  Clique na engrenagem para selecionar o corredor de teste (mais unittest) e o diretório inicial (.). <br><br>  Após a conclusão da instalação, você verá o status dos testes na parte inferior da tela e poderá acessar rapidamente os logs de teste e reiniciar os testes clicando nos ícones: <br><br><img src="https://habrastorage.org/webt/rk/k6/cm/rkk6cmqzjwmtc-4upzozzurcjh4.png"><br><br>  Vimos que os testes estão sendo realizados, mas alguns deles falharam. <br><br>  O FIM <br><br>  Na próxima parte do artigo, examinaremos testes para estruturas como Django e Flask. <br><br>  Estamos aguardando suas perguntas e comentários aqui e, como sempre, você pode ir a Stanislav em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dia aberto</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segunda parte</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433358/">https://habr.com/ru/post/pt433358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433348/index.html">DSL digitado no TypeScript de JSX</a></li>
<li><a href="../pt433350/index.html">Eventos digitais em Moscou, de 17 a 23 de dezembro</a></li>
<li><a href="../pt433352/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 343 (10 a 16 de dezembro de 2018)</a></li>
<li><a href="../pt433354/index.html">Notícias do mundo do OpenStreetMap nº 438 (04/04/2018 - 10/12/2018)</a></li>
<li><a href="../pt433356/index.html">Os invasores aprenderam a ignorar a autenticação de dois fatores Yahoo Mail e Gmail</a></li>
<li><a href="../pt433360/index.html">Cientistas tentaram prever quando aviões elétricos se tornarão realidade</a></li>
<li><a href="../pt433362/index.html">9 princípios de beleza, simplicidade e cuidado no UX</a></li>
<li><a href="../pt433364/index.html">LDraw + Unity. Como eu gerei Lego</a></li>
<li><a href="../pt433366/index.html">Trabalhando com recursos externos no Unity3D</a></li>
<li><a href="../pt433368/index.html">Como aplicar o pensamento do supermercado ao mundo: um exemplo de moletom</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>