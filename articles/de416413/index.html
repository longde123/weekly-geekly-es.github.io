<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÄ ‚úçüèº üíî Kam, sah, verallgemeinerte: eingetaucht in Java Generics üë©üèº‚Äçüíº üö∞ üìè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Generics ist eine der wichtigsten √Ñnderungen in der Geschichte der Java-Sprache. Mit Java 5 verf√ºgbare Generika haben die Verwendung des Java Col...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kam, sah, verallgemeinerte: eingetaucht in Java Generics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java Generics ist eine der wichtigsten √Ñnderungen in der Geschichte der Java-Sprache.  Mit Java 5 verf√ºgbare Generika haben die Verwendung des Java Collection Framework einfacher, bequemer und sicherer gemacht.  Fehler, die mit einer falschen Verwendung von Typen verbunden sind, werden jetzt in der Kompilierungsphase erkannt.  Ja, und die Java-Sprache selbst ist noch sicherer geworden.  Trotz der offensichtlichen Einfachheit generischer Typen haben viele Entwickler Schwierigkeiten, sie zu verwenden.  In diesem Beitrag werde ich √ºber die Funktionen der Arbeit mit Java Generics sprechen, damit Sie weniger von diesen Schwierigkeiten haben.  N√ºtzlich, wenn Sie kein generischer Guru sind und dabei helfen, viele Schwierigkeiten beim Eintauchen in das Thema zu vermeiden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2>  Arbeiten Sie mit Sammlungen </h2><br>  Angenommen, eine Bank muss die H√∂he der Einsparungen auf Kundenkonten berechnen.  Vor dem Aufkommen von ‚ÄûGenerika‚Äú sah die Methode zur Berechnung der Summe folgenderma√üen aus: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Wir haben iteriert, die Liste der Konten durchgesehen und √ºberpr√ºft, ob das Element aus dieser Liste wirklich eine Instanz der <code>Account</code> Klasse ist, dh das Konto des Benutzers.  Der Typ unseres Objekts der <code>Account</code> Klasse und die <code>getAmount</code> Methode wurden <code>getAmount</code> , wodurch der Betrag in diesem Konto zur√ºckgegeben wurde.  Dann fassten sie alles zusammen und gaben den Gesamtbetrag zur√ºck.  Es waren zwei Schritte erforderlich: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br>  Wenn Sie ( <code>instanceof</code> ) nicht auf Zugeh√∂rigkeit zur <code>Account</code> Klasse pr√ºfen, ist in der zweiten Phase eine <code>ClassCastException</code> m√∂glich, <code>ClassCastException</code> ein Programmabsturz.  Daher war eine solche √úberpr√ºfung obligatorisch. <br><br>  Mit dem Aufkommen von Generics ist die Notwendigkeit der Typpr√ºfung und des Castings verschwunden: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  Jetzt Methode <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre>  akzeptiert als Argumente nur eine Liste von Objekten der Klasse <code>Account</code> .  Diese Einschr√§nkung wird in der Methode selbst angegeben, in ihrer Signatur kann der Programmierer einfach keine andere Liste √ºbertragen - nur die Liste der Client-Konten. <br><br>  Wir m√ºssen den Typ der Elemente aus dieser Liste nicht √ºberpr√ºfen: Dies wird durch die Typbeschreibung des Methodenparameters impliziert <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  (Kann als <code>   Account</code> gelesen werden).  Und der Compiler gibt einen Fehler aus, wenn etwas schief geht - das hei√üt, wenn jemand versucht, eine Liste anderer Objekte als der <code>Account</code> Klasse an diese Methode zu √ºbergeben. <br><br>  In der zweiten Zeile der Pr√ºfung verschwand auch die Notwendigkeit.  Falls erforderlich, wird das <code>casting</code> in der Kompilierungsphase durchgef√ºhrt. <br><br><h2>  Substitutionsprinzip </h2><br>  Das Substitutionsprinzip von Barbara Liskov ist eine spezifische Definition eines Subtyps in der objektorientierten Programmierung.  Liskovs Idee eines ‚ÄûSubtyps‚Äú definiert das Konzept der Substitution: Wenn <code>S</code> ein Subtyp von <code>T</code> , k√∂nnen Objekte vom Typ <code>T</code> in einem Programm durch Objekte vom Typ <code>S</code> ohne dass die gew√ºnschten Eigenschaften dieses Programms ge√§ndert werden. <br><br><table><tbody><tr><td>  <b>Typ</b> <br></td><td>  <b>Subtyp</b> <br></td></tr><tr><td>  <i>Nummer</i> <br></td><td>  <i>Ganzzahl</i> <br></td></tr><tr><td>  <i>Liste</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Sammlung</i> &lt;E&gt; <br></td><td>  <i>Liste</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Iterable</i> &lt;E&gt; <br></td><td>  <i>Sammlung</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>Beispiele f√ºr Typ / Subtyp-Beziehungen</i> <br><br>  Hier ist ein Beispiel f√ºr die Verwendung des Substitutionsprinzips in Java: <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code> ist ein Subtyp von <code>Number</code> . Daher kann der Variablen <code>n</code> Typ <code>Number</code> der Wert zugewiesen werden, den die Methode <code>Integer.valueOf(42)</code> zur√ºckgibt. <br><br><h2>  Kovarianz, Kontravarianz und Invarianz </h2><br>  Zun√§chst eine kleine Theorie.  Kovarianz ist die Beibehaltung der Vererbungshierarchie von Quelltypen in abgeleiteten Typen in derselben Reihenfolge.  Wenn die <i>Katze</i> beispielsweise ein Subtyp von <i>Tieren ist</i> , ist die <i>Gruppe von &lt;Katzen&gt;</i> ein Subtyp der <i>Gruppe von &lt;Tieren&gt;</i> .  Unter Ber√ºcksichtigung des Substitutionsprinzips kann daher folgende Zuordnung vorgenommen werden: <br><br>  <i>Viele &lt;Tiere&gt; = Viele &lt;Katzen&gt;</i> <br><br>  Kontravarianz ist die Umkehrung der Hierarchie der Quelltypen in abgeleiteten Typen.  Wenn die <i>Katze</i> beispielsweise ein Subtyp der <code></code> , ist das <i>Set &lt;Tiere&gt;</i> ein Subtyp des <i>Sets der &lt;Katzen&gt;</i> .  Unter Ber√ºcksichtigung des Substitutionsprinzips kann daher folgende Zuordnung vorgenommen werden: <br><br>  <i>Viele &lt;Katzen&gt; = Viele &lt;Tiere&gt;</i> <br><br>  Invarianz - fehlende Vererbung zwischen abgeleiteten Typen.  Wenn die <i>Katze</i> ein Subtyp von <i>Tieren ist</i> , ist der <i>Satz von &lt;Katzen&gt;</i> kein Subtyp des <i>Satzes von &lt;Tieren&gt;</i> und der <i>Satz von &lt;Tieren&gt; ist</i> kein Subtyp des <i>Satzes von &lt;Katzen&gt;</i> . <br><br>  <b>Arrays in Java sind kovariant</b> .  Typ <code>S[]</code> ist ein Subtyp von <code>T[]</code> wenn <code>S</code> ein Subtyp von <code>T</code>  Zuordnungsbeispiel: <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br>  Wir haben der Variablen <code>arr</code> einen Link zu einem Array von Zeichenfolgen zugewiesen, dessen Typ <code>¬´ ¬ª</code> .  Wenn Arrays nicht kovariant w√§ren, k√∂nnten wir dies nicht tun.  Mit Java k√∂nnen Sie dies tun, das Programm wird kompiliert und fehlerfrei ausgef√ºhrt. <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br>  Wenn wir jedoch versuchen, den Inhalt des Arrays √ºber die Variable <code>arr</code> zu √§ndern und dort die Nummer 42 zu schreiben, erhalten wir in der Programmausf√ºhrungsphase eine <code>ArrayStoreException</code> , da 42 keine Zeichenfolge, sondern eine Zahl ist.  Dies ist der Nachteil der Kovarianz von Java-Arrays: Wir k√∂nnen in der Kompilierungsphase keine √úberpr√ºfungen durchf√ºhren, und m√∂glicherweise l√§uft bereits zur Laufzeit etwas kaputt. <br><br>  <b>"Generika" sind unver√§nderlich.</b>  Hier ist ein Beispiel: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br>  Wenn Sie eine Liste von Ganzzahlen verwenden, handelt es sich weder um einen Subtyp vom Typ <code>Number</code> noch um einen anderen Subtyp.  Er ist nur ein Subtyp von sich.  Das hei√üt, <code>List &lt;Integer&gt;</code> ist eine <code>List&lt;Integer&gt;</code> und sonst nichts.  Der Compiler stellt sicher, dass die als Liste der Objekte der <i>Integer-</i> Klasse <code>ints</code> Variable <code>ints</code> nur Objekte der <code>Integer</code> Klasse und sonst nichts enth√§lt.  In der Kompilierungsphase wird eine √úberpr√ºfung durchgef√ºhrt, und in unserer Laufzeit f√§llt nichts. <br><br><h2>  Platzhalter </h2><br>  Sind Generika immer invariant?  Nein.  Ich werde Beispiele geben: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br>  Das ist Kovarianz.  <code>List&lt;Integer&gt;</code> - Subtyp von <code>List&lt;? extends Number&gt;</code> <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br>  Das ist Kontravarianz.  <code>List&lt;Number&gt;</code> ist ein Subtyp von <code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> . <br><br>  Ein Datensatz wie <code>"? extends ..."</code> oder <code>"? super ..."</code> wird als Platzhalter oder Platzhalter mit einer Obergrenze ( <code>extends</code> ) oder einer Untergrenze ( <code>super</code> ) bezeichnet. <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code> kann Objekte enthalten, deren Klasse <code>Number</code> oder von <code>Number</code> erbt. <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code> kann Objekte enthalten, deren Klasse <code>Number</code> oder deren <code>Number</code> ein Erbe ist (Supertyp von <code>Number</code> ). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td>  erweitert <i>B</i> - Wildcard mit Obergrenze <br>  Super <i>B</i> - Platzhalter mit einer Untergrenze <br>  wobei <i>B</i> - die Grenze darstellt <br><br>  Eine Aufzeichnung der Form T <sub>2</sub> &lt;= T <sub>1</sub> bedeutet, dass die durch T <sub>2</sub> beschriebene Menge von Typen eine Teilmenge der durch T <sub>1</sub> beschriebenen Menge von Typen ist <br><br>  d.h. <br>  Nummer &lt;=?  erweitert Objekt <br>  ?  erweitert Nummer &lt;=?  erweitert Objekt <br>  und <br>  ?  Superobjekt &lt;=?  Super Nummer <br><br></td></tr></tbody></table><br>  <i>Mehr mathematische Interpretation des Themas</i> <br><br>  Ein paar Aufgaben zum Testen von Wissen: <br><br>  1. Warum tritt der Kompilierungsfehler im folgenden Beispiel auf?  Welchen Wert kann ich der <code>nums</code> hinzuf√ºgen? <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Sollte der Container mit Platzhalter deklariert werden <code>? extends</code>  <code>? extends</code> , k√∂nnen Sie nur die Werte lesen.  Der Liste kann nur <code>null</code> hinzugef√ºgt werden.  Um der Liste ein Objekt hinzuzuf√ºgen, ben√∂tigen wir einen anderen Platzhaltertyp - <code>? super</code> <code>? super</code> <br></div></div><br><br>  2. Warum kann ich keinen Artikel aus der folgenden Liste erhalten? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Sie k√∂nnen einen Artikel aus einem Container mit Platzhalter nicht lesen <code>? super</code>  <code>? super</code> , bis auf ein Objekt der Klasse <code>Object</code> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3>  Das Get and Put-Prinzip oder PECS (Producer Extends Consumer Super) </h3><br>  Die Platzhalterfunktion mit Ober- und Untergrenze bietet zus√§tzliche Funktionen f√ºr die sichere Verwendung von Typen.  Sie k√∂nnen nur von einem Variablentyp lesen, nur in einen anderen schreiben (die Ausnahme ist die M√∂glichkeit, <code>null</code> f√ºr Erweiterungen zu schreiben und <code>Object</code> f√ºr <code>super</code> lesen).  Damit Sie sich leichter merken k√∂nnen, wann welcher Platzhalter verwendet werden soll, gibt es das PECS-Prinzip - Producer Extends Consumer Super. <br><br><ul><li>  Wenn wir einen <i>Platzhalter mit</i> Extended deklariert haben, ist dies der <i>Produzent</i> .  Er "produziert" nur, liefert ein Element aus dem Container und akzeptiert nichts. <br></li><li>  Wenn wir einen <i>Platzhalter mit Super</i> angek√ºndigt haben, dann ist dies der <i>Verbraucher</i> .  Er akzeptiert nur, kann aber nichts liefern. <br></li></ul><br>  Verwenden Sie Wildcard und das PECS-Prinzip am Beispiel der Kopiermethode in der Klasse java.util.Collections. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Die Methode kopiert Elemente aus der urspr√ºnglichen <code>src</code> Liste in die <code>dest</code> Liste.  <code>src</code> - mit Platzhalter deklariert <code>? extends</code>  <code>? extends</code> und ist der Produzent, und <code>dest</code> wird mit Platzhalter deklariert <code>? super</code>  <code>? super</code> und ist ein Verbraucher.  Angesichts der Kovarianz und Kontravarianz von Platzhaltern k√∂nnen Sie Elemente aus der <code>ints</code> Liste in die <code>nums</code> Liste <code>nums</code> : <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br>  Wenn wir versehentlich die Parameter der <code>nums</code> <code>ints</code> und versuchen, von der <code>nums</code> in die <code>ints</code> Liste zu <code>ints</code> , erlaubt uns der Compiler dies nicht: <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;?&gt; und Raw-Typen </h3><br>  Unten finden Sie einen Platzhalter mit einem unbegrenzten Platzhalter.  Wir setzen einfach <code>&lt;?&gt;</code> , Ohne die <code>super</code> oder <code>extends</code> Keywords: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br>  Tats√§chlich ist ein solcher "unbegrenzter" Platzhalter von oben immer noch begrenzt.  <code>Collection&lt;?&gt;</code> Ist auch ein Platzhalter wie " <code>? extends Object</code> ".  Ein Datensatz des Formulars <code>Collection&lt;?&gt;</code> Entspricht <code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> , was bedeutet, dass die Auflistung Objekte jeder Klasse enthalten kann, da alle Klassen in Java von <code>Object</code> erben - die Substitution wird daher als unbegrenzt bezeichnet. <br><br>  Wenn wir zum Beispiel die Typangabe weglassen, wie hier: <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  dann sagen sie, dass <code>ArrayList</code> der <code>Raw</code> Typ der parametrisierten <i>ArrayList &lt;T&gt; ist</i> .  Mit Raw-Typen kehren wir in die √Ñra der Generika zur√ºck und geben bewusst alle Merkmale auf, die parametrisierten Typen inh√§rent sind. <br><br>  Wenn wir versuchen, eine parametrisierte Methode f√ºr den Raw-Typ aufzurufen, gibt der Compiler die Warnung "Unchecked call" aus.  Wenn wir versuchen, einem Typ einen Verweis auf einen parametrisierten Raw-Typ zuzuweisen, gibt der Compiler die Warnung "Nicht aktivierte Zuordnung" aus.  Das Ignorieren dieser Warnungen kann, wie wir sp√§ter sehen werden, zu Fehlern bei der Ausf√ºhrung unserer Anwendung f√ºhren. <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3>  Wildcard-Erfassung </h3><br>  Versuchen wir nun, eine Methode zu implementieren, die die Elemente einer Liste in umgekehrter Reihenfolge permutiert. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br>  Ein Kompilierungsfehler ist aufgetreten, weil die <code>reverse</code> Methode eine Liste mit einem unbegrenzten Platzhalterzeichen <code>&lt;?&gt;</code> Als Argument verwendet. <br>  <code>&lt;?&gt;</code> bedeutet dasselbe wie <code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> .  Nach dem PECS-Prinzip ist die <code>list</code> daher <code>producer</code> .  Und der <code>producer</code> produziert nur Elemente.  Und wir rufen in der <code>for</code> Schleife die <code>set()</code> -Methode auf, d.h.  versuchen, in die <code>list</code> zu schreiben.  Wir lehnen uns also gegen den Java-Schutz ab, der es uns nicht erlaubt, einen Wert nach Index festzulegen. <br><br>  Was zu tun ist?  Das <code>Wildcard Capture</code> Muster hilft uns dabei.  Hier erstellen wir eine generische <code>rev</code> Methode.  Es wird mit einer Variablen vom Typ <code>T</code> deklariert <code>T</code>  Diese Methode akzeptiert eine Liste von <code>T</code> Typen, und wir k√∂nnen eine Menge erstellen. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br>  Jetzt wird alles mit uns kompiliert.  Hier wurde die Wildcard-Erfassung erfasst.  Wenn die <code>reverse(List&lt;?&gt; list)</code> Methode aufgerufen wird <code>reverse(List&lt;?&gt; list)</code> , wird eine Liste einiger Objekte (z. B. Zeichenfolgen oder Ganzzahlen) als Argument √ºbergeben.  Wenn wir den Typ dieser Objekte erfassen und einer Variablen vom Typ <code>X</code> zuweisen k√∂nnen, k√∂nnen wir daraus schlie√üen, dass <code>T</code> <code>X</code> <br><br>  Weitere <code>Wildcard Capture</code> zu <code>Wildcard Capture</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  Fazit </h3><br>  Wenn Sie aus dem Container lesen m√ºssen, verwenden Sie einen Platzhalter mit dem oberen Rand " <code>? extends</code> ".  Wenn Sie in den Container schreiben m√ºssen, verwenden Sie einen Platzhalter mit dem unteren Rand von " <code>? super</code> ".  Verwenden Sie keinen Platzhalter, wenn Sie aufnehmen und lesen m√ºssen. <br><br>  Verwenden Sie keine <code>Raw</code> Typen!  Wenn das Typargument nicht definiert ist, verwenden Sie den Platzhalter <code>&lt;?&gt;</code> . <br><br><h2>  Geben Sie Variablen ein </h2><br>  Wenn wir den Bezeichner in spitzen Klammern notieren, z. B. <code>&lt;T&gt;</code> oder <code>&lt;E&gt;</code> wenn wir eine Klasse oder Methode deklarieren, erstellen wir <i>eine Typvariable</i> .  Eine Typvariable ist ein nicht qualifizierter Bezeichner, der als Typ im Hauptteil einer Klasse oder Methode verwendet werden kann.  Eine Typvariable kann oben begrenzt werden. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br>  In diesem Beispiel erweitert der Ausdruck <code>T extends Comparable&lt;T&gt;</code> <code>T</code> (eine Typvariable), die oben durch den Typ <code>Comparable&lt;T&gt;</code> .  Im Gegensatz zu Platzhaltern k√∂nnen Typvariablen nur oben begrenzt werden (nur erweitert).  Kann nicht <code>super</code> schreiben.  Au√üerdem h√§ngt <code>T</code> in diesem Beispiel von sich selbst ab und wird als <code>recursive bound</code> - eine rekursive Grenze. <br><br>  Hier ist ein weiteres Beispiel aus der Enum-Klasse: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br>  Hier wird die Enum-Klasse durch den Typ E parametrisiert, der ein Subtyp von <code>Enum&lt;E&gt;</code> . <br><br><h3>  Mehrere Grenzen </h3><br>  <code>Multiple Bounds</code> - mehrere Einschr√§nkungen.  Es wird durch das Zeichen " <code>&amp;</code> " geschrieben, dh wir sagen, dass der Typ, der durch eine Variable vom Typ <code>T</code> , von oben durch die <code>Object</code> Klasse und die <code>Comparable</code> Schnittstelle begrenzt werden sollte. <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> bildet den Schnittpunkttyp <code>Multiple Bounds</code> .  Die erste Einschr√§nkung - in diesem Fall <code>Object</code> - wird zum <code>erasure</code> , dem Prozess des √úberschreibens von Typen.  Es wird vom Compiler in der Kompilierungsphase ausgef√ºhrt. <br><br><h3>  Fazit </h3><br>  Eine Typvariable kann nur auf einen oder mehrere Typen beschr√§nkt werden.  Bei mehreren Einschr√§nkungen wird beim Maischen der linke Rand (die erste Einschr√§nkung) verwendet (Typ L√∂schen). <br><br><h2>  Geben Sie L√∂schen ein </h2><br>  Typl√∂schung ist eine Zuordnung von Typen (m√∂glicherweise einschlie√ülich parametrisierter Typen und Typvariablen) zu Typen, die niemals parametrisierte Typen oder Variablentypen sind.  Wir schreiben Typ <code>T</code> als <code>|T|</code>  . <br><br>  Die Maischeanzeige ist wie folgt definiert: <br><ul><li>  Das Mischen des parametrisierten Typs <i>G</i> &lt; <i>T1</i> , ..., <i>Tn</i> &gt; ist |  <i>G</i> | </li><li>  Das Mischen eines verschachtelten Typs <i>TC</i> ist |  <i>T</i> |.  <i>C.</i> </li><li>  Das Mischen des Array-Typs <i>T []</i> ist |  <i>T</i> | [] </li><li>  Beim Mischen einer Typvariablen wird der linke Rand gemischt </li><li>  Das Mischen eines anderen Typs ist dieser Typ selbst </li></ul><br><br>  W√§hrend der Ausf√ºhrung von Type Erasure (Type Mashing) f√ºhrt der Compiler die folgenden Aktionen aus: <br><ul><li>  F√ºgt bei Bedarf Typguss hinzu, um Typensicherheit zu gew√§hrleisten </li><li>  generiert Bridge-Methoden zur Aufrechterhaltung des Polymorphismus </li></ul><br><br><table><tbody><tr><td>  <b>T (Typ)</b> <br></td><td>  <b>| T |</b>  <b>(Maischetyp)</b> <br></td></tr><tr><td>  <i>List &lt;Integer&gt;, List &lt;String&gt;, List &lt;List &lt;String &gt;&gt;</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>Liste &lt;Integer&gt; []</i> <br></td><td>  <i>Liste []</i> <br></td></tr><tr><td>  <i>Liste</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>int</i> <br></td><td>  <i>int</i> <br></td></tr><tr><td>  <i>Ganzzahl</i> <br></td><td>  <i>Ganzzahl</i> <br></td></tr><tr><td>  <i>&lt;T erweitert Vergleichbares &lt;T&gt;&gt;</i> <br></td><td>  <i>Vergleichbar</i> <br></td></tr><tr><td>  <i>&lt;T erweitert Object &amp; Comparable &lt;?</i>  <i>Super T &gt;&gt;</i> <br></td><td>  <i>Objekt</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br>  Diese Tabelle zeigt, was aus den verschiedenen Typen w√§hrend des Maischvorgangs wird. Typ L√∂schen. <br><br>  Im folgenden Screenshot sehen Sie zwei Beispiele f√ºr das Programm: <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br>  Der Unterschied zwischen beiden besteht darin, dass links ein Fehler bei der Kompilierung auftritt und rechts alles fehlerfrei kompiliert wird.  Warum? <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  In Java k√∂nnen zwei verschiedene Methoden nicht dieselbe Signatur haben.  Beim Type Erasure-Prozess f√ºgt der Compiler die Bridge-Methode <code>public int compareTo(Object o)</code> .  Die Klasse enth√§lt jedoch bereits eine Methode mit einer solchen Signatur, dass beim Kompilieren ein Fehler auftritt. <br><br>  Kompilieren Sie die Name-Klasse, indem Sie die Methode <code>compareTo(Object o)</code> entfernen, und <code>compareTo(Object o)</code> den resultierenden Bytecode mit javap: <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br>  Wir sehen, dass die Klasse eine <code>int compareTo(java.lang.Object)</code> Methode <code>int compareTo(java.lang.Object)</code> , obwohl wir sie aus dem Quellcode entfernt haben.  Dies ist die Bridge-Methode, die der Compiler hinzugef√ºgt hat. <br></div></div><br><br><h3>  Reifizierbare Typen </h3><br>  In Java sagen wir, dass ein Typ <code>reifiable</code> wenn seine Informationen zur Laufzeit vollst√§ndig <code>reifiable</code> sind.  Zu den √ºberpr√ºfbaren Typen geh√∂ren: <br><ul><li>  Primitive Typen ( <i>int</i> , <i>long</i> , <i>boolean</i> ) </li><li>  Nicht parametrisierte (nicht generische) Typen ( <i>String</i> , <i>Integer</i> ) </li><li>  Parametrisierte Typen, deren Parameter als unbegrenzter Platzhalter (unbegrenzte Platzhalterzeichen) dargestellt werden ( <i>Liste &lt;?&gt;</i> , <i>Sammlung &lt;?&gt;</i> ) </li><li>  <i>Rohe</i> (nicht geformte) Typen ( <i>List</i> , <i>ArrayList</i> ) </li><li>  Arrays, deren Komponenten reifizierbare Typen sind ( <i>int []</i> , <i>Number []</i> , <i>List &lt;?&gt; []</i> , <i>List [</i> ) </li></ul><br><br>  Warum sind Informationen zu einigen Typen verf√ºgbar, andere jedoch nicht?  Tatsache ist, dass aufgrund des Prozesses des √úberschreibens von Typen durch den Compiler Informationen √ºber einige Typen verloren gehen k√∂nnen.  Wenn es verloren geht, kann dieser Typ nicht mehr √ºberpr√ºft werden.  Das hei√üt, es ist zur Laufzeit nicht verf√ºgbar.  Falls verf√ºgbar - jeweils nachpr√ºfbar. <br><br>  Die Entscheidung, nicht alle generischen Typen zur Laufzeit verf√ºgbar zu machen, ist eine der wichtigsten und widerspr√ºchlichsten Entwurfsentscheidungen im Java-Typsystem.  Dies geschieht zun√§chst aus Gr√ºnden der Kompatibilit√§t mit vorhandenem Code.  Ich musste f√ºr die Migrationskompatibilit√§t bezahlen - die vollst√§ndige Zug√§nglichkeit eines Systems generischer Typen zur Laufzeit ist nicht m√∂glich. <br><br>  Welche Arten sind nicht √ºberpr√ºfbar: <br><ul><li>  Typvariable ( <i>T</i> ) </li><li>  Parametrisierter Typ mit dem angegebenen Parametertyp ( <i>List &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> , <i>List &lt;List &lt;String&gt;&gt;</i> ) </li><li>  Ein parametrisierter Typ mit der angegebenen Ober- oder Untergrenze ( <i>List &lt;? Extends Number&gt;, Comparable &lt;? Super String&gt;</i> ).  Aber hier ist eine Reservierung: <i>Liste &lt;?</i>  <i>erweitert Objekt&gt;</i> - <b>nicht</b> √ºberpr√ºfbar, aber <i>Liste &lt;?&gt;</i> - √ºberpr√ºfbar </li></ul><br><br>  Und noch eine Aufgabe.  Warum kann im folgenden Beispiel keine parametrisierte Ausnahme erstellt werden? <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Jeder catch-Ausdruck in try-catch √ºberpr√ºft den Typ der empfangenen Ausnahme w√§hrend der Programmausf√ºhrung (was der Instanz von entspricht). Der Typ muss also √ºberpr√ºfbar sein.  Daher k√∂nnen Throwable und seine Untertypen nicht parametrisiert werden. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3>  Deaktivierte Warnungen </h3><br>  Beim Kompilieren unserer Anwendung wird m√∂glicherweise die sogenannte <code>Unchecked Warning</code> - eine Warnung, dass der Compiler die Sicherheitsstufe f√ºr die Verwendung unserer Typen nicht korrekt bestimmen konnte.  Dies ist kein Fehler, sondern eine Warnung, sodass Sie sie √ºberspringen k√∂nnen.  Es ist jedoch ratsam, alles zu beheben, um Probleme in Zukunft zu vermeiden. <br><br><h3>  Haufenverschmutzung </h3><br>  Wie bereits erw√§hnt, f√ºhrt das Zuweisen eines Verweises auf einen Raw-Typ zu einer Variablen eines parametrisierten Typs zur Warnung ‚ÄûNicht aktivierte Zuordnung‚Äú.  Wenn wir es ignorieren, ist eine Situation namens " <code>Heap Pollution</code> " (Heap Pollution) m√∂glich.  Hier ist ein Beispiel: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br>  In Zeile (1) warnt der Compiler vor "Nicht aktivierte Zuweisung". <br><br>  Wir m√ºssen ein weiteres Beispiel f√ºr ‚ÄûHaufenverschmutzung‚Äú geben - wenn wir parametrisierte Objekte verwenden.  Das folgende Codefragment zeigt deutlich, dass parametrisierte Typen nicht als Argumente f√ºr eine Methode mit <code>Varargs</code> verwendet werden <code>Varargs</code> .  In diesem Fall ist der Methodenparameter m <code>List&lt;String&gt;‚Ä¶</code> , d. H.  Tats√§chlich ein Array von Elementen vom Typ <code>List&lt;String&gt;</code> .  Angesichts der Regel, dass Typen w√§hrend des Maischens <code>stringLists</code> , wird der Typ <code>stringLists</code> zu einem Array von <code>stringLists</code> ( <code>List[]</code> ), d. H.  Zuweisung kann erfolgen <code>Object[] array = stringLists;</code>  und schreiben Sie dann ein anderes Objekt als die Liste der Zeichenfolgen (1) in ein <code>array</code> , wodurch <code>ClassCastException</code> in Zeichenfolge (2) <code>ClassCastException</code> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br>  Betrachten Sie ein anderes Beispiel: <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java erlaubt die Zuordnung in Zeile (1).  Dies ist aus Gr√ºnden der Abw√§rtskompatibilit√§t erforderlich.  Wenn wir jedoch versuchen, die <code>add</code> Methode in Zeile (2) auszuf√ºhren, erhalten wir eine Warnung f√ºr <code>Unchecked call</code> - der Compiler warnt uns vor einem m√∂glichen Fehler.  Tats√§chlich versuchen wir, der Liste der Zeichenfolgen eine Ganzzahl hinzuzuf√ºgen. <br><br><h3>  Reflexion </h3><br>  Obwohl parametrisierte Typen w√§hrend der Kompilierung einem L√∂schvorgang unterzogen werden, k√∂nnen wir mithilfe von Reflection einige Informationen abrufen. <br><br><ul><li>  Alle nachpr√ºfbaren sind √ºber den Reflexionsmechanismus verf√ºgbar. <br></li><li>  Informationen √ºber den Typ der Klassenfelder, Methodenparameter und die von ihnen zur√ºckgegebenen Werte sind √ºber Reflection verf√ºgbar. <br></li></ul><br>     Reflection          <code>Reifiable</code> ,      . , , ,     - ,         : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br>   Generics  <code>java.lang.Class</code>  .    : <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br>  <code>ints</code>   <code>List&lt;Integer&gt;</code>        <code>ArrayList&lt; Integer&gt;</code> .  <code>ints.getClass()</code>    <code>Class&lt;ArrayLis&gt;</code> ,   <code>List&lt;Integer&gt;</code>   <code>List</code> .   <code>Class&lt;ArrayList&gt;</code>    <code>k</code>  <code>Class&lt;? extends List&gt;</code> ,    ? <code>extends</code> .  <code>ArrayList.class</code>    <code>Class&lt;ArrayList&gt;</code> . <br><br><h3>  Fazit </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    ¬´ ¬ª      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     ¬´ ¬ª.     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   ‚Äì <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   ‚Äî   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> ‚Äî    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    ‚Äî     .        JDK 8 ‚Äî        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   ‚Äì    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    (¬´¬ª) ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      ¬´two¬ª. <br><br>   -    JDK1.7 ‚Äì    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     ¬´one¬ª. <code>Checkcast</code> ‚Äì    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2>  Fazit </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416413/">https://habr.com/ru/post/de416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416403/index.html">Fintech Digest: Angriff auf die PIR Bank, den Federal Tax Service und Steuern von der √úbertragung von Karte zu Karte sowie einige Blockchain- und Kryptow√§hrungen</a></li>
<li><a href="../de416405/index.html">Bachelor-Studieng√§nge in Partnerschaft mit Yandex</a></li>
<li><a href="../de416407/index.html">Verkehr von Mikrotiks Schn√ºffler sparen</a></li>
<li><a href="../de416409/index.html">5 h√§ufige Fehler bei der Entwicklung von Strategien und M√∂glichkeiten, mit ihnen umzugehen</a></li>
<li><a href="../de416411/index.html">Geschichten mit Daten erz√§hlen</a></li>
<li><a href="../de416415/index.html">Wir bewegen alles in der Testbaugruppe Vivaldi 1.16.1230.3</a></li>
<li><a href="../de416417/index.html">"Heavenly River" - China wird einen k√ºnstlichen Regen von beispielloser Kraft erzeugen</a></li>
<li><a href="../de416419/index.html">Zuf√§lliger zweidimensionaler H√∂hlengenerator</a></li>
<li><a href="../de416421/index.html">Ein Spaziergang in der Boxengasse oder wie IaaS-Technologien Rennteams helfen</a></li>
<li><a href="../de416423/index.html">Wie die Russen an den amerikanischen Prozessor erinnerten oder eine √úberpr√ºfung des AdvoCam-FD8 Gold-II DVR (GPS + GLONASS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>