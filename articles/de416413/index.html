<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😀 ✍🏼 💔 Kam, sah, verallgemeinerte: eingetaucht in Java Generics 👩🏼‍💼 🚰 📏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Generics ist eine der wichtigsten Änderungen in der Geschichte der Java-Sprache. Mit Java 5 verfügbare Generika haben die Verwendung des Java Col...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kam, sah, verallgemeinerte: eingetaucht in Java Generics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java Generics ist eine der wichtigsten Änderungen in der Geschichte der Java-Sprache.  Mit Java 5 verfügbare Generika haben die Verwendung des Java Collection Framework einfacher, bequemer und sicherer gemacht.  Fehler, die mit einer falschen Verwendung von Typen verbunden sind, werden jetzt in der Kompilierungsphase erkannt.  Ja, und die Java-Sprache selbst ist noch sicherer geworden.  Trotz der offensichtlichen Einfachheit generischer Typen haben viele Entwickler Schwierigkeiten, sie zu verwenden.  In diesem Beitrag werde ich über die Funktionen der Arbeit mit Java Generics sprechen, damit Sie weniger von diesen Schwierigkeiten haben.  Nützlich, wenn Sie kein generischer Guru sind und dabei helfen, viele Schwierigkeiten beim Eintauchen in das Thema zu vermeiden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2>  Arbeiten Sie mit Sammlungen </h2><br>  Angenommen, eine Bank muss die Höhe der Einsparungen auf Kundenkonten berechnen.  Vor dem Aufkommen von „Generika“ sah die Methode zur Berechnung der Summe folgendermaßen aus: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Wir haben iteriert, die Liste der Konten durchgesehen und überprüft, ob das Element aus dieser Liste wirklich eine Instanz der <code>Account</code> Klasse ist, dh das Konto des Benutzers.  Der Typ unseres Objekts der <code>Account</code> Klasse und die <code>getAmount</code> Methode wurden <code>getAmount</code> , wodurch der Betrag in diesem Konto zurückgegeben wurde.  Dann fassten sie alles zusammen und gaben den Gesamtbetrag zurück.  Es waren zwei Schritte erforderlich: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br>  Wenn Sie ( <code>instanceof</code> ) nicht auf Zugehörigkeit zur <code>Account</code> Klasse prüfen, ist in der zweiten Phase eine <code>ClassCastException</code> möglich, <code>ClassCastException</code> ein Programmabsturz.  Daher war eine solche Überprüfung obligatorisch. <br><br>  Mit dem Aufkommen von Generics ist die Notwendigkeit der Typprüfung und des Castings verschwunden: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  Jetzt Methode <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre>  akzeptiert als Argumente nur eine Liste von Objekten der Klasse <code>Account</code> .  Diese Einschränkung wird in der Methode selbst angegeben, in ihrer Signatur kann der Programmierer einfach keine andere Liste übertragen - nur die Liste der Client-Konten. <br><br>  Wir müssen den Typ der Elemente aus dieser Liste nicht überprüfen: Dies wird durch die Typbeschreibung des Methodenparameters impliziert <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  (Kann als <code>   Account</code> gelesen werden).  Und der Compiler gibt einen Fehler aus, wenn etwas schief geht - das heißt, wenn jemand versucht, eine Liste anderer Objekte als der <code>Account</code> Klasse an diese Methode zu übergeben. <br><br>  In der zweiten Zeile der Prüfung verschwand auch die Notwendigkeit.  Falls erforderlich, wird das <code>casting</code> in der Kompilierungsphase durchgeführt. <br><br><h2>  Substitutionsprinzip </h2><br>  Das Substitutionsprinzip von Barbara Liskov ist eine spezifische Definition eines Subtyps in der objektorientierten Programmierung.  Liskovs Idee eines „Subtyps“ definiert das Konzept der Substitution: Wenn <code>S</code> ein Subtyp von <code>T</code> , können Objekte vom Typ <code>T</code> in einem Programm durch Objekte vom Typ <code>S</code> ohne dass die gewünschten Eigenschaften dieses Programms geändert werden. <br><br><table><tbody><tr><td>  <b>Typ</b> <br></td><td>  <b>Subtyp</b> <br></td></tr><tr><td>  <i>Nummer</i> <br></td><td>  <i>Ganzzahl</i> <br></td></tr><tr><td>  <i>Liste</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Sammlung</i> &lt;E&gt; <br></td><td>  <i>Liste</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Iterable</i> &lt;E&gt; <br></td><td>  <i>Sammlung</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>Beispiele für Typ / Subtyp-Beziehungen</i> <br><br>  Hier ist ein Beispiel für die Verwendung des Substitutionsprinzips in Java: <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code> ist ein Subtyp von <code>Number</code> . Daher kann der Variablen <code>n</code> Typ <code>Number</code> der Wert zugewiesen werden, den die Methode <code>Integer.valueOf(42)</code> zurückgibt. <br><br><h2>  Kovarianz, Kontravarianz und Invarianz </h2><br>  Zunächst eine kleine Theorie.  Kovarianz ist die Beibehaltung der Vererbungshierarchie von Quelltypen in abgeleiteten Typen in derselben Reihenfolge.  Wenn die <i>Katze</i> beispielsweise ein Subtyp von <i>Tieren ist</i> , ist die <i>Gruppe von &lt;Katzen&gt;</i> ein Subtyp der <i>Gruppe von &lt;Tieren&gt;</i> .  Unter Berücksichtigung des Substitutionsprinzips kann daher folgende Zuordnung vorgenommen werden: <br><br>  <i>Viele &lt;Tiere&gt; = Viele &lt;Katzen&gt;</i> <br><br>  Kontravarianz ist die Umkehrung der Hierarchie der Quelltypen in abgeleiteten Typen.  Wenn die <i>Katze</i> beispielsweise ein Subtyp der <code></code> , ist das <i>Set &lt;Tiere&gt;</i> ein Subtyp des <i>Sets der &lt;Katzen&gt;</i> .  Unter Berücksichtigung des Substitutionsprinzips kann daher folgende Zuordnung vorgenommen werden: <br><br>  <i>Viele &lt;Katzen&gt; = Viele &lt;Tiere&gt;</i> <br><br>  Invarianz - fehlende Vererbung zwischen abgeleiteten Typen.  Wenn die <i>Katze</i> ein Subtyp von <i>Tieren ist</i> , ist der <i>Satz von &lt;Katzen&gt;</i> kein Subtyp des <i>Satzes von &lt;Tieren&gt;</i> und der <i>Satz von &lt;Tieren&gt; ist</i> kein Subtyp des <i>Satzes von &lt;Katzen&gt;</i> . <br><br>  <b>Arrays in Java sind kovariant</b> .  Typ <code>S[]</code> ist ein Subtyp von <code>T[]</code> wenn <code>S</code> ein Subtyp von <code>T</code>  Zuordnungsbeispiel: <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br>  Wir haben der Variablen <code>arr</code> einen Link zu einem Array von Zeichenfolgen zugewiesen, dessen Typ <code>« »</code> .  Wenn Arrays nicht kovariant wären, könnten wir dies nicht tun.  Mit Java können Sie dies tun, das Programm wird kompiliert und fehlerfrei ausgeführt. <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br>  Wenn wir jedoch versuchen, den Inhalt des Arrays über die Variable <code>arr</code> zu ändern und dort die Nummer 42 zu schreiben, erhalten wir in der Programmausführungsphase eine <code>ArrayStoreException</code> , da 42 keine Zeichenfolge, sondern eine Zahl ist.  Dies ist der Nachteil der Kovarianz von Java-Arrays: Wir können in der Kompilierungsphase keine Überprüfungen durchführen, und möglicherweise läuft bereits zur Laufzeit etwas kaputt. <br><br>  <b>"Generika" sind unveränderlich.</b>  Hier ist ein Beispiel: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br>  Wenn Sie eine Liste von Ganzzahlen verwenden, handelt es sich weder um einen Subtyp vom Typ <code>Number</code> noch um einen anderen Subtyp.  Er ist nur ein Subtyp von sich.  Das heißt, <code>List &lt;Integer&gt;</code> ist eine <code>List&lt;Integer&gt;</code> und sonst nichts.  Der Compiler stellt sicher, dass die als Liste der Objekte der <i>Integer-</i> Klasse <code>ints</code> Variable <code>ints</code> nur Objekte der <code>Integer</code> Klasse und sonst nichts enthält.  In der Kompilierungsphase wird eine Überprüfung durchgeführt, und in unserer Laufzeit fällt nichts. <br><br><h2>  Platzhalter </h2><br>  Sind Generika immer invariant?  Nein.  Ich werde Beispiele geben: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br>  Das ist Kovarianz.  <code>List&lt;Integer&gt;</code> - Subtyp von <code>List&lt;? extends Number&gt;</code> <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br>  Das ist Kontravarianz.  <code>List&lt;Number&gt;</code> ist ein Subtyp von <code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> . <br><br>  Ein Datensatz wie <code>"? extends ..."</code> oder <code>"? super ..."</code> wird als Platzhalter oder Platzhalter mit einer Obergrenze ( <code>extends</code> ) oder einer Untergrenze ( <code>super</code> ) bezeichnet. <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code> kann Objekte enthalten, deren Klasse <code>Number</code> oder von <code>Number</code> erbt. <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code> kann Objekte enthalten, deren Klasse <code>Number</code> oder deren <code>Number</code> ein Erbe ist (Supertyp von <code>Number</code> ). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td>  erweitert <i>B</i> - Wildcard mit Obergrenze <br>  Super <i>B</i> - Platzhalter mit einer Untergrenze <br>  wobei <i>B</i> - die Grenze darstellt <br><br>  Eine Aufzeichnung der Form T <sub>2</sub> &lt;= T <sub>1</sub> bedeutet, dass die durch T <sub>2</sub> beschriebene Menge von Typen eine Teilmenge der durch T <sub>1</sub> beschriebenen Menge von Typen ist <br><br>  d.h. <br>  Nummer &lt;=?  erweitert Objekt <br>  ?  erweitert Nummer &lt;=?  erweitert Objekt <br>  und <br>  ?  Superobjekt &lt;=?  Super Nummer <br><br></td></tr></tbody></table><br>  <i>Mehr mathematische Interpretation des Themas</i> <br><br>  Ein paar Aufgaben zum Testen von Wissen: <br><br>  1. Warum tritt der Kompilierungsfehler im folgenden Beispiel auf?  Welchen Wert kann ich der <code>nums</code> hinzufügen? <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Sollte der Container mit Platzhalter deklariert werden <code>? extends</code>  <code>? extends</code> , können Sie nur die Werte lesen.  Der Liste kann nur <code>null</code> hinzugefügt werden.  Um der Liste ein Objekt hinzuzufügen, benötigen wir einen anderen Platzhaltertyp - <code>? super</code> <code>? super</code> <br></div></div><br><br>  2. Warum kann ich keinen Artikel aus der folgenden Liste erhalten? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Sie können einen Artikel aus einem Container mit Platzhalter nicht lesen <code>? super</code>  <code>? super</code> , bis auf ein Objekt der Klasse <code>Object</code> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3>  Das Get and Put-Prinzip oder PECS (Producer Extends Consumer Super) </h3><br>  Die Platzhalterfunktion mit Ober- und Untergrenze bietet zusätzliche Funktionen für die sichere Verwendung von Typen.  Sie können nur von einem Variablentyp lesen, nur in einen anderen schreiben (die Ausnahme ist die Möglichkeit, <code>null</code> für Erweiterungen zu schreiben und <code>Object</code> für <code>super</code> lesen).  Damit Sie sich leichter merken können, wann welcher Platzhalter verwendet werden soll, gibt es das PECS-Prinzip - Producer Extends Consumer Super. <br><br><ul><li>  Wenn wir einen <i>Platzhalter mit</i> Extended deklariert haben, ist dies der <i>Produzent</i> .  Er "produziert" nur, liefert ein Element aus dem Container und akzeptiert nichts. <br></li><li>  Wenn wir einen <i>Platzhalter mit Super</i> angekündigt haben, dann ist dies der <i>Verbraucher</i> .  Er akzeptiert nur, kann aber nichts liefern. <br></li></ul><br>  Verwenden Sie Wildcard und das PECS-Prinzip am Beispiel der Kopiermethode in der Klasse java.util.Collections. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Die Methode kopiert Elemente aus der ursprünglichen <code>src</code> Liste in die <code>dest</code> Liste.  <code>src</code> - mit Platzhalter deklariert <code>? extends</code>  <code>? extends</code> und ist der Produzent, und <code>dest</code> wird mit Platzhalter deklariert <code>? super</code>  <code>? super</code> und ist ein Verbraucher.  Angesichts der Kovarianz und Kontravarianz von Platzhaltern können Sie Elemente aus der <code>ints</code> Liste in die <code>nums</code> Liste <code>nums</code> : <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br>  Wenn wir versehentlich die Parameter der <code>nums</code> <code>ints</code> und versuchen, von der <code>nums</code> in die <code>ints</code> Liste zu <code>ints</code> , erlaubt uns der Compiler dies nicht: <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;?&gt; und Raw-Typen </h3><br>  Unten finden Sie einen Platzhalter mit einem unbegrenzten Platzhalter.  Wir setzen einfach <code>&lt;?&gt;</code> , Ohne die <code>super</code> oder <code>extends</code> Keywords: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br>  Tatsächlich ist ein solcher "unbegrenzter" Platzhalter von oben immer noch begrenzt.  <code>Collection&lt;?&gt;</code> Ist auch ein Platzhalter wie " <code>? extends Object</code> ".  Ein Datensatz des Formulars <code>Collection&lt;?&gt;</code> Entspricht <code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> , was bedeutet, dass die Auflistung Objekte jeder Klasse enthalten kann, da alle Klassen in Java von <code>Object</code> erben - die Substitution wird daher als unbegrenzt bezeichnet. <br><br>  Wenn wir zum Beispiel die Typangabe weglassen, wie hier: <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  dann sagen sie, dass <code>ArrayList</code> der <code>Raw</code> Typ der parametrisierten <i>ArrayList &lt;T&gt; ist</i> .  Mit Raw-Typen kehren wir in die Ära der Generika zurück und geben bewusst alle Merkmale auf, die parametrisierten Typen inhärent sind. <br><br>  Wenn wir versuchen, eine parametrisierte Methode für den Raw-Typ aufzurufen, gibt der Compiler die Warnung "Unchecked call" aus.  Wenn wir versuchen, einem Typ einen Verweis auf einen parametrisierten Raw-Typ zuzuweisen, gibt der Compiler die Warnung "Nicht aktivierte Zuordnung" aus.  Das Ignorieren dieser Warnungen kann, wie wir später sehen werden, zu Fehlern bei der Ausführung unserer Anwendung führen. <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3>  Wildcard-Erfassung </h3><br>  Versuchen wir nun, eine Methode zu implementieren, die die Elemente einer Liste in umgekehrter Reihenfolge permutiert. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br>  Ein Kompilierungsfehler ist aufgetreten, weil die <code>reverse</code> Methode eine Liste mit einem unbegrenzten Platzhalterzeichen <code>&lt;?&gt;</code> Als Argument verwendet. <br>  <code>&lt;?&gt;</code> bedeutet dasselbe wie <code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> .  Nach dem PECS-Prinzip ist die <code>list</code> daher <code>producer</code> .  Und der <code>producer</code> produziert nur Elemente.  Und wir rufen in der <code>for</code> Schleife die <code>set()</code> -Methode auf, d.h.  versuchen, in die <code>list</code> zu schreiben.  Wir lehnen uns also gegen den Java-Schutz ab, der es uns nicht erlaubt, einen Wert nach Index festzulegen. <br><br>  Was zu tun ist?  Das <code>Wildcard Capture</code> Muster hilft uns dabei.  Hier erstellen wir eine generische <code>rev</code> Methode.  Es wird mit einer Variablen vom Typ <code>T</code> deklariert <code>T</code>  Diese Methode akzeptiert eine Liste von <code>T</code> Typen, und wir können eine Menge erstellen. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br>  Jetzt wird alles mit uns kompiliert.  Hier wurde die Wildcard-Erfassung erfasst.  Wenn die <code>reverse(List&lt;?&gt; list)</code> Methode aufgerufen wird <code>reverse(List&lt;?&gt; list)</code> , wird eine Liste einiger Objekte (z. B. Zeichenfolgen oder Ganzzahlen) als Argument übergeben.  Wenn wir den Typ dieser Objekte erfassen und einer Variablen vom Typ <code>X</code> zuweisen können, können wir daraus schließen, dass <code>T</code> <code>X</code> <br><br>  Weitere <code>Wildcard Capture</code> zu <code>Wildcard Capture</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  Fazit </h3><br>  Wenn Sie aus dem Container lesen müssen, verwenden Sie einen Platzhalter mit dem oberen Rand " <code>? extends</code> ".  Wenn Sie in den Container schreiben müssen, verwenden Sie einen Platzhalter mit dem unteren Rand von " <code>? super</code> ".  Verwenden Sie keinen Platzhalter, wenn Sie aufnehmen und lesen müssen. <br><br>  Verwenden Sie keine <code>Raw</code> Typen!  Wenn das Typargument nicht definiert ist, verwenden Sie den Platzhalter <code>&lt;?&gt;</code> . <br><br><h2>  Geben Sie Variablen ein </h2><br>  Wenn wir den Bezeichner in spitzen Klammern notieren, z. B. <code>&lt;T&gt;</code> oder <code>&lt;E&gt;</code> wenn wir eine Klasse oder Methode deklarieren, erstellen wir <i>eine Typvariable</i> .  Eine Typvariable ist ein nicht qualifizierter Bezeichner, der als Typ im Hauptteil einer Klasse oder Methode verwendet werden kann.  Eine Typvariable kann oben begrenzt werden. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br>  In diesem Beispiel erweitert der Ausdruck <code>T extends Comparable&lt;T&gt;</code> <code>T</code> (eine Typvariable), die oben durch den Typ <code>Comparable&lt;T&gt;</code> .  Im Gegensatz zu Platzhaltern können Typvariablen nur oben begrenzt werden (nur erweitert).  Kann nicht <code>super</code> schreiben.  Außerdem hängt <code>T</code> in diesem Beispiel von sich selbst ab und wird als <code>recursive bound</code> - eine rekursive Grenze. <br><br>  Hier ist ein weiteres Beispiel aus der Enum-Klasse: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br>  Hier wird die Enum-Klasse durch den Typ E parametrisiert, der ein Subtyp von <code>Enum&lt;E&gt;</code> . <br><br><h3>  Mehrere Grenzen </h3><br>  <code>Multiple Bounds</code> - mehrere Einschränkungen.  Es wird durch das Zeichen " <code>&amp;</code> " geschrieben, dh wir sagen, dass der Typ, der durch eine Variable vom Typ <code>T</code> , von oben durch die <code>Object</code> Klasse und die <code>Comparable</code> Schnittstelle begrenzt werden sollte. <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> bildet den Schnittpunkttyp <code>Multiple Bounds</code> .  Die erste Einschränkung - in diesem Fall <code>Object</code> - wird zum <code>erasure</code> , dem Prozess des Überschreibens von Typen.  Es wird vom Compiler in der Kompilierungsphase ausgeführt. <br><br><h3>  Fazit </h3><br>  Eine Typvariable kann nur auf einen oder mehrere Typen beschränkt werden.  Bei mehreren Einschränkungen wird beim Maischen der linke Rand (die erste Einschränkung) verwendet (Typ Löschen). <br><br><h2>  Geben Sie Löschen ein </h2><br>  Typlöschung ist eine Zuordnung von Typen (möglicherweise einschließlich parametrisierter Typen und Typvariablen) zu Typen, die niemals parametrisierte Typen oder Variablentypen sind.  Wir schreiben Typ <code>T</code> als <code>|T|</code>  . <br><br>  Die Maischeanzeige ist wie folgt definiert: <br><ul><li>  Das Mischen des parametrisierten Typs <i>G</i> &lt; <i>T1</i> , ..., <i>Tn</i> &gt; ist |  <i>G</i> | </li><li>  Das Mischen eines verschachtelten Typs <i>TC</i> ist |  <i>T</i> |.  <i>C.</i> </li><li>  Das Mischen des Array-Typs <i>T []</i> ist |  <i>T</i> | [] </li><li>  Beim Mischen einer Typvariablen wird der linke Rand gemischt </li><li>  Das Mischen eines anderen Typs ist dieser Typ selbst </li></ul><br><br>  Während der Ausführung von Type Erasure (Type Mashing) führt der Compiler die folgenden Aktionen aus: <br><ul><li>  Fügt bei Bedarf Typguss hinzu, um Typensicherheit zu gewährleisten </li><li>  generiert Bridge-Methoden zur Aufrechterhaltung des Polymorphismus </li></ul><br><br><table><tbody><tr><td>  <b>T (Typ)</b> <br></td><td>  <b>| T |</b>  <b>(Maischetyp)</b> <br></td></tr><tr><td>  <i>List &lt;Integer&gt;, List &lt;String&gt;, List &lt;List &lt;String &gt;&gt;</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>Liste &lt;Integer&gt; []</i> <br></td><td>  <i>Liste []</i> <br></td></tr><tr><td>  <i>Liste</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>int</i> <br></td><td>  <i>int</i> <br></td></tr><tr><td>  <i>Ganzzahl</i> <br></td><td>  <i>Ganzzahl</i> <br></td></tr><tr><td>  <i>&lt;T erweitert Vergleichbares &lt;T&gt;&gt;</i> <br></td><td>  <i>Vergleichbar</i> <br></td></tr><tr><td>  <i>&lt;T erweitert Object &amp; Comparable &lt;?</i>  <i>Super T &gt;&gt;</i> <br></td><td>  <i>Objekt</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br>  Diese Tabelle zeigt, was aus den verschiedenen Typen während des Maischvorgangs wird. Typ Löschen. <br><br>  Im folgenden Screenshot sehen Sie zwei Beispiele für das Programm: <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br>  Der Unterschied zwischen beiden besteht darin, dass links ein Fehler bei der Kompilierung auftritt und rechts alles fehlerfrei kompiliert wird.  Warum? <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  In Java können zwei verschiedene Methoden nicht dieselbe Signatur haben.  Beim Type Erasure-Prozess fügt der Compiler die Bridge-Methode <code>public int compareTo(Object o)</code> .  Die Klasse enthält jedoch bereits eine Methode mit einer solchen Signatur, dass beim Kompilieren ein Fehler auftritt. <br><br>  Kompilieren Sie die Name-Klasse, indem Sie die Methode <code>compareTo(Object o)</code> entfernen, und <code>compareTo(Object o)</code> den resultierenden Bytecode mit javap: <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br>  Wir sehen, dass die Klasse eine <code>int compareTo(java.lang.Object)</code> Methode <code>int compareTo(java.lang.Object)</code> , obwohl wir sie aus dem Quellcode entfernt haben.  Dies ist die Bridge-Methode, die der Compiler hinzugefügt hat. <br></div></div><br><br><h3>  Reifizierbare Typen </h3><br>  In Java sagen wir, dass ein Typ <code>reifiable</code> wenn seine Informationen zur Laufzeit vollständig <code>reifiable</code> sind.  Zu den überprüfbaren Typen gehören: <br><ul><li>  Primitive Typen ( <i>int</i> , <i>long</i> , <i>boolean</i> ) </li><li>  Nicht parametrisierte (nicht generische) Typen ( <i>String</i> , <i>Integer</i> ) </li><li>  Parametrisierte Typen, deren Parameter als unbegrenzter Platzhalter (unbegrenzte Platzhalterzeichen) dargestellt werden ( <i>Liste &lt;?&gt;</i> , <i>Sammlung &lt;?&gt;</i> ) </li><li>  <i>Rohe</i> (nicht geformte) Typen ( <i>List</i> , <i>ArrayList</i> ) </li><li>  Arrays, deren Komponenten reifizierbare Typen sind ( <i>int []</i> , <i>Number []</i> , <i>List &lt;?&gt; []</i> , <i>List [</i> ) </li></ul><br><br>  Warum sind Informationen zu einigen Typen verfügbar, andere jedoch nicht?  Tatsache ist, dass aufgrund des Prozesses des Überschreibens von Typen durch den Compiler Informationen über einige Typen verloren gehen können.  Wenn es verloren geht, kann dieser Typ nicht mehr überprüft werden.  Das heißt, es ist zur Laufzeit nicht verfügbar.  Falls verfügbar - jeweils nachprüfbar. <br><br>  Die Entscheidung, nicht alle generischen Typen zur Laufzeit verfügbar zu machen, ist eine der wichtigsten und widersprüchlichsten Entwurfsentscheidungen im Java-Typsystem.  Dies geschieht zunächst aus Gründen der Kompatibilität mit vorhandenem Code.  Ich musste für die Migrationskompatibilität bezahlen - die vollständige Zugänglichkeit eines Systems generischer Typen zur Laufzeit ist nicht möglich. <br><br>  Welche Arten sind nicht überprüfbar: <br><ul><li>  Typvariable ( <i>T</i> ) </li><li>  Parametrisierter Typ mit dem angegebenen Parametertyp ( <i>List &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> , <i>List &lt;List &lt;String&gt;&gt;</i> ) </li><li>  Ein parametrisierter Typ mit der angegebenen Ober- oder Untergrenze ( <i>List &lt;? Extends Number&gt;, Comparable &lt;? Super String&gt;</i> ).  Aber hier ist eine Reservierung: <i>Liste &lt;?</i>  <i>erweitert Objekt&gt;</i> - <b>nicht</b> überprüfbar, aber <i>Liste &lt;?&gt;</i> - überprüfbar </li></ul><br><br>  Und noch eine Aufgabe.  Warum kann im folgenden Beispiel keine parametrisierte Ausnahme erstellt werden? <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Jeder catch-Ausdruck in try-catch überprüft den Typ der empfangenen Ausnahme während der Programmausführung (was der Instanz von entspricht). Der Typ muss also überprüfbar sein.  Daher können Throwable und seine Untertypen nicht parametrisiert werden. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3>  Deaktivierte Warnungen </h3><br>  Beim Kompilieren unserer Anwendung wird möglicherweise die sogenannte <code>Unchecked Warning</code> - eine Warnung, dass der Compiler die Sicherheitsstufe für die Verwendung unserer Typen nicht korrekt bestimmen konnte.  Dies ist kein Fehler, sondern eine Warnung, sodass Sie sie überspringen können.  Es ist jedoch ratsam, alles zu beheben, um Probleme in Zukunft zu vermeiden. <br><br><h3>  Haufenverschmutzung </h3><br>  Wie bereits erwähnt, führt das Zuweisen eines Verweises auf einen Raw-Typ zu einer Variablen eines parametrisierten Typs zur Warnung „Nicht aktivierte Zuordnung“.  Wenn wir es ignorieren, ist eine Situation namens " <code>Heap Pollution</code> " (Heap Pollution) möglich.  Hier ist ein Beispiel: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br>  In Zeile (1) warnt der Compiler vor "Nicht aktivierte Zuweisung". <br><br>  Wir müssen ein weiteres Beispiel für „Haufenverschmutzung“ geben - wenn wir parametrisierte Objekte verwenden.  Das folgende Codefragment zeigt deutlich, dass parametrisierte Typen nicht als Argumente für eine Methode mit <code>Varargs</code> verwendet werden <code>Varargs</code> .  In diesem Fall ist der Methodenparameter m <code>List&lt;String&gt;…</code> , d. H.  Tatsächlich ein Array von Elementen vom Typ <code>List&lt;String&gt;</code> .  Angesichts der Regel, dass Typen während des Maischens <code>stringLists</code> , wird der Typ <code>stringLists</code> zu einem Array von <code>stringLists</code> ( <code>List[]</code> ), d. H.  Zuweisung kann erfolgen <code>Object[] array = stringLists;</code>  und schreiben Sie dann ein anderes Objekt als die Liste der Zeichenfolgen (1) in ein <code>array</code> , wodurch <code>ClassCastException</code> in Zeichenfolge (2) <code>ClassCastException</code> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br>  Betrachten Sie ein anderes Beispiel: <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java erlaubt die Zuordnung in Zeile (1).  Dies ist aus Gründen der Abwärtskompatibilität erforderlich.  Wenn wir jedoch versuchen, die <code>add</code> Methode in Zeile (2) auszuführen, erhalten wir eine Warnung für <code>Unchecked call</code> - der Compiler warnt uns vor einem möglichen Fehler.  Tatsächlich versuchen wir, der Liste der Zeichenfolgen eine Ganzzahl hinzuzufügen. <br><br><h3>  Reflexion </h3><br>  Obwohl parametrisierte Typen während der Kompilierung einem Löschvorgang unterzogen werden, können wir mithilfe von Reflection einige Informationen abrufen. <br><br><ul><li>  Alle nachprüfbaren sind über den Reflexionsmechanismus verfügbar. <br></li><li>  Informationen über den Typ der Klassenfelder, Methodenparameter und die von ihnen zurückgegebenen Werte sind über Reflection verfügbar. <br></li></ul><br>     Reflection          <code>Reifiable</code> ,      . , , ,     - ,         : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br>   Generics  <code>java.lang.Class</code>  .    : <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br>  <code>ints</code>   <code>List&lt;Integer&gt;</code>        <code>ArrayList&lt; Integer&gt;</code> .  <code>ints.getClass()</code>    <code>Class&lt;ArrayLis&gt;</code> ,   <code>List&lt;Integer&gt;</code>   <code>List</code> .   <code>Class&lt;ArrayList&gt;</code>    <code>k</code>  <code>Class&lt;? extends List&gt;</code> ,    ? <code>extends</code> .  <code>ArrayList.class</code>    <code>Class&lt;ArrayList&gt;</code> . <br><br><h3>  Fazit </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    « »      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     « ».     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   – <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   —   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> —    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    —     .        JDK 8 —        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   –    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    («») ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      «two». <br><br>   -    JDK1.7 –    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     «one». <code>Checkcast</code> –    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2>  Fazit </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416413/">https://habr.com/ru/post/de416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416403/index.html">Fintech Digest: Angriff auf die PIR Bank, den Federal Tax Service und Steuern von der Übertragung von Karte zu Karte sowie einige Blockchain- und Kryptowährungen</a></li>
<li><a href="../de416405/index.html">Bachelor-Studiengänge in Partnerschaft mit Yandex</a></li>
<li><a href="../de416407/index.html">Verkehr von Mikrotiks Schnüffler sparen</a></li>
<li><a href="../de416409/index.html">5 häufige Fehler bei der Entwicklung von Strategien und Möglichkeiten, mit ihnen umzugehen</a></li>
<li><a href="../de416411/index.html">Geschichten mit Daten erzählen</a></li>
<li><a href="../de416415/index.html">Wir bewegen alles in der Testbaugruppe Vivaldi 1.16.1230.3</a></li>
<li><a href="../de416417/index.html">"Heavenly River" - China wird einen künstlichen Regen von beispielloser Kraft erzeugen</a></li>
<li><a href="../de416419/index.html">Zufälliger zweidimensionaler Höhlengenerator</a></li>
<li><a href="../de416421/index.html">Ein Spaziergang in der Boxengasse oder wie IaaS-Technologien Rennteams helfen</a></li>
<li><a href="../de416423/index.html">Wie die Russen an den amerikanischen Prozessor erinnerten oder eine Überprüfung des AdvoCam-FD8 Gold-II DVR (GPS + GLONASS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>