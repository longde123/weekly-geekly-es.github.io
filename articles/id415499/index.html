<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏿 👩🏻‍🔧 📴 Bagaimana Berhenti Menjadi Takut pada Proguard dan Mulai Hidup 🦁 🦂 🔫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, saya adalah pengembang Android dan saya tidak lagi takut pada ProGuard ... 


 Biasanya, utilitas ini diingat ketika dihadapkan dengan masalah d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Berhenti Menjadi Takut pada Proguard dan Mulai Hidup</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415499/"><p><img src="https://habrastorage.org/webt/ws/uk/rs/wsukrsowhkx1zzbqyocrumhhsmi.png"></p><br><p>  Halo, saya adalah pengembang Android dan saya tidak lagi takut pada ProGuard ... </p><br><p> Biasanya, utilitas ini diingat ketika dihadapkan dengan masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalvik dex-limit</a> atau dengan persyaratan untuk meningkatkan keamanan aplikasi.  Sayangnya, ini jauh dari pertama kali mengkonfigurasi Proguard dengan benar.  Saya sering melihat berapa banyak, setelah memecahkan suatu proyek, mematikan Proguard dan menyalakan dukungan Mulditex, dan setiap kali saya sedikit sedih tentang hal itu, karena Proguard membantu mengurangi ukuran aplikasi dan meningkatkan kinerjanya. </p><br><p>  Pada akhirnya, saya memutuskan untuk menulis artikel di mana saya dapat menaruh semua informasi berguna yang saya pelajari selama beberapa tahun bekerja dengan Proguard dan yang dapat membantu pemula dan mereka yang sudah mengetahui sesuatu. </p><a name="habracut"></a><br><h2 id="o-chem-eto">  Tentang apa ini? </h2><br><p>  Proguard adalah utilitas open-source untuk mengoptimalkan dan mengaburkan kode Java.  Alat ini memproses kode Java yang sudah dikompilasi, sehingga harus bekerja dengan bahasa JVM apa pun.  Lebih tepatnya, bahasa itu sendiri untuk Proguard tidak acuh, hanya bytecode yang penting.  Semua manipulasi bytecode proguard dapat dibagi menjadi 3 kategori utama: <strong>Penyusutan kode</strong> , <strong>Optimasi,</strong> dan <strong>Kebingungan</strong> . </p><br><h3 id="code-shrinking">  Kode menyusut </h3><br><p>  Ya, ini agak aneh untuk menulis kode dan kemudian menghapusnya, tetapi ini adalah realitas pengembangan Android.  Ini, tentu saja, bukan tentang kode yang ditulis dengan tangan (walaupun ini terjadi), tetapi sekitar ton muatan mati yang dibawa oleh perpustakaan dari semua jenis.  <strong>Guava</strong> , <strong>Apache Commons</strong> , <strong>Layanan Google Play</strong> dan orang lain dapat mengembang ukuran file apk dari 500kb menjadi beberapa puluh megabyte.  Terkadang, program tidak bisa dikompilasi karena melebihi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batas metode Dalvik</a> .  Proguard akan membantu menghapus semua kode yang tidak digunakan dan mengurangi ukuran aplikasi kembali menjadi beberapa megabyte. </p><br><h3 id="optimisation">  Optimasi </h3><br><p>  Selain menghapus kode yang tidak perlu, Proguard dapat mengoptimalkan kode yang tersisa.  Arsenalnya meliputi analisis aliran kontrol, analisis aliran data, evaluasi parsial, penugasan tunggal statis, penomoran nilai global, analisis livitas.  Proguard dapat melakukan optimasi lubang intip, mengurangi jumlah alokasi variabel, menyederhanakan rekursi ekor dan banyak lagi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> ).  Selain operasi umum seperti itu, Proguard memiliki optimisasi yang berguna khusus untuk platform Android, misalnya, mengganti kelas enum dengan int, menghapus instruksi logging. </p><br><h3 id="obfuscation">  Kebingungan </h3><br><p>  Akhirnya, Proguard dapat mengubah semua kode Anda menjadi kekacauan yang tidak dapat dibaca dengan mengganti nama semua kelas, metode, dan bidang menjadi set huruf acak (sebenarnya tidak terlalu acak).  Ini adalah opsi yang sangat berguna, karena siapa pun dapat mendekompilasi file apk Anda, dan tidak semua orang memiliki kesabaran untuk memahami kode yang dikaburkan. </p><br><h2 id="princip-raboty">  Prinsip kerja </h2><br><p>  Proguard bekerja dalam 3 langkah dalam urutan yang dijelaskan di atas: <strong>kode menyusut</strong> → <strong>optimisasi</strong> → <strong>kebingungan</strong> .  Setiap langkah bersifat opsional. </p><br><p>  <em>Langkah Pengoptimalan dalam kasus Android SDK dimatikan secara default.</em> </p><br><p>  Agar Proguard berfungsi, Anda perlu menyediakan 3 komponen: </p><br><ul><li> Kode kompilasi Anda adalah arsip dengan file <code>class</code> program Anda dan semua perpustakaan yang Anda gunakan (jar, aar, apk, war, zip, dll.).  Proguard hanya memodifikasi kode yang sudah dikompilasi dan tidak ada hubungannya dengan sumbernya. </li><li>  File konfigurasi - file yang berisi semua aturan, opsi, dan pengaturan yang Anda inginkan untuk memulai pemrosesan. </li><li>  Guci perpustakaan (aar, apks, ...) - kelas platform tempat program Anda berjalan.  Dalam kasus Android, ini adalah <code>android.jar</code> .  Arsip ini diperlukan hanya untuk analisis kode Anda yang benar, mereka tidak akan diubah (ini tidak masuk akal, karena <code>android.jar</code> adalah "di telepon", kami tidak memiliki akses ke sana). </li></ul><br><p><img src="https://habrastorage.org/webt/sf/vb/b8/sfvbb8uuvqdacgnjvzmeka3zpa4.png" alt="Gambar dari presentasi Jeb Ware, tautan di akhir artikel"><br>  (Gambar dari presentasi Jeb Ware, tautan di akhir artikel) </p><br><p>  Menggunakan kelas pustaka dan file konfigurasi Anda, Proguard mendefinisikan semua titik masuk ke program Anda ( <strong>seed</strong> ).  Dengan kata lain, ini mendefinisikan kelas dan metode yang dapat dipanggil dari luar dan yang tidak dapat disentuh.  Kemudian, dimulai dengan <strong>benih yang</strong> ditemukan, Proguard secara rekursif menelusuri semua kode Anda, menandai "menggunakan" segala sesuatu yang dapat dijangkau.  Semua kode lain akan dihapus.  Anda harus menentukan setidaknya satu titik masuk dalam konfigurasi.  Untuk program java standar, ini adalah fungsi <code>main</code> .  Di Android, tidak ada titik masuk tunggal ke dalam program, sebaliknya, kami memiliki komponen standar (Aktivitas, Layanan, dll.) Yang dibuat dan dipanggil oleh sistem.  Untungnya, kita tidak perlu menentukan apa pun di sini sendiri, Android SDK akan membuat konfigurasi yang diperlukan untuk kita. </p><br><h3 id="soputstvuyuschie-fayly">  File pendamping </h3><br><p>  Setelah mendeteksi semua titik masuk, Proguard akan menuliskannya ke file <code>seeds.txt</code> . </p><br><p>  Semua kode yang ditemukan Proguard tidak perlu ditulis ke file <code>usage.txt</code> .  Ini adalah nama yang agak aneh untuk file yang berisi kode jarak jauh, akan lebih tepat untuk memanggilnya dengan unage.txt, tetapi kita memiliki apa yang kita miliki, ingat saja itu. </p><br><p>  Pada langkah kebingungan, file <code>mapping.txt</code> akan dibuat berisi pasangan &lt;nama kelas asli | metode | bidang&gt; -&gt; &lt;nama kelas kabur | metode | bidang&gt;.  File ini berguna ketika Anda perlu menghapus program, misalnya, membaca stacktrace.  Memetakan kembali file secara manual tidak diperlukan, Android SDK memiliki utilitas <code>retrace</code> dan <code>proguardui</code> untuk membantu.  Selain itu, jika Anda menggunakan Fabric Crashlytics, maka plugin gradle mereka dapat menemukan dan memuat file ini secara mandiri ke konsol, sehingga Anda tidak perlu khawatir tentang hal itu. </p><br><p>  Dalam kasus Android, file-file ini biasanya terletak di <code>app/build/output/mapping/&lt;product-flavor-name&gt;/</code> . </p><br><p>  Proguard juga membuat file <code>dump.txt</code> yang berisi semua yang dimasukkan Proguard ke arsip terakhir.  Dia tidak pernah berguna bagi saya, tetapi mungkin itu akan berguna bagi seseorang. </p><br><h3 id="kak-dela-obstoyat-v-android">  Bagaimana kabar Android? </h3><br><p>  Plugin Android Gradle dapat menjalankan Proguard sendiri.  Yang harus Anda lakukan adalah mengaktifkan opsi ini dan menentukan file konfigurasi. </p><br><pre> <code class="hljs cs">buildTypes { &lt;...&gt; release { minifyEnabled <span class="hljs-literal"><span class="hljs-literal">true</span></span> proguardFiles <span class="hljs-string"><span class="hljs-string">'proguard-rules.pro'</span></span>, getDefaultProguardFile(<span class="hljs-string"><span class="hljs-string">'proguard-android.txt'</span></span>) } }</code> </pre> <br><p>  <code>minifyEnabled true</code> - aktifkan Proguard pada waktu build </p><br><p>  <code>proguardFiles</code> - daftar file konfigurasi.  Aturan dari semua file konfigurasi akan ditambahkan ke daftar umum sesuai dengan urutannya. </p><br><p>  <code>proguard-rules.pro</code> adalah file konfigurasi kami dengan aturan spesifik proyek </p><br><p>  <code>getDefaultProguardFile('proguard-android.txt')</code> - fungsi yang mengembalikan file konfigurasi standar untuk aplikasi Android.  Itu terletak di <code>AndroidSDK/tools/proguard</code> </p><br><p>  Faktanya, Android SDK memiliki dua <code>proguard-android.txt</code> : <code>proguard-android.txt</code> dan <code>proguard-android-optimize.txt</code> .  Yang pertama memiliki opsi <code>-dontoptimize</code> , yang mematikan semua optimisasi.  Jika Anda ingin mengaktifkan pengoptimalan, gunakan konfigurasi kedua. </p><br><p>  Selain konfigurasi standar ini, Android SDK (aapt) secara otomatis menghasilkan seperangkat aturan untuk sumber daya: aapt memeriksa semua file xml (termasuk manifes) untuk menemukan semua aktivitas, layanan, tampilan, dll.  dan menghasilkan aturan yang diperlukan untuk mereka.  Aturan yang dihasilkan dapat ditemukan di <code>app/build/intermediates/proguard-rules/&lt;flavor&gt;/aapt_rules.txt</code> .  Anda tidak perlu menentukannya sendiri, Plugin Android Gradle akan menambahkan aturan ini secara otomatis. </p><br><p><img src="https://habrastorage.org/webt/1r/w4/t6/1rw4t6egtvymigl79hnxc3n8t9a.png" alt="Gambar dari presentasi Jeb Ware, tautan di akhir artikel"><br>  (Gambar dari presentasi Jeb Ware, tautan di akhir artikel) </p><br><h2 id="konfigi">  Konfigurasi </h2><br><p>  Menyiapkan Proguard adalah bagian paling mendasar dari bekerja dengannya dan pada saat yang sama paling sulit.  Konfigurasi yang salah dapat dengan mudah memutus kompilasi aplikasi dan aplikasi itu sendiri saat runtime.  Semua opsi konfigurasi yang tersedia didokumentasikan secara detail tidak aktif.  situs </p><br><p>  Di antara semua opsi, saya akan memilih 3 grup paling penting: </p><br><ul><li>  menjaga aturan - Semua titik masuk yang memungkinkan ke program.  Aturan memberi tahu Proguard kelas atau bagian mana dari kelas yang tidak berubah atau yang mana dari modifikasi yang valid untuk kelas tertentu. </li><li>  penyetelan pengoptimalan - menunjukkan pengoptimalan mana yang dapat diterima, berapa banyak siklus pengoptimalan yang perlu dilakukan. </li><li>  bekerja dengan peringatan, kesalahan, dan debugging </li></ul><br><h3 id="keep-rules">  Patuhi aturan </h3><br><p>  Ini adalah serangkaian opsi yang dirancang untuk melindungi kode Anda dari Proguard yang kejam.  Dalam bentuknya yang paling umum, aturan ini terlihat seperti ini: </p><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-keep</span></span> [,<span class="hljs-type"><span class="hljs-type">modifier</span></span>,<span class="hljs-type"><span class="hljs-type">...</span></span>] class_specification</code> </pre> <br><p>  <code>keep</code> adalah yang paling umum dari opsi-opsi ini (ada yang lain), memberi tahu Proguard untuk menyelamatkan kelas itu sendiri dan semua anggota kelasnya: bidang dan metode. </p><br><p>  <code>class_specification</code> - templat yang menunjuk ke kelas atau bagiannya (anggota kelas).  Tampilan umum template sangat besar, dapat dilihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Anda dapat menghubunginya, tetapi secara umum, Anda dapat mengingat bahwa kami memiliki kesempatan untuk membuat templat komponen ini: </p><br><ul><li>  pilih semua kelas dengan nama, paket tertentu </li><li>  pilih semua kelas yang mewarisi / mengimplementasikan kelas / antarmuka tertentu </li><li>  pilih semua kelas dengan pengubah spesifik dan / atau anotasi khusus </li><li>  pilih semua metode dengan nama tertentu, pengubah, argumen dan nilai balik </li><li>  pilih semua bidang dengan nama tertentu, pengubah, dari jenis tertentu. </li><li><p>  dimungkinkan untuk menggunakan wildcard </p><br><p>  Sekali lagi, ini bukan deskripsi ketat dari template, melainkan daftar fitur yang kami miliki.  Berikut ini beberapa contoh: </p><br></li></ul><br><p> <code>-keep public class com.example.MyActivity</code> <br>  simpan kelas <code>com.example.MyActivity</code> </p><br><p> <code>-keep public class * extends android.app.Activity</code> <br>  simpan semua kelas publik yang mewarisi <code>android.app.Activity</code> </p><br><pre> <code class="hljs scala">-keep public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">*</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">android</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ public &lt;init&gt;(android.content.<span class="hljs-type"><span class="hljs-type">Context</span></span>); public &lt;init&gt;(android.content.<span class="hljs-type"><span class="hljs-type">Context</span></span>, android.util.<span class="hljs-type"><span class="hljs-type">AttributeSet</span></span>); public &lt;init&gt;(android.content.<span class="hljs-type"><span class="hljs-type">Context</span></span>, android.util.<span class="hljs-type"><span class="hljs-type">AttributeSet</span></span>, int); public void set*(...); }</code> </pre> <br><p>  temukan semua kelas publik yang mewarisi <code>android.view.View</code> dan simpan 3 konstruktor dengan parameter tertentu di dalamnya + semua metode publik, dengan pengubah <code>void</code> , argumen apa pun, dan nama yang dimulai dengan <code>set</code> .  Semua bagian lain dari kelas dapat dimodifikasi. </p><br><p> <code>-keep class com.habr.** { *; }</code> <br>  simpan semua kelas dan semua isinya dalam paket <code>com.habr</code> </p><br><p>  <code>modifiers</code> - tambahan untuk keep-rule: </p><br><ul><li>  <code>includedescriptorclasses</code> - di samping kelas / metode / bidang yang ditentukan, Anda harus menyimpan semua kelas yang terjadi di deskriptornya. </li><li>  <code>includecode</code> - isi metode yang ditunjukkan oleh aturan khusus ini tidak dapat disentuh juga. </li><li>  <code>allowshrinking</code> - kelas yang ditunjuk oleh aturan ini bukan seed dan dapat dihapus, tetapi hanya jika mereka tidak digunakan dalam program itu sendiri.  Namun, jika setelah kode-menyusutkan kode ini tetap (karena fakta bahwa seseorang menggunakannya), tidak mungkin untuk mengoptimalkan / mengaburkan kode ini. </li><li>  <code>allowoptimization</code> - kelas yang dirujuk oleh aturan ini hanya dapat dioptimalkan, tetapi tidak dapat dihapus atau dikaburkan. </li><li>  <code>allowobfuscation</code> - kelas yang ditunjukkan oleh aturan ini hanya dapat dikaburkan, tetapi tidak dapat dihapus atau dioptimalkan. </li></ul><br><p>  Selain <code>keep</code> , ada beberapa opsi lagi: </p><br><p>  <code>-keepclassmembers</code> - menunjukkan bahwa anggota kelas harus disimpan jika kelas itu sendiri dipertahankan setelah kode menyusut. </p><br><p>  <code>-keepclasseswithmembers</code> - menunjukkan bahwa Anda ingin menyimpan kelas yang isinya termasuk dalam templat yang ditentukan.  Sebagai contoh, <code>-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context); }</code>  <code>-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context); }</code> - menyimpan semua kelas yang memiliki konstruktor publik dengan satu argumen tipe <code>Context</code> . </p><br><p>  <code>-keepnames</code> - kependekan <code>-keep,allowshrinking</code> untuk <code>-keep,allowshrinking</code> . </p><br><p>  <code>-keepclassmembernames</code> - singkatan untuk <code>-keepclassmembers,allowshrinking</code> . </p><br><p>  <code>keepclasseswithmembernames</code> - kependekan <code>-keepclasseswithmembers,allowshrinking</code> . </p><br><h3 id="optimisation-tuning">  Penyempurnaan optimasi </h3><br><p>  Opsi paling penting di sini adalah flag <code>-dontoptimize</code> .  Jika ada, tidak ada optimasi yang akan dilakukan dan semua opsi optimasi lainnya akan diabaikan. </p><br><p>  Ada banyak opsi pengoptimalan, tetapi yang berikut paling berguna bagi saya: </p><br><p>  <code>-optimizations optimization_filter</code> - mendaftar semua cara yang ingin Anda gunakan.  Lebih baik menggunakan set yang ditentukan di <code>proguard-android-optimize.txt</code> atau bagian dari itu.  Daftar semua optimasi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  <code>-optimizationpasses n</code> - jumlah siklus optimisasi.  Beberapa siklus dapat meningkatkan hasilnya.  Pada saat yang sama, Proguard cukup pintar untuk menghentikan siklus jika melihat bahwa hasilnya belum membaik dari waktu terakhir. </p><br><p>  <code>-assumenosideeffects class_specification</code> - menunjukkan bahwa metode ini tidak memiliki efek samping dan hanya mengembalikan beberapa nilai.  Proguard akan menghapus panggilan ke metode ini jika mendeteksi bahwa hasilnya tidak digunakan.  Mungkin penggunaan yang paling umum dari opsi ini adalah untuk menghapus semua log debug: <code>-assumenosideeffects class android.util.Log { public static int d(...); }</code> <code>-assumenosideeffects class android.util.Log { public static int d(...); }</code> </p><br><p>  <code>-allowaccessmodification</code> - tampilkan segala sesuatu yang disembunyikan :) Pilihan hebat yang memungkinkan Anda untuk menyingkirkan sekelompok metode <code>-allowaccessmodification</code> buatan untuk kelas bersarang.  Hanya bekerja bersamaan dengan <code>-repackageclasses</code> </p><br><p>  <code>-repackageclasses</code> - <code>-repackageclasses</code> untuk memindahkan semua kelas ke satu paket yang ditentukan.  Ini berlaku lebih untuk kebingungan, tetapi pada saat yang sama, memberikan hasil yang baik dalam pengoptimalan. </p><br><h3 id="prochie-poleznye-opcii">  Opsi lain yang bermanfaat </h3><br><p>  <code>-dontwarn</code> dan <code>-dontnote</code> </p><br><p>  Proguard sangat cerdas dan selalu melaporkan tempat mencurigakan selama analisis kode, terkadang ini adalah catatan, terkadang peringatan.  Jika build Anda tidak berjalan dengan Proguard dihidupkan, pastikan untuk membaca semua log yang dihasilkannya, itu akan menulis apa yang salah dan, kemungkinan besar, bahkan memberi tahu Anda cara memperbaikinya.  Setelah membaca semua pesan, Anda dapat memperbaiki masalah atau mengabaikan pesan dari salah satu opsi ini jika Anda yakin tidak ada masalah. </p><br><p>  Misalnya, beberapa perpustakaan java menggunakan kelas platform yang tidak ada di android.jar dan Proguard akan memperingatkan tentang hal ini.  Jika Anda yakin bahwa pustaka ini berfungsi dengan baik di lingkungan Android, Anda dapat mematikan peringatan ini - <code>-dontwarn java.lang.management.**</code> </p><br><p>  <code>-whyareyoukeeping class_specification</code> adalah opsi yang berguna yang akan mencetak alasan mengapa Proguard memutuskan untuk tidak menyentuh kelas / metode ini. </p><br><p>  <code>-verbose</code> - mencetak log dan pengecualian yang lebih rinci </p><br><p>  <code>-printconfiguration</code> - mencetak daftar opsi lengkap dari semua file konfigurasi yang digunakan, termasuk aturan dari pustaka dan dihasilkan melalui aapt. </p><br><p>  <code>-keepattributes SourceFile, LineNumberTable</code> - menyimpan meta-informasi (nama file, penomoran baris) untuk dapat men-debug kode dalam IDE dan mendapatkan stacktrace yang bermakna.  Pastikan untuk menambahkan opsi ini. </p><br><h3 id="praktika">  Berlatih </h3><br><p>  Ini biasanya terjadi: nyalakan Proguard dan itu menghancurkan Anda seluruh proyek memberikan banyak kesalahan.  Banyak di langkah ini mematikan Proguard dan mencoba untuk tidak kembali ke sana.  Saya akan mencoba memberikan beberapa tips untuk membuat proses transisi ini lebih mudah. </p><br><h4 id="opredelitsya-s-nachalnymi-vhodnymi-tochkami">  Tentukan titik masuk awal </h4><br><p>  Jika Anda seorang pengembang Android, semuanya sangat sederhana - cukup pilih salah satu dari dua konfigurasi standar dari Android SDK: <code>proguard-android.txt</code> atau <code>proguard-android-optimize.txt</code> , mereka akan mengurus semua yang harus tetap tidak tersentuh. </p><br><h4 id="proverit-vse-biblioteki">  Periksa semua perpustakaan </h4><br><p>  Baru-baru ini, semakin banyak perpustakaan didistribusikan dengan proguard-konfigurasi yang sudah jadi.  Proguard dapat melihat ke dalam arsip, menemukan konfigurasi perpustakaan dan menambahkannya ke opsi lain.  Periksa setiap perpustakaan yang Anda gunakan untuk konfigurasi seperti itu. </p><br><p><img src="https://habrastorage.org/webt/rf/dq/vn/rfdqvnztj-zagmqtzwctc73x3-k.png" alt="(isi file aar dari salah satu perpustakaan)"><br>  (isi file aar dari salah satu perpustakaan) </p><br><p>  Jika Anda menggunakan Google Play Services, maka plugin <code>com.google.gms.google-services</code> akan memilih konfigurasi yang Anda butuhkan sendiri. </p><br><p>  Jika penulis perpustakaan tidak mengemas konfigurasi ke dalam arsip, mungkin mereka berhati-hati dan menulis aturan di situs web mereka, di halaman repositori atau di file README.  Coba cari sendiri konfigurasi untuk versi perpustakaan yang Anda gunakan. </p><br><p>  Jika Anda tidak dapat menemukan aturan siap pakai di mana saja, Anda harus membaca log dan menyelesaikan masalah secara individual.  Kemungkinan besar, Anda perlu menambahkan aturan tetap untuk kode perpustakaan yang rusak.  Atau abaikan kesalahan jika tidak mengganggu program. </p><br><h4 id="provesti-inspekciyu-svoego-koda">  Periksa kode Anda </h4><br><p>  Anda lebih tahu kode apa yang dapat Anda kirim di bawah pisau, tetapi Anda harus hati-hati melihat semua tempat di mana refleksi digunakan: </p><br><ul><li>  Class.forName (...) (dokumentasi menjanjikan bahwa Proguard dapat mendefinisikan kode tersebut, namun, ada beberapa kasus, perlu diperiksa) </li><li>  Model / entitas-kelas yang digunakan dalam serialisasi, pemetaan.  Semua kelas yang nama bidangnya (kadang-kadang kelas itu sendiri) penting untuk disimpan (Gson, RealmIO, dll.) </li><li>  panggilan perpustakaan asli melalui JNI </li></ul><br><h4 id="testy">  Tes </h4><br><p>  Jika kelas / metode hanya digunakan dalam tes dan tempat lain, Proguard akan menghapus kode ini.  Ini adalah situasi umum jika Anda memiliki TDD :) Untuk kasus ini, saya memiliki konfigurasi terpisah, di mana saya menambahkan kelas-kelas yang belum terintegrasi ke dalam proyek, tidak digunakan di mana pun, tetapi yang perlu diuji. </p><br><p>  Di Android Gradle Plugin, selain instruksi <code>proguardFiles</code> , masih ada <code>testProguardFiles</code> .  Instruksi ini diperlukan untuk menentukan konfigurasi yang akan diterapkan pada aplikasi pengujian yang dihasilkan untuk menguji aplikasi Anda saat Anda menjalankan tes instrumentasi.  Biasanya ini digunakan untuk mencapai optimasi / kebingungan yang sama di kedua file apk sehingga tidak ada desync di antara mereka.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> </p><br><h4 id="apk-analyzer">  Penganalisa APK </h4><br><p>  Android Studio memiliki alat yang luar biasa.  Anda dapat membukanya melalui Temukan Tindakan -&gt; Analisis APK, atau dengan membuka file apk itu sendiri di Android Studio.  Analyzer menunjukkan banyak informasi berguna, tetapi sekarang kami tertarik pada kodenya.  Untuk melihat apa yang akhirnya dikemas ke dalam file APK, Anda harus memilih file <code>classes.dex</code> </p><br><p><img src="https://habrastorage.org/webt/go/zz/o_/gozzo_o83s3e1mknkxhqldrzr3g.png"></p><br><p>  Secara default, Anda akan ditunjukkan persis kode yang dihasilkan yang telah melewati langkah penyusutan dan optimisasi.  Namun, Anda dapat mengklik tombol <strong>Load Proguard mapping ...</strong> , tambah <code>seeds.txt</code> dan <code>usage.txt</code> untuk melihat kode yang telah dihapus. </p><br><p><img src="https://habrastorage.org/webt/gy/4a/gk/gy4agkxifirpyy95-exhk1xmguc.png"></p><br><p>  Jika Proguard karena suatu alasan memodifikasi kode yang Anda butuhkan, temukan di Analyzer dan pilih <strong>Generate Proguard Keep Rule</strong> melalui RMB.  Analyzer akan menghasilkan pilihan beberapa opsi untuk aturan, dari yang paling umum ke yang paling spesifik, pilih <strong>SATU</strong> dari mereka. </p><br><p><img src="https://habrastorage.org/webt/ny/zc/ob/nyzcobecp45cnrrjgq3unu3_zba.png"></p><br><p><img src="https://habrastorage.org/webt/yq/wg/0m/yqwg0mwllbw9wauhemkvffgk_h8.png"></p><br><h4 id="dlya-avtorov-bibliotek">  Untuk penulis perpustakaan </h4><br><p>  Jika Anda membuat pustaka Android, Anda dapat menambahkan konfigurasi proguard untuk klien Anda sebagai berikut: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">buildTypes</span></span> { <span class="hljs-section"><span class="hljs-section">release</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">consumerProguardFiles</span></span> <span class="hljs-string"><span class="hljs-string">'proguard-rules.pro'</span></span> } }</code> </pre> <br><p>  Menurut pendapat saya, lebih baik untuk tidak mengoptimalkan dan mengaburkan perpustakaan Anda, tetapi untuk memberikan kesempatan ini kepada pelanggan Anda.  Nada yang baik adalah menambahkan ke config apa yang masih harus ditambahkan oleh pelanggan jika mereka menyertakan Proguard.  Namun, jika Anda masih ingin menambahkan keamanan, jelas bahwa Anda perlu melindungi seluruh API pulic perpustakaan Anda dari Proguard, termasuk deskriptor dan tanda tangan. </p><br><h3 id="r8-dexguard-i-redex">  R8, DexGuard dan Redex </h3><br><p>  R8 adalah alat baru Google untuk menggantikan Proguard saat ini.  Tunggu, jangan mencoba melupakan semua yang baru saja Anda baca di artikel, perlakukan saja seperti Proguard baru.  Google berjanji untuk menjaga seluruh api publik, sehingga semua konfigurasi akan berfungsi seperti sebelumnya.  Proyek ini masih dalam versi beta, tetapi Anda dapat mencobanya sendiri. </p><br><p>  DexGuard adalah utilitas berbayar dari pengembang Proguard.  Itu bisa digunakan bersama atau sebagai ganti Proguard.  Dikatakan bahwa DexGuard dapat melakukan semua yang dapat dilakukan Proguard, tetapi lebih baik.  Sayangnya, saya tidak punya kesempatan untuk mencobanya, jika ada yang punya pengalaman, silakan bagikan. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redex</a> adalah pengoptimal dex lain dari Facebook.  Dilaporkan bahwa dengan itu Anda dapat mencapai peningkatan produktivitas hingga 25% dan mengurangi ukuran aplikasi dengan menerapkan alat ke kode yang sudah diproses oleh Proguard. </p><br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p>  Jangan takut menggunakan Proguard, jangan malas dan luangkan waktu untuk menyiapkan.  Ini akan mengurangi ukurannya, meningkatkan kecepatan kerja, daripada menambah loyalitas pengguna Anda.  Pada saat yang sama, cobalah untuk membuat konfigurasi Proguard yang efektif, jangan menulis aturan "karpet", jika tidak, Jake Wharton yang marah akan mendatangi Anda dan memarahi Anda. </p><br><p><img src="https://habrastorage.org/webt/ma/tf/kz/matfkzxceoougdvn7pfyx4klnho.png"></p><br><h2 id="resursy">  Sumber daya </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs web proguard</a> .  Ada juga informasi tentang DexGuard. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagai contoh aturan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R8</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Merekam presentasi tentang Bagaimana Proguard Bekerja dengan DroidCon</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ProGuard menjaga aturan untuk aplikasi yang lebih kecil (Google I / O '18) rekaman presentasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk untuk mengaktifkan dan mengonfigurasi Proguard untuk Android</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman Wiki</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redex</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415499/">https://habr.com/ru/post/id415499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415485/index.html">Drive Kingston A1000 - ambulan untuk laptop?</a></li>
<li><a href="../id415487/index.html">Halaman sejarah Intel. Chip pertama, Intel 3101</a></li>
<li><a href="../id415489/index.html">Facebook menutup proyek distribusi Internet dengan menggunakan drone pada energi matahari</a></li>
<li><a href="../id415493/index.html">Sebuah perhitungan baru dengan rumus Drake menunjukkan: manusia berada di galaksi dengan probabilitas 53-99,6%</a></li>
<li><a href="../id415495/index.html">Sistem CRM: alat untuk bisnis 80 lvl</a></li>
<li><a href="../id415501/index.html">Ruang Virtual The Hermitage - Langkah Pertama Menuju Masa Depan oleh Pelevin</a></li>
<li><a href="../id415505/index.html">Cara Kerja JS: Penyimpanan</a></li>
<li><a href="../id415509/index.html">Pembelajaran mendalam dalam pemrograman: apa, mengapa dan bagaimana</a></li>
<li><a href="../id415527/index.html">Konferensi DUMP 2018: video semua laporan dan presentasi</a></li>
<li><a href="../id415529/index.html">Juli Acara IT Digest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>