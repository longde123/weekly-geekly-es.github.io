<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 🧑🏿 💲 Membatasi kecepatan pemrosesan permintaan, atau cara mengatur serangan DDoS pada klien Anda 🐔 ⛩️ 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kadang-kadang, ketika mengembangkan produk highload, situasi muncul ketika perlu untuk memproses tidak sebanyak permintaan sebanyak mungkin, tetapi le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membatasi kecepatan pemrosesan permintaan, atau cara mengatur serangan DDoS pada klien Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448438/"><p> Kadang-kadang, ketika mengembangkan produk highload, situasi muncul ketika perlu untuk memproses tidak sebanyak permintaan sebanyak mungkin, tetapi lebih untuk membatasi jumlah permintaan per satuan waktu.  Dalam kasus kami, ini adalah jumlah pemberitahuan push yang dikirim ke pengguna akhir.  Baca lebih lanjut tentang algoritme pembatas laju, pro dan kontra - di bawah potongan. </p><br><a name="habracut"></a><br><p>  Pertama, sedikit tentang kita.  Pushwoosh adalah layanan b2b untuk komunikasi antara pelanggan kami dan penggunanya.  Kami menyediakan solusi komprehensif bagi bisnis untuk berkomunikasi dengan pengguna melalui pemberitahuan push, email, dan saluran komunikasi lainnya.  Selain benar-benar mengirim pesan, kami menawarkan alat untuk mensegmentasi audiens, mengumpulkan dan memproses statistik, dan banyak lagi.  Untuk melakukan ini, dari awal kami menciptakan produk highload di persimpangan banyak teknologi, hanya sebagian kecil di antaranya adalah PHP, Golang, PostgreSQL, MongoDB, Apache Kafka.  Banyak solusi kami yang unik, misalnya, pemberitahuan berkecepatan tinggi.  Kami memproses lebih dari 2 miliar permintaan API per hari, kami memiliki lebih dari 3 miliar perangkat di basis data kami, dan sepanjang waktu kami mengirim lebih dari 500 miliar pemberitahuan ke perangkat ini. </p><br><p>  Dan di sini kita sampai pada situasi di mana notifikasi perlu dikirimkan ke jutaan perangkat tidak secepat mungkin (seperti pada kecepatan tinggi yang telah disebutkan), tetapi secara artifisial membatasi kecepatan sehingga server klien kami yang akan dikunjungi pengguna ketika mereka membuka notifikasi tidak jatuh di bawah waktu yang sama memuat. <br></p><br><p>  Di sini, berbagai algoritme pembatas laju datang untuk membantu kami, yang memungkinkan kami membatasi jumlah permintaan per satuan waktu.  Sebagai aturan, ini digunakan, misalnya, ketika merancang API, karena dengan cara ini kita dapat melindungi sistem dari permintaan yang tidak disengaja atau berbahaya, sebagai akibatnya terjadi keterlambatan atau penolakan layanan kepada klien lain.  Jika pembatasan tarif diterapkan, semua klien dibatasi untuk jumlah permintaan tetap per satuan waktu.  Selain itu, pembatasan kecepatan dapat digunakan ketika mengakses bagian-bagian sistem yang terkait dengan data sensitif;  Jadi, jika penyerang mendapatkan akses ke mereka, maka ia tidak akan dapat dengan cepat mengakses semua data. <br></p><br><p>  Ada banyak cara untuk menerapkan pembatasan tarif.  Pada artikel ini, kami akan mempertimbangkan pro dan kontra dari berbagai algoritma, serta masalah yang mungkin timbul saat meningkatkan solusi ini. <br></p><br><h2>  Permintaan Memproses Algoritma Batas Kecepatan </h2><br><h3>  Leaky Bucket (Leaking Bucket) </h3><br><p>  <i>Leaky Bucket</i> adalah algoritma yang menyediakan pendekatan paling sederhana, paling intuitif untuk membatasi kecepatan pemrosesan menggunakan antrian, yang dapat direpresentasikan sebagai "ember" yang berisi permintaan.  Ketika permintaan diterima, itu ditambahkan ke akhir antrian.  Secara berkala, elemen pertama dalam antrian diproses.  Ini juga dikenal sebagai antrian <abbr title="In - First Out Pertama">FIFO</abbr> .  Jika antrian penuh, maka permintaan tambahan dibuang (atau "bocor"). <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fo/jw/hy/fojwhyst1w3e6fij2eh6lsb04y8.gif" alt="Render Token Bucket"></div><br><p>  Keuntungan dari algoritma ini adalah bahwa hal itu menghaluskan ledakan dan memproses permintaan pada kecepatan yang kira-kira sama, mudah diimplementasikan pada server tunggal atau load balancer, efisien dalam penggunaan memori, karena ukuran antrian untuk setiap pengguna terbatas. <br>  Namun, dengan peningkatan lalu lintas yang tajam, antrian dapat diisi dengan permintaan lama dan menghilangkan kemampuan sistem untuk memproses permintaan yang lebih baru.  Dia juga tidak menjamin bahwa permintaan akan diproses dalam waktu yang tetap.  Selain itu, jika Anda memuat penyeimbang untuk memberikan toleransi kesalahan atau meningkatkan throughput, maka Anda harus menerapkan kebijakan koordinasi dan memastikan batasan global di antara mereka. <br></p><br><p>  Ada variasi dari algoritma ini - <i>Token Bucket</i> ("ember dengan token" atau "algoritma keranjang penanda"). <br></p><br><p>  Dalam implementasi seperti itu, token ditambahkan ke "bucket" dengan kecepatan konstan, dan saat memproses permintaan, token dari "bucket" dihapus;  jika tidak ada token yang cukup, permintaan dibuang.  Anda cukup menggunakan cap waktu sebagai token. <br></p><br><p>  Ada variasi menggunakan beberapa "ember", sedangkan ukuran dan tingkat penerimaan token di dalamnya dapat berbeda untuk masing-masing "ember".  Jika tidak ada cukup token dalam "ember" pertama untuk memproses permintaan, maka kehadiran mereka di kotak kedua, dll., Diperiksa, tetapi prioritas pemrosesan permintaan dikurangi (sebagai aturan, ini digunakan dalam desain antarmuka jaringan ketika, misalnya, Anda dapat mengubah nilai bidang Paket yang diproses <abbr title="Poin Kode Layanan yang Dibedakan">DSCP</abbr> ). <br></p><br><p>  Perbedaan utama dari penerapan <i>Leaky Bucket</i> adalah bahwa token dapat terakumulasi ketika sistem idle dan semburan dapat terjadi kemudian, sementara permintaan akan diproses (karena ada cukup token), sementara <i>Leaky Bucket</i> dijamin untuk memperlancar beban bahkan dalam kasus downtime. <br></p><br><h3>  Memperbaiki Jendela </h3><br><p>  Algoritma ini menggunakan jendela n detik untuk melacak permintaan.  Biasanya, nilai-nilai seperti 60 detik (menit) atau 3600 detik (jam) digunakan.  Setiap permintaan masuk meningkatkan penghitung untuk jendela ini.  Jika penghitung melebihi nilai ambang tertentu, permintaan tersebut dibuang.  Biasanya, jendela ditentukan oleh batas bawah dari interval waktu saat ini, yaitu, ketika jendela 60 detik lebar, permintaan yang tiba di 12:00:03 akan pergi ke jendela 12:00:00. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w3/lz/di/w3lzdijb2gk80a6rltf7rs2ejz8.gif" alt="Rendering Fixed Window"></div><br><p>  Keuntungan dari algoritma ini adalah bahwa ia menyediakan pemrosesan permintaan yang lebih baru, tanpa tergantung pada pemrosesan yang lama.  Namun, satu ledakan lalu lintas di dekat batas jendela dapat menggandakan jumlah permintaan yang diproses, karena memungkinkan permintaan untuk jendela saat ini dan berikutnya untuk jangka waktu singkat.  Selain itu, jika banyak pengguna menunggu penghitung jendela untuk mengatur ulang, misalnya, pada akhir jam, mereka dapat memprovokasi peningkatan beban pada saat ini karena fakta bahwa mereka akan mengakses API pada saat yang sama. <br></p><br><h3>  Sliding Log </h3><br><p>  Algoritma ini melibatkan pelacakan cap waktu dari setiap permintaan pengguna.  Catatan-catatan ini disimpan, misalnya, dalam set atau tabel hash dan diurutkan berdasarkan waktu;  catatan di luar interval yang dipantau dibuang.  Ketika permintaan baru tiba, kami menghitung jumlah catatan untuk menentukan frekuensi permintaan.  Jika permintaan di luar jumlah yang diijinkan, maka itu dibuang. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/8a/9z/nv8a9zz0_ycg7sm4htfair2fk44.gif" alt="Visualisasi Sliding Log"></div><br><p>  Keuntungan dari algoritma ini adalah bahwa ia tidak mengalami masalah yang muncul di perbatasan <i>Fixed Window</i> , yaitu batas kecepatan akan diamati dengan ketat.  Selain itu, karena setiap permintaan klien dimonitor secara terpisah, tidak ada pertumbuhan beban puncak pada titik-titik tertentu, yang merupakan masalah lain dari algoritma sebelumnya. <br></p><br><p>  Namun, menyimpan informasi tentang setiap permintaan bisa mahal, di samping itu, setiap permintaan memerlukan penghitungan jumlah permintaan sebelumnya, yang berpotensi pada seluruh kluster, sebagai akibatnya pendekatan ini tidak skala dengan baik untuk menangani ledakan lalu lintas besar dan penolakan serangan layanan. <br></p><br><h3>  Jendela Geser </h3><br><p>  Ini adalah pendekatan hybrid yang menggabungkan biaya rendah pemrosesan <i>Window Tetap</i> dan penanganan canggih situasi batas <i>Sliding Log</i> .  Seperti pada <i>Jendela Tetap yang</i> sederhana, kami melacak penghitung untuk setiap jendela, dan kemudian memperhitungkan nilai bobot frekuensi permintaan jendela sebelumnya berdasarkan cap waktu saat ini untuk memuluskan ledakan lalu lintas.  Misalnya, jika 25% dari waktu jendela saat ini berlalu, maka kami memperhitungkan 75% dari permintaan sebelumnya.  Jumlah data yang relatif kecil yang diperlukan untuk melacak setiap kunci memungkinkan kami untuk mengukur dan bekerja dalam kelompok besar. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/yz/ps/jxyzpszmkozfruckcg2s5lhsmd0.gif" alt="Jendela Geser Visualisasi"></div><br><p>  Algoritma ini memungkinkan Anda untuk mengukur pembatasan tingkat, sambil mempertahankan kinerja yang baik.  Selain itu, ini adalah cara yang dapat dimengerti untuk menyampaikan informasi kepada pelanggan tentang pembatasan jumlah permintaan, dan juga menghindari masalah yang muncul saat menerapkan algoritma pembatasan tarif lainnya. <br></p><br><h2>  Pembatasan Nilai dalam Sistem Terdistribusi </h2><br><h3>  Kebijakan Sinkronisasi </h3><br><p>  Jika Anda ingin menetapkan batasan laju global saat mengakses kluster yang terdiri dari beberapa node, maka Anda perlu menerapkan kebijakan pembatasan.  Jika setiap node hanya melacak batasannya sendiri, maka pengguna dapat mem-bypassnya dengan hanya mengirimkan permintaan ke node yang berbeda.  Bahkan, semakin besar jumlah node, semakin besar kemungkinan pengguna akan dapat melampaui batas global. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/iq/30/nbiq30phqg_b0zibtuoagajyl50.gif" alt="Visualisasi kurangnya sinkronisasi"></div><br><p>  Cara termudah untuk menetapkan batas adalah dengan mengkonfigurasi "sesi lengket" pada penyeimbang sehingga pengguna diarahkan ke simpul yang sama.  Kerugian dari metode ini adalah kurangnya toleransi kesalahan dan masalah penskalaan ketika node cluster kelebihan beban. <br></p><br><p>  Solusi terbaik, yang memungkinkan aturan yang lebih fleksibel untuk load balancing, adalah dengan menggunakan gudang data terpusat (pilihan Anda).  Ini dapat menyimpan penghitung jumlah permintaan untuk setiap jendela dan pengguna.  Masalah utama dari pendekatan ini adalah peningkatan waktu respons karena permintaan penyimpanan dan kondisi ras. <br></p><br><h3>  Kondisi balapan </h3><br><p>  Salah satu masalah terbesar dengan data warehouse terpusat adalah kemungkinan kondisi balapan saat bersaing.  Ini terjadi ketika Anda menggunakan pendekatan get-then-set alami, di mana Anda mengekstrak penghitung saat ini, menambahkannya, dan kemudian mengirim nilai yang dihasilkan kembali ke toko.  Masalah dengan model ini adalah bahwa selama waktu yang diperlukan untuk menyelesaikan siklus penuh dari operasi ini (yaitu, membaca, menambah dan menulis), permintaan lain dapat masuk, di mana masing-masing penghitung akan disimpan dengan nilai yang tidak valid (lebih rendah).  Ini memungkinkan pengguna untuk mengirim lebih banyak permintaan daripada yang disediakan oleh algoritma pembatasan kecepatan. <br></p><br><p>  Salah satu cara untuk menghindari masalah ini adalah dengan mengatur kunci di sekitar kunci yang dimaksud, mencegah akses untuk membaca atau menulis proses lain ke penghitung.  Namun, ini dapat dengan cepat menjadi hambatan kinerja dan tidak skala dengan baik, terutama ketika menggunakan server jauh, seperti Redis, sebagai penyimpan data tambahan. <br></p><br><p>  Pendekatan yang jauh lebih baik adalah "set - kemudian - get", berdasarkan pada operator atom, yang memungkinkan Anda untuk dengan cepat meningkatkan dan memeriksa nilai penghitung tanpa mengganggu operasi atom. <br></p><br><h3>  Optimalisasi kinerja </h3><br><p>  Kerugian lain dari menggunakan gudang data terpusat adalah peningkatan waktu respons karena keterlambatan dalam memeriksa penghitung yang digunakan untuk menerapkan pembatasan tarif (waktu <i>pulang-pergi</i> , atau “penundaan <i>pulang-pergi</i> ”).  Sayangnya, bahkan memeriksa penyimpanan cepat seperti Redis akan menghasilkan penundaan tambahan beberapa milidetik per permintaan. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/y_/oc/vny_ocyqyqddljb5lbqnd5wlrgw.gif" alt="Visualisasi waktu pulang pergi"></div><br><p>  Untuk membuat definisi kendala dengan penundaan minimum, perlu dilakukan pemeriksaan di memori lokal.  Ini dapat dilakukan dengan mengendurkan kondisi untuk memeriksa kecepatan dan akhirnya menggunakan model yang konsisten. <br></p><br><p>  Misalnya, setiap node dapat membuat siklus sinkronisasi data yang akan disinkronkan dengan repositori.  Setiap node secara berkala mentransmisikan nilai penghitung untuk setiap pengguna dan jendela yang terpengaruh, ke toko, yang akan memperbarui nilai-nilai secara atom.  Kemudian node dapat menerima nilai baru dan memperbarui data dalam memori lokal.  Siklus ini pada akhirnya akan memungkinkan semua node dalam klaster menjadi terbaru. <br></p><br><p>  Periode di mana node disinkronkan harus disesuaikan.  Interval sinkronisasi yang lebih pendek akan menyebabkan perbedaan data yang lebih sedikit ketika beban didistribusikan secara merata di beberapa node cluster (misalnya, dalam kasus ketika balancer menentukan node sesuai dengan prinsip "round-robin"), sementara interval yang lebih lama membuat lebih sedikit beban baca / tulis untuk penyimpanan. dan mengurangi biaya di setiap node untuk menerima data yang disinkronkan. <br></p><br><h2>  Perbandingan Algoritma Pembatas Rate </h2><br><p>  Khususnya, dalam kasus kami, kami tidak boleh menolak permintaan klien untuk API, tetapi atas dasar data, sebaliknya, jangan membuatnya;  namun, kami tidak berhak untuk “kehilangan” permintaan.  Untuk melakukan ini, saat mengirim pemberitahuan, kami menggunakan parameter send_rate, yang menunjukkan jumlah maksimum pemberitahuan yang akan kami kirim per detik saat mengirim. <br></p><br><p>  Jadi, kami memiliki Pekerja tertentu yang melakukan pekerjaan dalam waktu yang ditentukan (dalam contoh saya, membaca dari file), yang menerima antarmuka RateLimitingInterface sebagai input, memberi tahu apakah mungkin untuk mengeksekusi permintaan pada waktu tertentu dan berapa lama akan berjalan. <br></p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateLimitingInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $rate Expected send rate */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $rate)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> float $currentTime Current timestamp in microseconds * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canDoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float $currentTime)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span>; }</code> </pre> <br><p>  Semua contoh kode dapat ditemukan di GitHub di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br></p><br><p>  Saya akan segera menjelaskan mengapa Anda perlu mentransfer waktu ke Worker.  Faktanya adalah bahwa terlalu mahal untuk menjalankan daemon terpisah untuk memproses pengiriman satu pesan dengan batas kecepatan, jadi send_rate sebenarnya digunakan sebagai parameter “jumlah pemberitahuan per unit waktu”, yaitu 0,01 - 1 detik tergantung pada beban. <br></p><br><p>  Bahkan, kami memproses hingga 100 permintaan berbeda dengan send_rate per detik, mengalokasikan 1 / N detik untuk setiap kuantum waktu, di mana N adalah jumlah dorongan yang diproses oleh daemon ini.  Parameter yang paling kami minati selama pemrosesan adalah apakah send_rate akan dihormati (kesalahan kecil diizinkan dalam satu arah atau yang lain) dan beban pada perangkat keras kami (jumlah minimum akses ke penyimpanan, CPU dan konsumsi memori). <br></p><br><p>  Untuk memulai, mari kita cari tahu pada titik mana waktu pekerja benar-benar bekerja.  Untuk mempermudah, contoh ini memproses file 10.000-baris dengan send_rate = 1000 (artinya, kita membaca 1000 baris per detik dari file). <br></p><br>  Dalam tangkapan layar, spidol menandai momen dan jumlah panggilan gadget untuk semua algoritma.  Pada kenyataannya, ini bisa menjadi banding ke database, sumber daya pihak ketiga, atau pertanyaan lain, jumlah yang ingin kita batasi per unit waktu. <br><br><p>  Pada skala X - waktu dari awal pemrosesan, dari 0 hingga 10 detik, setiap detik dibagi menjadi sepersepuluh, jadi jadwalnya adalah 0 hingga 100). <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/vk/9u/tbvk9usi0mai17koyki16flm6im.png" alt="Operasi Token Bucket"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/77/t0/av/77t0avq7kqwhkm_4tqlcurek4qc.png" alt="Memperbaiki Operasi Algoritma Window"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w9/xo/yi/w9xoyihrbuezu0exbewj8mru9mm.png" alt="Pengoperasian algoritma Sliding Log"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ye/u0/etyeu0hvzzd4hygu8outelbr2ru.png" alt="Pengoperasian Algoritma Jendela Geser"></div><br><p>  Kita melihat bahwa terlepas dari kenyataan bahwa semua algoritma mengatasi send_rate (untuk ini mereka dirancang), <i>Fixed Window</i> dan <i>Sliding Log</i> “memberikan” seluruh beban hampir secara bersamaan, yang tidak cocok dengan kita, sementara <i>Token Bucket</i> dan <i>Sliding Windows</i> mendistribusikannya secara merata per unit waktu (dengan pengecualian beban puncak pada saat mulai, karena kurangnya data tentang beban pada waktu sebelumnya). <br></p><br><p>  Karena kenyataan bahwa kode biasanya tidak bekerja dengan sistem file lokal, tetapi dengan penyimpanan pihak ketiga, jawabannya mungkin tertunda, mungkin ada masalah jaringan dan banyak masalah lainnya, kami akan mencoba memeriksa bagaimana ini atau itu akan berperilaku ketika permintaan membutuhkan waktu. tidak.  Misalnya, setelah 4 dan 6 detik. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/lj/gg/fjljggb06hkp7yannsyvtt3b_rw.png" alt="Operasi Bucket Token Tunda"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/jp/nw/qqjpnw6rtcp7wmgmnsu3omlqkrw.png" alt="Memperbaiki operasi Window dengan penundaan"></div><br><p>  Di sini, sepertinya <i>Window Tetap</i> tidak bekerja dengan benar dan diproses 2 kali lebih banyak dari permintaan yang diharapkan pada pertama dan dari 7 hingga 8 detik, tetapi kenyataannya tidak demikian, karena waktu dihitung dari saat peluncuran pada grafik, dan algoritma menggunakan cap waktu unix saat ini . <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yh/0k/-k/yh0k-ko8ragfy0mb1n4vcjj8c2o.png" alt="Operasi Penundaan Tertunda"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wh/jx/ww/whjxwwdpzkgxx1hikrb2ogpag-o.png" alt="Operasi Jendela Geser dengan penundaan"></div><br><p>  Secara umum, tidak ada yang berubah secara mendasar, tetapi kami melihat bahwa <i>Token Bucket</i> menghaluskan beban lebih lancar dan tidak pernah melebihi batas tarif yang ditentukan, tetapi <i>Sliding Log</i> jika terjadi downtime dapat melebihi nilai yang diizinkan. <br></p><br><h2>  Kesimpulan </h2><br><p>  Kami memeriksa semua algoritma dasar untuk menerapkan pembatasan tingkat, yang masing-masing memiliki pro dan kontra dan cocok untuk berbagai tugas.  Kami berharap setelah membaca artikel ini, Anda akan memilih algoritma yang paling cocok untuk menyelesaikan masalah Anda. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448438/">https://habr.com/ru/post/id448438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448424/index.html">55 tahun kemudian: konsol IBM System / 360 mainframe cult yang ikonik</a></li>
<li><a href="../id448430/index.html">Konten Pro 2019: tiga laporan keras dan lagu pendek</a></li>
<li><a href="../id448432/index.html">Radiasi berperekat: radioaktif terinduksi, kontaminasi radioaktif, dekontaminasi ...</a></li>
<li><a href="../id448434/index.html">Perusahaan pengembang aplikasi seluler teratas</a></li>
<li><a href="../id448436/index.html">Lapisan Konvolusi: Teknik Optimalisasi Penggandaan Matriks</a></li>
<li><a href="../id448440/index.html">Ratusan ribu pembayaran yang dilakukan oleh warga negara ke STSI dan FSSP berada di domain publik</a></li>
<li><a href="../id448442/index.html">SSD GIGABYTE Aorus RGB M.2: kecil, bahkan jarak jauh untuk LED RGB (1 bagian)</a></li>
<li><a href="../id448444/index.html">Menyingkirkan Rasa Takut akan Pekerjaan Pertama</a></li>
<li><a href="../id448448/index.html">Laporan SWIFT: Volume dana yang dicuri oleh peretas dari bank menurun sepuluh kali lipat tiga tahun setelah peretasan sebesar $ 100 juta</a></li>
<li><a href="../id448450/index.html">Alat analisis web untuk pemasar pemula, pemasar produk, dan analitik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>