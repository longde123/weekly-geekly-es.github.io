<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéã üßõüèæ ‚ô£Ô∏è Aserrar datos c√≥modamente üë©üèº‚Äç‚úàÔ∏è üë®üèø‚Äçüéì üç∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia 

 En la pr√°ctica real, a menudo encuentra tareas que est√°n lejos de ser complejos algoritmos de ML, pero al mismo tiempo no son menos import...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aserrar datos c√≥modamente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438556/"><img src="https://habrastorage.org/webt/im/nm/mx/imnmmxqmywsjq2wirence45dz4g.jpeg" alt="imagen"><br><br>  Buen dia <br><br>  En la pr√°ctica real, a menudo encuentra tareas que est√°n lejos de ser complejos algoritmos de ML, pero al mismo tiempo no son menos importantes y urgentes para el negocio. <br>  Hablemos de uno de ellos. <br><br>  La tarea se reduce a distribuir (aserrar, rasplitovat - la jerga del negocio es inagotable) los datos de alguna tabla objetivo con agregados (valores agregados) en una tabla de granularidad m√°s detallada. <br><br>  Por ejemplo, el departamento comercial necesita desglosar el plan anual acordado a nivel de marca, en detalle, para los productos, para que los especialistas en marketing desglosen el presupuesto anual de comercializaci√≥n por pa√≠s, el departamento de planificaci√≥n y econ√≥mico para desglosar los gastos comerciales generales por centros de responsabilidad financiera, etc.  etc. <br><br>  Si siente que tareas como esta ya se avecinan frente a usted en el horizonte o ya est√°n tratando a aquellos que han sufrido tales tareas, entonces le pido un gato. <br><a name="habracut"></a><br>  Considere un ejemplo real: <br><br>  Bajan el plan de ventas como una tarea como en la imagen de abajo (intencionalmente simplifiqu√© el ejemplo, en realidad: un banner de Excel de 100-200 mb). <br><br>  Explicaci√≥n del encabezado: <br><br><ul><li>  pos_terr-territorio (regi√≥n) de la salida </li><li>  pos_fo: el distrito federal de la tienda (por ejemplo, el Distrito Federal Central-Distrito Federal Central) </li><li>  product_brend - marca del producto </li><li>  clase_producto - clase de producto </li><li>  plan.sales es un plan de ventas para cualquier cosa. </li></ul><br><img src="https://habrastorage.org/webt/wc/2t/n5/wc2tn5wplux5kjawucs4gpl5ey8.png" alt="imagen"><br><br>  Y piden, por ejemplo, romper su mega-mesa (en el marco del ejemplo de nuestros hijos, por supuesto, es m√°s modesto) - al canal de ventas.  A la pregunta, de acuerdo con qu√© l√≥gica dividir, obtengo la respuesta: "pero tome las estad√≠sticas de ventas reales para el cuarto trimestre de tal a√±o, obtenga las cuotas reales de canales en% para cada l√≠nea del plan y desglose estas partes de la l√≠nea del plan". <br>  De hecho, esta es la respuesta m√°s frecuente en tales tareas ... <br><br>  Hasta ahora, todo parece bastante simple. <br><br>  Me da este hecho (ver la imagen a continuaci√≥n): <br><br><ul><li>  pos_channell - canal de ventas (atributo objetivo para el plan) </li><li>  fact.sales: ventas reales de algo. </li></ul><br><img src="https://habrastorage.org/webt/8t/uo/pn/8tuopnzhdexvdz9cq2c6sqftgxc.png" alt="imagen"><br><br>  Basado en el enfoque obtenido para "aserrar" en el ejemplo de la primera l√≠nea del plan, lo desglosaremos en base al hecho de algo como esto: <br><br><img src="https://habrastorage.org/webt/b9/ib/q0/b9ibq06zbezjvfhsf5gxkeoba4s.png" alt="imagen"><br><br>  Sin embargo, si comparamos el hecho con el plan para toda la placa con el fin de comprender si todas las l√≠neas del plan se pueden "cortar" adecuadamente en acciones, obtenemos la siguiente imagen: (verde: todos los atributos de la l√≠nea del plan coincidieron con el hecho, las celdas amarillas no coincid√≠an). <br><br><img src="https://habrastorage.org/webt/tp/vm/ta/tpvmtayhezx1cou7359wqzmds3c.png" alt="imagen"><br><br><ul><li>  En la primera l√≠nea del plan, todos los campos se encuentran completamente en el hecho. </li><li>  En la segunda l√≠nea del plan, el territorio correspondiente no se encontr√≥ en el hecho </li><li>  La tercera l√≠nea del plan no es suficiente en el hecho de que la marca </li><li>  La cuarta l√≠nea del plan no es suficiente en el hecho del territorio y el distrito federal. </li><li>  La quinta l√≠nea del plan carece de hecho de la marca y la clase. </li></ul><br>  Como dijo Panikovsky: "Vio la Shura, vio: son de oro ..." <br><br><img src="https://habrastorage.org/webt/m3/v0/ig/m3v0ig5ao9agopnt9-7tthegaiu.jpeg" alt="imagen"><br><br>  Voy al cliente comercial y aclaro sobre el ejemplo de la segunda l√≠nea, ¬øqu√© tipo de enfoque ve para tales situaciones? <br><br>  Recibo la respuesta: "para los casos en que no es posible calcular la proporci√≥n de canales para la marca No. 2 en la regi√≥n de Smolensk (teniendo en cuenta el hecho de que tenemos la regi√≥n de Smolensk en el Distrito Federal Central-Distrito Federal Central), ¬°entonces rompa esta l√≠nea de acuerdo con la estructura de canales dentro de todo el Distrito Federal Central!" <br><br>  Es decir, para {regi√≥n de Smolensk + marca_2} agregamos el hecho a nivel del Distrito Federal Central y dividimos la regi√≥n de Smolensk de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/2t/pf/i1/2tpfi18n14-qytt76pydyjjwnfs.png" alt="imagen"><br><br>  Volviendo y digiriendo lo que escuch√©, trato de generalizar a una heur√≠stica m√°s universal: <br>  Si no hay datos en el nivel de detalle actual de la tabla de hechos, entonces antes de calcular los recursos compartidos para el campo objetivo (canal de ventas), agregamos la tabla de hechos al atributo de jerarqu√≠a anterior. <br><br>  Es decir, si no fuera por el territorio, entonces agregamos el hecho a un nivel jer√°rquico m√°s alto: acciones para el mismo Distrito Federal Central que en el plan.  Si no fuera por la marca, entonces en la jerarqu√≠a anterior hay una clase de producto; en consecuencia, contamos las acciones de la misma clase, etc. <br><br>  Es decir  combinamos el plan y el hecho en los campos de acoplamiento para los cuales consideramos las partes en el hecho y en cada iteraci√≥n de acuerdo con el plan no distribuido restante, reducimos sucesivamente la composici√≥n de los campos de acoplamiento. <br><br>  Un cierto patr√≥n de distribuci√≥n de datos ya se avecina aqu√≠: <br><br><ol><li>  De hecho, distribuimos el plan en funci√≥n de la coincidencia completa de los campos correspondientes. </li><li>  Obtenemos un plan roto (lo acumulamos en el resultado intermedio) y un plan continuo (no todas las l√≠neas coinciden) </li><li>  Tomamos un plan ininterrumpido y lo dividimos de hecho a un nivel jer√°rquico m√°s alto (es decir, abandonamos un cierto campo de acoplamiento de estas 2 tablas y agregamos el hecho sin este campo para calcular las acciones) </li><li>  Obtenemos un plan roto (lo agregamos al resultado intermedio) y un plan continuo (no todas las l√≠neas coinciden) </li><li>  Y repetimos los mismos pasos hasta que no haya un plan "sin resolver". </li></ol><br>  En general, nadie nos obliga a eliminar consistentemente los campos de enganche solo dentro de la jerarqu√≠a.  Por ejemplo, ya hemos eliminado la marca y el territorio de los campos de enganche y distribuimos el plan restante por: product_class (jerarqu√≠a sobre la marca) + Fed.krug (jerarqu√≠a sobre el territorio).  Y todav√≠a tengo un saldo no asignado del plan. <br><br>  Adem√°s, podemos eliminar de los campos de acoplamiento la clase de producto o el distrito federal, como  ya no est√°n incrustados en la jerarqu√≠a del otro. <br><br>  Teniendo en cuenta que hay docenas y filas de campos en tales tablas, hasta un mill√≥n haciendo tales manipulaciones con las manos, la tarea no es la m√°s agradable. <br><br>  Y dado que las tareas de este tipo me llegan regularmente al final de cada a√±o (aprobando los presupuestos para el pr√≥ximo a√±o en la junta directiva), tuvo que traducir este proceso en alg√∫n tipo de plantilla universal flexible. <br><br>  Y como la mayor√≠a de las veces trabajo con datos a trav√©s de R, la implementaci√≥n es, por consiguiente, la misma. <br><br>  Primero, necesitamos escribir una funci√≥n m√°gica universal que tome una tabla base (basetab) con datos para un desglose (en nuestro ejemplo, un plan) y una tabla para calcular acciones (sharetab) en base a la cual "veremos" los datos (en nuestro ejemplo, hecho).  Pero la funci√≥n tambi√©n debe comprender lo que se debe hacer con estos objetos, por lo que la funci√≥n tambi√©n aceptar√° el vector de los nombres de los campos de acoplamiento (merge.vrs), es decir,  aquellos campos que tienen nombres id√©nticos en ambas tablas y nos permitir√°n conectar una tabla a la otra con estos campos donde funciona (es decir, uni√≥n correcta).  Adem√°s, la funci√≥n debe comprender qu√© columna de la tabla base debe tomarse en la distribuci√≥n (basetab.value) y en funci√≥n de qu√© campo contar los recursos compartidos (sharetab.value).  Bueno, y lo m√°s importante: qu√© tomar para el campo resultante (sharetab.targetvars), en nuestro caso, queremos detallar el plan a trav√©s del canal de ventas. <br><br>  Por cierto, esta variable sharetab.targetvars no es aleatoria en mi plural: puede que no sea un campo sino un vector de nombres de campo, para los casos en que necesite agregar no un campo a la tabla base desde la tabla compartida sino varios a la vez (por ejemplo, en funci√≥n del hecho, no puede dividir el plan solo a trav√©s del canal de ventas, pero tambi√©n por el nombre de los productos incluidos en la marca). <br><br>  S√≠, y una condici√≥n m√°s :) mi funci√≥n debe ser lo m√°s local y legible posible, sin ning√∫n edificio de varios pisos en 2 pantallas (realmente no me gustan las funciones grandes). <br><br>  En la √∫ltima condici√≥n, el popular paquete dplyr encaja lo m√°s c√≥modamente posible, y teniendo en cuenta que sus operadores de tuber√≠as deben comprender los nombres textuales de los campos que se han reducido a la funci√≥n, no podr√≠a funcionar sin la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evaluaci√≥n Standart</a> . <br><br>  Aqu√≠ est√° este beb√© (sin contar los comentarios internos): <br><br><pre><code class="plaintext hljs">fn_distr &lt;- function(sharetab, sharetab.value, sharetab.targetvars, basetab, basetab.value, merge.vrs,level.txt=NA) { # sharetab - =   # sharetab.value -            - # sharetab.targetvars -      -          # basetab - =      # basetab.value -         # merge.vrs -    2-  # level.txt -    .       (     merge.vrs) require(dplyr) sharetab.value &lt;- as.name(sharetab.value) basetab.value &lt;- as.name(basetab.value) if(is.na(level.txt )){level.txt &lt;- paste0(merge.vrs,collapse = ",")} result &lt;- sharetab %&gt;% group_by(.dots = c(merge.vrs, sharetab.targetvars)) %&gt;% summarise(sharetab.sum = sum(!!sharetab.value)) %&gt;% ungroup %&gt;% group_by(.dots = merge.vrs) %&gt;% mutate(sharetab.share = sharetab.sum / sum(sharetab.sum)) %&gt;% ungroup %&gt;% right_join(y = basetab, by = merge.vrs) %&gt;% mutate(distributed.result = !!basetab.value * sharetab.share, level = level.txt) %&gt;% select(-sharetab.sum,-sharetab.share) return(result) }</code> </pre> <br>  En la salida, la funci√≥n debe devolver data.frame de la uni√≥n de dos tablas con esas l√≠neas del plan + hecho donde fue posible dividir el plan en la versi√≥n actual de los campos de acoplamiento, y con las l√≠neas originales del plan (y el hecho vac√≠o) en las l√≠neas donde el plan no se pudo dividir en la iteraci√≥n actual. <br><br>  Es decir, el resultado devuelto por la funci√≥n despu√©s de la primera iteraci√≥n (rompiendo la primera l√≠nea del plan para la regi√≥n de Yaroslavl) se ver√° as√≠: <br><br><img src="https://habrastorage.org/webt/zr/jy/nz/zrjynzehck-sb3mv1bysenaixde.png" alt="imagen"><br><br>  Adem√°s, este resultado puede tomarse por un resultado distribuido no vac√≠o en el resultado acumulativo y por un resultado distribuido vac√≠o (NA): enviar a la siguiente iteraci√≥n t√≠pica, pero desglosado por acciones en un nivel jer√°rquico superior. <br><br>  Todo el encanto y la conveniencia es que el trabajo se realiza en el mismo tipo de bloques y una funci√≥n universal, todo lo que se necesita en cada paso (iteraci√≥n) es corregir el vector merge.vrs y observar c√≥mo la magia hace todo este trabajo tedioso para usted: <br><br><img src="https://habrastorage.org/webt/rb/7x/hb/rb7xhby_9ztkha0hwfjfysslxaq.jpeg" alt="imagen"><br><br>  S√≠, casi olvido un peque√±o matiz: si algo sale mal y al final obtenemos un plan roto que en total no ser√° igual al plan antes del desglose, ser√° dif√≠cil rastrear en qu√© iteraci√≥n todo sali√≥ mal. <br><br>  Por lo tanto, suministramos cada iteraci√≥n con una suma de verificaci√≥n: <br><br><pre> <code class="plaintext hljs">(_)-(___ )-(___.)=0</code> </pre> <br>  Ahora intentemos ejecutar nuestro ejemplo a trav√©s de la plantilla de distribuci√≥n y ver qu√© obtenemos en la salida. <br><br>  Primero, obtenga los datos de origen: <br><br><pre> <code class="plaintext hljs">library(dplyr) plan &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "), pos_fo = c("", "", "", "", ""), product_brend = c("brend_1", "brend_2", "brend_3", "brend_4", "brend_5"), product_class = c("class_1", "class_1", "class_2", "class_2", "class_3"), plan.sales = c(100, 200, 300, 400, 500)) fact &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "," ", " ", " ", " ", " "), pos_fo = c("", "","","", "", "", "", "", "", ""), product_brend = c("brend_1", "brend_1", "brend_2", "brend_2","brend_2", "brend_4", "brend_4", "brend_1", "brend_2", "brend_4"), product_class = c("class_1", "class_1", "class_1","class_1","class_1", "class_2", "class_2", "class_1", "class_1", "class_2"), pos_channell = c("", "", "","", "", "", "", "", "", ""), fact.sales = c(16.38, 11.64, 30.73,60, 20, 6.40, 26.49, 46.63, 65.96, 98.81)) &lt;/soure&gt;      (   )     . &lt;source&gt; plan.remain &lt;- plan result.total &lt;- data_frame()</code> </pre><br>  <b>1. Distribuimos por Terr, FD (distrito federal), marca, clase</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_terr","pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) #     -      plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) #            =    cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/84/zv/zq/84zvzqtilnk4mbdvkntjpf43lls.png" alt="imagen"><br><br>  <b>2. Distribuimos por pho, marca, clase (es decir, abandonamos el territorio de hecho)</b> <br><br>  La √∫nica diferencia con respecto al primer bloque es que acortaron ligeramente merge.fields al eliminar pos_terr en √©l <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>3. Distribuir por pho, clase</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>4. Distribuir por clase</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/fe/-q/nd/fe-qnd2szmr7giomwxnliujddha.png" alt="imagen"><br><br>  <b>5. Distribuir por FD</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "pos_fo") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  Como puede ver, no queda ning√∫n plan "no aserrado" y la aritm√©tica del plan distribuido es igual al original. <br><br><img src="https://habrastorage.org/webt/bb/cz/-e/bbcz-enxlpsnwnji6atftwle1tg.png" alt="imagen"><br><br>  Y aqu√≠ est√° el resultado con los canales de ventas (en la columna de la derecha, se muestra la funci√≥n: por qu√© campos se activ√≥ el acoplamiento / agregaci√≥n para que luego podamos entender de d√≥nde proviene esta distribuci√≥n) <br><br><img src="https://habrastorage.org/webt/l_/3t/fg/l_3tfgj9v2hvsflh_q18o8l2cbo.png" alt="imagen"><br><br>  Eso es todo  El art√≠culo no era muy peque√±o, pero hay m√°s texto explicativo que el c√≥digo en s√≠. <br><br>  Espero que este enfoque flexible ahorre tiempo y nervios no solo para m√≠ :-) <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438556/">https://habr.com/ru/post/438556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438544/index.html">Vemos pel√≠culas en casa: 10 materiales sobre c√≥mo construir un cine en casa y elegir equipos</a></li>
<li><a href="../438546/index.html">An√°lisis de los enfoques de enlace de m√≥dulos en Node.js</a></li>
<li><a href="../438548/index.html">Lombok, sources.jar y depuraci√≥n conveniente</a></li>
<li><a href="../438550/index.html">Otro manifiesto</a></li>
<li><a href="../438554/index.html">Administrar estados y eventos entre componentes en GameObject</a></li>
<li><a href="../438560/index.html">Escribir XGBoost desde cero - parte 1: √°rboles de decisi√≥n</a></li>
<li><a href="../438562/index.html">Escribir XGBoost desde cero - parte 2: aumento de gradiente</a></li>
<li><a href="../438566/index.html">Estuche para microprocesador Apple Strange A12X</a></li>
<li><a href="../438568/index.html">Acerca de las computadoras cu√°nticas: c√≥mo los diferentes pa√≠ses desarrollan esta tecnolog√≠a</a></li>
<li><a href="../438570/index.html">CS Center 2018 Competencia de Nochevieja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>