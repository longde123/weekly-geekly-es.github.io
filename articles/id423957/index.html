<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏽 ❤️ ◻️ Generasi lalu lintas ruang pengguna 👨‍👨‍👦 🤣 ❤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traffic Generation Menggunakan MoonGen + DPDK + Lua dalam Tampilan Artis 

 Netralisasi serangan DDoS dalam kondisi nyata memerlukan pengujian awal da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generasi lalu lintas ruang pengguna</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/423957/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/ab/qb/d4abqbslioh-eskinpe4jhet0y4.jpeg"></div><br>  <i>Traffic Generation Menggunakan MoonGen + DPDK + Lua dalam Tampilan Artis</i> <br><br>  Netralisasi serangan DDoS dalam kondisi nyata memerlukan pengujian awal dan pengujian berbagai teknik.  Peralatan dan perangkat lunak jaringan harus diuji dalam kondisi buatan yang mendekati kondisi sebenarnya - dengan arus lalu lintas yang mensimulasikan serangan.  Tanpa eksperimen semacam itu, sangat sulit untuk mendapatkan informasi yang dapat dipercaya tentang fitur-fitur spesifik dan batasan-batasan dari setiap alat kompleks. <br><br>  Pada artikel ini, kami akan mengungkapkan beberapa metode penghasil lalu lintas yang digunakan di Qrator Labs. <br><br>  <b>PERINGATAN</b> <br><br>  Kami sangat menyarankan agar pembaca tidak mencoba menggunakan alat yang disebutkan untuk menyerang objek infrastruktur nyata.  Organisasi serangan DoS dapat dihukum oleh hukum dan dapat menyebabkan hukuman berat.  Qrator Labs melakukan semua tes di lingkungan laboratorium yang terisolasi. <br><a name="habracut"></a><br><h2>  Tingkat teknis modern </h2><br>  Tugas penting di area kami adalah menjenuhkan antarmuka Ethernet 10G dengan paket kecil, yang menyiratkan pemrosesan 14,88 Mpps (jutaan paket per detik).  Selanjutnya, kami mempertimbangkan paket jaringan Ethernet terkecil - 64 byte - karena kepentingan utama kami adalah memaksimalkan jumlah paket yang dikirimkan per unit waktu.  Perhitungan sederhana menunjukkan bahwa kami hanya memiliki sekitar 67 nanodetik untuk memproses satu paket tersebut. <br><br>  Sebagai perbandingan, kali ini dekat dengan apa yang dibutuhkan prosesor modern untuk mendapatkan sepotong data dari memori jika ia melewatkan cache.  Semuanya menjadi lebih rumit ketika kita mulai bekerja dengan antarmuka Ethernet 40G dan 100G dan mencoba untuk menjenuhkan mereka sepenuhnya ke tingkat garis (kinerja maksimum yang dinyatakan mungkin dari perangkat jaringan). <br><br>  Karena dalam kasus biasa aliran data melewati aplikasi di ruang pengguna (userspace), kemudian melalui kernel, akhirnya masuk ke pengontrol jaringan (NIC), ide pertama dan paling mudah adalah mencoba mengkonfigurasi pembuatan paket langsung di kernel.  Contoh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi tersebut</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pktgen</a> modul nuklir [2].  Metode ini memungkinkan Anda untuk secara signifikan meningkatkan kinerja, tetapi tidak cukup fleksibel, karena perubahan sekecil apapun dalam kode sumber dalam kernel mengarah ke siklus pembangunan yang lama, mem-boot ulang modul kernel atau bahkan seluruh sistem dan, pada kenyataannya, pengujian, yang mengurangi produktivitas keseluruhan (yaitu, memerlukan lebih banyak waktu dari programmer dan usaha). <br><br>  Pendekatan lain yang mungkin adalah untuk mendapatkan akses langsung dari userspace ke buffer memori pengontrol jaringan.  Jalur ini lebih rumit, tetapi sepadan dengan upaya untuk mencapai produktivitas yang lebih tinggi.  Kerugian termasuk kompleksitas tinggi dan fleksibilitas rendah.  Contoh dari pendekatan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netmap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PF_RING,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DPDK</a> [4]. <br><br>  Cara lain yang efektif, meskipun sangat mahal untuk mencapai kinerja tinggi adalah dengan menggunakan peralatan yang tidak universal, tetapi khusus.  Contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ixia</a> . <br><br>  Ada juga solusi berdasarkan DPDK menggunakan skrip, yang meningkatkan fleksibilitas dalam mengontrol parameter generator, dan juga memungkinkan Anda untuk memvariasikan jenis paket yang dihasilkan selama startup.  Di bawah ini kami menggambarkan pengalaman kami sendiri dengan salah satu alat ini - MoonGen. <br><br><h2>  Arsitektur MoonGen </h2><br>  Fitur khas MoonGen adalah: <br><br><ol><li>  Memproses data DPDK di userspace adalah alasan utama untuk mendapatkan kinerja; </li><li>  Lua [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5</a> ] susun dengan skrip sederhana di tingkat atas dan binding ke perpustakaan DPDK yang ditulis dalam C, di bagian bawah; </li><li>  Berkat teknologi JIT (tepat waktu), skrip Lua bekerja cukup cepat, yang agak bertentangan dengan ide yang diterima secara umum tentang efektivitas bahasa skrip. </li></ol><br>  MoonGen dapat dianggap sebagai pembungkus Lua di sekitar perpustakaan DPDK.  Setidaknya operasi DPDK berikut terlihat di tingkat antarmuka pengguna Lua: <br><br><ul><li>  Mengkonfigurasi pengontrol jaringan; </li><li>  Alokasi dan akses langsung ke kumpulan dan buffer memori, yang, untuk tujuan optimasi, harus dialokasikan di area yang selaras terus menerus; </li><li>  Akses langsung ke RSS-antrian pengontrol jaringan; </li><li>  API untuk mengelola aliran komputasi, dengan mempertimbangkan heterogenitas akses memori (NUMA dan afinitas CPU) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12</a> ]. </li></ul><br><img src="https://habrastorage.org/webt/qg/vh/ij/qgvhijgvyv0fe5m9vntekmwggxo.png"><br><br>  Arsitektur MoonGen, skema dari material [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> ]. <br><br><h3>  Moongen </h3><br>  MoonGen adalah generator paket berkecepatan tinggi scripted berdasarkan perpustakaan DPDK.  Skrip Lua mengontrol seluruh proses: skrip yang dibuat pengguna bertanggung jawab untuk membuat, memodifikasi, dan mengirim paket.  Berkat pustaka pemrosesan paket LuaJIT dan DPDK yang sangat cepat, arsitektur ini memungkinkan Anda untuk menjenuhkan antarmuka Ethernet 10 gigabit dengan paket 64-byte hanya menggunakan satu inti dari CPU.  MoonGen memungkinkan Anda untuk mencapai kecepatan ini bahkan ketika skrip Lua memodifikasi setiap paket.  Itu tidak menggunakan trik seperti menggunakan kembali buffer yang sama dari pengontrol jaringan. <br><br>  MoonGen juga dapat menerima paket, mis. Memeriksa paket mana yang dijatuhkan oleh sistem yang sedang diuji.  Karena penerimaan paket dikendalikan secara eksklusif oleh skrip Lua khusus, itu juga dapat digunakan untuk membuat skrip pengujian yang lebih kompleks.  Misalnya, Anda dapat menggunakan dua instance MoonGen untuk membuat koneksi satu sama lain.  Konfigurasi semacam itu dapat digunakan, khususnya, untuk menguji apa yang disebut kotak tengah (peralatan antara titik pengiriman dan penerimaan lalu lintas), misalnya, firewall.  MoonGen berfokus pada empat bidang utama: <br><br><ul><li>  Kinerja tinggi dan penskalaan multi-core: lebih dari 20 juta paket per detik pada satu inti CPU; </li><li>  Fleksibilitas: setiap paket dihasilkan secara real time berdasarkan skrip Lua yang dibuat pengguna; </li><li>  Prangko waktu yang tepat: pada perangkat keras (komoditas) biasa, penandaan waktu dilakukan dengan akurasi milidetik; </li><li>  Kontrol yang tepat dari interval antara paket yang dikirim: generasi yang dapat diandalkan dari pola dan jenis lalu lintas yang diperlukan pada perangkat keras biasa. </li></ul><br><h3>  DPDK </h3><br>  DPDK adalah singkatan dari Data Plane Development Kit dan terdiri dari perpustakaan yang fungsi utamanya adalah untuk meningkatkan kinerja menghasilkan paket jaringan pada beragam arsitektur prosesor pusat. <br><br>  Dalam dunia di mana jaringan komputer menjadi dasar komunikasi manusia, kinerja, bandwidth, dan latensi menjadi parameter yang semakin penting untuk sistem seperti jaringan nirkabel dan infrastruktur kabel, termasuk semua komponen individu: router, penyeimbang beban, firewall;  serta area aplikasi: transfer media (streaming), VoIP, dll. <br><br>  DPDK adalah cara yang ringan dan nyaman untuk membuat tes dan skrip.  Transfer data dalam userspace adalah sesuatu yang tidak sering kita amati, terutama karena sebagian besar aplikasi berkomunikasi dengan peralatan jaringan melalui sistem operasi dan tumpukan kernel, yang merupakan kebalikan dari model DPDK. <br><br><h3>  Lua </h3><br>  Tujuan utama dari keberadaan Lua adalah untuk menyediakan alat-alat ekspresif yang sederhana dan fleksibel yang dapat diperluas untuk tugas-tugas spesifik saat ini, bukan seperangkat primitif yang hanya berlaku dalam satu paradigma pemrograman.  Hasilnya, bahasa dasarnya sangat ringan - seluruh penerjemah hanya membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">180 kB</a> dalam bentuk yang dikompilasi dan mudah beradaptasi dengan berbagai kemungkinan implementasi. <br><br>  Lua adalah bahasa yang dinamis.  Sangat kompak sehingga dapat ditempatkan di hampir semua perangkat.  Lua mendukung serangkaian kecil jenis: nilai Boolean, angka (titik mengambang presisi ganda), dan string.  Struktur data konvensional, seperti array, set, dan daftar, dapat diwakili oleh satu-satunya struktur data built-in di Lua - sebuah tabel, yang merupakan array asosiatif heterogen. <br><br>  Lua menggunakan kompilasi JIT (just in time), oleh karena itu, sebagai bahasa scripting, ia menunjukkan kinerja yang sebanding dengan bahasa yang dikompilasi seperti C [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10</a> ]. <br><br><h2>  Mengapa moongen </h2><br>  Sebagai perusahaan yang berspesialisasi dalam menetralkan serangan DDoS, Qrator Labs membutuhkan cara yang andal untuk membuat, meningkatkan, dan menguji solusi keamanannya sendiri.  Untuk pengujian yang terakhir, diperlukan berbagai metode untuk menghasilkan lalu lintas yang mensimulasikan serangan nyata.  Namun, tidaklah mudah untuk mensimulasikan serangan banjir yang berbahaya, namun langsung, pada 2-3 tingkat model OSI, terutama karena kesulitan dalam mencapai kinerja tinggi dalam pembuatan paket. <br><br>  Dengan kata lain, untuk perusahaan yang terlibat dalam ketersediaan berkelanjutan dan netralisasi DDoS, mensimulasikan berbagai serangan DoS di lingkungan laboratorium yang terisolasi adalah cara untuk memahami bagaimana berbagai peralatan yang merupakan bagian dari sistem perangkat keras perusahaan akan berperilaku dalam kenyataan. <br><br>  MoonGen adalah cara yang baik untuk menghasilkan nilai lalu lintas yang dekat dengan batas untuk pengontrol jaringan di minimum core CPU.  Transfer data dalam ruang pengguna secara signifikan meningkatkan kinerja tumpukan yang dipermasalahkan (MoonGen + DPDK), dibandingkan dengan banyak opsi lain untuk menghasilkan nilai lalu lintas tinggi.  Menggunakan DPDK murni membutuhkan lebih banyak upaya, jadi Anda tidak perlu terkejut dengan keinginan kami untuk mengoptimalkan kinerja.  Kami juga mendukung klon [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7</a> ] dari repositori MoonGen asli untuk memperluas fungsionalitas dan implementasi tes kami sendiri. <br><br>  Untuk mencapai fleksibilitas maksimum, logika untuk menghasilkan paket diatur oleh pengguna menggunakan skrip Lua, yang merupakan salah satu fitur utama MoonGen.  Dalam hal pemrosesan paket yang relatif sederhana, solusi ini bekerja cukup cepat untuk menjenuhkan antarmuka 10G pada inti CPU tunggal.  Cara khas untuk memodifikasi paket yang masuk dan membuat yang baru adalah bekerja dengan paket dari jenis yang sama, di mana hanya beberapa bidang yang berubah. <br><br>  Contohnya adalah tes l3-tcp-syn-ack-flood, dijelaskan di bawah ini.  Perhatikan bahwa setiap modifikasi paket dapat dilakukan di buffer yang sama, di mana paket yang dihasilkan atau diterima pada langkah sebelumnya ternyata.  Memang, konversi paket semacam itu dilakukan dengan sangat cepat, karena tidak melibatkan operasi mahal, seperti panggilan sistem, akses ke bagian memori yang berpotensi tidak di-cache, dan sejenisnya. <br><br><h2>  Tes pada Perangkat Keras Qrator Labs </h2><br>  Laboratorium Qrator melakukan semua tes di laboratorium pada berbagai peralatan.  Dalam hal ini, kami menggunakan pengontrol antarmuka jaringan berikut: <br><br><ul><li>  Intel 82599ES 10G </li><li>  Mellanox ConnectX-4 40G </li><li>  Mellanox ConnectX-5 100G </li></ul><br>  Kami mencatat secara terpisah bahwa ketika bekerja dengan pengontrol jaringan yang beroperasi pada standar di atas 10G, masalah kinerja menjadi lebih akut.  Saat ini tidak mungkin untuk menjenuhkan antarmuka 40G dengan satu inti, meskipun dengan sejumlah kecil inti ini sudah realistis. <br><br>  Dalam hal pengontrol jaringan yang diproduksi oleh Mellanox, dimungkinkan untuk mengubah beberapa parameter dan pengaturan perangkat menggunakan panduan tuning [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ] yang disediakan oleh pabrikan.  Ini memungkinkan Anda untuk meningkatkan kinerja, dan dalam beberapa kasus khusus, untuk memperdalam perilaku NIC.  Pabrikan lain mungkin memiliki dokumen serupa untuk perangkat berkinerja tinggi mereka sendiri yang ditujukan untuk penggunaan profesional.  Bahkan jika Anda tidak dapat menemukan dokumen seperti itu di domain publik, selalu masuk akal untuk menghubungi pabrikan secara langsung.  Dalam kasus kami, perwakilan dari perusahaan Mellanox sangat baik dan, selain memberikan dokumentasi, dengan cepat menjawab pertanyaan kami, karena itu kami berhasil mencapai pemanfaatan 100% strip, yang sangat penting bagi kami. <br><br><h3>  Tes banjir TCP SYN </h3><br>  L3-tcp-syn-ack-flood adalah contoh mensimulasikan serangan seperti SYN flood [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6</a> ].  Ini adalah versi diperpanjang Qrator Labs dari uji l3-tcp-syn-banjir dari repositori MoonGen utama, yang disimpan dalam klon repositori kami. <br><br>  Tes kami dapat menjalankan tiga jenis proses: <br><br><ol><li>  Hasilkan aliran paket TCP SYN dari awal, dengan memvariasikan bidang yang diperlukan, seperti alamat IP sumber, nomor port sumber, dll. </li><li>  Buat respons ACK yang valid untuk setiap paket SYN yang diterima sesuai dengan TCP; </li><li>  Buat respons SYN-ACK yang valid untuk setiap paket ACK yang diterima sesuai dengan protokol TCP. </li></ol><br>  Misalnya, loop kode internal (masing-masing, "terpanas") untuk membuat respons ACK adalah sebagai berikut: <br><br><pre><code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tx = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> rx = rxQ:recv(rxBufs) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, rx <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> buf = rxBufs[i] <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pkt = buf:getTcpPacket(ipv4) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pkt.ip4:getProtocol() == ip4.PROTO_TCP <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pkt.tcp:getSyn() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (pkt.tcp:getAck() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> synack) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> seq = pkt.tcp:getSeqNumber() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ack = pkt.tcp:getAckNumber() pkt.tcp:unsetSyn() pkt.tcp:setAckNumber(seq+<span class="hljs-number"><span class="hljs-number">1</span></span>) pkt.tcp:setSeqNumber(ack) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tmp = pkt.ip4.src:get() pkt.ip4.src:set(pkt.ip4.dst:get()) pkt.ip4.dst:set(tmp) … <span class="hljs-comment"><span class="hljs-comment">-- some more manipulations with packet fields tx = tx + 1 txBufs[tx] = buf end end if tx &gt; 0 then txBufs:resize(tx) txBufs:offloadTcpChecksums(ipv4) -- offload checksums to NIC txQ:send(txBufs) end</span></span></code> </pre> <br>  Gagasan umum untuk membuat paket respons adalah sebagai berikut.  Pertama, Anda perlu menghapus paket dari antrian RX, lalu periksa apakah jenis paket cocok dengan yang diharapkan.  Jika kebetulan, siapkan jawaban dengan memodifikasi beberapa bidang paket asli.  Akhirnya, masukkan paket yang dibuat ke antrian TX menggunakan buffer yang sama.  Untuk meningkatkan kinerja, alih-alih mengambil paket satu per satu dan memodifikasinya satu per satu, kami menggabungkannya, mengekstraksi semua paket yang tersedia dari antrian RX, membuat respons yang sesuai, dan menempatkan semuanya dalam antrian TX.  Meskipun ada sejumlah besar manipulasi pada satu paket, kinerja tetap tinggi, terutama karena fakta bahwa Lua JIT mengkompilasi semua operasi ini menjadi sejumlah kecil instruksi prosesor.  Banyak tes lain, tidak hanya TCP SYN / ACK, bekerja dengan prinsip yang sama. <br><br>  Tabel di bawah ini menunjukkan hasil uji banjir SYN (generasi SYN tanpa upaya respons) menggunakan Mellanox ConnectX-4.  NIC ini memiliki dua port 40G dengan langit-langit kinerja teoritis 59,52 Mpps pada satu port dan 2 * 50 Mpps untuk dua port.  Implementasi spesifik menghubungkan NIC ke PCIe agak membatasi bandwidth (memberikan 2 * 50 bukannya yang diharapkan 2 * 59,52). <br><table><tbody><tr><td>  <b>core per port</b> </td><td>  <b>1 port, Mpps</b> </td><td>  <b>2 port, Mpps per masing-masing port</b> </td></tr><tr><td>  1 </td><td>  20 </td><td>  19 </td></tr><tr><td>  2 </td><td>  38 </td><td>  36 </td></tr><tr><td>  3 </td><td>  56.5 </td><td>  47 </td></tr><tr><td>  4 </td><td>  59.5 </td><td>  50 </td></tr></tbody></table><br>  <i>Uji banjir SYN;</i>  <i>NIC: Mellanox Technologies MT27700 Family (ConnectX-4), port ganda 40G;</i>  <i>CPU: Intel® Xeon® Silver 4114 CPU @ 2.20GHz</i> <br><br>  Tabel berikut menunjukkan hasil uji banjir SYN yang sama yang dilakukan pada Mellanox ConnectX-5 dengan satu port 100G. <br><table><tbody><tr><td>  <b>core</b> </td><td>  <b>Mpps</b> </td></tr><tr><td>  1 </td><td>  35 </td></tr><tr><td>  2 </td><td>  69 </td></tr><tr><td>  3 </td><td>  104 </td></tr><tr><td>  4 </td><td>  127 </td></tr><tr><td>  5 </td><td>  120 </td></tr><tr><td>  6 </td><td>  131 </td></tr><tr><td>  7 </td><td>  132 </td></tr><tr><td>  8 </td><td>  144 </td></tr></tbody></table><br>  <i>Uji banjir SYN;</i>  <i>NIC: Mellanox Technologies MT27800 Family (ConnectX-5), port 100G tunggal;</i>  <i>CPU: Intel® Xeon® Silver 4114 CPU @ 2.20GHz</i> <br><br>  Perhatikan bahwa dalam semua kasus, kami mencapai lebih dari 96% langit-langit kinerja teoritis pada sejumlah kecil inti prosesor. <br><br><h3>  Tangkap lalu lintas masuk dan simpan ke file PCAP </h3><br>  Contoh lain dari tes ini adalah rx-to-pcap, yang mencoba untuk menangkap semua lalu lintas masuk dan menyimpan ke sejumlah file PCAP [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8</a> ].  Meskipun tes ini tidak secara khusus menyangkut pembuatan paket, itu berfungsi sebagai demonstrasi fakta bahwa tautan terlemah dalam mengatur transfer data melalui userspace adalah sistem file.  Bahkan sistem file virtual tmpfs memperlambat aliran secara signifikan.  Dalam hal ini, 8 inti dari prosesor sentral diperlukan untuk pemanfaatan 14,88 Mpps, sementara hanya satu inti yang cukup untuk menerima (dan mengatur ulang, atau mengarahkan ulang) jumlah lalu lintas yang sama. <br><br>  Tabel berikut menunjukkan jumlah lalu lintas (dalam Mpps) yang diterima dan disimpan ke file PCAP yang terletak di sistem file ext2 pada SSD (kolom kedua) atau pada sistem file tmpfs (kolom ketiga). <br><table><tbody><tr><td>  <b>core</b> </td><td>  <b>pada SSD, Mpps</b> </td><td>  <b>pada tmpfs, Mpps</b> </td></tr><tr><td>  1 </td><td>  1.48 </td><td>  1.62 </td></tr><tr><td>  2 </td><td>  4 </td><td>  4.6 </td></tr><tr><td>  3 </td><td>  6.94 </td><td>  8.1 </td></tr><tr><td>  4 </td><td>  9.75 </td><td>  11.65 </td></tr><tr><td>  5 </td><td>  12.1 </td><td>  13.8 </td></tr><tr><td>  6 </td><td>  13,38 </td><td>  14.47 </td></tr><tr><td>  7 </td><td>  14.4 </td><td>  14.86 </td></tr><tr><td>  8 </td><td>  14.88 </td><td>  14.88 </td></tr></tbody></table><br>  <i>Tes Rx-to-pcap;</i>  <i>NIC: Intel 82599ES 10-Gigabit;</i>  <i>CPU: Intel® Xeon® CPU E5-2683 v4 @ 2.10GHz</i> <br><br><h2>  Modifikasi MoonGen: Manajer Tugas tman </h2><br>  Kami juga ingin memperkenalkan kepada pembaca ekstensi kami sendiri dari fungsionalitas MoonGen, yang menyediakan cara lain untuk meluncurkan sekelompok tugas untuk pengujian.  Gagasan utama di sini adalah untuk memisahkan konfigurasi umum dan pengaturan khusus untuk setiap tugas, yang memungkinkan Anda untuk menjalankan sejumlah tugas yang berbeda secara sewenang-wenang (yaitu skrip Lua) secara bersamaan.  Dalam klon repositori MoonGen kami, implementasi MoonGen dengan task manager [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9</a> ] disajikan, di sini kami hanya akan secara singkat mencantumkan fungsi utamanya. <br><br>  Antarmuka baris perintah baru memungkinkan Anda untuk menjalankan banyak tugas dari berbagai jenis secara bersamaan.  Skenario dasarnya adalah sebagai berikut: <br><br><pre> <code class="bash hljs">./build/tman [tman options...] [-- &lt;task1-file&gt; [task1 options...]] [-- &lt;task2-file&gt; [task2 options...]] [-- ...]</code> </pre> <br>  Selain itu ./build/tman -h memberikan bantuan terperinci. <br><br>  Namun, ada batasan - file pekerjaan Lua biasa tidak kompatibel dengan antarmuka <i>tman</i> .  <i>File</i> pekerjaan <i>tman</i> harus dengan jelas mendefinisikan objek berikut: <br><br><ul><li>  Fungsi configure (parser) yang menjelaskan parameter pekerjaan; </li><li>  Fungsi tugas (taskNum, txInfo, rxInfo, args), yang menjelaskan proses tugas yang sebenarnya.  Di sini txInfo dan rxInfo masing-masing adalah array dari antrian RX dan TX;  args berisi parameter dari task manager dan tugas itu sendiri. </li><li>  Contoh dapat ditemukan dalam contoh / tman. </li></ul><br>  Menggunakan task manager memberi Anda lebih banyak fleksibilitas dalam menjalankan tes heterogen. <br><br><h3>  Kesimpulan </h3><br>  Metode yang ditawarkan MoonGen ternyata sangat sesuai dengan tujuan kami dan memuaskan karyawan dengan hasil yang diperoleh.  Kami mendapat alat dengan kinerja tinggi, sambil mempertahankan lingkungan pengujian dan bahasa yang cukup sederhana.  Kinerja tinggi dari pengaturan ini dicapai berkat dua fitur utama: akses langsung ke buffer pengontrol antarmuka jaringan dan teknik kompilasi Just-In-Time di Lua. <br><br>  Sebagai aturan, mencapai langit-langit teoritis untuk kinerja pengontrol antarmuka jaringan adalah tugas yang layak.  Seperti yang telah kami tunjukkan, satu inti mungkin cukup untuk menjenuhkan port 10G, sementara muatan penuh port 100G tidak menimbulkan masalah khusus dengan jumlah core yang lebih besar. <br><br>  Kami sangat berterima kasih kepada tim Mellanox atas bantuan mereka dengan peralatan mereka dan kepada tim MoonGen atas reaksi mereka untuk memperbaiki kesalahan. <br><br><h2>  Material </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MoonGen: Generator Paket Berkecepatan Tinggi Scriptable - Paul Emmerich et al., Konferensi Pengukuran Internet 2015 (IMC'15), 2015</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pktgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan tuning Mellanox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kit Pengembangan Pesawat Data</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lua</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Banjir sin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Klon repositori MoonGen dari Qrator Labs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Format file PCAP</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajer tugas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Performa Lua</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi Jaringan Whitepaper Virtualisasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUMA, akses memori yang tidak seragam</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423957/">https://habr.com/ru/post/id423957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423945/index.html">Mahkamah Agung menetapkan prosedur untuk mempertimbangkan kasus-kasus dengan repost dan suka</a></li>
<li><a href="../id423947/index.html">Data pribadi kami tidak dikenakan biaya apa pun</a></li>
<li><a href="../id423949/index.html">Alam semesta yang konsisten dengan kepercayaan kita saat ini mungkin tidak dimungkinkan.</a></li>
<li><a href="../id423953/index.html">Berfungsi manusia atau berhenti mempekerjakan teknologi</a></li>
<li><a href="../id423955/index.html">Bagaimana kami menciptakan produk teknologi dan jatuh ke bawah</a></li>
<li><a href="../id423959/index.html">Kasus Bawah Air - Untuk Robot</a></li>
<li><a href="../id423961/index.html">Jangan kehilangan diri Anda: metode baru untuk mendiagnosis demensia</a></li>
<li><a href="../id423963/index.html">Kelvin Point Prolog</a></li>
<li><a href="../id423965/index.html">Anda membeli SIEM dan yakin bahwa SOC ada di saku Anda, bukan?</a></li>
<li><a href="../id423967/index.html">Seluruh kebenaran tentang RTOS. Artikel # 10. Penjadwal: fitur canggih dan pelestarian konteks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>