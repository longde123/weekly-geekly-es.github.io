<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏻 ☝🏽 🌒 “Last resort” atau mengapa Database First Design diperlukan ♣️ ↪️ 👄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel yang sangat terlambat ini, saya akan menjelaskan mengapa, menurut pendapat saya, dalam banyak kasus, ketika mengembangkan model data unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“Last resort” atau mengapa Database First Design diperlukan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413597/"><p>  Dalam artikel yang sangat terlambat ini, saya akan menjelaskan mengapa, menurut pendapat saya, dalam banyak kasus, ketika mengembangkan model data untuk suatu aplikasi, Anda harus mengikuti pendekatan basis data terlebih dahulu.  Alih-alih pendekatan “Java [bahasa lain] terlebih dahulu”, yang akan membawa Anda ke jalur panjang penuh dengan rasa sakit dan penderitaan, segera setelah proyek mulai tumbuh. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fcf/aaf/2aefcfaafbeb94adc7a73ec265b5feb1.png" alt="gambar"><br>  <em>"Terlalu Sibuk untuk Menjadi Lebih Baik" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC Berlisensi</a> oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alan O'Rourke / Audience Stack</a> .</em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar asli</a></em> <em><br></em> </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel ini terinspirasi oleh pertanyaan StackOverflow baru-baru ini</a> . </p><br><p>  Diskusi reddit yang menarik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/ r / java</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/ r / pemrograman</a> . </p><br><h2 id="kodogeneraciya">  Pembuatan Kode </h2><br><p>  Yang mengejutkan saya, satu kelompok kecil pengguna tampaknya terkejut dengan fakta bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jOOQ</a> sangat terkait dengan pembuatan kode sumber. </p><br><p>  Meskipun Anda dapat menggunakan jOOQ persis seperti yang Anda suka, cara yang disukai (sesuai dengan dokumentasi) adalah mulai dengan skema database yang ada, kemudian buat kelas klien yang diperlukan (sesuai dengan tabel Anda) menggunakan jOOQ, dan setelah itu mudah untuk menulis jenis-aman pertanyaan untuk tabel ini: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Record2&lt;String, String&gt; record : DSL.using(configuration) <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^^^^^^^^^^^^^^ Type information derived from the // generated code referenced from the below SELECT clause .select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) // vvvvv ^^^^^^^^^^^^ ^^^^^^^^^^^^^^^ Generated names .from(ACTOR) .orderBy(1, 2)) { // ... }</span></span></code> </pre> <br><p>  Kode dapat dihasilkan secara manual di luar rakitan, atau secara otomatis dengan setiap rakitan.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generasi tersebut dapat terjadi segera setelah menginstal migrasi Flyway</a> , yang juga dapat dimulai baik secara manual atau otomatis. </p><br><h3 id="generaciya-ishodnogo-koda">  Pembuatan kode sumber </h3><br><p>  Ada berbagai filosofi, kelebihan, dan kekurangan terkait pendekatan pembuatan kode yang tidak ingin saya bahas dalam artikel ini.  Tetapi pada dasarnya, arti dari kode yang dihasilkan adalah bahwa itu adalah representasi Java dari apa yang kita anggap semacam "standar" (baik di dalam maupun di luar sistem kami).  Di satu sisi, kompiler melakukan hal yang sama ketika mereka menghasilkan bytecode, kode mesin, atau beberapa kode sumber lain dari sumber - sebagai hasilnya, kami mendapatkan ide tentang "standar" kami dalam bahasa tertentu lainnya. </p><br><p>  Ada beberapa generator kode semacam itu.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XJC dapat menghasilkan kode Java dari file XSD atau WSDL</a> .  Prinsipnya selalu sama: </p><br><ul><li>  Ada beberapa standar (eksternal atau internal), seperti spesifikasi, model data, dll. </li><li>  Penting untuk mendapatkan ide Anda sendiri tentang standar ini dalam bahasa pemrograman biasa kami. </li></ul><br><p>  Dan hampir selalu masuk akal untuk <em>menghasilkan</em> tampilan ini untuk menghindari pekerjaan yang tidak perlu dan kesalahan yang tidak perlu. </p><br><h3 id="type-providers-i-obrabotka-annotaciy">  Ketik penyedia dan pemrosesan anotasi </h3><br><p>  Perlu dicatat bahwa pendekatan lain, lebih modern, untuk pembuatan kode di jOOQ adalah Penyedia Tipe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti yang dilakukan dalam F #</a> ), di mana kode dihasilkan oleh kompiler selama kompilasi dan tidak pernah ada dalam bentuk asli.  Alat serupa (tapi kurang canggih) di Jawa adalah prosesor anotasi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lombok</a> . </p><br><p>  Dalam kedua kasus, semuanya sama seperti pada pembuatan kode normal, kecuali: </p><br><ul><li>  Anda tidak melihat kode yang dihasilkan (mungkin bagi banyak orang ini merupakan nilai tambah yang besar?) </li><li>  Anda harus memastikan bahwa "referensi" Anda tersedia di setiap kompilasi.  Ini tidak menimbulkan masalah dalam kasus Lombok, yang secara langsung membubuhi keterangan kode sumber itu sendiri, yang merupakan "standar" dalam kasus ini.  Sedikit lebih rumit dengan model database yang mengandalkan koneksi langsung yang selalu aktif. </li></ul><br><h2 id="v-chem-problema-s-generaciey-koda">  Apa masalah dengan pembuatan kode? </h2><br><p>  Selain pertanyaan rumit apakah akan membuat kode secara manual atau otomatis, beberapa orang berpikir bahwa kode tidak perlu dibuat sama sekali.  Alasan saya paling sering mendengar adalah bahwa generasi seperti itu sulit diimplementasikan dalam pipa CI / CD.  Dan ya, itu benar, karena  kami mendapatkan overhead untuk membuat dan mendukung infrastruktur tambahan, terutama jika Anda baru menggunakan alat yang digunakan (jOOQ, JAXB, Hibernate, dll.). </p><br><p>  Jika overhead mempelajari generator kode terlalu tinggi, maka akan ada sedikit manfaatnya.  Tapi ini satu-satunya argumen yang menentang.  Dalam kebanyakan kasus lain, sama sekali tidak masuk akal untuk menulis kode secara manual, yang merupakan representasi biasa dari model sesuatu. </p><br><p>  Banyak orang mengklaim bahwa mereka tidak punya waktu untuk ini, karena  sekarang Anda perlu meluncurkan MVP lain sesegera mungkin.  Dan mereka akan dapat menyelesaikan pipa CI / CD mereka beberapa waktu kemudian.  Dalam kasus seperti itu, saya biasanya berkata, "Kamu terlalu sibuk untuk menjadi lebih baik." </p><br><h2 id="no-ved-hibernatejpa-delaet-java-first-razrabotku-gorazdo-prosche">  "Tapi Hibernate / JPA membuat pengembangan pertama Java jauh lebih mudah." </h2><br><p>  Ya itu benar.  Ini adalah kesenangan dan rasa sakit bagi pengguna Hibernate.  Dengannya, Anda cukup menulis beberapa objek dalam bentuk: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; String title; }</code> </pre> <br><p>  Dan itu hampir selesai.  Selanjutnya, Hibernate akan membahas keseluruhan tentang cara mendefinisikan objek ini dalam DDL dan dalam dialek SQL yang diinginkan: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, title <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> pk_book PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> i_book_title <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> book (title);</code> </pre> <br><p>  Ini benar-benar cara yang bagus untuk memulai pengembangan dengan cepat - Anda hanya perlu memulai aplikasi. </p><br><p>  Tapi tidak semuanya begitu cerah.  Masih banyak pertanyaan: </p><br><ul><li>  Apakah Hibernate akan menghasilkan nama yang saya butuhkan untuk kunci utama? </li><li>  Apakah saya akan membuat indeks yang saya butuhkan di bidang TITLE? </li><li>  Apakah nilai ID unik akan dihasilkan untuk setiap catatan? </li></ul><br><p>  Sepertinya tidak.  Tetapi sementara proyek sedang dalam pengembangan, Anda selalu dapat membuang basis data Anda saat ini dan menghasilkan semuanya dari awal dengan menambahkan anotasi yang diperlukan ke model. <br>  Jadi, kelas Buku dalam bentuk akhirnya akan terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"book"</span></span>, indexes = { <span class="hljs-meta"><span class="hljs-meta">@Index</span></span>(name = <span class="hljs-string"><span class="hljs-string">"i_book_title"</span></span>, columnList = <span class="hljs-string"><span class="hljs-string">"title"</span></span>) }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; String title; }</code> </pre> <br><h2 id="no-vy-zaplatite-za-eto-chut-pozzhe">  Tetapi Anda akan membayar untuk itu, sedikit kemudian </h2><br><p>  Cepat atau lambat, aplikasi Anda masuk ke produksi, dan skema yang dijelaskan akan berhenti bekerja: </p><br><blockquote>  Dalam sistem nyata dan hidup, Anda tidak bisa lagi hanya mengambil dan menjatuhkan basis data Anda, karena  data digunakan di dalamnya dan dapat menghabiskan banyak uang. </blockquote><p>  Mulai sekarang, Anda perlu menulis skrip migrasi untuk setiap perubahan dalam model data, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">misalnya, menggunakan Flyway</a> .  Namun, apa yang terjadi pada kelas klien Anda?  Anda dapat mengadaptasinya secara manual (yang akan menghasilkan kerja ganda) atau meminta Hibernate untuk membuatnya (tetapi seberapa besar kemungkinan hasil dari generasi tersebut memenuhi harapan?).  Akibatnya, Anda mungkin mengalami masalah besar. </p><br><p>  Begitu kode masuk ke produksi, hampir segera diperlukan untuk melakukan koreksi, dan secepat mungkin. </p><br><p>  Dan karena  instalasi migrasi basis data tidak dibangun ke jalur perakitan Anda, Anda harus menginstal tambalan seperti itu secara manual dengan risiko Anda sendiri.  Tidak akan ada cukup waktu untuk kembali dan melakukan semuanya dengan benar.  Hanya cukup untuk menyalahkan Hibernate untuk semua masalahnya. </p><br><p>  Sebaliknya, Anda bisa bertindak sangat berbeda sejak awal.  Yaitu, gunakan roda bundar bukan yang persegi. </p><br><h2 id="vpered-k-database-first">  Pergi ke Database Pertama </h2><br><p>  Referensi dan kontrol skema data ada di kantor DBMS Anda.  Database adalah satu-satunya tempat di mana skema didefinisikan, dan semua klien memiliki <em>salinan</em> skema itu, tetapi tidak sebaliknya.  Data ada di database Anda, dan bukan di klien Anda, jadi masuk akal untuk memberikan kontrol skema dan integritasnya persis di mana data berada. </p><br><p>  Ini adalah kebijaksanaan lama, bukan hal baru.  Kunci primer dan unik bagus.  Kunci asing itu indah.  Memeriksa kendala di sisi basis data sangat bagus.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penegasan (ketika mereka akhirnya diimplementasikan) sangat</a> bagus. </p><br><p>  Dan itu belum semuanya.  Misalnya, jika Anda menggunakan Oracle, Anda dapat menentukan: </p><br><ul><li>  Tablespace di mana tabel Anda? </li><li>  Apa arti PCTFREE yang dimilikinya </li><li>  Berapa ukuran cache urutan? </li></ul><br><p>  Mungkin semua ini tidak masalah pada sistem kecil, tetapi pada sistem yang lebih besar Anda tidak harus mengikuti jalur "data besar" sampai Anda memeras semua jus dari penyimpanan Anda saat ini.  Bukan ORM tunggal yang pernah saya lihat (termasuk jOOQ) akan memungkinkan Anda untuk menggunakan set lengkap parameter DDL yang disediakan oleh DBMS Anda.  ORM hanya menawarkan beberapa alat untuk membantu Anda menulis DDL. </p><br><p>  Pada akhirnya, skema yang dirancang dengan baik hanya boleh ditulis secara manual menggunakan DBL khusus DBMS.  Semua DDL yang dibuat secara otomatis hanyalah perkiraan untuk ini. </p><br><h2 id="chto-naschet-klientskoy-modeli">  Bagaimana dengan model klien? </h2><br><p>  Seperti disebutkan sebelumnya, Anda akan memerlukan representasi tertentu dari skema database di sisi klien.  Tidak perlu dikatakan, pandangan ini harus disinkronkan dengan model nyata.  Bagaimana cara melakukannya?  Tentu saja menggunakan generator kode. </p><br><p>  Semua database menyediakan akses ke meta-informasi mereka melalui SQL lama yang baik.  Jadi, misalnya, Anda bisa mendapatkan daftar semua tabel dari database yang berbeda: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- H2, HSQLDB, MySQL, PostgreSQL, SQL Server SELECT table_schema, table_name FROM information_schema.tables -- DB2 SELECT tabschema, tabname FROM syscat.tables -- Oracle SELECT owner, table_name FROM all_tables -- SQLite SELECT name FROM sqlite_master -- Teradata SELECT databasename, tablename FROM dbc.tables</span></span></code> </pre> <br><p>  Ini adalah pertanyaan seperti itu (juga pertanyaan serupa untuk tampilan, tampilan terwujud, dan fungsi tabel) yang dieksekusi ketika metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DatabaseMetaData.getTables ()</a> dari driver JDBC tertentu dipanggil, atau dalam modul jOOQ-meta. </p><br><p>  Dari hasil pertanyaan seperti itu relatif mudah untuk membuat representasi klien dari model database, terlepas dari teknologi akses data mana yang digunakan. </p><br><ul><li>  Jika Anda menggunakan JDBC atau Spring, Anda bisa membuat grup konstanta String </li><li>  Jika menggunakan JPA, Anda dapat membuat objek sendiri </li><li>  Jika menggunakan jOOQ, Anda dapat membuat metamodel jOOQ </li></ul><br><p>  Bergantung pada jumlah fitur yang ditawarkan data akses API Anda (jOOQ, JPA, atau yang lainnya), metamodel yang dihasilkan dapat benar-benar kaya dan lengkap.  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi gabungan implisit di jOOQ 3.11, yang bergantung pada meta-informasi tentang hubungan kunci asing antara tabel Anda</a> . </p><br><p>  Sekarang, setiap perubahan pada skema database akan secara otomatis mengarah pada pembaruan kode klien. </p><br><p>  Bayangkan Anda perlu mengganti nama kolom dalam tabel: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> book_title;</code> </pre> <br><p>  Anda yakin ingin melakukan pekerjaan ini dua kali?  Tidak mungkin.  Cukup komit DDL ini, jalankan build dan nikmati objek yang diperbarui: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"book"</span></span>, indexes = { <span class="hljs-comment"><span class="hljs-comment">// Would you have thought of this? @Index(name = "i_book_title", columnList = "book_title") }) class Book { @Id @GeneratedValue(strategy = IDENTITY) int id; @Column("book_title") String **bookTitle**; }</span></span></code> </pre> <br><p>  Juga, klien yang diterima tidak perlu dikompilasi setiap waktu (setidaknya sampai perubahan berikutnya dalam skema database), yang sudah bisa menjadi nilai tambah yang besar! <br>  Sebagian besar perubahan DDL juga merupakan perubahan semantik, bukan hanya yang sintaksis.  Dengan demikian, sangat bagus untuk melihat dalam kode klien yang dihasilkan apa sebenarnya perubahan terbaru dalam database yang terpengaruh. </p><br><h2 id="pravda-vsegda-odna">  Yang benar selalu sendiri </h2><br><p>  Tidak peduli teknologi apa yang Anda gunakan, harus selalu ada hanya satu model, yang merupakan standar untuk subsistem.  Atau, setidaknya, kita harus berusaha untuk ini dan menghindari kebingungan dalam bisnis, di mana "standar" ada di mana-mana dan di mana pun pada saat yang bersamaan.  Itu membuat semuanya jauh lebih mudah.  Misalnya, jika Anda berbagi file XML dengan beberapa sistem lain, Anda mungkin menggunakan XSD.  Sebagai metamodel INFORMATION_SCHEMA jOOQ dalam format XML: <a href="">https://www.jooq.org/xsd/jooq-meta-3.10.0.xsd</a> </p><br><ul><li>  XSD dipahami dengan baik </li><li>  XSD dengan sempurna menggambarkan konten XML dan memungkinkan validasi dalam semua bahasa klien </li><li>  XSD membuat versi mudah dan terbelakang kompatibel </li><li>  XSD dapat diubah menjadi kode Java menggunakan XJC </li></ul><br><p>  Kami memberikan perhatian khusus pada poin terakhir.  Saat berkomunikasi dengan sistem eksternal melalui pesan XML, kita harus yakin akan validitas pesan.  Dan itu sangat mudah dilakukan dengan hal-hal seperti JAXB, XJC, dan XSD.  Akan gila untuk berpikir tentang kesesuaian pendekatan Java-pertama dalam kasus ini.  XML yang dihasilkan berdasarkan objek XML akan berkualitas buruk, akan didokumentasikan dengan buruk dan sulit untuk diperluas.  Dan jika ada SLA untuk interaksi seperti itu, maka Anda akan kecewa. </p><br><p>  Jujur, ini mirip dengan apa yang terjadi dengan berbagai API JSON sekarang, tetapi ini adalah cerita yang sama sekali berbeda ... </p><br><h3 id="chem-bazy-dannyh-huzhe">  Apa yang membuat basis data lebih buruk? </h3><br><p>  Ketika bekerja dengan database, semuanya sama di sini.  Database memiliki data, dan itu juga harus menjadi master dari skema data.  Semua modifikasi skema harus dilakukan secara langsung melalui DDL untuk memperbarui referensi. </p><br><p>  Setelah memperbarui referensi, semua pelanggan harus memperbarui ide mereka tentang model.  Beberapa klien dapat ditulis dalam Java menggunakan jOOQ dan / atau Hibernate atau JDBC.  Klien lain dapat ditulis dalam Perl (semoga sukses untuk mereka) atau bahkan dalam C #.  Itu tidak masalah.  Model utama ada di database.  Sementara model yang dibuat menggunakan ORM berkualitas buruk, tidak terdokumentasi dengan baik dan sulit diperluas. </p><br><p>  Karena itu, jangan lakukan ini, dan sejak awal pengembangan.  Sebaliknya, mulailah dengan basis data.  Buat pipa CI / CD otomatis.  Gunakan pembuatan kode di dalamnya untuk secara otomatis menghasilkan model database untuk klien untuk setiap build.  Dan berhenti khawatir, semuanya akan baik-baik saja.  Yang diperlukan hanyalah sedikit usaha awal untuk menyiapkan infrastruktur, tetapi sebagai hasilnya Anda akan mendapatkan keuntungan dalam proses pengembangan untuk sisa proyek Anda di tahun-tahun mendatang. </p><br><p>  Tidak terima kasih </p><br><h2 id="poyasneniya">  Penjelasan </h2><br><p>  Untuk mengkonsolidasikan: artikel ini sama sekali tidak mengklaim bahwa model database harus berlaku untuk seluruh sistem Anda (area subjek, logika bisnis, dll.).  Pernyataan saya hanya terdiri atas fakta bahwa kode klien yang berinteraksi dengan basis data harus hanya merupakan <em>representasi</em> dari skema basis data, tetapi tidak mendefinisikan dan membentuknya dengan cara apa pun. </p><br><p>  Dalam arsitektur dua tingkat yang masih memiliki tempat untuk dituju, skema basis data mungkin merupakan satu-satunya sumber informasi tentang model sistem Anda.  Namun, pada kebanyakan sistem, saya melihat tingkat akses data sebagai "subsistem" yang merangkum model database.  Sesuatu seperti itu. </p><br><h2 id="isklyucheniya">  Pengecualian </h2><br><p>  Seperti dalam aturan lain yang baik, aturan kami juga memiliki pengecualian (dan saya sudah memperingatkan bahwa pendekatan basis data pertama dan pembuatan kode tidak selalu merupakan pilihan yang tepat).  Pengecualian ini (mungkin daftar tidak lengkap): </p><br><ul><li>  Ketika sirkuit tidak diketahui sebelumnya dan perlu diselidiki.  Misalnya, Anda adalah penyedia alat untuk membantu pengguna menavigasi skema apa pun.  Tentu saja, tidak ada pembuatan kode.  Tetapi bagaimanapun juga, Anda harus berurusan dengan database itu sendiri dan skemanya. </li><li>  Ketika untuk beberapa tugas Anda perlu membuat skema dengan cepat.  Ini mungkin mirip dengan salah satu variasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola nilai atribut-Entitas</a> , seperti  Anda tidak memiliki pola yang jelas.  Serta tidak ada kepastian bahwa RDBMS dalam hal ini adalah pilihan yang tepat. </li></ul><br><p>  Keunikan dari pengecualian ini adalah bahwa mereka jarang bertemu di alam liar.  Dalam kebanyakan kasus, ketika menggunakan basis data relasional, skema diketahui sebelumnya dan merupakan "standar" dari model Anda, dan klien harus bekerja dengan salinan model ini yang dihasilkan menggunakan generator kode. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413597/">https://habr.com/ru/post/id413597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413585/index.html">Kolaborasi Hansen: baik atau tidak sama sekali (bagian 2)</a></li>
<li><a href="../id413587/index.html">Menilai cakupan uji proyek Java menggunakan Apache Ignite sebagai contoh</a></li>
<li><a href="../id413589/index.html">Ulasan Kode: Pengalaman Sukses</a></li>
<li><a href="../id413591/index.html">Robotika Industri - 57 tahun! Ingat dari mana datangnya hitungan</a></li>
<li><a href="../id413593/index.html">Terus menaklukkan dasar laut. Microsoft dan proyek pusat data subsea Natick 2-nya</a></li>
<li><a href="../id413599/index.html">Ada S.L.O.N.a di beberapa bagian. Memperkenalkan ITAM dan tidak tersedak</a></li>
<li><a href="../id413601/index.html">Apakah pusat data Microsoft memanaskan laut di sekitar</a></li>
<li><a href="../id413603/index.html">Pembuatan Kode di Uber</a></li>
<li><a href="../id413605/index.html">Tanya Ethan: Apa yang terjadi ketika sebuah bintang melewati tata surya?</a></li>
<li><a href="../id413607/index.html">Intisari Fintech: mata uang digital tidak mengancam sistem keuangan Federasi Rusia; PayPal menemukan berapa banyak pengeluaran gamer untuk permainan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>