<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüç≥ üßîüèæ üë©üèº‚Äçüíª Introdu√ß√£o aos ELFs do Linux: Entendendo e Analisando üïµüèæ üôÖüèΩ üë©‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° coisas no mundo que tomamos como garantidas, embora sejam verdadeiras obras-primas. Uma dessas coisas s√£o os utilit√°rios Linux, como ls e ps. Embor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o aos ELFs do Linux: Entendendo e Analisando</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480642/"> H√° coisas no mundo que tomamos como garantidas, embora sejam verdadeiras obras-primas.  Uma dessas coisas s√£o os utilit√°rios Linux, como ls e ps.  Embora eles geralmente sejam percebidos como simples, isso est√° longe de ser o caso, se olharmos para dentro.  E o mesmo acontece com ELF, execut√°vel e formato vincul√°vel.  Um formato de arquivo usado universalmente, mas poucos o entendem.  Este guia r√°pido ajudar√° voc√™ a entender. <br><br><img src="https://habrastorage.org/webt/ka/0m/em/ka0memy9zppvjiut58hua0_cyt8.jpeg"><br><br>  Depois de ler este guia, voc√™ aprender√°: <br><br><ul><li>  Por que o formato ELF √© necess√°rio e para quais tipos de arquivos √© usado </li><li>  Estrutura do arquivo ELF e detalhes do formato </li><li>  Como ler e analisar o conte√∫do bin√°rio de um arquivo ELF </li><li>  Quais ferramentas s√£o usadas para analisar arquivos bin√°rios? </li></ul><a name="habracut"></a><br><h2>  O que √© um arquivo ELF? </h2><br>  ELF significa Executable and Linkable Format e define a estrutura de arquivos bin√°rios, bibliotecas e arquivos principais.  A especifica√ß√£o de formato permite que o sistema operacional interprete corretamente as instru√ß√µes da m√°quina contidas no arquivo.  Um arquivo ELF √© geralmente o arquivo de sa√≠da de um compilador ou vinculador e tem um formato bin√°rio.  Utilizando ferramentas adequadas, pode ser analisado e estudado. <br><br><h3>  Por que estudar a ELF em detalhes? </h3><br>  Antes de mergulhar nos detalhes t√©cnicos, n√£o ser√° errado explicar por que entender o formato ELF √© √∫til.  Primeiro, ele permite que voc√™ estude a opera√ß√£o interna do sistema operacional.  Quando algo deu errado, esse conhecimento o ajudar√° a entender melhor o que exatamente aconteceu e por que motivo.  Al√©m disso, a capacidade de examinar arquivos ELF pode ser valiosa para encontrar falhas de seguran√ßa e detectar arquivos suspeitos.  E, finalmente, para uma melhor compreens√£o do processo de desenvolvimento.  Mesmo se voc√™ programar em um idioma de alto n√≠vel como o Go, ainda saber√° melhor o que est√° acontecendo nos bastidores. <br><br>  Ent√£o, por que estudar ELF? <br><br><ul><li>  Para uma compreens√£o geral do sistema operacional </li><li>  Para desenvolvimento de software </li><li>  Forense digital e resposta a incidentes (DFIR) </li><li>  Pesquisa de malware (an√°lise bin√°ria) </li></ul><br><h3>  Da origem ao processo </h3><br>  Qualquer que seja o sistema operacional que usamos, √© necess√°rio traduzir de alguma forma as fun√ß√µes do c√≥digo fonte no idioma da CPU - c√≥digo da m√°quina.  As fun√ß√µes podem ser as mais b√°sicas, por exemplo, abrir um arquivo no disco ou exibir algo na tela.  Em vez de usar a linguagem da CPU diretamente, usamos uma linguagem de programa√ß√£o que possui recursos padr√£o.  O compilador ent√£o traduz essas fun√ß√µes em c√≥digo de objeto.  Esse c√≥digo de objeto √© ent√£o vinculado ao programa completo, usando o vinculador.  O resultado √© um arquivo bin√°rio que pode ser executado em uma plataforma espec√≠fica e tipo espec√≠fico de CPU. <br><br><h3>  Antes de come√ßar </h3><br>  Este post cont√©m muitas equipes.  √â melhor execut√°-los em uma m√°quina de teste.  Copie os bin√°rios existentes antes de executar esses comandos neles.  Tamb√©m escreveremos um pequeno programa C que voc√™ pode compilar.  Por fim, a pr√°tica √© a melhor maneira de aprender alguma coisa. <br><br><h2>  Anatomia de um arquivo ELF </h2><br>  Um equ√≠voco comum √© que os arquivos ELF s√£o apenas para arquivos bin√°rios ou execut√°veis.  J√° dissemos que eles podem ser usados ‚Äã‚Äãpara partes de arquivos execut√°veis ‚Äã‚Äã(c√≥digo de objeto).  Outro exemplo s√£o os arquivos de biblioteca e dumps principais (arquivos principais e arquivos a.out).  A especifica√ß√£o ELF tamb√©m √© usada no Linux para kernel e m√≥dulos de kernel. <br><br><img src="https://habrastorage.org/webt/dt/5y/vq/dt5yvqm-oju3s6todxbbd6ivzw0.png"><br><br><h3>  Estrutura </h3><br>  Devido √† extensibilidade dos arquivos ELF, a estrutura pode variar para arquivos diferentes.  O arquivo ELF consiste em: <br><br><ol><li>  Cabe√ßalho ELF </li><li>  dados </li></ol><br>  Com o comando readelf, podemos olhar para a estrutura do arquivo, e ser√° algo parecido com isto: <br><br><img src="https://habrastorage.org/webt/vo/ng/w-/vongw-d8cy_mvkf9jgcizbdpq0c.png"><br><br><h3>  Cabe√ßalho ELF </h3><br>  Como voc√™ pode ver na captura de tela, o cabe√ßalho ELF come√ßa com um "n√∫mero m√°gico".  Este "n√∫mero m√°gico" fornece informa√ß√µes sobre o arquivo.  Os primeiros 4 bytes determinam que este √© um arquivo ELF (45 = E, 4c = L, 46 = F, eles s√£o precedidos por 7f). <br><br>  O cabe√ßalho ELF √© obrigat√≥rio.  √â necess√°rio para que os dados sejam corretamente interpretados durante a vincula√ß√£o e execu√ß√£o.  Para uma melhor compreens√£o da opera√ß√£o interna de um arquivo ELF, √© √∫til saber para que essas informa√ß√µes s√£o usadas. <br><br><h3>  Class </h3><br>  Depois de declarar um tipo ELF, um campo de classe segue.  Este valor significa a arquitetura para a qual o arquivo √© destinado.  Pode ser 01 (arquitetura de 32 bits) ou 02 (64 bits).  Aqui vemos 02, que √© traduzido pelo comando readelf como um arquivo ELF64, ou seja, esse arquivo usa uma arquitetura de 64 bits.  Isso n√£o √© surpreendente, um processador moderno est√° instalado no meu carro. <br><br><h3>  Dados </h3><br>  A seguir, vem o campo "data", que tem duas op√ß√µes: 01 - LSB (bit menos significativo), tamb√©m conhecido como little-endian, ou 02 - MSB (bit mais significativo, big-endian).  Esses valores ajudam a interpretar o restante dos objetos no arquivo.  Isso √© importante porque diferentes tipos de processadores lidam com estruturas de dados de maneira diferente.  No nosso caso, o LSB √© usado, uma vez que o processador possui uma arquitetura AMD64. <br><br>  O efeito LSB fica vis√≠vel ao usar o utilit√°rio hexdump em um arquivo bin√°rio.  Vamos ver o cabe√ßalho ELF para / bin / ps. <br><br><pre><code class="bash hljs">$ hexdump -n 16 /bin/ps 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010</code> </pre> <br>  Vemos que os pares de valores s√£o diferentes, devido √† interpreta√ß√£o da ordem dos dados. <br><br><h3>  Vers√£o </h3><br>  Em seguida, segue outro valor m√°gico "01", que √© o n√∫mero da vers√£o.  Somente a vers√£o 01 est√° dispon√≠vel no momento, portanto esse n√∫mero n√£o significa nada de interessante. <br><br><h3>  OS / ABI </h3><br>  Cada sistema operacional tem sua pr√≥pria maneira de chamar fun√ß√µes, eles t√™m muito em comum, mas, al√©m disso, cada sistema tem pequenas diferen√ßas.  A ordem da chamada de fun√ß√£o √© determinada pela ABI (Application Binary Interface).  Os campos OS / ABI descrevem qual ABI √© usado e sua vers√£o.  No nosso caso, o valor √© 00, o que significa que extens√µes espec√≠ficas n√£o s√£o usadas.  Na sa√≠da, isso √© mostrado como Sistema V. <br><br><h3>  Vers√£o ABI </h3><br>  Se necess√°rio, uma vers√£o ABI pode ser indicada. <br><br><h3>  Carro </h3><br>  O t√≠tulo tamb√©m indica o tipo de m√°quina esperado (AMD64). <br><br><h3>  Tipo </h3><br>  O campo type indica para que serve o arquivo.  Aqui est√£o alguns tipos de arquivos comuns. <br><br>  N√öCLEO (valor 4) <br>  DYN (arquivo de objeto compartilhado), biblioteca (valor 3) <br>  EXEC (arquivo execut√°vel), arquivo execut√°vel (valor 2) <br>  REL (arquivo realoc√°vel), arquivo antes da vincula√ß√£o (valor 1) <br><br><h3>  Veja o t√≠tulo completo </h3><br>  Embora alguns campos possam ser visualizados por si mesmo, na verdade existem mais.  Por exemplo, voc√™ pode descobrir para qual processador o arquivo se destina.  Use hexdump para ver o cabe√ßalho ELF completo e todos os valores. <br><br><pre> <code class="bash hljs">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 02 00 3e 00 01 00 00 00 a8 2b 40 00 00 00 00 00 |..&gt;......+@.....| 40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00 |@.......0e......| 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|</code> </pre> <br>  (sa√≠da hexdump -C -n 64 / bin / ps) <br><br>  O campo destacado determina o tipo de m√°quina.  O valor 3e √© decimal 62, que corresponde ao AMD64.  Para ter uma id√©ia de todos os tipos de arquivo, consulte <a href="" rel="nofollow">este</a> arquivo de cabe√ßalho. <br><br>  Embora voc√™ possa fazer tudo isso em um dump hexadecimal, faz sentido usar uma ferramenta que fa√ßa o trabalho para voc√™.  O utilit√°rio dumpelf pode ser √∫til.  Ele mostra a sa√≠da formatada correspondente ao cabe√ßalho ELF.  Ser√° bom estudar quais campos s√£o usados ‚Äã‚Äãe quais s√£o seus valores t√≠picos. <br><br>  Agora, onde explicamos o significado desses campos, √© hora de olhar para o que h√° por tr√°s da m√°gica real e passar para os pr√≥ximos t√≠tulos! <br><br><h3>  Dados do arquivo </h3><br>  Al√©m do cabe√ßalho, os arquivos ELF consistem em tr√™s partes. <br><br><ul><li>  Cabe√ßalhos ou segmentos de programa </li><li>  Se√ß√£o ou t√≠tulos de se√ß√£o </li><li>  Dados </li></ul><br>  Antes de mergulharmos nesses cabe√ßalhos, seria √∫til saber que o arquivo ELF possui dois "tipos" diferentes.  Um deles √© projetado para o vinculador e permite a execu√ß√£o de c√≥digo (segmentos).  O outro √© para comandos e dados (se√ß√µes).  Dependendo da finalidade, o tipo de cabe√ßalho apropriado √© usado.  Vamos come√ßar com o cabe√ßalho do programa, localizado nos arquivos execut√°veis ‚Äã‚Äãdo ELF. <br><br><h3>  T√≠tulos do programa </h3><br>  Um arquivo ELF consiste em zero ou mais segmentos e descreve como criar um processo, uma imagem de mem√≥ria para execu√ß√£o em tempo de execu√ß√£o.  Quando o kernel v√™ esses segmentos, os coloca no espa√ßo de endere√ßo virtual usando a chamada de sistema mmap (2).  Em outras palavras, converte instru√ß√µes pr√©-preparadas em uma imagem na mem√≥ria.  Se o arquivo ELF for um bin√°rio regular, ele requer esses cabe√ßalhos de programa, caso contr√°rio, simplesmente n√£o funcionar√°.  Esses cabe√ßalhos s√£o usados, juntamente com as estruturas de dados correspondentes, para formar o processo.  Para bibliotecas compartilhadas, o processo √© semelhante. <br><br><img src="https://habrastorage.org/webt/p4/ja/c_/p4jac_lojwvn9movhy8w5rad1g0.png"><br>  Cabe√ßalho do programa no arquivo ELF bin√°rio <br><br>  Vemos 9 t√≠tulos de programas neste exemplo.  No come√ßo, √© dif√≠cil entender o que eles significam.  Vamos mergulhar nos detalhes. <br><br><h3>  GNU_EH_FRAME </h3><br>  Essa √© a fila classificada usada pelo compilador GCC.  Ele armazena manipuladores de exce√ß√£o.  Se algo der errado, eles s√£o usados ‚Äã‚Äãpara lidar corretamente com a situa√ß√£o. <br><br><h3>  GNU_STACK </h3><br>  Este cabe√ßalho √© usado para salvar as informa√ß√µes da pilha.  Um recurso interessante √© que a pilha n√£o precisa ser execut√°vel, pois isso pode acarretar vulnerabilidades de seguran√ßa. <br><br>  Se o segmento GNU_STACK estiver ausente, a pilha execut√°vel ser√° usada.  Os utilit√°rios scanelf e execstack mostram os detalhes do dispositivo de pilha. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># scanelf -e /bin/ps TYPE STK/REL/PTL FILE ET_EXEC RW- R-- RW- /bin/ps # execstack -q /bin/ps - /bin/ps</span></span></code> </pre> <br>  Comandos para visualizar o cabe√ßalho do programa: <br><br><ul><li>  dumpelf (pax-utils) </li><li>  elfls -S / bin / ps </li><li>  eu-readelf - cabe√ßalhos de programa / bin / ps </li></ul><br><h3>  Se√ß√µes ELF </h3><br><h4>  Cabe√ßalhos de Se√ß√£o </h4><br>  Cabe√ßalhos de se√ß√£o definem todas as se√ß√µes de um arquivo.  Como j√° mencionado, essas informa√ß√µes s√£o usadas para vincula√ß√£o e realoca√ß√£o. <br><br>  As se√ß√µes s√£o exibidas em um arquivo ELF ap√≥s o compilador GNU C converter o c√≥digo C em assembler, e o assembler GNU cria objetos. <br><br>  Conforme mostrado na figura acima, um segmento pode ter 0 ou mais se√ß√µes.  Existem quatro se√ß√µes principais para arquivos execut√°veis: .text, .data, .rodata e .bss.  Cada uma dessas se√ß√µes √© inicializada com permiss√µes diferentes, que podem ser visualizadas com readelf -S. <br><br><h4>  .text </h4><br>  Cont√©m c√≥digo execut√°vel.  Ele ser√° empacotado em um segmento com direitos de leitura e execu√ß√£o.  √â baixado uma vez e seu conte√∫do n√£o muda.  Isso pode ser visto com o utilit√°rio objdump. <br><br><pre> <code class="bash hljs">12 .text 0000a3e9 0000000000402120 0000000000402120 00002120 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE</code> </pre> <br><h4>  .data </h4><br>  Dados inicializados com permiss√µes de leitura e grava√ß√£o. <br><br><h4>  .rodata </h4><br>  Dados inicializados com permiss√µes somente leitura.  (= A). <br><br><h4>  .bss </h4><br>  Dados n√£o inicializados com permiss√µes de leitura / grava√ß√£o.  (= WA) <br><br><pre> <code class="bash hljs">[24] .data PROGBITS 00000000006172e0 000172e0 0000000000000100 0000000000000000 WA 0 0 8 [25] .bss NOBITS 00000000006173e0 000173e0 0000000000021110 0000000000000000 WA 0 0 32</code> </pre> <br><br>  Comandos para visualizar se√ß√µes e t√≠tulos. <br><br><ul><li>  despejar </li><li>  elfls -p / bin / ps </li><li>  eu-readelf - cabe√ßalhos de se√ß√£o / bin / ps </li><li>  readelf -S / bin / ps </li><li>  objdump -h / bin / ps </li></ul><br><h4>  Grupos de Se√ß√£o </h4><br>  Algumas se√ß√µes podem ser agrupadas como se elas formassem um √∫nico todo.  Novos vinculadores suportam essa funcionalidade.  Mas enquanto isso n√£o √© comum. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># readelf -g /bin/ps There are no section groups in this file.</span></span></code> </pre> <br>  Embora isso possa n√£o parecer muito interessante, o conhecimento das ferramentas de an√°lise de arquivo ELF oferece grandes benef√≠cios.  Por esse motivo, √© apresentada uma vis√£o geral dessas ferramentas e seus objetivos no final do artigo. <br><br><h3>  Bin√°rios est√°ticos e din√¢micos </h3><br>  Ao lidar com bin√°rios ELF, ser√° √∫til saber como esses dois tipos de arquivos est√£o vinculados.  Eles podem ser est√°ticos e din√¢micos, e isso se aplica √†s bibliotecas que eles usam.  Se o bin√°rio for "din√¢mico", significa que ele usa bibliotecas externas que cont√™m algumas fun√ß√µes comuns, como abrir um arquivo ou criar um soquete de rede.  Os bin√°rios est√°ticos, por outro lado, incluem todas as bibliotecas necess√°rias. <br><br>  Se voc√™ deseja verificar se o arquivo √© est√°tico ou din√¢mico, use o comando file.  Ela mostrar√° algo assim: <br><br><pre> <code class="bash hljs">$ file /bin/ps /bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;b&gt;dynamically linked (uses shared libs)&lt;/b&gt;, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped</code> </pre> <br>  Para determinar quais bibliotecas externas s√£o usadas, basta usar ldd no mesmo bin√°rio: <br><br><pre> <code class="bash hljs">$ ldd /bin/ps linux-vdso.so.1 =&gt; (0x00007ffe5ef0d000) libprocps.so.3 =&gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000) /lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)</code> </pre> <br>  Dica: Para ver mais depend√™ncias, √© melhor usar o utilit√°rio lddtree. <br><br><h2>  Ferramentas de an√°lise bin√°ria </h2><br>  Se voc√™ deseja analisar arquivos ELF, definitivamente ser√° √∫til examinar primeiro as ferramentas existentes.  Existem kits de ferramentas para o desenvolvimento reverso de bin√°rios e c√≥digo execut√°vel.  Se voc√™ √© novo na an√°lise de arquivos ELF, comece com a an√°lise est√°tica.  A an√°lise est√°tica implica que examinemos os arquivos sem inici√°-los.  Quando voc√™ come√ßar a entender melhor o trabalho deles, passe para a an√°lise din√¢mica.  Execute os exemplos e observe o comportamento real deles. <br><br><h3>  Ferramentas populares </h3><br><h4>  Radare2 </h4><br>  O kit de ferramentas Radare2 foi criado por Sergi Alvarez.  O n√∫mero 2 implica que o c√≥digo foi completamente reescrito em compara√ß√£o com a primeira vers√£o.  Agora, √© usado por muitos pesquisadores para estudar a opera√ß√£o do c√≥digo. <br><br><h4>  Pacotes de software </h4><br>  A maioria dos sistemas Linux possui binutils instalados.  Outros pacotes podem ajud√°-lo a ver mais informa√ß√µes.  O kit de ferramentas correto simplificar√° seu trabalho, especialmente se voc√™ estiver analisando arquivos ELF.  Eu compilei aqui uma lista de pacotes e utilit√°rios para analisar arquivos ELF. <br><br>  <b>elfutils</b> <br>  / usr / bin / eu-addr2line <br>  / usr / bin / eu-ar - uma alternativa ao ar, para criar e processar arquivos compactados <br>  / usr / bin / eu-elfcmp <br>  / usr / bin / eu-elflint - verifique a conformidade com as especifica√ß√µes gABI e psABI <br>  / usr / bin / eu-findtextrel - pesquisa por realoca√ß√µes de texto <br>  / usr / bin / eu-ld - combina arquivos de objetos e archive <br>  / usr / bin / eu-make-debug-archive <br>  / usr / bin / eu-nm - mostra os s√≠mbolos do objeto e dos arquivos execut√°veis <br>  / usr / bin / eu-objdump - mostra informa√ß√µes do arquivo de objeto <br>  / usr / bin / eu-ranlib - cria um √≠ndice de arquivos compactados <br>  / usr / bin / eu-readelf - mostra o arquivo ELF em formato leg√≠vel <br>  / usr / bin / eu-size - mostra o tamanho de cada se√ß√£o (texto, dados, bss, etc) <br>  / usr / bin / eu-stack - mostra a pilha do processo atual ou despejo do kernel <br>  / usr / bin / eu-strings - mostra as strings de texto (como o utilit√°rio strings) <br>  / usr / bin / eu-strip - remove a tabela de caracteres do arquivo ELF <br>  / usr / bin / eu-unstrip - adiciona s√≠mbolos e informa√ß√µes de depura√ß√£o ao bin√°rio <br>  Nota: o pacote elfutils ser√° um bom come√ßo, cont√©m a maioria das ferramentas de an√°lise <br><br>  <b>elfkickers</b> <br>  / usr / bin / ebfc - Compilador de idiomas do Brainfuck <br>  / usr / bin / elfls - mostra cabe√ßalhos de programas e cabe√ßalhos de se√ß√£o com sinalizadores <br>  / usr / bin / elftoc - converte um bin√°rio em um programa C <br>  / usr / bin / infect - um utilit√°rio que injeta um conta-gotas cria um arquivo setuid em / tmp <br>  / usr / bin / objres - cria um objeto a partir de dados regulares ou bin√°rios <br>  / usr / bin / rebind - altera a liga√ß√£o e a visibilidade dos caracteres nos arquivos ELF <br>  / usr / bin / sstrip - remove componentes desnecess√°rios de um arquivo ELF <br>  Nota: o autor do pacote ELFKickers se concentra na manipula√ß√£o de arquivos ELF, o que permite obter mais informa√ß√µes ao trabalhar com os bin√°rios ELF "errados" <br><br>  <b>pax-utils</b> <br>  / usr / bin / dumpelf - despejo da estrutura ELF interna <br>  / usr / bin / lddtree - como o ldd, com a configura√ß√£o do n√≠vel de depend√™ncias exibido <br>  / usr / bin / pspax - exibe informa√ß√µes de ELF / PaX sobre processos em execu√ß√£o <br>  / usr / bin / scanelf - uma ampla variedade de informa√ß√µes, incluindo detalhes de PaX <br>  / usr / bin / scanmacho - mostra detalhes dos bin√°rios Mach-O (Mac OS X) <br>  / usr / bin / symtree - mostra os caracteres da √°rvore <br>  Nota: alguns utilit√°rios deste pacote podem varrer recursivamente os diret√≥rios e s√£o ideais para analisar todo o conte√∫do de um diret√≥rio.  O foco est√° nas ferramentas de pesquisa PaX.  Al√©m de oferecer suporte ao ELF, voc√™ pode extrair informa√ß√µes dos bin√°rios Mach-O. <br><br>  Exemplo de sa√≠da <br><pre> <code class="bash hljs">scanelf -a /bin/ps TYPE PAX PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE ET_EXEC PeMRxS 0755 LE RW- R-- RW- - - LAZY /bin/ps</code> </pre> <br><br>  <b>pr√©-liga√ß√£o</b> <br>  / usr / bin / execstack - voc√™ pode exibir ou alterar informa√ß√µes sobre se a pilha √© execut√°vel <br>  / usr / bin / prelink - realoca chamadas em arquivos ELF para acelerar o processo <br><br><h2>  Perguntas frequentes </h2><br><h3>  O que √© uma ABI? </h3><br>  ABI √© a Interface Bin√°ria do Aplicativo e define uma interface de baixo n√≠vel entre o sistema operacional e o c√≥digo execut√°vel. <br><br><h3>  O que √© ELF? </h3><br>  ELF √© um formato execut√°vel e vincul√°vel.  Essa √© uma especifica√ß√£o de formato que define como as instru√ß√µes s√£o escritas no c√≥digo execut√°vel. <br><br><h3>  Como posso ver o tipo de arquivo? </h3><br>  Use o comando file para o primeiro est√°gio da an√°lise.  Este comando √© capaz de mostrar os detalhes extra√≠dos dos n√∫meros e t√≠tulos "m√°gicos". <br><br><h2>  Conclus√£o </h2><br>  Os arquivos ELF s√£o para execu√ß√£o e vincula√ß√£o.  Dependendo da finalidade, eles cont√™m os segmentos e se√ß√µes necess√°rios.  O kernel do sistema operacional varre os segmentos e os mapeia na mem√≥ria (usando o mmap).  As se√ß√µes s√£o exibidas por um vinculador que cria um arquivo execut√°vel ou objeto compartilhado. <br><br>  Os arquivos ELF s√£o muito flex√≠veis e suportam v√°rios tipos de CPUs, arquiteturas de m√°quinas e sistemas operacionais.  Tamb√©m √© extens√≠vel, cada arquivo √© projetado de maneira diferente, dependendo das pe√ßas necess√°rias.  Usando as ferramentas certas, voc√™ pode descobrir a finalidade do arquivo e examinar o conte√∫do dos arquivos bin√°rios.  Voc√™ pode visualizar as fun√ß√µes e linhas contidas no arquivo.  Um bom come√ßo para quem pesquisa malware ou para entender por que o processo se comporta (ou n√£o) de uma certa maneira. <br><br><h2>  Recursos para estudos adicionais </h2><br>  Se voc√™ quiser saber mais sobre ELF e engenharia reversa, poder√° ver o trabalho que fazemos no Linux Security Expert.  Como parte do curr√≠culo, temos <a href="https://linuxsecurity.expert/training/domains/reverse-engineering" rel="nofollow">um m√≥dulo de engenharia reversa</a> com trabalho pr√°tico em laborat√≥rio. <br><br>  Para aqueles que gostam de ler, um documento bom e profundo: o <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" rel="nofollow">formato ELF</a> e um <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">artigo de autoria de</a> Brian Raiter, tamb√©m conhecido como ELFkickers.  Para quem gosta de entender a fonte, veja o <a href="" rel="nofollow">cabe√ßalho ELF documentado</a> da Apple. <br><br>  Dica: <br>  Se voc√™ deseja melhorar a an√°lise de arquivos, comece a usar as <a href="https://linuxsecurity.expert/security-tools/binary-analysis-tools" rel="nofollow">populares ferramentas de an√°lise</a> atualmente dispon√≠veis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480642/">https://habr.com/ru/post/pt480642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480614/index.html">ENUM r√°pido</a></li>
<li><a href="../pt480618/index.html">Jogo eletr√¥nico Tic Tac Toe. O que eu vim para</a></li>
<li><a href="../pt480620/index.html">SD-WAN e DNA para ajudar o administrador: recursos de arquitetura e pr√°tica</a></li>
<li><a href="../pt480622/index.html">Como usar a capacidade de armazenamento dispon√≠vel corretamente</a></li>
<li><a href="../pt480626/index.html">Heran√ßa de sistemas e processos legados ou Os primeiros 90 dias no papel de CTO</a></li>
<li><a href="../pt480644/index.html">O manifesto sobre a aboli√ß√£o de 146 do C√≥digo Penal e o boicote ao Sberbank e aos detentores de direitos autorais-parasitas. Para c√≥digo-fonte aberto e nginx</a></li>
<li><a href="../pt480646/index.html">Habr - melhores artigos, autores e estat√≠sticas 2019</a></li>
<li><a href="../pt480650/index.html">Cujo cabelo √© mais forte: morfologia capilar</a></li>
<li><a href="../pt480652/index.html">C√¢mera PoE de 250 metros por fio - √© poss√≠vel</a></li>
<li><a href="../pt480654/index.html">Ser√° que Julia venceu o Python assim como o Python fez o Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>