<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶 👉 🤥 Panduan Pandas untuk Analisis Data Besar 🖨️ 🤛 🤳🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat menggunakan panda library untuk menganalisis dataset kecil, yang ukurannya tidak melebihi 100 megabyte, kinerja jarang menjadi masalah. Tetapi ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Pandas untuk Analisis Data Besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Saat menggunakan panda library untuk menganalisis dataset kecil, yang ukurannya tidak melebihi 100 megabyte, kinerja jarang menjadi masalah.  Tetapi ketika datang ke studi set data, ukuran yang dapat mencapai beberapa gigabytes, masalah kinerja dapat menyebabkan peningkatan yang signifikan dalam durasi analisis data dan bahkan dapat menyebabkan ketidakmampuan untuk melakukan analisis karena kurangnya memori. <br><br>  Sementara alat-alat seperti Spark dapat secara efisien memproses set data besar (dari ratusan gigabyte hingga beberapa terabyte), untuk memanfaatkan sepenuhnya kemampuan mereka, Anda biasanya memerlukan perangkat keras yang cukup kuat dan mahal.  Dan, dibandingkan dengan panda, panda tidak berbeda dalam set alat yang kaya untuk pembersihan, penelitian, dan analisis data berkualitas tinggi.  Untuk kumpulan data berukuran sedang, yang terbaik adalah mencoba menggunakan panda lebih efisien, daripada beralih ke alat lain. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  Dalam materi yang kami terjemahkan hari ini, kami akan berbicara tentang fitur-fitur bekerja dengan memori saat menggunakan panda, dan bagaimana cara mengurangi konsumsi memori hingga hampir 90% dengan hanya memilih tipe data yang sesuai yang disimpan dalam kolom struktur data tabel pada <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bekerja dengan data pada pertandingan baseball</font> </h2><br>  Kami akan bekerja dengan data pada pertandingan bisbol Liga Utama yang dikumpulkan selama 130 tahun dan diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Retrosheet</a> . <br><br>  Awalnya, data ini disajikan sebagai 127 file CSV, tetapi kami menggabungkannya ke dalam satu set data menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">csvkit</a> dan menambahkan, sebagai baris pertama dari tabel yang dihasilkan, baris dengan nama kolom.  Jika mau, Anda dapat mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi</a> data kami dan bereksperimen dengannya, membaca artikel. <br><br>  Mari kita mulai dengan mengimpor dataset dan melihat lima baris pertamanya.  Anda dapat menemukannya di tabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , pada <code>   </code> lembar <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  Di bawah ini adalah informasi tentang kolom paling penting dari tabel dengan data ini.  Jika Anda ingin membaca penjelasan untuk semua kolom, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> Anda dapat menemukan kamus data untuk seluruh kumpulan data. <br><br><ul><li>  <code>date</code> - Tanggal permainan. </li><li>  <code>v_name</code> - Nama tim tamu. </li><li>  <code>v_league</code> - Liga tim tamu. </li><li>  <code>h_name</code> - Nama tim tuan rumah. </li><li>  <code>h_league</code> - Liga tim tuan rumah. </li><li>  <code>v_score</code> - Poin dari tim tandang. </li><li>  <code>h_score</code> - Poin dari tim tuan rumah. </li><li>  <code>v_line_score</code> - Ringkasan poin-poin dari tim tamu, misalnya - <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> - Ringkasan poin-poin dari tim tuan rumah, misalnya - <code>010000(10)0X</code> . </li><li>  <code>park_id</code> - Pengidentifikasi bidang tempat permainan dimainkan. </li><li>  <code>attendance</code> - Jumlah pemirsa. </li></ul><br>  Untuk mengetahui informasi umum tentang objek <code>DataFrame</code> , Anda dapat menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DataFrame.info ()</a> .  Berkat metode ini, Anda dapat mempelajari tentang ukuran suatu objek, tentang tipe data, dan tentang penggunaan memori. <br><br>  Secara default, panda, demi menghemat waktu, <code>DataFrame</code> informasi perkiraan tentang penggunaan memori dari <code>DataFrame</code> .  Kami tertarik pada informasi yang akurat, jadi kami akan mengatur parameter <code>memory_usage</code> ke <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Berikut ini informasi yang berhasil kami dapatkan: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Ternyata, kami memiliki 171.907 baris dan 161 kolom.  Perpustakaan panda secara otomatis mendeteksi tipe data.  Ada 83 kolom dengan data numerik dan 78 kolom dengan objek.  Kolom objek digunakan untuk menyimpan data string, dan dalam kasus di mana kolom berisi data dari tipe yang berbeda. <br><br>  Sekarang, untuk lebih memahami bagaimana Anda dapat mengoptimalkan penggunaan memori dengan <code>DataFrame</code> ini, mari kita bicara tentang bagaimana panda menyimpan data dalam memori. <br><br><h2>  <font color="#3AC1EF">Tampilan Internal DataFrame</font> </h2><br>  Di dalam panda, kolom data dikelompokkan ke dalam blok dengan nilai dari tipe yang sama.  Berikut adalah contoh bagaimana 12 kolom pertama <code>DataFrame</code> disimpan dalam panda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Representasi internal dari berbagai jenis data dalam panda</font></i> <br><br>  Anda mungkin memperhatikan bahwa blok tidak menyimpan informasi nama kolom.  Ini disebabkan oleh fakta bahwa blok dioptimalkan untuk menyimpan nilai yang tersedia dalam sel tabel objek <code>DataFrame</code> .  Kelas <code>BlockManager</code> bertanggung jawab untuk menyimpan informasi tentang korespondensi antara indeks baris dan kolom dari set data dan apa yang disimpan dalam blok dengan tipe data yang sama.  Ini memainkan peran API yang menyediakan akses ke data dasar.  Saat kami membaca, mengedit, atau menghapus nilai, kelas <code>DataFrame</code> berinteraksi dengan kelas <code>BlockManager</code> untuk mengubah permintaan kami menjadi panggilan fungsi dan metode. <br><br>  Setiap tipe data memiliki kelas khusus dalam modul <code>pandas.core.internals</code> .  Sebagai contoh, panda menggunakan kelas <code>ObjectBlock</code> untuk mewakili blok yang berisi kolom string, dan kelas <code>FloatBlock</code> untuk mewakili blok yang berisi kolom yang <code>FloatBlock</code> angka titik-mengambang.  Untuk blok yang mewakili nilai numerik yang terlihat seperti bilangan bulat atau angka floating point, panda menggabungkan kolom dan menyimpannya sebagai <code>ndarray</code> data <code>ndarray</code> perpustakaan NumPy.  Struktur data ini didasarkan pada larik C, nilainya disimpan dalam blok memori yang berkelanjutan.  Berkat skema penyimpanan data ini, akses ke fragmen data sangat cepat. <br><br>  Karena data dari berbagai jenis disimpan secara terpisah, kami memeriksa penggunaan memori dari berbagai jenis data.  Mari kita mulai dengan penggunaan memori rata-rata untuk berbagai jenis data. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Akibatnya, ternyata indikator rata-rata untuk penggunaan memori untuk data dari berbagai jenis terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Informasi ini membuat kita mengerti bahwa sebagian besar memori dihabiskan untuk 78 kolom yang menyimpan nilai objek.  Kita akan membicarakan lebih lanjut tentang ini nanti, tetapi sekarang mari kita pikirkan apakah kita dapat meningkatkan penggunaan memori dengan kolom yang menyimpan data numerik. <br><br><h2>  <font color="#3AC1EF">Subtipe</font> </h2><br>  Seperti yang telah kami katakan, panda mewakili nilai numerik sebagai struktur data NumPy <code>ndarray</code> dan menyimpannya dalam blok memori yang berdekatan.  Model penyimpanan data ini memungkinkan Anda menghemat memori dan dengan cepat mengakses nilai.  Karena panda mewakili setiap nilai dari jenis yang sama menggunakan jumlah byte yang sama, dan struktur <code>ndarray</code> menyimpan informasi tentang jumlah nilai, panda dapat dengan cepat dan akurat menampilkan informasi tentang jumlah memori yang dikonsumsi oleh kolom yang menyimpan nilai numerik. <br><br>  Banyak tipe data dalam panda memiliki banyak subtipe yang dapat menggunakan lebih sedikit byte untuk mewakili setiap nilai.  Sebagai contoh, tipe <code>float</code> memiliki subtipe <code>float16</code> , <code>float32</code> dan <code>float64</code> .  Angka dalam nama tipe menunjukkan jumlah bit yang digunakan subtipe untuk mewakili nilai.  Misalnya, dalam subtipe yang baru saja terdaftar, 2, 4, 8, dan 16 byte digunakan masing-masing untuk penyimpanan data.  Tabel berikut menunjukkan subtipe tipe data yang paling umum digunakan dalam panda. <br><table><tbody><tr><td>  <sup>Penggunaan memori, byte</sup> <sup><br></sup> </td><td>  <sup>Nomor titik mengambang</sup> <sup><br></sup> </td><td>  <sup>Integer</sup> <sup><br></sup> </td><td>  <sup>Bilangan bulat tak bertanda</sup> <sup><br></sup> </td><td>  <sup>Tanggal dan waktu</sup> <sup><br></sup> </td><td>  <sup>Nilai Boolean</sup> <sup><br></sup> </td><td width="75">  <sup>Obyek</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Kapasitas memori variabel</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>objek</sup> <sup><br></sup> </td></tr></tbody></table><br>  Nilai tipe <code>int8</code> menggunakan 1 byte (8 bit) untuk menyimpan angka dan dapat mewakili 256 nilai biner (daya 2 hingga 8).  Ini berarti bahwa subtipe ini dapat digunakan untuk menyimpan nilai dalam kisaran dari -128 hingga 127 (termasuk 0). <br><br>  Untuk memeriksa nilai minimum dan maksimum yang sesuai untuk penyimpanan menggunakan setiap subtipe integer, Anda dapat menggunakan metode <code>numpy.iinfo()</code> .  Pertimbangkan sebuah contoh: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Dengan menjalankan kode ini, kami mendapatkan data berikut: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Di sini Anda dapat memperhatikan perbedaan antara jenis <code>uint</code> (unsigned integer) dan <code>int</code> (signed integer).  Kedua jenis memiliki kapasitas yang sama, tetapi ketika menyimpan hanya nilai positif dalam kolom, jenis yang tidak ditandatangani memungkinkan penggunaan memori yang lebih efisien. <br><br><h2>  <font color="#3AC1EF">Optimalisasi penyimpanan data numerik menggunakan subtipe</font> </h2><br>  Fungsi <code>pd.to_numeric()</code> dapat digunakan untuk menurunkan konversi tipe numerik.  Untuk memilih kolom integer, kami menggunakan metode <code>DataFrame.select_dtypes()</code> , kemudian kami mengoptimalkannya dan membandingkan penggunaan memori sebelum dan sesudah optimasi. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Berikut ini adalah hasil dari studi tentang konsumsi memori: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  Untuk <br></td><td>  Setelah <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Akibatnya, Anda dapat melihat penurunan penggunaan memori dari 7,9 menjadi 1,5 megabyte, yaitu - kami mengurangi konsumsi memori lebih dari 80%.  Dampak keseluruhan dari pengoptimalan ini pada <code>DataFrame</code> asli, bagaimanapun, tidak terlalu kuat karena hanya memiliki sedikit kolom integer. <br><br>  Mari kita lakukan hal yang sama dengan kolom yang berisi angka floating point. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  Hasilnya adalah sebagai berikut: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  Untuk <br></td><td>  Setelah <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77.0 <br></td></tr><tr><td>  float64 <br></td><td>  77.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Akibatnya, semua kolom yang menyimpan angka floating point dengan tipe data <code>float64</code> sekarang menyimpan jumlah tipe <code>float32</code> , yang memberi kami pengurangan 50% dalam penggunaan memori. <br><br>  Buat salinan <code>DataFrame</code> asli, gunakan kolom numerik yang dioptimalkan ini, bukan yang awalnya ada di dalamnya, dan lihat keseluruhan penggunaan memori setelah optimasi. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Inilah yang kami dapatkan: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Meskipun kami secara signifikan mengurangi konsumsi memori dengan kolom yang menyimpan data numerik, secara umum, di seluruh <code>DataFrame</code> , konsumsi memori menurun hanya 7%.  Optimalisasi penyimpanan jenis objek dapat menjadi sumber perbaikan situasi yang jauh lebih serius. <br><br>  Sebelum kami melakukan optimasi ini, kami akan melihat lebih dekat bagaimana string disimpan dalam panda, dan membandingkannya dengan bagaimana angka disimpan di sini. <br><br><h2>  <font color="#3AC1EF">Perbandingan mekanisme untuk menyimpan angka dan string</font> </h2><br>  Jenis <code>object</code> mewakili nilai menggunakan objek string Python.  Ini sebagian karena NumPy tidak mendukung representasi nilai string yang hilang.  Karena Python adalah bahasa tingkat tinggi yang diinterpretasikan, Python tidak menyediakan alat bagi programmer untuk mengatur bagaimana data disimpan dalam memori. <br><br>  Keterbatasan ini mengarah pada fakta bahwa string tidak disimpan dalam fragmen memori yang berdekatan, representasi mereka dalam memori terfragmentasi.  Ini mengarah pada peningkatan konsumsi memori dan perlambatan kecepatan bekerja dengan nilai-nilai string.  Setiap elemen dalam kolom yang menyimpan tipe data objek, pada kenyataannya, adalah pointer yang berisi "alamat" di mana nilai sebenarnya terletak di memori. <br><br>  Berikut ini adalah diagram berdasarkan bahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> yang membandingkan penyimpanan data numerik menggunakan tipe data NumPy dan menyimpan string menggunakan tipe data built-in Python. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Menyimpan data numerik dan string</font></i> <br><br>  Di sini Anda dapat mengingat bahwa dalam salah satu tabel di atas ditunjukkan bahwa jumlah variabel memori digunakan untuk menyimpan data tipe objek.  Meskipun setiap pointer menempati 1 byte memori, setiap nilai string tertentu mengambil jumlah memori yang sama yang akan digunakan untuk menyimpan string tunggal dalam Python.  Untuk mengkonfirmasi ini, kami akan menggunakan metode <code>sys.getsizeof()</code> .  Pertama, lihat pada masing-masing baris, dan kemudian pada objek <code>Series</code> panda yang menyimpan data string. <br><br>  Jadi, pertama kita periksa baris yang biasa: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Di sini, data penggunaan memori terlihat seperti ini: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Sekarang mari kita lihat bagaimana penggunaan string dalam objek <code>Series</code> terlihat: <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Di sini kita mendapatkan yang berikut: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Di sini Anda dapat melihat bahwa ukuran garis yang disimpan dalam objek <code>Series</code> panda mirip dengan ukurannya saat bekerja dengannya dalam Python dan saat merepresentasikannya sebagai entitas terpisah. <br><br><h2>  <font color="#3AC1EF">Optimalisasi penyimpanan data jenis objek menggunakan variabel kategorikal</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Variabel kategorikal</a> muncul di versi panda 0.15.  Jenis yang sesuai, <code>category</code> , menggunakan nilai integer dalam mekanisme internal, bukan nilai-nilai asli yang disimpan di kolom tabel.  Panda menggunakan kamus terpisah yang mengatur korespondensi nilai integer dan awal.  Pendekatan ini berguna ketika kolom berisi nilai-nilai dari kumpulan terbatas.  Ketika data yang disimpan dalam kolom dikonversi ke jenis <code>category</code> , panda menggunakan subtipe <code>int</code> , yang memungkinkan penggunaan memori yang paling efisien dan mampu mewakili semua nilai unik yang ditemukan dalam kolom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Sumber data dan data kategorikal menggunakan subtipe int8</font></i> <br><br>  Untuk memahami dengan tepat di mana kita dapat menggunakan data kategorikal untuk mengurangi konsumsi memori, kami menemukan jumlah nilai unik dalam kolom yang menyimpan nilai tipe objek: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Anda dapat menemukan apa yang kami miliki di tabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , di lembar <code>    </code> . <br><br>  Misalnya, di kolom <code>day_of_week</code> , yang merupakan hari di mana permainan dimainkan, ada nilai 171907.  Di antara mereka, hanya 7 yang unik.  Secara keseluruhan, pandangan sekilas pada laporan ini cukup untuk memahami bahwa beberapa nilai unik digunakan dalam banyak kolom untuk mewakili data sekitar 172.000 game. <br><br>  Sebelum kita melakukan optimasi skala penuh, mari kita pilih satu kolom yang menyimpan data objek, setidaknya <code>day_of_week</code> , dan lihat apa yang terjadi di dalam program ketika dikonversi ke tipe kategorikal. <br><br>  Seperti yang telah disebutkan, kolom ini hanya berisi 7 nilai unik.  Untuk mengonversinya menjadi tipe kategorikal, kami menggunakan metode <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Inilah yang kami dapatkan: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Seperti yang Anda lihat, meskipun jenis kolom telah berubah, data yang tersimpan di dalamnya terlihat sama seperti sebelumnya.  Sekarang mari kita lihat apa yang terjadi di dalam program. <br><br>  Dalam kode berikut, kami menggunakan atribut <code>Series.cat.codes</code> untuk mengetahui nilai integer mana yang digunakan tipe <code>category</code> untuk mewakili setiap hari dalam seminggu: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Kami berhasil menemukan yang berikut: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Di sini Anda dapat melihat bahwa setiap nilai unik diberi nilai integer, dan bahwa kolom tersebut sekarang bertipe <code>int8</code> .  Tidak ada nilai yang hilang, tetapi jika itu yang terjadi, -1 akan digunakan untuk menunjukkan nilai-nilai tersebut. <br><br>  Sekarang mari kita bandingkan konsumsi memori sebelum dan sesudah mengonversi kolom <code>day_of_week</code> ke jenis <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Inilah hasilnya: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Seperti yang Anda lihat, pada awalnya 9,84 megabita memori dikonsumsi, dan setelah optimasi hanya 0,16 megabita, yang berarti peningkatan 98% pada indikator ini.  Harap perhatikan bahwa bekerja dengan kolom ini mungkin menunjukkan salah satu skenario optimisasi paling menguntungkan ketika hanya 7 nilai unik yang digunakan dalam kolom yang berisi sekitar 172.000 elemen. <br><br>  Meskipun gagasan mengubah semua kolom ke tipe data ini terlihat menarik, sebelum melakukan ini, pertimbangkan efek samping negatif dari konversi semacam itu.  Jadi, minus paling serius dari transformasi ini adalah ketidakmungkinan melakukan operasi aritmatika pada data kategorikal.  Ini juga berlaku untuk operasi aritmatika biasa, dan penggunaan metode seperti <code>Series.min()</code> dan <code>Series.max()</code> tanpa terlebih dahulu mengonversi data ke tipe angka nyata. <br><br>  Kita harus membatasi penggunaan tipe <code>category</code> terutama kolom yang menyimpan data <code>object</code> tipe, di mana kurang dari 50% dari nilai-nilai unik.  Jika semua nilai dalam kolom adalah unik, maka menggunakan jenis <code>category</code> akan meningkatkan tingkat penggunaan memori.  Ini disebabkan oleh fakta bahwa dalam memori Anda harus menyimpan, selain kode kategori numerik, nilai string asli.  Rincian tentang pembatasan jenis <code>category</code> dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> panda. <br><br>  Mari kita buat satu loop yang berulang-ulang di atas semua kolom yang menyimpan data <code>object</code> tipe, cari tahu apakah jumlah nilai unik dalam kolom melebihi 50%, dan jika demikian, ubah mereka untuk mengetikkan <code>category</code> . <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Sekarang bandingkan apa yang terjadi setelah optimasi dengan apa yang terjadi sebelumnya: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Kami mendapatkan yang berikut ini: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  Untuk <br></td><td>  Setelah <br></td></tr><tr><td>  objek <br></td><td>  78.0 <br></td><td>  NaN <br></td></tr><tr><td>  kategori <br></td><td>  NaN <br></td><td>  78.0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     —  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Pembaca yang budiman!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">eugene_bb</a> .    -  ,    —    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442516/">https://habr.com/ru/post/id442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442504/index.html">Proxy PHP Xdebug: ketika fitur standar Xdebug tidak cukup</a></li>
<li><a href="../id442506/index.html">Apakah Rusia dihukum karena perdagangan ilegal dalam data pribadi?</a></li>
<li><a href="../id442508/index.html">Bagaimana udalenka mempercepat inovasi di GitLab</a></li>
<li><a href="../id442512/index.html">Kustomisasi Django ORM pada contoh ZomboDB</a></li>
<li><a href="../id442514/index.html">Sistem terdistribusi. Pola desain. Ulasan Buku</a></li>
<li><a href="../id442518/index.html">10 Teknik Peretasan Web Terbaik 2018</a></li>
<li><a href="../id442520/index.html">Kasing. Hemat 300 000 p. per bulan pada iklan kontekstual</a></li>
<li><a href="../id442522/index.html">Intuitive RL (Reinforcement Learning): Pengantar Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../id442524/index.html">Cara meningkatkan keamanan dalam identifikasi pribadi dan sistem kontrol akses</a></li>
<li><a href="../id442526/index.html">Sejarah pemutar kaset Soviet (bagian dua): booming Walkmen, gadget untuk KGB dan tape recorder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>