<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê£ üñáÔ∏è üò≠ Hibernate - sobre o que os tutoriais est√£o calados üöÉ ‚ú≥Ô∏è üë©üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo n√£o abordar√° os conceitos b√°sicos do hibernate (como definir uma entidade ou consultar crit√©rios de grava√ß√£o). Aqui vou tentar falar sobre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hibernate - sobre o que os tutoriais est√£o calados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Este artigo n√£o abordar√° os conceitos b√°sicos do hibernate (como definir uma entidade ou consultar crit√©rios de grava√ß√£o).  Aqui vou tentar falar sobre pontos mais interessantes que s√£o realmente √∫teis no trabalho.  Informa√ß√µes sobre as quais n√£o conheci em um s√≥ lugar. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="imagem"><br><a name="habracut"></a><br>  Farei uma reserva imediatamente.  Tudo o que se segue √© verdadeiro no Hibernate 5.2.  Erros tamb√©m s√£o poss√≠veis devido ao fato de eu ter entendido algo errado.  Se voc√™ encontrar - escreva. <br><br><h2>  Problemas ao mapear um modelo de objeto em um relacional </h2><br>  Mas vamos come√ßar com o b√°sico do ORM.  ORM - mapeamento objeto-relacional - nesse sentido, temos modelos relacionais e de objetos.  E ao exibir um ao outro, h√° problemas que precisamos resolver sozinhos.  Vamos separ√°-los. <br><br>  Para ilustrar, vamos dar o seguinte exemplo: temos a entidade "Usu√°rio", que pode ser um Jedi ou uma aeronave de ataque.  Os Jedi devem ter for√ßa e especializa√ß√£o em aeronaves de ataque.  Abaixo est√° um diagrama de classes. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="imagem"><br><br><h3>  Problema 1. Heran√ßa e consultas polim√≥rficas. </h3><br>  H√° heran√ßa no modelo de objeto, mas n√£o no modelo relacional.  Consequentemente, este √© o primeiro problema - como mapear corretamente a heran√ßa para o modelo relacional. <br><br>  O Hibernate oferece 3 op√ß√µes para exibir esse modelo de objeto: <br><br><ol><li>  Todos os herdeiros est√£o na mesma tabela: <br>  <b>@ Heran√ßa (estrat√©gia = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="imagem"><br><br>  Nesse caso, os campos comuns e os campos dos herdeiros est√£o em uma tabela.  Usando essa estrat√©gia, evitamos jun√ß√µes ao selecionar entidades.  Das desvantagens, vale ressaltar que, em primeiro lugar, n√£o podemos definir a restri√ß√£o ‚ÄúNOT NULL‚Äù para a coluna ‚Äúforce‚Äù no modelo relacional e, em segundo lugar, perdemos a terceira forma normal.  (uma depend√™ncia transitiva de atributos n√£o chave aparece: for√ßa e disco). <br><br>  A prop√≥sito, inclusive por esse motivo, existem 2 maneiras de especificar uma restri√ß√£o de campo n√£o nula - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">NotNull</a> √© respons√°vel pela valida√ß√£o;  @Column (nullable = true) - respons√°vel pela restri√ß√£o n√£o nula no banco de dados. <br><br>  Na minha opini√£o, esta √© a melhor maneira de mapear um modelo de objeto para um modelo relacional. <br></li><li>  Os campos espec√≠ficos da entidade est√£o em uma tabela separada. <br><br>  <b>@ Heran√ßa (estrat√©gia = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="imagem"><br><br>  Nesse caso, os campos comuns s√£o armazenados em uma tabela comum e os espec√≠ficos para entidades filho s√£o armazenados em campos separados.  Usando essa estrat√©gia, obtemos um JOIN ao escolher uma entidade, mas agora salvamos o terceiro formul√°rio normal e tamb√©m podemos especificar uma restri√ß√£o NOT NULL no banco de dados. </li><li>  Cada entidade tem sua pr√≥pria tabela. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="imagem"><br><br>  Nesse caso, n√£o temos uma tabela comum.  Usando essa estrat√©gia, usamos UNION para consultas polim√≥rficas.  Estamos tendo problemas com geradores de chave prim√°ria e outras restri√ß√µes de integridade.  Esse tipo de mapeamento de heran√ßa √© fortemente desencorajado. </li></ol><br>  S√≥ para mencionar a anota√ß√£o - @MappedSuperclass.  √â usado quando voc√™ deseja "ocultar" campos comuns para v√°rias entidades do modelo de objeto.  Al√©m disso, a pr√≥pria classe anotada n√£o √© considerada uma entidade separada. <br><br><h3>  Problema 2. Taxa de composi√ß√£o no POO </h3><br>  Voltando ao nosso exemplo, observamos que no modelo de objeto levamos o perfil do usu√°rio para uma entidade separada - Profile.  Mas no modelo relacional, n√£o selecionamos uma tabela separada para ele. <br><br>  A atitude do OneToOne geralmente √© uma pr√°tica ruim porque  em select, temos um JOIN injustificado (mesmo especificando fetchType = LAZY na maioria dos casos, teremos JOIN - discutiremos esse problema mais tarde). <br><br>  Existem anota√ß√µes @Embedable e @Embeded para exibir uma composi√ß√£o em uma tabela comum.  O primeiro √© colocado acima do campo e o segundo acima da classe.  Eles s√£o intercambi√°veis. <br><br><h2>  Gerente de Entidade </h2><br>  Cada inst√¢ncia do EntityManager (EM) define uma sess√£o de intera√ß√£o com o banco de dados.  Dentro de uma inst√¢ncia EM, h√° um cache de primeiro n√≠vel.  Aqui vou destacar os seguintes pontos significativos: <br><br><ol><li>  <b>Capturando a conex√£o com o banco de dados</b> <br><br>  Este √© apenas um ponto interessante.  O Hibernate n√£o captura o Connection no momento de receber o EM, mas no primeiro acesso ao banco de dados ou na abertura da transa√ß√£o (embora esse problema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">possa ser resolvido</a> ).  Isso √© feito para reduzir o tempo de conex√£o ocupada.  Durante o recebimento do EM-a, a presen√ßa de uma transa√ß√£o JTA √© verificada. </li><li>  <b>Entidades persistidas sempre t√™m id</b> </li><li>  <b>As entidades que descrevem uma linha no banco de dados s√£o equivalentes por refer√™ncia</b> <br>  Como mencionado acima, o EM tem um cache de primeiro n√≠vel, os objetos nele s√£o comparados por refer√™ncia.  Assim, surge a pergunta - quais campos devem ser usados ‚Äã‚Äãpara substituir iguais e hashcode?  Considere as seguintes op√ß√µes: <br><br><ul><li>  Use todos os campos.  M√° ideia  iguais podem afetar os campos LAZY.  A prop√≥sito, isso tamb√©m se aplica ao m√©todo toString. </li><li>  Use apenas ID.  Uma ideia normal, mas tamb√©m existem nuances.  J√° que na maioria das vezes para novas entidades, o id coloca um gerador no momento da persist√™ncia.  A seguinte situa√ß√£o √© poss√≠vel: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Use uma chave comercial (grosso modo, campos exclusivos e N√ÉO NULL).  Mas essa op√ß√£o nem sempre √© conveniente. <br><br>  A prop√≥sito, como estamos falando de NOT NULL e UNIQUE, √†s vezes √© conveniente criar um construtor p√∫blico com argumentos NOT NULL, e o construtor sem argumentos √© protegido. </li><li>  N√£o substitua iguais e hashcode. </li></ul></li><li>  <b>Como funciona a descarga</b> <br>  Liberar - executa inser√ß√µes, atualiza√ß√µes e exclus√µes acumuladas no banco de dados.  Por padr√£o, o flush √© executado nos casos: <br><br><ul><li>  Antes de executar a consulta (com exce√ß√£o do em.get), isso √© necess√°rio para cumprir o princ√≠pio do ACID.  Por exemplo: alteramos a data de nascimento da aeronave de ataque e, em seguida, desejamos obter o n√∫mero de aeronaves de ataque adultas. <br><br>  Se estivermos falando sobre CriteriaQuery ou JPQL, a libera√ß√£o ser√° executada se a consulta afetar uma tabela cujas entidades est√£o no cache do primeiro n√≠vel. </li><li>  Ao cometer uma transa√ß√£o; </li><li>  √Äs vezes, quando persistimos em uma nova entidade - no caso em que podemos obter seu ID apenas atrav√©s da inser√ß√£o. </li></ul><br>  E agora um pequeno teste.  Quantas opera√ß√µes UPDATE ser√£o executadas neste caso? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Um recurso interessante de hiberna√ß√£o est√° oculto sob a opera√ß√£o de libera√ß√£o - ele est√° tentando reduzir o tempo necess√°rio para bloquear linhas no banco de dados. <br><br>  Observe tamb√©m que existem estrat√©gias diferentes para a opera√ß√£o de descarga.  Por exemplo, voc√™ pode proibir altera√ß√µes "mescladas" no banco de dados - ele √© chamado MANUAL (tamb√©m desativa o mecanismo de verifica√ß√£o suja). <br></li><li>  <b>Verifica√ß√£o suja</b> <br><br>  Dirty Checking √© um mecanismo executado durante uma opera√ß√£o de descarga.  Seu objetivo √© encontrar entidades que foram alteradas e atualiz√°-las.  Para implementar esse mecanismo, o hibernate deve armazenar a c√≥pia original do objeto (com a qual o objeto real ser√° comparado).  Para ser mais preciso, o hibernate armazena uma c√≥pia dos campos do objeto, n√£o do pr√≥prio objeto. <br><br>  Vale ressaltar que, se o gr√°fico de entidades for grande, a opera√ß√£o de verifica√ß√£o suja pode ser cara.  N√£o esque√ßa que o hibernate armazena 2 c√≥pias de entidades (grosso modo). <br>  Para "reduzir o custo" desse processo, use os seguintes recursos: <br><br><ul><li>  em.detach / em.clear - desanexa entidades do EntityManager </li><li>  FlushMode = MANUAL - √∫til em opera√ß√µes de leitura </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Imut√°vel</a> - tamb√©m evita opera√ß√µes de verifica√ß√£o sujas </li></ul><br></li><li>  <b>Transa√ß√µes</b> <br><br>  Como voc√™ sabe, o hibernate permite atualizar entidades apenas dentro de uma transa√ß√£o.  As opera√ß√µes de leitura oferecem mais liberdade - podemos execut√°-las sem abrir explicitamente uma transa√ß√£o.  Mas esta √© precisamente a quest√£o: vale a pena abrir explicitamente uma transa√ß√£o para opera√ß√µes de leitura? <br><br>  Vou citar alguns fatos: <br><br><ul><li>  Qualquer instru√ß√£o √© executada no banco de dados dentro da transa√ß√£o.  Mesmo se obviamente n√£o o abr√≠ssemos.  (modo de confirma√ß√£o autom√°tica). </li><li>  Como regra, n√£o estamos limitados a uma consulta no banco de dados.  Por exemplo: para obter os 10 primeiros registros, voc√™ provavelmente deseja retornar o n√∫mero total de registros.  E isso √© quase sempre 2 solicita√ß√µes. </li><li>  Se estamos falando de dados de primavera, os m√©todos do reposit√≥rio s√£o transacionais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">por padr√£o</a> , enquanto os m√©todos de leitura s√£o somente leitura. </li><li>  A anota√ß√£o @Transactional spring (readOnly = true) tamb√©m afeta o FlushMode, mais precisamente, o Spring o coloca no status MANUAL, portanto, o hibernate n√£o realiza a verifica√ß√£o suja. </li><li>  Testes sint√©ticos com uma ou duas consultas ao banco de dados mostram que a confirma√ß√£o autom√°tica √© mais r√°pida.  Mas no modo de combate, pode n√£o ser assim.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente artigo sobre este assunto</a> , + ver coment√°rios) </li></ul><br>  Em poucas palavras: √© uma boa pr√°tica realizar qualquer comunica√ß√£o com o banco de dados em uma transa√ß√£o. <br></li></ol><br><h2>  Geradores </h2><br>  Os geradores s√£o necess√°rios para descrever como as chaves prim√°rias de nossas entidades receber√£o valores.  Vamos analisar rapidamente as op√ß√µes: <br><br><ul><li>  <b>GenerationType.AUTO</b> - a sele√ß√£o do gerador √© baseada no dialeto.  N√£o √© a melhor op√ß√£o, pois a regra "expl√≠cito √© melhor que o impl√≠cito" se aplica aqui. </li><li>  <b>GenerationType.IDENTITY</b> √© a maneira mais f√°cil de configurar um gerador.  Ele se baseia na coluna de incremento autom√°tico na tabela.  Portanto, para obter id com persist√™ncia, precisamos inserir.  √â por isso que elimina a possibilidade de persist√™ncia diferida e, portanto, lote. </li><li>  <b>GenerationType.SEQUENCE</b> √© o caso mais conveniente quando obtemos o ID da sequ√™ncia. </li><li>  <b>GenerationType.TABLE</b> - neste caso, o hibernate emula uma sequ√™ncia atrav√©s de uma tabela adicional.  N√£o √© a melhor op√ß√£o, porque  nessa solu√ß√£o, o hibernate precisa usar uma transa√ß√£o separada e bloquear por linha. </li></ul><br>  Vamos falar um pouco mais sobre sequ√™ncia.  Para aumentar a velocidade da opera√ß√£o, o hibernate usa diferentes algoritmos de otimiza√ß√£o.  Todos eles visam reduzir o n√∫mero de conversas com o banco de dados (o n√∫mero de viagens de ida e volta).  Vamos dar uma olhada neles com mais detalhes: <br><br><ul><li>  <b>nenhum</b> - sem otimiza√ß√µes.  para cada id, puxamos a sequ√™ncia. </li><li>  <b>pooled e pooled-lo</b> - nesse caso, nossa sequ√™ncia deve aumentar em um determinado intervalo - N no banco de dados (SequenceGenerator.allocationSize).  E no aplicativo, temos um determinado pool, os valores dos quais podemos atribuir a novas entidades sem acessar o banco de dados. </li><li>  <b>hilo</b> - para gerar um ID, o algoritmo hilo usa 2 n√∫meros: hi (armazenado no banco de dados - o valor obtido da chamada de sequ√™ncia) e lo (armazenado somente no aplicativo - SequenceGenerator.allocationSize).  Com base nesses n√∫meros, o intervalo para gerar a identifica√ß√£o √© calculado da seguinte forma: [(hi - 1) * lo + 1, hi * lo + 1).  Por raz√µes √≥bvias, esse algoritmo √© considerado desatualizado e n√£o √© recomend√°vel us√°-lo. </li></ul><br>  Agora vamos ver como o otimizador est√° selecionado.  O Hibernate possui v√°rios geradores de sequ√™ncia.  Estaremos interessados ‚Äã‚Äãem 2 deles: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> √© um gerador antigo que usa o otimizador de hilo.  Selecionado por padr√£o se tivermos a propriedade hibernate.id.new_generator_mappings == false. </li><li>  <b>SequenceStyleGenerator</b> - usado por padr√£o (se a propriedade hibernate.id.new_generator_mappings == true).  Este gerador suporta v√°rios otimizadores, mas o padr√£o √© agrupado. </li></ul><br>  Voc√™ tamb√©m pode configurar a anota√ß√£o do gerador @GenericGenerator. <br><br><h2>  Impasse </h2><br>  Vejamos um exemplo de uma situa√ß√£o de pseudo-c√≥digo que pode levar a um impasse: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Para evitar esses problemas, o hibernate possui um mecanismo que evita conflitos desse tipo - o par√¢metro hibernate.order_updates.  Nesse caso, todas as atualiza√ß√µes ser√£o ordenadas por ID e executadas.  Tamb√©m mencionarei mais uma vez que o hibernate est√° tentando "atrasar" a captura da conex√£o e a execu√ß√£o de insert-s e update-s. <br><br><h2>  Conjunto, Bolsa, Lista </h2><br>  O Hibernate possui 3 maneiras principais de apresentar a cole√ß√£o de comunica√ß√£o OneToMany. <br><br><ul><li>  Conjunto - um conjunto n√£o ordenado de entidades sem repeti√ß√µes; </li><li>  Bag - um conjunto n√£o ordenado de entidades; </li><li>  Lista √© um conjunto ordenado de entidades. </li></ul><br>  N√£o h√° classe para Bag no n√∫cleo java que descreva essa estrutura.  Portanto, todas as listas e cole√ß√µes s√£o agrupadas, a menos que voc√™ especifique uma coluna pela qual nossa cole√ß√£o ser√° classificada (anota√ß√£o OrderColumn. N√£o deve ser confundida com SortBy).  Eu recomendo n√£o usar a anota√ß√£o OrderColumn devido √† m√° implementa√ß√£o (em minha opini√£o) dos recursos - n√£o √†s consultas sql ideais, aos poss√≠veis NULLs na planilha. <br><br>  A quest√£o surge, mas o que √© melhor usar bolsa ou conjunto?  Para come√ßar, ao usar uma bolsa, os seguintes problemas s√£o poss√≠veis: <br><br><ul><li>  Se a sua vers√£o do hibernate for inferior a 5.0.8, haver√° um erro bastante s√©rio - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HHH-5855</a> - ao inserir uma entidade filha, √© poss√≠vel duplicar (no caso de cascadType = MERGE e PERSIST); </li><li>  Se voc√™ usar bag para o relacionamento ManyToMany, o hibernate gera consultas extremamente inadequadas ao excluir uma entidade da cole√ß√£o - primeiro remove todas as linhas da tabela de jun√ß√£o e, em seguida, executa a inser√ß√£o; </li><li>  O Hibernate n√£o pode buscar v√°rias malas para a mesma entidade ao mesmo tempo. </li></ul><br>  No caso em que voc√™ deseja adicionar outra entidade √† conex√£o @OneToMany, √© mais rent√°vel usar o Bag, porque  n√£o requer o carregamento de todas as entidades relacionadas para esta opera√ß√£o.  Vamos ver um exemplo: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  Refer√™ncias de for√ßa </h2><br>  Refer√™ncia √© uma refer√™ncia a um objeto, que decidimos adiar o carregamento.  No caso do relacionamento de ManyToOne com fetchType = LAZY, obtemos essa refer√™ncia.  A inicializa√ß√£o do objeto ocorre no momento do acesso aos campos da entidade, com exce√ß√£o do id (j√° que sabemos o valor desse campo). <br><br>  Vale ressaltar que, no caso do Lazy Loading, a refer√™ncia sempre se refere a uma linha existente no banco de dados.  Por esse motivo, a maioria dos casos de Carregamento Pregui√ßoso n√£o funciona nos relacionamentos do OneToOne - o hibernate precisa ser JOIN para verificar se a conex√£o existe e j√° existe um JOIN, e o hibernate o carrega no modelo de objeto.  Se indicarmos nullable = true no OneToOne, o LazyLoad dever√° funcionar. <br><br>  Podemos criar nossa pr√≥pria refer√™ncia usando o m√©todo em.getReference.  √â verdade que, neste caso, n√£o h√° garantia de que a refer√™ncia se refira a uma linha existente no banco de dados. <br><br>  Vamos dar um exemplo do uso desse link: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  S√≥ por precau√ß√£o, lembro que obteremos uma LazyInitializationException no caso de um EM fechado ou um link desanexado. <br><br><h2>  Data e hora </h2><br>  Apesar do java 8 ter uma excelente API para trabalhar com data e hora, a API JDBC ainda permite que voc√™ trabalhe apenas com a API antiga.  Portanto, analisaremos alguns pontos interessantes. <br><br>  Primeiro, voc√™ precisa entender claramente as diferen√ßas entre LocalDateTime e Instant e ZonedDateTime.  (N√£o esticarei, mas darei excelentes artigos sobre esse assunto: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Se brevemente</b> <div class="spoiler_text">  LocalDateTime e LocalDate representam uma tupla regular de n√∫meros.  Eles n√£o est√£o vinculados a um hor√°rio espec√≠fico.  I.e.  o hor√°rio de pouso do avi√£o n√£o pode ser armazenado no LocalDateTime.  E a data de nascimento atrav√©s do LocalDate √© bastante normal.  Instant√¢neo representa um ponto no tempo, em rela√ß√£o ao qual podemos obter a hora local em qualquer ponto do planeta. <br></div></div><br>  Um ponto mais interessante e importante √© como as datas s√£o armazenadas no banco de dados.  Se tivermos o tipo TIMESTAMP WITH TIMEZONE afixado, n√£o haver√° problemas, mas se o TIMESTAMP (SEM FUSO HOR√ÅRIO) permanecer, haver√° uma chance de que a data seja escrita / lida incorretamente.  (excluindo LocalDate e LocalDateTime) <br><br>  Vamos ver o porqu√™: <br><br>  Quando salvamos a data, um m√©todo com a seguinte assinatura √© usado: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Como voc√™ pode ver, a API antiga √© usada aqui.  O argumento opcional Calend√°rio √© necess√°rio para converter o carimbo de data / hora em uma representa√ß√£o de sequ√™ncia.  Ou seja, ele armazena o fuso hor√°rio em si.  Se o Calend√°rio n√£o for transmitido, o Calend√°rio ser√° usado por padr√£o com o fuso hor√°rio da JVM. <br><br>  Existem 3 maneiras de resolver esse problema: <br><br><ul><li>  Defina o JVM de fuso hor√°rio desejado </li><li>  Use o par√¢metro hibernate - hibernate.jdbc.time_zone (adicionado em 5.2) - corrigir√° apenas ZonedDateTime e OffsetDateTime </li><li>  Use o tipo TIMESTAMP WITH TIMEZONE </li></ul><br>  Uma pergunta interessante, por que LocalDate e LocalDateTime n√£o se enquadram nesse problema? <br><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  Para responder a essa pergunta, voc√™ precisa entender a estrutura da classe java.util.Date (java.sql.Date e java.sql.Timestamp, seus herdeiros e suas diferen√ßas nesse caso n√£o nos incomodam).  Date armazena a data em milissegundos desde 1970, aproximadamente no UTC, mas o m√©todo toString converte a data de acordo com o fuso hor√°rio do sistema. <br><br>  Assim, quando obtemos uma data sem um fuso hor√°rio do banco de dados, ela √© mapeada para um objeto Timestamp para que o m√©todo toString exiba o valor desejado.  Ao mesmo tempo, o n√∫mero de milissegundos desde 1970 pode ser diferente (dependendo do fuso hor√°rio).  √â por isso que apenas a hora local √© sempre exibida corretamente. <br><br>  Tamb√©m dou um exemplo do c√≥digo respons√°vel pela convers√£o de Timesamp em LocalDateTime e Instant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Lote </h2><br>  Por padr√£o, as consultas s√£o enviadas ao banco de dados, uma de cada vez.  Quando o lote est√° ativado, o hibernate poder√° enviar v√°rias instru√ß√µes em uma consulta ao banco de dados.  (ou seja, o lote reduz o n√∫mero de viagens de ida e volta ao banco de dados) <br><br>  Para fazer isso, voc√™ deve: <br><br><ul><li>  Ative o lote e defina o n√∫mero m√°ximo de instru√ß√µes: <br>  hibernate.jdbc.batch_size (5 a 30 recomendado) </li><li>  Ative a classifica√ß√£o de inser√ß√£o e atualiza√ß√£o s: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Se usarmos o controle de vers√£o, tamb√©m precisamos ativar <br>  hibernate.jdbc.batch_versioned_data - tenha cuidado aqui, voc√™ precisa do driver jdbc para poder fornecer o n√∫mero de linhas afetadas durante a atualiza√ß√£o. </li></ul><br>  Tamb√©m vou lembr√°-lo sobre a efic√°cia da opera√ß√£o em.clear () - ela desobstrui as entidades, liberando mem√≥ria e reduzindo o tempo da opera√ß√£o de verifica√ß√£o suja. <br>  Se usarmos o postgres, tamb√©m podemos dizer hibernar para usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a inser√ß√£o multi-raw</a> . <br><br><h2>  Problema N + 1 </h2><br>  Este √© um t√≥pico bastante onipresente, portanto, leia-o rapidamente. <br><br>  Um problema N + 1 √© uma situa√ß√£o em que, em vez de uma √∫nica solicita√ß√£o para selecionar N books, ocorrem pelo menos solicita√ß√µes N + 1. <br><br>  A maneira mais f√°cil de resolver o problema N + 1 √© buscar tabelas relacionadas.  Nesse caso, podemos ter v√°rios outros problemas: <br><br><ul><li>  <b>Pagina√ß√£o.</b>  no caso dos relacionamentos OneToMany, o hibernate n√£o poder√° especificar deslocamento e limite.  Portanto, a pagina√ß√£o ocorrer√° na mem√≥ria. </li><li>  <b>O problema de um produto cartesiano</b> √© uma situa√ß√£o em que um banco de dados retorna N * M * K linhas para escolher N livros com M cap√≠tulos e K autores. </li></ul><br>  Existem outras maneiras de resolver o problema N + 1. <br><br><ul><li>  <b>FetchMode</b> - permite alterar o algoritmo de carregamento de entidades <b>filhas</b> .  No nosso caso, estamos interessados ‚Äã‚Äãno seguinte: <ul><li>  <b>FetchType.SUBSELECT</b> - Carrega registros filho em uma solicita√ß√£o separada.  A desvantagem √© que toda a complexidade da solicita√ß√£o principal √© repetida na subsele√ß√£o. </li><li>  <b>BATCH (anota√ß√£o FetchType.SELECT + BatchSize)</b> - tamb√©m carrega registros como uma solicita√ß√£o separada, mas, juntamente com a subconsulta, cria uma condi√ß√£o como WHERE parent_id IN (?,?,?, ..., N) </li></ul>  √â importante notar que, ao usar a busca na API de crit√©rios, o FetchType √© ignorado - JOIN √© sempre usado </li><li>  <b>JPA EntityGraph e Hibernate FetchProfile</b> - permitem criar regras de carregamento de entidades em uma abstra√ß√£o separada - na minha opini√£o, ambas as implementa√ß√µes s√£o inconvenientes. </li></ul><br><h2>  Teste </h2><br>  Idealmente, o ambiente de desenvolvimento deve fornecer o m√°ximo de informa√ß√µes √∫teis poss√≠vel sobre a opera√ß√£o do hibernate e sobre a intera√ß√£o com o banco de dados.  Ou seja: <br><br><ul><li>  Registo <ul><li>  org.hibernate.SQL: debug </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Estat√≠sticas <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  Dos utilit√°rios √∫teis, √© poss√≠vel distinguir o seguinte: <br><ul><li>  <b>DBUnit</b> - permite descrever o estado do banco de dados no formato XML.  √Äs vezes √© conveniente.  Mas √© melhor pensar novamente se voc√™ precisar. </li><li>  DataSource-proxy <ul><li>  <b>O p6spy</b> √© uma das solu√ß√µes mais antigas.  oferece log de consulta avan√ßado, tempo de execu√ß√£o etc. </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> √© um utilit√°rio √∫til para encontrar problemas de N + 1.  Tamb√©m permite registrar consultas.  A composi√ß√£o inclui uma anota√ß√£o interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Repetir</a> , que tenta novamente a transa√ß√£o no caso de uma OptimisticLockException. </li><li>  <b>Sniffy</b> - permite que voc√™ fa√ßa uma declara√ß√£o sobre o n√∫mero de solicita√ß√µes por meio da anota√ß√£o.  De certa forma, mais elegante que a decis√£o de Vlad. </li></ul></li></ul><br>  Mas mais uma vez repito que isso √© apenas para desenvolvimento, n√£o deve ser inclu√≠do na produ√ß√£o. <br><br><h2>  Literatura </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relat√≥rio de Nikolai Alimenkov - Vamos acelerar o Hibernate novamente</a> - foi este relat√≥rio que me inspirou a estudar mais profundamente o hiberna√ß√£o.  Abaixo est√£o os recursos que eu usei. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O livro "Java Persistence API and Hibernate"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o oficial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vlad M. Blog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Weakly Digest</a> - Daily Digest (indiretamente relacionado ao t√≥pico) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416851/">https://habr.com/ru/post/pt416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416841/index.html">Como testar hip√≥teses e ganhar dinheiro com o Swift usando testes divididos</a></li>
<li><a href="../pt416843/index.html">Motores de foguete nuclear e sistemas de propuls√£o el√©trica de foguete nuclear</a></li>
<li><a href="../pt416845/index.html">10 raz√µes para us√°-lo ou abandon√°-lo para sempre</a></li>
<li><a href="../pt416847/index.html">Ammyy Admin site novamente comprometido</a></li>
<li><a href="../pt416849/index.html">Oh meu c√≥digo. Como se tornar um administrador do sistema</a></li>
<li><a href="../pt416855/index.html">Bacharel pela Universidade Estadual de S√£o Petersburgo</a></li>
<li><a href="../pt416857/index.html">Constru√≠mos templos - no c√≥digo e na vida. Minha experi√™ncia no desenvolvimento do meu segundo aplicativo Android</a></li>
<li><a href="../pt416859/index.html">Conhe√ßa Tudo de Uma Vez Reagir Boilerplate de Maximilian Stoiber v3.6.0</a></li>
<li><a href="../pt416863/index.html">Uma nova maneira de apresentar expositores</a></li>
<li><a href="../pt416865/index.html">Design retro para o primeiro console port√°til do distante 1979</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>