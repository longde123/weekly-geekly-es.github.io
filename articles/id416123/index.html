<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 🚿 🥣 Pengakuan barang di rak menggunakan jaringan saraf menggunakan teknologi Keras dan Tensorflow Object Detection API 🐌 👩🏾‍🚒 🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini kita akan berbicara tentang penggunaan jaringan saraf convolutional untuk menyelesaikan tugas bisnis praktis mengembalikan realogram...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengakuan barang di rak menggunakan jaringan saraf menggunakan teknologi Keras dan Tensorflow Object Detection API</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/416123/">  Dalam artikel ini kita akan berbicara tentang penggunaan jaringan saraf convolutional untuk menyelesaikan tugas bisnis praktis mengembalikan realogram dari foto-foto rak dengan barang.  Menggunakan Tensorflow Object Detection API, kami akan melatih model pencarian / pelokalan.  Kami akan meningkatkan kualitas pencarian produk kecil dalam foto resolusi tinggi menggunakan jendela mengambang dan algoritma penindasan yang tidak maksimal.  Di Keras, kami menerapkan klasifikasi barang berdasarkan merek.  Secara paralel, kami akan membandingkan pendekatan dan hasil dengan keputusan 4 tahun yang lalu.  Semua data yang digunakan dalam artikel tersedia untuk diunduh, dan kode yang berfungsi penuh ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> dan dirancang sebagai tutorial. <br><br><img src="https://habrastorage.org/webt/aw/27/ar/aw27argaeseqsgos5cbpwdwt89s.jpeg"><br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Apa itu planogram?  Diagram tata letak tampilan barang pada peralatan perdagangan beton toko. <br><br>  Apa itu realogram?  Tata letak barang pada peralatan perdagangan tertentu yang ada di toko di sini dan sekarang. <br><br>  Planogram - sebagaimana mestinya, realogram - apa yang kita miliki. <br><br><img src="https://habrastorage.org/webt/ym/oo/ew/ymooewlirqpaosatarrenno8caw.jpeg"><br><br>  Sampai sekarang, di banyak toko, mengelola sisa barang di rak, rak, konter, rak adalah pekerjaan manual.  Ribuan karyawan memeriksa ketersediaan produk secara manual, menghitung saldo, memeriksa lokasi dengan persyaratan.  Itu mahal, dan kesalahan sangat mungkin terjadi.  Tampilan yang salah atau kurangnya barang menyebabkan penjualan lebih rendah. <br><br>  Juga, banyak produsen mengadakan perjanjian dengan pengecer untuk memajang barang-barang mereka.  Dan karena ada banyak produsen, di antara mereka perjuangan untuk tempat terbaik di rak dimulai.  Semua orang ingin produknya terletak di tengah di seberang mata pembeli dan menempati area seluas mungkin.  Ada kebutuhan untuk audit berkelanjutan. <br><br>  Ribuan pedagang bergerak dari satu toko ke toko untuk memastikan bahwa produk perusahaan mereka ada di rak dan disajikan sesuai dengan kontrak.  Terkadang mereka malas: jauh lebih menyenangkan untuk menyusun laporan tanpa meninggalkan rumah Anda daripada pergi ke outlet ritel.  Ada kebutuhan untuk audit permanen terhadap auditor. <br><br>  Secara alami, tugas otomatisasi dan penyederhanaan proses ini telah dipecahkan sejak lama.  Salah satu bagian tersulit adalah pemrosesan gambar: menemukan dan mengenali produk.  Dan hanya relatif baru-baru ini tugas ini telah disederhanakan sehingga untuk kasus tertentu dalam bentuk yang disederhanakan, solusi lengkapnya dapat dijelaskan dalam satu artikel.  Ini yang akan kita lakukan. <br><br>  Artikel berisi kode minimal (hanya untuk kasus-kasus ketika kode lebih jelas daripada teks).  Solusi lengkap tersedia sebagai tutorial bergambar di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notebook jupyter</a> .  Artikel ini tidak mengandung deskripsi arsitektur jaringan saraf, prinsip-prinsip neuron, rumus matematika.  Dalam artikel tersebut, kami menggunakannya sebagai alat teknik, tanpa terlalu banyak membahas detail perangkatnya. <br><br><h3>  Data dan Pendekatan </h3><br>  Seperti halnya pendekatan berbasis data, solusi jaringan saraf membutuhkan data.  Anda juga dapat merakitnya secara manual: untuk menangkap beberapa ratus penghitung dan menandainya menggunakan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LabelImg</a> .  Anda dapat memesan markup, misalnya, di Yandex.Tolok. <br><br><img src="https://habrastorage.org/webt/ji/he/lv/jihelvxh9vkmixjzsxink1nknya.jpeg"><br><br>  Kami tidak dapat mengungkapkan rincian proyek nyata, oleh karena itu kami akan menjelaskan teknologi pada data terbuka.  Berbelanja dan mengambil foto terlalu malas (dan kita tidak akan dipahami di sana), dan keinginan untuk melakukan markup foto yang ditemukan di Internet pada kita sendiri berakhir setelah objek rahasia yang keseratus.  Untungnya, kebetulan saya menemukan arsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grocery Dataset</a> . <br><br>  Pada 2014, karyawan Idea Teknoloji, Istanbul, Turki mengunggah 354 foto dari 40 toko yang dibuat di 4 kamera.  Pada masing-masing foto ini, mereka menyorot dengan persegi panjang total beberapa ribu objek, beberapa di antaranya diklasifikasikan ke dalam 10 kategori. <br><br>  Ini adalah gambar bungkus rokok.  Kami tidak mempromosikan atau mempromosikan merokok.  Tidak ada yang lebih netral.  Kami berjanji bahwa di mana saja dalam artikel ini, di mana situasinya memungkinkan, kami akan menggunakan foto-foto kucing. <br><br><img src="https://habrastorage.org/webt/04/8x/ek/048xekrylrnspiwd7vefbux_kgu.jpeg"><br><br>  Selain foto rak yang ditandai, mereka menulis artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menuju Pengakuan Produk Eceran di Rak Kelontong</a> dengan solusi untuk masalah lokalisasi dan klasifikasi.  Ini menetapkan semacam titik referensi: solusi kami menggunakan pendekatan baru seharusnya menjadi lebih sederhana dan lebih akurat, jika tidak itu tidak menarik.  Pendekatan mereka terdiri dari kombinasi algoritma: <br><br><img src="https://habrastorage.org/webt/j5/p4/t_/j5p4t_ul9ungv_luvlzxa5aa1gi.jpeg"><br><br>  Baru-baru ini, jaringan saraf convolutional (CNN) telah merevolusi bidang visi komputer dan benar-benar mengubah pendekatan untuk memecahkan masalah tersebut.  Selama beberapa tahun terakhir, teknologi ini telah tersedia untuk berbagai pengembang, dan API tingkat tinggi seperti Keras telah secara signifikan menurunkan ambang entri mereka.  Sekarang, hampir semua pengembang dapat menggunakan kekuatan penuh dari jaringan saraf convolutional setelah hanya beberapa hari berkencan.  Artikel ini menjelaskan penggunaan teknologi ini menggunakan contoh, menunjukkan bagaimana seluruh kaskade algoritma dapat dengan mudah diganti dengan hanya dua jaringan saraf tanpa kehilangan keakuratan. <br><br>  Kami akan memecahkan masalah dalam langkah-langkah: <br><br><ul><li>  Persiapan data.  Kami memompa arsip dan mengubahnya menjadi tampilan yang nyaman untuk bekerja. </li><li>  Klasifikasi merek.  Kami memecahkan masalah klasifikasi menggunakan jaringan saraf. </li><li>  Cari produk di foto.  Kami melatih jaringan saraf untuk mencari barang. </li><li>  Implementasi pencarian.  Kami akan meningkatkan kualitas deteksi menggunakan jendela mengambang dan algoritma untuk menekan non-maksimum. </li><li>  Kesimpulan  Jelaskan secara singkat mengapa kehidupan nyata jauh lebih rumit daripada contoh ini. </li></ul><br><h3>  Teknologi </h3><br>  Teknologi utama yang akan kami gunakan: Tensorflow, Keras, Tensorflow Object Detection API, OpenCV.  Meskipun Windows dan Mac OS cocok untuk bekerja dengan Tensorflow, kami tetap merekomendasikan menggunakan Ubuntu.  Bahkan jika Anda belum pernah bekerja dengan sistem operasi ini sebelumnya, menggunakannya akan menghemat banyak waktu.  Menginstal Tensorflow untuk bekerja dengan GPU adalah topik yang pantas mendapatkan artikel terpisah.  Untungnya, artikel seperti itu sudah ada.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menginstal TensorFlow di Ubuntu 16.04 dengan GPU Nvidia</a> .  Beberapa instruksi darinya mungkin sudah ketinggalan zaman. <br><br>  <b>Langkah 1. Mempersiapkan data ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan github</a> )</b> <br><br>  Langkah ini, sebagai suatu peraturan, membutuhkan waktu lebih lama dari simulasi itu sendiri.  Untungnya, kami menggunakan data yang sudah jadi, yang kami konversi ke formulir yang kami butuhkan. <br><br>  Anda dapat mengunduh dan menghapus zip dengan cara ini: <br><br><pre><code class="bash hljs">wget https://github.com/gulvarol/grocerydataset/releases/download/1.0/GroceryDataset_part1.tar.gz wget https://github.com/gulvarol/grocerydataset/releases/download/1.0/GroceryDataset_part2.tar.gz tar -xvzf GroceryDataset_part1.tar.gz tar -xvzf GroceryDataset_part2.tar.gz</code> </pre> <br>  Kami mendapatkan struktur folder berikut: <br><br><img src="https://habrastorage.org/webt/n1/yi/8n/n1yi8n3faxzmxia70bxsee-b69u.jpeg"><br><br>  Kami akan menggunakan informasi dari direktori ShelfImages dan ProductImagesFromShelves. <br>  ShelfImages berisi gambar-gambar rak itu sendiri.  Dalam namanya, pengidentifikasi rak dengan pengidentifikasi gambar dikodekan.  Mungkin ada beberapa gambar satu rak.  Misalnya, satu foto secara keseluruhan dan 5 foto di bagian dengan persimpangan. <br><br>  File C1_P01_N1_S2_2.JPG (rack C1_P01, snapshot N1_S2_2): <br><br><img src="https://habrastorage.org/webt/nv/jd/or/nvjdorlqwj1qc7asuzktk7dqccs.jpeg"><br><br>  Kami menelusuri semua file dan mengumpulkan informasi dalam bingkai data panda photos_df: <br><br><img src="https://habrastorage.org/webt/us/zq/zq/uszqzqw3haortnmdvscxp0sq1cq.png"><br>  ProductImagesFromShelves berisi foto cut-out barang dari rak di 11 subdirektori: 0 - tidak diklasifikasikan, 1 - Marlboro, 2 - Kent, dll.  Agar tidak mengiklankannya, kami hanya akan menggunakan nomor kategori tanpa menyebutkan nama.  File dalam nama berisi informasi tentang rak, posisi dan ukuran paket di atasnya. <br><br>  File C1_P01_N1_S3_1.JPG_1276_1828_276_448.png dari direktori 1 (kategori 1, rak C1_P01, gambar N1_S3_1, koordinat sudut kiri atas (1276, 1828), lebar 276, tinggi 448): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/-x/pc/f0-xpc4nqkymbj-ycs1my_sldhi.jpeg"></div><br>  Kami tidak membutuhkan foto-foto paket individu sendiri (kami akan memotongnya dari gambar-gambar rak), dan kami mengumpulkan informasi tentang kategori dan posisi mereka dalam bingkai data panda products_df: <br><br><img src="https://habrastorage.org/webt/0x/nh/rv/0xnhrvv5nibludwh7svn54hj_ba.png"><br>  Pada langkah yang sama, kami membagi semua informasi kami menjadi dua bagian: melatih untuk pelatihan dan validasi untuk pelatihan pemantauan.  Tentu saja, ini tidak layak dilakukan dalam proyek nyata.  Dan juga jangan percaya pada mereka yang melakukan ini.  Anda setidaknya harus mengalokasikan tes lain untuk ujian akhir.  Tetapi bahkan dengan pendekatan yang tidak terlalu jujur ​​ini, penting bagi kita untuk tidak menipu diri sendiri. <br><br>  Seperti yang telah kita catat, mungkin ada beberapa foto dari satu rak.  Dengan demikian, paket yang sama dapat jatuh ke beberapa gambar.  Oleh karena itu, kami menyarankan Anda untuk memecah bukan oleh gambar, dan bahkan lebih lagi bukan dengan paket, tetapi oleh rak.  Ini diperlukan agar tidak terjadi bahwa objek yang sama, yang diambil dari sudut yang berbeda, berakhir di kereta dan validasi. <br><br>  Kami membuat pemisahan 70/30 (30% dari rak digunakan untuk validasi, sisanya untuk pelatihan): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># get distinct shelves shelves = list(set(photos_df['shelf_id'].values)) # use train_test_split from sklearn shelves_train, shelves_validation, _, _ = train_test_split(   shelves, shelves, test_size=0.3, random_state=6) # mark all records in data frames with is_train flag def is_train(shelf_id): return shelf_id in shelves_train photos_df['is_train'] = photos_df.shelf_id.apply(is_train) products_df['is_train'] = products_df.shelf_id.apply(is_train)</span></span></code> </pre> <br>  Kami akan memastikan bahwa ketika kami berpisah, ada cukup perwakilan dari setiap kelas untuk pelatihan dan validasi: <br><img src="https://habrastorage.org/webt/9n/w_/xj/9nw_xjw1qiqc21sbi5q3s0pv3_q.jpeg"><br>  Warna biru menunjukkan jumlah produk dalam kategori untuk validasi, dan oranye untuk pelatihan.  Situasinya tidak terlalu baik dengan kategori 3 untuk validasi, tetapi pada prinsipnya ada beberapa perwakilannya. <br><br>  Pada tahap persiapan data, penting untuk tidak membuat kesalahan, karena semua pekerjaan lebih lanjut didasarkan pada hasilnya.  Kami masih membuat satu kesalahan dan menghabiskan banyak waktu senang mencoba memahami mengapa kualitas model sangat biasa-biasa saja.  Sudah merasa seperti pecundang terhadap teknologi "sekolah tua", sampai Anda secara tidak sengaja memperhatikan bahwa beberapa foto asli diputar 90 derajat, dan beberapa dilakukan terbalik. <br><br>  Pada saat yang sama, markup dibuat seolah-olah foto berorientasi dengan benar.  Setelah perbaikan cepat, segalanya menjadi lebih menyenangkan. <br><br>  Kami akan menyimpan data kami dalam file pkl untuk digunakan dalam langkah-langkah berikut.  Total, kami memiliki: <br><br><ul><li>  Direktori foto-foto rak dan bagian-bagiannya dengan bundel, </li><li>  Bingkai data dengan deskripsi setiap rak dengan catatan apakah itu dimaksudkan untuk pelatihan, </li><li>  Kerangka data dengan informasi tentang semua produk di rak, yang menunjukkan posisi, ukuran, kategori, dan penandaan mereka untuk pelatihan. </li></ul><br>  Untuk verifikasi, kami menampilkan satu rak sesuai dengan data kami: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># function to display shelf photo with rectangled products def draw_shelf_photo(file):   file_products_df = products_df[products_df.file == file]   coordinates = file_products_df[['xmin', 'ymin', 'xmax', 'ymax']].values   im = cv2.imread(f'{shelf_images}{file}')   im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)      for xmin, ymin, xmax, ymax in coordinates:       cv2.rectangle(im, (xmin, ymin), (xmax, ymax), (0, 255, 0), 5)   plt.imshow(im) # draw one photo to check our data fig = plt.gcf() fig.set_size_inches(18.5, 10.5) draw_shelf_photo('C3_P07_N1_S6_1.JPG')</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/1m/7a/xr/1m7axrc3gcdvgt1sg0sc9-dbs0y.png"><br><br>  <b>Langkah 2. Klasifikasi berdasarkan merek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan di github</a> )</b> <br><br>  Klasifikasi gambar adalah tugas utama di bidang visi komputer.  Masalahnya adalah “celah semantik”: fotografi hanyalah matriks besar angka [0, 255].  Misalnya, 800x600x3 (3 saluran RGB). <br><br><img src="https://habrastorage.org/webt/0w/mi/rx/0wmirxot0tx0_dl_b-m_gpdunse.jpeg"><br><br>  Mengapa tugas ini sulit: <br><br><img src="https://habrastorage.org/webt/gx/il/fh/gxilfhn6woijdjngbgrbgfzgjmo.png"><br><br>  Seperti yang telah kami katakan, penulis data yang kami gunakan mengidentifikasi 10 merek.  Ini adalah tugas yang sangat disederhanakan, karena ada lebih banyak merek rokok di rak.  Tetapi semua yang tidak termasuk dalam 10 kategori ini dikirim ke 0 - tidak diklasifikasikan: <br><br><img src="https://habrastorage.org/webt/wv/-j/hm/wv-jhmn18kt8ta1zhsai4fzdxbq.png">  " <br><br>  Artikel mereka menawarkan algoritma klasifikasi seperti itu dengan akurasi total 92%: <br><img src="https://habrastorage.org/webt/vv/d3/ub/vvd3ubvr_tvjxasrwvs7jap6h7o.jpeg"><br>  Apa yang akan kita lakukan: <br><br><ul><li>  Kami akan menyiapkan data untuk pelatihan, </li><li>  Kami melatih jaringan saraf convolutional dengan arsitektur ResNet v1, </li><li>  Periksa foto untuk validasi. </li></ul><br>  Kedengarannya “bervolume”, tetapi kami hanya menggunakan contoh Keras '“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Melatih ResNet pada dataset CIFAR10</a> ” dengan mengambil darinya fungsi membuat ResNet v1. <br><br>  Untuk memulai proses pelatihan, Anda perlu menyiapkan dua larik: x - foto paket dengan dimensi (jumlah paket, tinggi, lebar, 3) dan y - kategorinya dengan dimensi (jumlah paket, 10).  Array y berisi apa yang disebut vektor 1-panas.  Jika kategori paket untuk pelatihan memiliki nomor 2 (dari 0 hingga 9), maka ini sesuai dengan vektor [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]. <br><br>  Pertanyaan penting adalah apa yang harus dilakukan dengan lebar dan tinggi, karena semua foto diambil dengan resolusi berbeda dari jarak yang berbeda.  Kita perlu memilih beberapa ukuran tetap, yang dapat kita bawa semua gambar paket.  Ukuran tetap ini adalah meta-parameter yang menentukan bagaimana jaringan saraf kita akan melatih dan bekerja. <br><br>  Di satu sisi, saya ingin membuat ukuran ini sebesar mungkin sehingga tidak ada satu detail gambar yang diperhatikan.  Di sisi lain, dengan jumlah data pelatihan kami yang sedikit, ini dapat mengarah pada pelatihan ulang cepat: model ini akan bekerja dengan sempurna pada data pelatihan, tetapi buruk pada data validasi.  Kami memilih ukuran 120x80, mungkin pada ukuran yang berbeda kami akan mendapatkan hasil yang lebih baik.  Fungsi zoom: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># resize pack to fixed size SHAPE_WIDTH x SHAPE_HEIGHT def resize_pack(pack):   fx_ratio = SHAPE_WIDTH / pack.shape[1]   fy_ratio = SHAPE_HEIGHT / pack.shape[0]      pack = cv2.resize(pack, (0, 0), fx=fx_ratio, fy=fy_ratio)   return pack[0:SHAPE_HEIGHT, 0:SHAPE_WIDTH]</span></span></code> </pre> <br>  Skala dan tampilkan satu paket untuk verifikasi.  Nama merek sulit dibaca oleh seseorang, mari kita lihat bagaimana jaringan saraf akan mengatasi tugas klasifikasi: <br><br><img src="https://habrastorage.org/webt/z_/8p/0f/z_8p0f5kuxx27mneryilqv81ols.png"><br><br>  Setelah menyiapkan sesuai dengan flag yang diperoleh pada langkah sebelumnya, kita memecah array x dan y menjadi x_train / x_validation dan y_train / y_validation, kita mendapatkan: <br><br><pre> <code class="bash hljs">x_train shape: (1969, 120, 80, 3) y_train shape: (1969, 10) 1969 train samples 775 validation samples</code> </pre><br>  Data disiapkan, kami menyalin fungsi konstruktor jaringan saraf arsitektur ResNet v1 dari contoh Keras: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resnet_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input_shape, depth, num_classes=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span>   …</code> </pre> <br>  Kami membangun model: <br><br><pre> <code class="python hljs">model = resnet_v1(input_shape=x_train.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>:], depth=depth, num_classes=num_classes) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>,             optimizer=Adam(lr=lr_schedule(<span class="hljs-number"><span class="hljs-number">0</span></span>)), metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>])</code> </pre> <br>  Kami memiliki kumpulan data yang cukup terbatas.  Oleh karena itu, untuk mencegah model melihat foto yang sama setiap kali selama pelatihan, kami menggunakan augmentasi: menggeser gambar secara acak dan memutarnya sedikit.  Keras menyediakan serangkaian opsi untuk ini: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># This will do preprocessing and realtime data augmentation: datagen = ImageDataGenerator(   featurewise_center=False,  # set input mean to 0 over the dataset   samplewise_center=False,  # set each sample mean to 0   featurewise_std_normalization=False,  # divide inputs by std of the dataset   samplewise_std_normalization=False,  # divide each input by its std   zca_whitening=False,  # apply ZCA whitening   rotation_range=5,  # randomly rotate images in the range (degrees, 0 to 180)   width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)   height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)   horizontal_flip=False,  # randomly flip images   vertical_flip=False)  # randomly flip images datagen.fit(x_train)</span></span></code> </pre> <br>  Kami memulai proses pelatihan. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># let's run training process, 20 epochs is enough batch_size = 50 epochs = 15 model.fit_generator(datagen.flow(x_train, y_train, batch_size=batch_size),                   validation_data=(x_validation, y_validation),                   epochs=epochs, verbose=1, workers=4,                   callbacks=[LearningRateScheduler(lr_schedule)])</span></span></code> </pre> <br>  Setelah pelatihan dan evaluasi, kami mendapatkan akurasi di wilayah 92%.  Anda mungkin mendapatkan akurasi yang berbeda: hanya ada sedikit data, jadi akurasi sangat tergantung pada keberhasilan partisi.  Pada partisi ini, kami tidak mendapatkan akurasi secara signifikan lebih tinggi daripada yang ditunjukkan dalam artikel, tetapi kami praktis tidak melakukan apa pun dan menulis sedikit kode.  Selain itu, kami dapat dengan mudah menambahkan kategori baru, dan keakuratan seharusnya (secara teori) meningkat secara signifikan jika kami menyiapkan lebih banyak data. <br><br>  Untuk menarik, bandingkan matriks kebingungan: <br><img src="https://habrastorage.org/webt/ee/ns/tm/eenstmjcconudxyjjkmtpzcdmow.jpeg"><br>  Hampir semua kategori jaringan saraf kita mendefinisikan lebih baik, kecuali untuk kategori 4 dan 7. Juga berguna untuk melihat perwakilan paling terang dari setiap sel matriks kebingungan: <br><img src="https://habrastorage.org/webt/qv/tm/lw/qvtmlwxgqvbdhut73zgsbbtfqqo.jpeg"><br>  Anda juga dapat memahami mengapa Parlemen salah mengira Camel, tetapi mengapa Winston salah dengan Lucky Strike benar-benar tidak dapat dipahami, tetapi mereka tidak memiliki kesamaan.  Ini adalah masalah utama dari jaringan saraf - ketidakjelasan lengkap dari apa yang terjadi di dalam.  Anda dapat, tentu saja, memvisualisasikan beberapa lapisan, tetapi bagi kami visualisasi ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/w1/tn/et/w1tnetor61yz-uwvmjlserwvh3m.jpeg"><br><br>  Peluang nyata untuk meningkatkan kualitas pengakuan dalam kondisi kami adalah menambahkan lebih banyak foto. <br><br>  Jadi, classifiernya sudah siap.  Pergi ke detektor. <br><br>  <b>Langkah 3. Cari produk di foto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan di github</a> )</b> <br><br>  Tugas-tugas penting berikut dalam bidang visi komputer adalah segmentasi semantik, lokalisasi, pencarian objek, dan segmentasi instance. <br><br><img src="https://habrastorage.org/webt/z0/y9/bf/z0y9bfe7f6qp143c3wubj8rvnd8.jpeg"><br><br>  Tugas kita membutuhkan deteksi objek.  Artikel 2014 menawarkan pendekatan berdasarkan metode Viola-Jones dan HOG dengan akurasi visual: <br><br><img src="https://habrastorage.org/webt/11/jt/8j/11jt8jcggyutkrxyelswr8psm8s.jpeg"><br><br>  Berkat penggunaan pembatasan statistik tambahan, akurasinya sangat baik: <br><br><img src="https://habrastorage.org/webt/od/nb/yl/odnbylwn0yo-k92q_nu6mazz8fq.jpeg"><br><br>  Sekarang tugas pengenalan objek berhasil diselesaikan dengan bantuan jaringan saraf.  Kami akan menggunakan sistem Tensorflow Object Detection API dan melatih jaringan saraf dengan arsitektur Mobilenet V1 SSD.  Pelatihan model seperti itu dari awal membutuhkan banyak data dan bisa memakan waktu berhari-hari, jadi kami menggunakan model yang dilatih tentang data COCO sesuai dengan prinsip pembelajaran transfer. <br><br>  Konsep kunci dari pendekatan ini adalah ini.  Mengapa seorang anak tidak perlu menunjukkan jutaan objek sehingga ia belajar menemukan dan membedakan bola dari kubus?  Karena anak memiliki 500 juta tahun perkembangan korteks visual.  Evolusi telah menjadikan visi sistem sensorik terbesar.  Hampir 50% (tetapi ini tidak akurat) dari neuron otak manusia bertanggung jawab untuk pemrosesan gambar.  Orang tua hanya dapat menunjukkan bola dan kubus, dan kemudian mengoreksi anak itu beberapa kali sehingga ia dengan sempurna menemukan dan membedakan satu dari yang lainnya. <br><br>  Dari sudut pandang filosofis (dengan perbedaan teknis lebih dari umum), transfer pembelajaran dalam jaringan saraf bekerja dengan cara yang sama.  Jaringan saraf convolutional terdiri dari level-level, yang masing-masingnya mendefinisikan bentuk-bentuk yang semakin kompleks: ia mengidentifikasi titik-titik kunci, menggabungkannya ke dalam garis-garis, yang pada gilirannya menggabungkan menjadi angka-angka.  Dan hanya pada tingkat terakhir dari keseluruhan tanda yang ditemukan menentukan objek. <br><br>  Objek dunia nyata memiliki banyak kesamaan.  Saat mentransfer pembelajaran, kami menggunakan level definisi fitur dasar yang sudah terlatih dan hanya melatih layer yang bertanggung jawab untuk mengidentifikasi objek.  Untuk melakukan ini, beberapa ratus foto dan beberapa jam pengoperasian GPU biasa sudah cukup bagi kami.  Jaringan ini awalnya dilatih pada dataset COCO (Microsoft Common Objects in Context), yang terdiri dari 91 kategori dan 2.500.000 gambar!  Banyak, meski bukan 500 juta tahun evolusi. <br><br>  Melihat sedikit ke depan, animasi-gif ini (agak lambat, jangan gulir segera) dari tensorboard memvisualisasikan proses pembelajaran.  Seperti yang Anda lihat, model mulai menghasilkan hasil yang benar-benar berkualitas tinggi segera, dan kemudian muncul penggilingan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2d/356/aa4/d2d356aa49bedf31aa918930d8bf1545.gif" alt="gambar"><br><br>  "Pelatih" sistem Tensorflow Object Detection API dapat secara independen melakukan augmentasi, memotong bagian gambar acak untuk pelatihan, dan memilih contoh "negatif" (bagian foto yang tidak mengandung benda apa pun).  Secara teori, tidak perlu preprocessing foto.  Namun, pada komputer di rumah dengan HDD dan RAM dalam jumlah kecil, ia menolak untuk bekerja dengan gambar beresolusi tinggi: pada awalnya ia menggantung lama, berkarat dengan disk, kemudian terbang keluar. <br><br>  Hasilnya, kami mengkompres foto ke ukuran 1000x1000 piksel sambil mempertahankan rasio aspek.  Tetapi karena ketika mengompresi foto besar, banyak tanda hilang, beberapa kotak pertama ukuran acak dipotong dari setiap foto rak dan diperas menjadi 1000x1000.  Akibatnya, paket dalam resolusi tinggi (tetapi tidak cukup) dan dalam jumlah kecil (tetapi banyak) masuk ke dalam data pelatihan.  Kami ulangi: langkah ini terpaksa dan, kemungkinan besar, sama sekali tidak perlu, dan mungkin berbahaya. <br><br>  Foto yang disiapkan dan dikompresi disimpan dalam direktori yang terpisah (eval dan kereta), dan deskripsi mereka (dengan bundel yang terkandung di dalamnya) dibentuk dalam bentuk dua bingkai data panda (train_df dan eval_df): <br><br><img src="https://habrastorage.org/webt/dl/lx/pn/dllxpn03xu5us7wr6h7y3rgzayg.png"><br>  Sistem API Deteksi Objek Tensorflow membutuhkan input untuk disajikan sebagai file tfrecord.  Anda dapat membentuknya menggunakan utilitas, tetapi kami akan membuatnya menjadi kode: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_text_to_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row_label)</span></span></span><span class="hljs-function">:</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> row_label == <span class="hljs-string"><span class="hljs-string">'pack'</span></span>:       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:       <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df, group)</span></span></span><span class="hljs-function">:</span></span>   data = namedtuple(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, [<span class="hljs-string"><span class="hljs-string">'filename'</span></span>, <span class="hljs-string"><span class="hljs-string">'object'</span></span>])   gb = df.groupby(group)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [data(filename, gb.get_group(x))           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename, x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(gb.groups.keys(), gb.groups)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_tf_example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(group, path)</span></span></span><span class="hljs-function">:</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> tf.gfile.GFile(os.path.join(path, <span class="hljs-string"><span class="hljs-string">'{}'</span></span>.format(group.filename)), <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fid:       encoded_jpg = fid.read()   encoded_jpg_io = io.BytesIO(encoded_jpg)   image = Image.open(encoded_jpg_io)   width, height = image.size   filename = group.filename.encode(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)   image_format = <span class="hljs-string"><span class="hljs-string">b'jpg'</span></span>   xmins = []   xmaxs = []   ymins = []   ymaxs = []   classes_text = []   classes = []   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> group.object.iterrows():       xmins.append(row[<span class="hljs-string"><span class="hljs-string">'xmin'</span></span>] / width)       xmaxs.append(row[<span class="hljs-string"><span class="hljs-string">'xmax'</span></span>] / width)       ymins.append(row[<span class="hljs-string"><span class="hljs-string">'ymin'</span></span>] / height)       ymaxs.append(row[<span class="hljs-string"><span class="hljs-string">'ymax'</span></span>] / height)       classes_text.append(row[<span class="hljs-string"><span class="hljs-string">'class'</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>))       classes.append(class_text_to_int(row[<span class="hljs-string"><span class="hljs-string">'class'</span></span>]))   tf_example = tf.train.Example(features=tf.train.Features(feature={       <span class="hljs-string"><span class="hljs-string">'image/height'</span></span>: dataset_util.int64_feature(height),       <span class="hljs-string"><span class="hljs-string">'image/width'</span></span>: dataset_util.int64_feature(width),       <span class="hljs-string"><span class="hljs-string">'image/filename'</span></span>: dataset_util.bytes_feature(filename),       <span class="hljs-string"><span class="hljs-string">'image/source_id'</span></span>: dataset_util.bytes_feature(filename),       <span class="hljs-string"><span class="hljs-string">'image/encoded'</span></span>: dataset_util.bytes_feature(encoded_jpg),       <span class="hljs-string"><span class="hljs-string">'image/format'</span></span>: dataset_util.bytes_feature(image_format),       <span class="hljs-string"><span class="hljs-string">'image/object/bbox/xmin'</span></span>: dataset_util.float_list_feature(xmins),       <span class="hljs-string"><span class="hljs-string">'image/object/bbox/xmax'</span></span>: dataset_util.float_list_feature(xmaxs),       <span class="hljs-string"><span class="hljs-string">'image/object/bbox/ymin'</span></span>: dataset_util.float_list_feature(ymins),       <span class="hljs-string"><span class="hljs-string">'image/object/bbox/ymax'</span></span>: dataset_util.float_list_feature(ymaxs),       <span class="hljs-string"><span class="hljs-string">'image/object/class/text'</span></span>: dataset_util.bytes_list_feature(classes_text),       <span class="hljs-string"><span class="hljs-string">'image/object/class/label'</span></span>: dataset_util.int64_list_feature(classes),   }))   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tf_example <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_to_tf_records</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images_path, examples, dst_file)</span></span></span><span class="hljs-function">:</span></span>   writer = tf.python_io.TFRecordWriter(dst_file)   grouped = split(examples, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> group <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> grouped:       tf_example = create_tf_example(group, images_path)       writer.write(tf_example.SerializeToString())   writer.close() convert_to_tf_records(<span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{cropped_path}</span></span></span><span class="hljs-string">train/'</span></span>, train_df, <span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{detector_data_path}</span></span></span><span class="hljs-string">train.record'</span></span>) convert_to_tf_records(<span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{cropped_path}</span></span></span><span class="hljs-string">eval/'</span></span>, eval_df, <span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{detector_data_path}</span></span></span><span class="hljs-string">eval.record'</span></span>)</code> </pre><br>  Tetap bagi kami untuk menyiapkan direktori khusus dan memulai proses: <br><br><img src="https://habrastorage.org/webt/ld/yd/rb/ldydrbk3ivkixsx9kep69b5eyoy.jpeg"><br><br>  Strukturnya mungkin berbeda, tetapi kami merasa sangat nyaman. <br><br>  Direktori data berisi file yang telah kita buat dengan tfrecords (train.record dan eval.record), serta pack.pbtxt dengan jenis objek yang akan kita latih jaringan saraf.  Kami hanya memiliki satu jenis objek untuk didefinisikan, sehingga file ini sangat pendek: <br><br><img src="https://habrastorage.org/webt/pc/jw/x0/pcjwx0l3fc-wuzhiyt7lfo9xtcq.png"><br><br>  Direktori models (mungkin ada banyak model untuk menyelesaikan satu masalah) di direktori anak ssd_mobilenet_v1 berisi pengaturan untuk pelatihan dalam file .config, serta dua direktori kosong: train and eval.  Dalam kereta, "pelatih" akan menyimpan titik kontrol model, "evaluator" akan mengambilnya, menjalankannya pada data untuk evaluasi dan memasukkannya ke direktori eval.  Tensorboard akan melacak dua direktori ini dan menampilkan informasi proses. <br><br>  Penjelasan terperinci tentang struktur file konfigurasi, dll.  dapat ditemukan di <a href="">sini</a> dan di <a href="">sini</a> .  Instruksi pemasangan Tensorflow Object Detection API dapat ditemukan di <a href="">sini</a> . <br><br>  Kami masuk ke direktori models / research / object_detection dan mengempiskan model pra-terlatih: <br><br><pre> <code class="bash hljs">wget http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2017_11_17.tar.gz tar -xvzf ssd_mobilenet_v1_coco_2017_11_17.tar.gz</code> </pre><br>  Kami menyalin direktori pack_detector yang disiapkan oleh kami di sana. <br><br>  Pertama, mulailah proses pelatihan: <br><br><pre> <code class="bash hljs">python3 train.py --logtostderr \   --train_dir=pack_detector/models/ssd_mobilenet_v1/train/ \   --pipeline_config_path=pack_detector/models/ssd_mobilenet_v1/ssd_mobilenet_v1_pack.config</code> </pre><br>  Kami memulai proses evaluasi.  Kami tidak memiliki kartu video kedua, jadi kami meluncurkannya pada prosesor (menggunakan instruksi CUDA_VISIBLE_DEVICES = "").  Karena itu, ia akan sangat terlambat mengenai proses pelatihan, tetapi ini tidak terlalu buruk: <br><br><pre> <code class="bash hljs">CUDA_VISIBLE_DEVICES=<span class="hljs-string"><span class="hljs-string">""</span></span> python3 eval.py \   --logtostderr \   --checkpoint_dir=pack_detector/models/ssd_mobilenet_v1/train \   --pipeline_config_path=pack_detector/models/ssd_mobilenet_v1/ssd_mobilenet_v1_pack.config \   --eval_dir=pack_detector/models/ssd_mobilenet_v1/<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span></code> </pre> <br>  Kami memulai proses papan tensor: <br><br><pre> <code class="bash hljs">tensorboard --logdir=pack_detector/models/ssd_mobilenet_v1</code> </pre> <br>  Setelah itu kita bisa melihat grafik yang indah, serta karya nyata model pada estimasi data (gif di awal): <br><br><img src="https://habrastorage.org/webt/qc/wt/rl/qcwtrlmdugb4zgyhy6gnnaoia9w.jpeg"><br><br>  Proses pelatihan dapat dihentikan dan dilanjutkan kapan saja.  Ketika kami yakin bahwa modelnya cukup baik, kami menyimpan pos pemeriksaan dalam bentuk grafik inferensi: <br><br><pre> <code class="bash hljs">python3 export_inference_graph.py \   --input_type image_tensor \   --pipeline_config_path pack_detector/models/ssd_mobilenet_v1/ssd_mobilenet_v1_pack.config \   --trained_checkpoint_prefix pack_detector/models/ssd_mobilenet_v1/train/model.ckpt-13756 \   --output_directory pack_detector/models/ssd_mobilenet_v1/pack_detector_2018_06_03</code> </pre> <br>  Jadi, pada langkah ini kami mendapat grafik inferensi, yang dapat kita gunakan untuk mencari objek bundel.  Kami lolos penggunaannya. <br><br>  <b>Langkah 4. Menerapkan pencarian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan github</a> )</b> <br><br>  Kode inisialisasi pemuatan dan inferensi grafik ada di tautan di atas.  Fitur pencarian utama: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># let's write function that executes detection def run_inference_for_single_image(image, image_tensor, sess, tensor_dict):   # Run inference   expanded_dims = np.expand_dims(image, 0)   output_dict = sess.run(tensor_dict, feed_dict={image_tensor: expanded_dims})   # all outputs are float32 numpy arrays, so convert types as appropriate   output_dict['num_detections'] = int(output_dict['num_detections'][0])   output_dict['detection_classes'] = output_dict['detection_classes'][0].astype(np.uint8)   output_dict['detection_boxes'] = output_dict['detection_boxes'][0]   output_dict['detection_scores'] = output_dict['detection_scores'][0]   return output_dict # it is useful to be able to run inference not only on the whole image, # but also on its parts # cutoff - minimum detection score needed to take box def run_inference_for_image_part(image_tensor, sess, tensor_dict,                                image, cutoff, ax0, ay0, ax1, ay1):   boxes = []   im = image[ay0:ay1, ax0:ax1]   h, w, c = im.shape   output_dict = run_inference_for_single_image(im, image_tensor, sess, tensor_dict)   for i in range(100):       if output_dict['detection_scores'][i] &lt; cutoff:           break       y0, x0, y1, x1, score = *output_dict['detection_boxes'][i], \                               output_dict['detection_scores'][i]       x0, y0, x1, y1, score = int(x0*w), int(y0*h), \                               int(x1*w), int(y1*h), \                               int(score * 100)       boxes.append((x0+ax0, y0+ay0, x1+ax0, y1+ay0, score))   return boxes</span></span></code> </pre> <br>  Fungsi ini menemukan kotak terikat untuk paket tidak di seluruh foto, tetapi di bagiannya.  Fungsi ini juga menyaring persegi panjang yang ditemukan dengan skor deteksi rendah yang ditentukan dalam parameter cutoff. <br><br>  Ternyata menjadi dilema.  Di satu sisi, dengan cutoff tinggi, kami kehilangan banyak objek, di sisi lain, dengan cutoff rendah, kami mulai menemukan banyak objek yang bukan bundel.  Pada saat yang sama, kami masih menemukan tidak semuanya dan tidak secara ideal: <br><img src="https://habrastorage.org/webt/-u/ao/7y/-uao7ylwycrzrn3xqd1kfh2q0bs.jpeg"><br>  Namun, perhatikan bahwa jika kita menjalankan fungsi untuk sepotong kecil foto, pengakuannya hampir sempurna dengan cutoff = 0,9: <br><br><img src="https://habrastorage.org/webt/gg/qn/ia/ggqniasnrkggb6bjnarwum_6i48.jpeg"><br><br>  Ini disebabkan oleh fakta bahwa model MobileNet V1 SSD menerima 300x300 foto sebagai input.  Secara alami, dengan kompresi seperti itu banyak tanda hilang. <br><br>  Tetapi tanda-tanda ini tetap ada jika kita memotong sebuah kotak kecil berisi beberapa paket.  Ini menyarankan ide untuk menggunakan jendela mengambang: kita berlari melalui kotak kecil di foto dan mengingat semua yang kami temukan. <br><br><img src="https://habrastorage.org/webt/zn/7s/dz/zn7sdzl4wcb9dwugzkxilg2d2hk.jpeg"><br><br>  :          ,     .         .   :          (detection score),  ,    ,        overlapTresh (       ): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># function for non-maximum suppression def non_max_suppression(boxes, overlapThresh):   if len(boxes) == 0:       return np.array([]).astype("int")   if boxes.dtype.kind == "i":       boxes = boxes.astype("float")   pick = []   x1 = boxes[:,0]   y1 = boxes[:,1]   x2 = boxes[:,2]   y2 = boxes[:,3]   sc = boxes[:,4]   area = (x2 - x1 + 1) * (y2 - y1 + 1)   idxs = np.argsort(sc)   while len(idxs) &gt; 0:       last = len(idxs) - 1       i = idxs[last]       pick.append(i)       xx1 = np.maximum(x1[i], x1[idxs[:last]])       yy1 = np.maximum(y1[i], y1[idxs[:last]])       xx2 = np.minimum(x2[i], x2[idxs[:last]])       yy2 = np.minimum(y2[i], y2[idxs[:last]])       w = np.maximum(0, xx2 - xx1 + 1)       h = np.maximum(0, yy2 - yy1 + 1)       #todo fix overlap-contains...       overlap = (w * h) / area[idxs[:last]]              idxs = np.delete(idxs, np.concatenate(([last],           np.where(overlap &gt; overlapThresh)[0])))     return boxes[pick].astype("int")</span></span></code> </pre> <br>     : <br><br><img src="https://habrastorage.org/webt/go/hd/yz/gohdyzvwuyu8ja4w893big9c1yy.jpeg"><br><br>          : <br><br><img src="https://habrastorage.org/webt/jm/oi/da/jmoida7irvm4u3drey8nu6g00kw.jpeg"><br><br>   ,           ,    . <br><br><h3>  Kesimpulan </h3><br>       «»:         ,       . ,    ,         ..    . <br><br>       ,    ,    : <br><br><ol><li>  150  ,     ,   , </li><li>        3-7  , </li><li>   100    , </li><li>        , </li><li>        (), </li><li>    (,  ), </li><li>    ,        «», </li><li>  ,   ,     (SSD  ), </li><li>      ,  , </li><li>  . </li></ol><br>         ,      ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416123/">https://habr.com/ru/post/id416123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416111/index.html">Konversi data GraphQL untuk komponen CustomTreeData dari DevExtreme-Reactive</a></li>
<li><a href="../id416113/index.html">Steven Wolfram: Kenangan Steve Jobs</a></li>
<li><a href="../id416115/index.html">10 kesalahan desain kecil yang masih kami buat</a></li>
<li><a href="../id416119/index.html">Posting Jumat pada hari Rabu: atas paket NPM yang paling "esensial"</a></li>
<li><a href="../id416121/index.html">Fujitsu Artificial Intelligence menghitung geometri bahan magnetik</a></li>
<li><a href="../id416125/index.html">Instalasi, pengaturan sistem dan kontrol untuk kamera</a></li>
<li><a href="../id416127/index.html">CUDA dan Remote GPU</a></li>
<li><a href="../id416129/index.html">Bagaimana AI belajar menghasilkan gambar kucing</a></li>
<li><a href="../id416131/index.html">Bagaimana menangani PD di Federasi Rusia dan tidak melanggar hukum</a></li>
<li><a href="../id416133/index.html">Pusat Data di Luar Negeri: Equinix LD8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>