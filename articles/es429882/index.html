<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöë üë©üèø‚Äçüéì üë∏üèΩ Control de LED RGB a trav√©s de microcontroladores Cypress UDB PSoC üõ∞Ô∏è üè¥‚Äç‚ò†Ô∏è üìé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Hace tiempo que quer√≠a aprender la t√©cnica de programar bloques UDB en los controladores Cypress PSoC, pero de alguna manera no me lleg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Control de LED RGB a trav√©s de microcontroladores Cypress UDB PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429882/"><img src="https://habrastorage.org/webt/is/cg/hl/iscghlsqtbktd8fhkstyrghp9ee.jpeg"><br><br><h2>  Introduccion </h2><br>  Hace tiempo que quer√≠a aprender la t√©cnica de programar bloques UDB en los controladores Cypress PSoC, pero de alguna manera no me llegaron las manos.  Y as√≠, surgi√≥ un problema en el que esto podr√≠a hacerse.  Al comprender los materiales de la red, me di cuenta de que las recomendaciones pr√°cticas para trabajar con UDB se limitan a diversas variaciones de contadores y PWM.  Por alguna raz√≥n, todos los autores hacen sus variaciones de estos dos ejemplos can√≥nicos, por lo que la descripci√≥n de algo m√°s puede ser interesante para los lectores. <br><a name="habracut"></a><br>  Entonces  Hubo un problema para administrar din√°micamente una larga l√≠nea de LED RGB WS2812B.  Se conocen enfoques cl√°sicos de este asunto.  Puede tomar el Arduino trivial, pero all√≠ la salida se realiza mediante programaci√≥n, por lo que mientras se emiten los datos, todo lo dem√°s est√° inactivo, de lo contrario los diagramas de temporizaci√≥n fallar√°n.  Puede tomar STM32 y enviar datos a trav√©s de DMA a PWM o de DMA a SPI.  Se conocen t√©cnicas.  Incluso, en un momento, personalmente control√© una l√≠nea de diecis√©is diodos a trav√©s de SPI.  Pero la sobrecarga es genial.  Un bit de datos en los LED ocupa 8 bits en la memoria para el caso de PWM y de 3 a 4 bits (dependiendo de la frialdad de PLL en el controlador) para SPI.  Si bien hay pocos LED, esto no da miedo, pero si hay, por ejemplo, un par de cientos, entonces 200 * 24 = 4800 bits = 600 bytes de datos √∫tiles deben almacenarse f√≠sicamente en un b√∫fer con una capacidad de m√°s de 4 kilobytes para la opci√≥n PWM o m√°s de 2 kilobytes para SPI- opciones.  Para la indicaci√≥n din√°mica de buffers, debe haber varios, y STM32F103 tiene RAM para todo sobre todo, 20 kilobytes.  No es que nos hayamos topado con una tarea irrealizable, pero una raz√≥n para verificar si esto se puede implementar en el PSoC sin tener que gastar RAM adicional es bastante importante. <br><br><h2>  Referencias te√≥ricas </h2><br>  Primero, descubramos qu√© tipo de bestia es esa UDB y c√≥mo funcionan con ella.  Maravillosas pel√≠culas de instrucciones del fabricante del controlador ayudar√°n en esto. <br><br>  Deber√≠a comenzar a mirar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> , y luego, al final de cada video, habr√° un enlace a la pr√≥xima serie.  Paso a paso, obtendr√° conocimientos b√°sicos y considerar√° el ejemplo can√≥nico "contador".  Bueno, y un sistema de control de sem√°foro. <br><br>  Casi lo mismo, pero cortado en peque√±os pedazos, puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">verlo aqu√≠</a> .  Mi video no se reprodujo, pero se puede descargar y ver localmente.  Entre otras cosas, tambi√©n hay un ejemplo can√≥nico de la implementaci√≥n de PWM. <br><br><h2>  Soluciones terminadas </h2><br>  Para no reinventar la rueda (y viceversa, para aprender la metodolog√≠a de la experiencia de otra persona), rebusqu√© en la red en busca de soluciones listas para controlar los LED RGB.  La soluci√≥n m√°s popular es StripLightLib.cylib.  Pero desde hace muchos a√±os tiene planes para agregar el soporte Agregar DMA.  Pero quiero probar una soluci√≥n que no dependa del procesador central.  Quiero comenzar el proceso y olvidarlo, centr√°ndome en preparar el siguiente marco. <br><br>  La soluci√≥n que se adapta a mis deseos se encontr√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel</a> . <br><br>  Todo se implementa all√≠ en UDB (pero los LED son solo una excusa, el objetivo es aprender UDB).  Hay soporte para DMA.  Y el proyecto all√≠ est√° claramente bellamente organizado. <br><br><h2>  Problemas de la soluci√≥n elegida como base </h2><br>  C√≥mo se organiza el "firmware" en el proyecto PSoC_DMA_NeoPixel, quienes lo deseen pueden verlo despu√©s de leer el art√≠culo.  Esto arreglar√° el material.  Por ahora, solo dir√© que primero simplifiqu√© la l√≥gica del firmware original sin reducir los recursos consumidos (pero se ha vuelto m√°s f√°cil de entender).  Luego comenz√≥ a experimentar con la sustituci√≥n de la l√≥gica del aut√≥mata, que promet√≠a una ganancia en recursos, pero se encontr√≥ con un problema grave.  Y as√≠ decidi√≥: ¬°no se elimina!  Y las vagas dudas comenzaron a atormentarme: ¬øten√≠a el autor ingl√©s el mismo problema?  Su demo parpadea muy bien con LED.  Pero, ¬øqu√© sucede si reemplazamos el hermoso relleno con "todas las unidades" y controlamos la salida no con nuestros ojos, sino con un osciloscopio? <br>  Entonces, de la forma m√°s cruda posible (incluso podr√≠a decir "brutalmente") formamos los datos: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (pPixelArray,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pPixelArray)); <span class="hljs-comment"><span class="hljs-comment">//Call NeoPixel update function (non blocking) to trigger DMA pixel update NP_Update();</span></span></code> </pre> <br>  Y aqu√≠ vemos esa imagen en un osciloscopio: <br><br><img src="https://habrastorage.org/webt/kv/u7/wu/kvu7wuciw7tafpf_cjjbp4m-gzw.png"><br><br>  El primer bit tiene un ancho diferente al resto.  Ped√≠ enviar todas las unidades, pero no todas se van.  Entre ellos cero!  Cambiar el escaneo: <br><br><img src="https://habrastorage.org/webt/2k/ev/mb/2kevmb_fna8e8oce9pkdwhaofcg.png"><br><br>  El ancho es diferente para cada octavo bit. <br><br>  En general, este ejemplo como soluci√≥n independiente no es adecuado, sino como fuente de inspiraci√≥n, simplemente perfecto.  En primer lugar, su inoperabilidad no es visible con el ojo (los LED a√∫n est√°n brillantes, el ojo no ve que brillan a la mitad), pero el c√≥digo est√° bien estructurado, es bueno tomarlo como base.  En segundo lugar, este ejemplo proporciona espacio para encontrar formas de simplificar, y en tercer lugar, te hace pensar c√≥mo solucionar el defecto.  ¬°Lo mismo es entender el material!  Entonces, una vez m√°s, despu√©s de leer el art√≠culo, recomiendo intentar analizar el ejemplo original, d√°ndome cuenta de c√≥mo funciona. <br><br><h2>  Parte pr√°ctica </h2><br>  Ahora comenzamos a practicar.  Estamos probando los aspectos principales del desarrollo de firmware para UDB.  Considere la relaci√≥n y las t√©cnicas b√°sicas.  Para hacer esto, abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi versi√≥n del proyecto</a> .  El bloque izquierdo almacena informaci√≥n sobre archivos de trabajo.  Por defecto, la pesta√±a <b>Fuente</b> est√° abierta.  La fuente principal del proyecto es el archivo <b>main.c.</b>  En realidad, no hay otros archivos de trabajo en el grupo <b>Archivos de origen</b> . <br><br><img src="https://habrastorage.org/webt/-n/xu/lm/-nxulmetonhzhf6lwlvr30f-2r8.png"><br><br>  El grupo <b>Fuente Generada</b> contiene funciones de biblioteca.  Es mejor no editarlos.  Despu√©s de cada cambio del "firmware" de UDB, este grupo se regenerar√°.  Entonces, ¬ød√≥nde est√° la descripci√≥n del c√≥digo para UDB en este idilio?  Para verlo, debe cambiar a la pesta√±a <b>Componentes</b> : <br><br><img src="https://habrastorage.org/webt/qb/yj/ku/qbyjkuvng7ibcdlhiftcf5qld6o.png"><br><br>  El autor del proyecto original hizo un conjunto de componentes de dos niveles.  En el nivel superior se encuentra el circuito <b>NeoPixel_v1_2.cysch</b> .  Esto se puede ver desde el esquema principal: <br><br><img src="https://habrastorage.org/webt/z3/cg/fr/z3cgfrfl4k_rdsuu2dw6kykq_o4.png"><br><br>  El componente es el siguiente: <br><br><img src="https://habrastorage.org/webt/zp/h3/yw/zph3ywaeojjenc6ailxcmsb3f0m.png"><br><br>  El soporte de software para este esquema se discutir√° m√°s adelante.  Mientras tanto, descubra que es una unidad DMA normal y un cierto s√≠mbolo <b>NeoPixDrv_v1</b> .  Este misterioso bloque se describe anteriormente en el √°rbol, que se desprende de la siguiente informaci√≥n sobre herramientas: <br><br><img src="https://habrastorage.org/webt/zk/_u/2p/zk_u2pxpdmiokfow6b4iur-_ab0.png"><br><br><h2>  UDB "Firmware" </h2><br>  Abra ese componente (archivo con la extensi√≥n <b>.cyudb</b> ).  El dibujo abierto es simplemente enorme.  Comenzamos a entender qu√© es qu√©. <br><br><img src="https://habrastorage.org/webt/e6/co/4l/e6co4lsbmphoom6ikhuhutzkzbe.png"><br><br>  A diferencia del autor del proyecto original, considero la transmisi√≥n de cada bit de datos en forma de tres partes iguales (en el tiempo): <br><br><ol><li>  Parte inicial (siempre 1) </li><li>  Parte de datos </li><li>  Detener parte (siempre 0) </li></ol><br>  Con este enfoque, no se requiere una gran cantidad de contadores (en el original hab√≠a hasta tres piezas, que consum√≠an una gran cantidad de recursos).  La duraci√≥n de todas las partes es la misma y se puede configurar con un registro.  Por lo tanto, el gr√°fico de transici√≥n del firmware contiene los siguientes estados: <br><br>  Estado <b>inactivo</b> .  La m√°quina permanece en ella hasta que lleguen nuevos datos a FIFO. <br><br><img src="https://habrastorage.org/webt/s_/r5/zn/s_r5zn54lff9nd9thvqxphyxjqq.png"><br><br>  De los videos de capacitaci√≥n, no estaba del todo claro para m√≠ c√≥mo el estado de la m√°quina est√° relacionado con ALU.  Los autores usan la comunicaci√≥n como algo natural, pero yo, como principiante, no pude verla de inmediato.  Echemos un vistazo r√°pido en detalle.  La figura anterior muestra que el estado <b>inactivo</b> est√° codificado con el valor 1'b0.  3'b000 ser√° m√°s correcto, pero el editor rehacer√° todo de todos modos.  Las entradas del bloque <b>Datapath se</b> describen as√≠: <br><br><img src="https://habrastorage.org/webt/dq/qc/zp/dqqczpv87oulrwzvu-cbcmucsee.png"><br><br>  Si hace doble clic en ellos, aparecer√° una versi√≥n m√°s detallada: <br><br><img src="https://habrastorage.org/webt/pu/xm/ts/puxmtsmg3jf3hjnwstnpbeu-exe.png"><br><br>  Esto significa que el bit cero de la direcci√≥n de la instrucci√≥n ALU corresponde al bit cero de la variable que establece el estado de la m√°quina.  El primero es el primero, el segundo es el segundo.  Si lo desea, cualquier variable e incluso expresiones pueden coincidir con los bits de direcci√≥n de la instrucci√≥n ALU (en la versi√≥n original, el segundo bit de la direcci√≥n de la instrucci√≥n ALU coincid√≠a con una expresi√≥n, adem√°s, no se usa expl√≠citamente en la versi√≥n actual, pero es muy obvio como un ejemplo que lleva el cerebro, entonces puede echar un vistazo). <br><br>  Entonces  Con la configuraci√≥n actual de las entradas, que es el c√≥digo de estado binario de la m√°quina, se utiliza dicha instrucci√≥n ALU.  Cuando estamos en estado <b>inactivo</b> con el c√≥digo 000, se utiliza la instrucci√≥n nula.  Aqu√≠ esta: <br><br><img src="https://habrastorage.org/webt/4p/oz/gt/4pozgtr4-p66hypvlz2rqdjta2a.png"><br><br>  Ya s√© por esta entrada que este es un NOP banal.  Pero puede hacer doble clic en √©l y leer la versi√≥n completa: <br><br><img src="https://habrastorage.org/webt/-a/vl/ii/-avliivwnptl2ra9ipfxseurxqk.png"><br><br>  Los NOP est√°n inscritos en todas partes.  Los registros no se rellenan con nada. <br><br>  ¬°Ahora descubramos qu√© tipo de bandera misteriosa <b>! NoData</b> , obligando a la m√°quina a dejar el estado <b>inactivo</b> .  Esta es la salida del bloque <b>Datapath</b> .  En total, se pueden describir hasta seis salidas.  Es solo que <b>Datapath</b> puede producir muchos m√°s indicadores, pero no hay suficientes recursos de rastreo para todos, por lo que debemos elegir qu√© seis (o menos) realmente necesitamos.  Aqu√≠ est√° la lista en la figura: <br><br><img src="https://habrastorage.org/webt/qf/a7/yd/qfa7ydqxuql3khszkw1mqbdb63m.png"><br><br>  Si hace doble clic en √©l, se revelar√°n los detalles: <br><br><img src="https://habrastorage.org/webt/vu/zo/2z/vuzo2zxg56zpyaavdunmw60eapg.png"><br><br>  Aqu√≠ est√° la lista completa de banderas que se pueden mostrar: <br><br><img src="https://habrastorage.org/webt/gi/la/jf/gilajfhzmatw2hjtfjk9xl1gs7m.png"><br><br>  Despu√©s de haber seleccionado la bandera requerida, debe darle un nombre.  De ahora en adelante, el sistema tiene una bandera.  Como puede ver, el indicador <b>NoData</b> es el nombre del <b>estado del bloque F0</b> de la cadena <b>(vac√≠o)</b> .  Es decir, una se√±al de que no hay datos en el b√∫fer de entrada.  Ah <b>! NoData</b> , respectivamente, su inversi√≥n.  Se√±al de disponibilidad de datos.  Tan pronto como los datos ingresen al FIFO (mediante programaci√≥n o usando DMA), la bandera se borrar√° (y se activar√° su inversi√≥n), y en el siguiente ciclo de reloj, el aut√≥mata saldr√° del estado inactivo y entrar√° en el estado <b>GetData</b> . <br><br><img src="https://habrastorage.org/webt/lw/o3/av/lwo3avzjvfqynfpw-3t075oat-0.png"><br><br>  Como puede ver, el aut√≥mata saldr√° de este estado incondicionalmente despu√©s de haber estado en √©l exactamente un ciclo de reloj.  No se indican acciones en el gr√°fico de transici√≥n para este estado.  Pero siempre debe mirar lo que har√° ALU.  El c√≥digo de estado es 1'b1, es decir, 3'b001.  Nos fijamos en la direcci√≥n correspondiente en ALU: <br><br><img src="https://habrastorage.org/webt/ic/zk/y8/iczky8asdanru7kzgfzznebiynm.png"><br><br>  Hay algo  Al no tener experiencia en leer lo que est√° escrito aqu√≠, √°bralo haciendo doble clic en la celda correspondiente: <br><br><img src="https://habrastorage.org/webt/vu/yf/gf/vuyfgfecoxpfd1brc6v_lzu4a3w.png"><br><br>  De ello se deduce que la ALU en s√≠ todav√≠a no realiza ninguna acci√≥n.  Pero el contenido de FIFO0, es decir, los datos que provienen del programa o del bloque DMA, se colocar√°n en el registro A0.  Mirando hacia el futuro, dir√© que A0 se usa como un registro de desplazamiento, desde el cual el byte saldr√° en forma de serie.  El registro A1 colocar√° el valor del registro D1.  En general, todos los registros D generalmente se completan con software antes de que el hardware comience a estar activo.  Luego, al examinar la API, veremos que la cantidad de tics de reloj se coloca en este registro, que establece la duraci√≥n del tercer bit.  Entonces  En A0, el valor desplazado cay√≥, y en A1, la duraci√≥n de la parte inicial del bit.  Y en el pr√≥ximo latido, la m√°quina pasar√° al estado <b>Constant1</b> . <br><br><img src="https://habrastorage.org/webt/ue/jx/fh/uejxfhlbmgbh0wgkuy2k4fe-qva.png"><br><br>  Como el nombre del estado implica, aqu√≠ se genera la constante 1. Veamos la documentaci√≥n del LED.  As√≠ es como se debe transferir la unidad: <br><br><img src="https://habrastorage.org/webt/cn/2t/i3/cn2ti3ppzpacxrbyi2uy8mq5wte.png"><br><br>  Y aqu√≠ est√°: cero: <br><br><img src="https://habrastorage.org/webt/z6/yg/vp/z6ygvphpsb700_acfvwiek9mbeo.png"><br><br>  L√≠neas rojas que agregu√©.  Si suponemos que las duraciones de los tercios son iguales, entonces se cumplen los requisitos para la duraci√≥n de los pulsos (que figuran en la misma documentaci√≥n).  Es decir, cualquier impulso consiste en una unidad de inicio, un bit de datos y una parada cero.  En realidad, la unidad de arranque se transmite cuando la m√°quina est√° en estado <b>Constante1</b> . <br><br>  En este estado, la m√°quina bloquea la unidad en su disparador interno.  El nombre del desencadenante es <b>CurrentBit</b> .  En el proyecto original, generalmente era un disparador que establece el estado del aut√≥mata auxiliar.  Decid√≠ que esa m√°quina solo confundir√≠a a todos, as√≠ que comenc√© un disparador.  No se describe en ninguna parte.  Pero si ingresa las propiedades de estado, el siguiente registro es visible en la tabla: <br><br><img src="https://habrastorage.org/webt/tz/2e/m4/tz2em4pv4kxwsg5fvzkhx7-ve_w.png"><br><br>  Y debajo del estado en el gr√°fico hay dicho texto: <br><br><img src="https://habrastorage.org/webt/bx/az/0c/bxaz0clixua21k_umbqpch3vrca.png"><br><br>  No se alarme por el s√≠mbolo igual.  Estas son las caracter√≠sticas del editor.  En el c√≥digo Verilog resultante (generado autom√°ticamente por el mismo sistema) habr√° una flecha: <br><br><pre> <code class="plaintext hljs">Constant1 : begin CurrentBit &lt;= (1); if (( CycleTimeout ) == 1'b1) begin MainState &lt;= Setup1 ; end end</code> </pre> <br>  El valor retenido en este disparador es la salida de todo nuestro bloque: <br><br><img src="https://habrastorage.org/webt/bv/jq/qd/bvjqqdmqg-2framc6_trktlfix4.png"><br><br>  Es decir, cuando la m√°quina entr√≥ en el estado de <b>Constant1</b> , la salida del bloque que estamos desarrollando obtendr√° uno.  Ahora veamos c√≥mo se programa la ALU para la direcci√≥n 3'b010: <br><br><img src="https://habrastorage.org/webt/5e/4v/hi/5e4vhiqa5gl7wo6xk0zzea_8_dm.png"><br><br>  Revelamos este elemento: <br><br><img src="https://habrastorage.org/webt/ij/wx/fc/ijwxfcl3zzmuhlef2qq-j6hhkme.png"><br><br>  La unidad 1 se resta del registro A1.  El valor de salida de ALU cae en el registro A1.  Arriba, consideramos que A1 es un contador de reloj utilizado para establecer la duraci√≥n del pulso de salida.  D√©jame recordarte que arranc√≥ desde D1 en el √∫ltimo paso. <br>  ¬øCu√°l es la condici√≥n para salir de un estado?  <b>CycleTimeOut</b> .  Se describe entre las salidas de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/7m/1c/pn/7m1cpnxbqkt6fv4x5fv73idlp3g.png"><br><br>  Entonces, unimos la l√≥gica.  En el estado anterior, el contenido del registro D1 previamente completado por el programa cay√≥ en el registro A1.  En este paso, la m√°quina traduce el activador <b>CurrentBit</b> a uno, y en ALU, el registro A1 disminuye en cada ciclo de reloj.  Cuando A1 se convierte en cero, la bandera se elevar√° autom√°ticamente, a lo que el autor le dio el nombre <b>CycleTimeout</b> , como resultado de lo cual la m√°quina cambiar√° al estado <b>Setup1</b> . <br><br>  El estado <b>Setup1</b> prepara datos para transmitir el pulso √∫til. <br><br><img src="https://habrastorage.org/webt/on/3g/j-/on3gj-j0zujays_x6uxn_grjnq8.png"><br><br>  Observamos la instrucci√≥n ALU en 3'b011.  Lo abrir√© de inmediato: <br><br><img src="https://habrastorage.org/webt/2u/uu/tl/2uuutl1vwixsvirqgsuwfvxhsb4.png"><br><br>  Parece que ALU no tiene acciones.  Operaci√≥n NOP.  Y la salida de ALU no llega a ninguna parte.  Pero esto no es as√≠.  Una acci√≥n extremadamente importante es el cambio de datos en ALU.  El hecho es que el bit de transporte entre las salidas est√° conectado a nuestra cadena <b>ShiftOut</b> : <br><br><img src="https://habrastorage.org/webt/ov/8g/-e/ov8g-emfyzhu3vhj65unf0ukirw.png"><br><br>  Y como resultado de esta operaci√≥n de cambio, el valor desplazado en s√≠ mismo no llegar√° a ninguna parte, pero la cadena <b>ShiftOut</b> tomar√° el valor del bit m√°s significativo del registro A0.  Es decir, los datos que deben transmitirse.  Bajo el estado del gr√°fico, se puede ver que este valor, que dej√≥ la ALU en la cadena <b>ShiftOut</b> , se enganchar√° en el activador <b>CurrentBit</b> .  Perm√≠tanme mostrar el dibujo nuevamente para no rebobinar el art√≠culo: <br><br><img src="https://habrastorage.org/webt/3t/kq/ef/3tkqefuwb4cbt1mdx7uiqlwazjo.png"><br><br>  Comienza la transmisi√≥n de la segunda parte del bit: el valor inmediato es 0 o 1. <br><br>  Volvemos a las instrucciones para ALU.  Adem√°s de lo que ya se ha dicho, est√° claro que el contenido del registro D1 se colocar√° nuevamente en el registro A1 para medir nuevamente la duraci√≥n del segundo tercio del pulso. <br><br>  El estado de <b>DataStage</b> es muy similar al estado de <b>Constant1</b> .  El aut√≥mata simplemente resta uno de A1 y entra al siguiente estado cuando llega a cero.  D√©jame incluso mostrarlo as√≠: <br><br><img src="https://habrastorage.org/webt/ya/ir/hs/yairhsxxk0q9jvmctsthu0lswjk.png"><br><br>  y as√≠: <br><br><img src="https://habrastorage.org/webt/_-/cj/k9/_-cjk95cwake-lvvpgv5p4gc33i.png"><br><br>  Luego viene el estado de <b>Setup2</b> , <b>cuya</b> esencia ya conocemos. <br><br><img src="https://habrastorage.org/webt/x6/bw/qa/x6bwqa1zi6_s0zdcazzcgcp_emw.png"><br><br>  En este estado, el activador <b>CurrentBit se</b> restablece a cero (ya que se transmitir√° el tercer tercio del pulso, la parte de parada, y siempre es cero).  ALU carga el contenido de D1 en A1.  Incluso puede verlo en una breve nota con su ojo entrenado: <br><br><img src="https://habrastorage.org/webt/dv/pm/1q/dvpm1qqxtwut-1egggnj5mgintu.png"><br><br>  El estado de <b>Constant0 es</b> completamente id√©ntico a los estados de <b>Constant1</b> y <b>DataStage</b> .  Resta la unidad de A1.  Cuando el valor llegue a cero, salga al estado <b>ShiftData</b> : <br><br><img src="https://habrastorage.org/webt/d2/bs/bx/d2bsbxn-pd5opvpeh3g8us5aqkg.png"><br><br><img src="https://habrastorage.org/webt/4i/g2/my/4ig2mytms6p5mt2_msq8cwl33hi.png"><br><br>  El estado de <b>ShiftData es</b> m√°s complejo.  En las instrucciones correspondientes para ALU, se realizan las siguientes acciones: <br><br><img src="https://habrastorage.org/webt/r7/hn/bx/r7hnbxsnr0ynuxfexzrlisurybi.png"><br><br>  El registro A0 se desplaza 1 bit y los resultados se vuelven a colocar en A0.  En A1, los contenidos de D1 se vuelven a poner para comenzar a medir el inicio tercero para el siguiente bit de datos. <br><br>  Es mejor considerar las flechas de salida teniendo en cuenta las prioridades, para lo cual hacemos doble clic en el estado <b>ShiftData</b> . <br><br><img src="https://habrastorage.org/webt/sp/dx/f1/spdxf1xnw2j_7ytbypqrbhql6da.png"><br><br>  Si no se transmite el √∫ltimo bit (sobre c√≥mo se forma este indicador, un poco m√°s bajo), entonces transferimos uno para el siguiente bit del byte actual. <br><br>  Si se transmite el √∫ltimo bit y no hay datos en FIFO, pasamos al estado inactivo. <br><br>  Finalmente, si se transmite el √∫ltimo bit, pero hay datos en el FIFO, pasamos a la selecci√≥n y transmisi√≥n del siguiente byte. <br><br>  Ahora sobre el contador de bits.  Solo hay dos bater√≠as en ALU: A0 y A1.  Ya est√°n ocupados por el registro de desplazamiento y el contador de retraso, respectivamente.  Por lo tanto, un contador de bits se usa externamente. <br><br><img src="https://habrastorage.org/webt/dx/p2/wv/dxp2wv0kt0othgs12nwnq7anuqs.png"><br><br>  Haga doble clic en √©l: <br><br><img src="https://habrastorage.org/webt/dz/tj/kz/dztjkza856xdotpsckoje-fnmzo.png"><br><br>  El valor en el arranque es seis.  Se carga utilizando el indicador <b>LoadCounter</b> descrito en la secci√≥n variable: <br><br><img src="https://habrastorage.org/webt/e3/-a/tf/e3-atfbenscj9nudppvxrab9ylg.png"><br><br>  Es decir, cuando se toma el siguiente byte de datos, esta constante se carga en el camino. <br><br>  Cuando la m√°quina entra en el estado <b>ShiftData</b> , el contador disminuye el valor.  Cuando llega a cero, la salida <b>TerminalCount</b> est√° conectada, conectada al circuito de nuestra <b>semilla FinalBit</b> .  Es este circuito el que establece si la m√°quina transferir√° el siguiente bit del byte actual o transferir√° un nuevo byte (bueno, o esperar√° un nuevo paquete de datos). <br><br>  En realidad, todo es de la l√≥gica.  C√≥mo se <b>genera la</b> se√±al <b>SpaceForData</b> , que establece el estado de la salida <b>Hungry</b> (informando a la unidad DMA que es posible transmitir los siguientes datos), los lectores est√°n invitados a realizar un seguimiento de forma independiente. <br><br><h2>  Soporte de software </h2><br>  El autor del proyecto original eligi√≥ hacer soporte de software para todo el sistema en el bloque que describe la soluci√≥n integrada.  D√©jame recordarte, estamos hablando de este bloque: <br><br><img src="https://habrastorage.org/webt/pi/uz/vz/piuzvzjzbcuaqyqqlwnvrmwgh8m.png"><br><br>  Desde este nivel, hay control sobre la unidad de biblioteca DMA y todas las partes incluidas en la parte UDB.  Para implementar la API, el autor del original agreg√≥ el encabezado y los archivos de programa: <br><br><img src="https://habrastorage.org/webt/af/2y/aw/af2yaw0qcmxmjzsevxq30sjwfc4.png"><br><br>  El formato del cuerpo de estos archivos te pone triste.  Toda la culpa es el amor de los desarrolladores de PSoC Designer por los "puros".  De ah√≠ las terribles macros y nombres de kil√≥metros.  La organizaci√≥n de clases en C ++ ser√≠a √∫til aqu√≠.  Al menos lo comprobamos al implementar nuestro RTOS MAX: result√≥ hermoso y conveniente.  Pero aqu√≠ puedes discutir mucho, pero tendr√°s que usar lo que hemos defraudado desde arriba.  Solo mostrar√© brevemente c√≥mo se ve la funci√≥n API que contiene estas macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* `$INSTANCE_NAME`_Start(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNumberOfNeopixels, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fSpeedMHz) { <span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... `$INSTANCE_NAME`_g_pFrameBuffer = NULL; if((0.3/(1.0/(fSpeedMHz))) &gt; 255) return NULL; unsigned char fCyclesOn = (unsigned char)(0.35/(1.0/(fSpeedMHz))); `$INSTANCE_NAME`_g_nFrameBufferSize = nNumberOfNeopixels*3; //Configure for 19.2 MHz operation `$INSTANCE_NAME`_Neo_BITCNT_Start(); //Counts bits in a byte //Sets bitrate frequency in number of clocks. Must be larger than largest of above two counter periods CY_SET_REG8(`$INSTANCE_NAME`_Neo_DPTH_D1_PTR, fCyclesOn+1); //Setup a DMA channel `$INSTANCE_NAME`_g_nDMA_Chan = `$INSTANCE_NAME`_DMA_DmaInitialize(`$INSTANCE_NAME`_DMA_BYTES_PER_BURST, `$INSTANCE_NAME`_DMA_REQUEST_PER_BURST, HI16(`$INSTANCE_NAME`_DMA_SRC_BASE), HI16(`$INSTANCE_NAME`_DMA_DST_BASE)); if(pBuffer == NULL) ...</span></span></code> </pre> <br>  Estas reglas del juego tienen que ser aceptadas.  Ahora ya sabe de d√≥nde inspirarse cuando desarrolla sus funciones (es mejor hacerlo en el proyecto original).  Y prefiero hablar sobre los detalles, tomando la opci√≥n ya procesada por el generador. <br><br>  Despu√©s de generar el c√≥digo (descrito a continuaci√≥n), este archivo se almacenar√° aqu√≠: <br><br><img src="https://habrastorage.org/webt/b2/c_/j_/b2c_j_llpmg3yjjwirq4b3bjkag.png"><br><br>  Y la vista ya ser√° perfectamente legible.  Hay dos funciones hasta ahora.  El primero inicializa el sistema, el segundo inicia la transferencia de datos desde el b√∫fer a la l√≠nea de LED. <br><br>  La inicializaci√≥n afecta a todas las partes del sistema.  Hay una inicializaci√≥n del contador de siete bits, que forma parte del sistema UDB: <br><br><pre> <code class="cpp hljs"> NP_Neo_BITCNT_Start(); <span class="hljs-comment"><span class="hljs-comment">//Counts bits in a byte</span></span></code> </pre> <br>  Hay un c√°lculo constante que debe cargarse en el registro D1 (recuerdo que establece la duraci√≥n de cada uno de los terceros bits): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fCyclesOn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(<span class="hljs-number"><span class="hljs-number">0.35</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(fSpeedMHz))); CY_SET_REG8(NP_Neo_DPTH_D1_PTR, fCyclesOn+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Configurar un bloque DMA ocupa la mayor parte de esta funci√≥n.  El b√∫fer se usa como fuente y el FIFO0 del bloque UDB se usa como receptor (NP_Neo_DPTH_F0_PTR en el registro de kil√≥metros).  El autor ten√≠a una parte de esta configuraci√≥n en la funci√≥n de transferencia de datos.  Pero, en mi opini√≥n, hacer todos los c√°lculos por el bien de cada transmisi√≥n es demasiado derrochador.  Especialmente cuando consideras que una de las acciones dentro de la funci√≥n se ve muy, muy voluminosa. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... NP_g_pFrameBuffer = NULL; NP_g_nFrameBufferSize = nNumberOfNeopixels*3; //Setup a DMA channel NP_g_nDMA_Chan = NP_DMA_DmaInitialize(NP_DMA_BYTES_PER_BURST, NP_DMA_REQUEST_PER_BURST, HI16(NP_DMA_SRC_BASE), HI16(NP_DMA_DST_BASE)); ... NP_g_nDMA_TD = CyDmaTdAllocate(); CyDmaTdSetConfiguration(NP_g_nDMA_TD, NP_g_nFrameBufferSize, CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(NP_g_nDMA_TD, LO16((uint32)NP_g_pFrameBuffer), LO16((uint32)NP_Neo_DPTH_F0_PTR)); CyDmaChSetInitialTd(NP_g_nDMA_Chan, NP_g_nDMA_TD);</span></span></code> </pre><br>  La segunda funci√≥n en el contexto de la primera es la parte superior del laconismo.  Es solo que el primero se llama en la etapa de inicializaci√≥n, cuando los requisitos de rendimiento son bastante gratuitos.  Durante la operaci√≥n, es mejor no desperdiciar los ciclos del procesador en nada superfluo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NP_Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NP_g_pFrameBuffer) { CyDmaChEnable(NP_g_nDMA_Chan, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Claramente, no hay suficiente funcionalidad para trabajar con m√∫ltiples buffers (para proporcionar doble buffer), pero en general, una discusi√≥n sobre la funcionalidad de la API est√° m√°s all√° del alcance del art√≠culo.  Ahora lo principal es mostrar c√≥mo agregar soporte de software al firmware desarrollado.  Ahora sabemos c√≥mo hacerlo. <br><br><h2>  Generacion de proyectos </h2><br>  Entonces, toda la parte del firmware est√° lista, se agrega la API, ¬øqu√© hacer a continuaci√≥n?  Seleccione el elemento del men√∫ <b>Generar-&gt; Generar aplicaci√≥n</b> . <br><br><img src="https://habrastorage.org/webt/b-/5d/yv/b-5dyvvwubusbcm5f4xzy7bhie4.png"><br><br>  Si todo va bien, puede abrir la pesta√±a <b>Resultados</b> y ver el archivo con la extensi√≥n <b>rpt</b> . <br><br><img src="https://habrastorage.org/webt/d2/5e/4d/d25e4d3xlv845numi21z2wzxzba.png"><br><br>  Muestra cu√°ntos recursos del sistema se destinaron a la implementaci√≥n del firmware. <br><br><img src="https://habrastorage.org/webt/bv/mm/yn/bvmmynvgxcssd33wk-aetjwwbd4.png"><br><br><img src="https://habrastorage.org/webt/wr/_u/mo/wr_umoub3comqr_3v4qxcqbhpwi.png"><br><br>  Cuando comparo los resultados con los que estaban en el proyecto original, mi alma se calienta. <br><br>  Ahora vaya a la pesta√±a <b>Fuente</b> y comience a trabajar con la parte de software.  Pero esto ya es trivial y no requiere explicaciones especiales. <br><br><img src="https://habrastorage.org/webt/w4/d6/d5/w4d6d5fhjcllllxyqtjva7j-upo.png"><br><br><h2>  Conclusi√≥n </h2><br>  Espero que de este ejemplo, los lectores hayan aprendido algo nuevo e interesante sobre el trabajo pr√°ctico con bloques UDB.  Trat√© de concentrarme en una tarea espec√≠fica (control LED), as√≠ como en la metodolog√≠a de dise√±o, ya que ten√≠a que comprender algunos aspectos que eran obvios para los especialistas.  Trat√© de marcarlos mientras los recuerdos de la b√∫squeda son frescos.  En cuanto al problema resuelto, los diagramas de tiempo para m√≠ resultaron no ser tan ideales como el autor del desarrollo original, pero encajan perfectamente en las tolerancias definidas en la documentaci√≥n para los LED, y los recursos del sistema fueron significativamente menores. <br><br>  De hecho, esto es solo una parte de la informaci√≥n no est√°ndar encontrada.  En particular, de la mayor√≠a de los materiales puede parecer que UDB funciona bien solo con datos en serie, pero esto no es as√≠.  Nota de aplicaci√≥n encontrada, que muestra brevemente c√≥mo puede conducir y datos paralelos.  Podr√≠amos considerar ejemplos espec√≠ficos basados ‚Äã‚Äãen esta informaci√≥n (aunque es imposible eclipsar el FX2LP, otro controlador de Cypress: PSoC tiene una velocidad de bus USB m√°s baja). <br><br>  Mi cabeza est√° dando vueltas a ideas sobre c√≥mo resolver el problema de "flashear" una impresora 3D, lo que me ha atormentado durante mucho tiempo.  All√≠, las interrupciones que sirven a los motores paso a paso devoran solo un porcentaje incre√≠ble de tiempo de CPU.  En general, habl√© mucho sobre interrupciones y tiempo de procesador en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre RTOS MAX</a> .  Se estima que para el mantenimiento de motores paso a paso es posible llevar todas las caba√±as temporales completamente a la UDB, dejando al procesador una tarea puramente computacional sin temor a que no tenga tiempo para hacerlo en un intervalo de tiempo dedicado. <br><br>  Pero estas cosas solo pueden razonarse si el tema es interesante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429882/">https://habr.com/ru/post/es429882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429866/index.html">C√≥mo: t√©rminos de TI en ingl√©s</a></li>
<li><a href="../es429872/index.html">Generaci√≥n de entornos basados ‚Äã‚Äãen sonido y m√∫sica en Unity3D</a></li>
<li><a href="../es429876/index.html">Los investigadores superaron a los bloqueadores de anuncios m√°s potentes, se acerca la guerra de formatos</a></li>
<li><a href="../es429878/index.html">¬øPor qu√© con el crecimiento de la empresa, los desarrolladores que estaban a la vanguardia est√°n "por la borda"</a></li>
<li><a href="../es429880/index.html">Pix4D: de fotos a medidas</a></li>
<li><a href="../es429884/index.html">Conferencia PROSTOR 2018: preguntas y respuestas sobre el futuro del almacenamiento</a></li>
<li><a href="../es429888/index.html">Calculadora basada en pila en la placa FPGA Cyclone IV</a></li>
<li><a href="../es429890/index.html">Webinar abierto "Redes de confrontaci√≥n generativas"</a></li>
<li><a href="../es429892/index.html">xonsh - python como reemplazo de shell</a></li>
<li><a href="../es429894/index.html">Usando un ojo de pez en una Raspberry Pi 3 con ROS - Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>