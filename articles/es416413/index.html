<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüíº üë®üèº‚Äçüíº ü§° Vino, vio, generaliz√≥: inmerso en Java Generics üìö üë©üèø‚Äç‚öïÔ∏è ‚òùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Generics es uno de los cambios m√°s significativos en la historia del lenguaje Java. Los gen√©ricos disponibles con Java 5 han hecho que usar Java ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vino, vio, generaliz√≥: inmerso en Java Generics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java Generics es uno de los cambios m√°s significativos en la historia del lenguaje Java.  Los gen√©ricos disponibles con Java 5 han hecho que usar Java Collection Framework sea m√°s f√°cil, m√°s conveniente y m√°s seguro.  Los errores asociados con el uso incorrecto de los tipos ahora se detectan en la etapa de compilaci√≥n.  S√≠, y el lenguaje Java en s√≠ se ha vuelto a√∫n m√°s seguro.  A pesar de la aparente simplicidad de los tipos gen√©ricos, muchos desarrolladores tienen dificultades para usarlos.  En esta publicaci√≥n hablar√© sobre las caracter√≠sticas de trabajar con Java Generics, para que tenga menos de estas dificultades.  Es √∫til si no es un gur√∫ gen√©rico y ayudar√° a evitar muchas dificultades al sumergirse en el tema. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2>  Trabaja con colecciones </h2><br>  Supongamos que un banco necesita calcular la cantidad de ahorro en las cuentas de los clientes.  Antes del advenimiento de los "gen√©ricos", el m√©todo de c√°lculo de la suma se ve√≠a as√≠: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Repetimos, revisamos la lista de cuentas y verificamos si el elemento de esta lista es realmente una instancia de la clase <code>Account</code> , es decir, la cuenta del usuario.  El tipo de nuestro objeto de la clase <code>Account</code> y el m√©todo <code>getAmount</code> se <code>getAmount</code> , lo que devolvi√≥ el monto en esta cuenta.  Luego lo resumieron todo y devolvieron la cantidad total.  Se requieren dos pasos: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br>  Si no marca ( <code>instanceof</code> ) para pertenecer a la clase <code>Account</code> , entonces en la segunda etapa es posible una <code>ClassCastException</code> es decir, un bloqueo del programa.  Por lo tanto, tal verificaci√≥n era obligatoria. <br><br>  Con el advenimiento de los gen√©ricos, la necesidad de verificaci√≥n de tipo y conversi√≥n ha desaparecido: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  Ahora m√©todo <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre>  acepta como argumentos solo una lista de objetos de la clase <code>Account</code> .  Esta restricci√≥n se indica en el m√©todo en s√≠, en su firma, el programador simplemente no puede transferir ninguna otra lista, solo la lista de cuentas de clientes. <br><br>  No necesitamos verificar el tipo de elementos de esta lista: est√° impl√≠cito en la descripci√≥n del tipo del par√°metro del m√©todo <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  (puede leerse como una <code>   Account</code> ).  Y el compilador arrojar√° un error si algo sale mal, es decir, si alguien intenta pasar una lista de objetos distintos de la clase <code>Account</code> a este m√©todo. <br><br>  En la segunda l√≠nea del cheque, la necesidad tambi√©n desapareci√≥.  Si es necesario, el <code>casting</code> se realizar√° en la etapa de compilaci√≥n. <br><br><h2>  Principio de sustituci√≥n </h2><br>  El principio de sustituci√≥n de Barbara Liskov es una definici√≥n espec√≠fica de un subtipo en la programaci√≥n orientada a objetos.  La idea de Liskov de un "subtipo" define el concepto de sustituci√≥n: si <code>S</code> es un subtipo de <code>T</code> , entonces los objetos de tipo <code>T</code> en un programa pueden ser reemplazados por objetos de tipo <code>S</code> sin ning√∫n cambio en las propiedades deseadas de este programa. <br><br><table><tbody><tr><td>  <b>Tipo</b> <br></td><td>  <b>Subtipo</b> <br></td></tr><tr><td>  <i>Numero</i> <br></td><td>  <i>Entero</i> <br></td></tr><tr><td>  <i>Lista</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Colecci√≥n</i> &lt;E&gt; <br></td><td>  <i>Lista</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Iterable</i> &lt;E&gt; <br></td><td>  <i>Colecci√≥n</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>Ejemplos de relaci√≥n de tipo / subtipo</i> <br><br>  Aqu√≠ hay un ejemplo del uso del principio de sustituci√≥n en Java: <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code> es un subtipo de <code>Number</code> , por lo tanto, a la variable <code>n</code> tipo <code>Number</code> se le puede asignar el valor que devuelve el m√©todo <code>Integer.valueOf(42)</code> . <br><br><h2>  Covarianza, contravarianza e invariancia </h2><br>  Primero, una peque√±a teor√≠a.  La covarianza es la preservaci√≥n de la jerarqu√≠a de herencia de los tipos de origen en tipos derivados en el mismo orden.  Por ejemplo, si el <i>Gato</i> es un subtipo de <i>Animales</i> , entonces el <i>Conjunto de &lt;Gatos&gt;</i> es un subtipo del <i>Conjunto de &lt;Animales&gt;</i> .  Por lo tanto, teniendo en cuenta el principio de sustituci√≥n, se puede realizar la siguiente asignaci√≥n: <br><br>  <i>Many &lt;Animals&gt; = Many &lt;Cats&gt;</i> <br><br>  La contravarianza es la inversi√≥n de la jerarqu√≠a de los tipos de origen en los tipos derivados.  Por ejemplo, si el <i>Gato</i> es un subtipo de los <code></code> , entonces el <i>Conjunto &lt;Animales&gt;</i> es un subtipo del <i>Conjunto de &lt;Gatos&gt;</i> .  Por lo tanto, teniendo en cuenta el principio de sustituci√≥n, se puede realizar la siguiente asignaci√≥n: <br><br>  <i>Many &lt;Cats&gt; = Many &lt;Animals&gt;</i> <br><br>  Invarianza: falta de herencia entre los tipos derivados.  Si el <i>Gato</i> es un subtipo de <i>Animales</i> , entonces el <i>Conjunto de &lt;Gatos&gt;</i> no <i>es</i> un subtipo del <i>Conjunto de &lt;Animales&gt;</i> y el <i>Conjunto de &lt;Animales&gt;</i> no <i>es</i> un subtipo del <i>Conjunto de &lt;Gatos&gt;</i> . <br><br>  <b>Las matrices en Java son covariantes</b> .  El tipo <code>S[]</code> es un subtipo de <code>T[]</code> si <code>S</code> es un subtipo de <code>T</code>  Ejemplo de asignaci√≥n: <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br>  Asignamos un enlace a una matriz de cadenas a la variable <code>arr</code> , cuyo tipo es <code>¬´ ¬ª</code> .  Si las matrices no fueran covariantes, no podr√≠amos hacer esto.  Java le permite hacer esto, el programa compila y se ejecuta sin errores. <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br>  Pero si tratamos de cambiar el contenido de la matriz a trav√©s de la variable <code>arr</code> y escribimos el n√∫mero 42 all√≠, obtendremos una <code>ArrayStoreException</code> en la etapa de ejecuci√≥n del programa, ya que 42 no es una cadena, sino un n√∫mero.  Este es el inconveniente de la covarianza de las matrices Java: no podemos realizar comprobaciones en la etapa de compilaci√≥n, y algo puede romperse ya en tiempo de ejecuci√≥n. <br><br>  <b>Los "gen√©ricos" son invariables.</b>  Aqu√≠ hay un ejemplo: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br>  Si toma una lista de enteros, entonces no ser√° un subtipo de tipo <code>Number</code> , ni ning√∫n otro subtipo.  √âl es solo un subtipo de s√≠ mismo.  Es decir, <code>List &lt;Integer&gt;</code> es una <code>List&lt;Integer&gt;</code> y nada m√°s.  El compilador se asegurar√° de que la variable <code>ints</code> declarada como una lista de objetos de la clase <i>Integer</i> contenga solo objetos de la clase <code>Integer</code> y nada m√°s.  En la etapa de compilaci√≥n, se realiza una verificaci√≥n y nada caer√° en nuestro tiempo de ejecuci√≥n. <br><br><h2>  Comodines </h2><br>  ¬øLos gen√©ricos son siempre invariantes?  No  Dar√© ejemplos: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br>  Esto es covarianza.  <code>List&lt;Integer&gt;</code> - subtipo de <code>List&lt;? extends Number&gt;</code> <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br>  Esto es contravarianza.  <code>List&lt;Number&gt;</code> es un subtipo de <code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> . <br><br>  Un registro como <code>"? extends ..."</code> o <code>"? super ..."</code> se llama comod√≠n o comod√≠n, con un l√≠mite superior (se <code>extends</code> ) o un l√≠mite inferior ( <code>super</code> ). <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code> puede contener objetos cuya clase es <code>Number</code> o hereda de <code>Number</code> . <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code> puede contener objetos cuya clase es <code>Number</code> o cuyo <code>Number</code> es un heredero (supertipo de <code>Number</code> ). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td>  extiende <i>B</i> - comod√≠n con l√≠mite superior <br>  super <i>B</i> - comod√≠n con un l√≠mite inferior <br>  donde <i>B</i> - representa el borde <br><br>  Un registro de la forma T <sub>2</sub> &lt;= T <sub>1</sub> significa que el conjunto de tipos descritos por T <sub>2</sub> es un subconjunto del conjunto de tipos descritos por T <sub>1</sub> <br><br>  es decir <br>  N√∫mero &lt;=?  extiende objeto <br>  ?  extiende N√∫mero &lt;=?  extiende objeto <br>  y <br>  ?  super objeto &lt;=?  super numero <br><br></td></tr></tbody></table><br>  <i>M√°s interpretaci√≥n matem√°tica del tema.</i> <br><br>  Un par de tareas para probar el conocimiento: <br><br>  1. ¬øPor qu√© aparece el error en tiempo de compilaci√≥n en el siguiente ejemplo?  ¬øQu√© valor puedo agregar a la lista de <code>nums</code> ? <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  ¬øDeber√≠a declararse el contenedor con comod√≠n <code>? extends</code>  <code>? extends</code> , solo puede leer los valores.  No se puede agregar nada a la lista excepto <code>null</code> .  Para agregar un objeto a la lista necesitamos otro tipo de comod√≠n - <code>? super</code> <code>? super</code> <br></div></div><br><br>  2. ¬øPor qu√© no puedo obtener un art√≠culo de la lista a continuaci√≥n? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  ¬øNo puede leer un elemento de un contenedor con comod√≠n <code>? super</code>  <code>? super</code> , excepto por un objeto de clase <code>Object</code> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3>  El Principio Get and Put o PECS (Productor Extiende Consumer Super) </h3><br>  La funci√≥n comod√≠n con l√≠mites superior e inferior ofrece caracter√≠sticas adicionales relacionadas con el uso seguro de los tipos.  Solo puede leer de un tipo de variable, solo escribir en otro (la excepci√≥n es la capacidad de escribir <code>null</code> para <code>extends</code> y leer <code>Object</code> para <code>super</code> ).  Para que sea m√°s f√°cil recordar cu√°ndo usar qu√© comod√≠n, existe el principio PECS: Producer Extender Consumer Super. <br><br><ul><li>  Si declaramos un <i>comod√≠n con extensiones</i> , entonces este es el <i>productor</i> .  √âl solo "produce", proporciona un elemento del contenedor y no acepta nada. <br></li><li>  Si anunciamos un <i>comod√≠n con super</i> , entonces esto es <i>consumidor</i> .  Solo acepta, pero no puede proporcionar nada. <br></li></ul><br>  Considere usar Wildcard y el principio PECS usando el m√©todo de copia en la clase java.util.Collections como ejemplo. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  El m√©todo copia elementos de la lista <code>src</code> original a la lista <code>dest</code> .  <code>src</code> : ¬ødeclarado con comod√≠n <code>? extends</code>  <code>? extends</code> y es el productor, y se declara <code>dest</code> con comod√≠n <code>? super</code>  <code>? super</code> y es un consumidor.  Dada la covarianza y contravarianza del comod√≠n, puede copiar elementos de la lista de <code>ints</code> a la lista de <code>nums</code> : <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br>  Si confundimos los par√°metros del m√©todo de copia por error e intentamos copiar de la lista de <code>nums</code> a la lista de <code>ints</code> , el compilador no nos permitir√° hacer esto: <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;?&gt; y tipos sin formato </h3><br>  A continuaci√≥n se muestra un comod√≠n con un comod√≠n ilimitado.  Acabamos de poner <code>&lt;?&gt;</code> , Sin las palabras clave <code>super</code> o <code>extends</code> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br>  De hecho, dicho comod√≠n "ilimitado" sigue siendo limitado, desde arriba.  <code>Collection&lt;?&gt;</code> Tambi√©n es un comod√≠n, como " <code>? extends Object</code> ".  Un registro de la forma <code>Collection&lt;?&gt;</code> equivalente a la <code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> , lo que significa que la colecci√≥n puede contener objetos de cualquier clase, ya que todas las clases en Java heredan de <code>Object</code> , por lo que la sustituci√≥n se llama ilimitada. <br><br>  Si omitimos la indicaci√≥n de tipo, por ejemplo, como aqu√≠: <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  luego dicen que <code>ArrayList</code> es el tipo <code>Raw</code> del <i>ArrayList</i> parametrizado <i>&lt;T&gt;</i> .  Con los tipos sin formato, volvemos a la era de los gen√©ricos y abandonamos conscientemente todas las caracter√≠sticas inherentes a los tipos con par√°metros. <br><br>  Si intentamos llamar a un m√©todo parametrizado en el tipo Raw, el compilador nos dar√° una advertencia de "Llamada no verificada".  Si intentamos asignar una referencia a un tipo Raw parametrizado a un tipo, el compilador emitir√° una advertencia "Asignaci√≥n no verificada".  Ignorar estas advertencias, como veremos m√°s adelante, puede provocar errores durante la ejecuci√≥n de nuestra aplicaci√≥n. <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3>  Captura de comodines </h3><br>  Ahora intentemos implementar un m√©todo que permute los elementos de una lista en el orden inverso. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br>  Se produjo un error de compilaci√≥n porque el m√©todo <code>reverse</code> toma una lista con un car√°cter comod√≠n ilimitado <code>&lt;?&gt;</code> Como argumento. <br>  <code>&lt;?&gt;</code> significa lo mismo que <code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> .  Por lo tanto, de acuerdo con el principio PECS, la <code>list</code> es el <code>producer</code> .  Y el <code>producer</code> solo produce elementos.  Y en el bucle <code>for</code> llamamos al m√©todo <code>set()</code> , es decir  tratando de escribir en la <code>list</code> .  Y as√≠ descansamos contra la protecci√≥n de Java, que no nos permite establecer alg√∫n valor por √≠ndice. <br><br>  Que hacer  El patr√≥n de <code>Wildcard Capture</code> nos ayudar√°.  Aqu√≠ creamos un m√©todo gen√©rico de <code>rev</code> .  Se declara con una variable de tipo <code>T</code>  Este m√©todo acepta una lista de tipos <code>T</code> , y podemos hacer un conjunto. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br>  Ahora todo se compilar√° con nosotros.  La captura de comodines fue capturada aqu√≠.  Cuando se llama al m√©todo <code>reverse(List&lt;?&gt; list)</code> , se pasa una lista de algunos objetos (por ejemplo, cadenas o enteros) como argumento.  Si podemos capturar el tipo de estos objetos y asignarlo a una variable de tipo <code>X</code> , entonces podemos concluir que <code>T</code> es <code>X</code> <br><br>  Puede leer m√°s sobre <code>Wildcard Capture</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h3>  Conclusi√≥n </h3><br>  Si necesita leer desde el contenedor, utilice un comod√≠n con el borde superior " <code>? extends</code> ".  Si necesita escribir en el contenedor, utilice un comod√≠n con un borde inferior de " <code>? super</code> ".  No use comodines si necesita grabar y leer. <br><br>  ¬°No use tipos <code>Raw</code> !  Si el argumento de tipo no est√° definido, utilice el comod√≠n <code>&lt;?&gt;</code> . <br><br><h2>  Escribir variables </h2><br>  Cuando escribimos el identificador entre par√©ntesis angulares, por ejemplo, <code>&lt;T&gt;</code> o <code>&lt;E&gt;</code> al declarar una clase o m√©todo, creamos <i>una variable de tipo</i> .  Una variable de tipo es un identificador no calificado que se puede usar como un tipo en el cuerpo de una clase o m√©todo.  Una variable de tipo se puede acotar arriba. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br>  En este ejemplo, la expresi√≥n <code>T extends Comparable&lt;T&gt;</code> define <code>T</code> (una variable de tipo) limitada anteriormente por el tipo <code>Comparable&lt;T&gt;</code> .  A diferencia del comod√≠n, las variables de tipo solo se pueden limitar en la parte superior (solo se <code>extends</code> ).  No se puede escribir <code>super</code> .  Adem√°s, en este ejemplo, <code>T</code> depende de s√≠ mismo, se llama <code>recursive bound</code> , un borde recursivo. <br><br>  Aqu√≠ hay otro ejemplo de la clase Enum: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br>  Aqu√≠, la clase Enum se parametriza por tipo E, que es un subtipo de <code>Enum&lt;E&gt;</code> . <br><br><h3>  L√≠mites m√∫ltiples </h3><br>  <code>Multiple Bounds</code> : m√∫ltiples restricciones.  Est√° escrito a trav√©s del car√°cter " <code>&amp;</code> ", es decir, decimos que el tipo representado por una variable de tipo <code>T</code> debe estar limitado desde arriba por la clase <code>Object</code> y la interfaz <code>Comparable</code> . <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br>  Grabar <code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> forma el tipo de intersecci√≥n <code>Multiple Bounds</code> .  La primera limitaci√≥n, en este caso, <code>Object</code> , se usa para <code>erasure</code> , el proceso de maceraci√≥n de tipos.  Lo realiza el compilador en la etapa de compilaci√≥n. <br><br><h3>  Conclusi√≥n </h3><br>  Una variable de tipo solo se puede limitar sobre uno o m√°s tipos.  En el caso de restricciones m√∫ltiples, el borde izquierdo (la primera restricci√≥n) se usa en el proceso de sobrescritura (Borrado de tipo). <br><br><h2>  Tipo de borrado </h2><br>  Type Erasure es una asignaci√≥n de tipos (posiblemente incluyendo tipos parametrizados y variables de tipo) a tipos que nunca son tipos parametrizados o tipos variables.  Escribimos el tipo <code>T</code> mashing como <code>|T|</code>  . <br><br>  La pantalla de maceraci√≥n se define de la siguiente manera: <br><ul><li>  Mashing el tipo parametrizado <i>G</i> &lt; <i>T1</i> , ..., <i>Tn</i> &gt; es |  <i>G</i> | </li><li>  Machacar un tipo anidado <i>TC</i> es |  <i>T</i> |.  <i>C</i> </li><li>  Mashing el tipo de matriz <i>T []</i> es |  <i>T</i> | [] </li><li>  Mezclar una variable de tipo es machacar su borde izquierdo </li><li>  Mashing cualquier otro tipo es este tipo en s√≠ </li></ul><br><br>  Durante la ejecuci√≥n de Type Erasure (type mashing), el compilador realiza las siguientes acciones: <br><ul><li>  agrega fundici√≥n de tipos para proporcionar seguridad de tipo si es necesario </li><li>  genera m√©todos de puente para mantener el polimorfismo </li></ul><br><br><table><tbody><tr><td>  <b>T (tipo)</b> <br></td><td>  <b>| T |</b>  <b>(Tipo de trituraci√≥n)</b> <br></td></tr><tr><td>  <i>List &lt;Integer&gt;, List &lt;String&gt;, List &lt;List &lt;String &gt;&gt;</i> <br></td><td>  <i>Lista</i> <br></td></tr><tr><td>  <i>List &lt;Integer&gt; []</i> <br></td><td>  <i>Lista []</i> <br></td></tr><tr><td>  <i>Lista</i> <br></td><td>  <i>Lista</i> <br></td></tr><tr><td>  <i>int</i> <br></td><td>  <i>int</i> <br></td></tr><tr><td>  <i>Entero</i> <br></td><td>  <i>Entero</i> <br></td></tr><tr><td>  <i>&lt;T extiende Comparable &lt;T&gt;&gt;</i> <br></td><td>  <i>Comparable</i> <br></td></tr><tr><td>  <i>&lt;T extiende Objeto y Comparable &lt;?</i>  <i>super T &gt;&gt;</i> <br></td><td>  <i>Objeto</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br>  Esta tabla muestra en qu√© se convierten los diferentes tipos durante el proceso de maceraci√≥n, borrado de tipos. <br><br>  En la siguiente captura de pantalla hay dos ejemplos del programa: <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br>  La diferencia entre los dos es que se produce un error en tiempo de compilaci√≥n a la izquierda y a la derecha todo se compila sin errores.  Por qu√© <br><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  En Java, dos m√©todos diferentes no pueden tener la misma firma.  En el proceso Type Erasure, el compilador agregar√° el m√©todo bridge <code>public int compareTo(Object o)</code> .  Pero la clase ya contiene un m√©todo con tal firma que causar√° un error durante la compilaci√≥n. <br><br>  Compile la clase Name quitando el <code>compareTo(Object o)</code> y observe el bytecode resultante usando javap: <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br>  Vemos que la clase contiene un <code>int compareTo(java.lang.Object)</code> , aunque lo eliminamos del c√≥digo fuente.  Este es el m√©todo puente que agreg√≥ el compilador. <br></div></div><br><br><h3>  Tipos reificables </h3><br>  En Java, decimos que un tipo es <code>reifiable</code> si su informaci√≥n es totalmente accesible en tiempo de ejecuci√≥n.  Los tipos reificables incluyen: <br><ul><li>  Tipos primitivos ( <i>int</i> , <i>long</i> , <i>boolean</i> ) </li><li>  Tipos no parametrizados (no gen√©ricos) ( <i>String</i> , <i>Integer</i> ) </li><li>  Tipos parametrizados cuyos par√°metros se representan como comodines ilimitados (caracteres comod√≠n ilimitados) ( <i>Lista &lt;?&gt;</i> , <i>Colecci√≥n &lt;?&gt;</i> ) </li><li>  Tipos sin formato (sin forma) ( <i>List</i> , <i>ArrayList</i> ) </li><li>  Matrices cuyos componentes son tipos Reifiable ( <i>int []</i> , <i>Number []</i> , <i>List &lt;?&gt; []</i> , <i>List [</i> ) </li></ul><br><br>  ¬øPor qu√© hay informaci√≥n disponible sobre algunos tipos pero no sobre otros?  El hecho es que debido al proceso de sobrescritura de tipos por parte del compilador, se puede perder informaci√≥n sobre algunos tipos.  Si se pierde, este tipo ya no ser√° reificable.  Es decir, no est√° disponible en tiempo de ejecuci√≥n.  Si est√° disponible, respectivamente, reificable. <br><br>  La decisi√≥n de no hacer que todos los tipos gen√©ricos est√©n disponibles en tiempo de ejecuci√≥n es una de las decisiones de dise√±o m√°s importantes y conflictivas en el sistema de tipos Java.  Esto se hace, en primer lugar, por compatibilidad con el c√≥digo existente.  Tuve que pagar por la compatibilidad de la migraci√≥n: la accesibilidad total de un sistema de tipos gen√©ricos en tiempo de ejecuci√≥n no es posible. <br><br>  Qu√© tipos no son reificables: <br><ul><li>  Tipo variable ( <i>T</i> ) </li><li>  Tipo parametrizado con el tipo de par√°metro especificado ( <i>List &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> , <i>List &lt;List &lt;String&gt;&gt;</i> ) </li><li>  Un tipo parametrizado con el l√≠mite superior o inferior especificado ( <i>Lista &lt;? Ampl√≠a n√∫mero&gt;, Comparable &lt;? Super String&gt;</i> ).  Pero aqu√≠ hay una reserva: <i>Lista &lt;?</i>  <i>extiende Object&gt;</i> - <b>no</b> reifiable, pero <i>List &lt;?&gt;</i> - reifiable </li></ul><br><br>  Y una tarea m√°s.  ¬øPor qu√© en el siguiente ejemplo no se puede crear una excepci√≥n parametrizada? <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  Cada expresi√≥n catch en try-catch verifica el tipo de la excepci√≥n recibida durante la ejecuci√≥n del programa (que es equivalente a la instancia de), respectivamente, el tipo debe ser Reifiable.  Por lo tanto, Throwable y sus subtipos no se pueden parametrizar. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3>  Advertencias no verificadas </h3><br>  Compilar nuestra aplicaci√≥n puede producir la llamada <code>Unchecked Warning</code> , una advertencia de que el compilador no pudo determinar correctamente el nivel de seguridad de uso de nuestros tipos.  Esto no es un error, sino una advertencia, por lo que puede omitirlo.  Pero es aconsejable arreglarlo todo para evitar problemas en el futuro. <br><br><h3>  Contaminaci√≥n del mont√≥n </h3><br>  Como mencionamos anteriormente, la asignaci√≥n de una referencia a un tipo Raw a una variable de un tipo parametrizado lleva a la advertencia "Asignaci√≥n no verificada".  Si lo ignoramos, es posible una situaci√≥n llamada " <code>Heap Pollution</code> " (contaminaci√≥n del mont√≥n).  Aqu√≠ hay un ejemplo: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br>  En la l√≠nea (1), el compilador advierte sobre "Asignaci√≥n no verificada". <br><br>  Necesitamos dar otro ejemplo de "contaminaci√≥n de mont√≥n" - cuando usamos objetos parametrizados.  El fragmento de c√≥digo a continuaci√≥n muestra claramente que no est√° permitido usar tipos parametrizados como argumentos para un m√©todo que usa <code>Varargs</code> .  En este caso, el par√°metro del m√©todo m es <code>List&lt;String&gt;‚Ä¶</code> , es decir  de hecho, una matriz de elementos de tipo <code>List&lt;String&gt;</code> .  Dada la regla de mostrar tipos durante el <code>stringLists</code> , el tipo <code>stringLists</code> convierte en una matriz de listas sin procesar ( <code>List[]</code> ), es decir  la asignaci√≥n se puede hacer <code>Object[] array = stringLists;</code>  y luego escribe en una <code>array</code> un objeto que no sea la lista de cadenas (1), que <code>ClassCastException</code> en la cadena (2). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br>  Considere otro ejemplo: <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java permite la asignaci√≥n en la l√≠nea (1).  Esto es necesario para la compatibilidad con versiones anteriores.  Pero si intentamos ejecutar el m√©todo <code>add</code> en la l√≠nea (2), recibimos una advertencia de <code>Unchecked call</code> : el compilador nos advierte de un posible error.  De hecho, estamos tratando de agregar un n√∫mero entero a la lista de cadenas. <br><br><h3>  Reflexion </h3><br>  Aunque, durante la compilaci√≥n, los tipos parametrizados se someten a un procedimiento de borrado de tipo, podemos obtener informaci√≥n utilizando Reflection. <br><br><ul><li>  Todos los reificables est√°n disponibles a trav√©s del mecanismo de reflexi√≥n. <br></li><li>  La informaci√≥n sobre el tipo de campos de clase, los par√°metros del m√©todo y los valores devueltos por ellos est√° disponible a trav√©s de Reflection. <br></li></ul><br>     Reflection          <code>Reifiable</code> ,      . , , ,     - ,         : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br>   Generics  <code>java.lang.Class</code>  .    : <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br>  <code>ints</code>   <code>List&lt;Integer&gt;</code>        <code>ArrayList&lt; Integer&gt;</code> .  <code>ints.getClass()</code>    <code>Class&lt;ArrayLis&gt;</code> ,   <code>List&lt;Integer&gt;</code>   <code>List</code> .   <code>Class&lt;ArrayList&gt;</code>    <code>k</code>  <code>Class&lt;? extends List&gt;</code> ,    ? <code>extends</code> .  <code>ArrayList.class</code>    <code>Class&lt;ArrayList&gt;</code> . <br><br><h3>  Conclusi√≥n </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    ¬´ ¬ª      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     ¬´ ¬ª.     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   ‚Äì <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   ‚Äî   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> ‚Äî    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    ‚Äî     .        JDK 8 ‚Äî        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   ‚Äì    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    (¬´¬ª) ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      ¬´two¬ª. <br><br>   -    JDK1.7 ‚Äì    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     ¬´one¬ª. <code>Checkcast</code> ‚Äì    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2>  Conclusi√≥n </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416413/">https://habr.com/ru/post/es416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416403/index.html">Fintech digest: ataque al banco PIR, Servicio de Impuestos Federales e impuestos de la transferencia de tarjeta a tarjeta, as√≠ como a algunas cadenas de bloques y criptomonedas</a></li>
<li><a href="../es416405/index.html">Programas de licenciatura en asociaci√≥n con Yandex</a></li>
<li><a href="../es416407/index.html">Ahorrando tr√°fico del sniffer de Mikrotik</a></li>
<li><a href="../es416409/index.html">5 errores comunes en el desarrollo de estrategias y formas de lidiar con ellos</a></li>
<li><a href="../es416411/index.html">Cuenta historias con datos</a></li>
<li><a href="../es416415/index.html">Movimos todo en el ensamblaje de prueba Vivaldi 1.16.1230.3</a></li>
<li><a href="../es416417/index.html">"R√≠o celestial" - China crear√° una lluvia artificial de poder sin precedentes</a></li>
<li><a href="../es416419/index.html">Generador de cuevas bidimensional aleatorio</a></li>
<li><a href="../es416421/index.html">Un paseo por el pit lane o c√≥mo las tecnolog√≠as IaaS ayudan a los equipos de carreras</a></li>
<li><a href="../es416423/index.html">C√≥mo los rusos le recordaron el procesador estadounidense o una revisi√≥n del DVR AdvoCam-FD8 Gold-II (GPS + GLONASS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>