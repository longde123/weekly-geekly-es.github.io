<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö†Ô∏è üÜé ‚òùÔ∏è D√©marrage du noyau Linux. Partie 1 ü§µüèΩ üë¶üèº üë®üèæ‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Du chargeur de d√©marrage au noyau 

 Si vous lisez les articles pr√©c√©dents, vous connaissez mon nouveau passe-temps pour la programmation de bas nivea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©marrage du noyau Linux. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428664/"> <b>Du chargeur de d√©marrage au noyau</b> <br><br>  Si vous lisez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> pr√©c√©dents, vous connaissez mon nouveau passe-temps pour la programmation de bas niveau.  J'ai √©crit plusieurs articles sur la programmation des assembleurs pour Linux <code>x86_64</code> et en m√™me temps j'ai commenc√© √† plonger dans le code source du noyau Linux. <br><br>  Je suis tr√®s int√©ress√© de comprendre comment les choses de bas niveau fonctionnent: comment les programmes s'ex√©cutent sur mon ordinateur, comment ils sont situ√©s en m√©moire, comment le noyau g√®re les processus et la m√©moire, comment la pile r√©seau fonctionne √† un bas niveau, et bien plus encore.  J'ai donc d√©cid√© d'√©crire une autre s√©rie d'articles sur le noyau Linux pour l' <b>architecture x86_64</b> . <br><br>  Veuillez noter que je ne suis pas un d√©veloppeur de noyau professionnel et que je n'√©cris pas de code de noyau au travail.  C'est juste un hobby.  J'aime juste les choses de bas niveau et c'est int√©ressant de s'y plonger.  Par cons√©quent, si vous constatez une confusion ou si des questions / commentaires apparaissent, contactez-moi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Twitter</a> , par <a href="">mail</a> ou cr√©ez simplement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ticket</a> .  Je vous en serais reconnaissant. <br><a name="habracut"></a><br>  Tous les articles sont publi√©s dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le r√©f√©rentiel GitHub</a> , et si quelque chose ne va pas avec mon anglais ou le contenu de l'article, n'h√©sitez pas √† envoyer une pull request. <br><br>  <i>Veuillez noter qu'il ne s'agit pas d'une documentation officielle, mais simplement d'une formation et d'un partage de connaissances.</i> <br><br>  <b>Connaissances requises</b> <br><br><ul><li>  Comprendre le code C </li><li>  Comprendre le code assembleur (syntaxe AT&amp;T) </li></ul><br>  Dans tous les cas, si vous commencez tout juste √† apprendre de tels outils, je vais essayer d'expliquer quelque chose dans cet article et les suivants.  D'accord, avec l'introduction termin√©e, il est temps de plonger dans le noyau Linux et les choses de bas niveau. <br><br>  J'ai commenc√© √† √©crire ce livre √† l'√©poque du noyau Linux 3.18, et beaucoup de choses ont chang√© depuis lors.  S'il y a des changements, je mettrai √† jour les articles en cons√©quence. <br><br><h1>  Bouton d'alimentation magique, quelle est la prochaine √©tape? </h1><br>  Bien qu'il s'agisse d'articles sur le noyau Linux, nous ne l'avons pas encore atteint - du moins dans cette section.  D√®s que vous appuyez sur le bouton d'alimentation magique de votre ordinateur portable ou de bureau, il commence √† fonctionner.  La carte m√®re envoie un signal √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">alimentation</a> .  Apr√®s avoir re√ßu le signal, il fournit √† l'ordinateur la quantit√© d'√©lectricit√© n√©cessaire.  D√®s que la carte m√®re re√ßoit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">signal "Power OK"</a> , elle essaie de d√©marrer le CPU.  Il vide toutes les donn√©es restantes dans ses registres et d√©finit des valeurs pr√©d√©finies pour chacun d'eux. <br><br>  Les processeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">80386</a> et versions ult√©rieures doivent avoir les valeurs suivantes dans les registres du CPU apr√®s un red√©marrage: <br><br><pre>  IP 0xfff0
 S√©lecteur CS 0xf000
 CS base 0xffff0000 </pre><br>  Le processeur commence √† fonctionner en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode r√©el</a> .  Revenons un peu en arri√®re et essayons de comprendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la segmentation de la m√©moire</a> dans ce mode.  Le mode r√©el est pris en charge sur tous les processeurs compatibles x86: du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8086</a> aux processeurs Intel 64 bits modernes.  Le processeur 8086 utilise un bus d'adresse 20 bits, c'est-√†-dire qu'il peut fonctionner avec un espace d' <code>0-0xFFFFF</code> de <code>0-0xFFFFF</code> ou <code>1 </code> .  Mais il n'a que des registres 16 bits avec une adresse maximale de <code>2^16-1</code> ou <code>0xffff</code> (64 kilo-octets). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La segmentation de la m√©moire est</a> n√©cessaire pour utiliser tout l'espace d'adressage disponible.  Toute la m√©moire est divis√©e en petits segments d'une taille fixe de <code>65536</code> octets (64 Ko).  √âtant donn√© qu'avec les registres 16 bits, nous ne pouvons pas acc√©der √† la m√©moire sup√©rieure √† 64 Ko, une m√©thode alternative a √©t√© d√©velopp√©e. <br><br>  L'adresse se compose de deux parties: 1) un s√©lecteur de segment avec une adresse de base;  2) d√©calage par rapport √† l'adresse de base.  En mode r√©el, l'adresse de base du <code>  * 16</code> segment <code>  * 16</code> .  Ainsi, pour obtenir l'adresse physique en m√©moire, vous devez multiplier une partie du s√©lecteur de segment par 16 et y ajouter le d√©calage: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Par exemple, si le registre <code>CS:IP</code> a la valeur <code>0x2000:0x0010</code> , alors l'adresse physique correspondante sera comme ceci: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br>  Mais si vous prenez le s√©lecteur du segment le plus grand et le d√©calage <code>0xffff:0xffff</code> , vous obtenez l'adresse: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  c'est-√†-dire <code>65520</code> octets apr√®s le premier m√©gaoctet.  √âtant donn√© qu'un seul m√©gaoctet est disponible en mode r√©el, <code>0x10ffef</code> devient <code>0x00ffef</code> avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la ligne A20</a> d√©sactiv√©e. <br><br>  Eh bien, nous en savons maintenant un peu plus sur le mode r√©el et l'adressage de la m√©moire dans ce mode.  Revenons √† la discussion des valeurs de registre apr√®s r√©initialisation. <br><br>  Le registre <code>CS</code> compose de deux parties: un s√©lecteur de segment visible et une adresse de base cach√©e.  Bien que l'adresse de base soit g√©n√©ralement form√©e en multipliant la valeur du s√©lecteur de segment par 16, lors d'une r√©initialisation mat√©rielle, le s√©lecteur de segment dans le registre CS est <code>0xf000</code> et l'adresse de base est <code>0xffff0000</code> .  Le processeur utilise cette adresse de base sp√©ciale jusqu'√† ce que le CS change. <br><br>  L'adresse de d√©part est form√©e en ajoutant l'adresse de base √† la valeur dans le registre EIP: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br>  Nous obtenons <code>0xfffffff0</code> , soit 16 octets en dessous de 4 Go.  Ce point est appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vecteur de r√©initialisation</a> .  Il s'agit de l'emplacement en m√©moire o√π le CPU attend que la premi√®re instruction s'ex√©cute apr√®s une r√©initialisation: une op√©ration de saut ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jmp</a> ), qui indique g√©n√©ralement le point d'entr√©e du BIOS.  Par exemple, si vous regardez le code source de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coreboot</a> ( <code>src/cpu/x86/16bit/reset16.inc</code> ), nous verrons: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br>  Ici, nous voyons le code d'op√©ration ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opcode</a> ) <code>jmp</code> , √† savoir <code>0xe9</code> , et l'adresse de destination <code>_start16bit - ( . + 2)</code> . <br><br>  Nous voyons √©galement que la section de <code>reset</code> est de 16 octets, et elle se compile pour s'ex√©cuter √† partir de l'adresse <code>0xfffff0</code> ( <code>src/cpu/x86/16bit/reset16.ld</code> ): <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  Le BIOS d√©marre maintenant;  Apr√®s avoir initialis√© et v√©rifi√© le mat√©riel du BIOS, vous devez trouver le p√©riph√©rique de d√©marrage.  L'ordre de d√©marrage est enregistr√© dans la configuration du BIOS.  Lorsque vous essayez de d√©marrer √† partir du disque dur, le BIOS essaie de trouver le secteur de d√©marrage.  Sur les disques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partitionn√©s MBR</a> , le secteur de d√©marrage est stock√© dans les 446 premiers octets du premier secteur, o√π chaque secteur fait 512 octets.  Les deux derniers octets du premier secteur sont <code>0x55</code> et <code>0xaa</code> .  Ils montrent au BIOS qu'il s'agit d'un p√©riph√©rique de d√©marrage. <br><br>  Par exemple: <br><br><pre> <code class="hljs powershell">; ; :       Intel x86 ; [<span class="hljs-type"><span class="hljs-type">BITS</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0</span></span>x0e mov bh, <span class="hljs-number"><span class="hljs-number">0</span></span>x00 mov bl, <span class="hljs-number"><span class="hljs-number">0</span></span>x07 int <span class="hljs-number"><span class="hljs-number">0</span></span>x10 jmp <span class="hljs-variable"><span class="hljs-variable">$</span></span> times <span class="hljs-number"><span class="hljs-number">510</span></span>-(<span class="hljs-variable"><span class="hljs-variable">$</span></span>-<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span>x55 db <span class="hljs-number"><span class="hljs-number">0</span></span>xaa</code> </pre> <br>  Nous collectons et g√©rons: <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QEMU</a> re√ßoit une commande pour utiliser le binaire de <code>boot</code> que nous venons de cr√©er en tant qu'image disque.  √âtant donn√© que le fichier binaire g√©n√©r√© ci-dessus satisfait aux exigences du secteur de d√©marrage (commen√ßant √† <code>0x7c00</code> et se terminant par une s√©quence magique), QEMU consid√©rera le binaire comme l'enregistrement de d√©marrage principal (MBR) de l'image disque. <br><br>  Vous verrez: <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br>  Dans cet exemple, nous voyons que le code s'ex√©cute en mode r√©el 16 bits et commence √† l'adresse <code>0x7c00</code> en m√©moire.  Apr√®s le d√©marrage, il provoque une interruption <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">0x10</a> , qui imprime simplement un caract√®re <code>!</code>  ;  remplit les 510 octets restants par des z√©ros et se termine par deux octets magiques <code>0xaa</code> et <code>0x55</code> . <br><br>  Vous pouvez voir le vidage binaire avec l'utilitaire <code>objdump</code> : <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br>  Bien s√ªr, dans le vrai secteur de d√©marrage, il y a du code pour continuer le processus de d√©marrage et une table de partition au lieu d'un tas de z√©ros et d'un point d'exclamation :).  √Ä partir de ce moment, le BIOS transf√®re le contr√¥le au chargeur de d√©marrage. <br><br>  <i>Remarque</i> : comme expliqu√© ci-dessus, le CPU est en mode r√©el;  o√π le calcul de l'adresse physique en m√©moire est le suivant: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Nous n'avons que des registres √† usage g√©n√©ral 16 bits, et la valeur maximale du registre 16 bits est <code>0xffff</code> , donc aux valeurs les plus √©lev√©es, le r√©sultat sera: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  o√π <code>0x10ffef</code> est <code>1  + 64  - 16 </code> .  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">processeur 8086</a> (le premier processeur en mode r√©el) poss√®de une ligne d'adresse de 20 bits.  Puisque <code>2^20 = 1048576</code> , la m√©moire disponible r√©elle est de 1 Mo. <br><br>  En g√©n√©ral, l'adressage de la m√©moire en mode r√©el est le suivant: <br><br><pre>  0x00000000 - 0x000003FF - table des vecteurs d'interruption du mode r√©el
 0x00000400 - 0x000004FF - Zone de donn√©es du BIOS
 0x00000500 - 0x00007BFF - non utilis√©
 0x00007C00 - 0x00007DFF - notre chargeur de d√©marrage
 0x00007E00 - 0x0009FFFF - non utilis√©
 0x000A0000 - 0x000BFFFF - RAM vid√©o (VRAM) 
 0x000B0000 - 0x000B7777 - m√©moire vid√©o monochrome
 0x000B8000 - 0x000BFFFF - m√©moire vid√©o en mode couleur
 0x000C0000 - 0x000C7FFF - BIOS de la ROM vid√©o
 0x000C8000 - 0x000EFFFF - zone d'ombre (ombre du BIOS)
 0x000F0000 - 0x000FFFFF - BIOS syst√®me </pre><br>  Au d√©but de l'article, il est √©crit que la premi√®re instruction pour le processeur se trouve √† <code>0xFFFFFFF0</code> , ce qui est bien plus que <code>0xFFFFF</code> (1 Mo).  Comment le CPU peut-il acc√©der √† cette adresse en mode r√©el?  R√©ponse dans la documentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coreboot</a> : <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br>  Au d√©but de l'ex√©cution, le BIOS n'est pas en RAM, mais en ROM. <br><br><h1>  Bootloader </h1><br>  Le noyau Linux peut √™tre charg√© avec diff√©rents chargeurs de d√©marrage, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GRUB 2</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syslinux</a> .  Le noyau poss√®de un protocole de d√©marrage qui d√©finit les exigences du chargeur de d√©marrage pour impl√©menter la prise en charge Linux.  Dans cet exemple, nous travaillons avec GRUB 2. <br><br>  En poursuivant le processus de d√©marrage, le BIOS a s√©lectionn√© le p√©riph√©rique de d√©marrage et transf√©r√© le contr√¥le au secteur de d√©marrage, l'ex√©cution commence par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boot.img</a> .  En raison de sa taille limit√©e, il s'agit d'un code tr√®s simple.  Il contient un pointeur pour acc√©der √† l'image principale de GRUB 2. Il commence par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diskboot.img</a> et est g√©n√©ralement stock√© imm√©diatement apr√®s le premier secteur dans l'espace inutilis√© avant la premi√®re partition.  Le code ci-dessus charge en m√©moire le reste de l'image qui contient le noyau GRUB 2 et les pilotes pour le traitement des syst√®mes de fichiers.  Apr√®s cela, la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grub_main</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ex√©cut√©e</a> . <br><br>  La fonction <code>grub_main</code> initialise la console, renvoie l'adresse de base des modules, d√©finit le p√©riph√©rique racine, charge / analyse le fichier de configuration grub, charge les modules, etc.  √Ä la fin de l'ex√©cution, il met grub en mode normal.  La fonction <code>grub_normal_execute</code> (√† partir du fichier source <code>grub-core/normal/main.c</code> ) termine les derni√®res pr√©parations et affiche un menu pour choisir le syst√®me d'exploitation.  Lorsque nous s√©lectionnons l'un des √©l√©ments du menu grub, la fonction <code>grub_menu_execute_entry</code> est <code>grub_menu_execute_entry</code> , qui ex√©cute la commande de <code>boot</code> grub et charge le syst√®me d'exploitation s√©lectionn√©. <br><br>  Comme indiqu√© dans le protocole de d√©marrage du noyau, le chargeur de d√©marrage doit lire et remplir certains champs de l'en-t√™te d'installation du noyau, qui commence √† l'offset <code>0x01f1</code> du code d'installation du noyau.  Ce d√©calage est indiqu√© dans le <a href="">script de</a> l' <a href="">√©diteur de liens</a> .  L'archive d'en-t√™te du noyau <a href="">/ x86 / boot / header.S</a> commence par: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br>  Le chargeur de d√©marrage doit remplir cet en-t√™te et d'autres en-t√™tes (qui sont marqu√©s uniquement en tant que type <code>write</code> dans le protocole de d√©marrage Linux, comme dans cet exemple) avec des valeurs re√ßues de la ligne de commande ou calcul√©es au d√©marrage.  Maintenant, nous ne nous attarderons pas sur les descriptions et explications de tous les champs d'en-t√™te.  Nous verrons plus loin comment le noyau les utilise.  Pour une description de tous les champs, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le protocole de t√©l√©chargement</a> . <br><br>  Comme vous pouvez le voir dans le protocole de d√©marrage du noyau, la m√©moire sera affich√©e comme suit: <br><br><pre>  |  Mode noyau prot√©g√© |
 100000 + ------------------------ +
          |  Mappage d'E / S |
 0A0000 + ------------------------ +
          |  R√©serve  pour BIOS |  Laissez autant que possible gratuitement
          ~ ~
          |  Ligne de commande |  (peut √©galement √™tre inf√©rieur √† X + 10000)
 X + 10000 + ------------------------ +
          |  Pile / tas |  Pour utiliser du vrai code en mode noyau
 X + 08000 + ------------------------ +
          |  Installation du noyau |  Code en mode r√©el du noyau
          |  Secteur de d√©marrage du noyau |  Secteur de d√©marrage du noyau h√©rit√©
        X + ------------------------ +
          |  Chargeur |  &lt;- Secteur de d√©marrage du point d'entr√©e 0x7C00
 001000 + ------------------------ +
          |  R√©serve  pour MBR / BIOS |
 000800 + ------------------------ +
          |  Utiliser habituellement  MBR |
 000600 + ------------------------ +
          |  Utilis√©  BIOS uniquement |
 000000 + ------------------------ +
</pre><br>  Ainsi, lorsque le chargeur transf√®re le contr√¥le au noyau, il commence par l'adresse: <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  o√π <code>X</code> est l'adresse du secteur d'amor√ßage du noyau.  Dans notre cas, <code>X</code> est <code>0x10000</code> , comme le montre le vidage de la m√©moire: <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br>  Le chargeur de d√©marrage a d√©plac√© le noyau Linux en m√©moire, rempli les champs d'en-t√™te, puis d√©plac√© vers l'adresse m√©moire correspondante.  Maintenant, nous pouvons aller directement au code d'installation du noyau. <br><br><h1>  D√©but de la phase d'installation du noyau </h1><br>  Enfin, nous sommes au c≈ìur!  Bien que techniquement, il ne fonctionne pas encore.  Tout d'abord, la partie d'installation du noyau doit configurer quelque chose, y compris un d√©compresseur et certaines choses avec la gestion de la m√©moire.  Apr√®s tout cela, elle d√©ballera le vrai noyau et y ira.  L'installation d√©marre dans <a href="">arch / x86 / boot / header.S</a> avec le caract√®re <a href="">_start</a> . <br><br>  √Ä premi√®re vue, cela peut sembler un peu √©trange, car il y a plusieurs instructions devant lui.  Mais il y a longtemps, le noyau Linux avait son propre chargeur de d√©marrage.  Maintenant, si vous ex√©cutez, par exemple, <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br>  vous verrez: <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br>  En fait, le fichier <code>header.S</code> commence par le nombre magique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MZ</a> (voir la capture d'√©cran du vidage ci-dessus), le texte du message d'erreur et l'en-t√™te <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PE</a> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br>  Il est n√©cessaire de charger un syst√®me d'exploitation avec le support <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UEFI</a> .  Nous consid√©rerons son appareil dans les chapitres suivants. <br><br>  Point d'entr√©e r√©el pour l'installation du noyau: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br>  Le chargeur de d√©marrage (grub2 et autres) conna√Æt ce point (d√©calage <code>0x200</code> rapport √† <code>MZ</code> ) et y acc√®de directement, bien que <code>header.S</code> d√©marre √† partir de la section <code>.bstext</code> , o√π se trouve le texte du message d'erreur: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br>  Point d'entr√©e de l'installation du noyau: <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br>  Ici, nous voyons le code d'op√©ration <code>jmp</code> ( <code>0xeb</code> ), qui va au point <code>start_of_setup-1f</code> .  Dans la notation <code>Nf</code> , par exemple, <code>2f</code> fait r√©f√©rence √† l'√©tiquette locale <code>2:</code>  Dans notre cas, il s'agit de l'√©tiquette <code>1</code> , qui est pr√©sente imm√©diatement apr√®s la transition, et qui contient le reste de l'en-t√™te de configuration.  Imm√©diatement apr√®s l'en-t√™te d'installation, nous voyons la section <code>.entrytext</code> , qui commence par l'√©tiquette <code>start_of_setup</code> . <br><br>  Il s'agit du premier code r√©ellement ex√©cut√© (autre que les instructions de saut pr√©c√©dentes, bien s√ªr).  Apr√®s qu'une partie de l'installation du noyau a re√ßu le contr√¥le du chargeur, la premi√®re instruction <code>jmp</code> est situ√©e √† l'offset <code>0x200</code> depuis le d√©but du mode r√©el du noyau, c'est-√†-dire apr√®s les 512 premiers octets.  Cela peut √™tre vu √† la fois dans le protocole de d√©marrage du noyau Linux et dans le code source grub2: <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br>  Dans notre cas, le noyau d√©marre √† l'adresse <code>0x10000</code> .  Cela signifie qu'apr√®s le d√©marrage de l'installation du noyau, les registres de segments auront les valeurs suivantes: <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br>  Apr√®s √™tre all√© √† <code>start_of_setup</code> noyau devrait faire ce qui suit: <br><br><ul><li>  Assurez-vous que toutes les valeurs de registre de segment sont les m√™mes </li><li>  Si n√©cessaire, configurez la pile correcte </li><li>  Configurer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bss</a> </li><li>  Acc√©dez au code C dans <a href="">arch / x86 / boot / main.c</a> </li></ul><br>  Voyons comment cela est mis en ≈ìuvre. <br><br><h1>  Alignement de cas de segment </h1><br>  Tout d'abord, le noyau v√©rifie que les registres des segments <code>ds</code> et <code>es</code> pointent vers la m√™me adresse.  Il efface ensuite l'indicateur de direction √† l'aide de l' <code>cld</code> : <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br>  Comme je l'ai √©crit plus t√¥t, grub2 charge par d√©faut le code d'installation du noyau √† <code>0x10000</code> et <code>cs</code> √† <code>0x10200</code> , car l'ex√©cution ne d√©marre pas au d√©but du fichier, mais √† partir de la transition ici: <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br>  Il s'agit d'un d√©calage de <code>512</code> octets par rapport √† <a href="">4d 5a</a> .  Il est √©galement n√©cessaire d'aligner <code>cs</code> de <code>0x10200</code> √† <code>0x10000</code> , comme tous les autres registres de segment.  Apr√®s cela, installez la pile: <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br>  Cette instruction pousse la valeur <code>ds</code> sur la pile, suivie de l'adresse de l'√©tiquette <a href="">6</a> et de l'instruction <code>lretw</code> , qui charge l'adresse de l'√©tiquette <code>6</code> dans le registre du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compteur de commandes</a> et charge <code>cs</code> avec la valeur <code>ds</code> .  Apr√®s cela, <code>ds</code> et <code>cs</code> auront les m√™mes valeurs. <br><br><h1>  Configuration de la pile </h1><br>  Presque tout ce code fait partie du processus de pr√©paration de l'environnement C en mode r√©el.  L'√©tape suivante consiste √† v√©rifier la valeur du registre <code>ss</code> et √† cr√©er la pile correcte si la valeur <code>ss</code> est incorrecte: <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br>  Cela peut d√©clencher trois sc√©narios diff√©rents: <br><br><ul><li>  <code>ss</code> valeur valide de <code>0x1000</code> (comme avec tous les autres registres sauf <code>cs</code> ) </li><li>  <code>ss</code> valeur non valide et l'indicateur <code>CAN_USE_HEAP</code> d√©fini (voir ci-dessous) </li><li>  <code>ss</code> valeur non valide et l'indicateur <code>CAN_USE_HEAP</code> pas d√©fini (voir ci-dessous) </li></ul><br>  Consid√©rez tous les sc√©narios dans l'ordre: <br><br><ul><li>  <code>ss</code> valeur valide ( <code>0x1000</code> ).  Dans ce cas, nous allons au label 2: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br>  Ici, nous d√©finissons l'alignement du registre <code>dx</code> (qui contient la valeur <code>sp</code> indiqu√©e par le chargeur de d√©marrage) sur <code>4</code> octets et v√©rifions z√©ro.  S'il est nul, nous mettons la valeur <code>0xfffc</code> <code>dx</code> (adresse align√©e sur <code>4</code> octets avant la taille maximale de segment de 64 Ko).  S'il n'est pas √©gal √† z√©ro, nous continuons √† utiliser la valeur <code>sp</code> sp√©cifi√©e par le chargeur de d√©marrage ( <code>0xf7f4</code> dans notre cas).  Ensuite, nous mettons la valeur <code>ax</code> dans <code>ss</code> , ce qui enregistre l'adresse de segment correcte <code>0x1000</code> et d√©finit la bonne <code>sp</code> .  Maintenant, nous avons la bonne pile: <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li>  Dans le deuxi√®me sc√©nario, <code>ss != ds</code> .  D'abord, nous mettons la valeur <a href="">_end</a> (l'adresse de la fin du code d'installation) dans <code>dx</code> et v√©rifions les <code>loadflags</code> champ d'en-t√™te, en utilisant l'instruction <code>testb</code> pour v√©rifier si le tas peut √™tre utilis√©.  <a href="">loadflags</a> est un en-t√™te de masque de bits d√©fini comme suit: </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br>  et comme indiqu√© dans le protocole de d√©marrage: <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br>  Si le bit <code>CAN_USE_HEAP</code> est <code>CAN_USE_HEAP</code> , dans <code>dx</code> nous d√©finissons la valeur <code>heap_end_ptr</code> (qui pointe vers <code>_end</code> ) et y ajoutons <code>STACK_SIZE</code> (la taille minimale de la pile est de <code>1024</code> octets).  Apr√®s cela, passez √† l'√©tiquette <code>2</code> (comme dans le cas pr√©c√©dent) et faites la bonne pile. <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li>  Si <code>CAN_USE_HEAP</code> pas d√©fini, utilisez simplement la pile minimale de <code>_end</code> √† <code>_end + STACK_SIZE</code> : </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  Configuration de BSS </h1><br>  Deux √©tapes suppl√©mentaires sont n√©cessaires avant de passer au code C principal: il s'agit de configurer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">zone BSS</a> et de v√©rifier la signature ¬´magique¬ª.  V√©rification de signature d'abord: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br>  L'instruction compare simplement <a href="">setup_sig</a> avec le nombre magique 0x5a5aaa55.  S'ils ne sont pas √©gaux, une erreur fatale est signal√©e. <br><br>  Si le nombre magique correspond et que nous avons un ensemble de registres de segments corrects et une pile, alors tout ce qui reste √† faire est de configurer la section BSS avant de passer au code C. <br><br>  La section BSS est utilis√©e pour stocker des donn√©es non initialis√©es allou√©es statiquement.  Linux v√©rifie soigneusement que cette zone m√©moire est r√©initialis√©e: <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br>  Tout d'abord, l'adresse de d√©but de <a href="">__bss_start est</a> d√©plac√©e vers <code>di</code> .  Ensuite, l'adresse <code>_end + 3</code> (+3 pour l'alignement sur 4 octets) est d√©plac√©e vers <code>cx</code> .  Le registre <code>eax</code> est effac√© (√† l'aide de l'instruction <code>xor</code> ), la taille de la partition bss ( <code>cx-di</code> ) est calcul√©e et elle est plac√©e dans <code>cx</code> .  Ensuite, <code>cx</code> est divis√© en quatre (la taille du ¬´mot¬ª) et l'instruction <code>stosl</code> est utilis√©e √† <code>stosl</code> , stockant la valeur <code></code> (z√©ro) dans l'adresse pointant vers <code>di</code> , augmentant automatiquement <code>di</code> de quatre et r√©p√©tant cela jusqu'√† ce que <code></code> atteigne z√©ro).  L'effet net de ce code est que les z√©ros sont √©crits sur tous les mots en m√©moire de <code>__bss_start</code> √† <code>_end</code> : <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1>  Aller √† la page principale </h1><br>  C'est tout: nous avons une pile et un BSS, vous pouvez donc aller √† la fonction C <code>main()</code> : <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  La fonction <code>main()</code> se trouve dans <a href="">arch / x86 / boot / main.c.</a>  Nous parlerons d'elle dans la prochaine partie. <br><br><h1>  Conclusion </h1><br>  Ceci est la fin de la premi√®re partie sur le p√©riph√©rique du noyau Linux.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez des questions ou des suggestions, contactez-moi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou cr√©ez simplement un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ticket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans la partie suivante , </font><font style="vertical-align: inherit;">nous verrons le premier code en C, qui est effectu√©e lors de </font><font style="vertical-align: inherit;">l'installation du noyau Linux, la mise en </font><font style="vertical-align: inherit;">≈ìuvre des sous-programmes de m√©moire, tels que </font></font><code>memset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>earlyprintk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, au </font><font style="vertical-align: inherit;">d√©but de la </font><font style="vertical-align: inherit;">mise en </font><font style="vertical-align: inherit;">≈ìuvre et l' </font><font style="vertical-align: inherit;">initialisation de la console, et plus encore.</font></font><br><br><h1>  Les r√©f√©rences </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rence du programmeur Intel 80386 1986</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chargeur de d√©marrage minimal pour l'architecture Intel</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8086</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80386</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©initialiser le vecteur</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode r√©el</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocole de d√©marrage du noyau Linux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guide du d√©veloppeur Coreboot</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste d'interruption de Ralph Brown</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source d'alimentation</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Signal ¬´L'alimentation est OK¬ª</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428664/">https://habr.com/ru/post/fr428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428654/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 15: Logiciels m√©dicaux, partie 2</a></li>
<li><a href="../fr428656/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 15: Logiciels m√©dicaux, partie 3</a></li>
<li><a href="../fr428658/index.html">Ateliers p√©dagogiques gratuits dans les bureaux de Mail.Ru Group</a></li>
<li><a href="../fr428660/index.html">Activation des strat√©gies de demande d'extraction extensible dans VSTS pour prendre en charge le processus de d√©veloppement</a></li>
<li><a href="../fr428662/index.html">T√¢che de programmation de vente au d√©tail</a></li>
<li><a href="../fr428666/index.html">Comment j'ai cr√©√© des animations qui changent l'humeur en utilisant des masques CSS</a></li>
<li><a href="../fr428668/index.html">Blizzard a annonc√© la sortie de la r√©√©dition de WarCraft III en 2019. Pr√©-commande ouverte</a></li>
<li><a href="../fr428672/index.html">Pr√©sentation de QuietOn Active Squelch</a></li>
<li><a href="../fr428674/index.html">Cr√©ation de routage client / recherche s√©mantique sur Profi.ru</a></li>
<li><a href="../fr428676/index.html">Briser les fondements fondamentaux de C #: allouer de la m√©moire pour un type de r√©f√©rence sur la pile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>