<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 ♋️ 🛢️ Reverse Engineering der Gerätefirmware am Beispiel eines blinkenden „Nashorns“. Teil 2 👨🏿‍🤝‍👨🏻 💶 💝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir stellen Ihnen den zweiten Teil des Artikels über das Reverse Engineering der Flashing Rhino-Gerätefirmware vor, der auf einem Workshop auf der SMA...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reverse Engineering der Gerätefirmware am Beispiel eines blinkenden „Nashorns“. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/412561/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/yo/jz/nyyojzktr_-hcfv4j7ygq_eaiuu.png"></div><br>  Wir stellen Ihnen den zweiten Teil des Artikels über das Reverse Engineering der Flashing Rhino-Gerätefirmware vor, der auf einem Workshop auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMARTRHINO-2018-</a> Konferenz basiert. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im ersten Teil des</a> Artikels wurde die Gerätefirmware in den IDA-Disassembler geladen und eine erste Analyse der Geräteprotokollbefehle durchgeführt.  Einzelne Befehle wurden auf einem Arbeitsgerät getestet. <br><br>  Im zweiten Teil wird eine Analyse der verbleibenden Firmware-Aufgaben durchgeführt. <br><br>  Ich möchte Sie daran erinnern, dass nach der Analyse der Bluetooth-Aufgabe im Hinblick auf die Steuerung von LEDs beschlossen wurde, zur LED-Aufgabe zu wechseln, da die erste Aufgabe darin besteht, eine Anwendung zur Steuerung von LEDs zu erstellen. Dazu ist ein detailliertes Verständnis des Firmware-Betriebs erforderlich. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Firmware-Datei</a> steht für unabhängige Studien zur Verfügung. <br><br>  <i>Alle Informationen werden nur zu Bildungszwecken bereitgestellt.</i> <br><br>  Unter der Katze gibt es viele blinkende Nashörner. <br><a name="habracut"></a><br><h2>  LED Aufgabe </h2><br>  <i>Kurz gesagt: eine vollständige Analyse der Aufgabe, die für das Schalten von LEDs verantwortlich ist.</i>  <i>Analyse von Datentypen und globalen Variablen.</i> <br><br>  Die LED-Aufgabe wird durch die Funktion <b>x_leds_task dargestellt</b> , die sich unter <code>0x08005A08</code> . <br><br>  Zusätzlich zu den seltsamen Zeilen "Ich habe eine Superleistung ..." in der Hauptfunktion der LED-Aufgabe können Sie auf die Zeile <b>"Farbton&gt; max: Glanz ändern \ r \ n"</b> achten. <br><br><img src="https://habrastorage.org/webt/6j/7u/qv/6j7uqvcupizmfsbqca81as5dwlw.png"><br><br>  Gleichzeitig sehen wir eine vertraute Situation - (WORD *) (v26 + 4).  Wählen Sie im Kontextmenü der Variablen v26 das Element "In Struktur konvertieren *" aus und geben Sie die zuvor erstellte Struktur an: <br><br><img src="https://habrastorage.org/webt/6a/2i/jv/6a2ijvqm631yl3ce5z6uom02znw.png"><br><br>  Da <code>v5 = v26</code> , wiederholen wir die Operation <i>"In Struktur konvertieren *"</i> für die Variable v5. <br><br>  Wir strukturieren weiterhin den Code und die Daten.  Stellen Sie die Hex-Darstellung überall ein.  Umbenennen: <br><br><ul><li>  v5 - <b>geführt</b> ; </li><li>  v6 - <b>idx</b> ; </li><li>  v8 - <b>hue_1</b> ; </li><li>  v9 - <b>hue_2</b> ; </li><li>  v26 - <b>_led</b> ; </li></ul><br>  Der Code verbessert sich.  Einige Variablen verletzen jedoch immer noch das Auge, z. B. die Variable v23: <br><br><img src="https://habrastorage.org/webt/pz/cp/ch/pzcpchfjgrlwgwwtbun85x6weve.png"><br><br><img src="https://habrastorage.org/webt/k1/4k/fi/k14kfil99uzjgtwdpimtjcrl-ye.png"><br><br><div class="spoiler">  <b class="spoiler_title">Anscheinend ist v23 ein Array von 4 Bytes.</b> <div class="spoiler_text">  idx ist der Index der LED;  Dieser Index wird der Basisadresse hinzugefügt.  Auf diese Weise wird auf Elemente mit denselben Verschiebungen zugegriffen - so verhalten sich Arrays. <br></div></div><br>  Wir weisen den Typ <code>char v23[4]</code> und benennen ihn in <b>leds_smth um</b> . Der Code wird schöner: <br><br><img src="https://habrastorage.org/webt/3a/zp/vv/3azpvvasy-8oabd8be6tshcy6z8.png"><br><br>  Sie können auch feststellen, dass das Ergebnis der Funktion x_queue_recv an die Variable v25 zurückgegeben wird: <br><br><pre> <code class="cpp hljs">x_queue_recv(&amp;v25, leds_queue, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Möglicherweise ist jedoch nicht klar, wie sich die benötigten Daten in der <i>_led-</i> Struktur befinden.  Tatsache ist, dass sich die Variablen v25 und _led <b><i>in der Nähe des Stapels befinden</i></b> - dies kann durch die Tatsache verstanden werden, dass sie beim Dekompilieren in benachbarte Zeilen geschrieben werden.  Die Position der Variablen auf dem Stapel wird in einem separaten Fenster angezeigt, wenn Sie auf die Variable doppelklicken: <br><br><img src="https://habrastorage.org/webt/gm/1z/qs/gm1zqsoxvvppvneguj76arsppdu.png"><br><br>  Es handelt sich wahrscheinlich um eine Struktur, oder der Compiler hat einige Optimierungen vorgenommen.  Somit kann argumentiert werden, dass Daten von der Bluetooth-Aufgabe an die LED-Aufgabe übertragen werden.  Um dies genauer herauszufinden, überprüfe ich das Gerät - für die Null-LED über Bluetooth sende ich die Werte <b>0x208</b> , <b>0x2D0</b> , <b>0x398</b> , <b>0x3E9</b> , die im Code <b>erkennbar</b> sind: <br><br><img src="https://habrastorage.org/webt/f-/1k/ds/f-1kdsphlzdbhuc4q6dwtfk6zge.png"><br><br>  Die Ergebnisse der Überprüfung des Farbtonwerts auf dem Gerät: <br><br><ul><li>  0x208 - Die LEDs schalteten nicht mehr reibungslos und wurden in den Farben Rot, Grün, Blau, Lila eingestellt. </li><li>  0x2D0 - die LEDs begannen wieder zu schalten; </li><li>  0x398 - nichts hat sich geändert; </li><li>  0x3E9 - nichts hat sich geändert. </li></ul><br>  Wenn Sie sich den Code noch einmal ansehen, sehen Sie, dass der Wert 0x398 logisch einem Wert kleiner als 0x167 zugeordnet werden kann (für das Array-Element <i>leds_smth werden</i> unterschiedliche Werte <i>festgelegt</i> ).  Daher werde ich diese Prüfung durchführen: Zuerst setze ich die erste LED auf Grün (Farbton = 0x78, <code>LED 010078FF20</code> ), während die anderen drei LEDs weiterhin ihre Farben wechseln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5h/mp/dc/5hmpdckwscpkhlgvth05w1xvmuy.gif"></div><br>  Jetzt werde ich <code>LED 010398FFFF</code> Bluetooth-Protokollbefehl <code>LED 010398FFFF</code> - danach hat die erste LED in den allgemeinen Farbumschaltmodus geschaltet. <br><br>  Somit setzt der Farbtonwert von 0x398 den statischen Farbwert zurück, was bedeutet, dass das Array leds_smth Flags (0 oder 1) für die zu besetzenden LEDs enthält: <br><br><ul><li>  0 - die LED ist nicht besetzt, nimmt an einer reibungslosen Farbumschaltung teil ( <b>Farbton = 0x398</b> ); </li><li>  1 - Die LED ist besetzt, der Benutzer hat eine statische Farbe eingestellt ( <b>Farbton &lt;= 0x167</b> ). </li></ul><br>  Benennen <b>Sie</b> leds_smth in <b>leds_busy um</b> . <br><br>  Nun sollte der Zweck des folgenden Codeblocks klar werden: <br><br><img src="https://habrastorage.org/webt/sb/x8/mf/sbx8mfnnah6gziclrsqmgdcmpu0.png"><br><br>  Der Zyklus in den Zeilen 83-101 führt ein glattes Farbmosaik mit einem Farbwechselschritt von 5 aus: <code>v12 += 5</code> .  Wenn die LED eine statische Farbe hat, nimmt diese LED nicht am Mosaik teil.  Nach dem Zyklus gibt es Linien der kurzfristigen Einbeziehung aller LEDs. <br><br>  Umbenennen: <br><br><ul><li>  sub_800678A - <b>x_led_set_hsv</b> ; </li><li>  v12 - <b>hue_step</b> ; </li><li>  v13, v17, v18, v19 - <b>led0_busy</b> , <b>led1_busy</b> , <b>led2_busy</b> , <b>led3_busy</b> ; </li><li>  v11, v20, v21, v22 - <b>Farbton0</b> , <b>Farbton1</b> , <b>Farbton2</b> , <b>Farbton3</b> ; </li><li>  dword_200004C4 - <b>led_control</b> . </li></ul><br>  Die Funktion sub_80039FE führt vermutlich ein Timeout durch (andernfalls haben die LEDs nicht reibungslos, sondern sofort geschaltet). Nennen <b>wir</b> es <b>x_sleep</b> , und die Variable v16 lautet <b>led_timeout</b> . <br><br>  Der Zweck der Funktion sub_8006934 ist noch nicht klar, wird jedoch überall verwendet, nachdem die Farbe auf den LEDs eingestellt wurde - Sie können sie <b>x_led_fix_color nennen</b> . <br><br>  Nach dieser Umbenennung ist die Funktion <b>sub_8006944</b> (im Zweig hue &lt;= 0x167 aufgerufen) leicht zu verstehen: <br><br><img src="https://habrastorage.org/webt/nf/8a/j-/nf8aj-jzfsk9livqh_zxpwtojgq.png"><br><br>  Es wird lediglich eine zusätzliche Überprüfung durchgeführt, um die Farbe der LED zu bestimmen.  Benennen Sie die Funktion sub_8006944 in <b>x_led_set_hsv_wrap um</b> (Suffix <i>_wrap</i> - eine Erklärung, dass dies ein "Wrapper" über eine andere Funktion ist) und legen Sie den folgenden Prototyp dafür fest: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_led_set_hsv_wrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_control, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">signed</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span></span></code> </pre> <br>  Kehren wir eine Ebene zurück zur Funktion x_leds_task.  Wenn Sie sich den Code noch einmal ansehen, können Sie feststellen, dass der Zweig "Farbton&gt; 0x3E8" folgendermaßen aussah: <br><br><img src="https://habrastorage.org/webt/sh/tm/5j/shtm5jrmecd3quimykrcgognngs.png"><br><br>  Das heißt, ein Farbtonwert größer als 0x3E8 sollte das Zeitlimit des farbigen Mosaiks ändern.  Ich überprüfe dies, indem ich einige Werte an das Gerät sende: <br><br><ul><li>  Farbton = 0x3E9 - Die LEDs begannen schnell zu schalten: <br><br><img src="https://habrastorage.org/webt/1z/an/to/1zantozqcbgf0ho69jmgbvdd8v8.gif"><br></li><li>  hue = 0xFFFF - die LEDs begannen sehr langsam zu schalten: <br><br><img src="https://habrastorage.org/webt/jr/ty/sn/jrtysngekw8_1ise6uwd0kikrhc.gif"><br></li></ul><br>  Beim Verlassen des <b>Hauptzyklus</b> der LED-Task wird die Funktion <b>sub_8003C44 verwendet</b> , die auch in der Funktion sub_8005070 verwendet wird: <br><br><img src="https://habrastorage.org/webt/ow/ws/ql/owwsqly9wu0bhmwzhu3r7buky5s.png"><br><br>  Umbenennen: <br><br><ul><li>  sub_8005070 - <b>x_freeMsg</b> ; </li><li>  sub_8003C44 - <b>x_free_queue</b> . </li></ul><br>  Weiter in der LED-Aufgabe kann der folgende Zweig nur Aufmerksamkeit erregen: <br><br><img src="https://habrastorage.org/webt/iu/q6/rr/iuq6rrf54hzoupmpslmnp0r8pcu.png"><br><br>  Sie können versuchen, den <code>LED B816D8D90000FFFF</code> Befehl <code>LED B816D8D90000FFFF</code> .  Wenn Sie sich jedoch daran erinnern, dass nur 2 Zeichen als LED-Index verwendet werden, ist ein Versuch, diesen Code zu erreichen, offensichtlich erfolglos.  Lassen Sie diesen Thread für später.  Benennen Sie die Funktion sub_8004AE8 in <b>x_mad_blinking um</b> und es ist Zeit, die Signatur der <b>x_printf-</b> Funktion zu <b>korrigieren</b> (das letzte Mal, als ich die falsche Signatur geschrieben habe): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span></code> </pre> <br>  Der Hauptzyklus der LED-Aufgabe wird zerlegt, aber am Anfang der Aufgabe befindet sich noch ein Code. <br><br>  Schauen wir uns den Code an: <br><br><img src="https://habrastorage.org/webt/kt/xx/wn/ktxxwnzjvx9eqkkuiydzlro3vz4.png"><br><br>  In Zeile 49 werden die LEDs höchstwahrscheinlich auf Verfügbarkeit überprüft, und im Fehlerfall wird die Funktion sub_8004BBC aufgerufen, die Interrupts ausschaltet und eine Endlosschleife startet, in der die Zeile "../Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c" verwendet wird.  Höchstwahrscheinlich handelt es sich um eine <b>Assert-</b> oder ähnliche Funktion. <br><br>  Umbenennen: <br><br><ul><li>  sub_8004BBC - <b>x_gpio_assert</b> ; </li><li>  sub_800698C - <b>x_check_gpio</b> . </li></ul><br>  Der Zweck der Funktion <b>sub_8006968</b> wird deutlich, wenn Sie sich das Gerät beim <b>Einschalten</b> genau ansehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/ap/t4/i8apt4kjg6rrbu73wzya5noyx6m.gif"></div><br>  Alle vier LEDs zusammen leuchten zuerst rot, dann grün und dann blau.  Danach werden sie nach Farbe eingestellt: 0-rot, 1-grün, 2-blau, 3-violett.  Und erst dann beginnen sie, Mosaike zu wechseln. <br><br>  Da das Mosaik im Hauptaufgabenzyklus beginnt, ist es logisch, dass die Zeilen 58 bis 61 vor dem Hauptzyklus für die kurzfristige Aufnahme verschiedener Farben in die LEDs verantwortlich sind und die Zeilen 52 bis 56 für die gleichzeitige Einstellung von Rot-Grün-Blau auf allen LEDs verantwortlich sind.  Benennen Sie die Funktion sub_8006968 in <b>x_led_all_set_rgb um</b> (RGB - nach den übergebenen Argumenten rein <b>ahnungslos</b> ). <br><br><h2>  Seltsamkeiten in der LED-Aufgabe </h2><br>  <i>Kurz gesagt: Definieren der Funktionalität von Code mit seltsamen Zeilen.</i>  <i>Generieren eines Passworts für das Gerät.</i> <br><br>  Fahren wir nun mit dem Anfang der Funktion x_leds_task fort: <br><br><img src="https://habrastorage.org/webt/k1/64/2j/k1642jmvbxu5d0a7vs5lrtd3pru.png"><br><br>  <b>"Eraze"</b> , <b>"gen"</b> , <b>"flash"</b> , <b>"reset"</b> - warum ist das alles ??? <br><br>  Versuchen wir es herauszufinden. <br><br>  Sei sub_80066BC <b>x_leds_task_init</b> . <br><br>  Schauen wir uns sub_8006B38 an: <br><br><img src="https://habrastorage.org/webt/qa/80/ez/qa80ezojcnsyo_vz_q1hru7whz8.png"><br><br>  Reines Wasser memset, stimme zu? <br><br><img src="https://habrastorage.org/webt/pf/oa/tf/pfoatfwwwasjk338b3lphqiiya4.png"><br><br>  Zurück zu x_leds_task.  Mit dem Variablentyp v24 stimmt etwas nicht: <br><br><img src="https://habrastorage.org/webt/vg/ag/8u/vgag8ujkoylag2iryzujjvjldfu.png"><br><br>  Die IDA hat einen kleinen Fehler mit dem Typ gemacht, aber ein Kommentar mit einer Stapelmarkierung hilft uns.  Zwischen den Variablen v24 und v25 bis zu 12 Byte (0x44 - 0x38).  Daher benennen wir v24 in <b>buf um</b> und weisen den Typ <code>unsigned __int8 buf[12]</code> (Ida warnt, dass der neue Datentyp größer als der alte ist - wir sind uns einig). <br><br>  Weiter.  Funktion sub_8004CE4: <br><br><img src="https://habrastorage.org/webt/sc/qg/tw/scqgtwrqr1vzlaubtsqstydsqmu.png"><br><br>  Benennen Sie <i>a1</i> in <b>buf</b> , <i>v1</i> in <b>_buf um</b> . <br><br>  Funktion sub_8006B26: <br><br><img src="https://habrastorage.org/webt/gs/du/ff/gsduffmdls272wqpmmv6_klqxdm.png"><br><br>  Hast du sie erkannt? <br><br><div class="spoiler">  <b class="spoiler_title">Und wenn ohne Make-up?</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8k/1d/p9/8k1dp9nmxkl0xjktjtsk_cp2vem.png"><br>  Natürlich <b>memcpy</b> .  Umbenennen. <br></div></div><br>  Der Zweck der Funktion sub_8004CE4 besteht dann darin, einige Daten an der Adresse <b>0x08007C00 zu erhalten</b> .  Diese Adresse liegt übrigens im Adressbereich des Flash-Speichers des Mikrocontrollers (und insbesondere der Firmware).  Benennen <b>Sie</b> sub_8004CE4 in <b>x_read_data_0x08007C00 um</b> . <br><br>  X_leds_task Funktionszeile 36: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">65</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0x19</span></span> )</code> </pre> <br>  Ändern Sie die Datenanzeige (R-Taste auf der Nummer 65, H-Taste auf der Nummer 0x19): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'A'</span></span> &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> )</code> </pre> <br>  Nach einigem Nachdenken können Sie verstehen, dass dies ein solcher Test für den Bereich des lateinischen Alphabets AZ ist. <br><br>  Benennen Sie als Nächstes mithilfe der Eingabeaufforderungen in Form von Formatzeichenfolgen Folgendes um: <br><br><ul><li>  sub_8004C10 - <b>x_erase</b> ; </li><li>  sub_80059C8 - <b>x_gen</b> ; </li><li>  sub_8004C84 - <b>x_flash</b> . </li></ul><br>  Die Funktion sub_8003C66 macht nichts Bemerkenswertes - sie erhöht nur einige globale Variablen - benennt sub_8003C66 in <b>x_smth_inc um</b> . <br><br>  Die Funktion <b>x_erase</b> akzeptiert tatsächlich keine Argumente - dies kann im Disassembler überprüft werden: <br><br><img src="https://habrastorage.org/webt/rv/p3/_i/rvp3_iqmhzsegjqyi3mugvpxnis.png"><br><br>  In x_erase wird die bekannte Adresse 0x08007C00 verwendet und auf drei unbekannte Funktionen zugegriffen: <br><br><img src="https://habrastorage.org/webt/ys/nb/_b/ysnb_bfgd19htkrnmbyo5hudr0m.png"><br><br>  Ein <b>kurzer Blick</b> auf diese drei Funktionen zeigt, dass sie auf Adressen im Bereich von <b>0x40022000 - 0x400223FF zugreifen</b> .  In der Dokumentation zum Mikrocontroller ist eindeutig angegeben, dass dies der Bereich <b>„FLASH Interface“</b> ist.  Das heißt, die x_erase-Funktion löscht einen Teil des Flash-Speichers - großartig! <br><br>  Anscheinend schreibt die Funktion x_flash in den Flash-Speicher, nachdem die Länge der Zeile zum Schreiben überprüft wurde (die Argumente a2 und a3 sind hier übrigens überflüssig - wir helfen Idea): <br><br><img src="https://habrastorage.org/webt/ki/di/zi/kidizigfv5lb6bwg24aspkgvxmw.png"><br><br>  Und das alles passiert im "Beleuchtungsgerät" ??? <br><br>  Was ist mit der Funktion <b>x_gen</b> ?  Nach einem kurzen Blick und dem Umbenennen von Variablen sieht es folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/v3/js/nb/v3jsnb8jb36wstn3obcln2c3pvk.png"><br><br>  Die Funktion <b>sub_8006CB4</b> sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/ub/h1/rk/ubh1rki0ikjrygsiqcx9vuwylxc.png"><br><br>  Und <b>sub_8006D10</b> - so: <br><br><img src="https://habrastorage.org/webt/gp/qy/oc/gpqyocts_ubcd4u3ep9koyrcb0o.png"><br><br>  Halten Sie den Wunsch nicht zurück, im Internet nach diesen unanständig schönen Konstanten zu suchen: <b>0xABCD</b> , <b>0x1234</b> , <b>0xE66D</b> , <b>0xDEEC</b> , <b>0x4C957F2D</b> und <b>0x5851F42D</b> .  Wenn das Internet noch nicht vollständig gesperrt ist, finden Sie diese Konstanten wahrscheinlich in der Quelle für <b>zufällige Funktionen</b> .  Kein Wunder, dass die übergeordnete Funktion x_gen heißt. <br><br>  Dies ist auch eine sehr typische Situation: Rufen Sie srand () vor der Schleife auf und rufen Sie random () in der Schleife auf. Benennen Sie es also um: <br><br><ul><li>  sub_8006D10 - x_rand; </li><li>  sub_8006CB4 - x_srand. </li></ul><br>  Ein neugieriger Leser kann anhand der Funktion <b>sub_8005098</b> herausfinden, <i>woher</i> der Startwert für die srand-Funktion stammt. <br><br>  Somit generiert die Funktion x_gen <b>eine zufällige Zeichenfolge mit der angegebenen Größe</b> . <br><br>  Nachdem die generierte Zeile in den Flash-Speicher geschrieben wurde, wird das Gerät neu gestartet: <br><br><img src="https://habrastorage.org/webt/a9/ta/rr/a9tarrhqqc-jj7g-e-dplvr67py.png"><br><br>  Es scheint ein seltsamer Neustart zu sein.  Wenn wir uns jedoch die Liste der Aufgaben dieses Geräts ansehen, finden wir unter ihnen "watchdogTask".  Wenn es eine "feststeckende Aufgabe" gibt, wird der Watchdog offensichtlich neu gestartet. <br><br>  Eine LED-Aufgabe mit Ausnahme des MadBlinking-Modus kann als analysiert betrachtet werden. <br><br>  Lassen Sie uns durch die Zeilen schauen, welche anderen Aufgaben im System sind: <br><br><img src="https://habrastorage.org/webt/fz/yj/yk/fzyjykt6djuq8v20hjpuw5l0xow.png"><br><br>  Nachdem Sie die Links zu Zeichenfolgen im Code wiederhergestellt haben, sehen Sie dieses Bild: <br><br><img src="https://habrastorage.org/webt/ha/bl/ks/hablksetvyb0rskx6veqrxbt_z0.png"><br><br>  Zuerst gibt es eine Verknüpfung zu einer Zeichenfolge mit der Namensaufgabe, dann eine Verknüpfung zur Hauptaufgabenfunktion.  Und sie werden in der <b>Hauptfunktion</b> verwendet, in der diese Aufgaben gestartet werden: <br><br><img src="https://habrastorage.org/webt/oc/ah/qd/ocahqdn8usagpkr-isbabunuwms.png"><br><br>  Lassen Sie uns die fehlenden Umbenennungen ausführen: <br><br><ul><li>  sub_80050FC - <b>x_sensor_task</b> ; </li><li>  sub_8004AAC - <b>x_watchdogTask</b> ; </li><li>  sub_8005440 - <b>x_uartRxTask</b> . </li></ul><br><h2>  Watchdog-Aufgabe </h2><br>  Task Watchdog macht nichts besonders Interessantes: <br><br><img src="https://habrastorage.org/webt/m-/65/5w/m-655wpo6oboqmrob1tonwaoska.png"><br><br>  Umbenennen: <br><br><ul><li>  dword_200003F8 - <b>wd_variable</b> ; </li><li>  sub_8001050 - <b>x_update_wd_var</b> . </li></ul><br><h2>  UART-Aufgabe </h2><br>  <i>Kurz gesagt: Suchen Sie nach Daten und Funktionen, die Links von verschiedenen Funktionen enthalten.</i>  <i>Bestimmung ihres Zwecks.</i> <br><br>  Ein kurzer Blick auf die UART-Task ermöglicht es Ihnen, das Senden von Daten an eine unbekannte Warteschlange zu erkennen, die durch die Variable <b>unk_200003EC definiert ist</b> : <br><br><img src="https://habrastorage.org/webt/8j/ei/zz/8jeizzxpvgu5opijgopamebser0.png"><br><br>  Nachdem die Links zu dieser Variablen über die binäre Suche wiederhergestellt wurden, werden wir sehen, dass sie zusätzlich zu x_uartRxTask in der Hauptfunktion (dort wird anscheinend die Warteschlange erstellt) und in der bisher unbekannten Funktion <b>sub_80051EC verwendet wird</b> : <br><br><img src="https://habrastorage.org/webt/g2/md/sg/g2mdsgx9wwhzpklgcacelye8rb8.png"><br><br>  Umbenennen: <br><br><ul><li>  sub_80051EC - <b>x_recvMsg_uart_queue</b> ; </li><li>  unk_200003EC - <b>uart_queue</b> . </li></ul><br>  Siehe Querverweise zu x_recvMsg_uart_queue: <br><br><ul><li>  sub_8005250; </li><li>  x_bluetooth_task. </li></ul><br>  Siehe zuerst die Funktion <b>sub_8005250</b> : <br><br><img src="https://habrastorage.org/webt/z1/8z/yj/z18zyj09grly6nwhuycpftjbrcu.png"><br><br>  Benennen Sie nach dem Nachdenken um: <br><br><ul><li>  unk_2000034C - <b>cmd_count</b> ; </li><li>  a1 - <b>cmd</b> ; </li><li>  v4 - <b>_cmd</b> ; </li><li>  v6 ist <b>rsp</b> ; </li><li>  sub_8005250 - <b>x_bluetooth_cmd</b> . </li></ul><br>  Mal sehen, wo x_bluetooth_cmd noch verwendet wird.  Alle zusätzlichen Links nur von der Bluetooth-Aufgabe, es ist Zeit, zu ihr zurückzukehren. <br><br><h2>  Zurück zur Bluetooth-Aufgabe </h2><br>  <i>Kurz: die endgültige Analyse der Bluetooth-Aufgabe.</i>  <i>Suchen Sie nach einer Autorisierung ohne Passwort.</i> <br><br><img src="https://habrastorage.org/webt/mb/2b/-e/mb2b-eatekfev7dil5vfk3_s-es.png"><br><br>  Wenn Sie sich die Stellen ansehen, an denen die Funktion <b>sub_8006A84 verwendet wird</b> , und Sie nicht zu faul sind und in den Darm schauen, besteht kein Zweifel - dies ist <b>calloc</b> .  Es ist logisch - um Daten in den Puffer zu empfangen, müssen Sie zuerst diesen Puffer erstellen. <br><br>  Jetzt <b>sub_8006DBC</b> .  Schauen wir es uns an (Variablen wurden bereits umbenannt): <br><br><img src="https://habrastorage.org/webt/kt/hw/31/kthw31aeqzwyae4jvnoqf5u6yl4.png"><br><br>  <b>Wenn</b> wir uns an die Funktionen der Standard-C-Bibliothek für die Arbeit mit Zeichenfolgen <b>erinnern</b> , sehen wir hier <b>strstr</b> (Suche nach einem Teilstring) und benennen ihn mutig um. <br><br>  Lassen Sie uns den Code der Funktion x_bluetooth_task durchgehen - <i>vielleicht hat sich hier seit dem letzten Besuch etwas geändert</i> .  Dabei benennen wir die Variablen: <br><br><ul><li>  v2 - <b>_state</b> ; </li><li>  v3 - <b>data_len</b> . </li></ul><br>  <b>Direkt</b> daneben befindet sich eine Funktion <b>sub_80052E2</b> .  In Analogie zu Funktionen, die Zahlen aus einem Bluetooth-Befehl abrufen, wird eine Zeichenfolge mit einer bestimmten Länge <b>abgerufen</b> - nennen wir sie <b>x_get_str</b> . <br><br>  Wir fahren fort: <br><br><ul><li>  v26 - <b>isEcho</b> ; </li><li>  v6 - <b>meow_str</b> ; </li><li>  v10 - <b>uart_cmd_byte</b> ; </li><li>  v11 - <b>uart_cmd_str</b> ; </li><li>  v12 - <b>str_0</b> ; </li><li>  v13 - <b>str_1</b> ; </li><li>  v14 - <b>format_str</b> ; </li><li>  sub_8000F5C - <b>x_blink_small_led</b> . </li></ul><br>  Beenden Sie mit einer schnellen Umbenennung: <br><br><ul><li>  v19 - <b>Passwort</b> ;  (da daneben Zeilen über Autorisierung und Passwort stehen) </li><li>  sub_8004CC0 - <b>x_check_password</b> ; </li><li>  sub_8006AF4 - <b>x_free</b> (da password, cmd und bt_args Zeiger auf dynamische Objekte sind (überprüfen Sie dies!), sollte der Speicher nach deren Verwendung freigegeben werden); </li><li>  sub_8006DAC - <b>x_strcpy</b> (check it out!). </li></ul><br>  Erkunden Sie nun die Zweige <b>READ</b> , <b>WRIT</b> , <b>AUTP</b> , <b>SETP</b> . <br><br>  Wie ein Test auf einem laufenden Gerät gezeigt hat, ist eine Autorisierung für die Befehle READ, WRIT, SETP erforderlich.  Ein Autorisierungsversuch mit dem Befehl AUTP bringt uns zur Funktion <b>x_check_password</b> , um das Kennwort zu überprüfen: <br><br><img src="https://habrastorage.org/webt/vt/pw/6b/vtpw6b3h64bivcvzdlalldoo45k.png"><br><br>  Es stellt sich heraus, dass die Kennwortlänge 8 Zeichen betragen muss und das Kennwort (in der Funktion sub_8006B08) mit Bytes an der Adresse <b>0x08007C00 verglichen wird</b> - wo die generierte Folge von Zufallszeichen AZ gespeichert wird. <br><br>  Es stellt sich heraus, dass wir uns ohne Kenntnis des Passworts nicht am Gerät anmelden können.  Naja oder fast nicht ... <br><br>  <b>Achten Sie</b> darauf, wo die Variable <b>auth_flag verwendet wird</b> : <br><br><img src="https://habrastorage.org/webt/8h/ng/l0/8hngl0dqritcx8yzk1jbvkqpq34.png"><br><br>  Es stellt sich heraus, dass es nicht nur in Bluetooth-Aufgaben verwendet wird.  Und hier haben wir einfach noch nicht in Sensor Aufgabe geschaut.  Wir gehen dorthin. <br><br><h2>  Sensoraufgabe </h2><br>  <i>Kurz gesagt: Was macht die Touch-Taste?</i> <br><br>  Gemäß den besten Programmierpraktiken passt die gesamte Sensoraufgabe in einen IDA-Bildschirm.  Und das kann sich nur freuen: <br><br><img src="https://habrastorage.org/webt/mq/13/3v/mq133vs_uxqmyldfhmicajpxiak.png"><br><br>  Zeile zu Zeile ... <br><br><ul><li>  "TSC% d \ r \ n" - Diese Zeile sollte Sie über den Touch Sensing Controller für STM32-Mikrocontroller nachdenken lassen. </li><li>  "AUTH BTN \ r \ n" - Autorisierungsknopf ??? </li><li>  "SET AUTH% d \ r \ n" - Berechtigungsflag setzen? </li></ul><br>  Mal sehen, wie sich das Gerät verhält, wenn Sie die Touch-Taste drücken (haben Sie festgestellt, dass das Nashorn am Bein eine Touch-Taste hat?): <br><br><img src="https://habrastorage.org/webt/0p/ig/bp/0pigbpj4pj5gdrn1onololc_zfk.gif"><br><br>  Bei kurzem Drücken leuchtet die rote kleine LED auf.  Bei langem Drücken leuchtet diese LED lange auf. <br><br>  Wenn wir dies mit dem Code korrelieren, können wir annehmen, dass die Funktion <b>sub_8000708</b> eine Funktion zum <b>Abrufen</b> der aktuellen Zeit ist.  Wenn die Differenz zwischen der aktuellen Zeit und dem Beginn des Berührens des Sensors mehr als 1000 (1 Sekunde) <b>beträgt, leuchtet</b> die LED für <b>0xEA60</b> Millisekunden (1 Minute).  Von großem Interesse ist jedoch die Variable auth_flag, die durch langes Drücken der Touch-Taste auf 1 gesetzt wird und dem <s>Angreifer den</s> Zugriff auf den Administrator des "Beleuchtungskörpers" auf privilegierte Funktionen ermöglicht. <br><br>  So können Sie nach der Autorisierung „per Taste“ das im Gerät gespeicherte Passwort lesen (Befehl READ), in den RAM schreiben (WRIT-Funktion) oder ein neues Passwort festlegen (SETP). <br><br><h2>  Mad blinkt </h2><br>  <i>Kurz gesagt: Kann ein seltsamer Mad Blinking-Code-Zweig ausgeführt werden?</i> <br><br>  Kehren wir zur Bluetooth-Aufgabe zurück und führen eine weitere Umbenennung durch. <br><br><ul><li>  v21 - <b>vip_smth</b> (es ist noch nicht klar, was da ist); </li><li>  v22 - <b>vip_str</b> (Zeichenfolge unbekannter Größe, extrahiert aus den Argumenten); </li><li>  v23 - mad_led - <b>weise</b> "In Struktur konvertieren *" zu und <i>gebe struct_LED an</i> . </li></ul><br>  Und hier sehen wir die Nummer <b>0xB816D8D9</b> (sie wurde im ersten Teil des Artikels in der Bluetooth-Aufgabe gefunden) als Index der LED.  Dieser Code wird ausgeführt, wenn eine Überprüfung durchgeführt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sub_8005520(vip_str, vip_smth) == <span class="hljs-number"><span class="hljs-number">0x46F70674</span></span> )</code> </pre> <br>  Benennen <b>Sie</b> sub_8005520 in <b>x_vip_check um</b> und sehen Sie es sich an: <br><br><img src="https://habrastorage.org/webt/dl/h9/tx/dlh9txqyu5n1t4orgprpptbk8oc.png"><br><br>  Da das erste Argument eine Zeichenfolge ist (zumindest die Zeichenfolge wird an diese Funktion übergeben), zeigt dieser Code, dass das zweite Argument die Länge dieser Zeichenfolge (oder die Länge, die verarbeitet werden muss) ist.  Umbenennen: <br><br><ul><li>  a1 - <b>str</b> ; </li><li>  a2 - <b>len</b> . </li></ul><br>  Schauen wir uns die Funktion <b>sub_8000254 an</b> : <br><br><img src="https://habrastorage.org/webt/y-/ql/js/y-qljsey4clq4lowsdbrblnkyf8.png"><br><br>  Schauen Sie sich nun <b>sub_8000148 an</b> .  Hier ist der Anfang: <br><br><img src="https://habrastorage.org/webt/l7/xz/cr/l7xzcrdgjq0n5a82enkalsukqse.png"><br><br>  Dies ist nur ein Drittel der Funktion ... Mmmm ... Lecker!  Ein erfahrener Bagger wird hier leicht sehen ... <br><br><div class="spoiler">  <b class="spoiler_title">Was?</b> <div class="spoiler_text">  Ganzzahldivisionsoperation. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Wie kann es ausgegraben werden?</b> <div class="spoiler_text">  Wenn Sie sich anstrengen, können Sie über die Funktion <b>sub_8000254</b> (über mehrere andere Funktionen) zu <b>x_printf</b> gelangen.  Ein wichtiger Punkt an dieser Stelle ist, dass normalerweise alle <i>Standardfunktionen ziemlich Standard sind</i> .  Dies bedeutet, dass Sie versuchen können, mindestens einen Quellcode der untersuchten Funktion öffentlich zu finden, damit die Studie produktiver ist. <br><br>  Also nehmen wir die Quelle von printf, dann schauen wir uns <b>vfprintf an</b> und vergleichen es mit dem Code der untersuchten Firmware.  <b>Unter Verwendung des</b> Quellcodes verlassen wir die <b>itoa-</b> Funktion und schließen daraus, dass die <b>sub_8000254-</b> Funktion der Operatoroperator <b>% ist</b> (der Rest der Division nimmt), und diese schrecklich lange Funktion ist nichts anderes als der ganzzahlige Teil der Division (div-Operation). <br></div></div><br>  Es kann sich eine berechtigte Frage stellen - warum?  Tatsache ist, dass es in einem bestimmten Mikrocontroller keine DIV-, MOD-Operationen geben kann. Daher ersetzt der Compiler den Aufruf einzelner Funktionen anstelle dieser Operatoren.  Übrigens, hier sind einige andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mathematische Funktionen</a> . <br><br>  Vergessen Sie nicht, beim Graben umzubenennen. <br><br>  So berechnet die Funktion <b>x_vip_check</b> ... Und das sind Ihre <b><i>Hausaufgaben</i></b> . <br><br>  Übrigens, wenn Sie den richtigen <b>VIP-</b> Befehl ausführen, erhalten wir ein "Nashorn in der Disco": <br><br><img src="https://habrastorage.org/webt/ah/ty/sc/ahtyscents-3j77aqcxfa0_hrtq.gif"><br><br><h2>  Kurzbericht zur Firmware </h2><br>  Die Firmware des Geräts basiert auf dem Echtzeit-Betriebssystem FreeRTOS.  Das System hat folgende Aufgaben: <br><br><ol><li>  <b>Bluetooth-Aufgabe</b> .  Verarbeitet Befehle, die in Textform über Bluetooth eingehen. </li><li>  <b>LED Aufgabe</b> .  Steuert Farb-LEDs gemäß Bluetooth-Befehlen. </li><li>  <b>Sensoraufgabe</b> .  Schaltet die rote LED ein und ermöglicht eine kurzfristige Autorisierung ohne Kennwort auf dem Gerät. </li><li>  <b>UART-Aufgabe</b> .  Ermöglicht die Interaktion mit dem Bluetooth-Modul über den internen UART-Port (zur Initialisierung von Bluetooth). </li><li>  <b>Watchdog-Aufgabe</b> .  Verfolgt das Einfrieren. </li></ol><br>  Die Studie berücksichtigte nicht die Fähigkeit, Daten vom UART-Port (Tx / GND-Kontakte) zu lesen. <br><br><h2>  Zusammenfassung </h2><br>  Während der Meisterklasse auf der Konferenz wurde nur die Hauptfunktion der LED-Steuerung zerlegt.  Den aktivsten Teilnehmern wurden ihre experimentellen „Nashörner“ vorgestellt. <br><br>  Meiner Meinung nach hat das „Nashorn“ ein anständiges Layout für einen Schulungskurs über Reverse Engineering und Schwachstellensuche erstellt.  Ein Merkmal des Layouts kann die Möglichkeit sein, die Firmware so oft zu ändern, wie Sie möchten. Jeder Kurs hat seine eigene Firmware.  Im Gegensatz zum Parsen einer ausführbaren Datei können Sie mit der Reverse-Firmware Folgendes besser verstehen: <br><br><ul><li>  wie man mit IDA arbeitet; </li><li>  Prinzipien der Interaktion zwischen Firmware und Gerät; </li><li>  RTOS-Funktionsprinzipien. </li></ul><br>  Vielen Dank an alle, die bis zum Ende gelesen haben! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412561/">https://habr.com/ru/post/de412561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412551/index.html">Kopieren Sie Text aus der Zwischenablage über ADB auf Android-Geräte</a></li>
<li><a href="../de412553/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT für Juni 2018</a></li>
<li><a href="../de412555/index.html">Magnetgetriebe für bürstenlosen Motor</a></li>
<li><a href="../de412557/index.html">So erstellen Sie Ihren eigenen Bot ohne Programmierkenntnisse und verbinden ihn mit Yandex.Alice</a></li>
<li><a href="../de412559/index.html">Intelligenter Vertrag als Sicherheitsbedrohung für den Blockchain-Start</a></li>
<li><a href="../de412565/index.html">Comics über Sysadmins: Alles Leben blitzte vor meinen Augen auf</a></li>
<li><a href="../de412571/index.html">Kubernetes Erfolgsgeschichten in der Produktion. Teil 9: CERN- und 210 K8-Cluster</a></li>
<li><a href="../de412573/index.html">Was mit Geektimes los ist, kehre nach Habr zurück</a></li>
<li><a href="../de412575/index.html">Popmusik wird von Jahr zu Jahr eintöniger, weil die gleichen Leute sie komponieren</a></li>
<li><a href="../de412579/index.html">Marvel: Infinity War oder Wie Sie in wenigen Minuten Daten für Ihr Projekt sammeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>