<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ… ğŸ‘¥ â˜¦ï¸ Arduino dan penghitung waktu menyela ğŸ¾ ğŸ‘©ğŸ½ ğŸ‘¨â€ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel "Timer interrupt" oleh E. 
 Kata Pengantar 


 Papan Arduino memungkinkan Anda untuk dengan cepat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduino dan penghitung waktu menyela</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453276/"><p>  Halo, Habr!  Saya hadir untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Timer interrupt"</a> oleh E. </p><br><h3 id="predislovie">  Kata Pengantar </h3><br><p>  Papan Arduino memungkinkan Anda untuk dengan cepat dan minimal menyelesaikan berbagai masalah.  Tetapi di mana interval waktu sewenang-wenang diperlukan (polling sensor secara berkala, sinyal PWM presisi tinggi, pulsa berdurasi panjang) fungsi penundaan perpustakaan standar tidak nyaman.  Selama durasi aksi mereka, sketsa ditangguhkan dan menjadi tidak mungkin untuk mengelolanya. </p><br><p>  Dalam situasi serupa, lebih baik menggunakan penghitung waktu AVR bawaan.  Bagaimana melakukan ini dan tidak tersesat di belantara teknis lembar data, kata sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang sukses</a> , terjemahan yang dibawa ke perhatian Anda. </p><br><p><img src="https://habrastorage.org/webt/3g/n_/iw/3gn_iwqe-tubwgqslsclzuaznki.png"></p><a name="habracut"></a><br><p>  Artikel ini membahas timer AVR dan Arduino dan cara menggunakannya dalam proyek Arduino dan sirkuit pengguna. </p><br><h3 id="chto-takoe-taymer">  Apa itu timer? </h3><br><p> Seperti dalam kehidupan sehari-hari dalam mikrokontroler, timer adalah beberapa hal yang dapat memberi sinyal di masa depan, pada saat yang Anda atur.  Ketika momen ini datang, mikrokontroler terputus, mengingatkannya untuk melakukan sesuatu, misalnya, untuk mengeksekusi sepotong kode tertentu. </p><br><p>  Pengatur waktu, seperti interupsi eksternal, bekerja secara independen dari program utama.  Alih-alih mengulang atau mengulangi panggilan tunda <em>milis ()</em> , Anda dapat menetapkan timer untuk melakukan tugasnya sementara kode Anda melakukan hal-hal lain. </p><br><p>  Jadi, misalkan ada perangkat yang perlu melakukan sesuatu, misalnya, berkedip LED setiap 5 detik.  Jika Anda tidak menggunakan penghitung waktu, tetapi menulis kode normal, Anda perlu mengatur variabel pada saat LED dinyalakan dan terus-menerus memeriksa apakah saat peralihannya telah tiba.  Dengan interupsi timer, Anda hanya perlu mengkonfigurasi interupsi, dan kemudian memulai timer.  LED akan berkedip tepat waktu, terlepas dari tindakan program utama. </p><br><h3 id="kak-rabotaet-taymer">  Bagaimana cara kerja timer? </h3><br><p>  Kerjanya dengan menambah variabel yang disebut <em>register hitung</em> .  Register penghitungan dapat menghitung ke nilai tertentu, tergantung pada ukurannya.  Timer menambah penghitungnya berulang-ulang sampai mencapai nilai maksimumnya, pada titik ini penghitung akan meluap dan mengatur ulang ke nol.  Timer biasanya menetapkan bit bendera untuk memberi tahu Anda bahwa terjadi overflow. </p><br><p>  Anda dapat memeriksa flag ini secara manual atau Anda dapat membuat pengatur waktu - menyebabkan interupsi secara otomatis ketika flag diatur.  Seperti interupsi lainnya, Anda dapat menetapkan <em>Interrupt Service Routine</em> ( <em>ISR</em> ) untuk mengeksekusi kode yang ditentukan ketika timer meluap.  ISR sendiri akan menghapus flag overflow, jadi menggunakan interupsi biasanya merupakan pilihan terbaik karena kesederhanaan dan kecepatannya. </p><br><p>  Untuk meningkatkan nilai penghitung pada interval waktu yang tepat, timer harus terhubung ke sumber jam.  Sumber jam menghasilkan sinyal yang terus berulang.  Setiap kali timer mendeteksi sinyal ini, timer akan menambah nilai penghitungnya.  Karena timer beroperasi pada sumber jam, satuan waktu terkecil yang dapat diukur adalah periode siklus.  Jika Anda menghubungkan sinyal clock 1 MHz, maka resolusi timer (atau periode timer) adalah: </p><br><p>  T = 1 / f (f adalah frekuensi clock) <br>  T = 1/1 MHz = 1/10 ^ 6 Hz <br>  T = (1 âˆ— 10 ^ -6) s </p><br><p>  Dengan demikian, resolusi timer adalah sepersejuta detik.  Meskipun Anda dapat menggunakan sumber clock eksternal untuk timer, dalam kebanyakan kasus sumber internal chip itu sendiri digunakan. </p><br><h3 id="tipy-taymerov">  Jenis Timer </h3><br><p>  Di papan Arduino standar pada chip AVR 8-bit, ada beberapa timer sekaligus.  Chip Atmega168 dan Atmega328 memiliki tiga timer Timer0, Timer1, dan Timer2.  Mereka juga memiliki pengawas waktu yang dapat digunakan untuk melindungi dari kegagalan atau sebagai mekanisme reset perangkat lunak.  Berikut adalah beberapa fitur dari setiap timer. </p><br><p>  Timer0: <br>  Timer0 adalah timer 8-bit, yang berarti register penghitungnya dapat menyimpan angka hingga 255 (mis., Byte yang tidak ditandatangani).  Timer0 digunakan oleh fungsi sementara Arduino standar seperti <em>delay ()</em> dan <em>millis ()</em> , jadi sebaiknya jangan bingung jika Anda peduli dengan konsekuensinya. </p><br><p>  Timer1: <br>  Timer1 adalah timer 16-bit dengan nilai hitungan maksimum 65535 (integer unsigned).  Penghitung waktu ini menggunakan pustaka Arduino Servo, ingatlah ini jika Anda menggunakannya di proyek Anda. </p><br><p>  Timer2: <br>  Timer2 adalah 8 bit dan sangat mirip dengan Timer0.  Ini digunakan dalam fungsi <em>nada</em> Arduino <em>()</em> . </p><br><p>  Timer3, Timer4, Timer5: <br>  Chip ATmega1280 dan ATmega2560 (diinstal dalam varian Arduino Mega) memiliki tiga timer tambahan.  Semuanya 16 bit dan bekerja mirip dengan Timer1. </p><br><h3 id="konfiguraciya-registrov">  Daftarkan Konfigurasi </h3><br><p>  Untuk menggunakan penghitung waktu ini, AVR memiliki register pengaturan.  Pengatur waktu berisi banyak register semacam itu.  Dua di antaranya - register kontrol penghitung waktu / penghitung berisi variabel pengaturan dan disebut TCCRxA dan TCCRxB, di mana x adalah jumlah penghitung waktu (TCCR1A dan TCCR1B, dll.).  Setiap register berisi 8 bit dan setiap bit menyimpan variabel konfigurasi.  Berikut ini rincian dari lembar data Atmega328: </p><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1A </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Sedikit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 </td></tr><tr><td>  0x80 </td><td>  COM1A1 </td><td>  COM1A0 </td><td>  COM1B1 </td><td>  COM1B0 </td><td>  - </td><td>  - </td><td>  Wgm11 </td><td>  Wgm10 </td></tr><tr><td>  Baca ulang </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  R </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Nilai awal </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1B </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Sedikit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 </td></tr><tr><td>  0x81 </td><td>  ICNC1 </td><td>  ICES1 </td><td>  - </td><td>  Wmm13 </td><td>  Wgm12 </td><td>  CS12 </td><td>  CS11 </td><td>  CS10 </td></tr><tr><td>  Baca ulang </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Nilai awal </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><p>  Yang paling penting adalah tiga bit terakhir di TCCR1B: CS12, CS11 dan CS10.  Mereka menentukan frekuensi jam dari timer.  Memilih mereka dalam kombinasi yang berbeda, Anda dapat memesan timer untuk bertindak pada kecepatan yang berbeda.  Berikut adalah tabel lembar data yang menjelaskan efek dari bit terpilih: </p><br><div class="scrollable-table"><table><thead><tr><th>  CS12 </th><th>  CS11 </th><th>  CS10 </th><th>  Aksi </th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  0 </td><td>  Tidak ada sumber jam (Timer / Penghitung berhenti) </td></tr><tr><td>  0 </td><td>  0 </td><td>  1 </td><td>  clk_io / 1 (tanpa divisi) </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td><td>  clk_io / 8 (pembagi frekuensi) </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td><td>  clk_io / 64 (pembagi frekuensi) </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td><td>  clk_io / 256 (pembagi frekuensi) </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td><td>  clk_io / 1024 (pembagi frekuensi) </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td><td>  Sumber clock eksternal pada pin T1.  Clocking Resesi </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  Sumber clock eksternal pada pin T1.  Clocking depan </td></tr></tbody></table></div><br><p>  Secara default, semua bit ini diatur ke nol. </p><br><p>  Misalkan Anda ingin Timer1 dijalankan pada frekuensi jam dengan satu sampel per periode.  Saat meluap, Anda ingin memanggil rutin interupsi, yang mengalihkan LED yang terhubung ke leg 13 ke status hidup atau mati.  Untuk contoh ini, kita akan menulis kode Arduino, tetapi kita akan menggunakan prosedur dan fungsi pustaka avr-libc setiap kali ini tidak membuat hal-hal terlalu rumit.  Pendukung AVR murni dapat mengadaptasi kode sesuai keinginan mereka. </p><br><p>  Pertama, inisialisasi timer: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //  TCCR1A   0 TCCR1B = 0; //   Timer1 overflow: TIMSK1 = (1 &lt;&lt; TOIE1); //  CS10  ,      : TCCR1B |= (1 &lt;&lt; CS10); sei(); //    }</span></span></code> </pre> <br><p>  Register TIMSK1 adalah register masker interupsi timer / counter1.  Ini mengontrol interupsi yang dapat disebabkan oleh timer.  Mengatur bit TOIE1 memberitahu timer untuk menyela ketika timer meluap.  Lebih lanjut tentang ini nanti. </p><br><p>  Ketika Anda mengatur bit CS10, timer mulai menghitung dan, segera setelah terjadi overflow interupsi, ISR (TIMER1_OVF_vect) dipanggil.  Ini selalu terjadi ketika timer meluap. </p><br><p>  Selanjutnya kita mendefinisikan fungsi interupsi ISR: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_OVF_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Sekarang kita dapat mendefinisikan siklus () siklus dan mengganti LED terlepas dari apa yang terjadi di program utama.  Untuk mematikan timer, atur TCCR1B = 0 kapan saja. </p><br><h3 id="kak-chasto-budet-migat-svetodiod">  Seberapa sering LED berkedip? </h3><br><p>  Timer1 diatur ke overflow interrupt dan mari kita asumsikan bahwa Anda menggunakan Atmega328 dengan frekuensi clock 16 MHz.  Karena timer adalah 16-bit, itu dapat dihitung dengan nilai maksimum (2 ^ 16 - 1), atau 65535. Pada 16 MHz, siklus berjalan 1 / (16 âˆ— 10 ^ 6) detik atau 6,25e-8 s.  Ini berarti bahwa 65535 sampel akan muncul dalam (65535 âˆ— 6.25e-8 detik) dan ISR akan dipanggil setelah sekitar 0,0041 detik.  Maka dari waktu ke waktu, setiap empat ribu detik.  Terlalu cepat untuk melihat kedipan. </p><br><p>  Jika kita menerapkan sinyal PWM yang sangat cepat dengan cakupan 50% ke LED, maka cahaya akan tampak terus menerus, tetapi kurang terang dari biasanya.  Eksperimen semacam itu menunjukkan kekuatan mikrokontroler yang luar biasa - bahkan chip 8-bit yang murah dapat memproses informasi lebih cepat daripada yang dapat kita deteksi. </p><br><h3 id="delitel-taymera-i-rezhim-ctc">  Pembatas waktu dan mode CTC </h3><br><p>  Untuk mengontrol periode, Anda dapat menggunakan pembagi yang memungkinkan Anda untuk membagi sinyal jam menjadi dua tingkat yang berbeda dan menambah periode timer.  Misalnya, Anda ingin LED berkedip pada interval satu detik.  Ada tiga bit CS dalam register TCCR1B yang mengatur resolusi yang paling tepat.  Jika Anda mengatur bit CS10 dan CS12 menggunakan: </p><br><pre> <code class="cpp hljs">TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS10); TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS12);</code> </pre> <br><p>  maka frekuensi sumber jam akan dibagi dengan 1024. Ini memberikan resolusi timer 1 / (16 âˆ— 10 ^ 6/1024) atau 6.4e-5 s.  Sekarang timer akan meluap setiap (65535 âˆ— 6.4e-5s) atau untuk 4.194s.  Itu terlalu panjang. </p><br><p>  Tetapi ada mode timer AVR lain.  Ini disebut reset timer coincident atau CTC.  Alih-alih menghitung untuk meluap, timer membandingkan penghitungnya dengan variabel yang sebelumnya disimpan dalam register.  Ketika hitungan cocok dengan variabel ini, penghitung waktu dapat menetapkan bendera atau menyebabkan interupsi, seperti dalam kasus overflow. </p><br><p>  Untuk menggunakan mode CTC, Anda perlu memahami berapa banyak siklus yang Anda butuhkan untuk mendapatkan interval satu detik.  Misalkan rasio divisi masih 1024. </p><br><p>  Perhitungannya adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">(target time) = (timer resolution) * (# timer counts + 1) (# timer counts + 1) = (target time) / (timer resolution) (# timer counts + 1) = (1 s) / (6.4e-5 s) (# timer counts + 1) = 15625 (# timer counts) = 15625 - 1 = 15624</code> </pre> <br><p>  Anda harus menambahkan unit tambahan ke jumlah sampel karena dalam mode CTC, ketika penghitung cocok dengan nilai yang ditetapkan, itu akan mengatur ulang sendiri ke nol.  Reset membutuhkan satu periode jam, yang harus diperhitungkan dalam perhitungan.  Dalam banyak kasus, kesalahan dalam satu periode tidak terlalu signifikan, tetapi dalam tugas-tugas presisi tinggi itu bisa menjadi kritis. </p><br><p>  Fungsi setup () akan seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(LEDPIN, OUTPUT); <span class="hljs-comment"><span class="hljs-comment">//  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //   CTC  //   CS10  CS12    1024 TCCR1B |= (1 &lt;&lt; CS10); TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //     sei(); //    }</span></span></code> </pre> <br><p>  Anda juga perlu mengganti interupsi melimpah dengan interupsi kebetulan: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Sekarang LED akan hidup dan mati selama tepat satu detik.  Dan Anda bisa melakukan apa saja di loop () loop.  Sampai Anda mengubah pengaturan timer, program tidak ada hubungannya dengan interupsi.  Anda tidak memiliki batasan dalam menggunakan timer dengan berbagai mode dan pengaturan pembagi. </p><br><p>  Berikut ini adalah contoh awal lengkap yang dapat Anda gunakan sebagai dasar untuk proyek Anda sendiri: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Arduino  CTC  // avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //  CTC  TCCR1B |= (1 &lt;&lt; CS10); //      1024 TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //      sei(); //    } void loop() { //   } ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</span></span></code> </pre> <br><p>  Ingatlah bahwa Anda dapat menggunakan fungsi ISR â€‹â€‹bawaan untuk memperluas fungsi timer.  Misalnya, Anda perlu menyurvei sensor setiap 10 detik.  Tetapi tidak ada pengaturan pengatur waktu yang menyediakan penghitungan lama tanpa meluap.  Namun, Anda dapat menggunakan ISR untuk menambah variabel penghitungan satu kali per detik dan kemudian menyurvei sensor ketika variabel mencapai 10. Menggunakan mode STS dari contoh sebelumnya, interruptnya bisa seperti ini: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { seconds++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(seconds == <span class="hljs-number"><span class="hljs-number">10</span></span>) { seconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; readSensor(); } }</code> </pre> <br><p>  Karena variabel akan dimodifikasi di dalam ISR, itu harus dinyatakan sebagai <em>volatile</em> .  Karenanya, saat menjelaskan variabel di awal program, Anda perlu menulis: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> byte seconds;</code> </pre> <br><h3 id="posleslovie-perevodchika">  Kata penutup penerjemah </h3><br><p>  Pada suatu waktu, artikel ini menyelamatkan saya banyak waktu ketika mengembangkan generator pengukur prototipe.  Saya berharap ini akan bermanfaat bagi pembaca lain. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453276/">https://habr.com/ru/post/id453276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453260/index.html">Fitur Pengaturan DPI</a></li>
<li><a href="../id453262/index.html">Di mana konstanta Anda disimpan pada mikrokontroler CortexM (menggunakan kompiler C ++ IAR sebagai contoh)</a></li>
<li><a href="../id453264/index.html">Virtuali-tee: "T-shirt medis" yang tidak menutupi tetapi mengekspos</a></li>
<li><a href="../id453272/index.html">Sponsor GitHub: cara baru untuk berkontribusi ke open source</a></li>
<li><a href="../id453274/index.html">Komisi tersembunyi Yandex.Money di Samsung Pay</a></li>
<li><a href="../id453278/index.html">Mengapa para insinyur tidak peduli dengan pemantauan aplikasi?</a></li>
<li><a href="../id453280/index.html">Utang teknis</a></li>
<li><a href="../id453286/index.html">Kesalahan paling mahal dalam hidup saya: detail tentang serangan pada port kartu SIM</a></li>
<li><a href="../id453290/index.html">Intisari Ilmu Data (Mei 2019)</a></li>
<li><a href="../id453292/index.html">"Sebuah buku kecil tentang lubang hitam"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>