<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏿 🥥 🐥 Histoire de l'évolution des interfaces en Java ⛈️ ⚔️ 🧛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'interface en Java a beaucoup évolué au fil des ans. Voyons quels changements se sont produits au cours de son développement. 

 Interfaces originale...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Histoire de l'évolution des interfaces en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482498/"><img src="https://habrastorage.org/webt/db/rm/ac/dbrmacgcmj4awxvvosnyra8kmmo.png" alt="image"><br><br>  L'interface en Java a beaucoup évolué au fil des ans.  Voyons quels changements se sont produits au cours de son développement. <br><a name="habracut"></a><br><h2>  Interfaces originales </h2><br>  Les interfaces de Java 1.0 étaient assez simples par rapport à ce qu'elles sont maintenant.  Ils ne peuvent contenir que deux types d'éléments: les constantes et les méthodes abstraites publiques. <br><br><h3>  Champs constants </h3><br>  Les interfaces peuvent contenir des champs, tout comme les classes ordinaires, mais avec quelques différences: <br><br><ul><li>  Les champs doivent être initialisés. </li><li>  Les champs sont considérés comme une finale publique statique </li><li>  Les modificateurs public, static et final n'ont pas besoin d'être spécifiés explicitement (ils sont déposés par défaut) </li></ul><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MY_CONSTANT = <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre> <br>  Même si cela n'est pas spécifié explicitement, le champ MY_CONSTANT est considéré comme une constante finale statique publique.  Vous pouvez ajouter ces modificateurs, mais ce n'est pas nécessaire. <br><br><h2>  Méthodes abstraites </h2><br>  Les éléments les plus importants d'une interface sont ses méthodes.  Les méthodes d'interface diffèrent également des méthodes de classe normales: <br><br><ul><li>  Les méthodes n'ont pas de corps </li><li>  L'implémentation de la méthode est fournie par les classes qui implémentent cette interface. </li><li>  Les méthodes sont considérées comme publiques et abstraites même si elles ne sont pas explicitement spécifiées. </li><li>  Les méthodes ne peuvent pas être finales, car la combinaison de modificateurs abstraits et finaux n'est pas autorisée en Java </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingCompletelyDifferent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><h2>  Imbrication </h2><br>  Java 1.1 a introduit le concept de classes qui peuvent être placées dans d'autres classes.  Ces classes sont de deux types: statiques et non statiques.  Les interfaces peuvent également contenir d'autres interfaces et classes. <br><br>  Même si cela n'est pas spécifié explicitement, ces interfaces et classes sont considérées comme publiques et statiques. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } interface MyOtherInterface { //... } }</span></span></code> </pre><br><h3>  Énumérations et annotations </h3><br>  Deux autres types ont été introduits dans Java 5: les énumérations et les annotations.  Ils peuvent également être placés à l'intérieur des interfaces. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> MyEnum { FOO, BAR; } <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> MyAnnotation { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Types génériques </h2><br>  Java 5 a introduit le concept des génériques, des types génériques.  En bref: les génériques vous permettent d'utiliser un type générique au lieu de spécifier un type spécifique.  Ainsi, vous pouvez écrire du code qui fonctionne avec un nombre différent de types sans sacrifier la sécurité et sans fournir une implémentation distincte pour chaque type. <br><br>  Dans les interfaces commençant par Java 5, vous pouvez définir un type générique, puis l'utiliser comme type de valeur de retour d'une méthode ou comme type d'argument d'une méthode. <br><br>  L'interface Box fonctionne que vous l'utilisiez pour stocker des objets tels que String, Integer, List, Shoe ou tout autre. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T item)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoeBox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shoe</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shoe item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Méthodes statiques </h2><br>  À partir de Java 8, vous pouvez inclure des méthodes statiques dans les interfaces.  Cette approche a changé le fonctionnement de l'interface pour nous.  Ils fonctionnent maintenant très différemment de la façon dont ils fonctionnaient avant Java 8. Initialement, toutes les méthodes des interfaces étaient abstraites.  Cela signifiait que l'interface ne fournissait qu'une signature, mais pas une implémentation.  L'implémentation a été laissée aux classes implémentant votre interface. <br><br>  Lorsque vous utilisez des méthodes statiques dans les interfaces, vous devez également fournir une implémentation du corps de la méthode.  Pour utiliser cette méthode dans une interface, utilisez simplement le mot-clé statique.  Les méthodes statiques sont considérées comme publiques par défaut. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This works static int foo() { return 0; } // This does not work, // static methods in interfaces need body static int bar(); }</span></span></code> </pre><br><h3>  Héritage de méthode statique </h3><br>  Contrairement aux méthodes statiques classiques, les méthodes statiques dans les interfaces ne sont pas héritées.  Cela signifie que si vous souhaitez appeler une telle méthode, vous devez l'appeler directement à partir de l'interface, et non à partir de la classe qui l'implémente. <br><br><pre> <code class="java hljs">MyInterface.staticMethod();</code> </pre><br>  Ce comportement est très utile pour éviter plusieurs problèmes d'héritage.  Imaginez que vous ayez une classe qui implémente deux interfaces.  Chacune des interfaces a une méthode statique avec le même nom et la même signature.  Lequel doit être utilisé en premier? <br><br><h3>  Pourquoi est-ce utile </h3><br>  Imaginez que vous ayez une interface et un ensemble complet de méthodes d'assistance qui fonctionnent avec les classes qui implémentent cette interface. <br><br>  Traditionnellement, il y a eu une approche pour utiliser une classe d'accompagnement.  En plus de l'interface, une classe utilitaire a été créée avec un nom très similaire contenant des méthodes statiques appartenant à l'interface. <br><br>  Vous pouvez trouver des exemples d'utilisation de cette approche directement dans le JDK: l'interface java.util.Collection et la classe utilitaire java.util.Collections qui l'accompagnent. <br><br>  Avec des méthodes statiques dans les interfaces, cette approche n'est plus pertinente, n'est pas nécessaire et n'est pas recommandée.  Maintenant, vous pouvez tout avoir en un seul endroit. <br><br><h2>  Méthodes par défaut </h2><br>  Les méthodes par défaut sont similaires aux méthodes statiques dans la mesure où vous devez également leur fournir un corps.  Pour déclarer une méthode par défaut, utilisez simplement le mot clé par défaut. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Contrairement aux méthodes statiques, les méthodes sont héritées par défaut des classes qui implémentent l'interface.  Ce qui est important, ces classes peuvent redéfinir leur comportement si nécessaire. <br><br>  Bien qu'il y ait une exception.  L'interface ne peut pas avoir de méthodes par défaut avec la même signature que les méthodes toString, equals et hashCode de la classe Object.  Jetez un œil à la réponse de Brian Goetz pour comprendre la validité d'une telle solution: <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html">Autorisez les méthodes par défaut à remplacer les méthodes d'Object.</a> <br><br><h3>  Pourquoi est-ce utile </h3><br>  L'idée d'implémenter des méthodes directement dans l'interface ne semble pas tout à fait correcte.  Alors pourquoi cette fonctionnalité a-t-elle été introduite pour la première fois? <br><br>  Les interfaces ont un problème.  Dès que vous donnez votre API à d'autres personnes, elle «pétrifiera» pour toujours (elle ne peut pas être modifiée sans douleur). <br><br>  Par tradition, Java prend la compatibilité descendante très au sérieux.  Les méthodes par défaut permettent d'étendre les interfaces existantes avec de nouvelles méthodes.  Plus important encore, les méthodes par défaut fournissent déjà une implémentation spécifique.  Cela signifie que les classes implémentant votre interface n'ont pas besoin d'implémenter de nouvelles méthodes.  Mais, si nécessaire, les méthodes par défaut peuvent être remplacées à tout moment si leur implémentation cesse de convenir.  Donc, en bref, vous pouvez fournir de nouvelles fonctionnalités aux classes existantes qui implémentent votre interface, tout en conservant la compatibilité. <br><br><h3>  Conflits </h3><br>  Imaginons que nous ayons une classe qui implémente deux interfaces.  Ces interfaces ont une méthode par défaut avec le même nom et la même signature. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Désormais, la même méthode par défaut avec la même signature est héritée de deux interfaces différentes.  Chaque interface a sa propre implémentation de cette méthode. <br><br>  Alors, comment notre classe sait-elle laquelle des deux implémentations différentes utiliser? <br><br>  Il ne le saura pas.  Le code ci-dessus entraînera une erreur de compilation.  Si vous devez le faire fonctionner, vous devez remplacer la méthode conflictuelle dans votre classe. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Without this the compilation fails @Override public int doSomething() { return 256; } }</span></span></code> </pre><br><h2>  Méthodes privées </h2><br>  Avec l'avènement de Java 8 et l'introduction des méthodes par défaut et des méthodes statiques, les interfaces ont désormais la capacité de contenir non seulement les signatures de méthode, mais aussi leur implémentation.  Lors de l'écriture de telles implémentations, il est recommandé de diviser les méthodes complexes en méthodes plus simples.  Ce code est plus facile à réutiliser, à maintenir et à comprendre. <br><br>  À cette fin, vous utiliseriez des méthodes privées, car elles peuvent contenir tous les détails d'implémentation qui ne devraient pas être visibles et utilisés de l'extérieur. <br><br>  Malheureusement en Java 8, une interface ne peut pas contenir de méthodes privées.  Cela signifie que vous pouvez utiliser: <br><br><ol><li>  Techniques corporelles longues, complexes et difficiles à comprendre. </li><li>  Méthodes d'assistance faisant partie de l'interface.  Cela viole le principe d'encapsulation et pollue l'API publique de l'interface et des classes d'implémentation. </li></ol><br>  Heureusement, à partir de <a href="http://openjdk.java.net/jeps/213">Java 9, vous pouvez utiliser des méthodes privées dans les interfaces</a> .  Ils ont les caractéristiques suivantes: <br><br><ul><li>  les méthodes privées ont un corps, elles ne sont pas abstraites </li><li>  ils peuvent être statiques ou non statiques </li><li>  ils ne sont pas hérités par les classes qui implémentent l'interface et les interfaces </li><li>  ils peuvent appeler d'autres méthodes d'interface </li><li>  les méthodes privées peuvent appeler d'autres méthodes privées, abstraites, statiques ou par défaut </li><li>  les méthodes statiques privées ne peuvent appeler que d'autres méthodes statiques statiques et privées </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><h2>  Ordre chronologique </h2><br>  Voici une liste chronologique des modifications par version de Java: <br><br><h4>  Java 1.1 </h4><br>  Classes imbriquées <br><br>  Interfaces imbriquées <br><br><h4>  Java 5 </h4><br>  Types génériques <br><br>  Transferts fermés <br><br>  Annotations imbriquées <br><br><h4>  Java 8 </h4><br>  Méthodes par défaut <br><br>  Méthodes statiques <br><br><h4>  Java 9 </h4><br>  Méthodes privées </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482498/">https://habr.com/ru/post/fr482498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482486/index.html">Qu'est-ce que Misra et comment le faire cuire</a></li>
<li><a href="../fr482490/index.html">Qu'est-ce que MISRA et comment le faire cuire</a></li>
<li><a href="../fr482492/index.html">Dégel du pergélisol et émissions de gaz à effet de serre</a></li>
<li><a href="../fr482494/index.html">Mettre à jour les résultats de l'enquête</a></li>
<li><a href="../fr482496/index.html">Résultats: 9 avancées technologiques majeures de 2019</a></li>
<li><a href="../fr482500/index.html">Python ou R: quel est le meilleur choix pour la science des données?</a></li>
<li><a href="../fr482502/index.html">5,8 millions d'IOPS: pourquoi autant?</a></li>
<li><a href="../fr482504/index.html">Publier avec des publications: nos résultats pour 2019</a></li>
<li><a href="../fr482506/index.html">Entrée de données dans STM32F4xx à partir d'ADC parallèle via DCMI</a></li>
<li><a href="../fr482508/index.html">2019 sur Habré en chiffres: il y a plus de publications, moins les mêmes, commentez plus activement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>