<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📵 ✋🏾 🔳 功能思维。 第7部分 ☯️ 🚿 🥉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们将继续介绍有关F＃中的函数式编程的系列文章。 今天，我们有一个非常有趣的话题：函数的定义。 其中，让我们讨论匿名函数，不带参数的函数，递归函数，组合器等等。 看猫下！ 





- 第一部分 
- 第二部分 
- 第三部分 
- 第四部分 
- 第五部分 
- 第六部分 
 功能定义 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>功能思维。 第7部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p> 我们将继续介绍有关F＃中的函数式编程的系列文章。 今天，我们有一个非常有趣的话题：函数的定义。 其中，让我们讨论匿名函数，不带参数的函数，递归函数，组合器等等。 看猫下！ </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第六部分</a></strong> <a name="habracut"></a></li></ul><br><h1> 功能定义 </h1><br><p> 我们已经知道如何使用“ let”语法创建常规函数： </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p> 在本文中，我们将介绍创建函数的其他方法，以及定义函数的技巧。 </p><br><h2> 匿名函数（lambdas） </h2><br><p> 如果您熟悉其他语言的lambda，则以下几段看起来很熟悉。 匿名函数（或“ lambda表达式”）的定义如下： </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p> 与C＃中的lambda相比，有两个区别： </p><br><ul><li>  lambdas应该以<code>fun</code>关键字开头，这在C＃中不是必需的 </li><li> 使用单箭头<code>-&gt;</code> ，而不是C＃中的double <code>=&gt;</code> 。 </li></ul><br><p>  Lambda加法函数的定义： </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p> 传统形式的功能相同： </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambda通常以小表达式的形式使用，或者在不希望为表达式定义单独的函数时使用。 如您所见，在使用列表时，这并不罕见。 </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p> 请注意，必须在lambda周围使用括号。 </p><br><p> 当需要明显不同的功能时，也可以使用Lambda。 例如，可以使用lambdas重写前面讨论的“ <code>adderGenerator</code> ”（我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">之前讨论过）</a> 。 </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  lambda版本稍长一些，但是立即使您很清楚将返回一个中间函数。 </p><br><p>  Lambda可以嵌套。  <code>adderGenerator</code>定义的另一个示例，这次仅在lambda上。 </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p> 您是否清楚所有三个定义都相同？ </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p> 如果不是，请重新阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关curring</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">章节</a> 。 这对于理解非常重要！ </p><br><h2> 模式匹配 </h2><br><p> 定义函数后，可以像上面的示例中那样显式地将参数传递给它，但是也可以直接在参数部分与模板进行比较。 换句话说，参数部分可能包含模式（匹配模式），而不仅仅是标识符！ </p><br><p> 以下示例演示了在函数定义中使用模式： </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p> 仅当对应关系始终可确定时，才可以进行这种类型的比较。 例如，您不能以这种方式匹配联合类型和列表，因为某些情况无法匹配。 </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p> 编译器将发出有关不完全匹配的警告（空白列表将在此函数的入口处导致运行时错误）。 </p><br><h2> 常见错误：元组与 许多参数 </h2><br><p> 如果您来自类似C的语言，则用作该函数唯一参数的元组可能会非常类似于多参数函数。 但这不是同一回事！ 如前所述，如果您看到逗号，则很可能是元组。 参数以空格分隔。 </p><br><p> 混淆示例： </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li> 第一个定义“ <code>addTwoParams</code> ”采用两个参数，以空格分隔。 </li><li> 第二个定义“ <code>addTuple</code> ”采用一个参数。 此参数将元组中的“ x”和“ y”绑定并求和。 </li><li> 第三个定义“ <code>addConfusingTuple</code> ”采用单个参数，例如“ <code>addTuple</code> ”，但是窍门是将这个元组解包（与模式匹配）并使用模式匹配将其绑定为参数定义的一部分。 在幕后，所有操作都与<code>addTuple</code>完全相同。 </li></ul><br><p> 让我们看一下签名（如果不确定某些内容，请始终查看它们）。 </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p> 现在在这里： </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p> 在这里，我们看到了第二个调用中的错误。 </p><br><p> 首先，编译器将<code>(1,2)</code>视为形式<code>('a * 'b)</code>的通用元组，尝试将其作为第一个参数传递给<code>addTwoParams</code> 。 之后，他抱怨期望的第一个参数<code>addTwoParams</code>不是<code>int</code> ，但是尝试传递一个元组。 </p><br><p> 要制作元组，请使用逗号！ </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p> 反之亦然，如果您将多个参数传递给等待元组的函数，您还将收到一个无法理解的错误。 </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p> 这次，编译器决定一旦<code>addConfusingTuple</code>两个参数， <code>addConfusingTuple</code>应该对<code>addConfusingTuple</code>进行处理。 条目“ <code>addConfusingTuple 1</code> ”是部分应用程序，应该返回一个中间函数。 尝试使用参数“ 2”调用此中间函数将引发错误，因为 没有中间功能！ 我们看到了与curring一章中相同的错误，该章讨论了参数过多的问题。 </p><br><h3> 为什么不使用元组作为参数？ </h3><br><p> 上面对元组的讨论显示了定义具有许多参数的函数的另一种方法：可以将所有参数组装成一个结构，而不必分别传递它们。 在下面的示例中，该函数采用单个参数-三个元素的元组。 </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p> 应该注意的是，签名不同于具有三个参数的函数的签名。 只有一个箭头，一个参数和指向元组<code>(int*int*int)</code>星号。 </p><br><p> 什么时候需要提交带有单独参数的参数，以及何时使用元组？ </p><br><ul><li> 当元组本身很重要时。 例如，对于在三维空间中进行操作，三元组将比分别使用三个坐标更方便。 </li><li> 有时，元组用于将必须存储在一起的数据合并到一个结构中。 例如，.NET库中的<code>TryParse</code>方法返回结果和一个布尔变量作为元组。 但是要存储大量相关数据，最好定义一个类或记录（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">record）</a> 。 </li></ul><br><h3> 特殊情况：.NET库元组和函数 </h3><br><p> 调用.NET库时，逗号非常常见！ </p><br><p> 它们都接受元组，并且调用看起来与C＃中的相同： </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p> 原因是经典.NET的功能无法使用，无法部分应用。  <em>所有</em>参数必须<em>始终</em>立即传输，最明显的方法是使用元组。 </p><br><p> 请注意，这些调用仅看起来像传输元组，但这实际上是一种特殊情况。 您不能将真正的元组传递给以下函数： </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p> 如果要部分应用.NET函数，则可以像之前所做的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">那样</a>或如下所示在它们上面编写包装器： </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2> 选择单个参数和分组参数的指南 </h2><br><p> 元组的讨论引出了一个更笼统的话题：何时应该分开参数，何时将参数分组？ </p><br><p> 在这方面，您应注意F＃与C＃的区别。 在C＃中， <em>总是</em>传递<em>所有</em>参数，因此，这里根本不会出现这个问题！ 在F＃中，由于部分应用，只能表示某些参数，因此有必要区分参数应组合的情况和参数独立的情况。 </p><br><p> 有关在设计自己的功能时如何构造参数的一般建议。 </p><br><ul><li> 在一般情况下，最好使用单独的参数而不是传递一个结构（元组或记录）总是更好。 这允许更灵活的行为，例如部分应用程序。 </li><li> 但是，当<em>需要</em>一次传递一组参数时，应使用某种分组机制。 </li></ul><br><p> 换句话说，在开发功能时，问自己：“我可以单独提供此参数吗？” 如果答案为否，则应将参数分组。 </p><br><p> 让我们看几个例子： </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p> 最后，确保参数的顺序对部分应用有所帮助（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的手册）。 例如，为什么在最后一个函数<code>aName</code>放在<code>myCredentials</code>之前？ </p><br><h2> 没有参数的功能 </h2><br><p> 有时您可能需要一个不接受任何参数的函数。 例如，您需要可以多次调用的函数“ hello world”。 如上一节所示，天真定义不起作用。 </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p> 但这可以通过在函数中添加单位参数或使用lambda来解决。 </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p> 之后，应始终使用<code>unit</code>参数调用该函数： </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p> 与.NET库进行交互时经常发生的事情： </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p> 请记住，使用<code>unit</code>参数调用它们！ </p><br><h2> 定义新的运营商 </h2><br><p> 您可以使用一个或多个运算符来定义函数（有关字符列表，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ）： </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p> 您必须在字符周围使用括号来定义函数。 </p><br><p> 以<code>*</code>开头的运算符需要在括号和<code>*</code>之间加一个空格，因为 在F＃中<code>(*</code>用作注释的开头（如C＃中的<code>/*...*/</code> ）： </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p> 定义后，如果将新功能括在方括号中，则可以按常规方式使用它： </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p> 如果该函数与两个参数一起使用，则可以使用不带括号的中缀运算符记录。 </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p> 您还可以定义以<code>!</code>开头的前缀运算符<code>!</code> 或<code>~</code> （有一些限制，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ） </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p> 在F＃中，定义语句是一个相当常见的操作，许多库将导出名称，如<code>&gt;=&gt;</code>和<code>&lt;*&gt;</code> 。 </p><br><h2> 无点式 </h2><br><p> 我们已经看到了许多缺少最新参数以减少混乱程度的函数示例。 这种样式称为无<strong>点样式</strong>或<strong>默认编程</strong> 。 </p><br><p> 以下是一些示例： </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p> 这种风格各有利弊。 </p><br><p> 优点之一是，重点在于高阶函数的组成，而不是对低级对象大惊小怪。 例如，“ <code>(+) 1 &gt;&gt; (*) 2</code> ”是显式加法，后跟乘法。 并且“ <code>List.reduce (+)</code> ”清楚地表明，无论列表信息如何，加法操作都很重要。 </p><br><p> 无意义的样式使您可以专注于基本算法并识别代码中的常见功能。 上面使用的“ <code>reduce</code> ”功能就是一个很好的例子。 该主题将在计划的列表处理系列中进行讨论。 </p><br><p> 另一方面，过多使用这种样式会使代码晦涩难懂。 显式参数充当文档，其名称（例如“列表”）使您更容易理解函数的功能。 </p><br><p> 像编程中的所有内容一样，最好的建议是偏向提供最清晰的方法。 </p><br><h2> 组合器 </h2><br><p>  “ <strong>组合器</strong> ”称为函数，其结果仅取决于其参数。 这意味着不依赖外部世界，尤其是没有其他功能或全局值可以影响它们。 </p><br><p> 实际上，这意味着组合功能以各种方式受到其参数组合的限制。 </p><br><p> 我们已经看到了几种组合器：管道和组合运算符。 如果查看它们的定义，那么很显然，他们所做的只是以各种方式对参数重新排序。 </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p> 另一方面，“ printf”之类的函数尽管是原始函数，但它们并不是组合器，因为它们依赖于外部世界（I / O）。 </p><br><h3> 组合鸟 </h3><br><p> 组合器是整个逻辑部分（自然称为“组合逻辑”）的基础，该部分在计算机和编程语言问世之前就已经发明了很多年。 组合逻辑对函数式编程有很大的影响。 </p><br><p> 要了解有关组合器和组合逻辑的更多信息，我推荐Raymond Smullyan的书“模拟一只知更鸟”。 在其中，他解释了其他组合器，并幻想给它们起<a href="">鸟名</a> 。 以下是一些标准组合器及其鸟名的示例： </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p> 字母名称是非常标准的，因此您可以将K-combinator引用给熟悉此术语的任何人。 </p><br><p> 事实证明，可以通过这些标准组合器来表示许多常见的编程模式。 例如，Kestrel是流畅接口中的常规模式，您可以在其中执行某些操作，但返回原始对象。 画眉是管道，Queer是直接合成，Y组合器在创建递归函数方面做得很好。 </p><br><p> 实际上，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">众所周知的定理</a> ，即仅使用两个基本组合器（Kestrel和Starling）就可以构造任何可计算函数。 </p><br><h3> 组合图书馆 </h3><br><p> 组合库是导出许多旨在共享的组合功能的库。 这样的库的用户可以轻松地将功能组合在一起，以轻松获得更大，更复杂的功能，例如多维数据集。 </p><br><p> 设计良好的组合器库使您可以专注于高级功能，并隐藏低级“噪声”。 我们已经在“为什么使用F＃”系列的几个示例中看到了它们的功能，并且<code>List</code>模块中充斥着此类功能，如果您考虑一下，“ <code>fold</code> ”和“ <code>map</code> ”也是组合器。 </p><br><p> 组合器的另一个优点是它们是最安全的功能类型。 因为 它们不依赖外部世界；当全球环境变化时，它们也不会变化。 如果上下文发生更改，则读取全局值或使用库函数的函数可能会在调用之间中断或更改。 组合器永远不会发生这种情况。 </p><br><p> 在F＃中，可使用组合器库进行解析（FParsec），创建HTML，测试框架等。 在下一个系列的后面，我们将讨论和使用组合器。 </p><br><h2> 递归函数 </h2><br><p> 函数通常需要从其主体引用自身。 一个经典的例子是斐波那契函数。 </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p> 不幸的是，该函数将无法编译： </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p> 您必须使用<code>rec</code>关键字告诉编译器这是递归函数。 </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p> 递归函数和数据结构在函数式编程中非常常见，我希望以后再专门讨论这个主题。 </p><br><h1> 其他资源 </h1><br><p>  F＃的教程很多，包括那些具有C＃或Java经验的人的材料。 当您深入了解F＃时，以下链接可能会很有用： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃娱乐与利润</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃维基</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内学习X：F＃</a> </li></ul><br><p> 还介绍了其他几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始学习F＃的方法</a> 。 </p><br><p> 最后，F＃社区非常适合初学者。 在Slack上，由F＃Software Foundation支持的聊天非常活跃，您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以自由加入</a>初学者室。 我们强烈建议您这样做！ </p><br><p> 不要忘记访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区F＃的网站</a> ！ 如果您对学习语言有任何疑问，我们将很乐意在聊天室中讨论这些问题： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的<code>#ru_general</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在电报中聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的#en_general <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li></ul><br><h2> 关于翻译作者 </h2><br><p> 由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@kleidemos</em></a>翻译 <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在F＃开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区</a>的努力下进行了翻译和编辑更改。 我们也感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@schvepsss</em></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@shwars</em></a>为本文准备发表。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433398/">https://habr.com/ru/post/zh-CN433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433386/index.html">如何使用计算机视觉评估汽车状况。 体验Yandex.Taxi</a></li>
<li><a href="../zh-CN433388/index.html">公式迷或我们为什么玩游戏</a></li>
<li><a href="../zh-CN433390/index.html">Yandex加入了保护Linux和IT行业免于专利追索的保护</a></li>
<li><a href="../zh-CN433392/index.html">Snom D725 IP电话评论</a></li>
<li><a href="../zh-CN433396/index.html">前端2018：年度结果</a></li>
<li><a href="../zh-CN433400/index.html">React教程第2部分：功能组件</a></li>
<li><a href="../zh-CN433402/index.html">功能思维。 第8部分</a></li>
<li><a href="../zh-CN433404/index.html">React教程第3部分：组件文件，项目结构</a></li>
<li><a href="../zh-CN433406/index.html">功能思维。 第9部分</a></li>
<li><a href="../zh-CN433408/index.html">Node.js中的高效内存处理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>