<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦁 ☝️ ⚫️ opencv4arts: dibuja mi ciudad, Vincent 🚕 👼 😩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenCV es una biblioteca con una historia de desarrollo continuo en 20 años. La edad cuando comienzas a cavar en ti mismo, buscando un destino. ¿Hay a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>opencv4arts: dibuja mi ciudad, Vincent</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/437600/"><p>  OpenCV es una biblioteca con una historia de desarrollo continuo en 20 años.  La edad cuando comienzas a cavar en ti mismo, buscando un destino.  ¿Hay algún proyecto basado en él que haya mejorado la vida de alguien, alguien más feliz?  ¿Puedes hacerlo tú mismo?  En busca de respuestas y un deseo de descubrir módulos OpenCV previamente desconocidos, quiero crear aplicaciones que "funcionen maravillosamente", de modo que al principio haya "wow" y solo entonces diga "oh sí, es visión por computadora". </p><br><p>  El derecho del primer artículo fue un experimento con la transferencia de estilos de artistas mundiales en fotografía.  Del artículo aprenderá cuál es el corazón del procedimiento y sobre la relativamente nueva versión de OpenCV.js - JavaScript de la biblioteca OpenCV. </p><br><p><img src="https://habrastorage.org/webt/bd/gi/zx/bdgizx8meb6hqmshphkkpsonuee.jpeg"></p><a name="habracut"></a><br><h2 id="style-transfer">  Transferencia de estilo </h2><br><p> Los opositores al aprendizaje automático me perdonarán, pero el componente principal del artículo de hoy será una red convolucional profunda.  Porque funciona  No hay forma de entrenar redes neuronales en OpenCV, pero puede ejecutar modelos existentes.  Utilizaremos la red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CycleGAN previamente capacitada</a> .  Los autores, por los cuales están muy agradecidos, ofrecen redes completamente gratuitas para descargar que convierten imágenes de manzanas en naranjas, caballos en cebras, imágenes satelitales en mapas, fotos de invierno en fotos de verano y mucho más.  Además, el procedimiento de capacitación en red le permite tener dos modelos de generador trabajando en ambas direcciones a la vez.  Es decir, al enseñar la transformación del invierno en verano, obtendrá un modelo para pintar paisajes de invierno en fotografías de verano.  Una oferta única que es imposible de rechazar. </p><br><p>  En nuestro ejemplo, tomamos modelos que convierten fotos en pinturas de artistas.  A saber, Vincent Van Gogh, Claude Monet, Paul Cezanne o en todo el género de estampas japonesas Ukiyo-e.  Es decir, tendremos cuatro redes separadas a nuestra disposición.  Vale la pena señalar que para el entrenamiento de cada uno se utilizó no una imagen del artista, sino una multitud completa, por lo que los autores trataron de entrenar la red neuronal para no cambiar el estilo de una obra, sino, por así decirlo, adoptar el estilo de escritura. </p><br><h2 id="opencvjs">  Opencv.js </h2><br><p>  OpenCV es una biblioteca desarrollada en C ++, mientras que para la mayor parte de su funcionalidad existe la posibilidad de crear envoltorios automáticos que llaman métodos nativos.  Oficialmente, se admiten envoltorios para los lenguajes Python y Java.  Además, hay soluciones personalizadas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP</a> .  Si tiene experiencia en el uso de otros idiomas, sería bueno saber en qué y gracias a qué esfuerzos. </p><br><p> OpenCV.js es un proyecto que se ha ganado el derecho a la vida gracias al programa Google Summer of Code en 2017.  Por cierto, una vez que el módulo de aprendizaje profundo OpenCV fue creado y mejorado significativamente en su marco.  A diferencia de otros lenguajes, OpenCV.js en este momento no es un contenedor de métodos nativos en JavaScript, sino una compilación completa usando Emscripten usando LLVM y Clang.  Le permite crear un archivo desde su aplicación C y C ++ o biblioteca <code>.js</code> que se puede ejecutar, por ejemplo, en un navegador. </p><br><p>  Por ejemplo, </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main(int argc, char** argv) { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Compilando en <code>asm.js</code> </p><br><pre> <code class="plaintext hljs">emcc main.cpp -s WASM=0 -o main.js</code> </pre> <br><p>  Y carga: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote><img src="https://habrastorage.org/webt/pt/pp/bx/ptppbxsjtgxqe48qlfpxho0umaa.png"></blockquote><p>  Puede conectar OpenCV.js a su proyecto de la siguiente manera (compilación nocturna): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/opencv.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  También puede ser útil una biblioteca adicional para leer imágenes, trabajar con la cámara y otras cosas, que está escrita manualmente en JavaScript: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/utils.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="zagruzka-izobrazheniy">  Subir imágenes </h2><br><p>  Las imágenes en OpenCV.js se pueden leer desde elementos como <code>canvas</code> o <code>img</code> .  Esto significa que descargar archivos de imagen directamente a ellos sigue siendo tarea del usuario.  Por conveniencia, la función auxiliar <code>addFileInputHandler</code> cargará automáticamente la imagen en el elemento de <code>canvas</code> deseado cuando se selecciona una imagen del disco con solo hacer clic en un botón. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> utils = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Utils(<span class="hljs-string"><span class="hljs-string">''</span></span>); utils.addFileInputHandler(<span class="hljs-string"><span class="hljs-string">'fileInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>);</code> </pre> <br><p>  donde </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fileInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">accept</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image/*"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvasInput"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  El punto importante es que <code>img</code> será una imagen RGBA de 4 canales, que es diferente del <code>cv::imread</code> habitual <code>cv::imread</code> , que crea una imagen BGR.  Esto debe tenerse en cuenta, por ejemplo, al portar algoritmos de otros idiomas. </p><br><p>  Con el renderizado, todo es simple: solo llame a <code>imshow</code> con la <code>id</code> <code>canvas</code> deseado (espera RGB o RGBA). </p><br><pre> <code class="javascript hljs">cv.imshow(<span class="hljs-string"><span class="hljs-string">"canvasOutput"</span></span>, img);</code> </pre> <br><h3 id="algoritm">  Algoritmo </h3><br><p>  Todo el algoritmo de procesamiento de imágenes es el lanzamiento de una red neuronal.  Supongamos que lo que sucede dentro sigue siendo mágico, solo necesitamos preparar la entrada correcta e interpretar la predicción correctamente (salida de red). </p><br><p>  La red considerada en este ejemplo recibe un tensor de cuatro dimensiones con valores <code>float</code> en el intervalo <code>[-1, 1]</code> .  Cada una de las dimensiones, en orden de velocidad de cambio, es el índice de la imagen, los canales, la altura y el ancho.  Este estilo se llama NCHW, y el tensor en sí se llama blob, objeto binario grande.  La tarea de preprocesamiento es convertir una imagen OpenCV, cuyas intensidades están intercaladas, tienen un intervalo de valores <code>[0, 255]</code> tipo <code>unsigned char</code> en un blob NCHW con un rango de valores <code>[-1, 1]</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/yi/yo/biyiyoyp35oyopnpk3zb3yzohzm.jpeg"><br>  <em>un pedazo del Kremlin de Nizhny Novgorod (como ve una persona)</em> </p><br><p><img src="https://habrastorage.org/webt/qq/ju/nf/qqjunf_3hmkujx9ano4ordvwdtc.jpeg"><br>  <em>vista intercalada (cómo se almacena OpenCV)</em> </p><br><p><img src="https://habrastorage.org/webt/cc/z3/ln/ccz3lnfgrpn-tju9bbtk3qvlhdg.jpeg"><br>  <em>vista plana (lo que necesita la red)</em> </p><br><p>  Como postprocesamiento, será necesario realizar las transformaciones inversas: la red devuelve un blob NCHW con valores en el intervalo <code>[-1, 1]</code> , que deben volverse a empaquetar en la imagen, normalizar a <code>[0, 255]</code> y convertir a caracteres <code>unsigned char</code> . </p><br><p>  Por lo tanto, teniendo en cuenta todas las características de lectura y escritura de imágenes OpenCV.js, los siguientes pasos están tomando forma: </p><br><pre> <code class="plaintext hljs">imread -&gt; RGBA -&gt; BGR [0, 255] -&gt; NCHW [-1, 1] -&gt; [] [] -&gt; NCHW [-1, 1] -&gt; RGB [0, 255] -&gt; imshow</code> </pre> <br><p>  Al observar la tubería resultante, surgen preguntas, ¿por qué la red no puede funcionar inmediatamente en RGBA intercalado y devolver RGB intercalado?  ¿Por qué se necesitan transformaciones adicionales para la permutación y normalización de píxeles?  La respuesta es que una red neuronal es un objeto matemático que realiza transformaciones en los datos de entrada de una determinada distribución.  En nuestro caso, fue entrenada para recibir datos de esta forma, por lo tanto, para obtener los resultados deseados, es necesario reproducir el preprocesamiento que los autores utilizaron en la capacitación. </p><br><h3 id="realizaciya">  Implementación </h3><br><p>  La red neuronal que ejecutaremos se almacena en forma de un archivo binario, que primero debe cargarse en el sistema de archivos local. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> net; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>; utils.createFileFromUrl(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>, url, () =&gt; { net = cv.readNet(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>); });</code> </pre> <br><p>  Por cierto, <code>url</code> es un enlace completo al archivo.  En este caso, solo cargamos el archivo junto a la página HTML actual, pero puede reemplazarlo con la <a href="">fuente original</a> (en este caso, el tiempo de descarga puede ser más largo). </p><br><p>  Lectura de una imagen del <code>canvas</code> y conversión de RGBA a BGR: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgRGBA = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgBGR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cv.Mat(imgRGBA.rows, imgRGBA.cols, cv.CV_8UC3); cv.cvtColor(imgRGBA, imgBGR, cv.COLOR_RGBA2BGR);</code> </pre> <br><p>  Crear un blob 4D donde la función <code>blobFromImage</code> convierte en un <code>float</code> datos <code>float</code> utilizando constantes de normalización.  Luego, inicie la red. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = cv.blobFromImage(imgBGR, <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">127.5</span></span>, <span class="hljs-comment"><span class="hljs-comment">//  {width: imgBGR.cols, height: imgBGR.rows}, //  [127.5, 127.5, 127.5, 0]); //   net.setInput(blob); var out = net.forward();</span></span></code> </pre> <br><p>  El resultado se convierte de nuevo a la imagen del tipo deseado y el intervalo de valores <code>[0, 255]</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     [-1, 1]  [0, 255] var outNorm = new cv.Mat(); out.convertTo(outNorm, cv.CV_8U, 127.5, 127.5); //  interleaved   planar  var outHeight = out.matSize[2]; var outWidth = out.matSize[3]; var planeSize = outHeight * outWidth; var data = outNorm.data; var b = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(0, planeSize)); var g = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(planeSize, 2 * planeSize)); var r = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(2 * planeSize, 3 * planeSize)); var vec = new cv.MatVector(); vec.push_back(r); vec.push_back(g); vec.push_back(b); var rgb = new cv.Mat(); cv.merge(vec, rgb); //   cv.imshow("canvasOutput", rgb);</span></span></code> </pre> <br><p>  Por el momento, OpenCV.js se está construyendo en modo semiautomático.  En el sentido de que no todos los módulos y métodos de ellos reciben las firmas correspondientes en JavaScript.  Por ejemplo, para un módulo dnn, la lista de funciones válidas se define de la siguiente manera: </p><br><pre> <code class="python hljs">dnn = {<span class="hljs-string"><span class="hljs-string">'dnn_Net'</span></span>: [<span class="hljs-string"><span class="hljs-string">'setInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'forward'</span></span>], <span class="hljs-string"><span class="hljs-string">''</span></span>: [<span class="hljs-string"><span class="hljs-string">'readNetFromCaffe'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTensorflow'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTorch'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromDarknet'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromONNX'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNet'</span></span>, <span class="hljs-string"><span class="hljs-string">'blobFromImage'</span></span>]}</code> </pre> <br><p>  La última conversión, dividiendo el blob en tres canales y luego mezclándolos en una imagen, de hecho, se puede hacer con un método <code>imagesFromBlob</code> , que aún no se ha agregado a la lista anterior.  ¿Quizás esta sea su primera contribución al desarrollo de OpenCV?  ;) </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Como demostración, preparé una página en GitHub donde puede probar el código resultante: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://dkurtaev.github.io/opencv4arts</a> (¡Precaución! Descargar una red de aproximadamente 22 MB, guardar su tráfico. También se recomienda volver a cargar la página para cada nueva imagen, de lo contrario, la calidad el procesamiento posterior de alguna manera está fuertemente distorsionado).  Esté preparado para un proceso de procesamiento largo o intente cambiar el tamaño de la imagen, que será el resultado, un control deslizante. </p><br><p>  Mientras trabajaba en el artículo y elegía la imagen que se convertiría en su rostro, accidentalmente encontré una foto de mi amiga, que representa el Kremlin de nuestra ciudad y todo se unió, se me ocurrió el nombre del artículo y solo entonces sentí que debería ser así.  Le sugiero que pruebe la aplicación en fotos de su lugar favorito y, tal vez, diga algo interesante al respecto en los comentarios o en una carta personal. </p><br><p>  De mí, un hecho divertido.  La mayoría de los residentes de Nizhny Novgorod y la región de Nizhny Novgorod usan la palabra "salir" en el sentido de la palabra "encajar" (encontrar un lugar libre).  Por ejemplo, la pregunta "¿Limpiaremos su automóvil?"  significa "¿Tenemos suficiente espacio en su automóvil?", pero no "¿Podemos limpiar su automóvil?".  Cuando los estudiantes de otras áreas acuden a nosotros para realizar pasantías de verano, nos encanta contar este hecho: muchos se sorprenden sinceramente. </p><br><h2 id="poleznye-ssylki">  Enlaces utiles </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentación de OpenCV.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelos CycleGAN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros modelos de transferencia de estilo</a> (difieren en la normalización) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437600/">https://habr.com/ru/post/437600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437590/index.html">Números de latencia en iPhone</a></li>
<li><a href="../437592/index.html">Arquitectura asincrónica de la capa de ejecución de tareas</a></li>
<li><a href="../437594/index.html">Cómo erradicaba la causa de la tartamudez y el salto de cuadro en todos los juegos, y también bajaba accidentalmente la temperatura en 15 grados</a></li>
<li><a href="../437596/index.html">OTRS: autenticación, autorización y sincronización LDAP (FreeIPA, AD)</a></li>
<li><a href="../437598/index.html">Cómo guardar el sistema de juego desde la PC doméstica mediante la virtualización</a></li>
<li><a href="../437602/index.html">Perfile un proyecto de Unity con Android Studio</a></li>
<li><a href="../437604/index.html">Colapso de la función de onda: un algoritmo inspirado en la mecánica cuántica</a></li>
<li><a href="../437606/index.html">¿Quién se come el recuerdo de nuestro iPhone? Pelar manzanas</a></li>
<li><a href="../437610/index.html">[Longrid] 20 años de carrera de programación en una pequeña ciudad grande</a></li>
<li><a href="../437612/index.html">El gigante de TI se ocupará de la fotónica de silicio: cómo afectará al mercado de equipos de red</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>