<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∞ üê∑ ü§∏üèæ Kotlin puzzlers, vol. 2: um novo lote de quebra-cabe√ßas üêì üçº üôÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voc√™ pode prever como esse c√≥digo Kotlin se comportar√°? Compilar√° o que ser√° produzido e por qu√™? 

 N√£o importa o qu√£o boa seja a linguagem de progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin puzzlers, vol. 2: um novo lote de quebra-cabe√ßas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  Voc√™ pode prever como esse c√≥digo Kotlin se comportar√°?  Compilar√° o que ser√° produzido e por qu√™? <br><br>  N√£o importa o qu√£o boa seja a linguagem de programa√ß√£o, ela pode ser lan√ßada de modo que resta apenas arranhar a parte de tr√°s da cabe√ßa.  Kotlin n√£o √© exce√ß√£o - ele tamb√©m cont√©m quebra-cabe√ßas, quando mesmo um peda√ßo muito curto de c√≥digo tem um comportamento inesperado. <br><br>  Em 2017, publicamos no Habr√© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sele√ß√£o</a> desses quebra-cabe√ßas de <b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Keks antonkeks</a> .  E depois, ele se apresentou conosco no Mobius com a segunda sele√ß√£o, e agora tamb√©m o traduzimos para Habr em uma exibi√ß√£o de texto, ocultando as respostas corretas sob os spoilers. <br><br>  Tamb√©m anexamos a grava√ß√£o de v√≠deo do discurso, se algo parecer incompreens√≠vel no texto, voc√™ tamb√©m poder√° entrar em contato com ela. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A primeira metade dos quebra-cabe√ßas √© voltada para aqueles que n√£o est√£o muito familiarizados com Kotlin;  a segunda metade √© para desenvolvedores hardcore do Kotlin.  Iniciaremos tudo no Kotlin 1.3, mesmo com o modo progressivo ativado.  Os c√≥digos-fonte do quebra-cabe√ßas est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no GitHub</a> .  Quem tiver novas id√©ias, envie solicita√ß√µes pull. <br><br><h2>  N√∫mero Pazzler 1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(‚Ä≥Hello‚Ä≥) == print(‚Ä≥World‚Ä≥) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Antes de n√≥s, existe uma simples fun√ß√£o hello, que executa v√°rias impress√µes.  E lan√ßamos essa fun√ß√£o em si.  Uma pergunta simples sobre overclock: o que deve ser impresso? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) N√£o compilado <br><br><div class="spoiler">  <b class="spoiler_title">Resposta correta</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  A primeira op√ß√£o estava correta.  A compara√ß√£o √© acionada ap√≥s o in√≠cio das duas impress√µes, n√£o √© poss√≠vel iniciar mais cedo.  Por que esse c√≥digo √© compilado?  Qualquer fun√ß√£o diferente de retornar Nothing retorna algo.  Como tudo em Kotlin √© uma express√£o, at√© o retorno tamb√©m √© uma express√£o.  O tipo de retorno de retorno √© Nothing, √© convertido para qualquer tipo, para que voc√™ possa comparar assim.  E a impress√£o retorna a Unidade, para que a Unidade possa ser comparada a Nada in√∫meras vezes, e tudo funciona muito bem. <br></div></div><br><h2>  N√∫mero Pazzler 2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  Sugira que voc√™ n√£o adivinha: um n√∫mero assustador √© realmente o menor n√∫mero inteiro assinado de 32 bits poss√≠vel. <br><br>  Tudo parece simples aqui.  O Kotlin possui √≥timas fun√ß√µes de extens√£o, como .inc (), para incrementar.  Podemos cham√°-lo no Int e podemos imprimir o resultado.  O que vai acontecer? <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) Nenhuma das op√ß√µes acima <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamento!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  Como voc√™ pode ver na mensagem de erro, aqui est√° o problema com o Long.  Mas por quanto tempo? <br><br>  As fun√ß√µes de extens√£o t√™m prioridade, e o compilador executa primeiro inc () e depois o operador menos.  Se inc () for removido, ser√° Int e tudo funcionar√°.  Mas inc (), iniciando primeiro, transforma 2_147_483_648 em Long, porque esse n√∫mero sem menos n√£o √© mais v√°lido Int.  Acontece que Long, e s√≥ ent√£o menos √© chamado.  Tudo isso n√£o pode mais ser passado para a fun√ß√£o printInt (), porque requer um Int. <br><br>  Se alterarmos a chamada printInt para uma impress√£o regular, que pode aceitar Long, a segunda op√ß√£o estar√° correta. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  Vemos que isso √© realmente longo.  Cuidado com isso: nem todas as pe√ßas do quebra-cabe√ßa podem ser encontradas em c√≥digo real, mas essa pode. <br></div></div><br><h2>  N√∫mero Pazzler 3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  No Kotlin 1.3, surgiram novos recursos excelentes.  Al√©m da vers√£o final do corutin, n√≥s tamb√©m <br>  agora finalmente t√™m n√∫meros n√£o assinados.  Isso √© necess√°rio, especialmente se voc√™ estiver escrevendo algum tipo de c√≥digo de rede. <br><br>  Agora, para literais, existe at√© uma letra especial u, podemos definir constantes, podemos, como no exemplo, decrementar x e converter em Int.  Lembro que Int est√° familiarizado conosco. <br><br>  O que vai acontecer? <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0 -2 <br>  d) N√£o compilado <br><br>  4294967294 √© o n√∫mero m√°ximo de 32 bits que pode ser obtido. <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamento!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  Op√ß√£o correta b. <br><br>  Aqui, como na vers√£o anterior: primeiro, toInt () √© chamado em x, e somente ent√£o diminui.  O resultado do decremento n√£o assinado √© exibido e esse √© o m√°ximo de unsignedInt. <br><br>  O mais interessante √© que, se voc√™ escrever assim, o c√≥digo n√£o ser√° compilado: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  E para mim √© muito estranho que a primeira linha funcione, e a segunda - n√£o, isso √© il√≥gico. <br><br>  E na vers√£o de pr√©-lan√ßamento, a op√ß√£o correta seria C, t√£o bem feita no JetBrains que corrige bugs antes do lan√ßamento da vers√£o final. <br></div></div><br><h2>  N√∫mero Pazzler 4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  N√≥s encontramos este caso em c√≥digo real.  N√≥s da Codeborne criamos o Coding Dojo e o implementamos juntos no Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Game of Life</a> .  Como voc√™ pode ver, n√£o √© muito conveniente trabalhar com matrizes de v√°rios n√≠veis no Kotlin. <br><br>  Em Game of Life, uma parte importante do algoritmo √© determinar o n√∫mero de vizinhos para uma c√©lula.  Todos os pequenos ao redor s√£o vizinhos e depende se a c√©lula vive ou morre.  Nesse c√≥digo, voc√™ pode contar e assumir o que acontece. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) N√£o compilado <br><br><div class="spoiler">  <b class="spoiler_title">Vamos ver</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  A resposta correta √© 3. <br><br>  O fato √© que o sinal de mais da primeira linha √© movido para baixo, e Kotlin acha que isso √© unaryPlus ().  Como resultado, apenas as tr√™s primeiras c√©lulas s√£o somadas.  Se quisermos escrever esse c√≥digo em v√°rias linhas, precisamos mover o sinal de mais. <br><br>  Este √© outro dos "maus quebra-cabe√ßas".  Lembre-se, no Kotlin, voc√™ n√£o precisa transferir a declara√ß√£o para uma nova linha, caso contr√°rio, ela pode ser considerada un√°ria. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  N√£o vi situa√ß√µes em que o unaryPlus seja necess√°rio em c√≥digo real, exceto DSL.  Este √© um t√≥pico muito estranho. <br><br>  Esse √© o pre√ßo que pagamos pela aus√™ncia de ponto e v√≠rgula.  Se fossem, ficaria claro quando uma express√£o termina e outra come√ßa.  E sem eles, o compilador deve tomar a decis√£o.  Alimenta√ß√µes de linha para o compilador muitas vezes significam que faz sentido tentar examinar as linhas separadamente. <br><br>  Mas h√° uma linguagem JavaScript muito legal na qual voc√™ tamb√©m n√£o pode escrever ponto e v√≠rgula, e esse c√≥digo ainda funcionar√° corretamente. <br></div></div><br><h2>  Pazzler n√∫mero 5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  Este quebra-cabe√ßas √© apresentado pelo orador da KotlinConf, Thomas Nild. <br><br>  O Kotlin possui um √≥timo recurso de tipos anul√°veis.  Temos x anul√°vel e podemos convert√™-lo, se for nulo, atrav√©s do operador Elvis para algum valor normal. <br><br>  O que vai acontecer? <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamento!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  O problema est√° novamente na ordem ou prioridade dos operadores.  Se reformatarmos isso, o formato oficial far√° o seguinte: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  O formato j√° sugere que 0 + y come√ßa primeiro e somente ent√£o x?:.  Portanto, √© claro, 2 permanece, porque X √© dois, n√£o √© nulo. <br></div></div><br><h2>  N√∫mero Pazzler 6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ‚Ä≥Simple IPA‚Ä≥ hops { name = ‚Ä≥Cascade‚Ä≥ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  Quando me chamaram aqui, me prometeram cerveja artesanal.  Vou procur√°-lo hoje √† noite, ainda n√£o o vi.  Kotlin tem um √≥timo t√≥pico - construtores.  Com quatro linhas de c√≥digo, escrevemos nossa DSL e depois a criamos atrav√©s dos construtores. <br><br>  Criamos, primeiramente, o IPA, adicionamos l√∫pulo chamado Cascade, 100 gramas no 15¬∫ minuto de cozimento, e depois imprimimos esta receita.  O que n√≥s fizemos? <br><br>  a) Receita (nome = IPA simples, l√∫pulo = [L√∫pulo (nome = Cascata, atMinuto = 15, gramas = 100)]) <br>  b) IllegalArgumentException <br>  c) N√£o compilado <br>  d) Nenhuma das op√ß√µes acima <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamento!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  Temos algo parecido com a cerveja artesanal, mas n√£o h√° l√∫pulo nela, ela desapareceu.  Eles queriam um IPA, mas conseguiram o B√°ltico 7. <br><br>  √â aqui que o conflito de nomes aconteceu.  O campo no Hops √© chamado de kind e, na linha name = ‚Ä≥ Cascade ‚Ä≥, usamos name, que √© armazenado em cache com o nome da receita. <br><br>  Podemos criar nossa pr√≥pria anota√ß√£o BeerLang e registr√°-la como parte da DSL BeerLang.  Agora estamos tentando executar esse c√≥digo, e ele n√£o deve ser compilado conosco. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  Agora nos dizem que, em princ√≠pio, o nome n√£o pode ser usado nesse contexto.  Para isso, o DSLMarker √© necess√°rio porque o compilador dentro do construtor n√£o nos permitiu usar o campo externo, se tivermos o mesmo dentro dele para que n√£o haja conflito de nomenclatura.  O c√≥digo √© fixo assim, e obtemos nossa receita. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler n√∫mero 7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Este quebra-cabe√ßas √© um dos funcion√°rios da JetBrains.  Kotlin tem um recurso quando.  √â para todas as ocasi√µes, permite que voc√™ escreva c√≥digos legais, geralmente √© usado junto com classes seladas para o design da API. <br><br>  Nesse caso, temos uma fun√ß√£o f () que pega um booleano e imprime algo dependendo de verdadeiro e falso. <br><br>  O que vai acontecer? <br><br>  a) verdadeiro VERDADEIRO;  falso falso <br>  b) verdadeiro VERDADEIRO;  false VERDADEIRO <br>  c) verdadeiro FALSO;  falso falso <br>  d) Nenhuma das op√ß√µes acima <br><br><div class="spoiler">  <b class="spoiler_title">Vamos ver</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Porque  Primeiro, calculamos a express√£o x == true: por exemplo, no primeiro caso, ser√° true == true, o que significa true.  E tamb√©m h√° uma compara√ß√£o com o padr√£o que passamos quando. <br><br>  E quando x √© definido como false, a avalia√ß√£o de x == true nos fornecer√° false, no entanto, a amostra tamb√©m ser√° falsa - portanto, o exemplo corresponder√° √† amostra. <br><br>  H√° duas maneiras de corrigir esse c√≥digo: uma √© remover ‚Äúx ==‚Äù nos dois casos: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  A segunda op√ß√£o √© remover (x) depois de quando.  Quando funciona com quaisquer condi√ß√µes e, em seguida, n√£o corresponde √† amostra. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  N√∫mero Pazzler 8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ‚Ä≥Kotlin‚Ä≥ } print(Kotlin().logo)</code> </pre><br>  O Kotlin foi comercializado como uma linguagem "null safe".  Imagine que temos uma classe abstrata, ela tem algum nome e tamb√©m uma propriedade que retorna o logotipo dessa linguagem: a primeira letra do nome, por via das mai√∫sculas, em mai√∫scula (de repente foi esquecido fazer o capital inicial). <br><br>  Como o idioma √© nulo seguro, alteraremos o nome e provavelmente obteremos o logotipo correto, que √© uma letra.  O que realmente recebemos? <br><br>  a) K <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) N√£o compilado <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamento!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  Temos uma NullPointerException, que n√£o devemos receber.  O problema √© que o construtor da superclasse √© chamado primeiro, o c√≥digo tenta inicializar o logotipo da propriedade e recebe o nome char de zero e, nesse momento, o nome √© nulo, portanto ocorre uma NullPointerException. <br><br>  A melhor maneira de corrigir isso √© fazer o seguinte: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ‚Ä≥Kotlin‚Ä≥ }</code> </pre><br>  Se rodarmos esse c√≥digo, obteremos "K".  Agora a classe base chamar√° o construtor da classe base, na verdade chamar√° o nome do getter e obter√° o Kotlin. <br><br>  A propriedade √© um √≥timo recurso no Kotlin, mas voc√™ precisa ter muito cuidado ao substituir as propriedades, porque √© muito f√°cil esquecer, cometer um erro ou garantir a coisa errada. <br><br></div></div><br><h2>  N√∫mero Pazzler 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(‚Ä≥$i, $j; ‚Ä≥) } } result.forEach { it() }</code> </pre><br>  Existe uma lista mut√°vel de algumas coisas assustadoras.  Se ele lembra Scala, n√£o √© em v√£o, porque realmente se parece.  Existe uma lista lambd, tomamos dois contadores - I e j, incrementamos e depois fazemos algo com eles.  O que vai acontecer? <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) nenhuma das op√ß√µes acima <br><br><div class="spoiler">  <b class="spoiler_title">Vamos correr</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  Temos 3 1;  3 2;  3 3. Isso acontece porque i √© uma vari√°vel e ele manter√° seu valor at√© o final da fun√ß√£o.  E j √© passado por valor. <br><br>  Se, em vez de var i = 0, houvesse val i = 0, isso n√£o funcionaria, mas n√£o poder√≠amos incrementar a vari√°vel. <br><br>  Aqui no Kotlin usamos o fechamento, esse recurso n√£o est√° em Java.  √â muito legal, mas pode nos morder se n√£o usarmos imediatamente o valor de i, mas pass√°-lo para o lambda, que inicia mais tarde e v√™ o √∫ltimo valor dessa vari√°vel.  E j √© passado por valor, porque as vari√°veis ‚Äã‚Äãna condi√ß√£o do loop - s√£o iguais a val, n√£o mudam mais seu valor. <br><br>  Em JavaScript, a resposta seria "3 3;  3 3;  3 3 ‚Äù, porque nada √© transmitido por valor. <br><br></div></div><br><h2>  Pazzler n√∫mero 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(‚Ä≥$a, $b‚Ä≥) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  Temos uma fun√ß√£o foo (), pega dois booleanos, os imprime, tudo parece simples.  E temos muitos n√∫meros, resta ver qual √© o n√∫mero maior que o outro e decidir qual op√ß√£o est√° correta. <br><br>  a) verdadeiro, verdadeiro <br>  b) falso, falso <br>  c) nulo, nulo <br>  d) n√£o compilado <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  N√£o compilado. <br><br>  O problema √© que o compilador pensa que isso √© semelhante aos par√¢metros gen√©ricos: com &lt;a, b&gt;.  Embora pare√ßa que "c" n√£o seja uma classe, n√£o est√° claro por que ele deve ter par√¢metros gen√©ricos. <br><br>  Se o c√≥digo fosse assim, funcionaria bem: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  Parece-me que isso √© um bug no compilador.  Mas quando eu vou at√© Andrei Breslav com qualquer quebra-cabe√ßas, ele diz "isso ocorre porque o analisador √© assim, eles n√£o queriam que fosse muito lento".  Em geral, ele sempre encontra uma explica√ß√£o do porqu√™. <br><br>  Infelizmente √© assim.  Ele disse que eles n√£o v√£o consertar, porque o analisador <br>  Kotlin ainda n√£o conhece a sem√¢ntica.  A an√°lise ocorre primeiro e depois a transmite para outro componente do compilador.  Infelizmente, isso provavelmente continuar√° assim.  Portanto, n√£o escreva dois colchetes angulares e nenhum c√≥digo no meio! <br></div></div><br><h2>  Pazzler n√∫mero 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(‚Ä≥Kotlin‚Ä≥, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(‚Ä≥Hello $name, $items‚Ä≥)</code> </pre><br>  O delegado √© um √≥timo recurso no Kotlin.  A prop√≥sito, Andrei Breslav diz que esse √© um recurso que ele removeria de bom grado do idioma. Ele n√£o gosta mais.  Agora, talvez, vamos descobrir o porqu√™!  E ele tamb√©m disse que os objetos complementares s√£o feios. <br><br>  Mas as classes de dados s√£o definitivamente lindas.  Temos uma classe de dados Container, que leva um nome e itens para si.  Ao mesmo tempo, no Cont√™iner, implementamos o tipo de itens, isto √© Lista, e delegamos todos os seus m√©todos aos itens. <br><br>  Ent√£o usamos outro recurso interessante - desestruturar.  N√≥s "destru√≠mos" os elementos de nome e itens do container e os exibimos na tela.  Tudo parece ser simples e claro.  O que vai acontecer? <br><br>  a) Ol√° Kotlin, [1, 2, 3] <br>  b) Ol√° Kotlin, 1 <br>  c) Ol√° 1, 2 <br>  d) Ol√° Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  A op√ß√£o mais obscura √© d.  Ele acaba sendo verdade.  Como se viu, os itens simplesmente desaparecem da cole√ß√£o de itens, e n√£o do come√ßo ou do fim, mas apenas no meio.  Porque <br><br>  O problema com a desestrutura√ß√£o √© que, devido √† delega√ß√£o, todas as cole√ß√µes no Kotlin tamb√©m s√£o <br>  t√™m sua pr√≥pria op√ß√£o de desestrutura√ß√£o.  Eu posso escrever val (I, j) = listOf (1, 2) e obter esses 1 e 2 em vari√°veis, ou seja, List implementou as fun√ß√µes component1 () e <br>  component2 (). <br><br>  A classe de dados tamb√©m possui component1 () e component2 ().  Mas como o segundo componente, neste caso, √© privado, o p√∫blico da List vence, ent√£o o segundo elemento √© retirado da List e chegamos aqui 2. A moral √© muito simples: n√£o fa√ßa isso, n√£o fa√ßa isso. <br></div></div><br><h2>  N√∫mero Pazzler 12 </h2><br>  O pr√≥ximo quebra-cabe√ßas √© muito assustador.  Esta √© uma pessoa submissa que de alguma forma est√° conectada com Kotlin, para que ele saiba o que est√° escrevendo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  Temos uma fun√ß√£o de extens√£o em Any anul√°vel, ou seja, ela pode ser aplicada a qualquer coisa.  Este √© um recurso muito √∫til.  Se ainda n√£o estiver no seu projeto, vale a pena adicionar, pois pode colocar tudo o que voc√™ deseja em qualquer coisa.  Ent√£o pegamos 42 e lan√ßamos no Nada. <br><br>  Bem, se queremos ter certeza de que fizemos algo importante, podemos faz√™-lo !!!  write !!!!, o compilador Kotlin permite que voc√™ fa√ßa isso: se estiver faltando dois pontos de exclama√ß√£o, escreva pelo menos vinte e seis. <br><br>  Ent√£o n√≥s fazemos se (verdadeiro), e ent√£o eu mesmo n√£o entendo nada ... Vamos escolher imediatamente o que acontece. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) ClassCastException <br>  d) N√£o compilado <br><br><div class="spoiler">  <b class="spoiler_title">Assistindo</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  √â muito dif√≠cil dar uma explica√ß√£o l√≥gica.  Muito provavelmente, a Unidade aqui se deve ao fato de que n√£o h√° mais nada a ser empurrado para l√°.  Este √© um c√≥digo inv√°lido, mas funciona porque usamos o Nothing.  Fizemos upload de algo para Nothing, e esse √© um tipo especial que informa ao compilador que uma inst√¢ncia desse tipo nunca deve aparecer.  O compilador sabe que, se houver a possibilidade do aparecimento de Nothing, o que √© imposs√≠vel por defini√ß√£o, voc√™ n√£o poder√° verificar mais, essa √© uma situa√ß√£o imposs√≠vel. <br><br>  Provavelmente, este √© um bug no compilador, a equipe do JetBrains chegou a dizer que talvez esse bug seja corrigido algum dia, isso n√£o √© uma prioridade.  O truque √© que enganamos o compilador aqui por causa desse elenco.  Se voc√™ remover a linha 42.asGeneric &lt;Nothing&gt; () !!!  e parar de trapacear, o c√≥digo ir√° parar de compilar.  E se formos embora, o compilador enlouquece, acha que essa √© uma express√£o imposs√≠vel e enfia o que quer que esteja l√°. <br><br>  Eu entendo isso  Talvez algu√©m um dia o explique melhor. <br><br></div></div><br><h2>  Pazzler n√∫mero 13 </h2><br>  Temos uma caracter√≠stica muito interessante.  Voc√™ pode usar a inje√ß√£o de depend√™ncia, ou pode ficar sem ela, criar singletones atrav√©s do objeto e executar o programa legal.  Por que voc√™ precisa de Koin, Dagger ou algo assim?  Testar, no entanto, ser√° dif√≠cil. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  Temos a classe A aberta para heran√ßa, √© preciso algo dentro de si, criamos dois objetos'a, singleton, B e C, ambos s√£o herdados de A e passam um ao outro por l√°.  Ou seja, um excelente ciclo √© formado.  Em seguida, imprimimos o que B e C receberam. <br><br>  a) nulo;  nulo <br>  b) C;  nulo <br>  c) ExceptionInInitializerError <br>  d) N√£o compilado <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  A op√ß√£o correta √© C;  nulo <br><br>  Algu√©m poderia pensar que, quando o primeiro objeto √© inicializado, o segundo ainda n√£o est√° l√°.  Mas, quando deduzimos isso, C n√£o tem B. Ou seja, a ordem inversa √© obtida: por algum motivo, o compilador decidiu inicializar C primeiro e depois inicializou B junto com C. Parece il√≥gico, seria l√≥gico, pelo contr√°rio, nulo ;  B. <br><br>  Mas o compilador tentou fazer alguma coisa, n√£o teve sucesso, ele deixou nulo l√° e decidiu n√£o jogar nada para n√≥s.  Tamb√©m poderia ser assim. <br><br>  Se houver?  no tipo de par√¢metro, remova?, ent√£o n√£o funcionar√°. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  Podemos dizer bem ao compilador que, quando o nulo foi resolvido, ele tentou, mas falhou, mas o qu√™?  n√£o, ele nos lan√ßa uma exce√ß√£o de que √© imposs√≠vel fazer um ciclo. <br></div></div><br><h2>  Pazzler ‚Ññ14 </h2><br>  A vers√£o 1.3 lan√ßou grandes novas corotinas no Kotlin.  Pensei por um longo tempo como criar um quebra-cabe√ßas sobre corutin, para que algu√©m pudesse entender.  Para algumas pessoas, qualquer c√≥digo com corotinas √© um quebra-cabe√ßas. <br><br>  Na vers√£o 1.3, foram alterados alguns nomes de fun√ß√µes que estavam na vers√£o 1.2 da API experimental.  Por exemplo, buildSequence () √© renomeado para simplesmente sequence ().  Ou seja, podemos criar excelentes seq√º√™ncias com a fun√ß√£o yield, loops infinitos e, em seguida, podemos tentar obter algo dessa sequ√™ncia. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  Eles disseram com corotinas que todas as primitivas interessantes que est√£o em outros idiomas, como yield, podem ser feitas como fun√ß√µes de biblioteca, porque yield √© uma fun√ß√£o de suspens√£o que pode ser interrompida. <br><br>  O que vai acontecer? <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) Loop infinito <br>  d) Nenhuma das op√ß√µes acima <br><br><div class="spoiler">  <b class="spoiler_title">Lan√ßamento!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  A op√ß√£o correta √© a √∫ltima. <br><br>  A sequ√™ncia √© uma engenhoca pregui√ßosa e, quando nos apegamos a ela, tamb√©m √© pregui√ßosa.  Mas se voc√™ adicionar √† lista, ela realmente ser√° impressa [0, 1, 2]. <br><br>  A resposta correta n√£o est√° relacionada √†s corotinas.  As corotinas realmente funcionam, s√£o f√°ceis de usar.  Para a fun√ß√£o de sequ√™ncia e rendimento, voc√™ nem precisa conectar uma biblioteca a corotinas, tudo j√° est√° na biblioteca padr√£o. <br></div></div><br><h2>  Pazzler ‚Ññ15 </h2><br>  Este quebra-cabe√ßas tamb√©m √© controlado pelo desenvolvedor do JetBrains.  Existe um c√≥digo t√£o infernal: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  Quando o vi pela primeira vez, durante o KotlinConf, n√£o consegui dormir, tentei entender o que era.  Esse c√≥digo enigm√°tico pode ser escrito em Kotlin; portanto, se algu√©m pensou que Scalaz era assustador, ent√£o em Kotlin tamb√©m √© poss√≠vel. <br><br>  Vamos adivinhar: <br><br>  a) Kotlin.Unit <br>  b) Kotlin.Nada <br>  c) N√£o compilado <br>  d) Nenhuma das op√ß√µes acima <br><br><div class="spoiler">  <b class="spoiler_title">Vamos correr</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  Temos uma unidade que veio do nada. <br><br>  Porque  Primeiro, atribu√≠mos a vari√°vel lambda: {-&gt;} - este √© um c√≥digo v√°lido, voc√™ pode escrever um lambda vazio.  N√£o possui par√¢metros, n√£o retorna nada.  Consequentemente, ele retorna Unit. <br><br>  Atribu√≠mos um lambda √† vari√°vel e gravamos imediatamente a extens√£o nesse lambda e, em seguida, executamos.  De fato, ele simplesmente reserva o Kotlin.Unit. <br><br>  Nesse lambda, voc√™ pode escrever uma fun√ß√£o de extens√£o: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br>  √â declarado no tipo Fun√ß√£o &lt;*&gt;, e o que temos no topo tamb√©m √© adequado para ele.  Na verdade, √© a fun√ß√£o &lt;Unit&gt;, mas eu n√£o escrevi Unit que n√£o estava claro.  Voc√™ sabe como funciona um asterisco no Kotlin?     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      ‚Äî   . <br></div></div><br>    .    ,  Kotlin ‚Äî  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ¬´Coroutining Android Apps¬ª        .        ( Android,   iOS),      ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            ‚Äî  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440974/">https://habr.com/ru/post/pt440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440958/index.html">Como eu tentei consertar uma pesquisa no mapa por drivers. Parte 2</a></li>
<li><a href="../pt440960/index.html">Orange Pi 2G-IOT: mapa do campo minado</a></li>
<li><a href="../pt440962/index.html">Os provedores de comunica√ß√£o ser√£o obrigados a concluir contratos para a conex√£o de edif√≠cios residenciais</a></li>
<li><a href="../pt440966/index.html">Conex√£o dos sensores KELLER ao MATLAB</a></li>
<li><a href="../pt440972/index.html">Universidade de Innopolis realizar√° a primeira escola internacional de design de ve√≠culos aut√¥nomos da R√∫ssia</a></li>
<li><a href="../pt440976/index.html">Examinei toda a √Åustria e encontrei ...</a></li>
<li><a href="../pt440978/index.html">Termostato program√°vel sem fio Wi-Fi com monitor de qualidade do ar e outros recursos √∫teis</a></li>
<li><a href="../pt440980/index.html">Que presentes est√£o esperando por homens em 23 de fevereiro? Resultados da pesquisa</a></li>
<li><a href="../pt440984/index.html">Como a redu√ß√£o da taxa de aquisi√ß√£o nos afetar√° (portadores de cart√£o) - 2</a></li>
<li><a href="../pt440986/index.html">Locomotivas: o que sabemos sobre vag√µes ferrovi√°rios automotores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>