<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ âœğŸ¼ ğŸ‘¨â€ğŸ”§ Kekacauan ketergantungan python ğŸˆ‚ï¸ ğŸ˜¸ ğŸ§—ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah Anda akrab dengan sejarah pengemasan Python? Apakah Anda menavigasi dalam format paket? Apakah Anda tahu bahwa Anda harus mengurai kusut keterg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kekacauan ketergantungan python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/483920/"> Apakah Anda akrab dengan sejarah pengemasan Python?  Apakah Anda menavigasi dalam format paket?  Apakah Anda tahu bahwa Anda harus mengurai kusut ketergantungan bahkan ketika tampaknya itu adalah keajaiban - ketergantungan nol?  Saya yakin mereka tidak akrab dengan semua ini seperti penulis perpustakaan DepHell. <br><br><img src="https://habrastorage.org/webt/zp/dv/ao/zpdvaohc2qflukqaxxduyl7rxmu.png"><br><br>  Saya berhasil berbicara dengan <b>Nikita Voronov</b> , lebih dikenal sebagai Gram atau <a href="https://habr.com/ru/users/orsinium/" class="user_link">orsinium</a> , dan bertanya kepadanya tentang topik laporan di masa depan, rasa sakit dari keputusan penyelesaian ketergantungan yang buruk, DepHell, pip, prinsip pertandingan pertama yang menang, Guido, Pipfile, pengembangan penambahan Python, dan masa depan ekosistem. <br><a name="habracut"></a><br>  <b>- Di Moscow Python Conf ++ Anda akan berbicara tentang dependensi dan semua yang ada di sebelahnya.</b>  <b>Mengapa Anda memilih topik seperti itu saja untuk laporan?</b> <br><br>  Karena pertanyaan ini melewati semua pengalaman saya dengan Python.  Ketika saya membuat paket pertama saya, menulis kode pertama, saya berpikir tentang bagaimana membantu orang lain sehingga mereka dapat menginstalnya, dan melakukan setup.py.  Kemudian dia bekerja di satu perusahaan, di perusahaan lain, di perusahaan ketiga, tugasnya rumit dan berkembang.  Pada awalnya hanya ada file requirement.txt, kemudian saya menyadari bahwa saya perlu memperbaiki dependensi, pip-tools, file kunci muncul.  Kemudian kami mendapat Pipenv, dan kemudian Puisi. <br><br>  Berangsur-angsur semakin banyak masalah yang muncul, saya semakin tenggelam dalam kekacauan ini.  Sebagai hasilnya, saya mulai mengimplementasikan <a href="https://github.com/dephell/dephell">DepHell</a> , sebuah proyek untuk mengelola dependensi yang dapat menyelesaikan dan membacanya dalam format yang berbeda.  Sementara saya bekerja dengan semua jenis format, saya sudah cukup melihat bagian dalamnya dan sekarang saya tahu berapa banyak yang diatur di dalamnya, tetapi setiap hari saya belajar sesuatu yang baru.  Karena itu, saya dapat memberi tahu Anda banyak hal menarik tentang rasa sakit dan keputusan yang buruk. <br><br>  <b>- Nyeri selalu menarik.</b>  <b>Menurut Anda apa masalahnya sekarang di bagian Python ini?</b> <br><br>  JS memiliki direktori <code>node_modules</code> , dan setiap dependensi memiliki dependensinya sendiri yang tertumpuk di dalamnya.  Dalam Python, ini tidak terjadi.  Misalnya, paket diinstal di lingkungan yang sama, dan semua paket yang menggunakannya menggunakan versi yang sama dari paket ini.  Untuk melakukan ini, Anda harus menyelesaikan dependensi dengan benar - pilih versi paket ini yang akan memuaskan semua paket di lingkungan ini secara umum.  Tugasnya cukup non-sepele: paket saling tergantung, semuanya saling terkait, dan menyelesaikan dependensi sulit.  Praktis tidak ada resolvers di Python.  Penyelesai yang cerdik hanya ada di Puisi dan DepHell. <br><br>  Semua ini sangat rumit oleh kenyataan bahwa pypi.org sering tidak memberikan informasi tentang dependensi paket, karena informasi ini harus ditentukan oleh klien, server PyPI tidak dapat menemukannya dengan sendirinya.  Oleh karena itu, ketika PyPI mengatakan bahwa paket tersebut tidak memiliki dependensi, Anda tidak dapat mempercayainya.  Anda harus mengunduh seluruh paket, unzip dan mengurai dependensi paket dari setup.py.  Ini adalah proses yang panjang, sehingga resolver di Python tidak bisa cepat. <br><br><blockquote>  Tidak hanya ada beberapa resolvers di Python, mereka juga lambat oleh desain. </blockquote><br>  Dalam <a href="https://conf.python.ru/moscow/2020/abstracts/6254">laporan</a> saya, saya ingin memberi tahu cara kerja penyelesaian DepHell: cara membuat grafik dependensi, bagaimana grafik ini terlihat, mengapa sebagian besar artikel ilmiah terletak pada bagaimana menyelesaikan dependensi dan bekerja dengan grafik ini.  Tentu saja, ada whitepaper tentang bagaimana semua ini harus bekerja.  Orang pintar memiliki artikel yang ditulis dengan algoritma, tetapi paling sering mereka tidak bekerja untuk Python.  Oleh karena itu, saya akan menjelaskan bagaimana saya bekerja dengan resolusi ketergantungan dalam praktik di DepHell. <br><br>  <b>- Saya sering mendengar dari programmer bahwa mereka menggunakan pip, dan semuanya berfungsi dengan baik untuk mereka.</b>  <b>Apa yang mereka lakukan salah?</b> <br><br>  Mereka beruntung, mereka tidak menemukan konflik ketergantungan.  Meskipun masalah bisa muncul ketika Anda hanya menempatkan dua paket di lingkungan yang bersih.  Baru-baru ini ada rilis paket coverage 5.0, dan jika Anda hanya menentukan <code>pip install pytest-cov coveralls</code> , pip akan berurutan dan untuk paket pertama akan memilih versi terbaru dari coverage, yaitu 5.0.  Prinsip <b>pertandingan pertama menang</b> bekerja di pip, jadi meskipun versi tidak kompatibel dengan paket kedua, itu akan sudah diperbaiki untuk paket pertama.  Seringkali pendekatan ini berhasil, tetapi tidak selalu. <br><br>  Selain itu, ada pertanyaan dengan lingkungan yang dapat direproduksi.  Karena pip selalu menempatkan versi terbaru, versi di lingkungan lokal dan produksi mungkin berbeda.  Untuk mengatasi masalah ini, sudah lazim untuk memperbaiki dependensi.  Dan ketika dependensi sudah diperbaiki, versi spesifik yang harus dipasang oleh pip ditunjukkan, maka pip sudah berfungsi dengan baik.  Pip tidak memiliki resolver, tetapi itu terjadi ketika orang lain menyelesaikan dependensi untuk itu, seperti DepHell atau Puisi. <br><br>  <b>- Mengapa topik ini sekarang mendapatkan relevansi seperti itu, seperti yang Anda pikirkan?</b>  <b>Mengapa tidak ada yang terjadi sebelumnya, tetapi sekarang hilang, dan bahkan ke arah yang berbeda?</b> <br><br>  Pertama, ekosistem Python tumbuh.  Ada lebih banyak paket, mereka harus diinstal lebih banyak, dan lebih banyak masalah muncul.  Kedua, masalah dengan format file telah ada sejak lama dan telah dibahas sejak lama. <br><br>  Setup.py umumnya tidak dapat diurai, itu hanya dapat dieksekusi.  Jika kita ingin, misalnya, untuk menulis server di Go untuk dengan cepat mendistribusikan paket untuk Python, maka kita tidak bisa hanya mengambil dan membaca setup.py, karena itu adalah file yang dapat dieksekusi.  Oleh karena itu, untuk menjalankannya, Anda memerlukan Python dan lingkungan yang lengkap, dan seringkali juga agar seluruh proyek berada di dekatnya, dan beberapa dependensi tertentu diinstal.  Selain semua kesulitan ini, menjalankan setup.py dapat berbahaya, karena beberapa kode lain akan dieksekusi di komputer Anda.  Bahkan, menakutkan untuk mengeksekusi kode dari bawah pengguna saat ini, karena jika, misalnya, ia menerima kunci SSH pribadi saya dan mengirimkannya ke suatu tempat, itu akan menjadi tragedi besar. <br><br>  Opsi kedua untuk mendefinisikan dependensi, yang telah lama ada dan semua orang bekerja dengannya, adalah requirement.txt.  Hampir tidak mungkin mengurai dengan cara yang sama.  Pip bisa, tetapi itu sangat, sangat sulit: fungsi yang memanggil fungsi, iterator, semuanya dicampur.  Selain itu, pip dapat membaca beberapa kuncinya dari requirement.txt, misalnya, indeks untuk mengunduh dapat ditentukan.  Tetapi ini tidak bekerja dengan semua kunci. <br><br>  Jadi, untuk mem-parse requirement.txt, Anda harus menggunakan pip atau solusi pihak ketiga.  Semua solusi pihak ketiga pada dasarnya adalah garpu dan menggunakan semacam asumsi tentang file.  Tidak setiap file rumit requirement.txt yang dapat dibaca oleh pip akan dapat membaca garpu ini. <br><br>  Pip sendiri tidak dimaksudkan untuk digunakan sebagai perpustakaan.  Ini adalah alat eksklusif CLI yang hanya dapat digunakan dari konsol.  Semua kode sumber pip disembunyikan di belakang <code>_internal</code> , dan pengembang langsung mengatakan: "Jangan gunakan ini!".  Dan setiap rilis merusak kompatibilitas ke belakang.  Mereka dengan jujur â€‹â€‹tidak menjamin kompatibilitas dan dapat mengubah apa pun kapan saja.  Dan inilah yang terjadi - setiap kali rilis baru datang dengan pip, saya mempelajarinya dari CI yang rusak di DepHell. <br><br>  <b>- Bagaimana dengan bahasa lain?</b>  <b>Apakah sama buruknya di sana, atau semua masalah ini diselesaikan di suatu tempat?</b> <br><br>  <b>Guido van Rossum baru</b> - <b>baru ini</b> dianugerahi Dijkstra Prize.  Saya menghadiri kuliahnya dan bertanya kepadanya tentang dependensi Python.  Guido mengatakan bahwa kecanduan dalam semua bahasa adalah kekacauan, ia berusaha untuk tidak masuk ke sana dan mempercayai komunitas untuk menyelesaikan masalah ini. <br><br>  Dengan demikian, dalam Python, bekerja dengan dependensi secara bertahap diselenggarakan oleh komunitas.  Solusi baru sedang muncul.  Setelah Distutils dibangun dengan Python, maka orang-orang menyadari bahwa ia memiliki banyak masalah, add-on Setuptools.  <code>easy_Install</code> kemudian dikembangkan untuk menginstal paket, tetapi juga memiliki masalah.  Untuk mengatasinya, buat pip.  Sekarang pip memiliki banyak masalah.  Sumbernya terus berubah, tidak ada arsitektur, tidak ada antarmuka sama sekali. <br><br>  Komunitas sedang mencoba membuat sesuatu.  Misalnya, ada diskusi panjang tentang masalah yang disebut persyaratan 2.0 tentang bagaimana membuat persyaratan dapat dipahami baik oleh orang-orang (di sini adalah versi, di sini ada spidol), dan secara terprogram dari bahasa lain. <br><br><blockquote>  Mereka membuat Pipfile, tetapi karena pip sangat membingungkan, mereka tidak dapat menambahkan dukungan Pipfile ke dalamnya. </blockquote><br>  Pengembang ingin melakukan ini, tentu saja.  Kemungkinan besar, suatu hari nanti mereka akan dapat, tetapi sejauh ini pip tidak dapat mendukung Pipfile.  Oleh karena itu, kami membuat pipenv untuk bekerja dengan Pipfile dan lingkungan virtual, beberapa pembungkus lain dengan lingkungan.  Namun dalam pipenv, semuanya tercampur dan membingungkan. <br><br>  Untuk bahasa lain, saya suka bagaimana manajemen ketergantungan diterapkan di Go.  Sebelumnya, tidak ada versi di dalamnya, ada <code>go get</code> , di mana Anda menunjukkan dari repositori mana paket untuk diunduh.  Dari sudut pandang pemula, ini nyaman: Anda cukup menulis <code>go get</code> dan paket sudah ada di sistem.  Dan ketika Anda mulai bekerja dengan Python, seluruh tumpukan semuanya runtuh: beberapa versi, PyPI, pip, requirement.txt, setup.py, sekarang juga Pipfile, Puisi, <code>__pymodules__</code> , dll. <br><br>  Ketika Python berevolusi secara bertahap dan dengan bantuan komunitas, warisan menumpuk di ekosistem.  Go baru saja <code>go get</code> , tetapi sekali lagi muncul masalah bahwa ketergantungan perlu diperbaiki sehingga, khususnya, lingkungan dapat direproduksi. <br><br>  Lingkungan yang dapat dimainkan dapat dibuat menggunakan wadah buruh pelabuhan dengan semua dependensi diinstal.  Tetapi kadang-kadang Anda perlu memperbarui dependensi individual.  Misalnya, kami mungkin tidak siap memperbarui semuanya, karena proyek tidak memiliki cukup tes untuk membuktikan bahwa setelah pembaruan semuanya masih berfungsi.  Tetapi ketergantungan tertentu mungkin perlu diperbarui, karena, katakanlah, kerentanan ditemukan di dalamnya.  Untuk melakukan ini, lebih baik tidak memiliki gambar buruh pelabuhan, tetapi file yang mengatakan: "Instal versi spesifik dari paket tertentu." <br><br>  Tidak ada yang seperti itu di Go, dan vendorisasi muncul: semua dependensi baru saja diambil dan dimasukkan ke dalam satu direktori.  Ini adalah solusi kotor, mirip dengan <code>node_modules</code> , yang di Go telah diimplementasikan untuk beberapa waktu menggunakan solusi pihak ketiga.  Dalam Python, pendekatan ini juga digunakan, misalnya, pip memiliki direktori <code>vendor</code> .  Ketika Anda menginstal pip, dependensi tidak dibuat, dan Anda mungkin berpikir bahwa semuanya sangat keren dan tidak ada dependensi sama sekali, tetapi sebenarnya semuanya ada di dalam <code>vendor</code> . <br><br>  Sekitar setahun yang lalu go.mod (Go Modul) muncul di Go.  Ini adalah alat bawaan yang baru, tetapi <code>go get</code> juga didukung.  Proyek ini berisi dua file: <br><br><ul><li>  satu menggambarkan ketergantungan dengan mana proyek bekerja secara langsung; </li><li>  yang lainnya adalah file kunci, yang menjelaskan secara mutlak semua dependensi dan versi spesifiknya. </li></ul><br>  Ini adalah solusi terpusat yang keren. <br><br>  Yang penting, mereka bersikeras bahwa hal-hal tertentu harus terlihat dengan cara tertentu.  Misalnya, di Go, versi tersebut harus versi semantik. <br><br>  Python juga memiliki spesifikasi tentang bagaimana versi akan terlihat.  Untuk ini, ada PEP 440. Tapi, pertama, spesifikasinya sangat rumit: tidak hanya ada tiga komponen versi (angka), tetapi juga pra-rilis, pasca-rilis, dan era (ketika cara perubahan versi).  Kedua, PEP 440 tidak diterima dengan segera, mereka juga datang secara bertahap, oleh karena itu versi lawas didukung, yang berarti bahwa apa pun dapat digunakan sebagai versi - setiap baris seperti â€œHello world!â€. <br><br>  <b>- Anda mengatakan bahwa komunitas mengembangkan bahasa secara bertahap, sehingga ada sejumlah besar solusi.</b>  <b>Tapi mengapa tidak membuang semua sampah ini?</b>  <b>Mengapa tidak membuang Distutils, meninggalkan yang lama dan tidak perlu yang tidak ada yang menggunakan, dan sebaliknya secara aktif memperkenalkan praktik dan alat baru?</b> <br><br>  Untuk mempertahankan semua ini masuk akal, sehingga Anda masih dapat menginstal paket lama.  Tidak mungkin untuk bersikeras bahwa itu perlu dilakukan, dan bukan sebaliknya, karena keputusan dibuat oleh masyarakat.  Tidak ada pengembang Core Python yang datang dan berkata: "Itu saja, kami melakukan semuanya sekarang, dan tidak ada paku." <br><br>  Go memiliki semua yang Anda butuhkan untuk bekerja dengan dependensi segera.  Dengan Python, Anda perlu menginstal ulang semuanya dari luar, dan Anda masih perlu memahami apa sebenarnya.  Paling sering, pip sudah cukup, tetapi sekarang opsi lain muncul. <br><br>  Di situs dengan rekomendasi paket resmi dari Python Packaging Authority, grup yang membuat pip, pipenv, PyPI, ditulis menggunakan pipenv.  Dengan pipenv adalah cerita lain.  Pertama, memiliki resolusi yang buruk.  Kedua, tidak ada rilis untuk waktu yang sangat lama dan komunitas sudah menunggu pembuatnya untuk jujur â€‹â€‹mengakui bahwa proyek ini sudah mati.  Masalah ketiga dengan pipenv adalah ia hanya cocok untuk proyek, tetapi tidak untuk paket: Anda bisa menentukan dependensi proyek di pipenv, tetapi Anda tidak bisa menentukan nama, versinya, dan, karenanya, memasukkannya ke dalam paket untuk diunduh di PyPI.  Ternyata mengikuti rekomendasi dari Python Packaging Authority dan menggunakan pipenv masih belum cukup untuk mengetahuinya. <br><br>  Puisi berusaha menjadi revolusioner.  Ini pada dasarnya tidak menghasilkan file setup.py, yang akan berguna untuk kompatibilitas mundur, karena Puisi ingin menjadi format baru dan satu-satunya untuk semuanya.  Dia tahu cara mengumpulkan paket, dan dia memiliki file kunci, yang diperlukan untuk proyek.  Meskipun demikian, Puisi memiliki banyak hal aneh, banyak fitur yang akrab tidak didukung. <br><br>  <b>- Menurut Anda apa masa depan ekosistem dalam hal bekerja dengan ketergantungan?</b>  <b>Prediksi Anda.</b> <br><br>  Semuanya kurang lebih semakin baik.  Sebagai contoh, saya melihat lowongan di pip, dan seorang pengembang yang mengaturnya dijanjikan banyak uang.  Mungkin pip akan menjadi solusi yang lebih universal.  Tetapi Anda membutuhkan seseorang untuk menganggapnya serius: datang dan katakan bahwa kami melakukannya dengan cara ini, sekarang kami mengikuti beberapa PEP yang lebih ketat, dan akan mendesaknya (karena PEP hanyalah sebuah rekomendasi yang tidak ada orang yang benar-benar melakukannya. tidak diharuskan untuk mengikuti). <br><br>  Sebagai contoh, kami memiliki cerita seperti itu: versi PyYAML tertentu dikunci dalam file kunci.  Suatu hari tes pada lulus CI, kami menyebarkan ke produksi, dan semuanya jatuh di sana, karena versi PyYAML tidak ditemukan.  Masalahnya adalah bahwa versi yang terkunci telah dihapus dari pypi.org.  Semua orang marah, memperbarui file kunci, entah bagaimana selamat, tetapi sedimen tetap ada. <br><br>  Belum lama ini, PEP 592 muncul, sudah diadopsi dan dikelola dalam pip, di mana rilis menarik menarik muncul.  Yank berarti bahwa rilis tersebut belum sepenuhnya dihapus dari pypi.org - itu disembunyikan.  Artinya, jika Anda menentukan bahwa Anda perlu, misalnya, versi PyYAML lebih besar dari 3.0, maka pip akan melewati rilis yang ditarik dan menginstal yang terbaru tersedia.  Tetapi jika versi tertentu ditunjukkan dalam file kunci, dan versi ini adalah menarik, maka pip akan menginstalnya juga.  Dengan demikian, mengunci file dan menyebarkan tidak akan rusak, tetapi, jika mungkin, versi lama tidak akan digunakan. <br><br>  Hal menarik kedua adalah PEP untuk <code>__pymodules__</code> .  Ini adalah lingkungan virtual yang ringan: Anda membuka direktori proyek, menulis <code>pip install</code> PyYAML, dan PyYAML diinstal bukan secara global, tetapi dalam direktori <code>__pymodules__</code> .  Ketika Python dimulai di direktori ini, PyYAML tidak diimpor secara global, tetapi dari direktori ini. <br><br>  Saya menyebutnya lingkungan virtual minimal, karena ada sedikit isolasi.  Misalnya, tidak ada akses ke file biner.  Ketika lingkungan virtual dengan pytest diinstal diaktifkan, itu dapat digunakan dari konsol: cukup tulis pytest dan lakukan sesuatu.  Dengan <code>__pymodules__</code> akan tersedia untuk impor, tetapi bukan binari, karena mereka tidak akan benar-benar diinstal. <br><br>  PEP ini dirancang untuk memudahkan pemula.  Sehingga mereka tidak perlu berurusan dengan semua seluk-beluk lingkungan virtual, tetapi cukup instal semua yang Anda butuhkan dalam <code>__pymodules__</code> melalui pip install. <br><br>  <b>- Nah, masa depan dalam ramalan Anda lebih cerah dari sekarang.</b> <br><br>  Ya, tetapi seperti yang saya katakan, jika tidak ada yang datang dan mengatakan bahwa kami sedang mengulang dan mencoba membuang warisan, maka masalahnya akan tetap ada.  Sekarang kami mengumpulkan dan mengumpulkan alat-alat, dan tidak mungkin untuk benar-benar menyingkirkan salah satu dari mereka dalam waktu dekat. <br><br>  <b>- Apa pendapat Anda, mengapa tidak ada pengembang yang dapat memperbarui dependensi Hampir di mana saja - baik di perusahaan maupun di sumber terbuka - proses bekerja dengan rilis keamanan, pada prinsipnya, dengan rilis kecil atau besar baru, telah dibangun.</b>  <b>Di mana Anda melihat masalah di sini?</b> <br><br>  Paling tidak, ketika Anda ingin memperbarui dependensi, menakutkan untuk memperbarui semua dependensi, karena itu bukan fakta bahwa meskipun Anda lulus tes, semuanya akan berfungsi.  Sebagai contoh, seringkali situasi ini muncul dengan Seledri, karena Seledri tidak dapat sepenuhnya diuji dalam tes.  Anda dapat mengunci sesuatu, menyederhanakan sesuatu, tetapi kenyataan bahwa para pekerja sedang berlari tidak dapat diverifikasi. <br><br>  Go work dengan tes diimplementasikan dengan baik, bahkan dalam tutorial Go Modul ditulis tentang cara memperbarui dependensi: Anda memperbarui dependensi tertentu dan menjalankan tes.  Selain itu, tes tidak hanya berjalan pada Anda, tetapi juga ketergantungan ini. <br><br>  Aspek yang menarik masih layak disebut: haruskah tes dilakukan dalam paket dengan Python?  Saat Anda mengunduh paket dari pypi.org, haruskah ada tes?  Secara teori, mereka harus, dan bahkan memiliki mekanisme untuk menjalankannya: di setup.py Anda dapat menentukan cara menjalankan tes, dependensi apa yang mereka miliki. <br><br>  Tapi, pertama, banyak orang tidak tahu cara menjalankannya dan tidak menjalankan tes yang tergantung.  Karena itu, seringkali tidak diperlukan.  Kedua, seringkali tes ini memiliki perlengkapan yang sangat sulit, dan oleh karena itu untuk memasukkan tes dalam paket berarti membuat paket 6-10 kali lebih besar. <br><br>  Akan sangat bagus untuk dapat mengunduh paket dengan tes dan tanpa tes.  Tapi sekarang tidak ada kemungkinan seperti itu, jadi tes sering tidak dijumlahkan di dalam paket.  Ada kekacauan, dan saya bahkan tidak tahu apakah mungkin untuk menjalankan tes dependensi ini ketika memperbarui dependensi. <br><br>  Aspek ini tampaknya diabaikan.  Tetapi dalam beberapa bahasa lain, khususnya, Go dianggap sebagai praktik yang baik, memperbarui paket di lingkungan, segera menjalankan tes untuk memastikan bahwa paket ini berfungsi dengan baik di lingkungan ini. <br><br>  <b>- Mengapa, menurut Anda, dengan Python, alat untuk versi semantik otomatis tidak populer?</b> <br><br>  Saya pikir salah satu masalahnya adalah bahwa versinya dapat dijelaskan di banyak tempat.  Paling sering ada tiga di antaranya: format deskripsi metadata proyek (pypi.org, poety, setup.py, dll.), Di dalam proyek itu sendiri dan dalam dokumentasi.  Memutakhirkan versi di tiga tempat tidak terlalu sulit, tetapi mudah dilupakan. <br><br>  DepHell memiliki tim untuk peningkatan versi.  DepHell      , ,        .    semantic version, compatible version  ..  <a href="https://dephell.readthedocs.io/cmd-project-bump.html"></a> ,    ,    . <br><br>      Flit. Flit â€”          ,      .    : <code>init</code> , <code>build</code> , <code>publish</code>  <code>install</code> .     ,  ,   PyPI     â€”   .  Flit      ,        .       docstring  .       ,    . <br><br> DepHell     Flit   .        description,   ,   ,       . <br><br><blockquote>  ,      . </blockquote><br>  DepHell      <code>import</code> ,   ,   , ,        .           ,    ,    . <br><br><blockquote>    ,      <a href="https://conf.python.ru/moscow/2020">Moscow Python Conf++</a> 27 .  DepHell    backend, web,    , AI/ML, , DevOps,  , IoT, infosec      . , <a href="http://conf.ontico.ru/conference/join/mpc2020.html"> </a> ,   Moscow Python Conf++. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483920/">https://habr.com/ru/post/id483920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483910/index.html">Teori Informasi Visual (Bagian 1)</a></li>
<li><a href="../id483912/index.html">Apa yang baru dari YouTrack di tahun 2020?</a></li>
<li><a href="../id483914/index.html">Kami mengundang Anda ke DINS JavaScript EVENING: kami berbicara tentang desain API dan menyelesaikan masalah menggunakan tipe data aljabar</a></li>
<li><a href="../id483916/index.html">DJI belum dapat menambal aplikasi DJI Fly untuk Android 10 selama sebulan sekarang</a></li>
<li><a href="../id483918/index.html">Pelatihan Perusahaan: Pemimpin Mengajar Pemimpin</a></li>
<li><a href="../id483922/index.html">Rumah pintar di atas roda ... Alice</a></li>
<li><a href="../id483926/index.html">Three.js dan geometri</a></li>
<li><a href="../id483930/index.html">6 proyek pengembangan web GitHub patut dilihat</a></li>
<li><a href="../id483934/index.html">Izin file Linux</a></li>
<li><a href="../id483936/index.html">Kuliah Pengembangan Game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>