<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦗 🕍 👨🏻‍✈️ Software-Testmethoden 🍞 👨‍👨‍👦‍👦 💯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Nächste Woche starten wir einen neuen Thread zum Kurs "Automation Web Testing" . Dies wird das Thema des heutigen Materials sein. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Software-Testmethoden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443418/"> Hallo allerseits!  Nächste Woche starten wir einen neuen Thread zum Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Automation Web Testing"</a> .  Dies wird das Thema des heutigen Materials sein. <br><br>  In diesem Artikel werden verschiedene Methoden zum Testen von Software beschrieben, z. B. Komponententests, Integrationstests, Funktionstests, Abnahmetests usw. <br><br><img src="https://habrastorage.org/webt/tc/nf/kc/tcnfkcczhmixn92gpm04au1rgdo.png"><br><br>  Es gibt viele verschiedene Arten von Tests, die Sie anwenden können, um sicherzustellen, dass Änderungen an Ihrem Code per Skript ausgeführt werden.  Nicht alle Testarten sind identisch, obwohl wir hier untersuchen, wie sich die Haupttestpraktiken voneinander unterscheiden. <br><br>  <b>Testen: manuell oder automatisiert?</b> <br><br>  Zuerst müssen Sie die Unterschiede zwischen manuellen und automatisierten Tests verstehen.  Manuelle Tests werden direkt von einer Person durchgeführt, die auf Schaltflächen in der Anwendung klickt oder mit Software oder API mit den erforderlichen Tools interagiert.  Dies ist ziemlich teuer, da der Tester die Entwicklungsumgebung installieren und die Tests manuell ausführen muss.  Es besteht die Wahrscheinlichkeit eines Fehlers aufgrund eines menschlichen Faktors, wie z. B. eines Tippfehlers oder des Überspringens von Schritten in einem Testfall. <a name="habracut"></a><br><br>  Automatisierte Tests werden dagegen von einem Computer ausgeführt, der ein zuvor geschriebenes Testskript ausführt.  Solche Tests können je nach Komplexität sehr unterschiedlich sein, vom Testen einer einzelnen Methode in einer Klasse bis zum Ausarbeiten einer Folge komplexer Aktionen in einer Benutzeroberfläche, um sicherzustellen, dass sie ordnungsgemäß funktioniert.  Diese Methode wird als zuverlässiger angesehen, ihre Leistung hängt jedoch davon ab, wie gut das zu testende Skript geschrieben wurde. <br><br>  Automatisierte Tests sind eine Schlüsselkomponente für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kontinuierliche Integration</a> und die kontinuierliche Bereitstellung sowie eine gute Möglichkeit, Ihren QS-Prozess zu skalieren und Ihrer Anwendung neue Funktionen hinzuzufügen.  Manuelle Tests haben jedoch immer noch ihren eigenen Wert.  Daher werden wir in dem Artikel definitiv über Erkundungstests sprechen. <br><br>  <b>Verschiedene Arten von Tests</b> <br><br>  <i><b>Unit-Tests</b></i> <br><br>  Unit-Tests gelten als niedrig, nahe am Quellcode Ihrer Anwendung.  Sie zielen darauf ab, einzelne Methoden und Funktionen innerhalb von Klassen zu testen und die von Ihrem Programm verwendeten Komponenten und Module zu testen.  Unit-Tests erfordern im Allgemeinen keine besonderen Automatisierungskosten und können extrem schnell funktionieren, wenn Sie einen Continuous Integration Server verwenden. <br><br>  <i><b>Integrationstests</b></i> <br><br>  Integrationstests prüfen, ob die von Ihrer Anwendung verwendeten Dienste und Module gut zusammenarbeiten.  Sie können beispielsweise die Integration in eine Datenbank testen oder sicherstellen, dass Microservices korrekt miteinander interagieren.  Diese Tests sind kostenintensiver, da viele Teile der Anwendung gleichzeitig ausgeführt werden müssen. <br><br>  <i><b>Funktionstests</b></i> <br><br>  Funktionstests basieren auf den Geschäftsanforderungen für die Anwendung.  Sie überprüfen die Ausgabe erst, nachdem die Aktion ausgeführt wurde, und überprüfen nicht die Zwischenzustände des Systems während der Wiedergabe der Aktion. <br><br>  Manchmal gibt es Widersprüche zwischen Integrationstests und Funktionstests  Beide fordern mehrere Komponenten an, die miteinander interagieren.  Der Unterschied besteht darin, dass Integrationstests einfach sicherstellen können, dass auf die Datenbank zugegriffen werden kann, während ein Funktionstest einen bestimmten Wert aus der Datenbank abrufen möchte, um eine der Anforderungen für das Endprodukt zu überprüfen. <br><br>  <i><b>End-to-End-Tests</b></i> <br><br>  End-to-End-Tests simulieren das Benutzerverhalten bei der Interaktion mit Software.  Es wird überprüft, wie genau verschiedene Benutzer dem beabsichtigten Szenario der Anwendung folgen. Dies kann recht einfach sein, z. B. das Laden einer Webseite oder das Aufrufen einer Website oder in einem komplizierteren Fall das Bestätigen einer E-Mail-Adresse, Online-Zahlungen usw. <br><br>  End-to-End-Tests sind äußerst nützlich, ihre Herstellung ist jedoch teuer und kann schwierig zu automatisieren sein.  Es werden mehrere Querschnittstests empfohlen, die sich jedoch eher auf Tests auf niedriger Ebene (Einheits- und Integrationstests) stützen, um wichtige Änderungen schnell erkennen zu können. <br><br>  <i><b>Abnahmetests</b></i> <br><br>  Abnahmetests sind formale Tests, die durchgeführt werden, um sicherzustellen, dass das System die Geschäftsanforderungen erfüllt.  Sie erfordern, dass die Anwendung ausgeführt wird und Benutzeraktionen nachahmt.  Akzeptanztests können noch weiter gehen und die Systemleistung messen und kürzlich vorgenommene Änderungen ablehnen, wenn die endgültigen Entwicklungsziele nicht erreicht wurden. <br><br>  <i><b>Leistungstests</b></i> <br><br>  Leistungstests testen das Verhalten eines Systems unter erheblicher Belastung.  Diese Tests sind nicht funktionsfähig und können viele Formen annehmen, um die Zuverlässigkeit, Stabilität und Verfügbarkeit der Plattform zu testen.  Beispielsweise kann es die Antwortzeit überwachen, wenn eine große Anzahl von Anforderungen ausgeführt wird, oder beobachten, wie sich das System bei der Interaktion mit Big Data verhält. <br><br>  Leistungstests sind von Natur aus teuer, können Ihnen jedoch helfen, zu verstehen, welche externen Faktoren Ihr System beeinträchtigen können. <br><br>  <i><b>Rauchprüfung</b></i> <br><br>  Rauchtests sind grundlegende Tests, die die grundlegende Funktionalität einer Anwendung testen.  Sie arbeiten schnell genug und ihr Ziel ist es, klar zu machen, dass die Hauptfunktionen des Systems so funktionieren, wie sie sollten, und nicht mehr.  Solche Tests zielen darauf ab, offensichtliche Fehler zu identifizieren. <br><br>  Rauchtests können unmittelbar nach dem Erstellen eines neuen Builds hilfreich sein, um zu überprüfen, ob Sie teurere Tests ausführen können, oder unmittelbar nach der Bereitstellung, um sicherzustellen, dass die Anwendung in der neuen Umgebung ordnungsgemäß funktioniert. <br><br>  <b>So automatisieren Sie Tests</b> <br><br>  Ein Tester kann alle oben genannten Tests manuell durchführen, dies ist jedoch äußerst kostspielig und unproduktiv.  Weil Menschen nur begrenzt in der Lage sind, eine große Anzahl sich wiederholender Aktionen auszuführen, während sie dennoch zuverlässig testen.  Das Gerät kann jedoch problemlos dieselben Aktionen reproduzieren und beispielsweise überprüfen, ob die Kombination aus Benutzername und Kennwort zum hundertsten Mal ohne Beschwerden funktioniert. <br><br>  Um das Testen zu automatisieren, müssen Sie sie zunächst in einigen Programmiersprachen mit einem für Ihre Anwendung geeigneten Testframework schreiben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHPUnit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mocha</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSpec</a> sind Beispiele für Test-Frameworks, die Sie für PHP, Javascript bzw. Ruby verwenden können.  Sie haben viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen</a> für jede Sprache, daher sollten Sie selbst ein wenig recherchieren und sich mit den Entwicklergemeinschaften beraten, um herauszufinden, welches Framework für Sie am besten geeignet ist. <br><br>  Wenn Ihre Tests mithilfe von Skripten vom Terminal ausgeführt werden können, können Sie sie mithilfe eines kontinuierlichen Integrationsservers im Bamboo-Stil oder des Bitbucket Pipelines-Cloud-Servers automatisieren.  Diese Tools überwachen Ihre Repositorys und führen Testsuiten aus, sobald neue Änderungen in das Haupt-Repository übernommen werden. <br><br><img src="https://habrastorage.org/webt/ux/1g/ad/ux1gadoiynbuaj_s6k_l_oos1ow.jpeg"><br><br>  Wenn Sie mit dem Testen noch nicht vertraut sind, lesen Sie unseren Leitfaden zur kontinuierlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration</a> , um Ihre erste Testsuite zu erstellen. <br><br>  <b>Forschungstests</b> <br><br>  Je mehr Funktionen und Verbesserungen zu Ihrem Code hinzugefügt werden, desto größer ist der Testbedarf, da Sie in jeder Phase sicherstellen müssen, dass das System ordnungsgemäß funktioniert.  Außerdem wird es jedes Mal benötigt, wenn Sie einen Fehler beheben, da es nicht überflüssig wäre, sicherzustellen, dass es nach mehreren Releases nicht wieder zurückkehrt.  Automatisierung ist der Schlüssel, um dies zu ermöglichen.  Das Schreiben von Tests früher oder später wird Teil Ihrer Entwicklerpraxis. <br><br>  Die Frage ist, ob in diesem Fall überhaupt manuelle Tests durchgeführt werden müssen.  Die kurze Antwort lautet "Ja" und sollte sich auf sogenannte Erkundungstests konzentrieren, mit deren Hilfe nicht offensichtliche Fehler identifiziert werden können. <br><br>  Eine Forschungstestsitzung sollte zwei Stunden nicht überschreiten und einen klar definierten Umfang haben, damit sich die Tester auf einen bestimmten Bereich der Software konzentrieren können.  Nachdem alle Tester über die Grenzen des Tests informiert wurden, liegt es in ihrem Ermessen, welche Maßnahmen sie ergreifen werden, um das Verhalten des Systems zu überprüfen.  Solche Tests sind von Natur aus teuer, aber sehr nützlich, um Probleme mit der Benutzeroberfläche zu identifizieren oder den Zustand komplexer Workflows für Benutzer zu überprüfen.  Es ist wichtig, solche Tests immer dann durchzuführen, wenn der Anwendung eine radikal neue Funktion hinzugefügt wird, um zu verstehen, wie sie sich unter Grenzbedingungen verhält. <br><br>  <b>Testhinweis</b> <br><br>  Bevor ich diesen Artikel beende, möchte ich über den Zweck des Testens sprechen.  Einerseits ist es sehr wichtig sicherzustellen, dass Benutzer Ihre Anwendung verwenden können ("Ich kann mich nicht anmelden", "Ich kann keine Daten speichern" usw.), andererseits ist es ebenso wichtig, Ihr System zu überprüfen Bricht nicht ab, wenn falsche Daten oder unerwartete Aktionen eingegeben werden.  Sie müssen vorhersehen, was passieren wird, wenn ein Benutzer einen Tippfehler macht, versucht, ein unvollständiges Formular zu speichern oder die falsche API verwendet.  Sie müssen überprüfen, ob einer der Benutzer die Daten leicht gefährden und Zugriff auf eine bestimmte Ressource erhalten kann, auf die er keinen Zugriff haben sollte.  Eine gute Reihe von Tests sollte versuchen, Ihre Anwendung zu beschädigen und die Grenzen ihrer Funktionen zu verstehen. <br><br>  Und schließlich sind Tests auch Code!  Vergessen Sie sie daher nicht bei der Codeüberprüfung, da sie möglicherweise der letzte Schritt vor der Freigabe des Produkts für den Verbrauchermarkt sind. <br><br>  Gemäß der etablierten Tradition warten wir auf Ihre Kommentare und laden alle zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen Tür ein</a> , der am 18. März von unserem Lehrer, dem führenden Testautomatisierungsingenieur der Gruppe IB, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikhail Samoilov</a> , abgehalten wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443418/">https://habr.com/ru/post/de443418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443406/index.html">Top 20 Fehler bei der Arbeit mit Multithreading in C ++ und Möglichkeiten, sie zu vermeiden</a></li>
<li><a href="../de443408/index.html">Photonen, Quanten und Fock-Zustand: Manipulationen auf Quantenebene mit einem Hochfrequenzresonator</a></li>
<li><a href="../de443412/index.html">Warum Programmierer weiterhin ausführliches Java verwenden, obwohl es prägnantes Python gibt</a></li>
<li><a href="../de443414/index.html">Wegweiser: Wenn Haltepunkte nicht ausreichen</a></li>
<li><a href="../de443416/index.html">Winnti: ein Angriff auf Lieferketten - asiatische Spieleentwickler stehen an vorderster Front</a></li>
<li><a href="../de443422/index.html">Flexible Datenspeicherung in MySQL (JSON)</a></li>
<li><a href="../de443424/index.html">Umschreiben des Testfalls für das Junior-Frontend auf TypeScript und React-Hooks</a></li>
<li><a href="../de443426/index.html">Schwarze Markierung - wie OpenShift mit SELinux vor Container-Schwachstellen schützt</a></li>
<li><a href="../de443428/index.html">Palmer Lucky, der "Vater" von Oculus Rift, entwickelt ein virtuelles Schlachtfeldsystem für das Pentagon</a></li>
<li><a href="../de443430/index.html">Warum ist es schlecht, wenn das Internet alles über Sie weiß?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>