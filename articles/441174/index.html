<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêß üèáüèæ üë©üèª‚Äç‚öïÔ∏è OOP est√° muerto, larga vida OOP üíû üóúÔ∏è üë®üèø‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fuentes de inspiraci√≥n 
 Esta publicaci√≥n surgi√≥ gracias a una publicaci√≥n reciente de Aras Prantskevichus sobre un informe destinado a programadores ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP est√° muerto, larga vida OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="imagen"></div><br><h1>  Fuentes de inspiraci√≥n </h1><br>  Esta publicaci√≥n surgi√≥ gracias a una publicaci√≥n reciente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Aras Prantskevichus</a> sobre un informe destinado a programadores junior.  Habla sobre c√≥mo adaptarse a las nuevas arquitecturas ECS.  Aras sigue el patr√≥n habitual ( <em>explicaci√≥n a continuaci√≥n</em> ): muestra ejemplos del terrible c√≥digo OOP y luego demuestra que el modelo relacional ( <em>pero lo llama "ECS" en lugar de relacional</em> ) es una gran alternativa.  De ninguna manera critico a Aras, ¬°soy un gran admirador de su trabajo y lo elogio por su excelente presentaci√≥n!  Eleg√≠ su presentaci√≥n en lugar de cientos de otras publicaciones de ECS de Internet porque hizo un esfuerzo adicional y public√≥ un repositorio git para estudiar en paralelo con la presentaci√≥n.  Contiene un peque√±o "juego" simple, usado como un ejemplo de la selecci√≥n de diferentes soluciones arquitect√≥nicas.  Este peque√±o proyecto me permiti√≥ demostrar mis comentarios sobre un material espec√≠fico, ¬°as√≠ que gracias, Aras! <br><br>  Las diapositivas de Aras est√°n disponibles aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> , y el c√≥digo est√° en github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  No analizar√© (¬øtodav√≠a?) Analizar la arquitectura ECS resultante de este informe, pero me centrar√© en el c√≥digo de "POO malo" (similar al truco relleno) desde el principio.  Mostrar√© c√≥mo se ver√≠a realmente si todas las violaciones de los principios de OOD (dise√±o orientado a objetos, dise√±o orientado a objetos) se corrigieran correctamente. <br><br>  <strong>Spoiler: la eliminaci√≥n de todas las violaciones de OOD conduce a mejoras de rendimiento similares a las conversiones de Aras a ECS, ¬°tambi√©n usa menos RAM y requiere menos l√≠neas de c√≥digo que la versi√≥n ECS!</strong> <br><br>  <em>TL; DR: Antes de concluir que OOP es una mierda y unidades ECS, haga una pausa y examine OOD (para saber c√≥mo usar OOP correctamente), y tambi√©n comprenda el modelo relacional (para saber c√≥mo aplicar correctamente ECS).</em> <br><a name="habracut"></a><br>  He participado en muchas discusiones sobre ECS en el foro durante mucho tiempo, en parte porque no creo que este modelo merezca existir como un t√©rmino separado ( <em>spoiler: esta es solo una versi√≥n ad-hoc del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">modelo relacional</a></em> ), pero tambi√©n porque Casi <em>todas las</em> publicaciones, presentaciones o art√≠culos que promueven un patr√≥n ECS siguen la siguiente estructura: <br><br><ol><li>  Muestre un ejemplo de c√≥digo OOP terrible, cuya implementaci√≥n tiene fallas terribles debido al uso excesivo de la herencia (lo que significa que esta implementaci√≥n viola muchos principios de OOD). <br></li><li>  Para mostrar que la composici√≥n es una mejor soluci√≥n que la herencia (y sin mencionar que OOD realmente nos da la misma lecci√≥n). <br></li><li>  Demuestre que el modelo relacional es ideal para juegos (pero ll√°melo "ECS"). </li></ol><br>  Tal estructura me enfurece porque: <strong>(A)</strong> este es un truco "relleno" ... que compara lo suave con lo c√°lido (c√≥digo incorrecto y buen c√≥digo) ... y esto es deshonesto, incluso si se hace de manera no intencional y no se requiere que demuestre que la nueva arquitectura es buena;  y, lo que es m√°s importante: <strong>(B)</strong> tiene un efecto secundario: este enfoque suprime el conocimiento y desanima involuntariamente a los lectores del conocimiento de los estudios realizados durante medio siglo.  Comenzaron a escribir sobre el modelo relacional en la d√©cada de 1960.  A lo largo de los a√±os 70 y 80, este modelo ha mejorado significativamente.  Los principiantes a menudo tienen preguntas como " <em>¬øen qu√© clase quieres poner estos datos?</em> ", Y en respuesta a menudo se les dice algo vago, como " <em>solo necesitas ganar experiencia y luego aprender a comprender internamente</em> " ... pero en los a√±os 70 esta pregunta fue activa estudi√≥ y en el caso general se dedujo una respuesta formal;  Esto se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">normalizaci√≥n de la base de datos</a> .  Descartando la investigaci√≥n existente y llamando a ECS una soluci√≥n completamente nueva y moderna, ocultas este conocimiento a los principiantes. <br><br>  ¬°Los fundamentos de la programaci√≥n orientada a objetos se establecieron hace mucho tiempo, si no antes ( <em>este estilo comenz√≥ a explorarse en el trabajo de la d√©cada de 1950</em> )!  Sin embargo, fue en la d√©cada de 1990 que la orientaci√≥n a objetos se puso de moda, viral y muy r√°pidamente se convirti√≥ en el paradigma de programaci√≥n dominante.  Se ha producido la explosi√≥n de popularidad de muchos nuevos lenguajes OO, incluidos Java y la C ++ ( <em>versi√≥n estandarizada</em> ).  Sin embargo, dado que esto se debi√≥ a la exageraci√≥n, todos <em>necesitaban</em> conocer este concepto de alto perfil para escribir en su curr√≠culum, pero solo unos pocos realmente entraron en √©l.  Estos nuevos lenguajes crearon las palabras clave - <em>clase</em> , <em>virtual</em> , <em>amplia</em> , <em>implementa</em> - a partir de muchas caracter√≠sticas de OO, y creo que es por eso que en ese momento OO se dividi√≥ en dos entidades separadas que viven sus propias vidas. <br><br>  Me referir√© al uso de estas caracter√≠sticas del lenguaje inspiradas en OO como " <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">OOP</a></strong> " y el uso de t√©cnicas de dise√±o / arquitectura inspiradas en OO " <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">OOD</a></strong> ".  Todo muy r√°pidamente recogi√≥ la POO.  Las instituciones educativas tienen cursos de OO que hornean a nuevos programadores de OOP ... sin embargo, el conocimiento de OOD va a la zaga. <br><br>  Creo que el c√≥digo que usa las caracter√≠sticas del lenguaje de OOP, pero no sigue los principios del dise√±o OOD, <strong>no</strong> es <strong>un c√≥digo OO</strong> .  La mayor√≠a de las cr√≠ticas contra OOP usan c√≥digo destripado como ejemplo, que no es realmente un c√≥digo OO. <br><br>  El c√≥digo OOP tiene muy mala reputaci√≥n, y en particular porque la mayor√≠a del c√≥digo OOP no sigue los principios de OOD y, por lo tanto, no es un c√≥digo OO "verdadero". <br><br><h1>  Antecedentes </h1><br>  Como se indic√≥ anteriormente, la d√©cada de 1990 se convirti√≥ en el pico de la "moda OO", y fue en ese momento que la "mala OOP" fue probablemente la peor.  Si estudiaste POO en ese momento, lo m√°s probable es que hayas aprendido sobre los "cuatro pilares de la POO": <br><br><ul><li>  Abstracci√≥n </li><li>  Encapsulaci√≥n </li><li>  Polimorfismo </li><li>  Herencia </li></ul><br>  Prefiero llamarlos no cuatro pilares, sino "cuatro herramientas OOP".  Estas son herramientas que <em><strong>puede</strong></em> usar para resolver problemas.  Sin embargo, no basta con descubrir c√≥mo funciona la herramienta, debe saber cu√°ndo usarla ... Por parte de los maestros, es irresponsable ense√±ar a las personas una nueva herramienta, no decirles cu√°ndo vale la pena usar cada una de ellas.  A principios de la d√©cada de 2000, hubo resistencia al mal uso activo de estas herramientas, una especie de "segunda ola" de pensamiento OOD.  El resultado fue la aparici√≥n de mnem√≥nicos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">S√ìLIDOS</a> , que proporcionaron una forma r√°pida de evaluar las fortalezas arquitect√≥nicas.  Cabe se√±alar que esta sabidur√≠a en realidad se extendi√≥ en los a√±os 90, pero a√∫n no ha recibido un acr√≥nimo genial, lo que permiti√≥ que se fijaran como cinco principios b√°sicos ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">El principio de responsabilidad exclusiva</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">principio de responsabilidad</a></strong> individual).  Cada clase debe tener solo una raz√≥n para el cambio.  Si la clase "A" tiene dos responsabilidades, entonces debe crear la clase "B" y "C" para procesar cada una de ellas individualmente, y luego crear "A" a partir de "B" y "C". </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">El principio de apertura / cierre</a></strong> ( <b>O</b> pen / principio cerrado).  El software cambia con el tiempo ( <em>es decir, su soporte es importante</em> ).  Intente poner las partes que tienen m√°s probabilidades de cambiar en las <em>implementaciones (</em> <em>es decir, en clases espec√≠ficas</em> ) y cree <em>interfaces</em> basadas en esas partes que no es probable que cambien ( <em>por ejemplo, clases base abstractas</em> ). <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">El principio de sustituci√≥n de Barbara Liskov</a></strong> (principio de sustituci√≥n de <b>L</b> iskov).  Cada implementaci√≥n de una interfaz debe cumplir al 100% los requisitos de esta interfaz, es decir  cualquier algoritmo que funcione con una interfaz deber√≠a funcionar con cualquier implementaci√≥n. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">El principio de separaci√≥n de la interfaz</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">principio de segregaci√≥n de interfaz</a></strong> ).  Haga que las interfaces sean lo m√°s peque√±as posible para que cada parte del c√≥digo "sepa" sobre la cantidad m√°s peque√±a de c√≥digo base, por ejemplo, evite dependencias innecesarias.  Este consejo tambi√©n es bueno para C ++, donde los tiempos de compilaci√≥n se vuelven enormes si no lo sigue. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">El principio de inversi√≥n de dependencia</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">principio de inversi√≥n de dependencia</a></strong> ).  En lugar de dos implementaciones espec√≠ficas que se comunican directamente (y dependen unas de otras), generalmente pueden separarse formalizando su interfaz de comunicaci√≥n como una tercera clase, utilizada como interfaz entre ellas.  Puede ser una clase base abstracta que define las llamadas de los m√©todos utilizados entre ellos, o incluso simplemente una estructura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">POD</a> que define los datos transferidos entre ellos. </li><li>  Otro principio no est√° incluido en el acr√≥nimo SOLID, pero estoy seguro de que es muy importante: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">"Prefiera la composici√≥n sobre la herencia"</a></strong> (Principio de reutilizaci√≥n de compuestos).  La composici√≥n <em>es la opci√≥n correcta por defecto</em> .  La herencia se debe dejar para los casos en que sea absolutamente necesario. </li></ul><br>  Entonces obtenemos SOLID-C (++) <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  A continuaci√≥n me referir√© a estos principios, llam√°ndolos acr√≥nimos: SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Algunas notas m√°s: <br><br><ul><li>  En OOD, los conceptos de <em>interfaces</em> e <em>implementaciones</em> no pueden vincularse a ninguna palabra clave espec√≠fica de OOP.  En C ++, a menudo creamos interfaces con <em>clases base abstractas</em> y <em>funciones virtuales</em> , y luego las <em>implementaciones</em> heredan de estas clases base ... pero esta es solo una forma espec√≠fica de implementar el principio de la interfaz.  En C ++, tambi√©n podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">punteros opacos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">tipeo de pato</a> , typedef, etc. ¬°Puede crear una estructura OOD y luego implementarla en C, en la que no hay palabras clave del lenguaje OOP!  Entonces, cuando hablo de <em>interfaces</em> , no me refiero necesariamente a <em>las</em> funciones <em>virtuales</em> , estoy hablando del principio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">ocultar la implementaci√≥n</a> .  Las interfaces <em>pueden</em> ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">polim√≥rficas</a> , ¬°pero la mayor√≠a de las veces lo son!  El polimorfismo rara vez se usa correctamente, pero las interfaces son un concepto fundamental para todo el software. <br><ul><li>  Como dej√© claro anteriormente, si crea una estructura POD que simplemente almacena algunos datos para la transmisi√≥n de una clase a otra, entonces esta estructura se usa como una <em>interfaz</em> ; esta es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">descripci√≥n</a> formal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">de los datos</a> . <br></li><li>  Incluso si solo crea una clase separada con las partes <em>p√∫blica</em> y <em>privada</em> , entonces todo lo que est√° en la parte com√∫n es una <em>interfaz</em> , y todo en la parte privada es una <em>implementaci√≥n</em> . </li></ul></li><li>  La herencia en realidad tiene (al menos) dos tipos: herencia de interfaz y herencia de implementaci√≥n. <br><ul><li>  En C ++, la herencia de interfaz incluye clases base abstractas con funciones virtuales puras, PIMPL, typedef condicional.  En Java, la herencia de la interfaz se expresa a trav√©s de la palabra clave <em>implements</em> . </li><li>  En C ++, la herencia de implementaciones ocurre cada vez que las clases base contienen algo m√°s que funciones virtuales puras.  En Java, la herencia de implementaci√≥n se expresa utilizando la <em>palabra clave extend</em> . </li><li>  ¬°OOD tiene muchas reglas para heredar interfaces, pero vale la pena considerar la herencia de implementaciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">"c√≥digo con un mordisco"</a> ! </li></ul></li></ul><br>  Y finalmente, debo mostrar algunos ejemplos de la terrible capacitaci√≥n de OOP y c√≥mo conduce a un mal c√≥digo en la vida real (y la mala reputaci√≥n de OOP). <br><br><ol><li>  Cuando le ense√±aron jerarqu√≠as / herencia, es posible que le hayan asignado una tarea similar: <strong><em>suponga que tiene una aplicaci√≥n universitaria que contiene un directorio de estudiantes y personal.</em></strong>  <strong><em>Puede crear la clase base Persona, y luego la clase Estudiante y la clase Personal, heredadas de Persona.</em></strong> <br><br>  No no no  Aqu√≠ te detendr√©.  La implicaci√≥n t√°cita del principio LSP es que <em>las jerarqu√≠as de clase</em> y los <em>algoritmos que las procesan</em> son simbi√≥ticos.  Estas son las dos mitades de todo el programa.  OOP es una extensi√≥n de la programaci√≥n de procedimientos, y todav√≠a se asocia principalmente con estos procedimientos.  Si no sabemos qu√© tipos de algoritmos funcionar√°n con los <i>estudiantes</i> y el <em>personal</em> ( <em>y qu√© algoritmos se simplificar√°n debido al polimorfismo</em> ), entonces ser√° completamente irresponsable comenzar a crear la estructura de las jerarqu√≠as de clases.  Primero necesita conocer los algoritmos <em>y los</em> datos. </li><li>  Cuando le ense√±aron jerarqu√≠as / herencia, probablemente le dieron una tarea similar: <b><i>suponga que tiene una clase de formas.</i></b>  <b><i>Tambi√©n tenemos cuadrados y rect√°ngulos como subclases.</i></b>  <b><i>¬øDeber√≠a un cuadrado ser un rect√°ngulo o un rect√°ngulo un cuadrado?</i></b> <br><br>  Este es realmente un buen ejemplo para demostrar la diferencia entre la herencia de implementaciones y la herencia de interfaces. <br><ul><li>  Si utiliza el enfoque de herencia de implementaci√≥n, entonces ignora por completo el LSP y, desde un punto de vista pr√°ctico, piensa en la posibilidad de reutilizar el c√≥digo, utilizando la herencia como herramienta. <br><br>  Desde este punto de vista, lo siguiente es perfectamente l√≥gico: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  El cuadrado tiene solo el ancho, y el rect√°ngulo tiene el ancho + alto, es decir, al expandir el cuadrado con el componente de altura, ¬°obtenemos un rect√°ngulo! <br><ul><li>  Como habr√°s adivinado, OOD dice que hacer esto es ( <em>probablemente</em> ) incorrecto.  Dije <em>"probablemente"</em> porque aqu√≠ puedes discutir sobre las caracter√≠sticas impl√≠citas de la interfaz ... oh, bueno. <br><br>  Un cuadrado siempre tiene la misma altura y ancho, por lo que desde la interfaz del cuadrado es perfectamente cierto suponer que el √°rea es "ancho * ancho". <br><br>  Al heredar de un cuadrado, la clase de rect√°ngulos (seg√∫n LSP) <strong>debe</strong> obedecer las reglas de la interfaz cuadrada.  Cualquier algoritmo que funcione correctamente para un cuadrado tambi√©n deber√≠a funcionar correctamente para un rect√°ngulo. </li><li>  Toma otro algoritmo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Funcionar√° correctamente para cuadrados (calculando la suma de sus √°reas), pero no funcionar√° para rect√°ngulos. <br><br>  Por lo tanto, el rect√°ngulo viola el principio LSP. </li></ul></li><li>  Si utiliza el enfoque de herencia de interfaz, ni Square ni Rectangle heredar√°n entre s√≠.  Las interfaces para el cuadrado y el rect√°ngulo son realmente diferentes, y una no es un superconjunto de la otra. <br></li><li>  Por lo tanto, OOD desalienta el uso de la herencia de implementaci√≥n.  Como se indic√≥ anteriormente, si desea reutilizar el c√≥digo, ¬°OOD dice que la composici√≥n es la elecci√≥n correcta! <br><ul><li>  Entonces, la versi√≥n <i>correcta</i> del c√≥digo (incorrecto) anterior para la jerarqu√≠a de herencia de las implementaciones de C ++ se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "P√∫blico virtual" en Java significa "implementos".  Se usa al implementar la interfaz. <br></li><li>  "Privado" le permite extender la clase base sin heredar su interfaz; en este caso, el rect√°ngulo <b>no</b> es <b>un</b> cuadrado, aunque hereda de √©l. <br></li></ul></li><li>  No recomiendo escribir dicho c√≥digo, pero si desea usar la herencia de implementaciones, ¬°debe hacer eso! </li></ul></li></ul></li></ol><br>  TL; DR: su clase de OOP le dijo c√≥mo era la herencia.  ¬°Tu clase de OOD faltante deber√≠a haberte dicho que no la uses el 99% del tiempo! <br><br><h1>  Conceptos de entidad / componente </h1><br>  Habiendo tratado con los requisitos previos, pasemos a donde comenz√≥ Aras, al llamado punto de partida de una "OOP t√≠pica". <br><br>  Pero para empezar, una adici√≥n m√°s: Aras llama a este c√≥digo "OOP tradicional", y quiero objetarlo.  Este c√≥digo puede ser t√≠pico para OOP en el mundo real, pero, al igual que los ejemplos anteriores, viola todo tipo de principios b√°sicos de OO, por lo que no debe considerarse como tradicional. <br><br>  Comenzar√© con el primer commit antes de que √©l comenzara a rehacer la estructura hacia ECS: <a href="" rel="external nofollow">‚ÄúHaz que funcione nuevamente en Windows‚Äù 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  S√≠, es dif√≠cil descifrar cien l√≠neas de c√≥digo de inmediato, as√≠ que comencemos gradualmente ... Necesitamos otro aspecto de los requisitos previos: era popular usar la herencia en los juegos de los a√±os 90 para resolver todos los problemas de reutilizaci√≥n de c√≥digo.  Ten√≠as Entity, Character extensible, Player y Monster extensibles, y as√≠ sucesivamente ... Esta es una herencia de implementaciones, como describimos anteriormente ( <em>"c√≥digo con estrangulador"</em> ), y parece que es correcto comenzar con eso, pero como resultado conduce a base de c√≥digo inflexible.  Porque OOD tiene el principio de "composici√≥n sobre herencia" descrito anteriormente.  Entonces, en la d√©cada de 2000, el principio de "composici√≥n sobre herencia" se hizo popular, y los desarrolladores de juegos comenzaron a escribir c√≥digo similar. <br><br>  ¬øQu√© hace este c√≥digo?  Bueno no bueno <img alt=": D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D" width="20"><br><br>  En resumen, <strong>este c√≥digo vuelve a implementar una caracter√≠stica existente del lenguaje: la composici√≥n</strong> como una biblioteca de tiempo de ejecuci√≥n y no como una caracter√≠stica del lenguaje.  Puede imaginar esto como si el c√≥digo estuviera realmente creando un nuevo metalenguaje sobre C ++ y una m√°quina virtual (VM) para ejecutar este metalenguaje.  En el juego de demostraci√≥n de Aras, este c√≥digo no es obligatorio ( <em>¬°lo eliminaremos por completo pronto!</em> ) Y solo sirve para reducir el rendimiento del juego unas 10 veces. <br><br>  ¬øPero qu√© hace √©l realmente?  Este es el concepto de "sistema de componente <strong>E</strong> / entidad" (a <em>veces por alguna raz√≥n llamado "sistema de componente <strong>E</strong> / <strong>C</strong> "</em> ), pero es completamente diferente del concepto de "sistema <strong>C</strong> sistema de componente omponente "(" sistema de componente de entidad ") ( <em>que por razones obvias nunca se llama"</em> sistemas de sistema de componente de entidad de la entidad). Formaliza varios principios de la "CE": <br><br><ul><li>  el juego se construir√° a partir de no tener caracter√≠sticas de "Entidades" ("Entidad") ( <em>en este ejemplo, llamadas</em> GameObjects), que consisten en "componentes" ("Componente"). </li><li>  GameObjects implementa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">el patr√≥n de "localizador de servicios"</a> : sus componentes secundarios se consultar√°n por tipo. </li><li>  Los componentes saben a qu√© GameObject pertenecen: pueden encontrar componentes que est√©n en el mismo nivel con ellos consultando el GameObject padre. <br></li><li>  La composici√≥n puede tener solo un nivel de profundidad (los <em>componentes no pueden tener sus propios componentes secundarios, GameObjects no puede tener GameObjects secundarios</em> ). <br></li><li>  GameObject puede tener solo un componente de cada tipo ( <em>en algunos marcos esto es un requisito obligatorio, en otros no</em> ). <br></li><li>  Cada componente (probablemente) cambia con el tiempo de una manera no especificada, por lo que la interfaz contiene una "Actualizaci√≥n virtual vac√≠a". <br></li><li>  Los GameObjects pertenecen a una escena que puede ejecutar consultas en todos los GameObjects (y, por lo tanto, en todos los componentes). </li></ul><br>  Un concepto similar fue muy popular en la d√©cada de 2000, y a pesar de sus limitaciones, result√≥ ser lo suficientemente flexible como para crear innumerables juegos tanto en la actualidad como en la actualidad. <br><br>  Sin embargo, esto no es obligatorio.  Su lenguaje de programaci√≥n ya tiene soporte para la composici√≥n como una caracter√≠stica del lenguaje: no hay necesidad de un concepto hinchado para acceder a √©l ... ¬øPor qu√©, entonces, existen estos conceptos?  Bueno, para ser sincero, te permiten realizar <em>composiciones din√°micas en tiempo de ejecuci√≥n</em> .  En lugar de definir tipos de GameObject en el c√≥digo, puede cargarlos desde archivos de datos.  Y esto es muy conveniente, porque permite a los dise√±adores de juegos / niveles crear sus propios tipos de objetos ... Sin embargo, en la mayor√≠a de los proyectos de juegos hay muy pocos dise√±adores y literalmente un ej√©rcito completo de programadores, por lo que dir√≠a que esta es una oportunidad importante.  Peor a√∫n, ¬°esta no es la √∫nica forma en que puede implementar una composici√≥n en tiempo de ejecuci√≥n!  Por ejemplo, Unity usa C # como su "lenguaje de programaci√≥n", y muchos otros juegos usan sus alternativas, por ejemplo, Lua, una herramienta conveniente para los dise√±adores que puede generar c√≥digo C # / Lua para definir nuevos objetos de juego sin la necesidad de un concepto tan inflado.  Volveremos a agregar esta "caracter√≠stica" en la pr√≥xima publicaci√≥n y haremos que no nos cueste una disminuci√≥n de diez veces en el rendimiento ... <br><br>  Evaluemos este c√≥digo de acuerdo con OOD: <br><br><ul><li>  GameObject :: GetComponent usa dynamic_cast.  La mayor√≠a de la gente te dir√° que dynamic_cast es un "c√≥digo con un estrangulador", una gran pista de que tienes un error en alguna parte.  Dir√≠a esto, esto es evidencia de que viol√≥ el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">LSP</a> , tiene alg√∫n tipo de algoritmo que funciona con la interfaz base, pero necesita conocer diferentes detalles de implementaci√≥n.  Por esta raz√≥n en particular, el c√≥digo huele mal. <br></li><li>  GameObject, en principio, no es malo, si imagina que implementa la plantilla de "localizador de servicios" ... pero si va m√°s all√° de las cr√≠ticas desde el punto de vista de OOD, esta plantilla crea conexiones impl√≠citas entre partes del proyecto, y creo que ( <em>sin un enlace a Wikipedia que pueda soportar yo con conocimiento de la inform√°tica</em> ) que los canales de comunicaci√≥n impl√≠citos son un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">antipatr√≥n</a> , y deber√≠an preferir canales de comunicaci√≥n expl√≠citos.  El mismo argumento se aplica al hinchado "concepto de eventos" que a veces se usa en los juegos ... <br></li><li>  Quiero afirmar que un componente es una violaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">SRP</a> porque su interfaz ( <em>virtual void Update (time)</em> ) es demasiado amplia.  El uso de la "Actualizaci√≥n virtual de vac√≠o" en el desarrollo de juegos es omnipresente, pero tambi√©n dir√≠a que es antipattern.  Un buen software deber√≠a permitirle pensar f√°cilmente sobre el flujo de control y el flujo de datos.  Colocar <em>cada elemento del c√≥digo de juego</em> detr√°s de la llamada "Actualizaci√≥n virtual vac√≠a" ofusca completamente y completamente el flujo de control y el flujo de datos.  En mi humilde opini√≥n, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">los efectos secundarios</a> invisibles, tambi√©n llamados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">largo alcance,</a> son algunas de las fuentes m√°s comunes de errores, y la "Actualizaci√≥n de vac√≠o virtual" asegura que casi todo ser√° un efecto secundario invisible. <br></li><li>  Aunque el objetivo de la clase Component es habilitar la composici√≥n, lo hace a trav√©s de la herencia, lo cual es una violaci√≥n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">CRP</a> . </li><li>  El √∫nico lado bueno de este ejemplo es que el c√≥digo del juego es excesivo para cumplir con los principios de SRP e ISP: est√° dividido en muchos componentes simples con muy poca responsabilidad, lo cual es excelente para reutilizar el c√≥digo. <br><br>  Sin embargo, no es tan bueno para mantener DIP: muchos componentes tienen conocimiento directo el uno del otro. </li></ul><br>  Por lo tanto, todo el c√≥digo que se muestra arriba se puede eliminar.  Toda esta estructura.  Eliminar GameObject (tambi√©n llamado Entidad en otros marcos), eliminar Componente, eliminar FindOfType.  Esto es parte de una m√°quina virtual in√∫til que viola los principios de OOD y ralentiza terriblemente nuestro juego. <br><br><h1>  Composici√≥n sin marcos (es decir, utilizando caracter√≠sticas del lenguaje de programaci√≥n en s√≠) </h1><br>  Si eliminamos el marco de composici√≥n y no tenemos la clase base Componente, ¬øc√≥mo lograr√°n nuestros GameObjects utilizar la composici√≥n y consistir en componentes?  Como dice el t√≠tulo, en lugar de escribir esta m√°quina virtual hinchada y crear GameObjects en un extra√±o metalenguaje, solo escrib√°moslos en C ++ porque somos programadores de juegos y este es literalmente nuestro trabajo. <br><br>  Aqu√≠ est√° el commit que elimin√≥ el marco Entity / Component: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Aqu√≠ est√° la versi√≥n original del c√≥digo fuente: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Aqu√≠ est√° la versi√≥n modificada del c√≥digo fuente: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  Brevemente sobre los cambios: <br><br><ul><li>  Se elimin√≥ ": Componente p√∫blico" de cada tipo de componente. <br></li><li>  Se agreg√≥ un constructor a cada tipo de componente. <br><ul><li>  OOD se trata principalmente de encapsular el estado de una clase, pero dado que estas clases son tan peque√±as / simples, no hay nada especial que ocultar: una interfaz es una descripci√≥n de los datos.  Sin embargo, una de las razones principales por las que la encapsulaci√≥n es el pilar principal es que nos permite garantizar la verdad constante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">de los invariantes de clase</a> ... o si el invariante est√° roto, entonces solo necesita examinar el c√≥digo de implementaci√≥n encapsulado para encontrar el error.  En este ejemplo de c√≥digo, vale la pena agregar constructores para implementar una invariante simple: todos los valores deben inicializarse. </li></ul></li><li>  Cambi√© el nombre de los m√©todos "Actualizar" demasiado generales para que sus nombres reflejen lo que realmente hacen: UpdatePosition para MoveComponent y ResolveCollisions for AvoidComponent. <br></li><li>  Elimin√© tres bloques de c√≥digo codificados que se parec√≠an a una plantilla / prefabricado, el c√≥digo que crea un GameObject que contiene tipos espec√≠ficos de Componente, y lo reemplac√© con tres clases de C ++. <br></li><li>  Se elimin√≥ la "Actualizaci√≥n de vac√≠o virtual" antipatr√≥n. <br></li><li>  En lugar de que los componentes se busquen entre s√≠ a trav√©s de la plantilla de "localizador de servicios", el juego los une expl√≠citamente durante la construcci√≥n. </li></ul><br><h2>  Los objetos </h2><br>  Por lo tanto, en lugar de este c√≥digo de "m√°quina virtual": <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Ahora tenemos c√≥digo C ++ normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Algoritmos </h2><br>  Se ha realizado otro cambio importante en los algoritmos.  ¬øRecuerdas que al principio dije que las interfaces y los algoritmos funcionan en simbiosis y deber√≠an influir en la estructura de cada uno?  Entonces, la " <em>Actualizaci√≥n de vac√≠o virtual</em> " antipatr√≥n se ha convertido en el enemigo aqu√≠ tambi√©n.  El c√≥digo inicial contiene el algoritmo del bucle principal, que consiste solo en esto: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Puedes argumentar que es hermoso y simple, pero en mi humilde opini√≥n es muy, muy malo.  Esto ofusca completamente tanto el <em>flujo de</em> <em>control</em> como el <em>flujo de datos</em> dentro del juego.  Si queremos poder comprender nuestro software, si queremos admitirlo, si queremos agregarle cosas nuevas, optimizarlo, ejecutarlo de manera eficiente en varios n√∫cleos de procesador, entonces debemos comprender tanto el flujo de control como el flujo de datos.  Por lo tanto, la "Actualizaci√≥n de vac√≠o virtual" debe ser incendiada. <br><br>  En cambio, creamos un bucle principal m√°s expl√≠cito, que simplifica enormemente la comprensi√≥n del flujo de control (el <em>flujo de datos a√∫n est√° ofuscado, pero lo arreglaremos en las siguientes confirmaciones</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  La desventaja de este estilo es que para <em>cada nuevo tipo de objeto</em> agregado al juego, tenemos que agregar varias l√≠neas al bucle principal.  Volver√© sobre esto en una publicaci√≥n posterior de esta serie. <br><br><h1>  Rendimiento </h1><br>  Hay muchas violaciones enormes de OOD, se toman algunas malas decisiones al elegir una estructura y hay muchas oportunidades para la optimizaci√≥n, pero las abordar√© en la pr√≥xima publicaci√≥n de la serie.  Sin embargo, ya en esta etapa est√° claro que la versi√≥n con "OOD fijo" coincide casi por completo o gana el c√≥digo final "ECS" desde el final de la presentaci√≥n ... Y todo lo que hicimos fue tomar el c√≥digo pseudo-OOP incorrecto y hacer que cumpliera con los principios ¬°OOP (y tambi√©n borr√≥ cien l√≠neas de c√≥digo)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Pr√≥ximos pasos </h1><br>  Aqu√≠ quiero considerar una gama mucho m√°s amplia de problemas, incluida la resoluci√≥n de los problemas OOD restantes, los objetos inmutables ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">programaci√≥n en un estilo funcional</a> ) y las ventajas que pueden aportar en las discusiones sobre flujos de datos, paso de mensajes, aplicaci√≥n de l√≥gica DOD a nuestro c√≥digo OOD, aplicando sabidur√≠a relevante en el c√≥digo OOD, eliminando estas clases de "entidades" con las que terminamos, y usando solo componentes puros, usando diferentes estilos para conectar componentes (comparando punteros y  la responsabilidad de llevar) componentes de contenedores del mundo real, la versi√≥n ECS-revisi√≥n para una mejor optimizaci√≥n, as√≠ como una mayor optimizaci√≥n, no se menciona en el informe de Aras <em>(tales como multi-threading / SIMD).</em>  El orden no ser√° necesariamente este, y quiz√°s no considerar√© todo lo anterior ... <br><br><h1>  Adem√°s </h1><br>  Los enlaces al art√≠culo se han extendido m√°s all√° de los c√≠rculos de desarrolladores de juegos, por lo que agregar√©: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">ECS</a> " ( <em>este art√≠culo de Wikipedia es malo, por cierto, combina los conceptos de EC y ECS, y esto no es lo mismo ...</em> ) - esta es una plantilla falsa que circula dentro de las comunidades desarrolladores de juegos.  De hecho, es una versi√≥n del modelo relacional en el que las "entidades" son solo ID que designan un objeto sin forma, los "componentes" son filas en tablas espec√≠ficas que hacen referencia a los ID, y los "sistemas" son c√≥digos de procedimiento que pueden modificar componentes. .  Esta "plantilla" siempre se ha posicionado como una soluci√≥n al problema del uso excesivo de la herencia, pero no se menciona que el uso excesivo de la herencia realmente viola las recomendaciones de la OOP.  De ah√≠ mi indignaci√≥n.  Esta no es la "√∫nica forma verdadera" de escribir software.  La publicaci√≥n est√° dise√±ada para garantizar que las personas realmente aprendan sobre los principios de dise√±o existentes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441174/">https://habr.com/ru/post/441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441158/index.html">C√≥mo la √©tica se convirti√≥ en el problema m√°s costoso de Silicon Valley, y la filosof√≠a se convirti√≥ en su soluci√≥n m√°s pr√°ctica</a></li>
<li><a href="../441160/index.html">C√≥mo aprender a determinar cu√°ndo decir no</a></li>
<li><a href="../441166/index.html">Obtenemos la contrase√±a maestra del administrador de contrase√±as bloqueadas 1 Contrase√±a 4</a></li>
<li><a href="../441168/index.html">Canales de datos QUIC: primeros pasos</a></li>
<li><a href="../441172/index.html">C√≥mo creci√≥ el mercado de la impresi√≥n 3D en 2018 y lo que significa para las empresas</a></li>
<li><a href="../441180/index.html">Nublado con posibilidad de publicidad no desactivable en el cielo estrellado</a></li>
<li><a href="../441182/index.html">Enfoque sinest√©sico de m√°quina para detectar ataques DDoS de red. Parte 2</a></li>
<li><a href="../441184/index.html">La primera conferencia de juegos Mail.ru Group</a></li>
<li><a href="../441186/index.html">Visor de cenizas: reinicio</a></li>
<li><a href="../441192/index.html">Usando el poder de c√≥mputo de R para probar la hip√≥tesis de igualdad de medias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>