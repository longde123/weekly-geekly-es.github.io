<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïå üë©üèæ‚Äçüíº üéÖ Ensamblador inserta ... en C #? üî™ üßóüèº ü§πüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entonces, esta historia comenz√≥ con una coincidencia de tres factores. Yo: 



1. principalmente escrito en C #; 
2. solo aproximadamente imagin√© c√≥mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ensamblador inserta ... en C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Entonces, esta historia comenz√≥ con una coincidencia de tres factores.  Yo: <br><br><ol><li>  principalmente escrito en C #; </li><li>  solo aproximadamente imagin√© c√≥mo est√° organizado y funciona; </li><li>  se interes√≥ en ensamblador. </li></ol><br>  Esta mezcla aparentemente inocente dio lugar a una idea extra√±a: ¬øes posible combinar de alguna manera estos idiomas?  Agregue en C # la capacidad de hacer insertos de ensamblador, al igual que en C ++. <br><br>  Si est√° interesado en las consecuencias que esto provoc√≥, bienvenido a cat. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Primeras dificultades </h2><br>  Incluso en ese momento, me di cuenta de que es muy poco probable que existan herramientas est√°ndar para llamar al c√≥digo ensamblador desde el c√≥digo C #; esto contradice demasiado uno de los conceptos importantes del lenguaje: la seguridad de la memoria.  Despu√©s de un estudio superficial del problema (que, entre otras cosas, confirm√≥ el presentimiento inicial: "fuera de la caja" no existe tal posibilidad), qued√≥ claro que, adem√°s del problema ideol√≥gico, existe un problema puramente t√©cnico: C #, como saben, se compila en un c√≥digo de bytes intermedio, que interpretado adicionalmente por la m√°quina virtual CLR.  Y es precisamente aqu√≠ donde nos enfrentamos con el mismo problema: por un lado, el compilador (en adelante me referir√© a Roslyn de Microsoft, ya que es de hecho el est√°ndar en el campo de los compiladores de C #), obviamente, no puede reconocer y traduce los comandos del ensamblador de una vista de texto a una representaci√≥n binaria, lo que significa que debemos usar las instrucciones de la m√°quina directamente en su forma binaria como una inserci√≥n, y por otro lado, la m√°quina virtual tiene su propio c√≥digo de bytes y no puede reconocer y ejecutar eso  comandos de paquetes que su oferta. <br><br>  La soluci√≥n te√≥rica a este problema es obvia: debe asegurarse de que el c√≥digo de inserci√≥n binario sea ejecutado por el procesador, evitando la interpretaci√≥n de la m√°quina virtual.  Lo m√°s simple que viene a la mente es almacenar el c√≥digo binario como una matriz de bytes, a los cuales el control se transferir√° de alguna manera en el momento adecuado.  Desde aqu√≠ surge la primera tarea: debe encontrar una forma de transferir el control a lo que est√° contenido en un √°rea de memoria arbitraria. <br><br><h2>  Primer prototipo: "llamar" a una matriz </h2><br>  Esta tarea es quiz√°s el obst√°culo m√°s serio para las inserciones.  Usando las herramientas de lenguaje, es f√°cil obtener un puntero a nuestra matriz, pero en el mundo C # los punteros solo existen en los datos y es imposible convertirlo en un puntero para, por ejemplo, una funci√≥n para que pueda llamarse m√°s tarde (bueno, o al menos no pude averiguar c√≥mo hacer) <br><br>  Afortunadamente (o desafortunadamente), nada es nuevo bajo la luna y una b√∫squeda r√°pida en Yandex de las palabras "C #" y "insertos de ensamblador" me llev√≥ a un art√≠culo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">edici√≥n de diciembre de 2007 de la revista]] [Aker]</a> .  Despu√©s de haber copiado honestamente la funci√≥n desde all√≠ y adaptarla a mis necesidades, obtuve <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  La idea principal de este c√≥digo es reemplazar la direcci√≥n de retorno de la funci√≥n <code>InvokeAsm()</code> en la pila con la direcci√≥n de la matriz de bytes a la que desea transferir el control.  Luego, despu√©s de salir de la funci√≥n, en lugar de continuar la ejecuci√≥n del programa, comenzar√° la ejecuci√≥n de nuestro c√≥digo binario. <br><br>  Trataremos la magia que <code>InvokeAsm()</code> en <code>InvokeAsm()</code> con m√°s detalle.  Primero, declaramos una variable local, que, por supuesto, aparece en la pila, luego obtenemos su direcci√≥n (obteniendo as√≠ la direcci√≥n de la parte superior de la pila).  A continuaci√≥n, le agregamos una cierta constante m√°gica obtenida calculando minuciosamente en el depurador el desplazamiento de la direcci√≥n de retorno en relaci√≥n con la parte superior de la pila, guarda la direcci√≥n de retorno y escribe la direcci√≥n de nuestra matriz de bytes.  El significado sagrado de guardar la direcci√≥n del remitente es obvio: necesitamos continuar ejecutando el programa despu√©s de nuestra inserci√≥n, lo que significa que necesitamos saber d√≥nde transferir el control despu√©s de √©l.  Luego viene la llamada a la funci√≥n WinAPI desde la biblioteca kernel32.dll - <code>VirtualProtect()</code> .  Es necesario para cambiar los atributos de la p√°gina de memoria en la que se encuentra el c√≥digo de inserci√≥n.  Por supuesto, al compilar el programa, aparece en la secci√≥n de datos y la p√°gina de memoria correspondiente tiene acceso de lectura y escritura.  Tambi√©n necesitamos agregar permiso para ejecutar su contenido.  Finalmente, devolvemos la direcci√≥n de retorno real almacenada.  Por supuesto, esta direcci√≥n no se devolver√° al c√≥digo que llam√≥ <code>InvokeAsm()</code> , porque  ejecuci√≥n inmediatamente despu√©s del <code>return (void*)i;</code>  "Fail" en el inserto.  Sin embargo, las convenciones de llamada utilizadas por la m√°quina virtual (llamada est√°ndar con optimizaci√≥n deshabilitada y llamada r√°pida habilitada) significan devolver el valor a trav√©s del registro EAX, es decir  Para volver de la inserci√≥n, debemos seguir dos instrucciones: <code>push eax</code> (c√≥digo 0x50) y <code>ret</code> (c√≥digo 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Aclaracion</b> <div class="spoiler_text">  En el futuro, hablaremos sobre la arquitectura de x86 (o m√°s bien, IA-32), cursi debido al hecho de que en ese momento estaba al menos familiarizado con ella, a diferencia de, por ejemplo, x86-64.  Sin embargo, el m√©todo de transferencia de control descrito anteriormente deber√≠a funcionar para el c√≥digo de 64 bits. <br></div></div><br>  Finalmente, debe prestar atenci√≥n a dos argumentos no utilizados: <code>void* firstAsmArg</code> y <code>void* secondAsmArg</code> .  Son necesarios para transferir datos de usuario arbitrarios al inserto del ensamblador.  Estos argumentos se ubicar√°n en un lugar conocido de la pila (stdcall) o, nuevamente, en registros conocidos (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Un poco sobre optimizaci√≥n</b> <div class="spoiler_text">  Dado que, desde el punto de vista del compilador, lo que est√° sucediendo en el c√≥digo, no entiendo qu√©, puede arrojar inadvertidamente alguna llamada fundamentalmente importante / agregar algo en l√≠nea / no guardar alg√∫n argumento "no utilizado" / interferir de alguna manera con la implementaci√≥n de nuestro plan.  Esto est√° parcialmente resuelto por el <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> , sin embargo, incluso esas precauciones no dan el efecto deseado: por ejemplo, la variable local <code>i</code> , que es clave para toda la funci√≥n, de repente resulta ser un registro, que obviamente estropea todo .  Por lo tanto, para eliminar por completo la probabilidad de que algo salga mal, debe crear una biblioteca con la optimizaci√≥n deshabilitada (deshabil√≠tela en las propiedades del proyecto o use la configuraci√≥n de Depuraci√≥n).  En consecuencia, se utilizar√° stdcall, por lo que en el futuro proceder√© de esta convenci√≥n de llamadas. <br></div></div><br><h2>  Mejoras </h2><br><h3>  Lo seguro es mejor que lo inseguro </h3><br>  Por supuesto, no se trata de ninguna seguridad (en el sentido con el que se usa esta palabra en C #).  Sin embargo, el m√©todo <code>InvokeAsm()</code> descrito anteriormente funciona en punteros, lo que significa que solo se puede llamar desde el bloque marcado con la palabra clave <code>unsafe</code> , lo que no siempre es conveniente, al menos requiere compilaci√≥n con el modificador / inseguro (o la marca de verificaci√≥n correspondiente en las propiedades del proyecto en VS).  Por lo tanto, parece l√≥gico proporcionar un shell que opere al menos IntPtr (en el peor de los casos) e, idealmente, permite al usuario especificar por completo los tipos transferidos y devueltos.  Bueno, eso suena como gen√©rico, escribimos gen√©rico, ¬øqu√© m√°s hay, uno pregunta, para hablar?  De hecho, hay algo. <br><br>  Lo m√°s obvio: ¬øc√≥mo obtener un puntero a un argumento cuyo tipo es desconocido?  Las construcciones del tipo <code>T* ptr = &amp;arg</code> no <code>T* ptr = &amp;arg</code> permitidas en C # y, en general, no es dif√≠cil entender la raz√≥n: el usuario puede usar uno de los tipos administrados como un par√°metro de tipo, un puntero al que no se puede obtener.  La soluci√≥n podr√≠a ser limitar un par√°metro de tipo <code>unmanaged</code> , pero, en primer lugar, apareci√≥ solo en C # 7.3, y en segundo lugar, no permite pasar cadenas y matrices como argumentos, aunque el operador <code>fixed</code> permite que se usen (obtenemos el puntero al primer car√°cter o elemento de matriz, respectivamente).  Bueno, adem√°s, me gustar√≠a darle al usuario la oportunidad de operar, incluidos los tipos controlados: desde que comenzamos a violar las reglas del lenguaje, ¬°las violaremos hasta el final! <br><br><h3>  Obtener un puntero a un objeto administrado y un objeto por puntero </h3><br>  Y nuevamente, despu√©s de una deliberaci√≥n no muy fruct√≠fera, comenc√© a buscar las soluciones finales.  Esta vez el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre Habr√©</a> me ayud√≥.  En resumen, uno de los m√©todos propuestos en √©l es escribir una biblioteca auxiliar, y no en C #, sino directamente en IL.  Su tarea es insertar un objeto (en realidad una referencia al objeto) en la pila de la m√°quina virtual, pasarlo como un argumento y luego recuperar algo m√°s de la pila, por ejemplo, un n√∫mero o <code>IntPtr</code> .  Al realizar los mismos pasos en orden inverso, puede convertir el puntero (por ejemplo, devuelto por la inserci√≥n del ensamblador) en un objeto.  Este m√©todo es bueno porque todo lo que sucede es claro y transparente.  Pero hay un inconveniente: quer√≠a sobrevivir con la menor cantidad de archivos posible, as√≠ que en lugar de escribir una biblioteca separada, decid√≠ incrustar el c√≥digo IL en el principal.  La √∫nica forma que encontr√© es escribir m√©todos stub en C #, construir el proyecto, desmontar el binario usando ildasm, reescribir el c√≥digo de los m√©todos stub y volver a armarlo todo con ilasm.  Estas son bastantes acciones adicionales, y dado que debe realizarlas cada vez que las construye despu√©s de realizar cambios en el c√≥digo ... En general, me cans√© bastante r√°pido y comenc√© a buscar alternativas. <br><br>  Justo en ese momento, un libro maravilloso cay√≥ en mis manos, gracias al cual aprend√≠ mucho por m√≠ mismo: "CLR a trav√©s de C #" de Jeffrey Richter.  En √©l, en alg√∫n lugar alrededor del vig√©simo cap√≠tulo, hablamos sobre la estructura <code>GCHandle</code> , que tiene un m√©todo <code>Alloc()</code> que toma un objeto y uno de los <code>GCHandleType</code> enumeraci√≥n <code>GCHandleType</code> .  Entonces, si llama a este m√©todo pas√°ndolo el objeto deseado y <code>GCHandle.Pinned</code> , puede obtener la direcci√≥n de este objeto en la memoria.  Adem√°s, antes de llamar a <code>GCHandle.Free()</code> objeto es fijo, es decir  totalmente protegido de los efectos del recolector de basura.  Sin embargo, hay ciertos problemas.  En primer lugar, <code>GCHandle</code> no ayuda de ninguna manera a completar la conversi√≥n "puntero ‚Üí objeto", solo "objeto ‚Üí puntero".  M√°s importante a√∫n, para usar <code>GCHandleType.Pinned</code> clase o estructura del objeto cuya direcci√≥n que queremos obtener debe tener el atributo <code>[StructLayout(LayoutKind.Sequential)]</code> , mientras que <code>LayoutKind.Auto</code> usa por <code>LayoutKind.Auto</code> .  Por lo tanto, este m√©todo es adecuado solo para algunos tipos est√°ndar y para aquellos tipos personalizados que fueron dise√±ados originalmente con esto en mente.  No es exactamente el m√©todo universal que nos gustar√≠a encontrar, ¬øverdad? <br><br>  Bueno, int√©ntalo de nuevo.  Ahora prestemos atenci√≥n a dos funciones no documentadas, que, sin embargo, son compatibles con Roslyn: <code>__makeref()</code> y <code>__refvalue()</code> .  El primero de ellos toma un objeto y devuelve una instancia de la estructura <code>TypedReference</code> que almacena una referencia al objeto y su tipo, mientras que el segundo extrae el objeto de la instancia transmitida <code>typedReference</code> .  ¬øPor qu√© estas caracter√≠sticas son importantes para nosotros?  ¬°Porque <code>TypedReference</code> es una estructura!  En el contexto de la discusi√≥n, esto significa que podemos obtener un puntero que, en combinaci√≥n, ser√° un puntero al primer campo de esta estructura.  Es decir, almacena el enlace al objeto que nos interesa.  Luego, para obtener un puntero a un objeto administrado, necesitamos leer el valor de un puntero a lo que <code>__makeref()</code> devolver√° y convertirlo en un puntero.  Para obtener un objeto por puntero, debe llamar a <code>__makeref()</code> desde un objeto condicionalmente vac√≠o del tipo requerido, obtener un puntero a la instancia <code>TypedReference</code> devuelta, escribir un puntero al objeto en √©l y luego llamar a <code>__refvalue()</code> .  El resultado es algo como este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Observaci√≥n</b> <div class="spoiler_text">  Volviendo a la tarea de escribir un contenedor seguro para <code>InvokeAsm()</code> , debe tenerse en cuenta que el m√©todo para obtener punteros usando <code>__makeref()</code> y <code>__refvalue()</code> , a diferencia de usar <code>GCHandle.Alloc(GCHandleType.Pinned)</code> , no garantiza que nuestro recolector de basura no est√© en ninguna parte El objeto no se mover√°.  Por lo tanto, el contenedor debe comenzar apagando el recolector de basura y terminando con la restauraci√≥n de su funcionalidad.  La soluci√≥n es bastante grosera, pero efectiva. <br></div></div><br><h2>  Para aquellos que no recuerdan los c√≥digos de operaci√≥n </h2><br>  Entonces, aprendimos c√≥mo llamar al c√≥digo binario, aprendimos a pasarlo como argumentos no solo valores inmediatos, sino tambi√©n indicadores a cualquier cosa ... Solo hay un problema.  ¬øD√≥nde obtener el mismo c√≥digo binario?  Puede armarse con un l√°piz, un bloc de notas y una tabla de c√≥digo de operaci√≥n (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> ) o tomar un editor hexadecimal con soporte de ensamblador x86 o incluso un traductor completo, pero todas estas opciones significan que el usuario tendr√° que usar algo m√°s que la biblioteca.  Esto no es exactamente lo que quer√≠a, as√≠ que decid√≠ incluir mi traductor en la biblioteca, que tradicionalmente se llamaba SASM (abreviatura de Stack Assembler; no tiene nada que ver con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDE</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Descargo de responsabilidad</b> <div class="spoiler_text">  No soy bueno para analizar cadenas, as√≠ que el c√≥digo del traductor ... bueno, imperfecto, por decir lo menos.  Adem√°s, no soy fuerte en las expresiones regulares, por lo que no est√°n all√≠.  Y en general, un analizador iterativo. <br></div></div><br>  Probablemente no voy a hablar sobre el proceso de creaci√≥n de este "milagro". No hay nada interesante en esta historia, pero describir√© brevemente las caracter√≠sticas principales.  La mayor√≠a de las instrucciones x86 son compatibles actualmente.  Las instrucciones de coprocesador matem√°tico para trabajar con n√∫meros de coma flotante y desde extensiones (MMX, SSE, AVX) a√∫n no son compatibles.  Es posible declarar constantes, procedimientos, variables de pila locales, variables globales, cuya memoria se asigna durante la traducci√≥n directamente en una matriz con c√≥digo binario (si estas variables se nombran usando etiquetas, entonces su valor tambi√©n se puede obtener de C # despu√©s de realizar la inserci√≥n llamando a m√©todos <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> y <code>GetWStringVariable()</code> del objeto <code>SASMCode</code> ), las macros <code>addr</code> e <code>SASMCode</code> est√°n presentes.  Una de las caracter√≠sticas importantes es el soporte para importar funciones de bibliotecas externas usando la construcci√≥n <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> macro merece un p√°rrafo separado.  En el proceso de traducci√≥n, se desarrolla en 11 instrucciones que forman el ep√≠logo.  El pr√≥logo se agrega al comienzo del c√≥digo traducido de forma predeterminada.  Su tarea es guardar / restaurar el estado del procesador.  Adem√°s, el pr√≥logo agrega cuatro constantes: <code>$first</code> , <code>$second</code> , <code>$this</code> y <code>$return</code> .  Durante la traducci√≥n, estas constantes se reemplazan por direcciones en la pila, en las cuales, respectivamente, se encuentran el primer y el segundo argumento pasados ‚Äã‚Äãal inserto del ensamblador, la direcci√≥n del primer comando de inserci√≥n y la direcci√≥n de retorno. <br><br><h2>  Resumen </h2><br>  El c√≥digo dir√° mucho m√°s que palabras, y ser√≠a extra√±o no compartir el resultado de un trabajo bastante largo, por lo que invito a todos los que estoy interesado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  Sin embargo, si trato de generalizar de alguna manera todo lo que se ha hecho, entonces, en mi opini√≥n, ha resultado un proyecto interesante e incluso, hasta cierto punto, no in√∫til.  Por ejemplo, algoritmos id√©nticos para ordenar insertos en C # y usar insertos de ensamblador difieren en velocidad en m√°s de dos veces (por supuesto, a favor del ensamblador).  En proyectos serios, por supuesto, no se recomienda usar la biblioteca resultante (los efectos secundarios impredecibles son posibles, aunque no muy probables), pero es bastante posible para usted. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464931/">https://habr.com/ru/post/464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464919/index.html">Control de recursos incorporado de RAM utilizada en la aplicaci√≥n.</a></li>
<li><a href="../464921/index.html">System.IO.Pipelines: una herramienta poco conocida para los amantes del alto rendimiento</a></li>
<li><a href="../464925/index.html">Gu√≠a de voz UX: situaciones, patrones, herramientas (y un poco de apoyo moral)</a></li>
<li><a href="../464927/index.html">Minero ASIC de segunda mano: riesgos, verificaci√≥n y hashrate recableado</a></li>
<li><a href="../464929/index.html">Carga diferida de la imagen del navegador (atributo de carga)</a></li>
<li><a href="../464933/index.html">Aplicaciones para libros electr√≥nicos en el sistema operativo Android. Parte 4. Juegos</a></li>
<li><a href="../464935/index.html">C√≥modo DevOpsSec: Nemesida WAF Gratis para NGINX con API y cuenta personal</a></li>
<li><a href="../464937/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 312 (del 19 al 25 de agosto)</a></li>
<li><a href="../464939/index.html">Prueba de anotaciones @ no nulas / @ anulables</a></li>
<li><a href="../464947/index.html">Eventos digitales en Mosc√∫ del 25 de agosto al 1 de septiembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>