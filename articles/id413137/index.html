<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ”¬ ğŸ’‡ğŸ¼ ğŸ‘º Klasifikasi sejumlah besar data pada Apache Spark menggunakan model pembelajaran mesin sewenang-wenang ğŸ¤³ğŸ¾ ğŸ—¯ï¸ ğŸŒ˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1: Pernyataan Masalah 
 Halo, Habr! Saya seorang arsitek solusi di CleverDATA. Hari ini saya akan berbicara tentang bagaimana kita mengklasifik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klasifikasi sejumlah besar data pada Apache Spark menggunakan model pembelajaran mesin sewenang-wenang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413137/"><h2>  Bagian 1: Pernyataan Masalah </h2><br>  Halo, Habr!  Saya seorang arsitek solusi di CleverDATA.  Hari ini saya akan berbicara tentang bagaimana kita mengklasifikasikan data dalam jumlah besar menggunakan model yang dibangun menggunakan hampir semua perpustakaan pembelajaran mesin yang tersedia.  Dalam seri dua bagian ini, kami akan mempertimbangkan pertanyaan-pertanyaan berikut. <br><br><ul><li>  Bagaimana cara menyajikan model pembelajaran mesin sebagai layanan (Model as a Service)? </li><li>  Bagaimana tugas pemrosesan terdistribusi data dalam jumlah besar dilakukan secara fisik menggunakan Apache Spark? </li><li>  Masalah apa yang muncul ketika Apache Spark berinteraksi dengan layanan eksternal? </li><li>  Bagaimana interaksi Apache Spark dengan layanan eksternal diorganisasikan menggunakan pustaka akka-stream dan akka-http, serta pendekatan Reactive Streams? </li></ul><br>  Awalnya, saya berencana untuk menulis satu artikel, tetapi karena volume materi ternyata cukup besar, saya memutuskan untuk memecahnya menjadi dua bagian.  Hari ini di bagian pertama kita akan mempertimbangkan pernyataan umum masalah, serta masalah utama yang perlu diselesaikan selama implementasi.  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua,</a> kita akan berbicara tentang implementasi praktis dari solusi untuk masalah ini menggunakan pendekatan Reactive Streams. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/8g/p2/pv8gp2gxotjij6hjkkirlllzlii.png"></div><a name="habracut"></a><br>  Perusahaan kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CleverDATA</a> memiliki tim analis data yang, dengan bantuan berbagai alat (seperti scikit-learn, facebook fastText, xgboost, tensorFlow, dll.), Melatih model pembelajaran mesin.  Bahasa pemrograman inti de facto yang digunakan analis adalah Python.  Hampir semua perpustakaan untuk pembelajaran mesin, bahkan awalnya diimplementasikan dalam bahasa lain, memiliki antarmuka Python dan terintegrasi dengan perpustakaan Python utama (terutama dengan NumPy). <br><br>  Di sisi lain, ekosistem Hadoop banyak digunakan untuk menyimpan dan memproses sejumlah besar data tidak terstruktur.  Di dalamnya, data disimpan pada sistem file HDFS dalam bentuk blok replikasi terdistribusi dengan ukuran tertentu (biasanya 128 MB, tetapi dimungkinkan untuk dikonfigurasi).  Algoritma pemrosesan data terdistribusi yang paling efisien mencoba meminimalkan interaksi jaringan antara mesin cluster.  Untuk melakukan ini, data harus diproses pada mesin yang sama di mana mereka disimpan. <br><br>  Tentu saja, dalam banyak kasus, interaksi jaringan tidak dapat sepenuhnya dihindari, tetapi, bagaimanapun, Anda perlu mencoba untuk melakukan semua tugas secara lokal dan meminimalkan jumlah data yang perlu dikirim melalui jaringan. <br><br>  Prinsip pemrosesan data terdistribusi ini disebut "pindahkan perhitungan dekat dengan data".  Semua kerangka kerja utama, terutama Hadoop MapReduce dan Apache Spark, mematuhi prinsip ini.  Mereka menentukan komposisi dan urutan operasi spesifik yang perlu dijalankan pada mesin di mana blok data yang diperlukan disimpan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qs/os/nw/qsosnwsibgwo5ajbmzg-v4la7m0.png"></div>  <i>Gambar 1. Cluster HDFS terdiri dari beberapa mesin, salah satunya adalah Name Node, dan sisanya adalah Data Node.</i>  <i>Name Node menyimpan informasi tentang file yang membentuk blok mereka, dan tentang mesin di mana mereka berada secara fisik.</i>  <i>Blok itu sendiri disimpan di Data Node, yang direplikasi ke beberapa mesin untuk meningkatkan keandalan.</i>  <i>Data Node juga menjalankan tugas pemrosesan data.</i>  <i>Tugas terdiri dari proses utama (Master, M), yang mengoordinasikan peluncuran proses kerja (Pekerja, W) pada mesin di mana blok data yang diperlukan disimpan.</i> <br><br>  Hampir semua komponen ekosistem Hadoop diluncurkan menggunakan Java Virtual Machine (JVM) dan terintegrasi erat satu sama lain.  Misalnya, untuk menjalankan tugas yang ditulis menggunakan Apache Spark untuk bekerja dengan data yang disimpan pada HDFS, hampir tidak ada manipulasi tambahan yang diperlukan: kerangka kerja ini menyediakan fungsionalitas ini di luar kotak. <br><br>  Sayangnya, sebagian besar perpustakaan yang dirancang untuk pembelajaran mesin menganggap bahwa data disimpan dan diproses secara lokal.  Pada saat yang sama, ada perpustakaan yang terintegrasi erat dengan ekosistem Hadoop, misalnya, Spark ML atau Apache Mahout.  Namun, mereka memiliki sejumlah kelemahan signifikan.  Pertama, mereka menyediakan implementasi algoritma pembelajaran mesin yang jauh lebih sedikit.  Kedua, tidak semua analis data dapat bekerja dengannya.  Keuntungan dari perpustakaan ini termasuk fakta bahwa mereka dapat digunakan untuk melatih model pada volume data yang besar menggunakan komputasi terdistribusi. <br><br>  Namun, analis data sering menggunakan metode alternatif untuk melatih model, khususnya perpustakaan yang memungkinkan penggunaan GPU.  Saya tidak akan mempertimbangkan masalah model pelatihan dalam artikel ini, karena saya ingin fokus pada penggunaan model yang sudah jadi yang dibangun menggunakan perpustakaan pembelajaran mesin yang tersedia untuk mengklasifikasikan sejumlah besar data. <br><br>  Jadi, tugas utama yang kami coba selesaikan di sini adalah untuk menerapkan model pembelajaran mesin pada sejumlah besar data yang disimpan di HDFS.  Jika kita dapat menggunakan modul SparkML dari perpustakaan Apache Spark, yang mengimplementasikan algoritma pembelajaran mesin dasar, maka mengklasifikasikan sejumlah besar data akan menjadi tugas yang sepele: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> model: <span class="hljs-type"><span class="hljs-type">LogisticRegressionModel</span></span> = <span class="hljs-type"><span class="hljs-type">LogisticRegressionModel</span></span>.load(<span class="hljs-string"><span class="hljs-string">"/path/to/model"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataset = spark.read.parquet(<span class="hljs-string"><span class="hljs-string">"/path/to/data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = model.transform(dataset)</code> </pre> <br>  Sayangnya, pendekatan ini hanya berfungsi untuk algoritma yang diterapkan dalam modul SparkML (daftar lengkap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Dalam hal menggunakan perpustakaan lain, apalagi, diimplementasikan bukan pada JVM, semuanya menjadi jauh lebih rumit. <br><br>  Untuk mengatasi masalah ini, kami memutuskan untuk membungkus model dalam layanan REST.  Karena itu, ketika memulai tugas mengklasifikasikan data yang disimpan pada HDFS, perlu untuk mengatur interaksi antara mesin tempat data disimpan dan mesin (atau kelompok mesin) tempat layanan klasifikasi berjalan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/8g/p2/pv8gp2gxotjij6hjkkirlllzlii.png"></div>  <i>Gambar 2. Konsep Model sebagai Layanan</i> <br><br><h3>  Deskripsi layanan klasifikasi python </h3><br>  Untuk menyajikan model sebagai layanan, perlu untuk menyelesaikan tugas-tugas berikut: <br><br><ol><li>  menerapkan akses efisien ke model melalui HTTP; </li><li>  memastikan penggunaan sumber daya mesin yang paling efisien (terutama semua inti prosesor dan memori); </li><li>  memberikan ketahanan terhadap beban tinggi; </li><li>  memberikan kemampuan untuk skala secara horizontal. </li></ol><br>  Akses ke model melalui HTTP cukup sederhana untuk diterapkan: sejumlah besar perpustakaan telah dikembangkan untuk Python yang memungkinkan Anda untuk menerapkan titik akses REST menggunakan sejumlah kecil kode.  Salah satu dari microframes ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flask</a> .  Implementasi layanan klasifikasi pada Flask adalah sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask, request, Response model = load_model() n_features = <span class="hljs-number"><span class="hljs-number">100</span></span> app = Flask(__name__) @app.route(<span class="hljs-string"><span class="hljs-string">"/score"</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">score</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> inp = np.frombuffer(request.data, dtype=<span class="hljs-string"><span class="hljs-string">'float32'</span></span>).reshape(<span class="hljs-number"><span class="hljs-number">-1</span></span>, n_features) result = model.predict(inp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response(result.tobytes(), mimetype=<span class="hljs-string"><span class="hljs-string">'application/octet-stream'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: app.run()</code> </pre> <br>  Di sini, ketika layanan dimulai, kami memuat model ke dalam memori, dan kemudian menggunakannya saat memanggil metode klasifikasi.  Fungsi load_model memuat model dari beberapa sumber eksternal, baik itu sistem file, penyimpanan nilai kunci, dll. <br><br>  Model adalah objek yang memiliki metode prediksi.  Dalam kasus klasifikasi, dibutuhkan input ke beberapa vektor fitur dengan ukuran tertentu dan menghasilkan nilai Boolean yang menunjukkan apakah vektor yang ditentukan cocok untuk model ini, atau beberapa nilai dari 0 hingga 1, yang kemudian dapat Anda terapkan ambang batas cutoff: semuanya di atas ambang batas, adalah hasil positif dari klasifikasi, sisanya tidak. <br><br>  Vektor fitur yang kita perlu mengklasifikasikan dilewatkan dalam bentuk biner dan deserialized ke array numpy.  Ini akan menjadi overhead untuk membuat permintaan HTTP untuk setiap vektor.  Misalnya, dalam kasus vektor 100 dimensi dan menggunakan untuk nilai tipe float32, permintaan HTTP lengkap, termasuk header, akan terlihat seperti ini: <br><br><pre> <code class="hljs powershell">PUT /score HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: score<span class="hljs-literal"><span class="hljs-literal">-node</span></span><span class="hljs-literal"><span class="hljs-literal">-1</span></span>:<span class="hljs-number"><span class="hljs-number">8099</span></span> User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.58</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> Accept: */* Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/binary Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span> [<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span><span class="hljs-type"><span class="hljs-type">s</span></span> <span class="hljs-type"><span class="hljs-type">of</span></span> <span class="hljs-type"><span class="hljs-type">data</span></span>]</code> </pre> <br>  Seperti yang Anda lihat, efisiensi permintaan seperti itu sangat rendah (400 byte payload / (133 byte byte + 400 byte tubuh) = 75%).  Untungnya, di hampir semua perpustakaan, metode prediksi memungkinkan Anda untuk menerima bukan vektor [1 xn], tetapi matriks [mxn], dan, dengan demikian, hasilkan segera untuk nilai input m. <br><br>  Selain itu, perpustakaan numpy dioptimalkan untuk bekerja dengan matriks besar, memungkinkan Anda untuk secara efektif menggunakan semua sumber daya mesin yang tersedia.  Jadi, kita dapat mengirim bukan hanya satu tetapi sejumlah besar fitur vektor dalam satu permintaan, deserialize mereka menjadi matriks numpy ukuran [mxn], mengklasifikasikan, dan mengembalikan vektor [mx 1] dari nilai Boolean atau float32.  Akibatnya, efisiensi interaksi HTTP saat menggunakan matriks 1000 baris menjadi hampir sama dengan 100%.  Ukuran tajuk HTTP dalam hal ini dapat diabaikan. <br><br>  Untuk menguji layanan Flask di mesin lokal, Anda dapat menjalankannya dari baris perintah.  Namun, metode ini sama sekali tidak cocok untuk penggunaan industri.  Faktanya adalah bahwa Flask adalah single-threaded dan, jika kita melihat diagram beban prosesor saat layanan sedang berjalan, kita akan melihat bahwa satu core 100% dimuat, dan sisanya tidak aktif.  Untungnya, ada cara untuk menggunakan semua kernel mesin: untuk ini, Flask perlu dijalankan melalui server aplikasi web uwsgi.  Ini memungkinkan Anda untuk mengkonfigurasi jumlah proses dan utas secara optimal untuk memastikan beban yang seragam pada semua inti prosesor.  Rincian lebih lanjut tentang semua opsi untuk mengkonfigurasi uwsgi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Lebih baik menggunakan nginx sebagai titik masuk HTTP, karena uwsgi dapat bekerja secara tidak stabil jika bebannya tinggi.  Nginx, di sisi lain, mengambil seluruh aliran input permintaan ke dirinya sendiri, menyaring permintaan yang tidak valid, dan dosis beban pada uwsgi.  Nginx berkomunikasi dengan uwsgi melalui soket linux menggunakan file proses.  Contoh konfigurasi nginx ditunjukkan di bawah ini: <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span> <span class="hljs-variable"><span class="hljs-variable">@score</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@score</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> uwsgi_params; <span class="hljs-attribute"><span class="hljs-attribute">uwsgi_pass</span></span> unix:/tmp/score.sock; } }</code> </pre><br>  Seperti yang dapat kita lihat, itu ternyata merupakan konfigurasi yang agak rumit untuk satu mesin.  Jika kita perlu mengklasifikasikan data dalam jumlah besar, sejumlah besar permintaan akan datang ke layanan ini, dan itu bisa menjadi hambatan.  Solusi untuk masalah ini adalah penskalaan horizontal. <br><br>  Untuk kenyamanan, kami mengemas layanan dalam wadah Docker dan kemudian menyebarkannya pada jumlah mesin yang diperlukan.  Jika diinginkan, Anda dapat menggunakan alat penyebaran otomatis seperti Kubernetes.  Contoh struktur Dockerfile untuk membuat wadah dengan layanan diberikan di bawah ini. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ubuntu #Installing required ubuntu <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> python modules RUN apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> RUN apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y install python3 python3-pip nginx RUN <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>-alternatives <span class="hljs-comment"><span class="hljs-comment">--install /usr/bin/python python /usr/bin/python3 1 RUN update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 RUN pip install uwsgi flask scipy scikit-learn #copying script files WORKDIR /etc/score COPY score.py . COPY score.ini . COPY start.sh . RUN chmod +x start.sh RUN rm /etc/nginx/sites-enabled/default COPY score.nginx /etc/nginx/sites-enabled/ EXPOSE 80 ENTRYPOINT ["./start.sh"]</span></span></code> </pre> <br>  Jadi, struktur layanan untuk klasifikasi adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/4b/c7/fz4bc7kha2wb_dbhck4gifa52ho.png"></div>  <i>Gambar 3. Skema layanan untuk klasifikasi</i> <br><br><h3>  Ringkasan singkat pekerjaan Apache Spark di ekosistem Hadoop </h3><br>  Sekarang pertimbangkan proses pemrosesan data yang disimpan pada HDFS.  Seperti yang saya sebutkan sebelumnya, prinsip mentransfer perhitungan ke data digunakan untuk ini.  Untuk mulai memproses tugas, Anda perlu tahu di mesin mana blok data yang kami butuhkan disimpan untuk menjalankan proses yang terlibat langsung dalam memprosesnya.  Anda juga perlu mengoordinasikan peluncuran proses ini, memulai kembali jika terjadi keadaan darurat, jika perlu, mengagregasikan hasil dari berbagai subtugas, dll. <br><br>  Semua tugas ini diselesaikan oleh berbagai kerangka kerja yang bekerja dengan ekosistem Hadoop.  Salah satu yang paling populer dan nyaman adalah Apache Spark.  Konsep utama di mana seluruh kerangka kerja dibangun adalah RDD (Resilient Distributed Dataset).  Secara umum, RDD dapat dianggap sebagai koleksi terdistribusi yang tahan-drop.  RDD dapat diperoleh dengan dua cara utama: <br><br><ol><li>  pembuatan dari sumber eksternal, seperti koleksi dalam memori, file atau direktori pada sistem file, dll. </li><li>  konversi dari RDD lain dengan menerapkan operasi transformasi.  RDD mendukung semua operasi dasar bekerja dengan koleksi, seperti peta, flatMap, filter, groupBy, gabung, dll. </li></ol><br>  Penting untuk dipahami bahwa RDD, tidak seperti koleksi, bukan secara langsung data, tetapi urutan operasi yang harus dilakukan pada data.  Oleh karena itu, ketika operasi transformasi dipanggil, tidak ada pekerjaan yang benar-benar terjadi, dan kami hanya mendapatkan RDD baru, yang akan berisi satu operasi lebih banyak daripada yang sebelumnya.  Pekerjaan itu sendiri dimulai ketika yang disebut operasi terminal, atau tindakan, dipanggil.  Ini termasuk menyimpan ke file, menyimpan ke koleksi di memori, menghitung jumlah elemen, dll. <br><br>  Ketika memulai operasi terminal, Spark membangun grafik operasi asiklik (DAG, Grafik Asiklik Langsung) berdasarkan RDD yang dihasilkan dan menjalankannya secara berurutan pada kluster sesuai dengan grafik yang diterima.  Ketika membangun DAG berdasarkan RDD, Spark melakukan sejumlah optimasi, misalnya, jika mungkin, menggabungkan beberapa transformasi berturut-turut menjadi satu operasi. <br><br>  RDD adalah unit utama interaksi dengan API Spark dalam versi Spark 1.x.  Dalam Spark 2.x, para pengembang mengatakan bahwa sekarang konsep utama untuk interaksi adalah Dataset.  Dataset adalah add-on untuk RDD dengan dukungan untuk interaksi seperti SQL.  Saat menggunakan Dataset API, Spark memungkinkan Anda untuk menggunakan berbagai optimisasi, termasuk yang tingkatannya cukup rendah.  Tetapi secara umum, prinsip-prinsip dasar yang berlaku untuk RDD juga berlaku untuk Dataset. <br><br>  Rincian lebih lanjut tentang karya Spark dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi di situs web resmi</a> . <br><br>  Mari kita perhatikan contoh klasifikasi paling sederhana tentang Spark tanpa menggunakan layanan eksternal.  Algoritma yang agak tidak berarti diterapkan di sini, yang mempertimbangkan proporsi masing-masing huruf Latin dalam teks, dan kemudian mempertimbangkan standar deviasi.  Di sini, pertama-tama, penting untuk memperhatikan langsung langkah-langkah dasar yang digunakan saat bekerja dengan Spark. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, text: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">Float</span></span> = ??? <span class="hljs-comment"><span class="hljs-comment">//(2) val ds: Dataset[Data] = spark.read.parquet("/path/to/data").as[Data] //(3) val result: Dataset[Score] = ds.map {d: Data =&gt; //(4) val filteredText = d.text.toLowerCase.filter { letter =&gt; 'a' &lt;= letter &amp;&amp; letter &lt;= 'z' } val featureVector = new Array[Float](26) if (filteredText.nonEmpty) { filteredText.foreach(letter =&gt; featureVector(letter) += 1) featureVector.indicies.foreach { i =&gt; featureVector(i) = featureVector(i) / filteredText.length() } } Features(d.id, featureVector) }.map {f: Features =&gt; Score(f.id, std(f.vector)) //(5) } result.write.parquet("/path/to/result") //(6)</span></span></code> </pre><br>  Dalam contoh ini, kami: <br><br><ol><li>  kami menentukan struktur input, menengah dan data keluaran (data input didefinisikan sebagai beberapa teks yang terkait dengan pengidentifikasi tertentu, data menengah cocok dengan pengidentifikasi dengan vektor fitur, dan output cocok dengan pengidentifikasi dengan beberapa nilai numerik); </li><li>  kami mendefinisikan fungsi untuk menghitung nilai yang dihasilkan oleh vektor fitur (misalnya, standar deviasi, implementasi tidak ditampilkan); </li><li>  mendefinisikan Dataset asli sebagai data yang disimpan pada HDFS dalam format parket di sepanjang jalur / path / ke / data; </li><li>  Tetapkan Dataset perantara sebagai peta bitmap dari Dataset asli. </li><li>  Demikian pula, kami menentukan Dataset yang dihasilkan melalui transformasi bitwise dari perantara; </li><li>  simpan Dataset yang dihasilkan ke HDFS dalam format parket di sepanjang jalur / path / ke / hasil.  Karena menyimpan ke file adalah operasi terminal, perhitungan sendiri diluncurkan tepat pada tahap ini. </li></ol><br>  Apache Spark bekerja berdasarkan prinsip master-pekerja.  Ketika aplikasi dimulai, proses utama, yang disebut driver, dimulai.  Itu mengeksekusi kode yang bertanggung jawab untuk pembentukan RDD, atas dasar di mana perhitungan akan dilakukan. <br><br>  Ketika operasi terminal dipanggil, pengemudi menghasilkan DAG berdasarkan RDD yang dihasilkan.  Kemudian pengemudi memulai peluncuran alur kerja yang disebut pelaksana, di mana data akan diproses secara langsung.  Setelah memulai alur kerja, driver melewatinya blok yang dapat dieksekusi yang perlu dieksekusi, dan juga menunjukkan bagian data mana yang harus diterapkan. <br><br>  Di bawah ini adalah kode dari contoh kita, di mana bagian-bagian kode yang dieksekusi pada eksekutor (antara baris eksekutor bagian dimulai dan eksekutor bagian akhir) disorot.  Sisa kode dieksekusi pada driver. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, text: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">Float</span></span> = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: <span class="hljs-type"><span class="hljs-type">Dataset</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = spark.read.parquet(<span class="hljs-string"><span class="hljs-string">"/path/to/data"</span></span>).as[<span class="hljs-type"><span class="hljs-type">Data</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: <span class="hljs-type"><span class="hljs-type">Dataset</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = ds.map { <span class="hljs-comment"><span class="hljs-comment">// --------------- EXECUTOR PART BEGIN ----------------------- d: Data =&gt; val filteredText = d.text.toLowerCase.filter { letter =&gt; 'a' &lt;= letter &amp;&amp; letter &lt;= 'z' } val featureVector = new Array[Float](26) if (filteredText.nonEmpty) { filteredText.foreach(letter =&gt; featureVector(letter) += 1) featureVector.indicies.foreach { i =&gt; featureVector(i) = featureVector(i) / filteredText.length() } } Features(d.id, featureVector) // --------------- EXECUTOR PART END ----------------------- }.map { // --------------- EXECUTOR PART BEGIN ----------------------- f: Features =&gt; Score(f.id, std(f.vector)) // --------------- EXECUTOR PART END ----------------------- } result.write.parquet(â€œ/path/to/resultâ€)</span></span></code> </pre><br>  Dalam ekosistem Hadoop, semua aplikasi berjalan dalam wadah.  Wadah adalah proses yang berjalan di salah satu mesin dalam sebuah cluster yang dialokasikan sejumlah sumber daya.  Peluncuran kontainer ditangani oleh YARN Resource Manager.  Ini menentukan mesin mana yang memiliki jumlah inti prosesor dan RAM yang cukup, serta apakah itu berisi blok data yang diperlukan untuk diproses. <br><br>  Saat meluncurkan aplikasi Spark, YARN membuat dan menjalankan kontainer di salah satu mesin cluster di mana ia meluncurkan driver.  Kemudian, ketika pengemudi menyiapkan DAG dari operasi yang perlu dijalankan pada eksekutor, YARN meluncurkan kontainer tambahan pada mesin yang diinginkan. <br><br>  Sebagai aturan, sudah cukup bagi pengemudi untuk mengalokasikan satu inti dan sejumlah kecil memori (kecuali, tentu saja, maka hasil perhitungan tidak akan diagregasi pada driver ke dalam memori).  Untuk pelaksana, untuk mengoptimalkan sumber daya dan mengurangi jumlah total proses dalam sistem, lebih dari satu inti dapat dibedakan: dalam hal ini, pelaksana akan dapat melakukan beberapa tugas secara bersamaan. <br><br>  Tetapi di sini penting untuk memahami bahwa jika terjadi kegagalan dari salah satu tugas yang berjalan di wadah atau jika sumber daya tidak mencukupi, YARN dapat memutuskan untuk menghentikan wadah, dan kemudian semua tugas yang dieksekusi di dalamnya harus dimulai kembali pada pelaksana lain.  Selain itu, jika kami mengalokasikan jumlah core yang cukup besar per kontainer, maka kemungkinan YARN tidak akan dapat memulainya.  Sebagai contoh, jika kita memiliki dua mesin yang dua core tidak digunakan, maka kita dapat memulai pada setiap kontainer yang membutuhkan dua core, tetapi tidak dapat memulai satu kontainer yang membutuhkan empat core. <br><br>  Sekarang mari kita lihat bagaimana kode dari contoh kita akan dieksekusi langsung di cluster.  Bayangkan bahwa ukuran data sumber adalah 2 Terabyte.  Dengan demikian, jika ukuran blok pada HDFS adalah 128 megabita, maka akan ada total 16384 blok.  Setiap blok direplikasi ke beberapa mesin untuk memastikan keandalan.  Untuk kesederhanaan, kita ambil faktor replikasi sama dengan dua, yaitu, akan ada total 32768 blok yang tersedia.  Misalkan kita menggunakan sekelompok 16 mesin untuk penyimpanan.  Dengan demikian, pada masing-masing mesin dalam hal distribusi seragam akan ada sekitar 2048 blok, atau 256 Gigabytes per mesin.  Di setiap mesin, kami memiliki 8 inti prosesor dan 64 gigabytes RAM. <br><br>  Untuk tugas kami, driver tidak memerlukan banyak sumber daya, jadi kami akan mengalokasikan 1 inti dan 1 GB memori untuk itu.  Kami akan memberikan pemain 2 core dan 4 GB memori.  Misalkan kita ingin memaksimalkan penggunaan sumber daya klaster.  Dengan demikian, kami mendapatkan 64 kontainer: satu untuk pengemudi, dan 63 untuk pemain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/qu/rc/uwqurc3i8v7wagn1zfexu-3dfgo.png"></div>  <i>Gambar 4. Proses yang berjalan pada Node Data dan sumber daya yang mereka gunakan.</i> <br><br>  Karena dalam kasus kami, kami hanya menggunakan operasi peta, DAG kami akan terdiri dari satu operasi.  Ini terdiri dari tindakan berikut: <br><br><ol><li>  ambil satu blok data dari hard drive lokal, </li><li>  Konversi data </li><li>  simpan hasilnya ke blok baru di disk lokal Anda sendiri. </li></ol><br>  Secara total, kita perlu memproses 16384 blok, sehingga setiap pelaksana harus melakukan 16384 / (63 pelaksana * 2 inti) = 130 operasi.  Dengan demikian, siklus hidup pelaksana sebagai proses yang terpisah (jika semuanya terjadi tanpa jatuh) akan terlihat sebagai berikut. <br><br><ol><li>  Peluncuran kontainer. </li><li>  Menerima dari pengemudi tugas di mana akan ada pengidentifikasi blok dan operasi yang diperlukan.  Karena kami mengalokasikan dua inti ke wadah, pelaksana menerima dua tugas sekaligus. </li><li>  Melakukan tugas dan mengirimkan hasilnya ke pengemudi. </li><li>  Dapatkan tugas berikutnya dari driver dan ulangi langkah 2 dan 3 sampai semua blok untuk mesin lokal ini diproses. </li><li>  Kontainer Berhenti </li></ol><br>  <i>Catatan</i> : DAG yang lebih kompleks diperoleh jika perlu untuk mendistribusikan kembali data antara antara mesin, biasanya untuk operasi pengelompokan (groupBy, lessByKey, dll.) Dan koneksi (bergabung), pertimbangan yang berada di luar ruang lingkup artikel ini. <br><br><h3>  Masalah utama interaksi antara Apache Spark dan layanan eksternal </h3><br>  Jika, dalam kerangka operasi peta, kita perlu mengakses beberapa layanan eksternal, tugas menjadi kurang sepele.  Misalkan objek kelas ExternalServiceClient bertanggung jawab untuk berinteraksi dengan layanan eksternal.  Secara umum, sebelum mulai bekerja, kita perlu menginisialisasi, dan menyebutnya seperlunya: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = <span class="hljs-type"><span class="hljs-type">ExternalServiceClient</span></span>.create() <span class="hljs-comment"><span class="hljs-comment">// val score = client.score(featureVector) // .</span></span></code> </pre><br>  Biasanya, inisialisasi klien membutuhkan waktu, oleh karena itu, sebagai aturan, inisialisasi diinisialisasi pada startup aplikasi, dan kemudian digunakan untuk mendapatkan instance klien dari beberapa konteks global atau kumpulan.  Oleh karena itu, ketika sebuah wadah dengan pelaksana Spark menerima tugas yang memerlukan interaksi dengan layanan eksternal, alangkah baiknya untuk mendapatkan klien yang sudah diinisialisasi sebelum mulai bekerja pada array data, dan kemudian menggunakannya kembali untuk setiap elemen. <br><br>  Ada dua cara untuk melakukan ini di Spark.  Pertama, jika klien serializable (klien itu sendiri dan semua bidangnya harus memperluas antarmuka java.io.Serializable), maka dapat diinisialisasi pada driver dan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diteruskan ke pelaksana melalui mekanisme variabel siaran</a> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = <span class="hljs-type"><span class="hljs-type">ExternalServiceClient</span></span>.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clientBroadcast = sparkContext.broadcast(client) ds.map { f: <span class="hljs-type"><span class="hljs-type">Features</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> score = clientBroadcast.value.score(f.vector) <span class="hljs-type"><span class="hljs-type">Score</span></span>(f.id, score) }</code> </pre><br>  Dalam hal klien tidak serializable, atau inisialisasi klien adalah proses yang tergantung pada pengaturan mesin tertentu yang menjalankannya (misalnya, untuk menyeimbangkan, permintaan dari satu bagian mesin harus pergi ke mesin layanan pertama, dan untuk yang lain ke yang kedua), maka klien dapat diinisialisasi langsung pada pelaksana. <br><br>  Untuk ini, RDD (dan Dataset) memiliki operasi mapPartitions, yang merupakan versi umum dari operasi peta (jika Anda melihat kode sumber dari kelas RDD, maka operasi peta diimplementasikan melalui mapPartitions).  Fungsi yang diteruskan ke operasi mapPartitions dijalankan sekali untuk setiap blok.        ,      ,          ,   : <br><br><pre> <code class="scala hljs">ds.mapPartitions {fi: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>[<span class="hljs-type"><span class="hljs-type">Features</span></span>] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = <span class="hljs-type"><span class="hljs-type">ExternalServiceClient</span></span>.create() fi.map { f: <span class="hljs-type"><span class="hljs-type">Features</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> score = client.score(f.vector) <span class="hljs-type"><span class="hljs-type">Score</span></span>(f.id, score) } }</code> </pre><br>             . , , ,         ,         .     ,    ,               ,    . <br><br>      . ,             hasNext  next: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> item = i.next() â€¦ }</code> </pre><br>        ,         ,    . ,       8 ,  YARN       4    2 , ,     8   .       ,               .         . <br><br>          .       ,         , ,    ,   .        :    ,    ,       .   ,     hasNext       ,      .    (,          ,       )     ,   ,    ,    . , <i>    </i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4_/hn/vl/4_hnvluet1tc0lvq68urw9ij5fi.png" width="550"></div> <i> 5.   ,     ,   mapPartitions,    .        .</i> <br><br>   ,       ,       . ,         ,    ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0e/dm/yy/0edmyyfjkekpdp5f0ncx84tevei.png" width="450"></div> <i> 6.          </i> <br><br>   ,       ,  , -,        ,      , , -,      ,     . <br><br><h3>    </h3><br>  ,          .  ,            .               ,           .          ,     . ,      ,     ,  ,    , ,    . <br><br>         . <br><br><ol><li>  ,       ,       ,          . </li><li>  ,            ,    .          ,     .                         ,      . </li><li>  ,      hasNext  false,    ,       ,    ,       .      :         hasNext = false, , ,    .    ,       ,     ,           . </li></ol><br>  ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . Stay tuned! <br><br><div class="spoiler"> <b class="spoiler_title">     ,  ,    ?</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembang Java</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insinyur sistem</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413137/">https://habr.com/ru/post/id413137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413125/index.html">Terapi gen memberi pasien kecil dengan atrofi otot kesempatan untuk bertahan hidup</a></li>
<li><a href="../id413127/index.html">Beberapa kata tentang kinerja nyata dari hypervisor</a></li>
<li><a href="../id413129/index.html">25 kesalahan seorang programmer pemula</a></li>
<li><a href="../id413133/index.html">Antipatterns populer: pagination</a></li>
<li><a href="../id413135/index.html">Penugasan tes review kode pengembang reaksi junior</a></li>
<li><a href="../id413139/index.html">Mobil listrik: revolusi akan datang</a></li>
<li><a href="../id413141/index.html">Klasifikasi sejumlah besar data pada Apache Spark menggunakan model pembelajaran mesin sewenang-wenang</a></li>
<li><a href="../id413143/index.html">Bobby Urban Lite: New Urban Backpack XD Design</a></li>
<li><a href="../id413145/index.html">Analis membantu bisnis menghasilkan uang</a></li>
<li><a href="../id413147/index.html">Apakah mungkin menggunakan Tibero alih-alih Oracle. Dan apakah itu perlu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>