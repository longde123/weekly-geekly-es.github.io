<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🔬 🧑🏾‍🤝‍🧑🏼 💾 Pourquoi Kubernetes est-il si compliqué avec les référentiels? 👨🏾‍🏭 👨‍❤️‍👨 🦐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque les orchestrateurs de conteneurs comme Kubernetes sont arrivés, l'approche du développement et du déploiement d'applications a radicalement ch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi Kubernetes est-il si compliqué avec les référentiels?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441222/"><p><img src="https://habrastorage.org/webt/3w/v4/sh/3wv4sha9sfamx7elh4imtocvesm.jpeg"></p><br><p>  Lorsque les orchestrateurs de conteneurs comme Kubernetes sont arrivés, l'approche du développement et du déploiement d'applications a radicalement changé.  Des microservices sont apparus, et pour le développeur, la logique applicative n'est plus connectée à l'infrastructure: créez des applications pour vous et offrez de nouvelles fonctions. </p><br><p>  Kubernetes résume les ordinateurs physiques qu'il contrôle.  Dites-lui simplement la quantité de mémoire et de puissance de traitement dont vous avez besoin - et vous obtiendrez tout.  Infrastructure?  Non, pas entendu. </p><br><p>  La gestion des images Docker, Kubernetes et des applications le rend portable.  Après avoir développé des applications de conteneur avec Kubernetes, vous pouvez les déployer n'importe où: dans un cloud ouvert, localement ou dans un environnement hybride - sans changer le code. </p><br><p>  Nous aimons Kubernetes pour l'évolutivité, la portabilité et la gérabilité, mais il ne stocke pas l'état.  Mais nous avons presque toutes les applications avec état, c'est-à-dire qu'elles ont besoin d'un stockage externe. </p><a name="habracut"></a><br><p>  Kubernetes a une architecture très dynamique.  Les conteneurs sont créés et détruits en fonction de la charge et des instructions des développeurs.  Les gousses et les conteneurs sont auto-réparateurs et se répliquent.  Ils sont essentiellement éphémères. </p><br><p>  <strong>Le stockage externe est trop difficile pour une telle variabilité.</strong>  <strong>Il n'obéit pas aux règles de création et de destruction dynamiques.</strong> </p><br><p> Il suffit de déployer une application avec état dans une autre infrastructure: dans un autre cloud, localement ou dans un modèle hybride - comment elle a des problèmes de portabilité.  Le stockage externe peut être lié à un cloud spécifique. </p><br><p>  Mais ce n'est que dans ces stockages pour les applications cloud que le diable lui-même se cassera la jambe.  Et allez comprendre les significations fictives et les significations de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la terminologie</a></strong> du <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stockage dans Kubernetes</a></strong> .  Et il existe des référentiels propres à Kubernetes, des plateformes open source, des services gérés ou payants ... </p><br><p>  Voici quelques exemples <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de stockage cloud CNCF</a></strong> : </p><br><p><img src="https://habrastorage.org/webt/cm/wl/ov/cmwlovlr6qt3qcicg0sm5acufvw.png"></p><br><p>  Il semblerait que déployer la base de données dans Kubernetes - il vous suffit de sélectionner la solution appropriée, de l'emballer dans un conteneur pour travailler sur le disque local et de la déployer sur le cluster en tant que charge de travail suivante.  Mais la base de données a ses propres particularités, donc penser n'est pas une glace. </p><br><p>  Conteneurs - ils sont tellement pavés qu'ils ne préservent pas leur état.  C'est pourquoi ils sont si faciles à démarrer et à arrêter.  Et comme il n'y a rien à sauvegarder et à transférer, le cluster ne se soucie pas des opérations de lecture et de copie. </p><br><p>  Vous devrez stocker l'état dans la base de données.  Si une base de données déployée sur un cluster dans un conteneur ne migre nulle part et ne démarre pas trop souvent, la physique du stockage de données entre en jeu.  Idéalement, les conteneurs qui utilisent des données devraient être dans le même foyer que la base de données. </p><br><p>  Dans certains cas, la base de données peut bien sûr être déployée dans un conteneur.  Dans un environnement de test ou dans des tâches où il y a peu de données, les bases de données vivent confortablement dans des clusters. </p><br><p>  <strong>La production nécessite généralement un stockage externe.</strong> </p><br><p>  Kubernetes communique avec le référentiel via des interfaces de plan de contrôle.  Ils lient Kubernetes au stockage externe.  Le stockage externe attaché à Kubernetes est appelé plugins de volume.  Avec eux, vous pouvez résumer le stockage et transférer le stockage. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les plugins de volume étaient auparavant créés</a></strong> , liés, compilés et fournis à l'aide de la base de code Kubernetes.  Cela limitait considérablement les développeurs et nécessitait une maintenance supplémentaire: si vous souhaitez ajouter de nouveaux référentiels, veuillez modifier la base de code de Kubernetes. </p><br><p>  Déployez maintenant des plugins de volume sur le cluster - je ne veux pas.  Et vous n'avez pas besoin de creuser dans la base de code.  Merci à CSI et Flexvolume. </p><br><p><img src="https://habrastorage.org/webt/ug/r7/m4/ugr7m4uco1skczyasqf7xf3op3y.png"></p><br><h3 id="sobstvennoe-hranilische-kubernetes">  Stockage natif Kubernetes </h3><br><p>  Comment Kubernetes résout-il les problèmes de stockage?  Il existe plusieurs solutions: options éphémères, stockage persistant dans des volumes persistants, requêtes de revendication de volume persistant, classes de stockage ou StatefulSets.  Allez le comprendre, en général. </p><br><p>  Les volumes persistants (PV) sont des unités de stockage préparées par l'administrateur.  Ils ne dépendent pas des foyers et de leur vie éphémère. </p><br><p>  Les revendications de volume persistantes (PVC) sont des demandes de stockage, c'est-à-dire PV.  Avec PVC, vous pouvez lier le stockage à un nœud et ce nœud l'utilisera. </p><br><p>  Vous pouvez travailler avec le stockage de manière statique ou dynamique. </p><br><p>  Avec une approche statique, l'administrateur prépare les PV, qui sont censés être nécessaires à l'avance, avant les demandes, et ces PV sont liés manuellement à des pods spécifiques à l'aide de PVC explicites. </p><br><p>  Dans la pratique, les PV spécialement définis ne sont pas compatibles avec la structure portable Kubernetes - le stockage dépend de l'environnement, comme AWS EBS ou un lecteur permanent GCE.  Pour lier manuellement, vous devez pointer vers un référentiel spécifique dans le fichier YAML. </p><br><p>  L'approche statique contredit généralement la philosophie de Kubernetes: les processeurs et la mémoire ne sont pas alloués à l'avance et ne sont pas liés à des pods ou des conteneurs.  Ils sont émis dynamiquement. </p><br><p>  Pour l'approvisionnement dynamique, nous utilisons des classes de stockage.  L'administrateur de cluster n'a pas besoin de créer le PV à l'avance.  Il crée plusieurs profils de stockage, comme des modèles.  Lorsqu'un développeur fait une demande PVC, au moment de la demande, l'un de ces motifs est créé et attaché au foyer. </p><br><p><img src="https://habrastorage.org/webt/id/9q/mj/id9qmjxqf7tqnki0xc_1a710seg.png"></p><br><p>  Donc, dans les termes les plus généraux, Kubernetes fonctionne avec un stockage externe.  Il existe de nombreuses autres options. </p><br><h3 id="csi--container-storage-interface">  CSI - Interface de stockage de conteneurs </h3><br><p>  Il y a une telle chose - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interface de stockage de conteneurs</a></strong> .  Le CSI a été créé par le groupe de travail du coffre-fort de la CNCF, qui a décidé de définir une interface de stockage de conteneurs standard afin que les pilotes du coffre-fort fonctionnent avec n'importe quel orchestre. </p><br><p>  Les spécifications CSI sont déjà adaptées pour Kubernetes, et il existe des <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tonnes de plugins de pilotes</a></strong> pour les déploiements dans le cluster Kubernetes.  Vous devez accéder au référentiel via un pilote de volume compatible CSI - utilisez le <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">type de</a></strong> volume <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">csi</a></strong> dans Kubernetes. </p><br><p>  Avec CSI, le stockage peut être considéré comme une autre charge de travail pour la conteneurisation et le déploiement sur le cluster Kubernetes. </p><br><p>  Pour plus de détails, écoutez <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jie Yu parler de CSI dans notre podcast</a></strong> . </p><br><h3 id="opensors-proekty">  Projets open source </h3><br><p>  Les outils et projets pour les technologies cloud se multiplient rapidement, et une bonne partie des projets open source - ce qui est logique - résout l'un des principaux problèmes de production: travailler avec le stockage dans l'architecture cloud. </p><br><p>  Les plus populaires d'entre eux sont Ceph et Rook. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ceph</a></strong> est un cluster de stockage distribué géré dynamiquement avec une mise à l'échelle horizontale.  Ceph fournit une abstraction logique pour les ressources de stockage.  Il n'a pas de point de défaillance unique, il se gère lui-même et fonctionne sur la base d'un logiciel.  Ceph fournit des interfaces pour stocker simultanément des blocs, des objets et des fichiers pour un seul cluster de stockage. </p><br><p>  Ceph a une architecture très complexe avec RADOS, librados, RADOSGW, RDB, algorithme CRUSH et divers composants (moniteurs, OSD, MDS).  Nous n'entrerons pas dans les détails de l'architecture, il suffit de comprendre que Ceph est un cluster de stockage distribué qui simplifie l'évolutivité, élimine un point de défaillance unique sans sacrifier les performances et fournit un stockage unique avec accès aux objets, blocs et fichiers. </p><br><p>  Naturellement, Ceph est adapté au cloud.  Vous pouvez déployer un cluster Ceph de différentes manières, par exemple, en utilisant Ansible ou dans un cluster Kubernetes via CSI et PVC. </p><br><p><img src="https://habrastorage.org/webt/g9/kn/ft/g9knft3jj1y3hw8u2v-4jzoa26k.png"><br>  <em>Architecture de Ceph</em> </p><br><p>  Rook est un autre projet intéressant et populaire.  Il combine Kubernetes avec son informatique et Ceph avec ses référentiels en un seul cluster. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rook</a></strong> est un orchestrateur de stockage cloud qui complète Kubernetes.  Ils emballent Ceph dans des conteneurs avec lui et utilisent la logique de gestion de cluster pour un fonctionnement fiable de Ceph dans Kubernetes.  Rook automatise le déploiement, l'amorçage, le réglage, la mise à l'échelle, le rééquilibrage - en général, tout ce que l'administrateur du cluster fait. </p><br><p>  Avec Rook, un cluster Ceph peut être déployé à partir de yaml, comme Kubernetes.  Dans ce fichier, l'administrateur décrit ce dont il a besoin dans le cluster.  Rook lance un cluster et commence à surveiller activement.  C'est quelque chose comme un opérateur ou un contrôleur - cela garantit que toutes les exigences de yaml sont remplies.  Rook fonctionne avec des cycles de synchronisation - il voit l'état et prend des mesures s'il y a des écarts. </p><br><p>  Il n'a pas son état permanent et n'a pas besoin d'être contrôlé.  C'est dans l'esprit de Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/ep/qx/qk/epqxqk5iecbwcekk88ac8tjxih4.png"></p><br><p>  Rook, combinant Ceph et Kubernetes, est l'une des solutions de stockage cloud les plus populaires: 4000 étoiles sur Github, 16,3 millions de téléchargements et plus d'une centaine de contributeurs. <br>  Le projet Rook a déjà été accepté à la CNCF <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">et s'est récemment retrouvé dans un incubateur</a></strong> . </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bassam Tabara</a></strong> vous en dira plus sur Rook <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans notre épisode du référentiel Kubernetes</a></strong> . <br>  Si l'application a un problème, vous devez connaître les exigences et créer un système ou prendre les outils nécessaires.  Cela s'applique également au stockage dans le cloud.  Et bien que le problème ne soit pas simple, les outils et les approches ont échoué.  La technologie cloud continue d'évoluer et de nouvelles solutions nous attendront sûrement. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441222/">https://habr.com/ru/post/fr441222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441212/index.html">Travailler avec la protection des informations cryptographiques et les supports de clés matérielles sous Linux</a></li>
<li><a href="../fr441214/index.html">Guide de l'utilisateur Kibana. Visualisation. Partie 1</a></li>
<li><a href="../fr441216/index.html">Miroir noir ou pub Picooc?</a></li>
<li><a href="../fr441218/index.html">OpenAI Gym + ROS + Gazebo: entraînez un robot autonome à la maison. Partie 1</a></li>
<li><a href="../fr441220/index.html">Analyse des récentes attaques de masse avec capture DNS</a></li>
<li><a href="../fr441224/index.html">Créer un exemple ARCore de visages augmentés dans Unity</a></li>
<li><a href="../fr441226/index.html">Forbes a publié une liste des sociétés Internet russes les plus chères en 2019</a></li>
<li><a href="../fr441234/index.html">Effets de filtrage SVG. Partie 6. Créer des textures avec feTurbulence</a></li>
<li><a href="../fr441236/index.html">Habraiting 2018: les meilleurs matériaux pour 2018</a></li>
<li><a href="../fr441238/index.html">Programmation de l'anglais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>