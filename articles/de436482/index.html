<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà üîç üîü Advanced Three.js: Shader-Materialien und Nachbearbeitung üë©‚Äçüç≥ üç∫ üíπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt einige Einf√ºhrungen in die Grundlagen der Arbeit mit Three.js im Web, aber Sie werden m√∂glicherweise einen Mangel an Materialien zu fortgeschr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Advanced Three.js: Shader-Materialien und Nachbearbeitung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436482/"><p><img src="https://habrastorage.org/webt/hh/qv/5o/hhqv5okcynxdjke-qqhtmvokjsw.jpeg"></p><br><p>  Es gibt einige Einf√ºhrungen in die Grundlagen der Arbeit mit Three.js im Web, aber Sie werden m√∂glicherweise einen Mangel an Materialien zu fortgeschritteneren Themen feststellen.  Eines dieser Themen ist die Kombination von Shadern und Szenen mit dreidimensionalen Modellen.  In den Augen vieler unerfahrener Entwickler sind dies scheinbar inkompatible Dinge aus verschiedenen Welten.  Anhand eines einfachen Beispiels f√ºr eine ‚ÄûPlasmakugel‚Äú werden wir heute sehen, was ShaderMaterial ist und womit es gegessen wird, was der Effekt ist und wie schnell es m√∂glich ist, eine gerenderte Szene nachzubearbeiten. </p><a name="habracut"></a><br><p>  Es wird davon ausgegangen, dass der Leser mit den Grundlagen der Arbeit mit Three.js vertraut ist und versteht, wie Shader funktionieren.  Wenn Sie dies noch nicht erlebt haben, empfehle ich dringend, dies zuerst zu lesen: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in die Shader-Programmierung f√ºr Layouts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tragen Sie Voronoi-Mosaik- und geometrische Masken in Shadern auf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dreidimensionale Produktpr√§sentationen auf Three.js f√ºr die Kleinsten</a> </li></ul><br><p>  Aber fangen wir an ... </p><br><h2 id="shadermaterial--chto-eto">  ShaderMaterial - was ist das? </h2><br><p>  Wir haben bereits gesehen, wie eine flache Textur verwendet wird und wie sie √ºber ein dreidimensionales Objekt gespannt wird.  Da diese Textur ein gew√∂hnliches Bild war.  Als wir das Schreiben von Fragment-Shadern untersuchten, war auch dort alles flach.  Also: Wenn wir mit einem Shader ein flaches Bild erzeugen k√∂nnen, warum nicht als Textur? </p><br><p>  Diese Idee bildet die Grundlage f√ºr Shader-Material.  Beim Erstellen von Material f√ºr ein dreidimensionales Objekt geben wir Shader anstelle einer Textur daf√ºr an.  In seiner Grundform sieht es ungef√§hr so ‚Äã‚Äãaus: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// ... }, vertexShader: '...', fragmentShader: '...' });</span></span></code> </pre> <br><p>  Der Fragment-Shader wird verwendet, um die Textur des Materials zu erstellen, und Sie fragen sich nat√ºrlich, was der Vertex-Shader tun wird.  Wird er wieder eine banale Nachz√§hlung der Koordinaten durchf√ºhren?  Ja, wir beginnen mit dieser einfachen Option, k√∂nnen aber auch einen Versatz festlegen oder andere Manipulationen f√ºr jeden Scheitelpunkt eines dreidimensionalen Objekts durchf√ºhren - jetzt gibt es keine Einschr√§nkungen f√ºr die Ebene.  Aber es ist besser, all dies anhand eines Beispiels zu betrachten.  In Worten wird wenig verstanden.  Erstellen Sie eine Szene und machen Sie eine Kugel in der Mitte. </p><br><p><img src="https://habrastorage.org/webt/ot/0n/zj/ot0nzjfc89iiwsqqdc2isam_woo.jpeg"></p><br><p>  Als Material f√ºr die Kugel verwenden wir ShaderMaterial: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereBufferGeometry(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// . . . }, vertexShader: document.getElementById('sphere-vertex-shader').textContent, fragmentShader: document.getElementById('sphere-fragment-shader').textContent }); const sphere = new THREE.Mesh(geometry, shaderMaterial); SCENE.add(sphere);</span></span></code> </pre> <br><p>  Der Vertex-Shader ist neutral: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Beachten Sie, dass Three.js seine einheitlichen Variablen √ºbergibt.  Wir m√ºssen nichts tun, sie sind impliziert.  An sich enthalten sie alle Arten von Matrizen, auf die wir bereits von JS aus zugreifen k√∂nnen, sowie die Position der Kamera.  Stellen Sie sich vor, dass am Anfang der Shader selbst etwas eingef√ºgt wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// = object.matrixWorld uniform mat4 modelMatrix; // = camera.matrixWorldInverse * object.matrixWorld uniform mat4 modelViewMatrix; // = camera.projectionMatrix uniform mat4 projectionMatrix; // = camera.matrixWorldInverse uniform mat4 viewMatrix; // = inverse transpose of modelViewMatrix uniform mat3 normalMatrix; // = camera position in world space uniform vec3 cameraPosition;</span></span></code> </pre> <br><p>  Dar√ºber hinaus werden mehrere Attributvariablen an den Vertex-Shader √ºbergeben: </p><br><pre> <code class="cpp hljs">attribute vec3 position; attribute vec3 normal; attribute vec2 uv;</code> </pre> <br><p>  An den Namen ist klar, was es ist - die Position des aktuellen Scheitelpunkts, die Normale zur Oberfl√§che an diesem Punkt und die Koordinaten auf der Textur, der der Scheitelpunkt entspricht. </p><br><p>  Traditionell werden Koordinaten im Raum als (x, y, z) und Koordinaten auf der Texturebene als (u, v) bezeichnet.  Daher der Name der Variablen.  Sie werden ihn oft in verschiedenen Beispielen treffen.  Theoretisch m√ºssen wir diese Koordinaten auf den Fragment-Shader √ºbertragen, um dort mit ihnen arbeiten zu k√∂nnen.  Wir werden es tun. </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Zun√§chst sollte der Fragment-Shader ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSILON 0.02 varying vec2 vUv; void main() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((fract(vUv.x * 10.0) &lt; EPSILON) || (fract(vUv.y * 10.0) &lt; EPSILON)) { gl_FragColor = vec4(vec3(0.0), 1.0); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { gl_FragColor = vec4(1.0); } }</span></span></code> </pre> <br><p>  Erstellen Sie einfach ein Netz.  Wenn Sie ein wenig nachdenken, dann ist es in der Ebene nur ein Quadratgitter, aber da wir es einer Kugel √ºberlagern, ist es verzerrt und verwandelt sich in einen Globus.  Auf Wikipedia gibt es ein gutes Bild, das zeigt, was passiert: </p><br><p><img src="https://habrastorage.org/webt/uc/uq/us/ucuqusdhqwfubpgtrpujvwq7uww.png"></p><br><p>  Das hei√üt, im Fragment-Shader erstellen wir eine flache Textur, wie in der Mitte dieser Abbildung, und Three.js zieht sie dann auf die Kugel.  Sehr bequem. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/EGzKOd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bei komplexeren Modellen ist der Sweep nat√ºrlich komplizierter.  In der Regel arbeiten wir beim Erstellen verschiedener Design-Sites mit einfachen geometrischen Formen, und es ist leicht vorstellbar, dass sich Ihr Kopf bewegt. </p><br><h2 id="ok-a-chto-s-etim-mozhno-delat">  Ok, was kannst du dagegen tun? </h2><br><p>  Das Hauptmerkmal ist, dass sich das Shader-Material im Laufe der Zeit √§ndern kann.  Dies ist keine statische Sache, die wir einmal gezeichnet und vergessen haben, wir k√∂nnen sie animieren.  Dar√ºber hinaus sowohl in Farbe (im Fragment-Shader) als auch in Form (im Scheitelpunkt).  Dies ist ein sehr m√§chtiges Werkzeug. </p><br><p>  In unserem Beispiel machen wir ein Feuer, das eine Kugel umh√ºllt.  Es gibt zwei Kugeln - eine gew√∂hnliche (innen) und eine zweite aus dem Shader-Material (au√üen, mit gro√üem Radius).  Das Hinzuf√ºgen einer weiteren Kugel wird nicht kommentiert. </p><br><p><img src="https://habrastorage.org/webt/ti/_q/4m/ti_q4mo843ywt0fbjdmd8nmrcmy.jpeg"></p><br><p>  F√ºgen Sie zun√§chst die Zeit als einheitliche Variable f√ºr die Shader in unserem Material hinzu.  Nirgendwo ohne Zeit.  Wir haben dies bereits in reinem JS gemacht, aber in Three.js ist es genauso einfach.  Lassen Sie die Zeit in den Shadern uTime hei√üen und in der Variablen TIME gespeichert werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUniforms</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ SCENE.traverse(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> THREE.Mesh &amp;&amp; child.material.type === <span class="hljs-string"><span class="hljs-string">'ShaderMaterial'</span></span>) { child.material.uniforms.uTime.value = TIME; child.material.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); }</code> </pre> <br><p>  Wir aktualisieren alles bei jedem Aufruf der Animationsfunktion: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); TIME += <span class="hljs-number"><span class="hljs-number">0.005</span></span>; updateUniforms(); render(); }</code> </pre> <br><h2 id="ogon">  Feuer </h2><br><p>  Das Erzeugen eines Feuers ist im Wesentlichen dem Erzeugen einer Landschaft sehr √§hnlich, aber anstelle von H√∂hen Farbe.  Oder Transparenz wie in unserem Fall. </p><br><p>  Funktionen f√ºr Zuf√§lligkeit und Rauschen, die wir bereits gesehen haben, werden wir nicht im Detail analysieren.  Alles, was wir tun m√ºssen, ist, Ger√§usche mit unterschiedlichen Frequenzen zu erzeugen, um Abwechslung zu schaffen, und jedes dieser Ger√§usche mit unterschiedlichen Geschwindigkeiten zu bewegen.  Du bekommst so etwas wie Flammen, gro√üe bewegen sich langsam, kleine bewegen sich schneller: </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec2 position1 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime); vec2 position2 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">2.0</span></span>); vec2 position3 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color = ( noise(position1 * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + noise(position2 * <span class="hljs-number"><span class="hljs-number">10.0</span></span>) + noise(position3 * <span class="hljs-number"><span class="hljs-number">15.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, color - smoothstep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1.3</span></span>, vUv.y)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 position)</span></span></span><span class="hljs-function"> </span></span>{ vec2 blockPosition = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topLeftValue = rand(blockPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomLeftValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computedValue = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(position)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix(topLeftValue, topRightValue, computedValue.x) + (bottomLeftValue - topLeftValue) * computedValue.y * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - computedValue.x) + (bottomRightValue - topRightValue) * computedValue.x * computedValue.y; }</code> </pre> <br><p>  Damit die Flamme nicht die gesamte Kugel bedeckt, spielen wir mit dem vierten Farbparameter - Transparenz - und binden ihn an die y-Koordinate.  In unserem Fall ist diese Option sehr praktisch.  Allgemeiner ausgedr√ºckt wenden wir einen Gradienten mit Transparenz auf Rauschen an. </p><br><blockquote>  In Zeiten wie diesen ist es n√ºtzlich, sich an die Smoothstep-Funktion zu erinnern. </blockquote><p>  Im Allgemeinen ist ein solcher Ansatz zur Erzeugung von Feuer mit Shadern ein Klassiker.  Sie werden ihn oft an verschiedenen Orten treffen.  Es wird n√ºtzlich sein, mit magischen Zahlen zu spielen - sie werden im Beispiel zuf√§llig festgelegt, und wie das Plasma aussehen wird, h√§ngt von ihnen ab. </p><br><p>  Um das Feuer interessanter zu machen, gehen wir weiter zum Vertex-Shader und einem kleinen Schamanen ... </p><br><p>  Wie kann man die Flamme im Weltraum ein wenig "gie√üen" lassen?  F√ºr Anf√§nger kann diese Frage trotz ihrer Einfachheit gro√üe Schwierigkeiten verursachen.  Ich habe sehr komplexe Ans√§tze zur L√∂sung dieses Problems gesehen, aber im Wesentlichen m√ºssen wir die Eckpunkte auf der Kugel entlang der Linien ‚Äûvon ihrem Zentrum‚Äú aus reibungslos verschieben.  Hin und her, hin und her.  Three.js hat uns bereits die aktuelle Position des Scheitelpunkts √ºbergeben und normal - wir werden sie verwenden.  F√ºr "hin und her" passt eine eingeschr√§nkte Funktion, zum Beispiel ein Sinus.  Sie k√∂nnen nat√ºrlich experimentieren, aber der Sinus ist die Standardoption. </p><br><blockquote>  Ich wei√ü nicht, was ich nehmen soll - nimm den Sinus.  Besser noch die Summe der Sinusse mit unterschiedlichen Frequenzen. </blockquote><p>  Wir verschieben die Koordinaten normal auf den erhaltenen Wert und berechnen nach der zuvor bekannten Formel neu. </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; vec3 delta = normal * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(position.x * position.y * uTime / <span class="hljs-number"><span class="hljs-number">10.0</span></span>); vec3 newPosition = position + delta; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Was wir bekommen, ist keine Kugel mehr.  Dies ... Ich wei√ü nicht einmal, ob dieser einen Namen hat.  Aber vergessen Sie auch hier nicht, mit den Gewinnchancen herumzuspielen - sie wirken sich stark aus.  Bei der Erstellung solcher Effekte wird h√§ufig etwas durch Ausprobieren ausgew√§hlt, und es ist sehr n√ºtzlich, die ‚Äûmathematische Intuition‚Äú in sich selbst zu entwickeln - die F√§higkeit, sich mehr oder weniger vorzustellen, wie sich eine Funktion verh√§lt und wie sie von welchen Variablen abh√§ngt. </p><br><p>  Zu diesem Zeitpunkt haben wir ein interessantes, aber etwas ungeschicktes Bild.  Schauen wir uns also zuerst die Nachbearbeitung an und gehen dann zu einem lebenden Beispiel √ºber. </p><br><h2 id="postobrabotka">  Nachbearbeitung </h2><br><p>  Die F√§higkeit, etwas mit dem gerenderten Three.js-Bild zu tun, ist eine sehr n√ºtzliche Sache, w√§hrend sie in zahlreichen Unterrichtsreihen zu Unrecht vergessen wird.  Technisch wird dies wie folgt implementiert: Das Bild, das der Renderer uns gegeben hat, wird an EffectComposer gesendet (solange es sich um eine Black Box handelt), das etwas an sich schamanisiert und das endg√ºltige Bild auf Leinwand anzeigt.  Das hei√üt, nach dem Renderer wird ein weiteres Modul hinzugef√ºgt.  Wir √ºbertragen Parameter an diesen Komponisten - was tun mit dem empfangenen Bild?  Ein solcher Parameter hei√üt pass.  In gewisser Weise arbeitet der Komponist wie ein Gulp - er macht nichts, wir geben ihm Plugins, die die Arbeit bereits erledigen.  Vielleicht ist es nicht ganz richtig, das zu sagen, aber die Idee sollte klar sein. </p><br><p>  Alles, was wir weiter verwenden werden, ist nicht in der Grundstruktur von Three.js enthalten, daher verbinden wir einige Abh√§ngigkeiten und Abh√§ngigkeiten der Abh√§ngigkeiten selbst: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/EffectComposer.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/RenderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/ShaderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/CopyShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/LuminosityHighPassShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/UnrealBloomPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote>  Denken Sie daran, dass diese Skripte in den drei Paketen enthalten sind und Sie all dies mithilfe eines Webpacks oder von Analoga in einem einzigen Bundle zusammenfassen k√∂nnen. </blockquote><p>  In seiner Grundform wird der Komponist wie folgt erstellt: </p><br><pre> <code class="javascript hljs">COMPOSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.EffectComposer(RENDERER); COMPOSER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.RenderPass(SCENE, CAMERA); renderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(renderPass);</code> </pre> <br><p>  RenderPass macht eigentlich nichts Neues.  Es wird nur das gerendert, was wir von einem normalen Renderer erhalten haben.  Wenn Sie sich den Quellcode von RenderPass ansehen, finden Sie dort den Standard-Renderer.  Da jetzt das Rendern dort stattfindet, m√ºssen wir den Renderer in unserem Skript durch den Komponisten ersetzen: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// RENDERER.render(SCENE, CAMERA); COMPOSER.render(SCENE, CAMERA); }</span></span></code> </pre> <br><p>  Dieser Ansatz mit RenderPass als erstem Durchgang ist bei der Arbeit mit EffectComposer Standard.  Normalerweise m√ºssen wir zuerst ein gerendertes Bild der Szene erstellen und dann etwas damit anfangen. </p><br><p>  In den Beispielen von Three.js finden Sie im Abschnitt Nachbearbeitung etwas namens UnrealBloomPass.  Dies ist ein portiertes Skript aus der Unreal-Engine.  Es f√ºgt ein wenig Glanz hinzu, der verwendet werden kann, um eine sch√∂nere Beleuchtung zu erzeugen.  Oft ist dies der erste Schritt zur Bildverbesserung. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bloomPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.UnrealBloomPass( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight), <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); bloomPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(bloomPass);</code> </pre> <br><p>  Bitte beachten Sie: Die Option renderToScreen ist nur auf den letzten Durchgang festgelegt, den wir an den Komponisten √ºbergeben haben. </p><br><p>  Aber lassen Sie uns schon sehen, welche Art von Glanz dieser BloomPass uns verlieh und wie er zur Kugel passt: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdegG" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Stimmen Sie zu, dies ist viel interessanter als nur eine Kugel und eine gew√∂hnliche Lichtquelle, wie sie normalerweise in den ersten Lektionen auf Three.js gezeigt werden. </p><br><p>  Aber wir werden noch weiter gehen ... </p><br><h2 id="bolshe-sheyderov-bogu-sheyderov">  Noch mehr Shader f√ºr den Shadergott! </h2><br><p><img src="https://habrastorage.org/webt/kk/ap/ks/kkapksi_a_secwfoh81jjxkgtx4.jpeg"></p><br><p>  Es ist sehr n√ºtzlich, console.log zu verwenden und sich die Struktur des Komponisten anzusehen.  Darin finden Sie einige Elemente mit den Namen renderTarget1, renderTarget2 usw., wobei die Zahlen den Indizes der √ºbergebenen Durchg√§nge entsprechen.  Und dann wird klar, warum EffectComposer so genannt wird.  Es funktioniert nach dem Prinzip der Filter in SVG.  Denken Sie daran, dass Sie dort das Ergebnis der Durchf√ºhrung einiger Filter in anderen verwenden k√∂nnen?  Hier das gleiche - Sie k√∂nnen Effekte kombinieren. </p><br><blockquote>  Die Verwendung von console.log zum Verst√§ndnis der internen Struktur von Three.js-Objekten und vielen anderen Bibliotheken ist sehr n√ºtzlich.  Verwenden Sie diesen Ansatz h√§ufiger, um besser zu verstehen, was was ist. </blockquote><p>  F√ºgen Sie einen weiteren Pass hinzu.  Diesmal wird es ShaderPass sein. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = { <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-attr"><span class="hljs-attr">uRender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: COMPOSER.renderTarget2 }, <span class="hljs-attr"><span class="hljs-attr">uTime</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: TIME } }, <span class="hljs-attr"><span class="hljs-attr">vertexShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-vertex-shader'</span></span>).textContent, <span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-fragment-shader'</span></span>).textContent }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderPass(shader); shaderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(shaderPass);</code> </pre> <br><p>  RenderTarget2 enth√§lt das Ergebnis des vorherigen Durchlaufs - bloomPass (es war der zweite in Folge). Wir verwenden es als Textur (dies ist im Wesentlichen ein flach gerendertes Bild) und √ºbergeben es als einheitliche Variable an den neuen Shader. </p><br><p>  Wahrscheinlich lohnt es sich, hier zu bremsen und die ganze Magie zu verwirklichen ... </p><br><p>  Erstellen Sie als N√§chstes einen einfachen Vertex-Shader.  In den meisten F√§llen m√ºssen wir zu diesem Zeitpunkt nichts mit den Eckpunkten tun, sondern √ºbergeben nur die Koordinaten (u, v) an den Fragment-Shader: </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Und fragmentarisch k√∂nnen wir Spa√ü an unserem Geschmack und unserer Farbe haben.  Zum Beispiel k√∂nnen wir einen leichten Glitch-Effekt hinzuf√ºgen, alles schwarz und wei√ü machen und mit Helligkeit / Kontrast spielen: </p><br><pre> <code class="cpp hljs">uniform sampler2D uRender; uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> randomValue = rand(vec2(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(vUv.y * <span class="hljs-number"><span class="hljs-number">7.0</span></span>), uTime / <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec4 color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomValue &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { color = texture2D(uRender, vec2(vUv.x + randomValue - <span class="hljs-number"><span class="hljs-number">0.01</span></span>, vUv.y)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { color = texture2D(uRender, vUv); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightness = (color.r + color.g + color.b) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; color.rgb = vec3(smoothstep(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, lightness)); gl_FragColor = color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre> <br><p>  Schauen wir uns das Ergebnis an: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdeKB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Wie Sie sehen k√∂nnen, wurden Filter auf die Kugel gelegt.  Es ist immer noch dreidimensional, nichts ist kaputt gegangen, aber auf der Leinwand haben wir ein verarbeitetes Bild. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die Shader-Materialien und die Nachbearbeitung in Three.js sind zwei kleine, aber sehr leistungsstarke Tools, die es definitiv wert sind, verwendet zu werden.  Es gibt viele M√∂glichkeiten f√ºr ihre Verwendung - alles ist durch Ihre Vorstellungskraft begrenzt.  Selbst die einfachsten Szenen k√∂nnen mit ihrer Hilfe bis zur Unkenntlichkeit ver√§ndert werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436482/">https://habr.com/ru/post/de436482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436468/index.html">Legislative Experiment mit digitaler Innovation</a></li>
<li><a href="../de436472/index.html">DEFCON-Konferenz 20. Erfassung in 60 Sekunden: von einem Gastkonto zu einem Windows-Dom√§nenadministrator. Teil 1</a></li>
<li><a href="../de436474/index.html">DEFCON-Konferenz 20. Erfassung in 60 Sekunden: von einem Gastkonto zu einem Windows-Dom√§nenadministrator. Teil 2</a></li>
<li><a href="../de436476/index.html">Cloud f√ºr Versicherer</a></li>
<li><a href="../de436480/index.html">Ich habe einen Bot gemacht, der mit Personalvermittlern f√ºr mich kommuniziert, und ich mochte</a></li>
<li><a href="../de436484/index.html">Wo finde ich DNS-Einstellungen unter MacOS?</a></li>
<li><a href="../de436486/index.html">Was passiert auf dem Audio-Podcast-Markt?</a></li>
<li><a href="../de436488/index.html">Currying und Teilanwendung in C ++ 14</a></li>
<li><a href="../de436490/index.html">Motorola plant die Einf√ºhrung der Razr v3-Inkarnation</a></li>
<li><a href="../de436492/index.html">Wir suchen Redner beim 10. DIY Mitap am 17. Februar 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>