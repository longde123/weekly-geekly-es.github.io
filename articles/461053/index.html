<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òîÔ∏è üßòüèæ üßó Conectamos mapas en l√≠nea al navegador en el tel√©fono inteligente. Parte 2 - tarjetas de vectores üíÄ üë®‚Äçüë®‚Äçüëß‚Äçüëß üïö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estamos escribiendo una aplicaci√≥n de servidor que generar√° mosaicos de trama PNG basados ‚Äã‚Äãen mapas vectoriales en l√≠nea. Utilice el raspado web con ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conectamos mapas en l√≠nea al navegador en el tel√©fono inteligente. Parte 2 - tarjetas de vectores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Estamos escribiendo una aplicaci√≥n de servidor que generar√° mosaicos de trama PNG basados ‚Äã‚Äãen mapas vectoriales en l√≠nea.  Utilice el raspado web con Puppeteer para obtener datos del mapa. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Contenido: </h3><br><p> 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas r√°ster est√°ndar</a> <br>  2 - Continuaci√≥n.  Escribir un rasterizador simple para mapas vectoriales <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un caso especial.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conectamos la tarjeta OverpassTurbo</a> </p><br><h3 id="prodolzhenie">  Continuaci√≥n </h3><br><p>  Y as√≠ llegamos al tema m√°s interesante.  Imagine que encontramos un sitio con un mapa que realmente queremos agregar a nuestro navegador.  Hacemos todo de acuerdo con las instrucciones de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte anterior</a> .  Abrimos la visualizaci√≥n de los contenidos del sitio, ¬°y no hay im√°genes!  Absolutamente  Bueno, un par de √≠conos y eso es todo.  Y alg√∫n otro archivo de texto con una lista de coordenadas. </p><br><p>  Felicidades, encontramos un mapa vectorial.  En t√©rminos generales, su navegador lo procesa en tiempo real.  Entonces ella no necesita ning√∫n azulejo preparado en absoluto.  Por un lado, no hay tantos mapas vectoriales hasta ahora.  Pero esta tecnolog√≠a es muy prometedora y con el tiempo pueden convertirse en muchas m√°s.  Bueno, lo descubrimos.  Y sin embargo, ¬øqu√© hacemos ahora? </p><br><p>  En primer lugar, puede intentar descargar un navegador de una versi√≥n muy, muy antigua.  Uno que no admite las funciones requeridas para representar el mapa.  Es posible que se le muestre una versi√≥n diferente del sitio.  Con mapa r√°ster.  Bueno, lo que necesitas hacer con eso ya lo sabes. </p><br><p>  Sin embargo, si este truco no funcion√≥, pero todav√≠a desea obtener esta tarjeta y, adem√°s, no en el navegador del tel√©fono inteligente, es decir, en su navegador, entonces hay una manera. </p><br><h3 id="osnovnaya-ideya">  Idea principal </h3><br><p>  Procederemos del hecho de que queremos obtener un mapa que se pueda abrir en cualquiera de los navegadores.  Luego necesitamos un adaptador, un tipo de intermediario que generar√° mosaicos para nosotros en formato PNG. </p><br><p>  Resulta que necesitas <del>  inventar una bicicleta </del>  desarrollar otro motor para visualizar datos vectoriales.  Bueno, o puedes escribir un script que ir√° al sitio, permiti√©ndole dibujar su propio mapa vectorial por su cuenta.  Y luego esperar√° la descarga, tomar√° una captura de pantalla, recortar√° y volver√° al usuario.  Quiz√°s elegir√© la segunda opci√≥n. </p><br><p>  Para tomar capturas de pantalla, usar√© un "navegador de control remoto": Chrome sin cabeza.  Puede controlarlo utilizando el nodo <strong>Puppeteer de la</strong> biblioteca js.  Puede aprender sobre los conceptos b√°sicos para trabajar con esta biblioteca en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> . </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Hola mundo  O crea y personaliza un proyecto </h3><br><p>  Si a√∫n no ha instalado Node.js, vaya a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">esta</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">esta</a> p√°gina, seleccione su sistema operativo y complete la instalaci√≥n de acuerdo con las instrucciones. </p><br><p>  Cree una nueva carpeta para el proyecto y √°brala en la terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Comenzamos el gerente de crear un nuevo proyecto </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Aqu√≠ puede especificar el nombre del proyecto ( <strong>nombre del paquete</strong> ), el nombre del archivo para ingresar a la aplicaci√≥n ( <strong>punto de entrada</strong> ) y el nombre del autor ( <strong>autor</strong> ).  Para todas las dem√°s solicitudes, aceptamos los par√°metros predeterminados: no ingresamos nada y solo presionamos <strong>Enter</strong> .  Al final, presione <strong>yy</strong> <strong>Enter</strong> . </p><br><p>  A continuaci√≥n, instale los marcos necesarios para el trabajo.  Express para crear un servidor y Puppeteer para trabajar con un navegador. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Como resultado, el archivo de configuraci√≥n del proyecto <strong>package.json</strong> aparece en la carpeta del proyecto.  En mi caso, esto: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  Agregar√© la l√≠nea de inicio a la secci√≥n de scripts para iniciar nuestra aplicaci√≥n de manera m√°s conveniente. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Ahora cree dos archivos con la implementaci√≥n de la funcionalidad b√°sica.  El primer archivo es el punto de entrada a la aplicaci√≥n.  En mi caso, <strong>router.js</strong> .  Crear√° un servidor y har√° el enrutamiento. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Ahora crea un segundo archivo.  √âl controlar√° el navegador y tomar√° capturas de pantalla.  Lo tengo llamado <strong>mapshoter.js</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Ejecute nuestro script y verifique su rendimiento.  Para hacer esto, escriba la consola: </p><br><p> <code>$ npm start</code> </p> <br><p>  Aparece un mensaje que dice "El servidor se crea en el puerto 5000".  Ahora abra un navegador en su computadora y vaya a la direcci√≥n local de nuestro servidor.  En lugar de las coordenadas <strong>x, y, z,</strong> puede ingresar cualquier n√∫mero.  Entr√© en 1, 2, 3. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Si todo se hace correctamente, aparecer√° una captura de pantalla del sitio de Google. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="imagen"></p><br><p>  Presione Ctrl + C en la consola para detener nuestro script. </p><br><p>  ¬°Felicitaciones, la base de nuestra aplicaci√≥n est√° lista!  Creamos un servidor que acepta nuestras solicitudes html, toma una captura de pantalla y nos devuelve una imagen.  Ahora es el momento de pasar a la implementaci√≥n de los detalles. </p><br><h3 id="rasschitaem-koordinaty">  Calcular las coordenadas </h3><br><p>  La idea es que el navegador abra un sitio con un mapa e ingrese las coordenadas del lugar que necesitamos en la barra de b√∫squeda.  Despu√©s de hacer clic en el bot√≥n "Buscar", este lugar estar√° exactamente en el centro de la pantalla.  Por lo tanto, ser√° f√°cil cortar el √°rea que necesitamos. </p><br><p>  Pero primero, debe calcular las coordenadas del centro del mosaico en funci√≥n de su n√∫mero de serie.  Har√© esto basado en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">f√≥rmula</a> para encontrar la esquina superior izquierda.  Lo puse en la funci√≥n <strong>getCoordinates ()</strong> . </p><br><p>  Y dado que para algunos sitios, adem√°s del centro del mosaico, tambi√©n debe especificar sus bordes, entonces tambi√©n los buscar√©.  Bueno, <strong>creemos</strong> un m√≥dulo separado para estos c√°lculos con el nombre <strong>geoTools.js</strong> .  Aqu√≠ est√° su c√≥digo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Ahora estamos listos para comenzar a implementar el script para trabajar con el navegador.  Veamos algunos escenarios de c√≥mo se puede hacer esto. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Escenario 1 - B√∫squeda de API </h3><br><p>  Comencemos con el caso m√°s simple, cuando simplemente puede ingresar las coordenadas en la URL de la p√°gina del mapa.  Por ejemplo, as√≠: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Miremos el gui√≥n.  Simplemente reemplace, elimine todo el contenido del archivo <strong>mapshoter.js</strong> y pegue el c√≥digo a continuaci√≥n. </p><br><p>  En esta versi√≥n, al iniciar el navegador, especificamos par√°metros adicionales que le permitir√°n iniciarse y funcionar en servidores Linux, como Heroku.  Adem√°s, ahora reduciremos el tama√±o de la ventana para que quepan en la pantalla la menor cantidad posible de mosaicos de mapas.  Por lo tanto, aumentamos la velocidad de carga de la p√°gina. </p><br><p>  A continuaci√≥n, calculamos las coordenadas del centro del mosaico deseado.  Los pegamos en la URL y hacemos clic en √©l.  El mosaico aparece exactamente en el centro de la pantalla.  Corta una pieza de 256x256 p√≠xeles.  Este ser√° el mosaico que necesitamos.  Solo queda devolverlo al usuario. </p><br><p>  Antes de pasar al c√≥digo, noto que para mayor claridad, todo el manejo de errores se ha eliminado del script. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Ahora ejecute nuestro script y vea el mapa para esta secci√≥n. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Si todo se hace correctamente, el servidor deber√≠a devolver ese mosaico: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Para asegurarse de que no mezclemos nada al recortar, compare nuestro mosaico con el original de OpenStreetMaps.org </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Escenario 2 - Buscar usando la interfaz del sitio </h3><br><p>  Sin embargo, no siempre es posible controlar una tarjeta a trav√©s de una l√≠nea de navegador.  Bueno, en tales casos, nuestro script se comportar√° como un usuario real.  Imprimir√° las coordenadas en el cuadro de b√∫squeda y har√° clic en el bot√≥n Buscar.  Despu√©s de eso, eliminar√° el marcador del punto encontrado, que generalmente aparece en el centro de la pantalla.  Y luego har√° clic en los botones para aumentar o disminuir la escala hasta que alcance la deseada.  Luego tomar√° una captura de pantalla y la devolver√° al usuario. </p><br><p>  Observo que generalmente despu√©s de la b√∫squeda se establece la misma escala.  15, por ejemplo.  En nuestro ejemplo, esto no siempre sucede.  Por lo tanto, reconoceremos el nivel de zoom de los par√°metros de los elementos html en la p√°gina. </p><br><p>  Tambi√©n en este ejemplo, buscaremos elementos de interfaz utilizando selectores XPath.  ¬øPero c√≥mo los reconoces? </p><br><p>  Para hacer esto, abra la p√°gina requerida en el navegador y abra la barra de herramientas del desarrollador ( <strong>Ctll + Alt + I</strong> para Google Chrome).  Presione el bot√≥n para seleccionar elementos.  Hacemos clic en el elemento que le interesa (hice clic en el campo de b√∫squeda). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  La lista de elementos se desplaza al que hizo clic y se resalta en azul.  Haga clic en el bot√≥n con tres puntos a la izquierda del nombre. </p><br><p>  En el men√∫ emergente, seleccione Copiar.  A continuaci√≥n, si necesita un selector normal, haga clic en <strong>Copiar selector</strong> .  Pero para el mismo ejemplo, utilizaremos el elemento <strong>Copiar XPath</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Ahora reemplace el contenido del archivo <strong>mapshoter.js</strong> con este c√≥digo.  En √©l, ya he recopilado selectores para todos los elementos de interfaz necesarios. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Ejecute nuestro script y siga el enlace.  Si todo se hace correctamente, el script nos devolver√° algo como este mosaico. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Optimizaci√≥n </h3><br><p>  En principio, los dos m√©todos descritos anteriormente son suficientes para conectarse a muchos sitios con mapas vectoriales.  Pero si de repente necesita acceso a alg√∫n mapa nuevo, solo tendr√° que modificar ligeramente la secuencia de comandos en el archivo mapshoter.js.  Es decir, este m√©todo hace que sea muy f√°cil agregar nuevas tarjetas.  Esto es de sus ventajas. </p><br><p>  Pero tambi√©n hay desventajas.  Y el principal es la velocidad del trabajo.  Solo compara.  En promedio, se tarda aproximadamente 0,5 segundos en descargar un mosaico r√°ster normal.  Si bien recibir una ficha de nuestro script en este momento, toma alrededor de 8 segundos. </p><br><p>  ¬°Pero eso no es todo!  Usamos el nodo js de un solo subproceso y nuestras solicitudes largas eventualmente bloquear√°n el subproceso principal, que desde el exterior se ver√° como una cola sincr√≥nica regular.  Y cuando intentamos descargar el mapa para toda la pantalla (en la que, por ejemplo, se colocan 24 mosaicos), es decir, existe el riesgo de encontrar un problema. </p><br><p>  Y una cosa m√°s.  Algunos navegadores tienen un tiempo de espera: dejar√°n de cargar despu√©s de 30 segundos.  Y esto significa que con la implementaci√≥n actual solo 3-4 mosaicos tendr√°n tiempo para cargar.  Bueno, veamos qu√© podemos hacer al respecto. </p><br><p>  Probablemente la forma m√°s obvia es simplemente aumentar el n√∫mero de servidores en los que se ejecutar√° nuestro script.  Por ejemplo, si tenemos 10 servidores, tendr√°n tiempo para procesar los mosaicos para toda la pantalla en 30 segundos.  (Si no desea pagar mucho dinero, puede obtenerlo registrando varias cuentas gratuitas en Heroku) </p><br><p>  En segundo lugar, todav√≠a es posible implementar subprocesos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√∫ltiples</a> en el nodo js utilizando el m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">worker_threads</a> .  Seg√∫n mis observaciones, en un servidor con un procesador de un solo n√∫cleo en una cuenta gratuita de Heroku, logro iniciar tres subprocesos.  Tres transmisiones con un navegador separado en cada una, que pueden funcionar simult√°neamente sin bloquearse entre s√≠.  Para ser justos, noto que como resultado del aumento de la carga en el procesador, la velocidad de descarga de un mosaico incluso aument√≥ ligeramente.  Sin embargo, si intenta descargar un mapa para toda la pantalla, luego de 30 segundos, m√°s de la mitad del mapa tendr√° tiempo para cargarse.  M√°s de 12 azulejos.  Ya mejor. </p><br><p>  En tercer lugar.  En la implementaci√≥n actual de la secuencia de comandos, con cada solicitud, pasamos tiempo descargando el navegador Chrome y luego complet√°ndolo.  Ahora crearemos un navegador por adelantado y transferiremos un enlace a √©l en mapshoter.js.  Como resultado, la velocidad no cambiar√° para la primera solicitud.  Pero para toda la descarga posterior, la velocidad de un mosaico se reduce a 4 segundos.  Y despu√©s de 30 segundos, todo el mapa tiene tiempo de cargarse: las 24 fichas que se colocan en mi pantalla. </p><br><p>  Bueno, si implementa todo esto, entonces el script puede volverse bastante viable.  Entonces comencemos.  Para un trabajo m√°s simple con subprocesos m√∫ltiples, utilizar√© el m√≥dulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">grupo de subprocesos de nodo de trabajo</a> , una especie de envoltorio sobre subprocesos de trabajo.  Vamos a instalarlo </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Corrija el archivo router.js.  Agregue la creaci√≥n de un grupo de subprocesos.  Los hilos ser√°n de 3 piezas.  Su c√≥digo se describir√° en el archivo <strong>worker.js</strong> , lo veremos m√°s adelante.  Mientras tanto, elimine el inicio del m√≥dulo de captura de pantalla directamente.  En su lugar, agregaremos una nueva tarea al grupo de subprocesos.  Comenzar√°n a procesarlo cuando alguno de los hilos se libere. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Ahora eche un vistazo al archivo <strong>worker.js</strong> .  Cada vez que <strong>llega</strong> una nueva tarea <strong>, se iniciar√° el</strong> m√©todo <strong>parentPort.on ()</strong> .  Desafortunadamente, no puede manejar funciones as√≠ncronas / en espera.  Entonces usaremos la funci√≥n del adaptador en forma del m√©todo <strong>doMyAsyncCode ()</strong> . </p><br><p>  En √©l, en un formato legible conveniente, pondremos la l√≥gica del trabajador.  Es decir, inicie el navegador (si a√∫n no se est√° ejecutando) y active el m√©todo para tomar una captura de pantalla.  Al inicio, pasaremos a este m√©todo un enlace al navegador en ejecuci√≥n. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  Para mayor claridad, volvamos a la primera versi√≥n de <strong>mapshoter.js</strong> .  No va a cambiar mucho.  Ahora, en los par√°metros de entrada, aceptar√° un enlace al navegador, y cuando finalice el script, no apagar√° el navegador, sino que simplemente cerrar√° la pesta√±a creada. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  En principio, eso es todo.  Ahora puede cargar el resultado al servidor de la forma que le resulte m√°s conveniente.  Por ejemplo, a trav√©s de docker.  Si desea ver el resultado final, puede hacer clic en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">este enlace</a> .  Tambi√©n puede encontrar el c√≥digo completo del proyecto en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Conclusi√≥n </h3><br><p>  Ahora vamos a evaluar el resultado.  Por un lado, incluso a pesar de todos los trucos realizados, la velocidad de descarga sigue siendo muy baja.  Adem√°s, debido a los frenos, dicha tarjeta es simplemente desagradable para desplazarse. </p><br><p>  Por otro lado, este script, sin embargo, hace frente a las tarjetas que antes de eso era generalmente imposible conectarse al navegador en el tel√©fono inteligente.  Es poco probable que esta soluci√≥n se aplique alguna vez como el m√©todo principal para obtener datos cartogr√°ficos.  Pero aqu√≠ como uno adicional, con la ayuda de la cual, si es necesario, ser√° posible abrir una tarjeta ex√≥tica, es bastante posible. </p><br><p>  Adem√°s, las ventajas de este script incluyen el hecho de que es f√°cil trabajar con √©l.  Es facil de escribir.  Y, lo m√°s importante, se puede rehacer extremadamente f√°cilmente para conectar cualquier otra tarjeta en l√≠nea. </p><br><p>  Bueno, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el pr√≥ximo art√≠culo</a> me ocupar√© de eso.  Transformar√© el script en una especie de API para trabajar con el mapa interactivo OverpassTurbo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461053/">https://habr.com/ru/post/461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461043/index.html">Gesti√≥n de conflictos en un equipo: ¬øun acto de equilibrio o una necesidad vital?</a></li>
<li><a href="../461045/index.html">Obtenga un extracto de Rosreestr a trav√©s de FSIS USRN y python. Parte 1</a></li>
<li><a href="../461047/index.html">Escribir o no escribir. Cartas a las autoridades durante los eventos.</a></li>
<li><a href="../461049/index.html">ONYX BOOX Faust - El que busca no est√° obligado a vagar</a></li>
<li><a href="../461051/index.html">Los 10 errores m√°s comunes que he encontrado en Go-projects</a></li>
<li><a href="../461055/index.html">Rekko Challenge 2019: como fue</a></li>
<li><a href="../461057/index.html">Canales de Telegram sobre desarrollo de juegos</a></li>
<li><a href="../461059/index.html">Escribir una aplicaci√≥n de Android para fan√°ticos del cine - Parte 1 (creaci√≥n de prototipos)</a></li>
<li><a href="../461061/index.html">Aleaciones de magnesio, l√≠mites gemelos y segregaci√≥n</a></li>
<li><a href="../461063/index.html">Interacci√≥n de R con bases de datos en el ejemplo de Microsoft SQL Server y otros DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>