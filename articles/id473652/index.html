<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ŠğŸ¿ ğŸ‚ ğŸŒ©ï¸ Membuat API REST dengan Node.js dan Oracle Database. Bagian 5 âœ‹ ğŸ§—ğŸ¿ ğŸ¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 5. Membuat API REST: pagination, pengurutan manual, dan pemfilteran 

 Pada artikel sebelumnya, Anda selesai membangun fungsionalitas inti API ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat API REST dengan Node.js dan Oracle Database. Bagian 5</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473652/">  <b>Bagian 5. Membuat API REST: pagination, pengurutan manual, dan pemfilteran</b> <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> Anda selesai membangun fungsionalitas inti API CRUD. <br><br>  Dan sekarang, ketika permintaan HTTP GET dikeluarkan pada rute karyawan, semua baris tabel dikembalikan.  Ini mungkin tidak terlalu penting dengan hanya 107 baris dalam tabel HR.EMPLOYEES, tetapi bayangkan apa yang akan terjadi jika tabel tersebut berisi ribuan atau jutaan baris.  Klien seperti aplikasi seluler dan web biasanya hanya menampilkan sebagian kecil dari baris yang tersedia di database, dan kemudian memilih lebih banyak baris bila perlu - mungkin ketika pengguna menggulir ke bawah atau mengklik tombol "Berikutnya" pada beberapa kontrol istirahat ke halaman di antarmuka pengguna. <br><br>  Untuk ini, REST APIs harus mendukung alat pagination untuk hasil yang dikembalikan.  Setelah pagination didukung, kemampuan penyortiran menjadi perlu, karena data biasanya harus disortir sebelum pagination diterapkan.  Selain itu, alat pemfilteran data sangat penting untuk kinerja.  Mengapa mengirim data dari database, melalui lapisan perantara dan sepenuhnya ke klien, jika ini tidak perlu? <br><a name="habracut"></a><br>  Saya akan menggunakan parameter string kueri URL sehingga klien dapat menentukan bagaimana hasil harus paginasi, diurutkan dan difilter.  Seperti biasa dalam pemrograman, implementasi dapat bervariasi tergantung pada kebutuhan Anda, tujuan kinerja, dll. Dalam posting ini saya akan memberi tahu Anda tentang pendekatan manual untuk menambahkan fungsi-fungsi ini ke API. <br><br>  <b>Pagination</b> <br><br>  Parameter string kueri yang akan saya gunakan untuk paginasi: lewati dan batasi.  Parameter lewati akan digunakan untuk melewati jumlah baris yang ditentukan, sementara batas akan membatasi jumlah baris yang dikembalikan.  Saya akan menggunakan nilai default 30 untuk batas jika klien tidak memberikan nilai. <br><br>  Mulai dengan memperbarui logika pengontrol untuk mengekstrak nilai dari string kueri dan meneruskannya ke API database.  Buka file <b>controllers / employee.js</b> dan tambahkan baris kode berikut ke fungsi get setelah baris yang mem-parsing parameter req.params.id. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** line that parses req.params.id is here *** context.skip = parseInt(req.query.skip, 10); context.limit = parseInt(req.query.limit, 10);</span></span></code> </pre> <br>  Sekarang Anda perlu memperbarui logika database untuk mengambil nilai-nilai ini ke dalam akun dan memperbarui query SQL yang sesuai.  Dalam SQL, klausa offset digunakan untuk melewati baris, dan klausa ambil digunakan untuk membatasi jumlah baris yang dikembalikan oleh kueri.  Seperti biasa, nilai tidak akan ditambahkan langsung ke kueri - sebagai gantinya, nilai itu akan ditambahkan sebagai variabel terikat untuk alasan kinerja dan keamanan.  Buka <b>db_apis / employee.js</b> dan tambahkan kode berikut setelah blok if di fungsi find, yang menambahkan klausa where ke permintaan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** if block that appends where clause ends here *** if (context.skip) { binds.row_offset = context.skip; query += '\noffset :row_offset rows'; } const limit = (context.limit &gt; 0) ? context.limit : 30; binds.row_limit = limit; query += '\nfetch next :row_limit rows only';</span></span></code> </pre> <br>  Ini semua yang perlu Anda lakukan untuk melakukan paginasi!  Luncurkan API, dan kemudian jalankan beberapa perintah URL di terminal lain untuk mengujinya.  Berikut ini beberapa contoh yang dapat Anda gunakan: <br><br><pre> <code class="javascript hljs"># use <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> limit (<span class="hljs-number"><span class="hljs-number">30</span></span>) curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees"</span></span> # set limit to <span class="hljs-number"><span class="hljs-number">5</span></span> curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?limit=5"</span></span> # use <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> limit and set skip to <span class="hljs-number"><span class="hljs-number">5</span></span> curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?skip=5"</span></span> # set both skip and limit to <span class="hljs-number"><span class="hljs-number">5</span></span> curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?skip=5&amp;limit=5"</span></span></code> </pre> <br>  <b>Menyortir</b> <br><br>  Minimal, pelanggan harus dapat menentukan kolom untuk mengurutkan dan memesan (naik atau turun).  Cara termudah untuk melakukan ini adalah dengan menentukan parameter kueri (saya akan menggunakan sort), yang memungkinkan Anda meneruskan string seperti 'last_name: asc' atau 'payroll: desc'.  Satu-satunya cara untuk menjamin urutan hasil yang dikembalikan dari query SQL adalah dengan memasukkan urutan dengan klausa.  Untuk alasan ini, alangkah baiknya jika definisi pesanan default didefinisikan untuk memastikan konsistensi ketika klien tidak menentukannya. <br><br>  Kembali ke <b>controllers / employee.js</b> dan tambahkan baris kode berikut ke fungsi get setelah baris yang mem-parsing parameter req.query.limit. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** line that parses req.query.limit is here *** context.sort = req.query.sort;</span></span></code> </pre> <br>  Kemudian buka <b>db_apis / employee.js</b> dan tambahkan baris berikut di bawah baris yang menyatakan dan menginisialisasi baseQuery. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** lines that initalize baseQuery end here *** const sortableColumns = ['id', 'last_name', 'email', 'hire_date', 'salary'];</span></span></code> </pre> <br>  sortableColumns adalah daftar putih kolom yang dapat digunakan pelanggan untuk mengurutkan.  Kemudian, di dalam fungsi find, tambahkan blok if berikut ini, yang menambahkan urutan dengan klausa.  Ini harus dilakukan setelah menambahkan klausa mana, tetapi sebelum mengimbangi dan mengambil klausa. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** if block that appends where clause ends here *** if (context.sort === undefined) { query += '\norder by last_name asc'; } else { let [column, order] = context.sort.split(':'); if (!sortableColumns.includes(column)) { throw new Error('Invalid "sort" column'); } if (order === undefined) { order = 'asc'; } if (order !== 'asc' &amp;&amp; order !== 'desc') { throw new Error('Invalid "sort" order'); } query += `\norder by "${column}" ${order}`; }</span></span></code> </pre> <br>  Bagian pertama dari blok if memeriksa apakah klien melewati nilai sortir.  Jika tidak, maka urutan default dengan klausa ditambahkan ke kueri SQL, yang mengurutkan berdasarkan nama belakang dalam urutan naik.  Jika nilai sortir ditentukan, maka itu pertama-tama dipecah menjadi kolom dan nilai pesanan, dan setiap nilai diperiksa sebelum menambahkan urutan oleh ke kueri. <br><br>  Sekarang Anda dapat menjalankan beberapa perintah URL untuk memvalidasinya.  Berikut ini beberapa contoh untuk dicoba: <br><br><pre> <code class="javascript hljs"># use <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> sort (last_name asc) curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees"</span></span> # sort by id and use <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> direction (asc) curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?sort=id"</span></span> # sort by hire_date desc curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?sort=hire_date:desc"</span></span> # use sort <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> limit and skip together curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?limit=5&amp;skip=5&amp;sort=salary:desc"</span></span> # should <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> an error because first_name is not whitelisted curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?sort=first_name:desc"</span></span> # should <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> an error because <span class="hljs-string"><span class="hljs-string">'other'</span></span> is not a valid order curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?sort=last_name:other"</span></span></code> </pre> <br>  Dua contoh terakhir harus membuang pengecualian, karena berisi nilai yang tidak dibuat untuk daftar putih.  Ini menggunakan penangan kesalahan standar Express, sehingga kesalahan dikembalikan sebagai halaman web HTML. <br><br>  <b>Penyaringan</b> <br><br>  Kemampuan untuk memfilter data adalah fitur penting yang harus disediakan oleh semua REST API.  Seperti penyortiran, implementasinya mungkin sederhana atau kompleks tergantung pada apa yang ingin Anda dukung.  Pendekatan termudah adalah menambahkan dukungan untuk filter pertandingan penuh (misalnya, last_name = Doe).  Implementasi yang lebih kompleks dapat menambahkan dukungan untuk operator dasar (misalnya, &lt;,&gt;, instr, dll.) Dan operator logis kompleks (misalnya, dan / atau) yang dapat mengelompokkan beberapa filter secara bersamaan. <br><br>  Dalam posting ini saya akan mencoba menyederhanakan situasi dan menambahkan dukungan filter hanya untuk dua kolom: department_id dan manager_id.  Untuk setiap kolom, saya akan mengaktifkan parameter terkait dalam string kueri.  Logika database yang menambahkan klausa di mana ketika permintaan GET dikirim ke titik akhir dengan satu karyawan perlu diperbarui untuk mempertimbangkan filter baru ini. <br><br>  Buka <b>controllers / employee.js</b> dan tambahkan baris berikut di bawah baris yang mem-parsing nilai req.query.sort dalam fungsi get. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** line that parses req.query.sort is here *** context.department_id = parseInt(req.query.department_id, 10); context.manager_id = parseInt(req.query.manager_id, 10);</span></span></code> </pre> <br>  Kemudian edit <b>db_apis / employee.js</b> untuk menambahkan kalimat 1 = 1 ke permintaan dasar, seperti yang ditunjukkan di bawah ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseQuery = <span class="hljs-string"><span class="hljs-string">`select employee_id "id", first_name "first_name", last_name "last_name", email "email", phone_number "phone_number", hire_date "hire_date", job_id "job_id", salary "salary", commission_pct "commission_pct", manager_id "manager_id", department_id "department_id" from employees where 1 = 1`</span></span>;</code> </pre> <br>  Tentu saja, 1 = 1 akan selalu benar, sehingga pengoptimal akan mengabaikannya.  Namun, metode ini akan menyederhanakan penambahan predikat tambahan di masa depan. <br><br>  Dalam fungsi find, ganti blok if, yang menambahkan klausa where ketika meneruskan context.id, dengan baris berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// *** line that declares 'binds' is here *** if (context.id) { binds.employee_id = context.id; query += '\nand employee_id = :employee_id'; } if (context.department_id) { binds.department_id = context.department_id; query += '\nand department_id = :department_id'; } if (context.manager_id) { binds.manager_id = context.manager_id; query += '\nand manager_id = :manager_id'; }</span></span></code> </pre> <br>  Seperti yang Anda lihat, masing-masing jika blok hanya menambahkan nilai yang diteruskan ke objek mengikat, dan kemudian menambahkan predikat yang sesuai ke klausa mana.  Simpan perubahan dan mulai ulang API.  Kemudian gunakan perintah URL ini untuk memverifikasi ini: <br><br><pre> <code class="javascript hljs"># filter where department_id = <span class="hljs-number"><span class="hljs-number">90</span></span> (returns <span class="hljs-number"><span class="hljs-number">3</span></span> employees) curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?department_id=90"</span></span> # filter where manager_id = <span class="hljs-number"><span class="hljs-number">100</span></span> (returns <span class="hljs-number"><span class="hljs-number">14</span></span> employees) curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?manager_id=100"</span></span> # filter where department_id = <span class="hljs-number"><span class="hljs-number">90</span></span> and manager_id = <span class="hljs-number"><span class="hljs-number">100</span></span> (returns <span class="hljs-number"><span class="hljs-number">2</span></span> employees) curl <span class="hljs-string"><span class="hljs-string">"http://localhost:3000/api/employees?department_id=90&amp;manager_id=100"</span></span></code> </pre> <br>  Itu saja - API sekarang mendukung pagination, sorting dan filtering!  Pendekatan manual menyediakan banyak kontrol, tetapi membutuhkan banyak kode.  Fungsi pencarian sekarang memiliki 58 baris dan hanya mendukung kemampuan penyortiran dan penyaringan terbatas.  Anda mungkin mempertimbangkan untuk menggunakan modul, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembuat</a> kueri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Knex.js</a> , untuk menyederhanakan operasi ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473652/">https://habr.com/ru/post/id473652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473638/index.html">Shader bukanlah sihir. Menulis shader di Unity. Pendahuluan</a></li>
<li><a href="../id473640/index.html">Sunset Data Besar</a></li>
<li><a href="../id473642/index.html">Cribble Crabble Gradle: Auto Build</a></li>
<li><a href="../id473646/index.html">Hackathon di sebuah perusahaan kecil: cara mengatur tanpa membuang kereta sumber daya</a></li>
<li><a href="../id473648/index.html">Kuda itu mati - menangis: transisi dari tslint ke eslint</a></li>
<li><a href="../id473654/index.html">PHP Composer: Perbaiki dependensi tanpa rasa sakit</a></li>
<li><a href="../id473656/index.html">Hugo Static Site Generator Experience</a></li>
<li><a href="../id473658/index.html">Menangani bug di Go 1.13</a></li>
<li><a href="../id473660/index.html">Arcade Reverse Engineering: Rekam Michael Jordan di NBA Jam</a></li>
<li><a href="../id473664/index.html">Pengalaman belajar langsung. Yandex.Practicum - Analis Data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>