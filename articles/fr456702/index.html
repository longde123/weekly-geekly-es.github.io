<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üàØÔ∏è üß° S√©curit√© du mobile OAuth 2.0 üåú üßî üßíüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La popularit√© des applications mobiles continue de cro√Ætre. Il en va de m√™me pour le protocole OAuth 2.0 sur les applications mobiles. Il ne suffit pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S√©curit√© du mobile OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456702/"><img src="https://habrastorage.org/getpro/habr/post_images/def/8b1/158/def8b1158655952902bf05be9fb7f308.jpg" alt="image"><br><br>  La popularit√© des applications mobiles continue de cro√Ætre.  Il en va de m√™me pour le protocole OAuth 2.0 sur les applications mobiles.  Il ne suffit pas d'impl√©menter la norme comme c'est de s√©curiser le protocole OAuth 2.0 l√†-bas.  Il faut consid√©rer les sp√©cificit√©s des applications mobiles et appliquer des m√©canismes de s√©curit√© suppl√©mentaires. <br><br>  Dans cet article, je souhaite partager les concepts d'attaques mobiles OAuth 2.0 et les m√©canismes de s√©curit√© utilis√©s pour √©viter de tels probl√®mes.  Les concepts d√©crits ne sont pas nouveaux mais il y a un manque d'informations structur√©es sur ce sujet.  L'objectif principal de l'article est de combler cette lacune. <br><a name="habracut"></a><br><h1>  Nature et objectif d'OAuth 2.0 </h1><br>  OAuth 2.0 est un protocole d' <i>autorisation</i> qui d√©crit un moyen pour un service client d'obtenir un acc√®s s√©curis√© aux ressources de l'utilisateur sur un fournisseur de services.  Gr√¢ce √† OAuth 2.0, l'utilisateur n'a pas besoin de saisir son mot de passe en dehors du prestataire: l'ensemble du processus se r√©duit √† cliquer sur le bouton "J'accepte de donner acc√®s √† ...". <br><br>  Un fournisseur est un service qui d√©tient les donn√©es utilisateur et, avec l'autorisation de l'utilisateur, fournit des services tiers (clients) avec un acc√®s s√©curis√© √† ces donn√©es.  Un client est une application qui souhaite obtenir les donn√©es utilisateur stock√©es par le fournisseur. <br><br>  Peu de temps apr√®s la publication du protocole OAuth 2.0, il a √©t√© adapt√© pour l' <i>authentification</i> , m√™me s'il n'√©tait pas destin√© √† cela.  L'utilisation d'OAuth 2.0 pour l'authentification d√©place un vecteur d'attaque des donn√©es stock√©es chez le fournisseur de services vers les comptes d'utilisateurs du service client. <br><br>  Mais l'authentification n'√©tait qu'un d√©but.  √Ä l'√©poque des applications mobiles et de la glorification des conversions, acc√©der √† une application avec un seul bouton semblait agr√©able.  Les d√©veloppeurs ont adapt√© OAuth 2.0 pour une utilisation mobile.  Bien s√ªr, peu de gens se sont inqui√©t√©s de la s√©curit√© et des sp√©cificit√©s des applications mobiles: zappez et dans la production, ils sont all√©s!  L√† encore, OAuth 2.0 ne fonctionne pas bien en dehors des applications Web: il y a les m√™mes probl√®mes dans les applications mobiles et de bureau. <br><br>  Voyons donc comment s√©curiser OAuth 2.0 mobile. <br><br><h1>  Comment √ßa marche? </h1><br>  Il existe deux principaux probl√®mes de s√©curit√© pour OAuth 2.0 mobile: <br><br><ol><li>  Client non fiable.  Certaines applications mobiles n'ont pas de backend pour OAuth 2.0, donc la partie client du flux de protocole va sur l'appareil mobile. <br></li><li>  Les redirections d'un navigateur vers une application mobile se comportent diff√©remment selon les param√®tres du syst√®me, l'ordre dans lequel les applications sont install√©es et d'autres √©l√©ments magiques. <br></li></ol><br>  Examinons en profondeur ces probl√®mes. <br><br><h4>  L'application mobile est un client public </h4><br>  Pour comprendre les racines et les cons√©quences du premier probl√®me, voyons comment OAuth 2.0 fonctionne en cas d'interaction de serveur √† serveur, puis comparons-le avec OAuth 2.0 en cas d'interaction client-serveur. <br><br>  Dans les deux cas, tout commence par les registres du service client sur le service fournisseur et re√ßoit <code>client_id</code> et <code>,</code> dans certains cas <code>, client_secret. client_id</code>  <code>, client_secret. client_id</code> est une valeur publique, et elle est requise pour l'identification du service client par opposition √† la valeur <code>client_secret</code> , qui est priv√©e.  Vous pouvez en savoir plus sur le processus d'enregistrement dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 7591</a> . <br><br>  Le sch√©ma ci-dessous montre le fonctionnement d'OAuth 2.0 en cas d'interaction de serveur √† serveur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/689/61f/9a668961fd270118492bec6134a1aca9.png"><br>  <i>Origine de l'image: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Le protocole OAuth 2.0 peut √™tre divis√© en trois √©tapes principales: <br><br><ol><li>  [√©tapes AC] Recevez un <code>code</code> <code>authorization_code</code> (ci-apr√®s, <code>code</code> ). <br></li><li>  [√©tapes DE] √âchangez le <code>code</code> pour <code>access_token</code> . <br></li><li>  Obtenez la ressource via <code>access_token</code> . </li></ol><br><br>  D√©veloppons le processus d'obtention de <code>code</code> valeur du <code>code</code> : <br><br><ol><li>  [√âtape A] Le client redirige l'utilisateur vers le fournisseur de services. <br></li><li>  [√âtape B] Le fournisseur de services demande l'autorisation √† l'utilisateur de fournir les donn√©es au client (fl√®che B vers le haut).  L'utilisateur fournit un acc√®s aux donn√©es (fl√®che B √† droite). <br></li><li>  [√âtape C] Le fournisseur de services renvoie le <code>code</code> au navigateur de l'utilisateur qui redirige le <code>code</code> vers le client. <br></li></ol><br>  Parlons davantage du processus d'obtention de <code>access_token</code> : <br><br><ol><li>  [√âtape D] Le serveur client envoie une demande d' <code>access_token</code> .  <code>Code</code> , <code>client_secret</code> et <code>redirect_uri</code> sont inclus dans la demande. <br></li><li>  [√âtape E] En cas de <code>code</code> valide, <code>client_secret</code> et <code>redirect_uri</code> , <code>access_token</code> est fourni. <br></li></ol><br>  La demande d' <code>access_token</code> se fait selon le sch√©ma de serveur √† serveur: par cons√©quent, en g√©n√©ral, l'attaquant doit pirater le serveur de service client ou le serveur du fournisseur de services afin de voler <code>access_token</code> . <br><br>  Examinons maintenant le sch√©ma OAuth 2.0 mobile sans backend (interaction client-serveur). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Origine de l'image: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Le sch√©ma principal est divis√© en les m√™mes √©tapes principales: <br><br><ol><li>  [√©tapes 1-4 dans l'image] Obtenez le <code>code</code> . </li><li>  [√©tapes 5-6 dans l'image] <code>code</code> √©change pour <code>access_token</code> </li><li>  Acc√©dez aux ressources via <code>access_token</code> </li></ol><br>  Cependant, dans ce cas, l'application mobile a √©galement les fonctions de serveur;  par cons√©quent, <code>client_secret</code> serait int√©gr√© √† l'application.  Par cons√©quent, <code>client_secret</code> ne peut pas √™tre cach√© aux attaquants sur les appareils mobiles.  Le <code>client_secret</code> int√©gr√© peut √™tre extrait de deux mani√®res: en analysant le trafic d'application vers serveur ou par r√©tro-ing√©nierie.  Les deux peuvent √™tre facilement impl√©ment√©s, et c'est pourquoi <code>client_secret</code> est inutile sur les appareils mobiles. <br><br>  Vous pourriez vous demander: "Pourquoi ne recevons-nous pas <code>access_token</code> ?"  Vous pourriez penser que cette √©tape suppl√©mentaire n'est pas n√©cessaire.  De plus, il existe un sch√©ma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention implicite</a> qui permet √† un client de recevoir <code>access_token</code> .  M√™me si elle peut √™tre utilis√©e dans certains cas, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention implicite</a> ne fonctionnerait pas pour OAuth 2.0 mobile s√©curis√©. <br><br><h4>  Redirection sur les appareils mobiles </h4><br>  En g√©n√©ral, le m√©canisme d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">URI personnalis√©</a> et les m√©canismes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppLink</a> sont utilis√©s pour la redirection du navigateur vers l'application.  Aucun de ces m√©canismes ne peut √™tre aussi s√ªr que le navigateur redirige seul. <br><br>  <i>Le sch√©ma d'URI personnalis√©</i> (ou lien profond) est utilis√© de la mani√®re suivante: un d√©veloppeur d√©termine un sch√©ma d'application avant le d√©ploiement.  Le sch√©ma peut √™tre n'importe lequel et un appareil peut avoir plusieurs applications avec le m√™me sch√©ma. <br><br>  Cela facilite les choses lorsque chaque sch√©ma d'un appareil correspond √† une application.  Mais que se passe-t-il si deux applications enregistrent le m√™me sch√©ma sur un seul appareil?  Comment le syst√®me d'exploitation d√©cide-t-il quelle application ouvrir lorsqu'il est contact√© via un sch√©ma d'URI personnalis√©?  Android affichera une fen√™tre avec le choix d'une application et un lien √† suivre.  iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'a pas de proc√©dure pour cela</a> et, par cons√©quent, l'une ou l'autre application peut √™tre ouverte.  Quoi qu'il en soit, l'attaquant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a la possibilit√© d'intercepter du code ou access_token</a> . <br><br>  Contrairement au sch√©ma d'URI personnalis√©, <i>AppLink</i> garantit d'ouvrir la bonne application, mais ce m√©canisme pr√©sente plusieurs d√©fauts: <br><br><ol><li>  Chaque client du service doit subir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la proc√©dure de v√©rification</a> . <br></li><li>  Les utilisateurs d'Android peuvent d√©sactiver AppLink pour une application sp√©cifique dans les param√®tres. <br></li><li>  Les versions Android ant√©rieures √† 6.0 et les versions iOS ant√©rieures √† 9.0 ne prennent pas en charge AppLink. <br></li></ol><br>  Toutes ces failles AppLink augmentent la courbe d'apprentissage pour les clients de services potentiels et peuvent entra√Æner une d√©faillance de l'utilisateur OAuth 2.0 dans certaines circonstances.  C'est pourquoi de nombreux d√©veloppeurs ne choisissent pas le m√©canisme AppLink comme substitution pour la redirection de navigateur dans le protocole OAuth 2.0. <br><br><h1>  OK, qu'est-ce qu'il y a √† attaquer? </h1><br>  Les probl√®mes li√©s √† Mobile OAuth 2.0 ont cr√©√© des attaques sp√©cifiques.  Voyons ce qu'ils sont et comment ils fonctionnent. <br><br><a name="1"></a><h4>  Attaque d'interception de code d'autorisation </h4><br>  Consid√©rons la situation o√π la machine utilisateur a une application l√©gitime (client OAuth 2.0) et une application malveillante qui a enregistr√© le m√™me sch√©ma que celui l√©gitime.  L'image ci-dessous montre le sch√©ma d'attaque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d79/b98/46e/d79b9846e18e85a546b32a5927cdd627.png"><br>  <i>Origine de l'image <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Voici le probl√®me: √† la quatri√®me √©tape, le navigateur renvoie le <code>code</code> dans l'application via un sch√©ma d'URI personnalis√© et, par cons√©quent, le <code>code</code> peut √™tre intercept√© par une application malveillante (car il est enregistr√© le m√™me sch√©ma qu'une application l√©gitime).  Ensuite, l'application malveillante modifie le <code>code</code> en <code>access_token</code> et re√ßoit l'acc√®s aux donn√©es de l'utilisateur. <br><br>  Quelle est la protection?  Dans certains cas, vous pouvez utiliser la communication inter-processus;  nous en parlerons plus tard.  En g√©n√©ral, vous avez besoin d'un sch√©ma appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cl√© de preuve pour l'√©change de code</a> .  Il est d√©crit dans le sch√©ma ci-dessous. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac2/289/967/ac2289967122b9d5f458e35ab2a0d902.png"><br>  <i>Origine de l'image: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  La demande client a plusieurs param√®tres suppl√©mentaires: <code>code_verifier</code> , <code>code_challenge</code> (dans le sch√©ma <code>t(code_verifier)</code> ) et <code>code_challenge_method</code> (dans le sch√©ma <code>t_m</code> ). <br><br>  <code>Code_verifier</code> - est un nombre al√©atoire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'une longueur minimale de 256 bits</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui n'est utilis√© qu'une seule fois</a> .  Ainsi, un client doit g√©n√©rer un nouveau <code>code_verifier</code> pour chaque demande de <code>code</code> . <br><br>  <code>Code_challenge_method</code> - il s'agit du nom d'une fonction de conversion, principalement SHA-256. <br><br>  <code>Code_challenge</code> - est <code>code_verifier</code> auquel la conversion <code>code_challenge_method</code> √©t√© appliqu√©e et qui a √©t√© cod√© dans URL Safe Base64. <br><br>  La conversion de <code>code_verifier</code> en <code>code_challenge</code> est n√©cessaire pour repousser les vecteurs d'attaque bas√©s sur l'interception de <code>code_verifier</code> (par exemple, √† partir des journaux syst√®me de l'appareil) lors de la demande de <code>code</code> . <br><br>  Dans le cas o√π une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> utilisateur <b>ne prend pas en charge</b> SHA-256, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> .  Dans tous les autres cas, SHA-256 doit √™tre utilis√©. <br><br>  Voici comment fonctionne ce sch√©ma: <br><br><ol><li>  Le client g√©n√®re <code>code_verifier</code> et le m√©morise. <br></li><li>  Le client choisit <code>code_challenge_method</code> et re√ßoit <code>code_challenge</code> de <code>code_verifier</code> . <br></li><li>  [√âtape A] Le client demande du <code>code</code> , avec <code>code_challenge</code> et <code>code_challenge_method</code> ajout√©s √† la demande. <br></li><li>  [√âtape B] Le fournisseur stocke <code>code_challenge</code> et <code>code_challenge_method</code> sur le serveur et renvoie le <code>code</code> √† un client. <br></li><li>  [√âtape C] Le client demande <code>access_token</code> , auquel <code>code_verifier</code> ajout√© <code>code_verifier</code> . <br></li><li>  Le fournisseur re√ßoit <code>code_challenge</code> de <code>code_challenge</code> entrant, puis le compare √† <code>code_challenge</code> , qu'il a enregistr√©. <br></li><li>  [√âtape D] Si les valeurs correspondent, le fournisseur donne au client <code>access_token</code> . <br></li></ol><br>  Pour comprendre pourquoi <code>code_challenge</code> interception de code, voyons √† quoi ressemble le flux de protocole du point de vue de l'attaquant. <br><br><ol><li>  Tout d'abord, le <code>code</code> demandes d'application l√©gitimes ( <code>code_challenge</code> et <code>code_challenge_method</code> sont envoy√©s avec la <b>demande</b> ). <br></li><li>  Une application malveillante intercepte le <code>code</code> (mais pas <code>code_challenge</code> , car le code <code>_challenge</code> ne figure pas dans la r√©ponse). <br></li><li>  Une application malveillante demande <code>access_token</code> (avec un <code>code</code> valide, mais <b>sans</b> <code>code_verifier</code> valide). <br></li><li>  Le serveur remarque une incompatibilit√© de <code>code_challenge</code> et d√©clenche un message d'erreur. <br></li></ol><br>  Notez que l'attaquant ne peut pas deviner <code>code_verifier</code> (valeur al√©atoire de 256 bits!) Ou le trouver quelque part dans les journaux (puisque la premi√®re requ√™te a r√©ellement transmis <code>code_challenge</code> ). <br><br>  Ainsi, <code>code_challenge</code> r√©pond √† la question du fournisseur de services: " <code>access_token</code> est- <code>access_token</code> demand√© par le m√™me client d'application qui a demand√© le <code>code</code> ou un autre?". <br><br><h4>  OAuth 2.0 CSRF </h4><br>  OAuth 2.0 CSRF est relativement inoffensif lorsque OAuth 2.0 est utilis√© pour l'autorisation.  C'est une tout autre histoire quand OAuth 2.0 est utilis√© pour l'authentification.  Dans ce cas, OAuth 2.0 CSRF conduit souvent √† une prise de contr√¥le de compte. <br><br>  Parlons plus de l'attaque CSRF conform√©ment √† OAuth 2.0 √† travers l'exemple du client de l'application de taxi et du fournisseur provider.com.  Tout d'abord, un attaquant sur son propre appareil se connecte au compte <code>attacker@provider.com</code> et re√ßoit le <code>code</code> de taxi.  Il interrompt ensuite le processus OAuth 2.0 et g√©n√®re un lien: <br><br><pre> <code class="plaintext hljs">com.taxi.app://oauth? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4</code> </pre> <br>  Ensuite, l'attaquant envoie ce lien √† sa victime, par exemple, sous la forme d'un courrier ou d'un message texte provenant de taxi.  La victime clique sur le lien, l'application taxi s'ouvre et re√ßoit <code>access_token</code> .  En cons√©quence, ils se retrouvent dans le compte de taxi de l' <b>attaquant</b> .  Ignorant cela, la victime utilise ce compte: faire des voyages, saisir des donn√©es personnelles, etc. <br><br>  D√©sormais, l'attaquant peut se connecter √† tout moment au compte de taxi de la victime, car il est li√© √† <a href=""><code>attacker@provider.com</code></a> .  L'attaque de connexion CSRF a permis au contrevenant de voler un compte. <br><br>  Les attaques CSRF sont g√©n√©ralement repouss√©es avec un jeton CSRF (il est √©galement appel√© <code>state</code> ), et OAuth 2.0 ne fait pas exception.  Comment utiliser le jeton CSRF: <br><br><ol><li>  L'application client g√©n√®re et enregistre le jeton CSRF sur l'appareil mobile d'un client. <br></li><li>  L'application client inclut le jeton CSRF dans la demande d'acc√®s au <code>code</code> . <br></li><li>  Le serveur renvoie le m√™me jeton CSRF avec le <code>code</code> dans sa r√©ponse. <br></li><li>  L'application client compare les jetons CSRF entrants et enregistr√©s.  Si leurs valeurs correspondent, le processus se poursuit. <br></li></ol><br>  Exigences de jeton CSRF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nonce</a> doit √™tre d'au moins 256 bits et re√ßu d'une bonne source de s√©quences pseudo-al√©atoires. <br><br>  En bref, le jeton CSRF permet √† un client d'application de r√©pondre √† la question suivante: "Est-ce moi qui <code>access_token</code> lanc√© la demande <code>access_token</code> ou quelqu'un essaie de me <code>access_token</code> ?". <br><br><h4>  Secret client cod√© en dur </h4><br>  Les applications mobiles sans backend stockent parfois des valeurs <code>client_id</code> et <code>client_secret</code> <code>client_id</code> dur.  Bien s√ªr, ils peuvent √™tre facilement extraits par une application d'ing√©nierie inverse. <br><br>  L'impact de l'exposition de <code>client_id</code> et <code>client_secret</code> d√©pend fortement de la quantit√© de fournisseur de services de confiance mise sur la certaine paire <code>client_id</code> , <code>client_secret</code> .  On les utilise juste pour distinguer un client d'un autre tandis que d'autres ouvrent des points de terminaison d'API cach√©s ou font des limites de taux plus souples pour certains clients. <br><br>  L'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi les cl√©s et les secrets de l'API OAuth ne sont pas s√ªrs dans les applications mobiles</a> d√©veloppe plus sur ce sujet. <br><br><h4>  Application malveillante agissant en tant que client l√©gitime </h4><br>  Certaines applications malveillantes peuvent imiter les applications l√©gitimes et afficher un √©cran de consentement en leur nom (un √©cran de consentement est un √©cran o√π un utilisateur voit: "J'accepte de fournir l'acc√®s √† ...").  L'utilisateur peut cliquer sur ¬´autoriser¬ª et fournir √† l'application malveillante ses donn√©es. <br><br>  Android et iOS fournissent les m√©canismes de recoupement des applications.  Un fournisseur d'application peut s'assurer qu'une application client est l√©gitime et vice versa. <br><br>  Malheureusement, si le m√©canisme OAuth 2.0 utilise un thread via un navigateur, il est impossible de se d√©fendre contre cette attaque. <br><br><h4>  Autres attaques </h4><br>  Nous avons examin√© de plus pr√®s les attaques exclusives au mobile OAuth 2.0.  Cependant, n'oublions pas l'original OAuth 2.0: substitution <code>redirect_uri</code> , interception du trafic via une connexion non s√©curis√©e, etc.  Vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h1>  Comment le faire en toute s√©curit√©? </h1><br>  Nous avons appris le fonctionnement du protocole OAuth 2.0 et ses vuln√©rabilit√©s sur les appareils mobiles.  Maintenant, assemblons les pi√®ces s√©par√©es pour avoir un sch√©ma OAuth 2.0 mobile s√©curis√©. <br><br><h4>  Bon, mauvais OAuth 2.0 </h4><br>  Commen√ßons par la bonne fa√ßon d'utiliser l'√©cran de consentement.  Les appareils mobiles ont deux fa√ßons d'ouvrir une page Web dans une application mobile. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/d1e/75a/740d1e75aedec07de286cf9d7fc49292.png"><br><br>  La premi√®re fa√ßon est via l'onglet personnalis√© du navigateur (√† gauche sur l'image).  <b>Remarque</b> : l'onglet personnalis√© du navigateur pour Android est appel√© onglet personnalis√© Chrome et pour iOS - SafariViewController.  C'est juste un onglet de navigateur affich√© dans l'application: il n'y a pas de basculement visuel entre les applications. <br><br>  La deuxi√®me fa√ßon se fait via WebView (√† droite sur la photo) et je le consid√®re mauvais par rapport au mobile OAuth 2.0. <br><br>  WebView est un navigateur int√©gr√© pour une application mobile. <br><br>  " <i>Navigateur int√©gr√©</i> " signifie que l'acc√®s aux cookies, au stockage, au cache, √† l'historique et √† d'autres donn√©es Safari et Chrome est interdit pour WebView.  L'inverse est √©galement correct: Safari et Chrome ne peuvent pas acc√©der aux donn√©es WebView. <br><br>  ¬´ <i>Navigateur d'applications mobiles</i> ¬ª signifie qu'une application mobile qui ex√©cute WebView a <b>un</b> acc√®s <b>complet</b> aux cookies, au stockage, au cache, √† l'historique et √† d'autres donn√©es WebView. <br><br>  Maintenant, imaginez: un utilisateur clique sur "entrer avec ..." et une WebView d'une application malveillante demande son identifiant et son mot de passe au fournisseur de services. <br><br>  √âchec √©pique: <br><br><ol><li>  L'utilisateur entre son identifiant et son mot de passe pour le compte du fournisseur de services dans l'application, qui peut facilement voler ces donn√©es. <br></li><li>  OAuth 2.0 a √©t√© initialement d√©velopp√© pour <i>ne pas entrer le login et le mot de passe du fournisseur de services.</i> <i><br></i> <br>  L'utilisateur s'habitue √† saisir son identifiant et son mot de passe n'importe o√π, augmentant ainsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> possibilit√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">p√™che</a> . <br></li></ol><br>  Compte tenu de tous les inconv√©nients de WebView, une conclusion √©vidente s'offre: utilisez l'onglet personnalis√© du navigateur pour l'√©cran de consentement. <br><br>  Si quelqu'un a des arguments en faveur de WebView au lieu de l'onglet personnalis√© du navigateur, j'appr√©cierais que vous √©criviez √† ce sujet dans les commentaires. <br><br><h4>  Sch√©ma OAuth 2.0 mobile s√©curis√© </h4><br>  Nous allons utiliser le sch√©ma d'autorisation de code d'autorisation, car il nous permet d'ajouter <code>code_challenge</code> ainsi que d' <code>state</code> et de se d√©fendre contre une attaque d'interception de code et OAuth 2.0 CSRF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Origine de l'image: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  La demande d'acc√®s au code (√©tapes 1-2) se pr√©sente comme suit: <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> 3D% 3D &amp; <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  √Ä l'√©tape 3, le navigateur obtient une r√©ponse avec redirection: <br><br><pre> <code class="plaintext hljs">com.mail.cloud.app://outh? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> </pre> <br>  √Ä l'√©tape 4, le navigateur ouvre le sch√©ma d'URI personnalis√© et transmet le jeton CSRF √† une application cliente. <br>  demande <code>access_token</code> (√©tape 5): <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/token? code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  La derni√®re √©tape apporte une r√©ponse avec <code>access_token</code> . <br><br>  Ce sch√©ma est g√©n√©ralement s√©curis√©, mais il existe des cas particuliers o√π OAuth 2.0 peut √™tre plus simple et plus s√©curis√©. <br><br><h4>  IPC Android </h4><br>  Android dispose d'un m√©canisme de communication de donn√©es bidirectionnelle entre les processus: IPC (communication inter-processus).  IPC est meilleur que le sch√©ma d'URI personnalis√© pour deux raisons: <br><br><ol><li>  Une application qui ouvre le canal IPC peut confirmer l'authenticit√© d'une application qu'elle ouvre par son certificat.  L'inverse est √©galement vrai: l'application ouverte peut confirmer l'authenticit√© de l'application qui l'a ouverte. <br></li><li>  Si un exp√©diteur envoie une demande via le canal IPC, il peut recevoir une r√©ponse via le m√™me canal.  Avec le recoupement (√©l√©ment 1), cela signifie qu'aucun processus √©tranger ne peut intercepter <code>access_token</code> . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/d7c/1a9/dacd7c1a98a6d1c7227b7e8e5e24757f.png"><br><br>  Par cons√©quent, nous pouvons utiliser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention implicite</a> pour simplifier le sch√©ma OAuth 2.0 mobile.  Aucun <code>code_challenge</code> et <code>state</code> signifie √©galement moins de surface d'attaque.  Nous pouvons √©galement r√©duire les risques que des applications malveillantes agissent comme un client l√©gitime essayant de voler les comptes d'utilisateurs. <br><br><h4>  SDK pour les clients </h4><br>  Outre la mise en ≈ìuvre de ce sch√©ma OAuth 2.0 mobile s√©curis√©, un fournisseur doit d√©velopper un SDK pour ses clients.  Cela simplifiera la mise en ≈ìuvre d'OAuth 2.0 c√¥t√© client et r√©duira simultan√©ment le nombre d'erreurs et de vuln√©rabilit√©s. <br><br><h1>  Conclusions </h1><br>  Permettez-moi de le r√©sumer pour vous.  Voici la <i>liste de contr√¥le</i> (de base) <i>pour OAuth 2.0 s√©curis√©</i> pour les fournisseurs OAuth 2.0: <br><br><ol><li>  Une base solide est cruciale.  Dans le cas d'OAuth 2.0 mobile, la fondation est un sch√©ma ou un protocole choisi pour la mise en ≈ìuvre.  Il est facile de faire des erreurs lors de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation de votre propre sch√©ma OAuth 2.0</a> .  D'autres ont d√©j√† frapp√© et appris leur le√ßon;  il n'y a rien de mal √† apprendre de leurs erreurs et √† s√©curiser la mise en ≈ìuvre en une seule fois.  Le sch√©ma OAuth 2.0 mobile le plus s√©curis√© est d√©crit dans <i>Comment le faire en toute s√©curit√©</i> ? <br></li><li>  <code>Access_token</code> et d'autres donn√©es sensibles doivent √™tre stock√©s dans le trousseau pour iOS et dans le stockage interne pour Android.  Ces stockages ont √©t√© sp√©cialement d√©velopp√©s sp√©cialement pour cela.  Le fournisseur de contenu peut √™tre utilis√© dans Android, mais il doit √™tre configur√© en toute s√©curit√©. <br></li><li>  <code>Client_secret</code> est <b>inutile</b> , sauf s'il est stock√© dans le backend.  Ne le donnez pas aux clients publics. <br></li><li>  N'utilisez pas WebView pour l'√©cran de consentement;  utilisez l'onglet personnalis√© du navigateur. <br></li><li>  Pour vous d√©fendre contre une attaque d'interception de code, utilisez <code>code_challenge</code> . <br></li><li>  Pour vous d√©fendre contre OAuth 2.0 CSRF, utilisez <code>state</code> . <br></li><li>  Utilisez HTTPS <b>partout</b> , avec r√©trogradation interdite √† HTTP.  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une d√©mo de 3 minutes</a> expliquant pourquoi (avec un exemple de bug bounty). <br></li><li>  Suivez les <b>normes de</b> cryptographie (choix de l'algorithme, longueur des jetons, etc.).  Vous pouvez copier les donn√©es et comprendre pourquoi cela a √©t√© fait de cette fa√ßon, mais ne lancez pas votre propre crypto. <br></li><li>  <code>Code</code> doit √™tre utilis√© qu'une seule fois, avec une courte dur√©e de vie. <br></li><li>  Du c√¥t√© client de l'application, v√©rifiez ce que vous ouvrez pour OAuth 2.0;  et du c√¥t√© du fournisseur d'applications, v√©rifiez qui vous ouvre pour OAuth 2.0. <br></li><li>  Gardez √† l'esprit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les vuln√©rabilit√©s courantes d'OAuth 2.0</a> .  Mobile OAuth 2.0 agrandit et compl√®te l'original, par cons√©quent, la v√©rification de <code>redirect_uri</code> pour une correspondance exacte et d'autres recommandations pour OAuth 2.0 d'origine sont toujours en vigueur. <br></li><li>  Vous devez fournir √† vos clients un SDK.  Ils auront moins de bogues et de vuln√©rabilit√©s et il leur sera plus facile d'impl√©menter votre OAuth 2.0. <br></li></ol><br><h1>  Lectures compl√©mentaires </h1><br><ol><li>  "Vuln√©rabilit√©s du mobile OAuth 2.0" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.youtube.com/watch?v=vjCF_O6aZIg</a> <br></li><li>  Recherche sur les conditions de course OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://hackerone.com/reports/55140</a> <br></li><li>  Presque tout sur OAuth 2.0 en un seul endroit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://oauth.net/2/</a> <br></li><li>  Pourquoi les cl√©s et les secrets de l'API OAuth ne sont pas s√©curis√©s dans les applications mobiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps</a> <br></li><li>  [RFC] OAuth 2.0 pour les applications natives <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc8252</a> <br></li><li>  [RFC] Cl√© de preuve pour l'√©change de code par les clients publics OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7636</a> <br></li><li>  [RFC] Mod√®le de menace OAuth 2.0 et consid√©rations de s√©curit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc6819</a> <br></li><li>  [RFC] Protocole d'enregistrement de client dynamique OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7591</a> <br></li><li>  Google OAuth 2.0 pour applications mobiles et de bureau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> <br></li></ol><br><h1>  Cr√©dits </h1><br>  Merci √† tous ceux qui m'ont aid√© √† √©crire cet article.  Surtout √† Sergei Belov, Andrei Sumin, Andrey Labunets pour les commentaires sur les d√©tails techniques, √† Pavel Kruglov pour la traduction anglaise et √† Daria Yakovleva pour l'aide √† la sortie de la version russe de cet article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456702/">https://habr.com/ru/post/fr456702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456686/index.html">Les subtilit√©s des entretiens lors de l'embauche d'Udalenka</a></li>
<li><a href="../fr456690/index.html">Casques de tous les jours par Case Guru - CGPods Sport</a></li>
<li><a href="../fr456692/index.html">L'ascension et la chute de Visual Basic</a></li>
<li><a href="../fr456696/index.html">Comment les int√©r√™ts sur les pr√™ts sont-ils accumul√©s et comment les appliquer</a></li>
<li><a href="../fr456700/index.html">GeekUniversity ouvre un recrutement √† la Facult√© de gestion des produits</a></li>
<li><a href="../fr456704/index.html">Six avantages pour les testeurs (en plus des tests fonctionnels)</a></li>
<li><a href="../fr456710/index.html">Qu'est-ce qu'une plateforme low-code / no-code et CRM, CRM +, ERP</a></li>
<li><a href="../fr456712/index.html">Journalisation s√©lective du trafic pour les services SOAP</a></li>
<li><a href="../fr456714/index.html">Comprendre les nombres √† virgule flottante (partie 0)</a></li>
<li><a href="../fr456716/index.html">Pas de tr√®s gros volumes de donn√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>