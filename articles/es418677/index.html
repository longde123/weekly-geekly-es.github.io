<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöã üé° üßöüèæ Toda la verdad sobre RTOS. Art√≠culo # 6. Otros servicios RTOS üõ§Ô∏è üîé üí°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En art√≠culos anteriores, discutimos la funcionalidad del n√∫cleo en t√©rminos de las tareas realizadas y la interacci√≥n entre ellas. En este art√≠culo, o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 6. Otros servicios RTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418677/"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos anteriores,</a> discutimos la funcionalidad del n√∫cleo en t√©rminos de las tareas realizadas y la interacci√≥n entre ellas.  En este art√≠culo, observamos qu√© m√°s puede hacer el n√∫cleo, que se manifiesta en gran medida en una serie de otras llamadas API disponibles.  Tambi√©n responderemos a la pregunta, ¬øqu√© convierte el n√∫cleo en un sistema operativo? <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br><h2>  Gesti√≥n de tareas </h2><br>  Adem√°s de la programaci√≥n de tareas y la interacci√≥n entre ellos, el RTOS incluir√° la funcionalidad (llamadas a la API) para administrar tareas de varias maneras.  Consideremos algunas posibilidades. <br><br>  <b>Crear y eliminar tareas</b> <br><br>  En el RTOS "din√°mico" hay llamadas a funciones que le permiten crear tareas (y otros objetos RTOS) cuando se requieren.  Dichas llamadas incluyen una amplia gama de par√°metros que definen la tarea, por ejemplo, punto de entrada, tama√±o de pila y prioridad.  La llamada a la API de eliminaci√≥n de tareas correspondiente le permite liberar recursos despu√©s de completar la tarea. <br><br>  En el RTOS "est√°tico", los par√°metros de definici√≥n de la tarea se configuran en una especie de archivo de configuraci√≥n durante el ensamblaje. <br><br>  <b>Pausa y reanuda una tarea</b> <br><br>  Como vimos, la mayor√≠a de los RTOS tienen el concepto de un estado de tareas "suspendido".  Esto se puede lograr de varias maneras.  Una de ellas es una llamada expl√≠cita a la funci√≥n API Suspender tarea.  Puede ser causado por s√≠ mismo o por otra tarea.  La correspondiente llamada "Reanudar tarea" permite que la tarea vuelva a ponerse en cola para la planificaci√≥n. <br><br>  <b>Tarea estado de suspensi√≥n</b> <br><br>  Para un sistema en tiempo real, el control del tiempo es un requisito importante y puede adoptar diversas formas.  Una vista simple es la capacidad de la tarea de "quedarse dormido", es decir, la tarea se suspende por un cierto per√≠odo de tiempo.  Cuando se agota el tiempo, la tarea "se despierta" y nuevamente se pone en cola para su planificaci√≥n.  Una llamada API generalmente estar√° disponible para este prop√≥sito.  Por supuesto, esta funcionalidad depende de la disponibilidad del temporizador. <br><br>  <b>Exenci√≥n</b> <br><br>  Cuando se usa el programador Round Robin ("carrusel"), una tarea puede negarse a controlar el procesador para la siguiente tarea en la cadena.  Para hacer esto, la funci√≥n API "Liberar tarea" estar√° disponible.  La tarea no se suspende, estar√° disponible para la planificaci√≥n cuando llegue su turno.  Cuando se utiliza el planificador de segmentos de tiempo, es posible que una tarea pueda liberar parte de su intervalo de tiempo si no tiene un trabajo importante que hacer de inmediato.  Liberar una tarea no tiene un significado l√≥gico cuando se ejecuta Ejecutar hasta la finalizaci√≥n o Programadores prioritarios. <br><br>  <b>Tarea completada</b> <br><br>  En un art√≠culo anterior, encontramos que, adem√°s de los estados "Listo" o "Suspendido", el RTOS puede admitir otros estados de tareas.  La tarea puede ser "Finalizada", lo que significa que su funci√≥n principal acaba de salir: no se requiere una llamada API especial.  Una tarea puede ser "Terminada", lo que significa que no est√° disponible para la planificaci√≥n y debe reiniciarse para que est√© disponible para su lanzamiento nuevamente, consulte "Restablecer una tarea" a continuaci√≥n.  Esto requiere una llamada API especial.  La disponibilidad de estos estados de tareas adicionales, la terminolog√≠a utilizada y sus definiciones exactas diferir√°n seg√∫n el RTOS. <br><br>  <b>Restablecer tarea</b> <br><br>  Muchos RTOS ofrecen una llamada a la funci√≥n API "Restablecer tarea", que le permite devolver la tarea a su estado original.  Puede estar en estado suspendido y requerir que se ejecute la funci√≥n "Reanudar tarea" para hacer cola para la planificaci√≥n. <br><br>  <b>Tareas prioritarias, etc.</b> <br><br>  En un RTOS "din√°mico", las llamadas API pueden estar disponibles para configurar varios par√°metros de tareas en tiempo de ejecuci√≥n.  Los ejemplos incluyen la prioridad y la duraci√≥n del intervalo de tiempo. <br><br><h2>  Informaci√≥n del sistema </h2><br>  En RTOS, habr√° una serie de llamadas API para proporcionar al sistema informaci√≥n sobre la tarea, que incluye: <br>  <b>Informaci√≥n sobre las tareas</b> .  Cu√°ntas tareas hay en el sistema, su configuraci√≥n y estados actuales. <br>  <b>Informaci√≥n sobre otros objetos del n√∫cleo.</b>  Cu√°ntos objetos de cada tipo hay en el sistema, su configuraci√≥n e informaci√≥n sobre el estado actual.  Por ejemplo: <br><br><ul><li>  ¬øCu√°l es la capacidad actual de la cola? ¬øPuedo agregar m√°s mensajes? </li><li>  ¬øCu√°ntas tareas est√°n suspendidas en un buz√≥n particular? </li></ul>  <b>Informaci√≥n sobre la versi√≥n RTOS</b> .  Una llamada a la API puede proporcionar datos similares. <br><br><h2>  Asignaci√≥n de memoria </h2><br>  En muchas aplicaciones, es importante que el programa pueda capturar din√°micamente algo de memoria cuando sea necesario y liberarlo cuando ya no sea necesario.  Lo mismo sucede en el firmware.  Sin embargo, los enfoques convencionales son propensos a problemas que son poco probables o inconvenientes en las aplicaciones de escritorio, pero pueden ser desastrosos para un sistema integrado.  Sin embargo, hay formas de implementar dichos servicios, incluso en un RTOS est√°tico. <br><br><h2>  Problemas con las funciones malloc () y free () </h2><br>  En un programa de escritorio C, una funci√≥n puede llamar a <b>malloc ()</b> , indicando cu√°nta memoria se requiere, y recuperar un puntero al √°rea de almacenamiento.  Usando memoria, se puede liberar llamando a <b>free ()</b> .  La memoria se asigna desde un √°rea llamada mont√≥n.  El problema con este enfoque es que con una secuencia descoordinada de llamadas a estas funciones, el √°rea de almacenamiento din√°mico puede fragmentarse f√°cilmente, y luego la asignaci√≥n de memoria fallar√° incluso si hay suficiente memoria disponible, porque  Las √°reas adyacentes no son lo suficientemente grandes.  Algunos sistemas (como Java y Visual Basic) utilizan esquemas sofisticados de "recolecci√≥n de basura" para desfragmentar.  El problema es que estos esquemas pueden generar retrasos impredecibles significativos en el tiempo de ejecuci√≥n y la necesidad de utilizar punteros indirectos (que no funcionan en C). <br><br>  Si <b>malloc ()</b> y <b>free ()</b> se implementaron de forma reentrante (generalmente no) y se usaron en las tareas RTOS, la fragmentaci√≥n ocurrir√° muy r√°pidamente y una falla del sistema ser√° casi inevitable.  En C ++, hay operadores <b>nuevos</b> y de <b>eliminaci√≥n</b> que generalmente realizan las mismas funciones que malloc () y free ().  Est√°n sujetos a las mismas limitaciones y problemas. <br><br><h2>  Secciones de memoria </h2><br>  Para proporcionar un sistema en tiempo real con memoria accesible din√°micamente, se puede utilizar un enfoque de bloque para la administraci√≥n de memoria.  Tales bloques se denominan com√∫nmente "particiones";  las particiones se pueden asignar desde el "grupo de particiones". <br><br>  El grupo de particiones contiene un cierto n√∫mero de bloques, cada uno de los cuales tiene el mismo tama√±o.  El n√∫mero y el tama√±o de los bloques en una partici√≥n se determinan cuando se crea el grupo de particiones.  Esto puede ser din√°mico si el sistema lo permite, o est√°ticamente durante el ensamblaje.  Por lo general, una aplicaci√≥n puede incluir varios grupos de particiones que ofrecen bloques de diferentes tama√±os. <br><br>  Si una tarea necesita memoria, llama a una API que solicita un bloque de un grupo espec√≠fico.  Si esta llamada tiene √©xito, la tarea recibir√° un puntero al bloque seleccionado.  Si la llamada falla porque  no hay particiones disponibles en el grupo indicado, la tarea puede recibir una respuesta de error.  Alternativamente, la tarea puede bloquearse (suspenderse) hasta que otra tarea libere el bloqueo en la secci√≥n. <br><br>  T√≠picamente, una tarea simplemente pasa un puntero a un bloque de memoria en cualquier c√≥digo que use el bloque.  Esto lleva a un problema cuando el bloque ya no es necesario.  Si el c√≥digo solo tiene un puntero a un bloque, ¬øc√≥mo puede decirle al RTOS a trav√©s de una llamada API, de qu√© grupo de partici√≥n desea liberar memoria?  La respuesta es que la mayor√≠a de los RTOS admiten datos adicionales en un bloque dedicado (generalmente un desplazamiento negativo del puntero) que proporcionan la informaci√≥n requerida.  Por lo tanto, para llamar a la API para liberar un bloque, solo se requiere su direcci√≥n. <br><br>  El siguiente art√≠culo tendr√° m√°s informaci√≥n sobre particiones de memoria. <br><br><h2>  Tiempo </h2><br>  Es probable que la funcionalidad asociada con el uso y el control del tiempo est√© disponible en el sistema operativo en tiempo real.  Las oportunidades variar√°n seg√∫n el RTOS, pero consideraremos las disponibles p√∫blicamente.  En cualquier caso, el temporizador en tiempo real es un elemento indispensable para el funcionamiento de cualquiera de estos servicios. <br><br>  <b>Hora del sistema</b> <br><br>  La hora del sistema simple, o "temporizador de reloj", casi siempre est√° disponible.  Esto es solo un contador (generalmente 32 bits), que se incrementa utilizando la rutina de servicio de interrupci√≥n en tiempo real y se puede configurar y leer a trav√©s de llamadas API. <br><br>  <b>Tiempos de espera de llamadas de servicio</b> <br><br>  Normalmente, un RTOS permite bloquear llamadas API, es decir, la tarea de llamada se suspende (bloquea) hasta que se proporciona el servicio solicitado.  Por lo general, este bloqueo es vago, pero algunos RTOS ofrecen un tiempo de espera durante el cual la llamada regresa cuando expira el tiempo de espera si el servicio contin√∫a sin estar disponible.  Los tiempos de espera de llamadas de API no son compatibles con todos los RTOS. <br><br>  <b>Tarea estado de suspensi√≥n</b> <br><br>  Por lo general, las tareas tienen la capacidad de detenerse por un per√≠odo fijo de tiempo.  Esto se discuti√≥ anteriormente en la secci√≥n Gesti√≥n de tareas. <br><br>  <b>Temporizadores de software</b> <br><br>  Para que las tareas del programa realicen funciones de conteo de tiempo, la mayor√≠a de los RTOS ofrecen objetos de temporizador.  Estos son temporizadores independientes actualizados por el controlador de interrupci√≥n de temporizador en tiempo real, que puede controlarse mediante llamadas API.  Tales llamadas configuran, monitorean y monitorean la operaci√≥n del temporizador.  Como regla, se pueden configurar para una sola actuaci√≥n o reinicio autom√°tico.  Por lo general, tambi√©n se admite una rutina de caducidad, una funci√≥n que se ejecuta cada vez que un temporizador completa un ciclo.  El siguiente art√≠culo proporcionar√° m√°s informaci√≥n sobre temporizadores de software y una descripci√≥n de su implementaci√≥n. <br><br><h2>  Interrupciones, controladores y E / S </h2><br>  La medida en que los RTOS est√°n asociados con interrupciones y E / S es muy diferente.  Del mismo modo, algunos RTOS tienen una estructura muy clara para los controladores de dispositivos, lo que puede agregar problemas al elegir un producto espec√≠fico. <br><br>  <b>Interrupciones</b> <br><br>  Las interrupciones presentan un problema para RTOS por dos razones. <br><br><ul><li>  Sin ninguna precauci√≥n, el controlador de interrupciones (ISR) "robar√°" el tiempo del procesador, interrumpiendo as√≠ el comportamiento RTOS en tiempo real. </li><li>  Si el ISR realiza llamadas a la API que afectan la programaci√≥n de tareas, esto deber√≠a ser monitoreado y el RTOS deber√≠a poder ejecutar su algoritmo de programaci√≥n. </li></ul>  Un ejemplo de una llamada API de este tipo es el procedimiento para activar una tarea con una prioridad m√°s alta que la que se inici√≥ cuando se produjo la interrupci√≥n. <br><br>  Algunos RTOS controlan completamente todas las interrupciones.  Hay una serie de llamadas API disponibles para "registrar" los programas ISR.  Este enfoque permite que el planificador identifique cu√°ndo se habilitan las interrupciones y facilita el uso de la mayor√≠a de las llamadas API desde el ISR. <br><br>  Por ejemplo, Nucleus RTOS implementa el concepto de manejadores de interrupciones de "baja prioridad" y "alta prioridad", que proporciona una gesti√≥n de interrupciones confiable sin sobrecarga innecesaria (es decir, un aumento en el retraso de la interrupci√≥n). <br><br>  Otros RTOS pueden usar el modo autom√°tico de "interrupci√≥n" para las interrupciones, que proporciona a los desarrolladores m√°s opciones para garantizar que los manejadores de interrupciones funcionen correctamente.  Como regla, se proporcionan prefijo ISR (pr√≥logo) y sufijo (ep√≠logo) adicionales para proteger las llamadas API realizadas en √©l. <br>  Nucleus SE utiliza una rutina de interrupci√≥n ligera, que se describir√° en un art√≠culo futuro. <br><br>  <b>Conductores</b> <br><br>  La mayor√≠a de los RTOS determinan la estructura del controlador del dispositivo.  Los detalles pueden variar seg√∫n el RTOS, pero el controlador generalmente consta de dos componentes interactivos: c√≥digo incrustado (llamadas API) e ISR.  Por lo general, otras llamadas API estar√°n disponibles para administrar y registrar controladores. <br><br>  <b>Entrada / salida</b> <br><br>  Actualmente, la mayor√≠a de los RTOS en el mercado no se preocupan por la entrada / salida de nivel superior, pero algunos definen un flujo de entrada / salida, que b√°sicamente establece una conexi√≥n entre los controladores de dispositivo correspondientes y las funciones est√°ndar del lenguaje C, como printf (). <br>  Hist√≥ricamente, el RTOS a menudo soportaba la "consola", la interfaz de usuario para el RTOS a trav√©s de un canal en serie.  Esto se us√≥ principalmente para diagn√≥sticos y depuraci√≥n.  El uso de depuradores modernos que admiten aplicaciones de depuraci√≥n con RTOS elimina la necesidad de tales objetos. <br><br><h2>  Diagn√≥sticos </h2><br>  Por lo general, RTOS requiere un rendimiento m√°ximo con una huella de memoria m√≠nima.  Por lo tanto, la verificaci√≥n de integridad no es una alta prioridad.  Con la ayuda de tecnolog√≠as modernas de depuraci√≥n que tienen en cuenta las caracter√≠sticas del RTOS, la mayor√≠a de las comprobaciones pueden realizarse fuera del RTOS. <br><br><h2>  Comprobaci√≥n de par√°metros de llamadas de API </h2><br>  Las llamadas a la API pueden tener muchos par√°metros complejos.  Esto puede causar errores.  Muchos RTOS proporcionan una verificaci√≥n de los par√°metros de tiempo de ejecuci√≥n con la devoluci√≥n de un c√≥digo de error en caso de un par√°metro incorrecto.  Dado que esto requiere un c√≥digo adicional y las comprobaciones mismas afectan negativamente el rendimiento, es mejor verificar los par√°metros durante el ensamblaje o la configuraci√≥n. <br><br><h2>  Verificaci√≥n de pila </h2><br>  Para la mayor√≠a de los tipos de planificador (excepto Run to Completion), cada tarea tiene su propia pila, cuyo tama√±o se determina individualmente.  En algunos RTOS, el n√∫cleo tiene una pila separada, en otros, la pila de tareas es "prestada" durante una llamada API.  Obviamente, la integridad de la pila es importante para la confiabilidad general del sistema.  Por lo tanto, los RTOS a menudo ofrecen herramientas para verificar la integridad de la pila en tiempo de ejecuci√≥n.  Hay varias opciones: <br><br><ul><li>  Una llamada a la API que devuelve la cantidad de espacio de pila para la tarea actual o especificada. </li><li>  Los par√°metros delimitadores de la pila.  Se les asigna un valor √∫nico (generalmente impar y distinto de cero), que se verifica peri√≥dicamente para su reescritura. </li></ul><br><br><h2>  Diagn√≥stico de la aplicaci√≥n </h2><br>  A pesar de que esta funci√≥n no se admite directamente en el RTOS, se puede asignar una tarea de aplicaci√≥n para verificar la integridad de todo el sistema.  Tal tarea puede ser responsable de restablecer el temporizador de vigilancia.  Una tarea puede recibir datos de entrada peri√≥dicos (por ejemplo, par√°metros de se√±al) de cada tarea cr√≠tica.  El restablecimiento del temporizador de vigilancia (que evitar√° que el sistema se reinicie) se realizar√° solo despu√©s de que hayan llegado los datos de todas las tareas. <br><br><h2>  Servicios no kernel </h2><br>  El RTOS es m√°s que solo el n√∫cleo en el que nos hemos centrado hasta ahora.  Este sistema operativo de escritorio es significativamente diferente del RTOS incorporado.  Por lo general, en un sistema operativo de escritorio, todos los componentes adicionales est√°n agrupados o pueden instalarse (todas las PC de escritorio tienen una interfaz gr√°fica de usuario, y solo algunas de ellas no tienen acceso a la red).  La PC de escritorio no tiene l√≠mites de recursos reales: siempre hay memoria libre, espacio en el disco duro y recursos de CPU no utilizados.  En un mundo de sistemas integrados con recursos limitados, pueden ser necesarios componentes adicionales como tarjetas de video, componentes de red y sistemas de archivos, pero deben ser desconectables y escalables para minimizar la huella de memoria. <br><br>  <b>Funciones de red</b> <br><br>  La mayor√≠a de los sistemas integrados est√°n relacionados de alguna manera con las redes.  Por lo tanto, se espera que haya un inter√©s significativo en las soluciones de red para sistemas integrados, debido a que hay una gran cantidad de productos en el mercado. <br><br>  <b>TCP / IP</b> es un protocolo est√°ndar que se usa ampliamente y es la opci√≥n obvia para muchas aplicaciones.  Normalmente, TCP / IP se usa para el protocolo Ethernet (IEEE802.3), que proporciona una velocidad promedio de 10 Mb / s.  Hoy, 100 Mb / s son bastante comunes, y en el enfoque de 1 Gb / s.  Adem√°s, TCP / IP se puede usar para otros protocolos.  Por ejemplo, PPP (Protocolo punto a punto) es una implementaci√≥n TCP / IP para transferencia de datos en serie que se ha adaptado para conexiones de Internet de banda ancha. <br><br>  Hasta hace poco, se usaba la versi√≥n v4 del protocolo IP (IPv4).  Sin embargo, se vuelve obsoleto a medida que se agotan las direcciones libres.  La soluci√≥n es IPv6, lo que aumenta significativamente el n√∫mero de direcciones posibles y proporciona herramientas m√°s eficientes para el mantenimiento y la seguridad.  IPv6 est√° ampliamente disponible y se utiliza en equipos de muchos pa√≠ses, as√≠ como en sistemas militares de todo el mundo. <br>  Una alternativa es el Protocolo de datagramas de usuario (UDP).  Este protocolo se utiliza para obtener el m√°ximo rendimiento.  UDP no proporciona la misma confiabilidad y consistencia que TCP, pero es liviano y altamente eficiente. <br><br>  <b>USB</b> es el bus serie universal, ampliamente utilizado en dispositivos para conectarse a computadoras de escritorio.  Proporciona una interfaz plug-and-play muy f√°cil de usar que oculta software bastante sofisticado.  ,     ,      USB-,      .      ,   USB (  ),       ¬´¬ª. <br><br> <b>IEEE1394</b> ‚Äì    ,           (,   ),    FireWire  i.Link. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos inal√°mbricos: la conveniencia y la prevalencia de diversas tecnolog√≠as inal√°mbricas entre los consumidores ha llevado a una gran demanda de capacidades inal√°mbricas en dispositivos integrados. Wi-Fi (conjunto de est√°ndares IEEE802.11) proporciona un conjunto completo de capacidades de red, lo que le permite implementar topolog√≠as de pares e infraestructura a una distancia suficiente. El inter√©s en la seguridad de datos en tales redes est√° creciendo, lo que significa que esto deber√≠a afectar el software. Otras tecnolog√≠as de radio, especialmente Bluetooth y ZigBee, proporcionan comunicaciones inal√°mbricas de punto a punto de corto alcance. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificaci√≥n del protocolo</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que las oportunidades de creaci√≥n de redes tienen una gran demanda, hay muchos proveedores que ofrecen sus soluciones. Los clientes enfrentan el desaf√≠o de verificar la calidad de los productos disponibles. A diferencia del kernel RTOS, una verificaci√≥n completa de la funcionalidad y el rendimiento de la pila de protocolos no es una tarea f√°cil. Afortunadamente, hay kits de herramientas disponibles para verificar protocolos (aunque a un precio significativo), y un posible comprador puede averiguar del proveedor qu√© conjunto sol√≠a verificar. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√°ficos</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una interfaz gr√°fica se est√° volviendo m√°s com√∫n entre los dispositivos integrados. Puede ser una LCD monocrom√°tica peque√±a muy simple (como en tel√©fonos viejos, reproductores de MP3, alarmas, etc.). Por otro lado, un receptor de televisi√≥n digital puede tener su propia pantalla HDTV de alta resoluci√≥n. Tal pantalla requiere soporte de software que est√° completamente integrado en el n√∫cleo RTOS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la pantalla generalmente tiene alg√∫n tipo de dispositivo de entrada, el soporte para dichos dispositivos a menudo se incluye en el paquete de gr√°ficos. Dicho paquete puede admitir dispositivos se√±aladores (por ejemplo, un mouse), pantallas t√°ctiles, teclados y teclados completos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los gr√°ficos se pueden usar de varias maneras. Simplemente puede proporcionar informaci√≥n de salida (por ejemplo, como un marcador electr√≥nico). O la pantalla puede ser parte de una interfaz gr√°fica de usuario junto con men√∫s, ventanas, iconos y elementos similares. En cualquier caso, se requiere un conjunto de software bastante espec√≠fico, y el paquete de gr√°ficos suministrado con el RTOS debe proporcionar la flexibilidad necesaria sin aumentar significativamente la cantidad de memoria utilizada. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistemas de archivos</font></font></b> <br><br>          , ,        -  .     RAM,   -,  ,        (CD-ROM  DVD-ROM).  ,          .            . <br><br>       . ,   ,   MS-DOS,               . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418677/">https://habr.com/ru/post/es418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418665/index.html">Adaptaci√≥n del proyecto MR para HoloLens</a></li>
<li><a href="../es418667/index.html">Evaluaci√≥n comparativa de HDFS 3 con HDFS 2</a></li>
<li><a href="../es418669/index.html">Semana de la seguridad 28: NetSpectre, ataque a canales de terceros a trav√©s de la red</a></li>
<li><a href="../es418673/index.html">Por qu√© est√° creciendo el mercado ERP: estad√≠sticas y tendencias</a></li>
<li><a href="../es418675/index.html">C√≥mo fui a Droidcon Berlin</a></li>
<li><a href="../es418679/index.html">Escribimos un componente con botones de "material" para Svelte</a></li>
<li><a href="../es418681/index.html">D√≠a de la amistad: 50% de descuento en todos los IDE de JetBrains para nuestros amigos</a></li>
<li><a href="../es418683/index.html">Creaci√≥n de una m√°quina arcade emulador. Parte 2</a></li>
<li><a href="../es418685/index.html">Generaci√≥n de nivel de procedimiento</a></li>
<li><a href="../es418687/index.html">Revoluci√≥n de 3.5 ": detalles de un peque√±o boom de disquetes con vapores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>