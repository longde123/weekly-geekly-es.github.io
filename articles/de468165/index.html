<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 🙆🏻 🙌 Wie der Browser zeichnet. Yandex-Bericht 👨‍👦‍👦 🐝 🍢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bis vor kurzem habe ich im Yandex.Browser-Team gearbeitet und im Anschluss an diese Erfahrung eine Präsentation auf der YaTalks-Konferenz gehalten. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie der Browser zeichnet. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/468165/">  Bis vor kurzem habe ich im Yandex.Browser-Team gearbeitet und im Anschluss an diese Erfahrung eine Präsentation auf der YaTalks-Konferenz gehalten.  In dem Bericht ging es darum, was der Browser unter der Haube hat und wie Ihre Seiten auf dem Bildschirm in Pixel umgewandelt werden.  Minimales Frontend, nur die Innenseiten des Browsers, nur Hardcore. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/1a/v_/yd/1av_ydaayfggjaxus6mfz_dtazu.jpeg"></a> <br><br>  - Hallo allerseits, mein Name ist Kostya.  Überraschenderweise arbeite ich jetzt im Team des virtuellen Netzwerks Yandex.Cloud.  Zuvor hatte ich mehr als fünf Jahre im Browser-Team gearbeitet, daher werde ich heute über Dinge sprechen, die uns und Ihnen gemeinsam sind. <br><br><a name="habracut"></a>  Wie Sie sich vorstellen können, verstehe ich das Frontend nicht sehr gut.  Wenn Sie mit mir über React oder ähnliches sprechen, werde ich Sie wahrscheinlich nicht verstehen.  Aber ich habe viele Dinge im Browser getan: Videodecodierung, Geschäftslogik.  Einschließlich ich habe viel Zeit damit verbracht, verschiedene Dinge beim Rendern des Browsers zu tun.  Heute werden wir beispielsweise ein solches Bildungsprogramm über das interne Gerät des Browsers haben.  Ich werde versuchen, die interessantesten Dinge durchzugehen, die wir in Yandex.Browser oder Google in Chromium gemacht haben. <br><br><img src="https://habrastorage.org/webt/cu/uk/m0/cuukm04v2xohnl0t4x2u86qf6je.jpeg"><br><br>  Wenn wir über das Rendern im Browser sprechen, ist dies eine sehr komplizierte Sache, die aus einer großen Anzahl von Komponenten besteht.  Zunächst müssen Sie Ressourcen herunterladen, um sie anzuzeigen.  Dann müssen Sie sie analysieren, einen DOM-Baum, Stile, Layouts usw. erstellen. Die ersten drei Punkte sind Ihnen höchstwahrscheinlich bekannt.  Mein Bericht wird sich mehr den anderen drei Teilen widmen: Malen, Rastern und Zusammensetzen - was passiert unter der Haube, wenn Sie das Layout bereits geschrieben haben.  Nur in Worten kann es so aussehen, als ob es sich um dasselbe handelt - tatsächlich handelt es sich um völlig unterschiedliche Komponenten. <br><br><img src="https://habrastorage.org/webt/pv/zd/ww/pvzdwwy3xvf6s3os0z3edvey3hw.jpeg"><br>  ￼ <br>  Beginnen wir mit Malen und Zusammensetzen.  Worum geht es hier?  Gehen wir zurück vor vielen, vielen Jahren, als das Web nicht so komplex war wie heute, als es nicht alle Arten von 3D-, CSS-Animationen und anderen Dingen gab.  Wie hat dann der Browser gezeichnet?  Stellen Sie sich vor, Sie haben Ihre Seite, einige wundervolle Elemente, Bilder usw. Der Browser hat all dies auf eine kräftige Textur in einem großen Speicherblock gemalt.  Er wusste, wie man jedes Element zeichnet, und wenn wir Änderungen hatten, werden diese gelb hervorgehoben, so etwas wie das Folgende geschah. <br><br>  Der Browser hat sie in Bereichen zusammengefasst, die hier blau angezeigt werden.  In diesem Bereich hat sich etwas geändert. Zeichnen wir ihn neu.  Alles in diesem Bereich wurde einfach neu gezeichnet und in die Textur kopiert. <br><br>  Es hat für sich selbst funktioniert.  Dann kamen kluge Leute auf 3D-CSS-Animationen, andere Dinge.  Wir könnten viele Renderings an verschiedenen Orten haben.  Wenn wir einen Spinner drehen, ist es nicht sehr effektiv, den gesamten Kreis der Elemente, die sich darunter befinden, neu zu zeichnen. <br><br><img src="https://habrastorage.org/webt/lp/9p/sh/lp9pshbw-k3xjwunjubol_xvo5k.jpeg"><br><br>  Dann beschlossen andere kluge Leute, alles ein wenig zu wiederholen.  Wir haben eine Art DOM-Baum, wir haben ihn im Speicher erstellt.  Dies sind Plus-Objekte. Sie werden mit dem von Ihnen geschriebenen Layout verglichen. <br><br><img src="https://habrastorage.org/webt/mq/m4/m6/mqm4m6-oocbnsypvc2uu_t1wame.jpeg"><br><br>  Und dann beginnt die Magie zu geschehen.  Der Browser konvertiert den gesamten DOM-Baum in einen Renderobjektbaum.  Dieses Ding weiß, wie man jedes spezifische DOM-Element zeichnet.  Das heißt, sie weiß, was zu tun ist, damit anstelle Ihres Baums oder P-Elements etwas auf dem Bildschirm angezeigt wird. <br><br><img src="https://habrastorage.org/webt/qh/lc/li/qhlcli9pyhe2-k1ikbuhytv5itu.jpeg"><br><br>  Der nächste Baum ist der Baum der Schichten.  Was ist das?  Jedes unserer Elemente kann einer beliebigen Ebene zugeordnet werden, und eine Renderebene kann mehrere Objekte gleichzeitig enthalten.  Warum wird das gemacht?  Dies wird hier sehr gut gezeigt.  Wir generieren eine Reihe von Ebenen, von denen jede bestimmte Elemente enthält.  Angenommen, auf einer der Ebenen ändert sich etwas - eine Animation findet statt, ein Stempelelement fliegt.  Dann zeichnen wir nur eine Ebene neu und der Rest, zum Beispiel der Hintergrund, bleibt unverändert.  Wir kleben sie dann einfach in Verbundwerkstoffe und erhalten am Ausgang das endgültige Bild - den aktuellen Frame der Animation. <br><br><img src="https://habrastorage.org/webt/lz/y5/4m/lzy54mvjeae-hnulzhsafu68m5g.jpeg"><br><br>  Es gibt eine Reihe fester Gründe für das Erstellen neuer Ebenen.  Beispielsweise wird eine Ebene erstellt, um 3D-CSS-Animationen, eine Leinwand und ein Videoelement darauf zu rendern - im Allgemeinen etwas, das sich auf schwere Animationen bezieht und zum separaten Zeichnen von allen anderen Inhalten geeignet ist. <br><br><img src="https://habrastorage.org/webt/0z/m3/tu/0zm3tuitlzjxxqdiyldzh26xd60.jpeg"><br><br>  Dieser Ansatz weist jedoch mehrere Probleme auf.  Jetzt müssen Sie den Kraftstoff einschalten.  Überlegen Sie, was hier abgebildet wird?  Es gibt nur zwei Elemente. <br><br><img src="https://habrastorage.org/webt/gl/c6/op/glc6opdar5a1kpd4oblgxin6cgg.jpeg"><br><br>  Hier.  Obwohl es scheint, dass die Elemente einzeln angeordnet sind.  Warum fliegt Leinwand hoch?  In unserem Land sind sie nacheinander angeordnet, ich habe keine Reihenfolge festgelegt. <br><br><img src="https://habrastorage.org/webt/gh/fk/8h/ghfk8hcwyrsk1se3g69uxobhs0y.jpeg"><br><br>  Lassen Sie uns komplizieren.  Hier haben wir noch einen Div, so. <br><br><img src="https://habrastorage.org/webt/sp/fy/kw/spfykw2_mvn88iagm46zaonkteg.jpeg"><br><br>  Im Allgemeinen das erwartete Verhalten.  Wir haben ein Div über dem Div, aber Leinwand ist aus irgendeinem Grund oben.  Die Magie!  Ok, lassen Sie uns dieses Beispiel noch einmal komplizieren. <br><br><img src="https://habrastorage.org/webt/k9/0r/jq/k90rjqxakei6oiidlklf5s2i1ia.jpeg"><br><br>  Genau eine Zeile hat sich geändert, ich habe transform hinzugefügt. <br><br><img src="https://habrastorage.org/webt/os/dm/bp/osdmbp6jkrfzdmrgabry61pjngi.jpeg"><br><br>  Und jetzt haben wir alles richtig positioniert - zumindest in Bezug auf Leinwand und Div.  Aber dieses Div befindet sich immer noch unten, obwohl es das nächste Element in unserem Layout war. <br><br>  Dies ist der sogenannte grundlegende Compositing-Fehler.  Wenn Sie nach dem Chromium-Tracker suchen, werden Sie eine Reihe von Fehlern sehen, die mit einem alten verknüpft sind.  Er heißt so. <br><br><img src="https://habrastorage.org/webt/kp/go/nx/kpgonxbu5yxy_7immr2urgfurva.jpeg"><br><br>  Also, was ist passiert?  Wie gesagt, einige Elemente werden auf der Renderebene gerendert, andere nicht.  Einige werden zusammen mit anderen gezeichnet.  Hier geschah Folgendes: div-Elemente bleiben in derselben Ebene wie der Hintergrund.  Canvas stürzt auf einer separaten Ebene ab.  Und die Z-Reihenfolge wird nur zwischen Schichten ausgeführt.  Aufgrund der Tatsache, dass wir einen Hintergrund und ein Div in einer Ebene und eine Leinwand in einer anderen haben, erhalten wir einen Fehler: Leinwand überlappt die Div. <br><br>  Sobald wir dieses div-Element auf eine separate Ebene verschieben und es beginnt, die z-Ordnung normal zu verwenden, beginnt es auch zu verstehen, wer hinter wem steht.  Und hier wird alles "normal" gemacht. <br><br><img src="https://habrastorage.org/webt/nl/ju/4j/nlju4jxtrt-1x7fjliv5hy8io3i.jpeg"><br><br>  Und eine der letzten Initiativen, die sich seit mehreren Jahren entwickelt hat, ist die sogenannte Schlankheitsfarbe, die das Problem beheben sollte.  Seine Bedeutung ist, dass wir das Malen vom Zeichnen in Ebenen trennen müssen, dh verstehen müssen, was getan werden muss, um diese Elemente zu zeichnen, und wie wir sie dann miteinander zusammensetzen können.  Wenn wir ein so einfaches Layout haben, wird es zu so etwas.  Es gibt eine einfache Liste von Befehlen, die Sie ausführen müssen, um Seiteninhalte abzurufen.  Und wenn wir zu diesem Beispiel zurückkehren, wird es ungefähr so ​​aussehen. <br><br><img src="https://habrastorage.org/webt/yd/fw/s7/ydfws7bge3oaylgwnr7mlojtivy.jpeg"><br>  ￼ <br>  Das heißt, wir sagten: Hier ist Paint für Sie, hier ist der Inhalt für Sie - bitte geben Sie mir etwas.  Es enthält eine Liste zum Rendern, die an Compositor gesendet wird, und Compositor versteht es, den gesamten Inhalt in Ebenen zu unterteilen, sodass sie normalerweise relativ zueinander angeordnet sind. <br><br>  Und wenn Sie es nicht bemerkt haben, ist dies ein Screenshot von Chrome.  Ich habe es vor ungefähr zwei Wochen geschafft, das heißt, der Fehler lebt noch.  Das Projekt ist noch nicht abgeschlossen, es befindet sich derzeit in der Entwicklung. <br><br><img src="https://habrastorage.org/webt/lk/dv/j0/lkdvj0dnnveu2o_jlmdtykxcwus.jpeg"><br>  ￼ <br>  Das heißt, der Compositor aus dieser Liste und einige geheime Kenntnisse, die Plink weitergibt, können verstehen, wie man alles richtig in Schichten legt. <br><br><img src="https://habrastorage.org/webt/li/lk/qu/lilkquciiebcpc3hjnvv_jjxuvy.jpeg"><br>  ￼ <br>  Neben der Tatsache, dass dieser Ansatz diesen Fehler im Grunde behebt, erhalten wir auch ziemlich billige Änderungen beim Rendern.  Angenommen, wir hatten eine Liste von Zeichenbefehlen und Änderungen - sagen wir, Element B verlässt, Element E wird hinzugefügt.  Dann können wir die beiden Listen einfach zusammenhalten, ohne uns um Bäume usw. kümmern zu müssen. Bei der Ausgabe erhalten wir eine neue Liste von Elementen zum Rendern und möglicherweise eine neue Liste von Ebenen, die in Zukunft kompiliert werden. <br><br>  Dies war eine kurze Geschichte darüber, was passiert, wenn der Browser Paint implementiert und was passiert, nachdem er versucht hat, Ebenen zu erstellen. <br>  ￼ <br>  Kommen wir zu einem anderen Thema: Rasterisierung.  Nur in Rasterization in Yandex.Browser wurden viele Dinge getan, und das habe ich auch getan.  Was bedeutet Rasterung?  Am Ende der vorherigen Phase, als wir Paint ausgeführt haben, gibt es eine Liste von Befehlen, die wir implementieren müssen, um ein Bild zu erhalten.  Rasterisierung ist die Umwandlung einer Liste von Befehlen in echte Pixel. <br><br><img src="https://habrastorage.org/webt/ap/ya/oo/apyaooljngenpae6hwzfksmptqc.jpeg"><br><br><img src="https://habrastorage.org/webt/nu/pr/pr/nuprprco-z2msvg-jcj2hnkxvic.jpeg"><br><br>  Wenn Sie im Browser-Inspektor die Registerkarte Weitere Tools → Rendern öffnen, gibt es ein Häkchen für Ebenenränder.  Und Sie sehen genau so ein Gitter.  Was ist hier los?  Wenn der Browser die Seite zeichnet, macht er jetzt nicht das Ganze.  Der Browser nimmt und unterteilt jede Ebene in eine bestimmte Anzahl solcher kleinen Quadrate.  Historisch gesehen sind sie 256 mal 256 Pixel groß.  Das heißt, jede Ebene ist in so viele separate Texturen unterteilt.  Der Inhalt der aktuellen Kachel wird dann auf jede Textur gezeichnet, und dann werden sie alle zu einer großen Textur zusammengeklebt. <br><br><img src="https://habrastorage.org/webt/1i/fr/-m/1ifr-m5llhmdoal3f-ecr9fv3mw.jpeg"><br><br>  Es hilft sehr.  Zunächst können wir nur die Kacheln neu zeichnen, die sich geändert haben.  Es ermöglicht uns aber auch, das Rendern zu priorisieren.  Das heißt, zunächst sollten die Kacheln gezeichnet werden, die der Benutzer sieht, das sogenannte Ansichtsfenster.  Dann müssen wir bald Grenze ziehen, das ist, was um das Ansichtsfenster ist.  Als nächstes folgt die Richtung der Schriftrolle: Wenn sie nach unten gescrollt wird, zeichnen wir so viel wie möglich nach unten.  Wenn hoch - ziehe so viel wie möglich hoch.  Wenn wir noch eine Speicherquote haben, werden wir etwas anderes zeichnen, aber nicht die Tatsache, dass es an diesem Punkt bleibt. <br><br><img src="https://habrastorage.org/webt/gb/aa/b1/gbaab12sjafchhn1okxtdml2yju.jpeg"><br><br>  Wir bekommen also ein ziemlich billiges Inhaltsupdate auf der Seite.  Angenommen, wir haben den aktuellen Frame verwendet und der Benutzer hat etwas deaktiviert - beispielsweise hervorgehobenen Text.  Dann zeichnen wir nur die Kacheln, die sich geändert haben. <br><br><img src="https://habrastorage.org/webt/qc/q5/it/qcq5itbfqab7ylojm1nabcwopra.jpeg"><br><br>  Das heißt, grüne Kacheln sind diejenigen, die vom vorherigen Rendering übrig geblieben sind, rote, die wir neu gezeichnet haben.  Dieser Ansatz hat jedoch andere Vorteile. <br><br><img src="https://habrastorage.org/webt/5f/xy/ip/5fxyipvzx6gfrkoy4yxl6foplgi.jpeg"><br><br>  Wir können - und Chrome hat es getan - die sogenannte Optimierung kleiner Neuzeichnungen durchführen.  Angenommen, Sie haben eine Art Pochen, Cursor oder ähnliches, das in einem kleinen Rechteck ein wenig neu gezeichnet wird.  Dann müssen wir nicht das gesamte Quadrat neu zeichnen.  Das ist logisch.  Wenn beispielsweise unser Cursor blinkt, wird nur er neu gezeichnet.  Dies spart viel CPU. <br><br><img src="https://habrastorage.org/webt/d1/if/je/d1ifjeax-iui5g2798qeywqbkxe.jpeg"><br><br>  Die nächste Optimierung haben sie gemacht.  Wo kann es Ineffizienz geben?  Sind die Fliesen verschoben?  Gute Idee, aber ich tendiere zu einer anderen.  Hier ist nur ein weißes Rechteck.  Dies ist eine weiße Kachel, auf die kein einziges Pixel gezeichnet ist.  Aber es ist eine Textur.  Es nimmt 256 mal 256 mal vier Bytes Speicher ein. <br><br><img src="https://habrastorage.org/webt/_u/rd/jz/_urdjzgxmievvqxncbbqnmk-iqg.jpeg"><br><br>  Eine weitere Optimierung, die in Chrome erfunden wurde: Nehmen wir diese Kacheln einfarbig und codieren sie nicht mit einer Reihe von Pixeln, sondern mit den Koordinatoren, der Größe und der Farbe.  Das Internet ist jetzt voll von Seiten mit vielen monochromen Bereichen für große Monitore.  Und solche Seiten sind entsprechend optimiert, wir sparen viel Speicher. <br><br>  Wir bei Yandex gingen noch einen Schritt weiter und beschlossen, ein spezifischeres Experiment durchzuführen.  Wo können Sie Ihrer Meinung nach mehr sparen? <br><br>  Wir haben eine Fliese.  Der Inhalt befindet sich in einem winzigen Bereich - einem Streifen, dem Wort Yandex.  Warum müssen wir als Ganzes zeichnen, wenn der Inhalt sehr klein und alles andere monochrom ist? <br><br><img src="https://habrastorage.org/webt/rc/lp/3l/rclp3lba5zrbbyy4i97k6fghoga.jpeg"><br><br>  Was haben wir getan  Das habe ich speziell getan.  Wir haben jede Kachel in fünf Kacheln unterteilt.  Wenn sich der Inhalt nur in der Mitte befindet, wählen wir die Textur für diesen Inhalt nur für das aus, was in der Mitte ausgeführt wird.  Hier ist der rote Bereich.  Alles andere codieren wir auf die gleiche Weise - Größe, Koordinaten und Farbe. <br><br><img src="https://habrastorage.org/webt/s2/5s/ue/s25sue2gc7yyi1wqmmuw8enuoi8.jpeg"><br><br>  Das heißt, speziell auf dieser Seite sind alle diese Bereiche jetzt nicht mehr texturiert.  Es werden keine Bytes im Speicher verwendet, sondern lediglich Befehle darüber, was wir hier zeichnen müssen, mit einer Farbe füllen.  Dies ergab eine durchschnittliche Einsparung von ca. 40% beim GPU-Speicher pro Benutzer. <br><br><img src="https://habrastorage.org/webt/-i/xu/-l/-ixu-l42br_ztso413cld8ph4pw.jpeg"><br><br>  Auf komplexeren Seiten sieht es so aus.  Da komplexere Seiten mehr Ebenen verwenden und jede Ebene eine separate Kachelung ist, können Sie auf jeder Ebene ein wenig sparen. <br><br>  Wenn Sie dieses Häkchen jetzt aktivieren, sehen Sie nicht ein solches Rechteckraster, sondern dieses. <br><br><img src="https://habrastorage.org/webt/m3/a4/yc/m3a4yc5_thakslwlcxkhhvx4a80.jpeg"><br><br>  Was ist das, warum sind die Fliesen hier so breit und warum gibt es nur wenige davon?  Die Bedeutung hier ist wie folgt.  In Chrome dachten sie: Warum machen wir nicht nicht nur Hardware-Compositing, sondern auch Hardware-Rendering?  Was machen sie?  Wir haben eine Liste von Befehlen, was zu tun ist: Zeichnen eines Rechtecks, Füllen mit Farbe usw. All dies geht an die GPU, und die GPU zeichnet eine solche Textur.  Das Neuzeichnen ist sehr schnell, sodass Kacheln auch groß gemacht werden können.  Hier ist ein kleines Schakalvideo, aber es zeigt sehr gut den Vorteil, der auf den Telefonen aufgrund der Tatsache, dass das Rendern hardwarebeschleunigt wurde, aufgetreten ist.  Ich denke, der Unterschied hier ist sehr, sehr auffällig. <br><br>  Die Kommunikation zwischen Browser-Entwicklern und Front-End-Anbietern scheint mir sehr nützlich zu sein.  Es kommt nicht sehr oft vor, bietet aber viele Vorteile.  Wenn unsere Kollegen aus anderen Abteilungen zu uns kommen und fragen, wie das Layout schneller und besser gestaltet werden kann, versuchen wir ihnen zu helfen und über Orte zu sprechen, an denen etwas nicht optimal ist und Sie schneller werden können. <br><br>  Und ich werde nicht müde, meinen Rat zu wiederholen.  (Ich werde hier nicht zitieren, es gab einen separaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">großen Bericht</a> zu diesem Thema. - Kommentar des Autors.) <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier habe</a> ich eine Reihe nützlicher Links zusammengestellt, über das Rendern und nicht nur, sondern auch ein wenig über Yandex.Browser.  Vielen Dank. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468165/">https://habr.com/ru/post/de468165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468151/index.html">Schwachstellen in GeekBrains: Warum Geld für Kurse bezahlen, wenn Sie diese nur herunterladen können?</a></li>
<li><a href="../de468155/index.html">Neue Produkttrends</a></li>
<li><a href="../de468157/index.html">Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP</a></li>
<li><a href="../de468161/index.html">Die gierige Leuchte: Warum Sonnenenergie die Welt nicht eroberte und wie das „russische Mineral“ sie retten kann</a></li>
<li><a href="../de468163/index.html">Oracle VM Server für SPARC for Dummies (Anleitung)</a></li>
<li><a href="../de468167/index.html">Lebe und lerne. Teil 4. Während der Arbeit lernen?</a></li>
<li><a href="../de468169/index.html">JQuery Geschichte und Erbe</a></li>
<li><a href="../de468175/index.html">Lesenswerte Frontend-Entwicklungsblogs</a></li>
<li><a href="../de468177/index.html">Git innen und außen</a></li>
<li><a href="../de468179/index.html">Analyse: Wie die Infrastruktur des russischen Wertpapiermarktes funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>