<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüé§ üôÜüèª üôå Wie der Browser zeichnet. Yandex-Bericht üë®‚Äçüë¶‚Äçüë¶ üêù üç¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bis vor kurzem habe ich im Yandex.Browser-Team gearbeitet und im Anschluss an diese Erfahrung eine Pr√§sentation auf der YaTalks-Konferenz gehalten. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie der Browser zeichnet. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/468165/">  Bis vor kurzem habe ich im Yandex.Browser-Team gearbeitet und im Anschluss an diese Erfahrung eine Pr√§sentation auf der YaTalks-Konferenz gehalten.  In dem Bericht ging es darum, was der Browser unter der Haube hat und wie Ihre Seiten auf dem Bildschirm in Pixel umgewandelt werden.  Minimales Frontend, nur die Innenseiten des Browsers, nur Hardcore. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/1a/v_/yd/1av_ydaayfggjaxus6mfz_dtazu.jpeg"></a> <br><br>  - Hallo allerseits, mein Name ist Kostya.  √úberraschenderweise arbeite ich jetzt im Team des virtuellen Netzwerks Yandex.Cloud.  Zuvor hatte ich mehr als f√ºnf Jahre im Browser-Team gearbeitet, daher werde ich heute √ºber Dinge sprechen, die uns und Ihnen gemeinsam sind. <br><br><a name="habracut"></a>  Wie Sie sich vorstellen k√∂nnen, verstehe ich das Frontend nicht sehr gut.  Wenn Sie mit mir √ºber React oder √§hnliches sprechen, werde ich Sie wahrscheinlich nicht verstehen.  Aber ich habe viele Dinge im Browser getan: Videodecodierung, Gesch√§ftslogik.  Einschlie√ülich ich habe viel Zeit damit verbracht, verschiedene Dinge beim Rendern des Browsers zu tun.  Heute werden wir beispielsweise ein solches Bildungsprogramm √ºber das interne Ger√§t des Browsers haben.  Ich werde versuchen, die interessantesten Dinge durchzugehen, die wir in Yandex.Browser oder Google in Chromium gemacht haben. <br><br><img src="https://habrastorage.org/webt/cu/uk/m0/cuukm04v2xohnl0t4x2u86qf6je.jpeg"><br><br>  Wenn wir √ºber das Rendern im Browser sprechen, ist dies eine sehr komplizierte Sache, die aus einer gro√üen Anzahl von Komponenten besteht.  Zun√§chst m√ºssen Sie Ressourcen herunterladen, um sie anzuzeigen.  Dann m√ºssen Sie sie analysieren, einen DOM-Baum, Stile, Layouts usw. erstellen. Die ersten drei Punkte sind Ihnen h√∂chstwahrscheinlich bekannt.  Mein Bericht wird sich mehr den anderen drei Teilen widmen: Malen, Rastern und Zusammensetzen - was passiert unter der Haube, wenn Sie das Layout bereits geschrieben haben.  Nur in Worten kann es so aussehen, als ob es sich um dasselbe handelt - tats√§chlich handelt es sich um v√∂llig unterschiedliche Komponenten. <br><br><img src="https://habrastorage.org/webt/pv/zd/ww/pvzdwwy3xvf6s3os0z3edvey3hw.jpeg"><br>  Ôøº <br>  Beginnen wir mit Malen und Zusammensetzen.  Worum geht es hier?  Gehen wir zur√ºck vor vielen, vielen Jahren, als das Web nicht so komplex war wie heute, als es nicht alle Arten von 3D-, CSS-Animationen und anderen Dingen gab.  Wie hat dann der Browser gezeichnet?  Stellen Sie sich vor, Sie haben Ihre Seite, einige wundervolle Elemente, Bilder usw. Der Browser hat all dies auf eine kr√§ftige Textur in einem gro√üen Speicherblock gemalt.  Er wusste, wie man jedes Element zeichnet, und wenn wir √Ñnderungen hatten, werden diese gelb hervorgehoben, so etwas wie das Folgende geschah. <br><br>  Der Browser hat sie in Bereichen zusammengefasst, die hier blau angezeigt werden.  In diesem Bereich hat sich etwas ge√§ndert. Zeichnen wir ihn neu.  Alles in diesem Bereich wurde einfach neu gezeichnet und in die Textur kopiert. <br><br>  Es hat f√ºr sich selbst funktioniert.  Dann kamen kluge Leute auf 3D-CSS-Animationen, andere Dinge.  Wir k√∂nnten viele Renderings an verschiedenen Orten haben.  Wenn wir einen Spinner drehen, ist es nicht sehr effektiv, den gesamten Kreis der Elemente, die sich darunter befinden, neu zu zeichnen. <br><br><img src="https://habrastorage.org/webt/lp/9p/sh/lp9pshbw-k3xjwunjubol_xvo5k.jpeg"><br><br>  Dann beschlossen andere kluge Leute, alles ein wenig zu wiederholen.  Wir haben eine Art DOM-Baum, wir haben ihn im Speicher erstellt.  Dies sind Plus-Objekte. Sie werden mit dem von Ihnen geschriebenen Layout verglichen. <br><br><img src="https://habrastorage.org/webt/mq/m4/m6/mqm4m6-oocbnsypvc2uu_t1wame.jpeg"><br><br>  Und dann beginnt die Magie zu geschehen.  Der Browser konvertiert den gesamten DOM-Baum in einen Renderobjektbaum.  Dieses Ding wei√ü, wie man jedes spezifische DOM-Element zeichnet.  Das hei√üt, sie wei√ü, was zu tun ist, damit anstelle Ihres Baums oder P-Elements etwas auf dem Bildschirm angezeigt wird. <br><br><img src="https://habrastorage.org/webt/qh/lc/li/qhlcli9pyhe2-k1ikbuhytv5itu.jpeg"><br><br>  Der n√§chste Baum ist der Baum der Schichten.  Was ist das?  Jedes unserer Elemente kann einer beliebigen Ebene zugeordnet werden, und eine Renderebene kann mehrere Objekte gleichzeitig enthalten.  Warum wird das gemacht?  Dies wird hier sehr gut gezeigt.  Wir generieren eine Reihe von Ebenen, von denen jede bestimmte Elemente enth√§lt.  Angenommen, auf einer der Ebenen √§ndert sich etwas - eine Animation findet statt, ein Stempelelement fliegt.  Dann zeichnen wir nur eine Ebene neu und der Rest, zum Beispiel der Hintergrund, bleibt unver√§ndert.  Wir kleben sie dann einfach in Verbundwerkstoffe und erhalten am Ausgang das endg√ºltige Bild - den aktuellen Frame der Animation. <br><br><img src="https://habrastorage.org/webt/lz/y5/4m/lzy54mvjeae-hnulzhsafu68m5g.jpeg"><br><br>  Es gibt eine Reihe fester Gr√ºnde f√ºr das Erstellen neuer Ebenen.  Beispielsweise wird eine Ebene erstellt, um 3D-CSS-Animationen, eine Leinwand und ein Videoelement darauf zu rendern - im Allgemeinen etwas, das sich auf schwere Animationen bezieht und zum separaten Zeichnen von allen anderen Inhalten geeignet ist. <br><br><img src="https://habrastorage.org/webt/0z/m3/tu/0zm3tuitlzjxxqdiyldzh26xd60.jpeg"><br><br>  Dieser Ansatz weist jedoch mehrere Probleme auf.  Jetzt m√ºssen Sie den Kraftstoff einschalten.  √úberlegen Sie, was hier abgebildet wird?  Es gibt nur zwei Elemente. <br><br><img src="https://habrastorage.org/webt/gl/c6/op/glc6opdar5a1kpd4oblgxin6cgg.jpeg"><br><br>  Hier.  Obwohl es scheint, dass die Elemente einzeln angeordnet sind.  Warum fliegt Leinwand hoch?  In unserem Land sind sie nacheinander angeordnet, ich habe keine Reihenfolge festgelegt. <br><br><img src="https://habrastorage.org/webt/gh/fk/8h/ghfk8hcwyrsk1se3g69uxobhs0y.jpeg"><br><br>  Lassen Sie uns komplizieren.  Hier haben wir noch einen Div, so. <br><br><img src="https://habrastorage.org/webt/sp/fy/kw/spfykw2_mvn88iagm46zaonkteg.jpeg"><br><br>  Im Allgemeinen das erwartete Verhalten.  Wir haben ein Div √ºber dem Div, aber Leinwand ist aus irgendeinem Grund oben.  Die Magie!  Ok, lassen Sie uns dieses Beispiel noch einmal komplizieren. <br><br><img src="https://habrastorage.org/webt/k9/0r/jq/k90rjqxakei6oiidlklf5s2i1ia.jpeg"><br><br>  Genau eine Zeile hat sich ge√§ndert, ich habe transform hinzugef√ºgt. <br><br><img src="https://habrastorage.org/webt/os/dm/bp/osdmbp6jkrfzdmrgabry61pjngi.jpeg"><br><br>  Und jetzt haben wir alles richtig positioniert - zumindest in Bezug auf Leinwand und Div.  Aber dieses Div befindet sich immer noch unten, obwohl es das n√§chste Element in unserem Layout war. <br><br>  Dies ist der sogenannte grundlegende Compositing-Fehler.  Wenn Sie nach dem Chromium-Tracker suchen, werden Sie eine Reihe von Fehlern sehen, die mit einem alten verkn√ºpft sind.  Er hei√üt so. <br><br><img src="https://habrastorage.org/webt/kp/go/nx/kpgonxbu5yxy_7immr2urgfurva.jpeg"><br><br>  Also, was ist passiert?  Wie gesagt, einige Elemente werden auf der Renderebene gerendert, andere nicht.  Einige werden zusammen mit anderen gezeichnet.  Hier geschah Folgendes: div-Elemente bleiben in derselben Ebene wie der Hintergrund.  Canvas st√ºrzt auf einer separaten Ebene ab.  Und die Z-Reihenfolge wird nur zwischen Schichten ausgef√ºhrt.  Aufgrund der Tatsache, dass wir einen Hintergrund und ein Div in einer Ebene und eine Leinwand in einer anderen haben, erhalten wir einen Fehler: Leinwand √ºberlappt die Div. <br><br>  Sobald wir dieses div-Element auf eine separate Ebene verschieben und es beginnt, die z-Ordnung normal zu verwenden, beginnt es auch zu verstehen, wer hinter wem steht.  Und hier wird alles "normal" gemacht. <br><br><img src="https://habrastorage.org/webt/nl/ju/4j/nlju4jxtrt-1x7fjliv5hy8io3i.jpeg"><br><br>  Und eine der letzten Initiativen, die sich seit mehreren Jahren entwickelt hat, ist die sogenannte Schlankheitsfarbe, die das Problem beheben sollte.  Seine Bedeutung ist, dass wir das Malen vom Zeichnen in Ebenen trennen m√ºssen, dh verstehen m√ºssen, was getan werden muss, um diese Elemente zu zeichnen, und wie wir sie dann miteinander zusammensetzen k√∂nnen.  Wenn wir ein so einfaches Layout haben, wird es zu so etwas.  Es gibt eine einfache Liste von Befehlen, die Sie ausf√ºhren m√ºssen, um Seiteninhalte abzurufen.  Und wenn wir zu diesem Beispiel zur√ºckkehren, wird es ungef√§hr so ‚Äã‚Äãaussehen. <br><br><img src="https://habrastorage.org/webt/yd/fw/s7/ydfws7bge3oaylgwnr7mlojtivy.jpeg"><br>  Ôøº <br>  Das hei√üt, wir sagten: Hier ist Paint f√ºr Sie, hier ist der Inhalt f√ºr Sie - bitte geben Sie mir etwas.  Es enth√§lt eine Liste zum Rendern, die an Compositor gesendet wird, und Compositor versteht es, den gesamten Inhalt in Ebenen zu unterteilen, sodass sie normalerweise relativ zueinander angeordnet sind. <br><br>  Und wenn Sie es nicht bemerkt haben, ist dies ein Screenshot von Chrome.  Ich habe es vor ungef√§hr zwei Wochen geschafft, das hei√üt, der Fehler lebt noch.  Das Projekt ist noch nicht abgeschlossen, es befindet sich derzeit in der Entwicklung. <br><br><img src="https://habrastorage.org/webt/lk/dv/j0/lkdvj0dnnveu2o_jlmdtykxcwus.jpeg"><br>  Ôøº <br>  Das hei√üt, der Compositor aus dieser Liste und einige geheime Kenntnisse, die Plink weitergibt, k√∂nnen verstehen, wie man alles richtig in Schichten legt. <br><br><img src="https://habrastorage.org/webt/li/lk/qu/lilkquciiebcpc3hjnvv_jjxuvy.jpeg"><br>  Ôøº <br>  Neben der Tatsache, dass dieser Ansatz diesen Fehler im Grunde behebt, erhalten wir auch ziemlich billige √Ñnderungen beim Rendern.  Angenommen, wir hatten eine Liste von Zeichenbefehlen und √Ñnderungen - sagen wir, Element B verl√§sst, Element E wird hinzugef√ºgt.  Dann k√∂nnen wir die beiden Listen einfach zusammenhalten, ohne uns um B√§ume usw. k√ºmmern zu m√ºssen. Bei der Ausgabe erhalten wir eine neue Liste von Elementen zum Rendern und m√∂glicherweise eine neue Liste von Ebenen, die in Zukunft kompiliert werden. <br><br>  Dies war eine kurze Geschichte dar√ºber, was passiert, wenn der Browser Paint implementiert und was passiert, nachdem er versucht hat, Ebenen zu erstellen. <br>  Ôøº <br>  Kommen wir zu einem anderen Thema: Rasterisierung.  Nur in Rasterization in Yandex.Browser wurden viele Dinge getan, und das habe ich auch getan.  Was bedeutet Rasterung?  Am Ende der vorherigen Phase, als wir Paint ausgef√ºhrt haben, gibt es eine Liste von Befehlen, die wir implementieren m√ºssen, um ein Bild zu erhalten.  Rasterisierung ist die Umwandlung einer Liste von Befehlen in echte Pixel. <br><br><img src="https://habrastorage.org/webt/ap/ya/oo/apyaooljngenpae6hwzfksmptqc.jpeg"><br><br><img src="https://habrastorage.org/webt/nu/pr/pr/nuprprco-z2msvg-jcj2hnkxvic.jpeg"><br><br>  Wenn Sie im Browser-Inspektor die Registerkarte Weitere Tools ‚Üí Rendern √∂ffnen, gibt es ein H√§kchen f√ºr Ebenenr√§nder.  Und Sie sehen genau so ein Gitter.  Was ist hier los?  Wenn der Browser die Seite zeichnet, macht er jetzt nicht das Ganze.  Der Browser nimmt und unterteilt jede Ebene in eine bestimmte Anzahl solcher kleinen Quadrate.  Historisch gesehen sind sie 256 mal 256 Pixel gro√ü.  Das hei√üt, jede Ebene ist in so viele separate Texturen unterteilt.  Der Inhalt der aktuellen Kachel wird dann auf jede Textur gezeichnet, und dann werden sie alle zu einer gro√üen Textur zusammengeklebt. <br><br><img src="https://habrastorage.org/webt/1i/fr/-m/1ifr-m5llhmdoal3f-ecr9fv3mw.jpeg"><br><br>  Es hilft sehr.  Zun√§chst k√∂nnen wir nur die Kacheln neu zeichnen, die sich ge√§ndert haben.  Es erm√∂glicht uns aber auch, das Rendern zu priorisieren.  Das hei√üt, zun√§chst sollten die Kacheln gezeichnet werden, die der Benutzer sieht, das sogenannte Ansichtsfenster.  Dann m√ºssen wir bald Grenze ziehen, das ist, was um das Ansichtsfenster ist.  Als n√§chstes folgt die Richtung der Schriftrolle: Wenn sie nach unten gescrollt wird, zeichnen wir so viel wie m√∂glich nach unten.  Wenn hoch - ziehe so viel wie m√∂glich hoch.  Wenn wir noch eine Speicherquote haben, werden wir etwas anderes zeichnen, aber nicht die Tatsache, dass es an diesem Punkt bleibt. <br><br><img src="https://habrastorage.org/webt/gb/aa/b1/gbaab12sjafchhn1okxtdml2yju.jpeg"><br><br>  Wir bekommen also ein ziemlich billiges Inhaltsupdate auf der Seite.  Angenommen, wir haben den aktuellen Frame verwendet und der Benutzer hat etwas deaktiviert - beispielsweise hervorgehobenen Text.  Dann zeichnen wir nur die Kacheln, die sich ge√§ndert haben. <br><br><img src="https://habrastorage.org/webt/qc/q5/it/qcq5itbfqab7ylojm1nabcwopra.jpeg"><br><br>  Das hei√üt, gr√ºne Kacheln sind diejenigen, die vom vorherigen Rendering √ºbrig geblieben sind, rote, die wir neu gezeichnet haben.  Dieser Ansatz hat jedoch andere Vorteile. <br><br><img src="https://habrastorage.org/webt/5f/xy/ip/5fxyipvzx6gfrkoy4yxl6foplgi.jpeg"><br><br>  Wir k√∂nnen - und Chrome hat es getan - die sogenannte Optimierung kleiner Neuzeichnungen durchf√ºhren.  Angenommen, Sie haben eine Art Pochen, Cursor oder √§hnliches, das in einem kleinen Rechteck ein wenig neu gezeichnet wird.  Dann m√ºssen wir nicht das gesamte Quadrat neu zeichnen.  Das ist logisch.  Wenn beispielsweise unser Cursor blinkt, wird nur er neu gezeichnet.  Dies spart viel CPU. <br><br><img src="https://habrastorage.org/webt/d1/if/je/d1ifjeax-iui5g2798qeywqbkxe.jpeg"><br><br>  Die n√§chste Optimierung haben sie gemacht.  Wo kann es Ineffizienz geben?  Sind die Fliesen verschoben?  Gute Idee, aber ich tendiere zu einer anderen.  Hier ist nur ein wei√ües Rechteck.  Dies ist eine wei√üe Kachel, auf die kein einziges Pixel gezeichnet ist.  Aber es ist eine Textur.  Es nimmt 256 mal 256 mal vier Bytes Speicher ein. <br><br><img src="https://habrastorage.org/webt/_u/rd/jz/_urdjzgxmievvqxncbbqnmk-iqg.jpeg"><br><br>  Eine weitere Optimierung, die in Chrome erfunden wurde: Nehmen wir diese Kacheln einfarbig und codieren sie nicht mit einer Reihe von Pixeln, sondern mit den Koordinatoren, der Gr√∂√üe und der Farbe.  Das Internet ist jetzt voll von Seiten mit vielen monochromen Bereichen f√ºr gro√üe Monitore.  Und solche Seiten sind entsprechend optimiert, wir sparen viel Speicher. <br><br>  Wir bei Yandex gingen noch einen Schritt weiter und beschlossen, ein spezifischeres Experiment durchzuf√ºhren.  Wo k√∂nnen Sie Ihrer Meinung nach mehr sparen? <br><br>  Wir haben eine Fliese.  Der Inhalt befindet sich in einem winzigen Bereich - einem Streifen, dem Wort Yandex.  Warum m√ºssen wir als Ganzes zeichnen, wenn der Inhalt sehr klein und alles andere monochrom ist? <br><br><img src="https://habrastorage.org/webt/rc/lp/3l/rclp3lba5zrbbyy4i97k6fghoga.jpeg"><br><br>  Was haben wir getan  Das habe ich speziell getan.  Wir haben jede Kachel in f√ºnf Kacheln unterteilt.  Wenn sich der Inhalt nur in der Mitte befindet, w√§hlen wir die Textur f√ºr diesen Inhalt nur f√ºr das aus, was in der Mitte ausgef√ºhrt wird.  Hier ist der rote Bereich.  Alles andere codieren wir auf die gleiche Weise - Gr√∂√üe, Koordinaten und Farbe. <br><br><img src="https://habrastorage.org/webt/s2/5s/ue/s25sue2gc7yyi1wqmmuw8enuoi8.jpeg"><br><br>  Das hei√üt, speziell auf dieser Seite sind alle diese Bereiche jetzt nicht mehr texturiert.  Es werden keine Bytes im Speicher verwendet, sondern lediglich Befehle dar√ºber, was wir hier zeichnen m√ºssen, mit einer Farbe f√ºllen.  Dies ergab eine durchschnittliche Einsparung von ca. 40% beim GPU-Speicher pro Benutzer. <br><br><img src="https://habrastorage.org/webt/-i/xu/-l/-ixu-l42br_ztso413cld8ph4pw.jpeg"><br><br>  Auf komplexeren Seiten sieht es so aus.  Da komplexere Seiten mehr Ebenen verwenden und jede Ebene eine separate Kachelung ist, k√∂nnen Sie auf jeder Ebene ein wenig sparen. <br><br>  Wenn Sie dieses H√§kchen jetzt aktivieren, sehen Sie nicht ein solches Rechteckraster, sondern dieses. <br><br><img src="https://habrastorage.org/webt/m3/a4/yc/m3a4yc5_thakslwlcxkhhvx4a80.jpeg"><br><br>  Was ist das, warum sind die Fliesen hier so breit und warum gibt es nur wenige davon?  Die Bedeutung hier ist wie folgt.  In Chrome dachten sie: Warum machen wir nicht nicht nur Hardware-Compositing, sondern auch Hardware-Rendering?  Was machen sie?  Wir haben eine Liste von Befehlen, was zu tun ist: Zeichnen eines Rechtecks, F√ºllen mit Farbe usw. All dies geht an die GPU, und die GPU zeichnet eine solche Textur.  Das Neuzeichnen ist sehr schnell, sodass Kacheln auch gro√ü gemacht werden k√∂nnen.  Hier ist ein kleines Schakalvideo, aber es zeigt sehr gut den Vorteil, der auf den Telefonen aufgrund der Tatsache, dass das Rendern hardwarebeschleunigt wurde, aufgetreten ist.  Ich denke, der Unterschied hier ist sehr, sehr auff√§llig. <br><br>  Die Kommunikation zwischen Browser-Entwicklern und Front-End-Anbietern scheint mir sehr n√ºtzlich zu sein.  Es kommt nicht sehr oft vor, bietet aber viele Vorteile.  Wenn unsere Kollegen aus anderen Abteilungen zu uns kommen und fragen, wie das Layout schneller und besser gestaltet werden kann, versuchen wir ihnen zu helfen und √ºber Orte zu sprechen, an denen etwas nicht optimal ist und Sie schneller werden k√∂nnen. <br><br>  Und ich werde nicht m√ºde, meinen Rat zu wiederholen.  (Ich werde hier nicht zitieren, es gab einen separaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üen Bericht</a> zu diesem Thema. - Kommentar des Autors.) <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier habe</a> ich eine Reihe n√ºtzlicher Links zusammengestellt, √ºber das Rendern und nicht nur, sondern auch ein wenig √ºber Yandex.Browser.  Vielen Dank. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468165/">https://habr.com/ru/post/de468165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468151/index.html">Schwachstellen in GeekBrains: Warum Geld f√ºr Kurse bezahlen, wenn Sie diese nur herunterladen k√∂nnen?</a></li>
<li><a href="../de468155/index.html">Neue Produkttrends</a></li>
<li><a href="../de468157/index.html">Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP</a></li>
<li><a href="../de468161/index.html">Die gierige Leuchte: Warum Sonnenenergie die Welt nicht eroberte und wie das ‚Äûrussische Mineral‚Äú sie retten kann</a></li>
<li><a href="../de468163/index.html">Oracle VM Server f√ºr SPARC for Dummies (Anleitung)</a></li>
<li><a href="../de468167/index.html">Lebe und lerne. Teil 4. W√§hrend der Arbeit lernen?</a></li>
<li><a href="../de468169/index.html">JQuery Geschichte und Erbe</a></li>
<li><a href="../de468175/index.html">Lesenswerte Frontend-Entwicklungsblogs</a></li>
<li><a href="../de468177/index.html">Git innen und au√üen</a></li>
<li><a href="../de468179/index.html">Analyse: Wie die Infrastruktur des russischen Wertpapiermarktes funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>