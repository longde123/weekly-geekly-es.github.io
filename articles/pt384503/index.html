<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚕️ 👐🏿 🍨 Máquina de cubo de Rubik baseada em FAC 🛀🏻 😰 🐓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há pouco tempo, juntamente com Wilbert Swinkels, terminamos o trabalho em uma máquina que coleta o Cubo de Rubik. Eles escreveram sobre nós no blog of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Máquina de cubo de Rubik baseada em FAC</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384503/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Há pouco tempo, juntamente com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wilbert Swinkels,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terminamos o trabalho em uma máquina que coleta o Cubo de Rubik. </font><font style="vertical-align: inherit;">Eles </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escreveram</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre nós </font><font style="vertical-align: inherit;">no blog oficial do Raspberry Pi e recebemos muitas críticas elogiosas. </font><font style="vertical-align: inherit;">No entanto, no segmento russo da rede, o projeto de alguma forma passou despercebido. </font><font style="vertical-align: inherit;">Então, decidi corrigir essa omissão postando aqui uma versão traduzida e aumentada da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">postagem original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://www.youtube.com/embed/vpAKfSYueMI%3Ffeature%3Doembed&amp;usg=ALkJrhjtKkgOwZGQ-pQqjnx8zGDbXyWkwQ" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob o corte, falaremos (principalmente) sobre a parte do software desta máquina, a parte mecânica pode ser encontrada na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">página oficial do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projeto (sim, sabemos que é uma pequena "velha escola")</font></font><br>
<a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TL; DR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para os impacientes, alguns links:</font></font><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Página oficial do projeto</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementações do algoritmo bifásico de Kotsemba (Python e C)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras obras de Wilbert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site da Wilbert FAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site oficial do sistema FAC</font></font></a></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdução</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo começou com o fato de que, em maio deste ano, conheci acidentalmente Wilbert Swinkels. Fiquei simplesmente chocado ao ver suas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">criações</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cada um desses mecanismos, de pequenos a grandes, pode ser chamado com segurança de obra de arte. E quanto mais você olha para o dispositivo deles, mais impressionado com a beleza deles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É claro que, quando Wilbert me convidou para ajudá-lo com a máquina de montagem de cubos de Rubik, não hesitei nem um segundo, principalmente porque já havia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descoberto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma paixão por cubos coloridos. Naquela época, ele já trabalhava na máquina há mais de 4 (!) Anos, mas a parte do software ainda estava para ser escrita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu não tinha experiência com programação para Raspberry Pi e Arduino, mas no geral a tarefa me pareceu bastante simples. </font><font style="vertical-align: inherit;">Claro, eu estava errado :)</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A própria máquina é construída usando um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema FAC modular</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">É como um designer soviético, mas criado para prototipar mecanismos sérios e complexos. </font><font style="vertical-align: inherit;">Na segunda metade do século passado, foi usado ativamente nos laboratórios da Philips e outras empresas e universidades. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando conheci Wilbert, ele já havia tentado duas vezes "reviver" o carro. </font><font style="vertical-align: inherit;">Nas duas vezes, os estudantes da Universidade de Amsterdã aceitaram o caso e, infelizmente, ambas perderam o interesse no projeto após várias tentativas frustradas. </font><font style="vertical-align: inherit;">Um deles chegou a defender um diploma de bacharel nesse assunto, apesar de a máquina não ter conseguido coletar o cubo (levante sua mão para aqueles que se reconhecem aqui).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microcontrolador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, decidimos usar o Raspberry Pi em vez do Arduino. </font><font style="vertical-align: inherit;">Isso se deve principalmente ao fato de que algoritmos "inteligentes" para resolver o Cubo de Rubik exigem uma quantidade significativa de memória e energia do processador. </font><font style="vertical-align: inherit;">Nas tentativas anteriores, um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> primitivo de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">três camadas foi usado</font></a><font style="vertical-align: inherit;"> , mas desta vez decidimos usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o algoritmo de Kotsemba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Além disso, eu realmente não queria escrever tudo em C (embora em parte fosse necessário). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/53b/142/5d4/53b1425d42fca6feb8f98819c3f4ff39.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na versão padrão do Raspberry Pi, como não tínhamos pinos suficientes para conectar todos os motores disponíveis, solicitamos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kit de Desenvolvimento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A propósito, eu recomendo fortemente: não apenas mais pinos, mas eles são, na minha opinião, mais lógicos à parte. </font><font style="vertical-align: inherit;">Além disso, esta placa possui dois conectores para a câmera em vez de um.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira versão do scanner</font></font></h3><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/465/d0e/05d/465d0e05d87cd5c11a732f3d448ac6b4.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ler a configuração inicial do cubo, era necessário um dispositivo de digitalização. A ideia é muito simples: por sua vez, iluminamos a superfície do cubo com três LEDs: vermelho, verde e azul. Cada vez que medimos a luz refletida usando um resistor fotossensível. Teoricamente, devemos obter valores RGB que possam ser usados ​​para reconhecer a cor do quadrado. Dos programadores anteriores, ainda temos código de prova de conceito para o Arduino, que, ao que parece, funcionou sob certas condições.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro problema que encontramos foi uma incompatibilidade de tensão. Como você sabe, a unidade lógica nos pinos do Arduino é de 5V, enquanto o Raspberry Pi é de 3,3V. Felizmente, os controladores de motor de passo que usamos continuaram a funcionar, apesar de alterar a amplitude dos pulsos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acabou sendo muito mais crítico que o Raspberry Pi não possua entradas analógicas. Por causa disso, o Raspberry não pode simplesmente captar e ler a tensão no fotorresistor. Provavelmente isso é óbvio para aqueles que pelo menos uma vez se depararam com isso, mas a princípio nem pensei nisso. Pesquisando na rede por uma solução, deparamos com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em poucas palavras, adicionamos um capacitor ao circuito e medimos o tempo durante o qual ele cobrará de zero a uma unidade lógica (podemos detectá-lo usando um pino digital). </font><font style="vertical-align: inherit;">O tempo de carregamento será proporcional à resistência do fotorresistor, para que possamos avaliar a quantidade de luz. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/40a/8d9/d2b/40a8d9d2b30365e9e4fd4c3cf3615798.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem não é apenas extremamente confiável (dedicar tempo em um script Python Python no Linux com vários processos em segundo plano é uma coisa ingrata), mas também é impossível demorar muito. </font><font style="vertical-align: inherit;">Para suavizar os desvios aleatórios nas leituras, tivemos que ler várias vezes, livrar-se dos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valores extremos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font><font style="vertical-align: inherit;">calcular </font><font style="vertical-align: inherit;">a média dos valores restantes. </font><font style="vertical-align: inherit;">No entanto, ainda conseguimos fazer com que esse scanner funcionasse:</font></font><br>
<br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://www.youtube.com/embed/z4iJ0hNQulo%3Ffeature%3Doembed&amp;usg=ALkJrhjXRjBzspmEUH_1BLzXncbpBaurGQ" frameborder="0" allowfullscreen=""></iframe><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda versão (final) do scanner</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O scanner de capacitor funcionou muito bem, mas foi muito lento. Demorou cerca de dois minutos para varrer todo o cubo de Rubik e, quando a varredura foi concluída, o espectador havia perdido todo o interesse. Portanto, decidimos retornar ao Arduino e compramos um pequeno Arduino Mini especificamente para controlar o scanner. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/21a/9e5/775/21a9e5775f5e15affb6792ae5f67b984.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fazer amigos do Arduino com o Raspberry Pi acabou incrivelmente simples: dois fios, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um conversor de voltagem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entre eles e pronto - temos uma interface serial. E se você estragar um protocolo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Min</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples </font><font style="vertical-align: inherit;">, programar esse negócio é um prazer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transferi toda a lógica de controle do scanner para o Arduino. </font><font style="vertical-align: inherit;">A velocidade da digitalização aumentou significativamente. </font><font style="vertical-align: inherit;">Graças às entradas analógicas, podemos ler a tensão diretamente dos fotorresistores, e esses valores são muito precisos. </font><font style="vertical-align: inherit;">Além disso, como o Arduino é montado diretamente no scanner, precisamos de muito menos fios do scanner para o Raspberry Pi!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo de construção</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Montar o cubo de Rubik do ponto de vista matemático é uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarefa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bastante </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">trabalhosa</font></a><font style="vertical-align: inherit;"> . Obviamente, estamos falando em encontrar a solução ideal, e não "algumas". Fiquei surpreso quando descobri que o número de Deus (o limite inferior exato para o número de movimentos necessários para resolver um cubo arbitrário) foi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encontrado apenas em 2010</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste projeto, queríamos reduzir o tempo total necessário para calcular a solução e montar, portanto, nem um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">três camadas se</font></a><font style="vertical-align: inherit;"> aproximou de nós </font><font style="vertical-align: inherit;">(ele funciona rapidamente, mas oferece soluções com cem movimentos), nem um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo ideal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (as soluções são curtas, mas o processo de renderização no Raspberry Pi levaria uma eternidade). Como resultado, decidimos pelo magnífico </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo "bifásico"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matemático alemão Herbert Kociemba. Ele é capaz de emitir decisões abaixo do ideal (uma média de 20 movimentos), mantendo-o dentro de um tempo razoável. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No site do autor, você pode encontrar a implementação do algoritmo em Java. A primeira coisa que fiz foi traduzir esse código em Python. Não foi nada difícil, pois a maior parte do programa é operações matemáticas e enumeração de opções. No entanto, não levei em conta que o algoritmo </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requer </font><i><b><font style="vertical-align: inherit;">muitos</font></b></i><font style="vertical-align: inherit;"> recursos. Encontrar uma solução no primeiro lançamento levou mais de um minuto (!) No meu laptop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pypy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o JIT ativado, a solução demorou 1 segundo no laptop, mas no Raspberry Pi ainda demorou cerca de um minuto. </font><font style="vertical-align: inherit;">Após várias tentativas de acelerar o trabalho do programa Python (numpy, multiprocessamento), decidi reescrever o algoritmo em C. No entanto, a solução agora leva de 1 a 2 segundos, mesmo para Raspberry. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postei as duas implementações do algoritmo no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle da máquina</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O próximo passo foi escrever um programa que controlasse a parte mecânica: mover os motores, levando em consideração as relações de transmissão e as limitações do mecanismo (por exemplo, os suportes laterais só podem ser girados quando o fundo estiver em uma determinada posição, caso contrário, isso interferirá). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/b89/c9b/3e0/b89c9b3e0780fae3e7dd5b28a8aa209d.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além do programa principal, criei um shell interativo que me salvou muito tempo ao depurar. </font><font style="vertical-align: inherit;">Em geral, essa parte não era incomum em termos de programação. </font><font style="vertical-align: inherit;">Para depurar a verificação, gerei os resultados como imagens.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digitalização e reconhecimento de cores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Até esse ponto, tudo era interessante, mas não difícil. </font><font style="vertical-align: inherit;">Duas semanas após o início do trabalho, a máquina já podia coletar um cubo de um determinado estado. </font><font style="vertical-align: inherit;">Restou apenas aprender a ler a configuração inicial do cubo usando um scanner. </font><font style="vertical-align: inherit;">Já tínhamos um programa de trabalho para o Arduino, por isso não esperávamos surpresas. </font><font style="vertical-align: inherit;">No entanto, essa parte do projeto acabou sendo a mais difícil e levamos mais 2 meses de trabalho.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indicações Photoresistor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como escrevi acima, começamos com um circuito de scanner com capacitores. O erro dessa abordagem foi horrível; portanto, para obter valores utilizáveis, tive que fazer medições várias vezes e depois me livrar das emissões. Depois disso, obtivemos algo assim (este é o resultado da digitalização do cubo montado em uma sala escura): </font></font><br>
<br>
<img src="https://habrastorage.org/files/d0d/0eb/467/d0d0eb4676f54a8c9319882658278664.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, o resultado está longe de ser o ideal. Primeiro, os valores para a mesma cor são diferentes em posições diferentes, pois os fotorresistores e os LEDs “olham” em direções ligeiramente diferentes. Em segundo lugar, algumas cores estão muito próximas umas das outras no espaço de cores e, às vezes, os intervalos de valores se sobrepõem (por exemplo, laranja e vermelho às vezes dão o mesmo valor). E, finalmente, as leituras dependem muito da iluminação externa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visualmente, o erro do scanner nos capacitores pode ser visto no diagrama a seguir (em geral, há </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma versão interativa aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><br>
<br>
<img src="https://habrastorage.org/files/8a6/489/4fd/8a64894fd9a249a1a297ac2743930120.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olhando para trás, pergunto-me como conseguimos fazer a digitalização funcionar com esses resultados, embora isso exigisse uma calibração cuidadosa e complicada dos valores em questão vai um pouco mais baixo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse, o scanner de capacitor funcionou, mas foi muito lento. </font><font style="vertical-align: inherit;">Quando o substituímos por outro, pelo Arduino embutido, as leituras ficaram muito mais "cheias" (a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versão interativa está aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<img src="https://habrastorage.org/files/c6e/0a8/8b5/c6e0a88b595747aa87ef2c35bdf634fe.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calibração e agrupamento de leituras</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que tínhamos as leituras brutas de RGB dos fotorresistores, tivemos que identificar as cores para fornecer a configuração do cubo ao algoritmo de construção. Duas abordagens diferentes foram imediatamente sugeridas aqui: o uso de intervalos de cores e o algoritmo de agrupamento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira abordagem é uma solução "frontal": foi possível determinar experimentalmente os intervalos de valores para cada lado do cubo (de fato, para dividir o espaço de cores em áreas separadas) e, em seguida, simplesmente combinar os valores de acordo com sua pertença a um determinado intervalo. Nesse caso, cada uma das 9 posições possíveis na borda do cubo deve ser considerada separadamente. Este método é muito fácil de programar, mas possui duas desvantagens significativas. Primeiro, ele nos liga a cores específicas, o que significa que só podemos coletar um cubo de Rubik estritamente definido. E segundo, os intervalos de valores possíveis dependem muito da iluminação externa. Além disso, descobrimos que, dependendo da luz ambiente, a mesma leitura pode corresponder a cores diferentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda abordagem requer calibração preliminar dos valores para que a mesma cor produz os mesmos resultados em todas as 9 posições na borda do cubo. </font><font style="vertical-align: inherit;">Nesse caso, podemos usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o algoritmo de agrupamento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para combinar os valores em 6 grupos. </font><font style="vertical-align: inherit;">Ao mesmo tempo, não importa em que cores o cubo é pintado, se elas forem diferentes. </font><font style="vertical-align: inherit;">Infelizmente, esse método também teve que ser "rejeitado" devido à natureza probabilística dos algoritmos de agrupamento: eles podem produzir um resultado "bom", mas não garantem sua precisão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas as abordagens têm seus prós e contras, portanto, como resultado, usamos algo entre:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de tudo, fazemos uma calibração artificial das leituras do scanner para normalizar os valores. </font><font style="vertical-align: inherit;">Os coeficientes são obtidos experimentalmente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converta os valores RGB resultantes em HSV</font></font></li>
<li>   ,    S ()</li>
<li>     </li>
<li>    ,     .</li>
</ol><br>
<br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesmo com um bom algoritmo de agrupamento, a verificação frequentemente falhava devido às condições ambientais. </font><font style="vertical-align: inherit;">O algoritmo, calibrado em um quarto escuro, não conseguiu lidar com a tarefa em condições diurnas e vice-versa. </font><font style="vertical-align: inherit;">Além disso, se a iluminação externa era muito brilhante (luz solar direta), o scanner geralmente parava de funcionar, pois a influência dos LEDs se tornava quase imperceptível. </font><font style="vertical-align: inherit;">Wilbert fez um trabalho minucioso ao isolar o scanner da luz ambiente. </font><font style="vertical-align: inherit;">Eu tive que passar por três iterações: cada vez que pensávamos que seria suficiente, e cada vez que encontramos outra lacuna através da qual a iluminação externa caía no fotorresistor.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/d4c/a1e/795/d4ca1e795ba1c28d27a3fa8ebbc8c5cb.jpg" alt="imagem"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhar neste projeto foi incrivelmente empolgante. É muito bom ver o carro ganhar vida diante de seus olhos e é especialmente legal ver como ele funciona, justificando todos os seus esforços. No entanto, isso não pode ser comparado ao estoque de conhecimento que conseguimos obter no processo. Eu não poderia imaginar que teria que estudar um monte de materiais sobre eletrônica, mecânica, álgebra e até estatística matemática, e ao longo do caminho para encontrar uma dúzia de utilitários e bibliotecas úteis. É por isso que estou tão feliz por ter tido a oportunidade de trabalhar neste projeto.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/238/e22/a67/238e22a6758025d7fbda1f52441b75a2.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seja como for, este carro é apenas um protótipo. </font><font style="vertical-align: inherit;">Não estabelecemos o objetivo de quebrar o recorde de velocidade e certamente não percebemos todo o potencial das peças mecânicas. </font><font style="vertical-align: inherit;">Mas definitivamente tentaremos fazer isso na próxima versão da máquina, na qual já começamos a trabalhar. </font><font style="vertical-align: inherit;">Lá vamos usar a câmera para digitalizar, e o design dos manipuladores sofreu mudanças significativas. </font><font style="vertical-align: inherit;">E, claro, se você tiver alguma dúvida, sugestão ou dica, ficarei feliz em ouvi-los nos comentários.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt384503/">https://habr.com/ru/post/pt384503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt384489/index.html">Новый самый быстрый твердотельный накопитель от корейского производителя — Samsung 950 Pro</a></li>
<li><a href="../pt384491/index.html">Robôs estacionam melhor que humanos</a></li>
<li><a href="../pt384493/index.html">Relógio eletrônico Qlocktwo-style</a></li>
<li><a href="../pt384499/index.html">Acer Revo One: миниатюрный компьютер широкого спектра действия</a></li>
<li><a href="../pt384501/index.html">Som no seu bolso por 500 000r: Astell & Kern AK380 + Astell & Kern Layla</a></li>
<li><a href="../pt384505/index.html">Fones de ouvido com tecnologia de condução óssea: o que são, por que são necessários e onde comprar</a></li>
<li><a href="../pt384507/index.html">O tempo de inatividade do datacenter da Amazon trava Netflix, Heroku e outros serviços</a></li>
<li><a href="../pt384509/index.html">A NVIDIA instalará sua melhor placa de vídeo para laptop GeForce GTX 980</a></li>
<li><a href="../pt384511/index.html">Стартовые грабли — как мы открывали игровую площадку</a></li>
<li><a href="../pt384513/index.html">Postos de gasolina solares móveis EV ARC - realidades e perspectivas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>