<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèæ üìé ‚úãüèΩ ¬øEs f√°cil agregar nuevas funciones al marco anterior? Harina de elecci√≥n sobre el ejemplo del desarrollo de SObjectizer üì° üëÜüèª üç∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollo de un marco gratuito para las necesidades de los desarrolladores es un tema espec√≠fico. Si al mismo tiempo el marco vive y se desarrolla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øEs f√°cil agregar nuevas funciones al marco anterior? Harina de elecci√≥n sobre el ejemplo del desarrollo de SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423879/"><img src="https://habrastorage.org/webt/en/lw/bb/enlwbb8hjnjmprjbfysbwsnejiy.jpeg"><br><br>  El desarrollo de un marco gratuito para las necesidades de los desarrolladores es un tema espec√≠fico.  Si al mismo tiempo el marco vive y se desarrolla durante un tiempo bastante largo, entonces se agregan los detalles.  Hoy intentar√© mostrar esto usando un ejemplo de un intento de expandir la funcionalidad de un marco de "actor" para C ++ llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> . <br><br>  El hecho es que este marco ya es bastante antiguo, ha cambiado dram√°ticamente varias veces.  Incluso su encarnaci√≥n actual, SObjectizer-5, ha sufrido muchos cambios, tanto graves como no tan graves.  Adem√°s, somos bastante sensibles a la compatibilidad, y hacer cambios que rompan la compatibilidad es un paso demasiado serio para que podamos decidirlo. <br><br>  En este momento tenemos que decidir c√≥mo agregar una nueva caracter√≠stica a la pr√≥xima versi√≥n.  En el proceso de encontrar una soluci√≥n adecuada, surgieron dos opciones.  Ambos parecen bastante realizables.  Pero son muy diferentes entre s√≠.  Tanto en t√©rminos de complejidad y complejidad de implementaci√≥n, como en su "apariencia".  Es decir  lo que tratar√° el desarrollador se ver√° diferente en cada una de las opciones.  Probablemente incluso fundamentalmente diferente. <br><br>  Y ahora, como desarrolladores del marco, tenemos que tomar una decisi√≥n a favor de una u otra soluci√≥n.  O uno debe admitir que ninguno de ellos es satisfactorio y, por lo tanto, hay que inventar algo m√°s.  Tales decisiones durante la historia de SObjectizer tuvieron que tomarse m√°s de una vez.  Si alguien est√° interesado en sentirse en la piel del desarrollador de dicho marco, entonces eres bienvenido a cat. <br><a name="habracut"></a><br><h1>  Problema original </h1><br>  Entonces, brevemente la esencia del problema original.  Desde el comienzo de su existencia, SObjectizer ten√≠a la siguiente caracter√≠stica: un mensaje de temporizador no es tan f√°cil de cancelar.  Debajo del temporizador se entender√°, en primer lugar, un mensaje retrasado.  Es decir  un mensaje que no debe enviarse inmediatamente al destinatario, sino despu√©s de un tiempo.  Por ejemplo, hacemos send_delayed con una pausa de 1s.  Esto significa que, en realidad, el mensaje ser√° enviado por el temporizador 1 despu√©s de la llamada send_delayed. <br><br>  Un mensaje pendiente puede, en principio, ser cancelado.  Si el mensaje todav√≠a est√° en posesi√≥n del temporizador, el mensaje despu√©s de la cancelaci√≥n no ir√° a ninguna parte.  Ser√° lanzado por el temporizador y eso es todo.  Pero si el temporizador ya ha enviado un mensaje y ahora est√° en la cola de solicitudes para el agente receptor, la cancelaci√≥n del temporizador no funcionar√°.  No hay ning√∫n mecanismo en SObjectizer para eliminar un mensaje de la cola de la aplicaci√≥n. <br><br>  El problema se agrava al menos por dos factores. <br><br>  En primer lugar, SObjectizer admite la entrega en modo 1: N, es decir  si el mensaje se envi√≥ al mbox de Multi-Consumer, entonces el mensaje no estar√° en una cola, sino en varias colas para N destinatarios a la vez. <br><br>  En segundo lugar, en SObjectizer se utiliza el mecanismo del despachador y los despachadores pueden ser muy diferentes, incluidos los escritos por el usuario para sus necesidades espec√≠ficas.  Las colas de solicitudes son gestionadas por los despachadores.  Y en la interfaz del despachador no hay funcionalidad para retirar una aplicaci√≥n que ya ha sido transferida al despachador.  Pero incluso si dicha funcionalidad estuviera integrada en la interfaz, est√° lejos de ser un hecho que pueda implementarse de manera efectiva en todos los casos.  Sin mencionar el hecho de que dicha funcionalidad aumentar√≠a la complejidad del desarrollo de nuevos despachadores. <br><br>  En general, objetivamente, si el temporizador ya ha enviado un mensaje pendiente a los destinatarios, entonces obligar a SObjectizer a no entregar esta instancia del mensaje es actualmente imposible. <br><blockquote>  De hecho, este problema tambi√©n es relevante para mensajes peri√≥dicos (es decir, mensajes que el temporizador debe enviar peri√≥dicamente a intervalos de tiempo predeterminados).  Pero en la pr√°ctica, cancelar mensajes peri√≥dicos es mucho menos necesario que cancelar un mensaje pendiente.  Al menos en nuestra pr√°ctica esto es as√≠. </blockquote><h2>  ¬øQu√© se puede hacer ahora? </h2><br>  Por lo tanto, este problema no es nuevo y durante mucho tiempo hay recomendaciones sobre c√≥mo tratarlo. <br><br><h3>  Identificaci√≥n √∫nica dentro del mensaje pendiente </h3><br>  La forma m√°s f√°cil es mantener un contador.  El agente tiene un contador; al enviar un mensaje pendiente, el valor del contador actual se env√≠a en el mensaje.  Cuando se cancela un mensaje, se incrementa el contador en el agente.  Al recibir el mensaje, el valor del contador actual en el agente se compara con el valor del mensaje.  Si los valores no coinciden, el mensaje se rechaza: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_; ... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expected_msg_id_{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> timer_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_some_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //   send_periodic, ..    //  timer_id   . timer_ = so_5::send_periodic&lt;delayed_msg&gt;(*this, 25s, //     . 0s, //    . //      delayed_msg, //      id   . ++expected_msg_id_, ... //  . ); ... } void on_cancel_event() { //   ,        //   .   : timer_.reset(); //     . ++expected_msg_id_; //   id-. ... } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     id    //  . if(expected_msg_id_ == cmd-&gt;id_) { ... //  . } } };</span></span></code> </pre> <br>  El problema con este m√©todo es que el desarrollador del agente necesita ser desconcertado al mantener estos contadores.  Y si como mensaje retrasado necesitamos enviar el mensaje de otra persona que otra persona hizo, y en el que no hay un campo id_, entonces nos encontramos en una situaci√≥n dif√≠cil. <br><br>  Aunque, por otro lado, esta es la forma m√°s efectiva que existe actualmente. <br><br><h3>  Use mbox √∫nico para mensajes demorados </h3><br>  Otra forma que funciona bien es usar un buz√≥n √∫nico (mbox) para un mensaje retrasado.  En este caso, creamos un nuevo mbox para cada mensaje pendiente, suscribimos y enviamos el mensaje pendiente a este mbox.  Cuando un mensaje necesita ser cancelado, simplemente eliminamos las suscripciones de mbox. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//   id_   . }; so_5::mbox_t timer_mbox_; //   . so_5::timer_id_t timer_; void on_some_event() { //        mbox //     . timer_mbox_ = so_environment().create_mbox(); some_state.event(time_mbox_, ...); another_state.event(time_mbox_, ...); ... //    . timer_ = so_5::send_delayed&lt;delayed_msg&gt;( so_environment(), timer_mbox_, //     . 25s, 0s, ... //    delayed_msg. ); } void on_cancel_event() { //        mbox. timer_.reset(); so_drop_subscription_for_all_states(timer_mbox_); } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     ,   //    . ... } };</span></span></code> </pre> <br>  Este m√©todo ya puede funcionar con mensajes de otras personas, dentro de los cuales no hay un identificador √∫nico.  Pero tambi√©n requiere mano de obra y atenci√≥n del desarrollador. <br><br>  Por ejemplo, en la realizaci√≥n anterior, no hay protecci√≥n contra el hecho de que un mensaje pendiente ya se ha enviado anteriormente.  En el buen sentido, antes de enviar un nuevo mensaje pendiente, siempre debe realizar acciones desde on_cancel_event (), de lo contrario, el agente tendr√° suscripciones innecesarias para ello. <br><br><h2>  ¬øPor qu√© este problema no se ha resuelto antes? </h2><br>  Aqu√≠ todo es bastante simple: de hecho, este no es un problema tan serio como podr√≠a parecer.  Al menos en la vida real no tienes que lidiar con eso a menudo.  Por lo general, los mensajes pendientes y peri√≥dicos no se cancelan en absoluto (por eso, por cierto, la funci√≥n send_delayed no devuelve timer_id).  Y cuando surja la necesidad de cancelaci√≥n, puede usar uno de los m√©todos descritos anteriormente.  O incluso usar alguna otra.  Por ejemplo, cree agentes separados que procesen un mensaje pendiente.  Estos agentes pueden ser dados de baja cuando un mensaje pendiente necesita ser cancelado. <br><br>  Entonces, en el contexto de otras tareas que nos enfrentamos, simplificar la cancelaci√≥n garantizada de un mensaje pendiente no era tan prioritario como para gastar nuestros recursos en resolver este problema. <br><br><h2>  ¬øPor qu√© es relevante el problema ahora? </h2><br>  Aqu√≠ todo es igual de simple.  Por un lado, las manos finalmente llegaron. <br><br>  Por otro lado, cuando nuevas personas que no ten√≠an experiencia trabajando con √©l comienzan a usar SObjectizer, esta caracter√≠stica con la cancelaci√≥n de temporizadores los sorprende enormemente.  No es tan gratamente sorprendente.  Y si es as√≠, me gustar√≠a minimizar las impresiones negativas de conocer nuestra herramienta. <br><br>  Adem√°s, ten√≠amos nuestras propias tareas, no necesit√°bamos cancelar constantemente los mensajes pendientes.  Y los nuevos usuarios tienen sus propias tareas, tal vez todo sea al rev√©s. <br><br><h1>  Nueva declaraci√≥n del problema. </h1><br>  Casi de inmediato, tan pronto como comenz√≥ a considerar la posibilidad de una "cancelaci√≥n garantizada del temporizador", pens√© que la tarea podr√≠a ampliarse.  Puede intentar resolver el problema de recuperar cualquiera de los mensajes enviados anteriormente, no necesariamente retrasados ‚Äã‚Äãy peri√≥dicos. <br><br>  De vez en cuando esta oportunidad est√° en demanda.  Por ejemplo, imagine que tenemos varios agentes interactivos de dos tipos: punto_entrada (acepta solicitudes de clientes) y procesador (procesa solicitudes): <br><br><img src="https://habrastorage.org/webt/s7/mo/jp/s7mojpeyu9s6prshykrqxul14he.png"><br><br>  Los agentes de punto de entrada env√≠an solicitudes al agente de procesador, que las procesa tanto como sea posible y responde a los agentes de punto de entrada.  Pero a veces, entry_point puede encontrar que ya no es necesario procesar una solicitud enviada anteriormente.  Por ejemplo, el cliente envi√≥ un comando de cancelaci√≥n o el cliente "se cay√≥" y ya no necesita procesar sus solicitudes.  Ahora, si el agente de procesador pone en cola los mensajes de solicitud, no podr√° recuperarlos.  Y ser√≠a √∫til. <br><br>  Por lo tanto, el enfoque actual para resolver el problema de la "cancelaci√≥n garantizada del temporizador" se lleva a cabo precisamente como un soporte adicional para los "mensajes de recuperaci√≥n".  Enviamos cualquier mensaje de una manera especial, tenemos un identificador a mano, con el que luego puede recuperar el mensaje.  Y no es tan importante si responde un mensaje regular o uno retrasado. <br><br><h1>  Un intento de llegar a la implementaci√≥n de "recordar mensajes" </h1><br>  Por lo tanto, debe introducir el concepto de "mensaje de recuperaci√≥n" y respaldar este concepto en SObjectizer.  Y as√≠, permanecer dentro de la rama 5.5.  La primera versi√≥n de este hilo, 5.5.0, sali√≥ hace casi cuatro a√±os, en octubre de 2014.  Desde entonces, no ha habido cambios importantes en 5.5.  Los proyectos que ya cambiaron o comenzaron inmediatamente en SObjectize-5.5 pueden cambiar a nuevas versiones en la rama 5.5 sin ning√∫n problema.  Esta compatibilidad debe mantenerse esta vez. <br><br>  En general, todo es simple: debes tomar y hacer. <br><br><h2>  Lo que est√° claro c√≥mo hacer </h2><br>  Despu√©s del primer enfoque del problema, se pusieron de manifiesto dos cosas acerca de la implementaci√≥n de los "mensajes de recuerdo". <br><br><h3>  Indicador at√≥mico y su verificaci√≥n antes del procesamiento del mensaje </h3><br>  En primer lugar, es obvio que dentro del marco de la arquitectura actual de SObjectizer-5.5 (y tal vez a√∫n m√°s globalmente: dentro del marco de los principios de SObjectizer-5 en s√≠), es imposible eliminar mensajes de las colas de solicitud del despachador, donde los mensajes esperan hasta que los agentes receptores los procesen.  Intentar hacer esto matar√° toda la idea de despachadores heterog√©neos, que incluso el usuario puede hacer por su cuenta, de acuerdo con los detalles de su tarea (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> ).  Adem√°s, en el caso de enviar un mensaje en modo 1: N, donde N ser√° grande, ser√° costoso mantener una lista de punteros a una instancia del mensaje enviado en todas las colas. <br><br>  Esto significa que, junto con el mensaje, se debe transmitir alg√∫n tipo de indicador at√≥mico, que deber√° analizarse inmediatamente despu√©s de eliminar el mensaje de la cola de solicitudes, pero antes de enviar el mensaje para su procesamiento al agente receptor.  Es decir  el mensaje ingresa a la cola y no se elimina de all√≠.  Pero cuando llega el turno del mensaje, se marca su bandera.  Y si la bandera dice que el mensaje ha sido retirado, entonces el mensaje no se procesa. <br><br>  En consecuencia, la recuperaci√≥n del mensaje en s√≠ consiste en establecer un valor especial para el indicador at√≥mico dentro del mensaje. <br><br><h3>  Revocable_handle_t &lt;M&gt; objeto </h3><br>  En segundo lugar, hasta ahora (?) Es obvio que para enviar un mensaje revocable, no se deben utilizar los m√©todos habituales de env√≠o de mensajes, sino un objeto especial bajo el nombre en c√≥digo revocable_handle_t. <br><br>  Para enviar un mensaje revocable, el usuario debe crear una instancia de revocable_handle_t y luego llamar al m√©todo de env√≠o en esta instancia.  Y si es necesario recuperar el mensaje, esto se hace utilizando el m√©todo de revocaci√≥n.  Algo como: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> {</span></span>...}; ... so_5::<span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_message&gt; msg; <span class="hljs-comment"><span class="hljs-comment">//    . msg.send(target, //  . ... //    my_message. ); ... //   . msg.revoke();</span></span></code> </pre> <br>  Todav√≠a no hay detalles claros de la implementaci√≥n revocable_handle_t, lo cual no es sorprendente, ya que  El mecanismo de trabajo de los mensajes de recuperaci√≥n a√∫n no se ha seleccionado.  Pero el principio del trabajo es que en revocable_handle_t se guarda un enlace inteligente al mensaje enviado y a la bandera at√≥mica para ello.  El m√©todo revoke () intenta reemplazar el valor del indicador.  Si esto tiene √©xito, el mensaje, despu√©s de extraerlo de la cola de pedidos, ya no se procesar√°. <br><br><h3>  De qu√© no ser√°n amigos </h3><br>  Desafortunadamente, hay un par de cosas con las que recordar mensajes no se puede vincular correctamente.  Solo porque el mensaje retirado contin√∫a en las colas donde ya ha llegado. <br><br><h4>  mensaje_limites </h4><br>  Una caracter√≠stica tan importante de SObjectizer como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">message_limits</a> est√° dise√±ada para proteger a los agentes de la sobrecarga.  Message_limits funciona en funci√≥n del recuento de mensajes en la cola.  Puso en cola un mensaje: aument√≥ el contador.  Sali√≥ de la l√≠nea - reducido. <br><br>  Porque  cuando se revoca un mensaje, permanece en la cola, entonces message_limits no afecta la respuesta del mensaje.  Por lo tanto, puede resultar que la cola tenga un l√≠mite en el n√∫mero de mensajes de tipo M, pero todos ellos han sido retirados del mercado.  De hecho, ninguno de ellos ser√° procesado.  Pero poner en cola un nuevo mensaje de tipo M no funcionar√°, porque  Se supera el l√≠mite. <br><br>  La situaci√≥n no es buena.  ¬øPero c√≥mo salir de eso?  No est√° claro <br><br><h4>  cola fija mchains </h4><br>  En SObjectizer, se puede enviar un mensaje no solo a mbox, sino tambi√©n a mchain (este es nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">an√°logo del canal CSP</a> ).  Y las cadenas pueden tener un tama√±o fijo para sus colas.  Un intento de poner un nuevo mensaje para mchain con un tama√±o fijo en mchain completo deber√≠a dar lugar a alg√∫n tipo de reacci√≥n.  Por ejemplo, esperando la liberaci√≥n de espacio en la cola.  O para empujar el mensaje m√°s antiguo. <br><br>  En el caso de un recuerdo del mensaje, permanecer√° dentro de la cola de mchain.  Resulta que el mensaje ya no es necesario, pero ocupa espacio en la cola de mchain.  Y evita que se env√≠en nuevos mensajes a mchain. <br><br>  La misma mala situaci√≥n que con message_limits.  Y de nuevo, no est√° claro c√≥mo se puede solucionar. <br><br><h2>  Lo que no est√° claro c√≥mo hacerlo </h2><br>  As√≠ que pudimos elegir entre dos (¬øhasta ahora?) Opciones para implementar mensajes de recuperaci√≥n.  La primera opci√≥n es simple de implementar y no requiere la alteraci√≥n de los menudillos de SObjectizer.  La segunda opci√≥n es mucho m√°s complicada, pero en ella el destinatario del mensaje ni siquiera sabe que est√° tratando con mensajes revocables.  Consideraremos brevemente cada uno de ellos. <br><br><h3>  Reciba mensajes revocables como revocable_t &lt;M&gt; </h3><br>  La primera soluci√≥n, que parece, en primer lugar, factible y, en segundo lugar, bastante pr√°ctica, es la introducci√≥n de un contenedor especial revocable_t &lt;M&gt;.  Cuando el usuario env√≠a un mensaje revocable de tipo M a trav√©s de revocable_handle_t &lt;M&gt;, no se env√≠a el mensaje M, sino el mensaje M dentro del contenedor especial revocable_t &lt;M&gt;.  Y, en consecuencia, el usuario no recibir√° ni procesar√° el mensaje de tipo M, sino el mensaje revocable_t &lt;M&gt;.  Por ejemplo, de esta manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-comment"><span class="hljs-comment">// ,    . void so_define_agent() override { //   . so_subscribe_self().event( //     ,    //   . [this](mhood_t&lt; revocable_t&lt;request&gt; &gt; cmd) { // ,      . cmd-&gt;try_handle([this](mhood_t&lt;request&gt; msg) { ... }); }); ... } ... };</span></span></code> </pre> <br>  El m√©todo revocable_t &lt;M&gt; :: try_handle () verifica el valor del indicador at√≥mico y, si no se recupera el mensaje, llama a la funci√≥n lambda que se le pas√≥.  Si se retira el mensaje, try_handle () no hace nada. <br><br><h4>  Pros y contras de este enfoque </h4><br>  La principal ventaja es que este viaje se implementa f√°cilmente (al menos hasta ahora parece).  De hecho, revocable_handle_t &lt;M&gt; y revocable_t &lt;M&gt; ser√°n solo un complemento sutil para SObjectizer. <br><br>  Es posible que se requiera la intervenci√≥n en los componentes internos de SObjectizer para hacer amigos revocable_t y mutable_msg.  El hecho es que en SObjectizer existe el concepto de mensajes inmutables (pueden enviarse tanto en modo 1: 1 como en modo 1: N).  Y existe el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mensajes mutables</a> que solo pueden enviarse en modo 1: 1.  En este caso, SObjectizer trata de manera especial el marcador mutable_msg &lt;M&gt; y realiza las comprobaciones correspondientes en tiempo de ejecuci√≥n.  En el caso de revocable_t &lt;mutable_msg &lt;M&gt;&gt;, deber√° ense√±ar a SObjectizer a tratar esta construcci√≥n como mutable_msg &lt;M&gt;. <br><br>  Otra ventaja es que la sobrecarga adicional (tanto en los metadatos del mensaje revocable como en la verificaci√≥n de la bandera at√≥mica) solo estar√° en lugares donde no puede prescindir de ella.  Cuando no se utilizan los mensajes de recuperaci√≥n, no habr√° sobrecarga adicional. <br><br>  Pero el principal inconveniente es ideol√≥gico.  En este enfoque, el hecho de usar mensajes revocables afecta tanto al remitente (usando revocable_handle_t &lt;M&gt;) como al destinatario (usando revocable_t &lt;M&gt;).  Pero el destinatario simplemente no necesita saber que est√° recibiendo mensajes de recuperaci√≥n.  Adem√°s, como destinatario, puede tener un agente externo listo para usar que se escribe sin revocable_t &lt;M&gt;. <br><br>  Adem√°s, quedan preguntas ideol√≥gicas sobre, por ejemplo, la posibilidad de reenviar dichos mensajes.  Pero, seg√∫n las primeras estimaciones, estos problemas est√°n resueltos. <br><br><h3>  Recibir mensajes de recuperaci√≥n como mensajes regulares </h3><br>  El segundo enfoque es ver solo el mensaje de tipo M en el lado del receptor y no tener una idea de la existencia de revocable_handle_t &lt;M&gt; y revocable_t &lt;M&gt;.  Es decir  si el procesador debe recibir una solicitud, solo deber√≠a ver una solicitud, sin envoltorios adicionales. <br><br>  En realidad, uno no puede prescindir de algunos contenedores en este enfoque, pero estar√°n ocultos dentro del SObjectizer y el usuario no deber√≠a verlos.  Una vez que la aplicaci√≥n se recupera de la cola, SObjectizer determinar√° por s√≠ misma que se trata de un mensaje revocable especialmente envuelto, verificar√° el indicador de relevancia del mensaje y lo ampliar√° si a√∫n es relevante.  Luego enviar√° un mensaje al agente para su procesamiento como si fuera un mensaje normal. <br><br><h4>  Pros y contras de este enfoque </h4><br>  La principal ventaja de este enfoque es obvia: el destinatario del mensaje no sabe con qu√© mensajes trabaja.  Esto permite al remitente del mensaje retirar con calma los mensajes de cualquier agente, incluso aquellos escritos por otros desarrolladores. <br><br>  Otra ventaja importante es la capacidad de integrarse con el mecanismo de rastreo de entrega de mensajes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ se describe el papel de este mecanismo con m√°s detalle</a> ).  Es decir  Si msg_tracing est√° habilitado y el remitente retira el mensaje, se pueden encontrar rastros de esto en el registro de msg_tracing.  Lo cual es muy conveniente al depurar. <br><br>  Pero la principal desventaja es la complejidad de implementar este enfoque.  En el que varios factores deber√°n tenerse en cuenta. <br><br>  Primero, arriba.  Todo tipo de cosas. <br><br>  Digamos que puede hacer una bandera especial dentro de un mensaje que indique si este mensaje es revocable o no.  Y luego verifique esta bandera antes de comenzar a procesar cada mensaje.  En t√©rminos generales, se agrega otro if al mecanismo de entrega de mensajes, que funcionar√° mientras procesa cada (!) Mensaje. <br><br>  Estoy seguro de que en aplicaciones reales, la p√©rdida de esto ser√° apenas perceptible.  Pero la reducci√≥n en los puntos de referencia sint√©ticos ciertamente aparecer√°.  Adem√°s, cuanto m√°s abstracto sea el punto de referencia, menos trabajo real har√°, m√°s se hundir√°.  Y esto es malo desde el punto de vista del marketing, porque  Hay varias personas que sacan conclusiones sobre el marco en t√©rminos de puntos de referencia sint√©ticos.  Y lo hacen espec√≠ficamente: sin entender qu√© tipo de punto de referencia es, que b√°sicamente muestra en qu√© hardware funciona, pero comparando los totales con el rendimiento de alguna herramienta especializada, en otro escenario, en otro hardware, etc. ., etc. <br><br>  En general, dado que estamos creando un marco universal que, como resulta, se juzga por n√∫meros abstractos en puntos de referencia abstractos, no queremos perder, por ejemplo, el 5% del rendimiento en el mecanismo de entrega de <i>todos los</i> mensajes debido a la adici√≥n de una funci√≥n que solo lleva tiempo de vez en cuando y no para todos los usuarios. <br><br>  Por lo tanto, debe asegurarse de que cuando env√≠a el mensaje al destinatario, SObjectizer comprende que cuando extrae el mensaje, debe manejarlo de una manera especial.  En principio, cuando se entrega un mensaje a un agente, SObjectizer almacena con el mensaje un puntero a una funci√≥n que se utilizar√° al procesar el mensaje.  Esto es necesario ahora para manejar mensajes as√≠ncronos y solicitudes sincr√≥nicas de diferentes maneras.  En realidad, as√≠ es como se ve la solicitud del mensaje dirigido al agente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_demand_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Receiver of demand. agent_t * m_receiver; //! Optional message limit for that message. const message_limit::control_block_t * m_limit; //! ID of mbox. mbox_id_t m_mbox_id; //! Type of the message. std::type_index m_msg_type; //! Event incident. message_ref_t m_message_ref; //! Demand handler. demand_handler_pfn_t m_demand_handler; ... };</span></span></code> </pre> <br>  Donde demand_handler_pfn_t es un puntero de funci√≥n regular: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">demand_handler_pfn_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">current_thread_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; )</span></span></span></span>;</code> </pre><br>  El mismo mecanismo tambi√©n se puede utilizar para procesar especialmente el mensaje que se retira.  Es decir  cuando mbox env√≠a un mensaje al agente, el agente sabe si se le env√≠a un mensaje asincr√≥nico o una solicitud sincr√≥nica.  Del mismo modo, un agente puede recibir un mensaje de devoluci√≥n de llamada as√≠ncrono de una manera especial.  Y el agente guardar√°, junto con el mensaje, un puntero a una funci√≥n que sabe c√≥mo debe manejar los mensajes revocados. <br><br>  Todo parece estar bien, pero hay dos grandes "peros" ... :( <br><br>  En primer lugar, la interfaz mbox existente (es decir, la clase <a href="">abstract_message_mbox_t</a> ) no tiene m√©todos para enviar mensajes de recuperaci√≥n.  Por lo tanto, esta interfaz debe ampliarse.  Y para que las implementaciones de mbox de otras personas que est√°n vinculadas a abstract_message_box_t de SObjectizer-5.5 no se rompan (en particular, la serie mbox se implementa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">so_5_extra</a> y simplemente no quiero romperlas). <br><br>  En segundo lugar, los mensajes se pueden enviar no solo a mbox-s, detr√°s de los cuales se ocultan los agentes, sino tambi√©n a mchain-s.  Cu√°les son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestras contrapartes de los canales CSP</a> .  Y hasta ahora, las aplicaciones estaban mintiendo sin ning√∫n puntero adicional a las funciones.  Para introducir un puntero adicional en cada elemento de la cola de aplicaciones mchain ... Puede, por supuesto, pero parece una soluci√≥n bastante costosa.  Adem√°s, las implementaciones de mchain en s√≠ mismas hasta ahora no han previsto una situaci√≥n en la que el mensaje extra√≠do deba verificarse y posiblemente desecharse. <br><br>  Si intenta resumir todos los problemas descritos anteriormente, el principal problema de este enfoque es que no es tan f√°cil implementarlo, por lo que resulta econ√≥mico para los casos en que no se utilizan los mensajes de recuperaci√≥n. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero, ¬øqu√© pasa con la cancelaci√≥n garantizada de mensajes pendientes? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me temo que el problema original se ha perdido en la naturaleza de los detalles t√©cnicos. </font><font style="vertical-align: inherit;">Supongamos que hay mensajes revocables, ¬øc√≥mo ocurrir√° la cancelaci√≥n de mensajes pendientes / peri√≥dicos? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠, como dicen, las opciones son posibles. </font><font style="vertical-align: inherit;">Por ejemplo, trabajar con mensajes pendientes / peri√≥dicos puede ser parte de la funcionalidad revocable_handle_t &lt;M&gt;:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_mesage&gt; msg; msg.send_delayed(target, <span class="hljs-number"><span class="hljs-number">15</span></span>s, ...); ... msg.revoke();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O puede hacer adem√°s de revocable_handle_t &lt;M&gt; una clase auxiliar adicional cancelable_timer_t &lt;M&gt;, que proporcionar√° los m√©todos send_delayed / send_periodic. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Punto blanco: solicitudes sincr√≥nicas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 admite no solo la interacci√≥n asincr√≥nica entre entidades en el programa (enviando mensajes a mbox y mchain), sino tambi√©n la interacci√≥n sincr√≥nica a trav√©s de request_value / request_future. </font><font style="vertical-align: inherit;">Esta interacci√≥n sincr√≥nica no solo funciona para los agentes.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No solo puede enviar una solicitud sincr√≥nica a un agente a trav√©s de su mbox. </font><font style="vertical-align: inherit;">En el caso de mchains, tambi√©n puede realizar solicitudes s√≠ncronas, por ejemplo, a otro subproceso de trabajo, en el que se llam√≥ a upload () o select () para mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, todav√≠a no est√° claro si deber√≠a permitirse el uso de solicitudes s√≠ncronas junto con mensajes revocables. </font><font style="vertical-align: inherit;">Por un lado, tal vez esto tenga alg√∫n sentido. </font><font style="vertical-align: inherit;">Y puede verse, por ejemplo, as√≠:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_request&gt; msg; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = msg.request_future&lt;my_reply&gt;(target, ...); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(some_condition) msg.revoke(); ... f.get(); <span class="hljs-comment"><span class="hljs-comment">//      revoke().</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por otro lado, todav√≠a hay muchos mensajes incomprensibles con mensajes de recuperaci√≥n, por lo que el tema de la interacci√≥n sincr√≥nica se ha pospuesto hasta tiempos mejores. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elige, pero ten cuidado. </font><font style="vertical-align: inherit;">Pero elige</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces hay una comprensi√≥n del problema. </font><font style="vertical-align: inherit;">Hay dos opciones para resolverlo. </font><font style="vertical-align: inherit;">Lo que por el momento parece factible. </font><font style="vertical-align: inherit;">Pero difieren mucho en el nivel de conveniencia brindado al usuario, y a√∫n m√°s fuertemente difieren en el costo de implementaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tienes que elegir entre estas dos opciones. </font><font style="vertical-align: inherit;">O inventa algo m√°s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°l es la dificultad de elegir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dificultad es que SObjectizer es un marco gratuito. </font><font style="vertical-align: inherit;">No nos trae dinero directamente. </font><font style="vertical-align: inherit;">Lo hacemos, como dicen, por nuestra cuenta. </font><font style="vertical-align: inherit;">Por lo tanto, solo por preferencias econ√≥micas, una opci√≥n m√°s simple y r√°pida de implementar es m√°s rentable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, por otro lado, no todo se mide en dinero, y a la larga, una herramienta bien hecha, cuyas caracter√≠sticas normalmente est√°n vinculadas entre s√≠, es mejor que un parche de mosaico hecho de parches unidos de alguna manera. La calidad es evaluada tanto por los usuarios como por nosotros mismos, cuando posteriormente acompa√±amos nuestro desarrollo y le agregamos nuevas caracter√≠sticas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, la elecci√≥n, de hecho, va entre los beneficios a corto plazo y las perspectivas a largo plazo. Es cierto que en el mundo moderno, las herramientas C ++ con perspectivas a largo plazo son de alguna manera nebulosas. Lo que hace que la elecci√≥n sea a√∫n m√°s dif√≠cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es en tales condiciones que tienes que elegir. Precauci√≥n Pero elige.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo intentamos mostrar un poco el proceso de dise√±o e implementaci√≥n de nuevas caracter√≠sticas en nuestro marco. </font><font style="vertical-align: inherit;">Tal proceso tiene lugar regularmente con nosotros. </font><font style="vertical-align: inherit;">Anteriormente a menudo porque </font><font style="vertical-align: inherit;">En 2014-2016 SObjectizer se desarroll√≥ mucho m√°s activamente. </font><font style="vertical-align: inherit;">Ahora el ritmo de lanzamiento de nuevas versiones ha disminuido. </font><font style="vertical-align: inherit;">Lo cual es objetivo, incluso porque agregar nueva funcionalidad sin romper nada, se vuelve m√°s dif√≠cil con cada nueva versi√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que haya sido interesante mirarnos detr√°s de escena.</font></font> Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423879/">https://habr.com/ru/post/es423879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423869/index.html">El futuro de los trabajos. Lo principal del informe del Foro Econ√≥mico Mundial</a></li>
<li><a href="../es423871/index.html">Resolvemos un problema l√≥gico para estudiantes en SQL</a></li>
<li><a href="../es423873/index.html">Descripci√≥n general de la impresora 3D PICASO 3D Designer X</a></li>
<li><a href="../es423875/index.html">Almacenamiento de una gran cantidad de archivos.</a></li>
<li><a href="../es423877/index.html">29-31 de octubre: creaci√≥n de un cl√∫ster de Kubernetes listo para la producci√≥n</a></li>
<li><a href="../es423881/index.html">¬øCu√°les fueron los soldadores para la √≥ptica (segunda parte)</a></li>
<li><a href="../es423885/index.html">Una invitaci√≥n a un espect√°culo de luces y un peque√±o conocedor de la futura plataforma Circle of Light en Mosc√∫</a></li>
<li><a href="../es423889/index.html">Mi decepci√≥n en el software</a></li>
<li><a href="../es423891/index.html">√Årboles de expresi√≥n de desarrollo empresarial</a></li>
<li><a href="../es423893/index.html">Hello World para recibir datos de un dispositivo Bluetooth (BLE) a trav√©s de C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>