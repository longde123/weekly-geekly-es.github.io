<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëú üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üë©üèª‚Äçüî¨ RESTinio es un servidor HTTP as√≠ncrono. Un ejemplo simple de la pr√°ctica: devolver una gran cantidad de datos en respuesta üö∫ üñêüèø ü•ô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, pas√© a trabajar en una aplicaci√≥n que deb√≠a controlar la velocidad de sus conexiones salientes. Por ejemplo, al conectarse a una URL, l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio es un servidor HTTP as√≠ncrono. Un ejemplo simple de la pr√°ctica: devolver una gran cantidad de datos en respuesta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462349/"><p><img src="https://habrastorage.org/webt/a6/kc/zt/a6kcztqtbqzp5shvd5wcz-8zzl0.jpeg"></p><br><p>  Recientemente, pas√© a trabajar en una aplicaci√≥n que deb√≠a controlar la velocidad de sus conexiones salientes.  Por ejemplo, al conectarse a una URL, la aplicaci√≥n deber√≠a limitarse a, digamos, 200KiB / seg.  Y conectarse a otra URL: solo 30 KB / seg. </p><br><p>  El punto m√°s interesante aqu√≠ fue probar estas mismas limitaciones.  Necesitaba un servidor HTTP que ofreciera tr√°fico a una velocidad determinada, por ejemplo, 512 KB / seg.  Entonces pude ver si la aplicaci√≥n realmente soporta la velocidad de 200 KB / seg o si se descompone a velocidades m√°s altas. </p><br><p>  Pero, ¬ød√≥nde conseguir un servidor HTTP? </p><br><p>  Como tengo algo que ver con el servidor HTTP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RESTinio</a> incrustado en aplicaciones C ++, no se me ocurri√≥ nada mejor que lanzar r√°pidamente un simple servidor de prueba HTTP en mi rodilla que puede enviar una larga secuencia de datos salientes al cliente. </p><br><p>  Sobre lo simple que ser√≠a y me gustar√≠a contarlo en el art√≠culo.  Al mismo tiempo, descubra en los comentarios si esto es realmente simple o si me estoy enga√±ando a m√≠ mismo.  En principio, este art√≠culo puede considerarse como una continuaci√≥n del art√≠culo anterior sobre RESTinio llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"RESTinio es un servidor HTTP as√≠ncrono. As√≠ncrono"</a> .  Por lo tanto, si alguien est√° interesado en leer sobre la aplicaci√≥n real, aunque no muy seria, de RESTinio, entonces puede invitar a cat. </p><a name="habracut"></a><br><h1 id="obschaya-ideya">  Idea general </h1><br><p>  La idea general del servidor de prueba mencionado anteriormente es muy simple: cuando el cliente se conecta al servidor y realiza una solicitud HTTP GET, se activa un temporizador que se ejecuta una vez por segundo.  Cuando se activa el temporizador, el siguiente bloque de datos de un tama√±o determinado se env√≠a al cliente. </p><br><h2 id="no-vse-neskolko-slozhnee">  Pero todo es un poco m√°s complicado. </h2><br><p>  Si el cliente lee los datos a un ritmo m√°s lento que el que env√≠a el servidor, no es una buena idea enviar N kilobytes por segundo.  Dado que los datos comenzar√°n a acumularse en el z√≥calo y esto no conducir√° a nada bueno. </p><br><p>  Por lo tanto, al enviar datos, es aconsejable controlar la disponibilidad del socket para escribir en el lado del servidor HTTP.  Mientras el socket est√© listo (es decir, a√∫n no se hayan acumulado demasiados datos), puede enviar una nueva porci√≥n.  Pero si no est√° listo, debe esperar hasta que el socket entre en un estado de preparaci√≥n para la grabaci√≥n. </p><br><p>  Parece razonable, pero las operaciones de E / S est√°n ocultas en los menudillos de RESTinio ... ¬øC√≥mo puedo saber si se puede escribir o no el siguiente dato? </p><br><p>  Puede salir de esta situaci√≥n si utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificadores de escritura posterior</a> , que est√°n en RESTinio.  Por ejemplo, podemos escribir esto: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ req-&gt;create_response() <span class="hljs-comment"><span class="hljs-comment">//   . ... //   . .done([](const auto &amp; ec) { ... //         . }); }</span></span></code> </pre> <br><p>  Se llamar√° al lambda pasado al m√©todo <code>done()</code> cuando RESTinio termine de escribir datos salientes.  En consecuencia, si el socket no estuvo listo para grabar durante alg√∫n tiempo, entonces no se llamar√° a lambda de inmediato, sino despu√©s de que el socket llegue a su estado correcto y acepte todos los datos salientes. </p><br><p>  Debido al uso de notificaciones posteriores a la escritura, la l√≥gica del servidor de prueba ser√° la siguiente: </p><br><ul><li>  env√≠e el siguiente lote de datos, calcule el tiempo en que tendr√≠amos que enviar el siguiente lote en el curso normal de los eventos; </li><li>  colgamos despu√©s de escribir el notificador en la siguiente porci√≥n de datos; </li><li>  cuando se llama a la notificaci√≥n posterior a la escritura, verificamos si ha llegado el siguiente lote.  Si es as√≠, inicie inmediatamente el env√≠o de la siguiente porci√≥n.  Si no es as√≠, entonces activa el temporizador. </li></ul><br><p>  Como resultado, resulta que tan pronto como la grabaci√≥n comience a disminuir, el env√≠o de nuevos datos se detendr√°.  Y reanude cuando el socket est√© listo para aceptar nuevos datos salientes. </p><br><h2 id="i-esche-nemnogo-slozhnogo-chunked_output">  Y un poco m√°s complicado: chunked_output </h2><br><p>  RESTinio admite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres formas de generar una respuesta a una solicitud HTTP</a> .  El m√©todo m√°s simple, que se usa por defecto, no es adecuado en este caso, porque  Necesito un flujo casi infinito de datos salientes.  Y, por supuesto, dicha secuencia no puede <code>set_body</code> a una sola llamada al m√©todo <code>set_body</code> . </p><br><p>  Por lo tanto, el servidor de prueba descrito utiliza el llamado  <em>chunked_output</em> .  Es decir  Al crear una respuesta, le indico a RESTinio que la respuesta se formar√° en partes.  Luego, peri√≥dicamente, llamo a los m√©todos <code>append_chunk</code> para agregar la siguiente parte a la respuesta y <code>flush</code> para escribir las partes acumuladas en el z√≥calo. </p><br><h1 id="a-davayte-uzhe-posmotrim-v-kod">  ¬°Y veamos el c√≥digo! </h1><br><p>  Quiz√°s sea suficiente que las palabras iniciales sean suficientes y es hora de pasar al c√≥digo en s√≠, que se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este repositorio</a> .  Comencemos con la funci√≥n <code>request_processor</code> , que se llama para procesar cada solicitud HTTP v√°lida.  Al mismo tiempo, profundicemos en las funciones que se <code>request_processor</code> desde <code>request_processor</code> .  Bueno, entonces veremos c√≥mo se asigna exactamente <code>request_processor</code> a una u otra solicitud HTTP entrante. </p><br><h2 id="funkciya-request_processor-i-eyo-podruchnye">  Funci√≥n Request_processor y sus ayudantes </h2><br><p>  Se llama a la funci√≥n <code>request_processor</code> para procesar las solicitudes HTTP GET que necesito.  Se pasa como argumentos: </p><br><ul><li>  Asio-shny io_context en el que se realiza todo el trabajo (se requerir√°, por ejemplo, para temporizadores de armado); </li><li>  El tama√±o de una parte de la respuesta.  Es decir  si necesito dar un flujo saliente a una velocidad de 512 KB / seg, entonces el valor 512 KB se pasar√° como este par√°metro; </li><li>  n√∫mero de partes en respuesta.  En caso de que la secuencia tenga una longitud limitada.  Por ejemplo, si desea dar una transmisi√≥n a una velocidad de 512 KB / s durante 5 minutos, el valor 300 se pasar√° como este par√°metro (60 bloques por minuto durante 5 minutos); </li><li>  Bueno, la solicitud entrante en s√≠ para su procesamiento. </li></ul><br><p>  Dentro de <code>request_processor</code> , se crea un objeto con informaci√≥n sobre la solicitud y sus par√°metros de procesamiento, despu√©s de lo cual comienza este mismo procesamiento: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( asio_ns::io_context &amp; ctx, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunk_size, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;response_data&gt;( ctx, chunk_size, req-&gt;create_response&lt;<span class="hljs-keyword"><span class="hljs-keyword">output_t</span></span>&gt;(), count); data-&gt;response_ .append_header(restinio::http_field::server, <span class="hljs-string"><span class="hljs-string">"RESTinio"</span></span>) .append_header_date_field() .append_header( restinio::http_field::content_type, <span class="hljs-string"><span class="hljs-string">"text/plain; charset=utf-8"</span></span>) .flush(); send_next_portion(data); }</code> </pre> <br><p>  El tipo de datos de <code>response_data</code> , que contiene todos los par√°metros relacionados con la solicitud, se ve as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">response_data</span></span></span><span class="hljs-class"> {</span></span> asio_ns::io_context &amp; io_ctx_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size_; <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter_; response_data( asio_ns::io_context &amp; io_ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size, <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter) : io_ctx_{io_ctx} , chunk_size_{chunk_size} , response_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response)} , counter_{counter} {} };</code> </pre> <br><p>  Cabe se√±alar aqu√≠ que una de las razones para la aparici√≥n de la estructura <code>response_data</code> es que un objeto de tipo <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> (es decir, este tipo est√° oculto detr√°s del alias corto <code>response_t</code> ) es un tipo movible, pero no un tipo copiable (por analog√≠as con <code>std::unique_ptr</code> ).  Por lo tanto, este objeto no solo puede capturarse en una funci√≥n lambda, que luego se envuelve en <code>std::function</code> .  Pero si coloca el objeto de respuesta en una instancia de <code>response_data</code> creada din√°micamente, el puntero inteligente a la instancia de <code>reponse_data</code> ya puede capturarse en funciones lambda sin problemas, y luego guarde este lambda en <code>std::function</code> . </p><br><h3 id="funkciya-send_next_portion">  Funci√≥n Send_next_portion </h3><br><p>  La funci√≥n <code>send_next_portion</code> llama cada vez que es necesario enviar la siguiente parte de la respuesta al cliente.  No sucede nada complicado, por lo que parece bastante simple y conciso: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_next_portion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;response_.append_chunk(make_buffer(data-&gt;chunk_size_)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1u</span></span> == data-&gt;counter_) { data-&gt;response_.flush(); data-&gt;response_.done(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data-&gt;counter_ -= <span class="hljs-number"><span class="hljs-number">1u</span></span>; data-&gt;response_.flush(make_done_handler(data)); } }</code> </pre> <br><p>  Es decir  enviar la siguiente parte  Y, si esta parte fue la √∫ltima, entonces completamos el procesamiento de la solicitud.  Y si no es lo √∫ltimo, se env√≠a un <code>flush</code> al m√©todo <code>flush</code> , que es creado, quiz√°s, por la funci√≥n m√°s compleja de este ejemplo. </p><br><h3 id="funkciya-make_done_handler">  Funci√≥n make_done_handler </h3><br><p>  La funci√≥n <code>make_done_handler</code> responsable de crear una lambda que se pasar√° a RESTinio como un notificador posterior a la escritura.  Este notificador debe verificar si la grabaci√≥n de la siguiente parte de la respuesta se ha completado con √©xito.  En caso afirmativo, debe averiguar si la siguiente parte debe enviarse de inmediato (es decir, hubo "frenos" en el z√≥calo y la tasa de env√≠o no puede mantenerse), o despu√©s de una pausa.  Si necesita una pausa, se proporciona a trav√©s de un temporizador de armado. </p><br><p>  En general, acciones simples, pero el c√≥digo produce lambda dentro de la lambda, lo que puede confundir a las personas que no est√°n acostumbradas al C ++ "moderno".  Que no es tan pocos a√±os para ser llamado moderno;) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> next_timepoint = steady_clock::now() + <span class="hljs-number"><span class="hljs-number">1</span></span>s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(now &lt; next_timepoint) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;asio_ns::steady_timer&gt;(data-&gt;io_ctx_); timer-&gt;expires_after(next_timepoint - now); timer-&gt;async_wait([timer, data](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) send_next_portion(data); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data-&gt;io_ctx_.post([data] { send_next_portion(data); }); } }; }</code> </pre> <br><p>  En mi opini√≥n, la principal dificultad en este c√≥digo proviene de las peculiaridades de la creaci√≥n y el pelot√≥n de temporizadores en Asio.  En mi opini√≥n, resulta de alguna manera demasiado detallado.  Pero realmente hay, eso es.  Pero no necesita atraer bibliotecas adicionales. </p><br><h2 id="podklyuchenie-express-like-routera">  Conexi√≥n de un enrutador tipo express </h2><br><p>  <code>send_next_portion</code> , <code>send_next_portion</code> y <code>make_done_handler</code> muestran arriba en <code>send_next_portion</code> conformaron la primera versi√≥n de mi servidor de prueba, escrita literalmente en 15 o 20 minutos. </p><br><p>  Pero despu√©s de un par de d√≠as de usar este servidor de prueba, result√≥ que hab√≠a un serio inconveniente: siempre devolv√≠a el flujo de respuesta a la misma velocidad.  Compilado a una velocidad de 512 KB / s: proporciona todos los 512 KB / s.  Recompilado a una velocidad de 20KiB / seg: le dar√° a todos 20KiB / seg y nada m√°s.  Lo que era inconveniente, porque  se hizo necesario poder recibir respuestas de diferente "grosor". </p><br><p>  Entonces surgi√≥ la idea: ¬øqu√© pasa si la velocidad de retorno se solicita directamente en la URL?  Por ejemplo, hicieron una solicitud a <code>localhost:8080/</code> y recibieron una respuesta a una velocidad predeterminada.  Y si realiz√≥ una solicitud a <code>localhost:8080/128K</code> , entonces comenzaron a recibir una respuesta a una velocidad de 128KiB / seg. </p><br><p>  Luego, la idea fue a√∫n m√°s lejos: en la URL tambi√©n puede especificar el n√∫mero de partes individuales en la respuesta.  Es decir  solicitud de <code>localhost:8080/128K/3000</code> producir√° un flujo de 3000 partes a una velocidad de 128KiB / seg. </p><br><p>  No hay problema  RESTinio tiene la capacidad de utilizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enrutador de consultas creado bajo la influencia de ExpressJS</a> .  Como resultado, exist√≠a dicha funci√≥n para describir los controladores para las solicitudes HTTP entrantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asio_ns::io_context &amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>&gt;(); router-&gt;http_get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { request_processor(ctx, <span class="hljs-number"><span class="hljs-number">100u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size) { request_processor(ctx, chunk_size, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size &amp;&amp; <span class="hljs-number"><span class="hljs-number">0u</span></span> != count) { request_processor(ctx, chunk_size, count, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br><p>  Aqu√≠, los controladores de solicitudes HTTP GET se forman para tres tipos de URL: </p><br><ul><li>  de la forma <code>http://localhost/</code> ; </li><li>  de la forma <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/</code> ; </li><li>  de la forma <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/&lt;count&gt;/</code> </li></ul><br><p>  Donde la <code>speed</code> es un n√∫mero que define la velocidad, y <code>U</code> es un multiplicador opcional que indica en qu√© unidades se establece la velocidad.  Entonces <code>128</code> o <code>128b</code> significa una velocidad de 128 bytes por segundo.  Y <code>128k</code> son 128 kilobytes por segundo. </p><br><p>  Cada URL tiene su propia funci√≥n lambda, que comprende los par√°metros recibidos, si todo est√° bien, llama a la funci√≥n <code>request_processor</code> que se muestra arriba. </p><br><p>  La funci√≥n auxiliar <code>extract_chunk_size</code> siguiente: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> extract_chunk_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">route_params_t</span></span> &amp; params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> multiplier = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sv) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sv.empty() || <span class="hljs-string"><span class="hljs-string">"B"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"b"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"K"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"k"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"value"</span></span>]) * multiplier(params[<span class="hljs-string"><span class="hljs-string">"multiplier"</span></span>]); }</code> </pre> <br><p>  Aqu√≠, C ++ lambda se usa para emular funciones locales de otros lenguajes de programaci√≥n. </p><br><h2 id="funkciya-main">  Funci√≥n principal </h2><br><p>  Queda por ver c√≥mo funciona todo esto en la funci√≥n principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&lt;&gt;; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_single_thread_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">single_threaded_ostream_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>; }; asio_ns::io_context io_ctx; restinio::run( io_ctx, restinio::on_this_thread&lt;<span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span>&gt;() .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .write_http_response_timelimit(<span class="hljs-number"><span class="hljs-number">60</span></span>s) .request_handler(make_router(io_ctx))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  ¬øQu√© est√° pasando aqu√≠? </p><br><ol><li>  Como no necesito un enrutador de solicitudes normal (que no puede hacer nada y pone todo el trabajo sobre los hombros del programador), defino nuevas propiedades para mi servidor HTTP.  Para hacer esto, tomo las propiedades est√°ndar de un servidor HTTP de subproceso √∫nico (escriba <code>restinio::default_single_thread_traits_t</code> ) e indico que se utilizar√° una instancia de enrutador tipo express como controlador de solicitudes.  Al mismo tiempo, para controlar lo que est√° sucediendo en el interior, indico que el servidor HTTP utiliza un registrador real (de forma predeterminada, <code>null_logger_t</code> utiliza <code>null_logger_t</code> que no registra nada). </li><li>  Como necesito activar los temporizadores dentro de los notificadores de escritura posterior, necesito una instancia io_context con la que pueda trabajar.  Por lo tanto, lo creo yo mismo.  Esto me da la oportunidad de pasar un enlace a mi io_context en la funci√≥n <code>make_router</code> . </li><li>  Solo queda iniciar el servidor HTTP en una versi√≥n de subproceso √∫nico en el io_context que cre√© anteriormente.  La funci√≥n <code>restinio::run</code> devolver√° el control solo cuando el servidor HTTP termine su trabajo. </li></ol><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  El art√≠culo no mostraba el c√≥digo completo de mi servidor de prueba, solo sus puntos principales.  El c√≥digo completo, que es ligeramente m√°s grande debido a los tipos de letra adicionales y las funciones auxiliares, es algo m√°s aut√©ntico.  Puedes verlo <a href="">aqu√≠</a> .  Al momento de escribir, esto es 185 l√≠neas, incluyendo l√≠neas en blanco y comentarios.  Bueno, estas 185 l√≠neas est√°n escritas en un par de enfoques con una duraci√≥n total de apenas m√°s de una hora. </p><br><p>  Me gust√≥ este resultado y la tarea fue interesante.  En t√©rminos pr√°cticos, la herramienta auxiliar que necesitaba se obtuvo r√°pidamente.  Y en t√©rminos del desarrollo posterior de RESTinio, aparecieron algunos pensamientos. </p><br><p>  En general, si alguien m√°s no ha probado RESTinio, entonces lo invito a que lo intente.  El proyecto en s√≠ mismo vive en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  Puede hacer una pregunta o expresar sus sugerencias en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupo de Google</a> o aqu√≠ mismo en los comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462349/">https://habr.com/ru/post/462349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462333/index.html">Crear un chatbot de conversaci√≥n simple en python</a></li>
<li><a href="../462335/index.html">No leer, releer</a></li>
<li><a href="../462337/index.html">Estad√≠sticas del sitio y tu peque√±o repositorio</a></li>
<li><a href="../462339/index.html">¬øC√≥mo se relaciona la capacitaci√≥n manual con los est√°ndares internos de Amazon y c√≥mo ha impactado la visi√≥n del mundo de la compa√±√≠a?</a></li>
<li><a href="../462347/index.html">Los primeros diez d√≠as en el camino de un b√∫ho a un madrugador: sue√±o, dieta, dieta y ejercicio</a></li>
<li><a href="../462353/index.html">Preguntas frecuentes sobre la seguridad del protocolo LoRaWAN</a></li>
<li><a href="../462355/index.html">Programaci√≥n asincr√≥nica de JavaScript (devoluci√≥n de llamada, promesa, RxJs)</a></li>
<li><a href="../462357/index.html">Primer prototipo: Unikernels como etapa en la evoluci√≥n de Linux</a></li>
<li><a href="../462359/index.html">Dat: qu√© protocolo es y qui√©n lo usa</a></li>
<li><a href="../462365/index.html">Limitaciones de aprendizaje autom√°tico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>