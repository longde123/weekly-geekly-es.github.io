<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüöí ‚ô£Ô∏è ü¶Ñ Impl√©mentation PPPOS sur stm32f4-discovery ‚öõÔ∏è ü¶î ‚§¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une fois, avant moi, il y avait une t√¢che pour fournir un acc√®s √† Internet sur le STM32 n'ayant pour cela qu'un port COM. Pour r√©soudre ce probl√®me, j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation PPPOS sur stm32f4-discovery</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419037/">  Une fois, avant moi, il y avait une t√¢che pour fournir un acc√®s √† Internet sur le STM32 n'ayant pour cela qu'un port COM.  Pour r√©soudre ce probl√®me, j'avais besoin de PPP ou, pour √™tre pr√©cis, PPPoS (Point-to-Point Protocol over Serial - l'un des moyens de mettre en ≈ìuvre PPP, il est utilis√© lors de la connexion via le port COM). <br><br>  Dans le processus de r√©solution de la t√¢che qui m'√©tait confi√©e, j'ai rencontr√© des difficult√©s, dont l'une, √† mon avis, √©tait une couverture insuffisante des probl√®mes li√©s aux PPPoS sur Internet.  Avec ce poste, je vais essayer de combler l'√©cart d√©sign√©, autant que mes modestes connaissances le permettront. <br><br>  Cet article explique comment cr√©er un projet pour System Workbench pour STM32 √† partir de z√©ro.  Affiche un exemple de travail avec UART.  Il existe des exemples de code pour impl√©menter PPP.  Et bien s√ªr, un exemple d'envoi d'un message √† un ordinateur voisin. <br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  PPP (Point-to-Point Protocol) est un protocole de liaison de donn√©es √† deux points du mod√®le de r√©seau OSI.  Il est g√©n√©ralement utilis√© pour √©tablir une communication directe entre deux n≈ìuds de r√©seau et il peut fournir une authentification de connexion, un chiffrement et une compression de donn√©es.  Utilis√© sur de nombreux types de r√©seaux physiques: c√¢ble null modem, ligne t√©l√©phonique, cellulaire, etc. <br><br>  Il existe souvent des sous-esp√®ces du protocole PPP, telles que le protocole point √† point sur Ethernet (PPPoE), utilis√©es pour se connecter via Ethernet, et parfois via DSL;  et le protocole point √† point sur ATM (PPPoA), qui est utilis√© pour la connexion via ATM Adaptation Layer 5 (AAL5), qui est la principale alternative PPPoE pour DSL. <br><br>  PPP est une famille de protocoles: Link Control Protocol (LCP), Network Control Protocol (NCP), Authentication Protocols (PAP, CHAP), Multichannel PPP (MLPPP). <br><br>  <i>De Wikip√©dia</i> . <br><br><h3>  La pr√©paration </h3><br>  Pour r√©soudre le probl√®me dont nous avons besoin: <br><br><h4>  Fer: </h4><br><ol><li>  Carte de d√©bogage stm32f4_discovery: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u1/0k/6-/u10k6-una1bkmaphl4wlazibaca.jpeg"></div></li><li>  Adaptateur USB vers miniUSB pour connecter la carte √† un ordinateur. </li><li>  Deux adaptateurs USBtoUART FT232: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/uk/mo/uhukmolq4_t-pckn8h2rjofspnu.png"></div></li><li>  Deux rallonges USB sont √©galement utiles, pas n√©cessairement, mais simplement pratiques. </li></ol><br><h4>  Doux: </h4><br><ol><li>  Machine virtuelle VirtualBox.  Vous pouvez le t√©l√©charger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Nous t√©l√©chargeons et installons √©galement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pack d'extension</a> pour VirtualBox. </li><li>  Deux disques d'installation avec les syst√®mes d'exploitation Windows et Linux.  Nous prenons Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Apr√®s avoir install√© le syst√®me d'exploitation, vous devrez installer des modules compl√©mentaires pour le syst√®me d'exploitation invit√©.  Pour la t√¢che que nous avons suffisamment de syst√®mes 32x, vous ne pouvez pas tromper avec l'inclusion de la virtualisation. </li><li>  Pour Windows, nous avons besoin d'un programme qui peut accepter les demandes et y r√©pondre via TCP / IP, et un programme terminal pour travailler avec un port COM.  T√©l√©chargez PacketSender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (cliquez sur "Non merci, laissez-moi simplement t√©l√©charger."), Le terminal est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  De plus, nous avons besoin de STM32CubeMX pour la configuration initiale du projet.  T√©l√©chargez depuis st.com (apr√®s l'enregistrement, le lien sera envoy√© par e-mail). </li><li>  Nous avons mis System Workbench pour STM32 sur le syst√®me d'exploitation principal.  T√©l√©chargez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (inscription requise). </li></ol><br><h3>  √âtape 1. Cr√©ation d'un projet </h3><br>  Tout d'abord, ouvrez STM32CubeMX et cr√©ez un nouveau projet pour notre carte de d√©couverte stm32f4.  Activez RCC, Ethernet (ETH), SYS, USART2, USART3, puis activez FREERTOS et LWIP. <br><br><img src="https://habrastorage.org/webt/vr/jk/ve/vrjkveavft5ry-oasa7h2e07rwe.png"><br><img src="https://habrastorage.org/webt/9c/v2/rv/9cv2rv-_8yf5w67mr7bw7ynp1vk.png"><br><br>  Pour les diagnostics, nous avons besoin de LED sur la carte.  Pour cela, configurez les jambes de PD12-PD15 en tant que GPIO_Output. <br><br><img src="https://habrastorage.org/webt/-s/bb/lk/-sbblkybmbdz1wrftiow38tq4eg.png"><br><br>  Dans l'onglet Configuration de l'horloge, d√©finissez la fr√©quence, comme dans l'image ci-dessous. <br><br><img src="https://habrastorage.org/webt/sd/cc/qy/sdccqyreetba7g_m8yq_gypc-ge.png"><br><br>  Ensuite, dans l'onglet Configuration, configurez les ports USART.  Nous travaillerons avec eux en mode DMA.  Nous avons deux ports USART, un que nous utiliserons pour transmettre et recevoir des donn√©es via PPP, le second pour la journalisation.  Pour les faire fonctionner, nous devons configurer DMA sur RX et TX pour les deux ports.  Pour toutes les jambes de r√©glage DMA, d√©finissez Moyen sur priorit√©.  Pour USART2 leg RX, r√©glez le mode sur "Circular".  Les autres param√®tres sont laiss√©s par d√©faut. <br><br><img src="https://habrastorage.org/webt/96/s8/9u/96s89uloxfrdtxd0scqvcyb-zng.png"><br><br>  Vous devrez √©galement activer l'interruption globale pour les deux ports dans l'onglet ¬´Param√®tres NVIC¬ª. <br><br>  Ceci termine la configuration initiale du projet dans STM32CubeMX.  Nous enregistrons le fichier de projet et faisons la g√©n√©ration de code pour System Workbench pour STM32. <br><br><img src="https://habrastorage.org/webt/ss/_d/8l/ss_d8lzdxneoj5mjasvmyhhhxiu.png"><br><br><h4>  Impl√©mentation </h4><br>  V√©rifions maintenant que le code t√©l√©charg√© compile et fonctionne.  Pour ce faire, dans le fichier main.c de la fonction "StartDefaultTask", nous rempla√ßons le corps de la boucle infinie for (;;) par le code LED on et off. <br><br>  Cela devrait √™tre comme ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* StartDefaultTask function */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> MX_LWIP_Init(); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Infinite loop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 5 */</span></span> }</code> </pre> <br>  Nous compilons le firmware et regardons.  Les quatre voyants doivent clignoter sur la carte. <br><br><h3>  √âtape 2. Travailler avec USART </h3><br>  Notre prochaine t√¢che est de v√©rifier le bon fonctionnement de notre USART. <br><br>  La premi√®re chose que nous devons faire est de connecter notre FT232 √† la d√©couverte.  Pour ce faire, regardez quelles jambes les interfaces USART sont divorc√©es.  Je l'ai PD6 et PD5 pour USART2_RX et USART2_TX respectivement. <br><br><img src="https://habrastorage.org/webt/qj/yh/yo/qjyhyoohdofxtqedphuhzq7qcac.png"><br><br>  Ainsi que PD9 et PD8 pour USART3_RX et USART3_TX, respectivement. <br><br><img src="https://habrastorage.org/webt/37/bf/om/37bfomzqqcapediljrf14flpuiu.png"><br><br>  De plus, nous avons besoin d'un pied GND. <br><br>  Nous trouvons ces broches sur la carte et les connectons aux broches FT232, tandis que la broche GND sur la carte peut √™tre quelconque, la broche RX sur la carte doit √™tre connect√©e √† la broche TX sur le FT232, et la broche TX sur la carte doit √™tre connect√©e √† la broche RX sur le FT232.  Les conclusions restantes ne sont pas utilis√©es. <br><br>  Il reste √† connecter notre FT232 aux ports USB de l'ordinateur, ainsi qu'√† connecter la carte de d√©couverte elle-m√™me via le connecteur miniUSB √† l'ordinateur (√† ne pas confondre avec microUSB). <br><br>  Apr√®s avoir connect√© FT232, le syst√®me d'exploitation principal installera les pilotes pour eux, apr√®s quoi ces p√©riph√©riques devront √™tre transmis √† l'invit√© Windows sur la machine virtuelle. <br><br>  Nous ajoutons maintenant le code de programme n√©cessaire au fonctionnement de notre USART.  Pour ce faire, nous ajouterons quatre fichiers: usart.h, usart.c, logger.h, logger.c. <br><br>  Contenu du fichier: <br><br>  <b>fichier usart.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> void usart_Open(void); bool usart_Send(char* bArray, int size_bArray); uint16_t usart_Recv(char* bArray, uint16_t maxLength); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _USART_ */</span></span></span></span></code> </pre><br>  <b>fichier usart.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmsis_os.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Q_USART2_SIZE 200 xQueueHandle g_qUsart; osThreadId g_usart_rxTaskHandle; extern UART_HandleTypeDef huart2; void usart_rxTask(void); uint8_t bGet[Q_USART2_SIZE] = {0}; uint16_t g_tail = 0; void usart_Open(void) { g_qUsart = xQueueCreate( Q_USART2_SIZE, sizeof( unsigned char ) ); osThreadDef(usart_rxTask_NAME, usart_rxTask, osPriorityNormal, 0, Q_USART2_SIZE/4+128); g_usart_rxTaskHandle = osThreadCreate(osThread(usart_rxTask_NAME), NULL); HAL_UART_Receive_DMA(&amp;huart2, bGet, Q_USART2_SIZE); } void usart_rxTask(void) { for(;;) { uint16_t length = Q_USART2_SIZE - huart2.hdmarx-&gt;Instance-&gt;NDTR; while(length - g_tail) { uint8_t tmp = bGet[g_tail]; xQueueSendToBack( g_qUsart, &amp;tmp, 100 ); g_tail++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (g_tail == Q_USART2_SIZE) g_tail = 0; } } } bool usart_Send(char* bArray, int size_bArray) { HAL_StatusTypeDef status; status = HAL_UART_Transmit_DMA(&amp;huart2, bArray, size_bArray); while (HAL_UART_GetState(&amp;huart2) != HAL_UART_STATE_READY) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (HAL_UART_GetState(&amp;huart2) == HAL_UART_STATE_BUSY_RX) break; osDelay(1); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (status == HAL_OK) return true; return false; } uint16_t usart_Recv(char* bArray, uint16_t maxLength) { uint8_t tmp = 0; uint16_t length = 0; while(uxQueueMessagesWaiting(g_qUsart)) { xQueueReceive( g_qUsart, &amp;tmp, 100 ); bArray[length] = tmp; length++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length &gt;= maxLength) break; } return length; }</span></span></code> </pre><br>  <b>fichier logger.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _LOGGER_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _LOGGER_ void logger(const char *format, ...); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _LOGGER_ */</span></span></span></span></code> </pre><br>  <b>fichier logger.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdarg.h&gt; extern UART_HandleTypeDef huart3; #define MAX_STRING_SIZE 1024 HAL_StatusTypeDef logger_Send(char* bArray, uint32_t size_bArray) { HAL_StatusTypeDef status; for(int i=0;i&lt;5;i++) { status = HAL_UART_Transmit_DMA(&amp;huart3, bArray, size_bArray); if (status == HAL_OK) break; osDelay(2); } while (HAL_UART_GetState(&amp;huart3) != HAL_UART_STATE_READY) { osDelay(1); } return status; } void logger(const char *format, ...) { char buffer[MAX_STRING_SIZE]; va_list args; va_start (args, format); vsprintf(buffer, format, args); va_end(args); buffer[MAX_STRING_SIZE-1]=0; logger_Send(buffer, strlen(buffer)); }</span></span></span></span></code> </pre><br>  Nous avons besoin de usart pour transmettre et recevoir des donn√©es sur usart2.  Ce sera notre interface principale pour communiquer avec un serveur PPP. <br><br>  Nous avons besoin de Logger pour impl√©menter la journalisation en envoyant des messages au terminal.  La fonction void usart_Open (void) forme une file d'attente et d√©marre la t√¢che de maintenance de cette file d'attente.  Cette fonction doit √™tre termin√©e avant d'utiliser USART.  Alors tout est simple, la fonction bool usart_Send (char * bArray, int size_bArray) envoie des donn√©es au port, et <br>  uint16_t usart_Recv (char * bArray, uint16_t maxLength) les extrait de la file d'attente dans laquelle la fonction void usart_rxTask (void) les a aimablement ajout√©s. <br><br>  Pour l'enregistreur, c'est encore plus simple; il n'est pas n√©cessaire d'obtenir des donn√©es, donc ni la file d'attente ni la t√¢che de maintenance de file d'attente ne sont n√©cessaires. <br><br>  Au d√©but du fichier <b>main.h</b> , <b>vous</b> devez ajouter plusieurs d√©finitions d√©crivant le type bool, qui n'est pas disponible en C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> true 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> false 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span></span></code> </pre><br>  Il est maintenant temps de v√©rifier la fonctionnalit√© du code r√©sultant.  Pour ce faire, dans le fichier <b>main.c</b> , changez le code de la t√¢che d√©j√† connue "StartDefaultTask" <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_MESSAGE_LENGTH 100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> MX_LWIP_Init(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span></span><span class="hljs-meta"> usart_Open(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Infinite loop */</span></span></span><span class="hljs-meta"> uint8_t send[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Send message\r\n"</span></span></span><span class="hljs-meta">; uint8_t recv[MAX_MESSAGE_LENGTH] = {0}; uint16_t recvLength = 0; for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usart_Send(send, sizeof(send)-1)) logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SEND - %s"</span></span></span><span class="hljs-meta">, send); recvLength = usart_Recv(recv, MAX_MESSAGE_LENGTH-1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (recvLength) { recv[recvLength] = 0; logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RECV - %s\r\n"</span></span></span><span class="hljs-meta">, recv); } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 5 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  De plus, nous devons donner plus de m√©moire √† la pile de notre t√¢che.  Pour ce faire, dans l'appel √† la fonction osThreadDef (), le fichier main.c, vous devez corriger 128 par 128 * 10 pour obtenir ceci: <br><br><pre> <code class="hljs lisp">osThreadDef(<span class="hljs-name"><span class="hljs-name">defaultTask</span></span>, StartDefaultTask, osPriorityNormal, <span class="hljs-number"><span class="hljs-number">0</span></span>, &lt;b&gt;128*10&lt;/b&gt;)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Nous compilons et flashons.  Les LED clignotent de la m√™me mani√®re que dans la t√¢che pr√©c√©dente. <br><br>  Pour voir le r√©sultat de notre travail, vous devez ex√©cuter le programme Terminal dans notre machine virtuelle.  Une instance du programme pour le port de journalisation, la seconde pour le port principal.  Regardez dans le gestionnaire de p√©riph√©riques les num√©ros de port attribu√©s √† votre FT232.  Si plus de 10 num√©ros ont √©t√© attribu√©s, r√©affectez-les. <br><br>  Lorsque vous d√©marrez la deuxi√®me instance du programme, une erreur peut se produire, fermez la fen√™tre avec l'erreur et continuez √† travailler avec le programme. <br><br>  Pour les deux ports, nous √©tablissons une connexion √† 115200 bauds, bits de donn√©es - 8, parit√© - aucun, bits d'arr√™t - 1, √©tablissement de liaison - aucun. <br><br>  Si vous avez tout fait correctement, alors dans la fen√™tre du terminal pour usart2 le message ¬´Envoyer un message¬ª sera transmis.  Le m√™me message sera dupliqu√© dans la fen√™tre du terminal pour l'enregistreur uniquement avec le pr√©fixe "SEND -" <br><br>  Si dans la fen√™tre du terminal pour usart2 vous tapez du texte dans le champ "Envoyer" et cliquez sur le bouton correspondant √† droite de ce champ, alors dans la fen√™tre de l'enregistreur vous verrez le m√™me message avec le pr√©fixe "RECV -" <br><br>  Dans l'image ci-dessous: √† gauche est l'enregistreur, √† droite est usart2. <br><br><img src="https://habrastorage.org/webt/k5/v6/hc/k5v6hcxebj6hfdgbitfwyzs1ffw.png"><br><br><h3>  √âtape 3. Premiers pas avec PPP </h3><br>  Dans le cadre de cette t√¢che, nous √©tablirons une connexion PPP.  Tout d'abord, activez l'utilisation de PPP, changez la valeur du PPP_SUPPORT define dans le fichier ppp_opts.h √† 1. Ensuite, nous red√©finissons les d√©finitions n√©cessaires dans le fichier lwipopts.h, <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEMP_NUM_SYS_TIMEOUT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_IP 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_TCP 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 1 */</span></span></span></span></code> </pre><br>  Dans le m√™me temps, les anciennes d√©finitions doivent √™tre mises en commentaire. <br><br>  Maintenant, nous modifions le fichier lwip.c, ins√©rons le code suivant dans le bloc ¬´/ * USER CODE BEGIN 0 * /¬ª: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pppos.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp.h"</span></span></span><span class="hljs-meta"> static ppp_pcb *ppp; struct netif pppos_netif; void PppGetTask(void const * argument) { uint8_t recv[2048]; uint16_t length = 0; for(;;) { length=usart_Recv(recv, 2048); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length) { pppos_input(ppp, recv, length); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"read - PppGetTask() len = %d\n"</span></span></span><span class="hljs-meta">, length); } osDelay(10); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ip4_addr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx) { struct netif *pppif = ppp_netif(pcb); LWIP_UNUSED_ARG(ctx); switch(err_code) { case PPPERR_NONE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No error. */</span></span></span><span class="hljs-meta"> { logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_NONE\n\r"</span></span></span><span class="hljs-meta">); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" our_ip4addr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_addr(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" his_ipaddr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_gw(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" netmask = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_netmask(pppif))); } break; case PPPERR_PARAM: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid parameter. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PARAM\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_OPEN: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to open PPP session. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_OPEN\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_DEVICE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid I/O device for PPP. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_DEVICE\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_ALLOC: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to allocate resources. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_ALLOC\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_USER: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* User interrupt. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_USER\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection lost. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_AUTHFAIL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed authentication challenge. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_AUTHFAIL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PROTOCOL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed to meet protocol. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PROTOCOL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PEERDEAD: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PEERDEAD\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_IDLETIMEOUT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Idle Timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_IDLETIMEOUT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECTTIME: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PPPERR_CONNECTTIME. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECTTIME\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_LOOPBACK: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_LOOPBACK\n"</span></span></span><span class="hljs-meta">); break; default: logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: unknown errCode %d\n"</span></span></span><span class="hljs-meta">, err_code); break; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Callback used by ppp connection static u32_t ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx) { LWIP_UNUSED_ARG(pcb); LWIP_UNUSED_ARG(ctx); if (len &gt; 0) { if (!usart_Send(data, len)) return 0x05; } logger("write - ppp_output_cb() len = %d\n", len); return len; } void pppConnect(void) { ppp = pppos_create(&amp;pppos_netif, ppp_output_cb, ppp_link_status_cb, NULL); ppp_set_default(ppp); osThreadId PppGetTaskHandle; osThreadDef(PPP_GET_TASK_NAME, PppGetTask, osPriorityNormal, 0, 128*10); PppGetTaskHandle = osThreadCreate(osThread(PPP_GET_TASK_NAME), NULL); err_t err = ppp_connect(ppp,0); if (err == ERR_ALREADY) { logger("Connected successfully"); } for(int i=0;i&lt;40;i++) { osDelay(500); if (ppp-&gt;phase &gt;= PPP_PHASE_RUNNING) break; } } /* USER CODE END 0 */</span></span></span></span></code> </pre><br>  Ensuite, dans la fonction MX_LWIP_Init (), dans le bloc ¬´/ * USER CODE BEGIN 3 * /¬ª nous ajoutons un appel √† la fonction pppConnect (). <br><br>  De plus, vous devez augmenter la taille du segment de m√©moire, pour cela, dans le fichier FreeRTOSConfig.h, vous devez mettre en commentaire la configuration configTOTAL_HEAP_SIZE et, √† la fin du fichier, dans le bloc / * USER CODE BEGIN Defines * /, d√©clarez-le avec une nouvelle valeur. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Defines */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configTOTAL_HEAP_SIZE ((size_t)1024*30) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Defines */</span></span></span></span></code> </pre><br>  En outre, dans le fichier usart.c, remplacez la valeur de la d√©finition Q_USART2_SIZE par 2048. <br><br>  La configuration de la connexion commence par la fonction MX_LWIP_Init (); elle a √©t√© cr√©√©e automatiquement; nous venons d'y ajouter un appel √† la fonction pppConnect ().  Dans cette fonction, les t√¢ches desservant la connexion PPPOS sont lanc√©es.  Les fonctions pppos_create () doivent recevoir les adresses des fonctions qui serviront √† l'envoi de messages et √† la sortie d'informations sur la modification de l'√©tat de la connexion.  Pour nous, ce sont les fonctions ppp_output_cb () et ppp_link_status_cb (), respectivement.  De plus, la fonction pppConnect () d√©marre la t√¢che de maintenance des messages re√ßus.  √Ä la fin de son op√©ration, la fonction pppConnect () attendra qu'une connexion au serveur soit √©tablie, puis terminera son op√©ration. <br><br>  Le travail avec le r√©seau sera effectu√© √† un niveau sup√©rieur, d√®s que LWIP d√©cidera qu'il est n√©cessaire d'envoyer un message au r√©seau, la fonction ppp_output_cb () sera appel√©e automatiquement.  La r√©ponse du r√©seau sera re√ßue par la fonction PppGetTask (), dans le cadre de la t√¢che de service des messages entrants, et transf√©r√©e dans les entrailles de LWIP.  Si l'√©tat de la connexion change, la fonction ppp_link_status_cb () sera appel√©e automatiquement. <br><br>  Enfin, nous allons modifier la t√¢che StartDefaultTask.  Maintenant, cela devrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> <span class="hljs-comment"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); } /* USER CODE END 5 */ }</span></span></code> </pre><br>  Termin√©, vous pouvez compiler et flasher. <br><br>  √Ä ce stade, vous devez d√©marrer le serveur PPP.  Pour ce faire, vous devez d'abord d√©ployer une machine virtuelle avec Linux.  J'ai utilis√© Ubuntu 16.04 x32.  Apr√®s avoir install√© le syst√®me d'exploitation, vous devez configurer l'utilisation du port COM. <br><br>  Dans cette partie, nous n'avons pas besoin d'une machine virtuelle avec Windows, nous pouvons la d√©sactiver en toute s√©curit√©.  Nous connectons les deux FT232 sous Linux. <br><br>  Sous Linux, avant de commencer √† travailler avec un port COM, vous devez autoriser l'utilisateur √† l'utiliser.  Pour ce faire, ex√©cutez la commande suivante: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> addgroup USERNAME dialout</code> </pre> <br>  o√π USERNAME est le nom de l'utilisateur actuel. <br><br>  Pour voir les ports disponibles dans le syst√®me COM, vous devez ex√©cuter la commande: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> tty</code> </pre> <br><img src="https://habrastorage.org/webt/zc/h4/mp/zch4mpfwyybln76dl1jnhpxjt0s.png"><br><br>  Nous voyons qu'il y a deux ports ttyUSB dans le syst√®me.  Nous ne pouvons pas dire imm√©diatement lequel est enregistreur et lequel est usart2.  Il vous suffit de les v√©rifier √† tour de r√¥le. <br><br>  Tout d'abord, ex√©cutez les commandes pour lire √† partir d'un port: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB0 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB0</code> </pre> <br>  puis d'un autre: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB1</code> </pre> <br>  O√π nous voyons une telle image, c'est l'enregistreur. <br><br><img src="https://habrastorage.org/webt/u0/cu/zc/u0cuzcnbhzppwdhpibm2o6zelpk.png"><br><br>  Vous pouvez quitter cette fen√™tre, cela ne nous d√©rangera pas. <br><br>  Ensuite, vous devez autoriser les paquets envoy√©s depuis notre carte √† quitter les limites de leur sous-r√©seau.  Pour ce faire, configurez iptables.  Nous effectuons les actions suivantes: <br><br>  1. Ouvrez une nouvelle fen√™tre de console <br>  2. Vous devez trouver votre nom d'IP et d'interface r√©seau (ex√©cutez la commande <b>ifconfig</b> ) <br><br><img src="https://habrastorage.org/webt/jy/d4/9s/jyd49satpc3erdlzeddi44gwcy4.png"><br><br>  3. Ex√©cutez les commandes de configuration nat <br><br><pre> <code class="hljs powershell">sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_forward &gt; /dev/null sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_dynaddr &gt; /dev/null sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> FORWARD sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-A</span></span> POSTROUTING <span class="hljs-literal"><span class="hljs-literal">-o</span></span> enp0s3 <span class="hljs-literal"><span class="hljs-literal">-j</span></span> SNAT -<span class="hljs-literal"><span class="hljs-literal">-to</span></span><span class="hljs-literal"><span class="hljs-literal">-source</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">10.196</span></span> sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-L</span></span></code> </pre> <br>  o√π enp0s3 est le nom de l'interface r√©seau <br>  192.168.10.196 - votre adresse IP <br>  / proc / sys / net / ipv4 / - chemin vers le fichier correspondant. <br><br>  Ces commandes peuvent √™tre r√©√©crites dans un fichier de commandes et ex√©cut√©es √† chaque fois avant de d√©marrer le serveur PPP.  Vous pouvez l'ajouter √† l'ex√©cution automatique, mais je ne l'ai pas fait. <br><br>  Maintenant que nous sommes pr√™ts √† d√©marrer le serveur, il ne reste plus qu'√† cr√©er un fichier de param√®tres.  Je l'ai appel√© " <b>pppd.conf</b> ", je sugg√®re d'utiliser les param√®tres suivants: <br><br><pre> <code class="hljs pgsql">nodetach noauth passive <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> lcp-echo-<span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> lcp-echo-failure <span class="hljs-number"><span class="hljs-number">1</span></span> cdtrcts</code> </pre> <br>  Nous r√©√©crivons les param√®tres dans un fichier et vous pouvez ensuite d√©marrer le serveur.  Cela se fait avec la commande <b>sudo pppd file ./pppd.conf</b> <br><br>  Le serveur PPPD doit √™tre d√©marr√© avant le d√©but de la d√©couverte, donc apr√®s le d√©marrage de PPPD, vous devez cliquer sur le bouton "R√©initialiser" situ√© sur la carte. <br><br>  Si vous avez tout fait correctement, vous verrez l'image suivante: <br><br><img src="https://habrastorage.org/webt/kv/-p/lj/kv-pljob3duk3bigzj3iazcsasa.png"><br><br>  Ex√©cution de pppd √† gauche, enregistreur √† droite. <br><br><h3>  √âtape 4. Nous envoyons un sac </h3><br>  √Ä ce stade, nous avons besoin des deux machines virtuelles.  Linux pour pppd et Windows pour recevoir le package.  Pour simplifier la t√¢che, il est n√©cessaire que les deux machines soient sur le m√™me sous-r√©seau, la solution id√©ale serait de sp√©cifier une connexion de pont r√©seau pour les deux machines dans les param√®tres r√©seau de VirtualBox et de d√©sactiver le pare-feu dans Windows. <br><br>  Nous d√©marrons les machines virtuelles et configurons la connexion ppp de la carte de d√©couverte avec pppd.  Sous Windows, nous d√©couvrons l'adresse IP de la machine (commande ipconfig), je l'ai obtenue 192.168.10.97. <br><br>  Lancez Packet Sender et configurez-le comme suit: <br><br><img src="https://habrastorage.org/webt/k8/zt/uv/k8ztuv4eccjueyvlk8gigjbmkj0.png"><br><br>  Maintenant, modifiez √† nouveau la t√¢che StartDefaultTask dans le fichier main.c. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sockets.h"</span></span></span><span class="hljs-meta"> typedef uint32_t SOCKET; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ uint8_t sendStr[]="Test message TCP/IP."; uint8_t resvStr[100]={0}; int resvLength = 0; struct sockaddr_in sockAddr; sockAddr.sin_family = AF_INET; sockAddr.sin_port = htons( 6565 ); uint32_t addr = inet_addr("192.168.10.97"); sockAddr.sin_addr.s_addr = addr; SOCKET socket = NULL; int nError = 0; /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); socket = socket( AF_INET, SOCK_STREAM, 0 ); nError = connect( socket, (struct sockaddr*)&amp;sockAddr, sizeof(sockAddr) ); if ( nError == 0 ) { nError = send( socket, sendStr, sizeof(sendStr)-1, 0 ); if ( nError &lt; 0 ) logger("SEND ERROR %d\n", nError); else { logger("SEND - %s\n", sendStr); resvLength = 0; while(resvLength &lt; 1) resvLength = lwip_recv( socket, resvStr, sizeof(resvStr), MSG_WAITALL); resvStr[resvLength]=0; logger("GET - %s\n", resvStr); } lwip_close(socket); } else logger("CONNECT ERROR %d\n", nError); } /* USER CODE END 5 */ }</span></span></span></span></code> </pre><br>  Comme valeur de la variable addr, nous utilisons l'adresse de la machine Windows, le num√©ro de port 6565. <br>  Message envoy√© "Message de test TCP / IP.", R√©ponse "Le message est re√ßu." <br><br>  Ici, vous pouvez voir que les fonctions PPP ne sont pas directement utilis√©es pour envoyer et recevoir des messages.  Tous les travaux se d√©roulent √† un niveau sup√©rieur et nos fonctions sont appel√©es automatiquement. <br><br>  Nous compilons et flashons. <br><br>  Le r√©sultat de la connexion √† pppd est visible sur une machine Linux: <br><br><img src="https://habrastorage.org/webt/il/og/h6/ilogh6wuak7zym8unedcnddcjr4.png"><br><br>  Les demandes re√ßues et les r√©ponses envoy√©es sont visibles dans le programme Packet Sender sur une machine Windows: <br><br><img src="https://habrastorage.org/webt/30/yh/4m/30yh4m_l52nvlkdixrv9zmivehc.png"><br><br>  Eh bien, c'est tout, le paquet que nous avons envoy√© √† partir de la carte de d√©couverte est all√© au port COM, est arriv√© au serveur pppd, a √©t√© envoy√© au port Windows 6565 de la machine, il a √©t√© re√ßu avec succ√®s, en r√©ponse √† cela, un autre paquet a √©t√© envoy√© qui a r√©ussi cette dans la direction oppos√©e et a √©t√© adopt√© avec succ√®s au conseil.  Vous pouvez √©galement envoyer des messages √† n'importe quelle machine sur Internet. <br><br>  ‚Üí Le code complet du projet peut √™tre t√©l√©charg√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419037/">https://habr.com/ru/post/fr419037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419025/index.html">@Pythonetc compilation, juillet 2018</a></li>
<li><a href="../fr419027/index.html">S√©curit√© de l'information des paiements bancaires sans esp√®ces. Partie 6 - Analyse de la criminalit√© bancaire</a></li>
<li><a href="../fr419029/index.html">Fortnite est devenu un ph√©nom√®ne social. Les parents recrutent de plus en plus des entra√Æneurs pour leurs enfants et jouent avec eux</a></li>
<li><a href="../fr419033/index.html">Une petite note sur le sujet de l'ex√©cution de vue.js dans le cluster kubernetes</a></li>
<li><a href="../fr419035/index.html">Livre ¬´Head First Agile. Gestion de projet flexible ‚Äù</a></li>
<li><a href="../fr419041/index.html">Les neuf r√¢teaux Elasticsearch sur lesquels j'ai march√©</a></li>
<li><a href="../fr419043/index.html">Le probl√®me insaisissable de synchronisation de trame</a></li>
<li><a href="../fr419047/index.html">Reddit pirat√©, fuite de base de donn√©es avec mots de passe et e-mail pour 2005-2007</a></li>
<li><a href="../fr419049/index.html">GeekBrains lance le marathon √©ducatif en ligne gratuit ¬´Find Yourself in Digital¬ª</a></li>
<li><a href="../fr419051/index.html">Comment Flant aide les d√©butants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>