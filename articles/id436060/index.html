<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤯 👩🏽‍🚀 🕵️ Solusi arsitektur untuk gim seluler. Bagian 3: Lihat di dorongan jet 🕎 🖐🏿 🤺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya, kami menjelaskan bagaimana model harus diatur dengan nyaman dan dengan kemampuan luas, sistem perintah seperti apa yang cocok...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solusi arsitektur untuk gim seluler. Bagian 3: Lihat di dorongan jet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436060/"><img src="https://habrastorage.org/webt/ix/84/lz/ix84lzlun0rnpohgx14wu7mzbp4.jpeg"><br><br>  Pada artikel sebelumnya, kami menjelaskan bagaimana model harus diatur dengan nyaman dan dengan kemampuan luas, sistem perintah seperti apa yang cocok untuknya, yang bertindak sebagai pengontrol, saatnya berbicara tentang huruf ketiga dari singkatan MVC alternatif kami. <br><br>  Sebenarnya, Assetstore memiliki perpustakaan UniRX yang sangat canggih dan siap pakai yang mengimplementasikan reaktivitas dan mengontrol inversi untuk persatuan.  Tetapi kita akan membicarakannya di akhir artikel, karena alat yang kuat, besar, dan sesuai dengan RX ini untuk kasus kita cukup berlebihan.  Untuk melakukan semua yang kami butuhkan sangat mungkin dilakukan tanpa menarik RX, dan jika Anda memilikinya, Anda dapat dengan mudah melakukan hal yang sama dengannya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi arsitektur untuk gim seluler.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Model</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi arsitektur untuk gim seluler.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Perintah dan antriannya</a> <br><a name="habracut"></a><br>  Ketika seseorang baru mulai menulis gim pertama, tampaknya logis baginya untuk memiliki fungsi yang akan menggambar seluruh bentuk, atau sebagian darinya, dan menariknya setiap kali ada perubahan penting.  Seiring berjalannya waktu, antarmuka tumbuh dalam ukuran, bentuk dan bagian cetakan menjadi seratus, kemudian dua ratus, dan ketika dompet mengubah keadaannya, seperempat dari mereka harus digambar ulang.  Dan kemudian manajer datang dan mengatakan bahwa "seperti dalam permainan itu" Anda perlu membuat titik merah kecil pada tombol jika ada bagian di dalam tombol di mana ada subbagian di mana tombol itu berada, dan sekarang Anda memiliki sumber daya yang cukup untuk melakukan sesuatu dengan mengkliknya itu penting.  Dan itu saja, berlayar ... <br><br>  Penyimpangan dari konsep menggambar berlangsung dalam beberapa tahap.  Pertama, masalah bidang tunggal diselesaikan.  Anda memiliki, misalnya, bidang dalam model, dan bidang teks di mana semua isinya harus ditampilkan.  Oke, kami memulai objek yang berlangganan pembaruan bidang ini, dan setiap pembaruan menambahkan hasil ke bidang teks.  Dalam kode tersebut, sesuatu seperti ini: <br><br><pre><code class="cpp hljs">var observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildControl(FCPlayerModel.ASSIGNED, Player); observable.onChange(i =&gt; Assigned.text = i.ToString())</code> </pre> <br>  Sekarang kita tidak perlu mengikuti redrawing, cukup buat desain ini, dan kemudian semua yang terjadi dalam model akan jatuh ke antarmuka.  Bagus, tapi rumit, itu mengandung banyak gerakan jelas yang tidak perlu bahwa seorang programmer harus menulis dengan tangannya 100.500 kali dan kadang-kadang membuat kesalahan.  Mari kita bungkus iklan ini dalam fungsi ekstensi yang akan menyembunyikan huruf tambahan di bawah tenda. <br><br><pre> <code class="cpp hljs">Player.Get(c, FCPlayerModel.ASSIGNED).Action(c, i =&gt; Assigned.text = i.ToString());</code> </pre> <br>  Jauh lebih baik, tapi bukan itu saja.  Menggeser bidang model ke dalam bidang teks adalah operasi yang sering dan tipikal sehingga kita akan membuat fungsi wrapper terpisah untuknya.  Sekarang ternyata cukup singkat dan baik, menurut saya. <br><br><pre> <code class="cpp hljs">Player.Get(c, FCPlayerModel.ASSIGNED).SetText(c, Assigned);</code> </pre> <br>  Di sini saya menunjukkan ide utama bahwa saya akan dibimbing oleh ketika membuat antarmuka untuk sisa hidup saya: "Jika seorang programmer harus melakukan sesuatu setidaknya dua kali, bungkus dengan fungsi khusus yang nyaman dan pendek." <br><br><h2>  Pengumpulan sampah </h2><br>  Efek samping dari rekayasa antarmuka reaktif adalah penciptaan banyak objek yang berlangganan sesuatu dan karenanya tidak akan meninggalkan memori tanpa tendangan khusus.  Bagi saya sendiri, pada zaman kuno, saya datang dengan cara yang tidak begitu indah, tetapi sederhana dan terjangkau.  Saat membuat formulir apa pun, daftar semua pengontrol dibuat yang dibuat sehubungan dengan formulir ini, untuk singkatnya, itu hanya disebut "c".  Semua fungsi pembungkus khusus menerima daftar ini sebagai parameter yang diperlukan pertama dan ketika DisconnectModel formulir, itu melewati daftar semua kontrol dan tanpa belas kasihan gelisah dengan kode dalam leluhur yang sama.  Tidak ada keindahan dan keanggunan, tetapi murah, dapat diandalkan dan relatif praktis.  Anda dapat memiliki keamanan yang lebih banyak jika, alih-alih lembar kontrol, Anda memerlukan IView untuk masuk dan memberikan ini ke semua tempat ini.  Pada dasarnya hal yang sama, lupa untuk mengisi hal yang sama tidak akan berhasil, tetapi lebih sulit untuk diretas.  Saya takut lupa, tetapi saya tidak terlalu takut bahwa seseorang akan dengan sengaja merusak sistem, karena orang yang pandai seperti itu harus diperangi dengan ikat pinggang dan metode non-perangkat lunak lainnya, jadi saya hanya membatasi diri untuk c. <br><br>  Pendekatan alternatif dapat diambil dari UniRX.  Setiap bungkus membuat objek baru yang memiliki tautan ke yang sebelumnya ia dengarkan.  Dan pada akhirnya, metode AddTo (komponen) dipanggil, yang mengaitkan seluruh rantai kontrol ke beberapa objek yang dapat dirusak.  Dalam contoh kita, kode tersebut akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">Player.Get(FCPlayerModel.ASSIGNED).SetText(Assigned).AddTo(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br>  Jika pemilik terakhir dari rantai ini memutuskan untuk dihancurkan, ia akan mengirim ke semua kontrol yang ditugaskan kepadanya perintah "bunuh diri tentang membuang jika tidak ada yang mendengarkan Anda kecuali saya".  Dan seluruh rantai dengan patuh dibersihkan.  Jadi tentu saja ini jauh lebih ringkas, tetapi dari sudut pandang saya ada satu kelemahan penting.  AddTo dapat secara tidak sengaja dilupakan dan tidak ada yang akan mengetahuinya sampai semuanya terlambat. <br><br>  Bahkan, Anda dapat menggunakan hack Unity yang kotor dan melakukannya tanpa kode tambahan di Tampilan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T AddTo&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T disposable, Component component) where T : IDisposable { var composite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeDisposable(disposable); Observable .EveryUpdate() .Where(_ =&gt; component == null) .Subscribe(_ =&gt; composite.Dispose()) .AddTo(composite); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> disposable; }</code> </pre> <br>  Seperti yang Anda ketahui, tautan ke Komponen Unicomponent atau GameObject di Unity adalah nol.  Tetapi Anda perlu memahami bahwa hakokostyl ini membuat pendengar yang diperbarui untuk setiap rantai kontrol yang dihancurkan, dan ini sudah agak sopan. <br><br><h2>  Antarmuka independen model </h2><br>  Cita-cita kami, yang, bagaimanapun, dapat kita capai dengan mudah, adalah situasi ketika kita dapat memuat GameState lengkap kapan saja, baik model yang diverifikasi server dan model data untuk UI, dan aplikasi akan berada dalam keadaan yang persis sama, sampai ke keadaan semua tombol.  Ada dua alasan untuk ini.  Yang pertama adalah bahwa beberapa programmer suka menyimpan di dalam pengontrol bentuk, atau bahkan dalam tampilan itu sendiri, mengutip fakta bahwa siklus hidup mereka persis sama dengan bentuk itu sendiri.  Yang kedua adalah bahwa bahkan jika semua data untuk formulir ada dalam modelnya, perintah untuk membuat dan mengisi formulir itu sendiri mengambil bentuk pemanggilan fungsi eksplisit, dengan beberapa parameter tambahan, misalnya, bidang mana dari daftar yang harus difokuskan. <br><br>  Anda tidak harus berurusan dengan ini jika Anda tidak benar-benar menginginkan kenyamanan debugging.  Tapi kami tidak seperti itu, kami ingin men-debug antarmuka semudah operasi dasar dengan model.  Untuk melakukan ini, fokus berikut.  Di bagian UI model, variabel diatur, misalnya. Utama, dan di dalamnya, sebagai bagian dari perintah, Anda meletakkan model formulir yang ingin Anda lihat.  Keadaan variabel ini dipantau oleh pengontrol khusus, jika sebuah model muncul dalam variabel ini, tergantung pada jenisnya, itu memunculkan formulir yang diinginkan, menempatkannya di tempat yang diperlukan, dan mengirimkannya panggilan ke ConnectModel (model).  Jika variabel dibebaskan dari model, pengontrol akan menghapus formulir dari kanvas dan menggunakannya.  Dengan demikian, tidak ada tindakan untuk memintas model terjadi, dan semua yang Anda lakukan dengan antarmuka terlihat jelas pada model ExportChanges.  Dan kemudian kita dibimbing oleh prinsip "semua yang telah dilakukan dua kali bungkus" dan menggunakan pengontrol yang sama persis di semua tingkat antarmuka.  Jika cetakan memiliki tempat untuk cetakan lain, maka model UI dibuat untuk itu, dan variabel dibuat dalam model cetakan induk.  Persis sama dengan daftar. <br><br>  Efek samping dari pendekatan ini adalah bahwa dua file ditambahkan ke formulir apa pun, satu dengan model data untuk formulir ini, dan yang lainnya, biasanya monobah yang berisi tautan ke elemen UI, yang, setelah menerima model dalam fungsi ConnectModel, akan membuat semua pengontrol reaktif untuk semua bidang model dan semua elemen UI.  Yah, itu bahkan lebih ringkas, sehingga juga nyaman untuk bekerja dengannya, mungkin itu tidak mungkin.  Jika memungkinkan, tulis di komentar. <br><br><h2>  Kontrol daftar </h2><br>  Situasi tipikal adalah ketika model memiliki daftar beberapa elemen.  Karena saya ingin semuanya dilakukan dengan sangat mudah, dan lebih disukai pada satu baris, saya juga ingin melakukan sesuatu untuk daftar yang mudah ditangani.  Satu baris mungkin, tetapi ternyata panjangnya tidak nyaman.  Secara empiris, ternyata hampir seluruh keragaman kasus hanya ditutupi oleh dua jenis kontrol.  Yang pertama memonitor keadaan koleksi dan memanggil tiga fungsi lambda, yang pertama dipanggil ketika beberapa elemen ditambahkan ke koleksi, yang kedua ketika elemen meninggalkan koleksi, dan akhirnya yang ketiga dipanggil ketika elemen koleksi mengubah urutan.  Jenis kontrol kedua yang paling umum memantau daftar, dan merupakan sumber langganan darinya - halaman dengan nomor tertentu.  Misalnya, ia mengikuti Daftar dengan panjang 102 elemen, dan itu sendiri mengembalikan Daftar 10 elemen, dari tanggal 20 hingga 29.  Dan peristiwa yang dihasilkan persis sama seolah-olah itu daftar itu sendiri. <br><br>  Tentu saja, mengikuti prinsip "membuat pembungkus untuk segala sesuatu yang dilakukan dua kali", sejumlah besar pembungkus nyaman muncul, misalnya, yang hanya menerima input Pabrik, membangun korespondensi antara jenis model dan Tampilan mereka, dan tautan ke Kanvas di mana Anda perlu menambahkan elemen.  Dan banyak yang serupa lainnya, hanya sekitar selusin pembungkus untuk kasus khas. <br><br><h2>  Kontrol yang lebih kompleks </h2><br>  Kadang-kadang muncul situasi yang berlebihan untuk diekspresikan melalui model, sebanyak mereka jelas.  Di sini, kontrol yang melakukan semacam operasi pada suatu nilai dapat datang ke penyelamatan, serta kontrol yang memantau kontrol lainnya.  Misalnya, situasi umum: tindakan memiliki harga, dan tombol hanya aktif jika ada lebih banyak uang di akun daripada harganya. <br><br><pre> <code class="cpp hljs">item.Get(c, FCUnitItem.COST).Join(c, Player.Get(c, MONEY)).Func(c, (cost, money) =&gt; cost &lt;= money).SetActive(c, BuyButton);</code> </pre> <br>  Bahkan, situasinya sangat khas sehingga sesuai dengan prinsip saya ada pembungkus yang sudah jadi untuk itu, tapi kemudian saya menunjukkan isinya. <br><br>  Kami mengambil barang yang akan dibeli, membuat objek yang berlangganan salah satu bidangnya, dan memiliki nilai tipe panjang.  Mereka menambahkan satu kontrol lagi, yang juga bertipe panjang, metode mengembalikan kontrol yang memiliki sepasang nilai, dan acara yang diubah dipecat ketika salah satu dari mereka berubah, kemudian fungsi menciptakan objek untuk setiap perubahan dalam input yang menghitung fungsi, dan acara yang diubah jika nilai akhir dihitung. fungsi telah berubah. <br><br>  Compiler akan berhasil membangun tipe kontrol yang diperlukan berdasarkan tipe data input dan tipe ekspresi yang dihasilkan.  Dalam kasus yang jarang terjadi ketika jenis yang dikembalikan oleh fungsi lambda tidak jelas, kompiler akan meminta Anda untuk mengklarifikasi secara eksplisit.  Akhirnya, panggilan terakhir mendengarkan kontrol Boolean, tergantung pada yang menghidupkan atau mematikan tombol. <br><br>  Bahkan, pembungkus nyata dalam proyek menerima dua tombol untuk input, satu untuk kasus ketika ada uang dan yang lainnya ketika tidak ada cukup uang, dan perintah untuk membuka jendela modal "Beli mata uang" juga tergantung pada tombol kedua.  Dan semua ini dalam satu baris sederhana. <br><br>  Sangat mudah untuk melihat bahwa menggunakan Bergabung dan Berfungsi Anda dapat membangun struktur kompleks sewenang-wenang.  Dalam kode saya, ada fungsi yang menghasilkan kontrol kompleks, menghitung berapa banyak pemain dapat membeli dengan memperhitungkan jumlah pemain di sisinya, dan aturan bahwa setiap orang bisa melebihi anggaran sebesar 10% jika semua bersama-sama tidak melebihi total anggaran.  Dan ini adalah contoh bagaimana tidak perlu melakukannya, karena seberapa sederhana dan mudah untuk men-debug apa yang terjadi dalam model, sama sulitnya untuk menangkap kesalahan dalam kontrol reaktif.  Anda bahkan akan menangkap eksekusi dan menghabiskan banyak waktu untuk memahami apa yang menyebabkannya. <br><br>  Oleh karena itu, prinsip umum menggunakan kontrol kompleks adalah sebagai berikut: Saat membuat prototipe formulir, Anda dapat menggunakan struktur pada kontrol reaktif, terutama jika Anda tidak yakin bahwa mereka akan menjadi lebih rumit di masa depan, tetapi segera setelah Anda curiga bahwa jika rusak, Anda tidak akan mengerti apa yang terjadi, Anda harus segera mentransfer manipulasi ini ke model, dan memasukkan perhitungan yang sebelumnya dilakukan dalam kontrol ke metode ekstensi di kelas aturan statis. <br><br>  Ini sangat berbeda dari prinsip “Lakukan segera dengan segera”, yang sangat disukai di kalangan perfeksionis, karena kita hidup di dunia pengembang game, dan ketika Anda mulai melewati formulir, Anda sama sekali tidak dapat memastikan apa yang akan dilakukan dalam tiga hari.  Seperti yang dikatakan salah satu kolega saya: "Jika saya mendapat lima sen setiap kali perancang permainan berubah pikiran, saya sudah menjadi orang yang sangat kaya."  Sebenarnya, ini tidak buruk, tetapi bahkan sebaliknya itu baik.  Gim ini harus berkembang dengan coba-coba, karena jika Anda tidak melakukan kloning bodoh, maka Anda tidak dapat membayangkan apa yang benar-benar dibutuhkan pemain. <br><br><h2>  Satu sumber data untuk banyak tampilan </h2><br>  Untuk begitu banyak kasus pola dasar yang perlu Anda bicarakan secara terpisah.  Kebetulan bahwa model elemen yang sama sebagai bagian dari model antarmuka dirender dalam Tampilan berbeda tergantung di mana dan dalam konteks apa ini terjadi.  Dan kami menggunakan prinsip - "satu tipe, satu tampilan."  Misalnya, Anda memiliki kartu pembelian senjata yang berisi informasi yang tidak rumit yang sama, tetapi dalam mode toko yang berbeda, kartu itu harus diwakili oleh prefab yang berbeda.  Solusinya terdiri dari dua bagian untuk dua situasi yang berbeda. <br><br>  Yang pertama adalah ketika Tampilan ini ditempatkan di dalam dua Tampilan yang berbeda, misalnya, toko dalam bentuk daftar pendek dan toko dengan gambar besar.  Dalam hal ini, dua pabrik terpisah didirikan untuk membantu, membangun pencocokan jenis cetakan.  Dalam metode ConnectModel dari satu Tampilan, Anda akan menggunakan satu dan yang lain di yang lain.  Ini kasus yang sama sekali berbeda jika Anda perlu menunjukkan kartu dengan informasi yang benar-benar identik di satu tempat sedikit berbeda.  Terkadang, dalam kasus ini, model elemen memiliki bidang tambahan yang menunjukkan latar belakang meriah dari elemen tertentu, dan kadang-kadang hanya saja model elemen memiliki ahli waris yang tidak memiliki bidang apa pun dan hanya perlu digambar dengan cetakan lain.  Pada prinsipnya, tidak ada yang bertentangan. <br><br>  Tampaknya ini solusi yang jelas, tetapi saya melihat cukup banyak kode aneh tentang tarian aneh dengan rebana di sekitar situasi ini, dan menganggap perlu untuk menulis tentang itu. <br><br><h2>  Kasus khusus: kontrol dengan banyak dependensi </h2><br>  Ada satu kasus khusus yang ingin saya bicarakan secara terpisah.  Ini adalah kontrol yang memantau sejumlah besar elemen.  Misalnya, kontrol yang memantau daftar model dan meringkas konten bidang yang terletak di dalam masing-masing elemen.  Dengan overtube besar dalam daftar, misalnya, mengisinya dengan data, kontrol seperti itu berisiko menangkap banyak peristiwa tentang perubahan karena ada plus satu dalam daftar elemen.  Menghitung ulang fungsi agregat berkali-kali tentu saja merupakan ide yang buruk.  Khusus untuk kasus seperti itu, kami membuat kontrol yang berlangganan acara onTransactionFinished, yang menonjol dari GameState, dan seingat kami, tautan ke GameState tersedia dalam model apa pun.  Dan dengan perubahan apa pun pada input, kontrol ini hanya akan memberi tanda pada dirinya sendiri bahwa data asli telah berubah, dan hanya akan diceritakan kembali ketika menerima pesan tentang akhir transaksi, atau ketika menemukan bahwa transaksi tersebut sudah selesai pada saat ketika menerima pesan dari aliran peristiwa input .  Jelas bahwa kontrol semacam itu mungkin tidak dilindungi dari pesan yang tidak perlu jika ada dua kontrol seperti itu dalam rantai pemrosesan aliran.  Yang pertama akan mengumpulkan awan perubahan, menunggu akhir transaksi, memulai aliran perubahan lebih lanjut, dan ada satu lagi yang telah menangkap banyak perubahan, menerima acara tentang akhir transaksi (ia beruntung berada dalam daftar fungsi yang dilanggankan pada acara sebelumnya), menghitung semuanya, dan kemudian dia bam dan acara perubahan lainnya, dan menceritakan semuanya untuk kedua kalinya.  Mungkin, tetapi jarang, dan yang lebih penting, jika kontrol Anda melakukan perhitungan mengerikan seperti lebih dari sekali dalam satu aliran perhitungan, maka Anda melakukan sesuatu yang salah, dan Anda perlu mentransfer semua manipulasi neraka ini ke model dan aturan, di mana mereka , faktanya, tempat itu. <br><br><h2>  Perpustakaan Siap UniRX </h2><br>  Dan mungkin untuk membatasi diri pada semua hal di atas, dan dengan tenang mulai menulis karya agung Anda, terutama karena dibandingkan dengan model dan tim kontrol itu sangat sederhana dan mereka ditulis dalam waktu kurang dari seminggu, jika gagasan bahwa Anda menciptakan sepeda tidak mengaburkan, dan semuanya sudah dipikirkan dan ditulis sebelum saya didistribusikan secara gratis kepada semua orang. <br><br>  Mengungkap UniRX, kami menemukan desain yang cantik dan sesuai standar yang dapat membuat utas dari semuanya secara umum, menggabungkannya dengan cerdik, menyaringnya dari utas utama ke utas non-utama, atau mengembalikan kontrol kembali ke utas utama, yang memiliki banyak alat siap pakai untuk dikirim ke tempat yang berbeda, dan seterusnya. selanjutnya.  Kami tidak memiliki dua hal di sana: Kesederhanaan dan Kemudahan debugging.  Apakah Anda pernah mencoba men-debug beberapa bangunan bertingkat di Linq dalam langkah-langkah di debugger?  Jadi di sini masih jauh lebih buruk.  Pada saat yang sama, kami benar-benar kekurangan untuk apa semua mesin canggih ini diciptakan.  Demi kesederhanaan kondisi debugging dan reproduksi, kami benar-benar tidak memiliki berbagai sumber sinyal, semuanya terjadi di aliran utama, karena menggoda dengan multithreading di permainan-meta sepenuhnya berlebihan, semua asinkronasi pemrosesan perintah tersembunyi di dalam mesin pengirim perintah, dan asinkroninya sendiri mengambil sangat banyak di dalamnya tidak banyak ruang, lebih banyak perhatian diberikan pada semua jenis pemeriksaan, pemeriksaan mandiri, dan kemungkinan pencatatan dan pemutaran. <br><br>  Secara umum, jika Anda sudah tahu cara menggunakan UniRX, saya akan membuatnya khusus untuk Anda untuk model IObservable, dan Anda dapat menggunakan fitur truf perpustakaan favorit Anda di mana Anda membutuhkannya, tetapi untuk sisanya saya sarankan untuk tidak membangun tank dari mobil berkecepatan tinggi dan mobil dari tank hanya di atas tanah. bahwa keduanya memiliki roda. <br><br>  Di akhir artikel ini, saya sampaikan kepada Anda, para pembaca yang budiman, pertanyaan-pertanyaan tradisional yang sangat penting bagi saya, ide-ide saya tentang yang indah, dan untuk prospek pengembangan karya ilmiah dan teknis saya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436060/">https://habr.com/ru/post/id436060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436048/index.html">Berkolaborasi hotspot Wi-Fi</a></li>
<li><a href="../id436050/index.html">Cara menyambungkan Raspberry PI ke Azure IoT: petunjuk langkah demi langkah</a></li>
<li><a href="../id436052/index.html">Cara membuat departemen Ilmu Data dan tidak mengacaukannya</a></li>
<li><a href="../id436056/index.html">Acara digital di Moskow dari 14 Januari hingga 20 Januari</a></li>
<li><a href="../id436058/index.html">Ikhtisar Modul Ekspansi Snom D3 dan D7</a></li>
<li><a href="../id436062/index.html">Sistem arbitrasi untuk pemula, bagian 1</a></li>
<li><a href="../id436064/index.html">Kecerdasan buatan untuk semua orang</a></li>
<li><a href="../id436066/index.html">Matematika Kiamat: Teori Permainan dan Krisis Nuklir Karibia</a></li>
<li><a href="../id436068/index.html">C ++ Russia Conference 2019</a></li>
<li><a href="../id436070/index.html">Bagaimana cara menghadapi tes yang rapuh di komunitas opensource</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>