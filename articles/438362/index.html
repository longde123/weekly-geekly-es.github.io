<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèª üë©üèø‚Äçüöí üè∏ C√≥mo tradujimos la configuraci√≥n de nuestros servicios de XML a YAML üßùüèº üë©‚Äçüè≠ üë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 
 Nuestra empresa, entre otras cosas, ha desarrollado varios servicios (m√°s precisamente, 12) que funcionan como el back-end de nuestros ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo tradujimos la configuraci√≥n de nuestros servicios de XML a YAML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/utex/blog/438362/"><h2>  Antecedentes </h2><br>  Nuestra empresa, entre otras cosas, ha desarrollado varios servicios (m√°s precisamente, 12) que funcionan como el back-end de nuestros sistemas.  Cada uno de los servicios es un servicio de Windows y realiza sus tareas espec√≠ficas. <br><br>  Me gustar√≠a transferir todos estos servicios a * nix-OS.  Para hacer esto, abandone el contenedor en forma de servicios de Windows y cambie de .NET Framework a .NET Standard. <br><br>  El √∫ltimo requisito lleva a la necesidad de deshacerse de algunos c√≥digos heredados, que no son compatibles con .NET Standard, incluidos  desde el soporte para configurar nuestros servidores a trav√©s de XML, implementado usando clases de System.Configuration.  Al mismo tiempo, esto resuelve el problema de larga data relacionado con el hecho de que en las configuraciones XML cometimos errores de vez en cuando al cambiar la configuraci√≥n (por ejemplo, a veces colocamos la etiqueta de cierre en el lugar incorrecto o la olvidamos), pero es un lector maravilloso de las configuraciones XML de System.Xml. XmlDocument se traga silenciosamente tales configuraciones, produciendo un resultado completamente impredecible. <br><br>  Se decidi√≥ cambiar a la configuraci√≥n a trav√©s del moderno YAML.  ¬øQu√© problemas enfrentamos y c√≥mo los resolvimos? En este art√≠culo. <br><a name="habracut"></a><br><h2>  Que tenemos </h2><br><h3>  ¬øC√≥mo leemos la configuraci√≥n de XML? </h3><br>  Leemos XML de manera est√°ndar para la mayor√≠a de los otros proyectos. <br><br>  Cada servicio tiene un archivo de configuraci√≥n para proyectos .NET, llamado AppSettings.cs, que contiene todas las configuraciones requeridas por el servicio.  Algo como esto: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Configuration.SettingsProvider(typeof(PortableSettingsProvider))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">IServerManagerConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { }</code> </pre> <br><br>  Una t√©cnica similar para separar configuraciones en interfaces hace que sea conveniente usarlas m√°s tarde a trav√©s de un contenedor DI. <br><br>  Toda la magia principal de almacenar configuraciones est√° realmente oculta en PortableSettingsProvider (vea el atributo de clase), as√≠ como en el archivo de dise√±ador AppSettings.Designer.cs: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.CodeDom.Compiler.GeneratedCodeAttribute(<span class="hljs-string"><span class="hljs-string">"Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator"</span></span>, <span class="hljs-string"><span class="hljs-string">"14.0.0.0"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">global</span></span>::<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Configuration</span></span>.<span class="hljs-title"><span class="hljs-title">ApplicationSettingsBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } } [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.UserScopedSettingAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ListenPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } ...</code> </pre><br>  Como puede ver, "detr√°s de escena" est√°n ocultas todas esas propiedades que agregamos a la configuraci√≥n del servidor cuando la editamos a trav√©s del dise√±ador de configuraciones en Visual Studio. <br><br>  Nuestra clase PortableSettingsProvider, mencionada anteriormente, lee directamente el archivo XML, y el resultado de la lectura ya se usa en SettingsProvider para escribir configuraciones en las propiedades de AppSettings. <br><br>  Un ejemplo de la configuraci√≥n XML que estamos leyendo (la mayor√≠a de las configuraciones est√°n ocultas por razones de seguridad): <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.UserSettingsGroup"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MetricServer.Properties.Settings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.ClientSettingsSection"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"KickUnknownAfter"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>00:00:10<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h3>  Qu√© archivos de YAML me gustar√≠a leer </h3><br>  Algo como esto: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br><h3>  Problemas de transici√≥n </h3><br>  <b>En primer lugar, las</b> configuraciones en XML son "planas", pero en YAML no lo son (se admiten secciones y subsecciones).  Esto se ve claramente en los ejemplos anteriores.  Usando XML, resolvimos el problema de la configuraci√≥n plana al introducir nuestros propios analizadores que pueden convertir cadenas de cierto tipo en nuestras clases m√°s complejas.  Un ejemplo de una cadena tan compleja: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  No tengo ganas de hacer esas transformaciones cuando trabajo con YAML.  Pero al mismo tiempo, estamos limitados por la estructura "plana" existente de la clase AppSettings: todas las propiedades de la configuraci√≥n en ella se acumulan en un mont√≥n. <br><br>  <b>En segundo lugar, las</b> configuraciones de nuestros servidores no son un monolito est√°tico, las cambiamos de vez en cuando en el transcurso del trabajo del servidor, es decir.  estos cambios deben ser capaces de capturar sobre la marcha, en tiempo de ejecuci√≥n.  Para hacer esto, en la implementaci√≥n XML, heredamos nuestros AppSettings de INotifyPropertyChanged (de hecho, cada interfaz que implementa AppSettings se hereda de √©l) y nos suscribimos para actualizar los eventos de configuraci√≥n de propiedades.  Este enfoque funciona porque la clase base System.Configuration.ApplicationSettingsBase lista para usar implementa INotifyPropertyChanged.  Se debe mantener un comportamiento similar despu√©s de la transici√≥n a YAML. <br><br>  <b>En tercer lugar, en</b> realidad no tenemos un archivo de configuraci√≥n para cada servidor, sino dos: uno con la configuraci√≥n predeterminada y el otro con los anulados.  Esto es necesario para que en cada una de las varias instancias de servidores del mismo tipo, que escuchen puertos diferentes y tengan configuraciones ligeramente diferentes, no tenga que copiar completamente todo el conjunto de configuraciones. <br><br>  <b>Y un problema m√°s</b> : el acceso a la configuraci√≥n pasa no solo a trav√©s de las interfaces, sino tambi√©n a trav√©s del acceso directo a AppSettings.Default.  Perm√≠teme recordarte c√≥mo se declara en el Backstage AppSettings.Designer.cs: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } }</code> </pre><br>  Basado en lo anterior, fue necesario idear un nuevo enfoque para almacenar la configuraci√≥n en AppSettings. <br><br><h2>  Soluci√≥n </h2><br><h3>  Kit de herramientas </h3><br>  Para la lectura directa, YAML decidi√≥ usar bibliotecas listas para usar disponibles a trav√©s de NuGet: <br><br><ul><li>  YamlDotNet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/aaubry/YamlDotNet</a> .  De la descripci√≥n de la biblioteca (traducci√≥n): <br><blockquote>  YamlDotNet es la biblioteca .NET para YAML.  YamlDotNet proporciona un analizador de bajo nivel y un generador de YAML, as√≠ como un modelo de objetos de alto nivel similar a XmlDocument.  Tambi√©n se incluye una biblioteca de serializaci√≥n que le permite leer y escribir objetos desde / hacia secuencias YAML. </blockquote><br></li><li>  NetEscapades.Configuration - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/andrewlock/NetEscapades.Configuration</a> .  Este es el proveedor de configuraci√≥n en s√≠ (en el sentido de Microsoft.Extensions.Configuration.IConfigurationSource, que se usa activamente en las aplicaciones ASP.NET Core), que lee archivos YAML utilizando solo el mencionado anteriormente YamlDotNet. <br></li></ul><br>  Lea m√°s sobre c√≥mo usar estas bibliotecas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h3>  Transici√≥n a YAML </h3><br>  La transici√≥n en s√≠ se realiz√≥ en dos etapas: al principio, simplemente cambiamos de XML a YAML, pero conservamos una jerarqu√≠a plana de archivos de configuraci√≥n, y luego ingresamos secciones en archivos YAML.  Estas etapas podr√≠an, en principio, combinarse en una sola, y por simplicidad de presentaci√≥n har√© exactamente eso.  Todas las acciones descritas a continuaci√≥n se aplicaron secuencialmente a cada servicio. <br><br><h3>  Preparando un archivo YML </h3><br>  Primero debes preparar el archivo YAML.  Lo llamamos el nombre del proyecto (√∫til para futuras pruebas de integraci√≥n, que deber√≠an poder trabajar con diferentes servidores y distinguir sus configuraciones entre ellos), colocar el archivo directamente en la ra√≠z del proyecto, junto a AppSettings: <br><br><img src="https://habrastorage.org/webt/es/2h/jo/es2hjofltziwk8fbqj3f5faxte0.png"><br><br>  En el archivo YML, para empezar, guardemos una estructura "plana": <br><br><pre> <code class="plaintext hljs">VirtualFeed: "MaxChartHistoryLength: 10, UseThrottling: True, ThrottlingIntervalMs: 50000, UseHistoryBroadcast: True, CalendarName: EmptyCalendar" VirtualFeedPort: 35016 UsMarketFeedUseImbalances: True</code> </pre><br><h3>  Relleno de ajustes de aplicaciones con propiedades de configuraci√≥n </h3><br>  Transferimos todas las propiedades de AppSettings.Designer.cs a AppSettings.cs, eliminando simult√°neamente los atributos superfluos del dise√±ador y el c√≥digo en s√≠ mismo en get / set-parts. <br><br>  Fue: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Configuration.UserScopedSettingAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre><br>  Se convirti√≥ en: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Eliminaremos completamente AppSettings <b>.Designer</b> .cs como innecesario.  Ahora, por cierto, puede deshacerse por completo de la secci√≥n UserSettings en el archivo app.config, si est√° en el proyecto; all√≠ se almacenan las mismas configuraciones predeterminadas, que especificamos a trav√©s del dise√±ador de configuraciones. <br>  Adelante <br><br><h3>  Configuraciones de control sobre la marcha </h3><br>  Dado que necesitamos poder obtener actualizaciones de nuestra configuraci√≥n en tiempo de ejecuci√≥n, necesitamos implementar INotifyPropertyChanged en nuestros AppSettings.  La base System.Configuration.ApplicationSettingsBase ya no est√° all√≠, respectivamente, no puedes contar con ninguna magia. <br><br>  Puede implementarlo "en la frente": agregando una implementaci√≥n de un m√©todo que arroje el evento deseado y llam√°ndolo en el setter de cada propiedad.  Pero estas son l√≠neas de c√≥digo adicionales, que adem√°s deber√°n copiarse en todos los servicios. <br><br>  Hag√°moslo mejor: introduzca un AutoNotifier de clase base auxiliar, que en realidad hace lo mismo, pero detr√°s de escena, al igual que System.Configuration.ApplicationSettingsBase hizo antes: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Implements </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="INotifyPropertyChanged"/&gt;</span></span></span><span class="hljs-comment"> for classes with a lot of public properties (ie AppSettings). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> This implementation is: </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - fairly slow, so don't use it for classes where getting/setting of properties is often operation; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - not for properties described in inherited classes of 2nd level (bad idea: Inherit2 -&gt; Inherit1 -&gt; AutoNotifier; good idea: sealed Inherit -&gt; AutoNotifier) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract class AutoNotifier : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment"> _wrappedValues = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment">(); //just to avoid manual writing a lot of fields protected T Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">([CallerMemberName] string propertyName = null) { return (T)_wrappedValues.GetValueOrDefault(propertyName, () =&gt; default(T)); } protected void Set</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(T value, [CallerMemberName] string propertyName = null) { // ReSharper disable once AssignNullToNotNullAttribute _wrappedValues.AddOrUpdate(propertyName, value, (s, o) =&gt; value); OnPropertyChanged(propertyName); } public object this[string propertyName] { get { return Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;object&gt;</span></span></span><span class="hljs-comment">(propertyName); } set { Set(value, propertyName); } } protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }</span></span></code> </pre><br>  Aqu√≠, el atributo [CallerMemberName] le permite obtener autom√°ticamente el nombre de la propiedad del objeto que llama, es decir  AppSettings <br><br>  Ahora podemos heredar nuestros AppSettings de este AutoNotifier de clase base, y luego cada propiedad se modifica ligeramente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Set(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre><br>  Con este enfoque, nuestras clases AppSettings, que incluso contienen una gran cantidad de configuraciones, se ven compactas y, al mismo tiempo, implementan INotifyPropertyChanged por completo. <br><br>  S√≠, s√© que ser√≠a posible introducir un poco m√°s de magia, usando, por ejemplo, Castle.DynamicProxy.IInterceptor, interceptando cambios en las propiedades necesarias y generando eventos all√≠.  Pero esa decisi√≥n me pareci√≥ demasiado sobrecargada. <br><br><h3>  Configuraci√≥n de lectura de un archivo YAML </h3><br>  El siguiente paso es agregar el lector de la configuraci√≥n de YAML.  Esto sucede en alg√∫n lugar m√°s cercano al inicio del servicio.  Al ocultar detalles innecesarios que no est√°n relacionados con el tema en discusi√≥n, obtenemos algo similar: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServerConfigurationProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadServerConfiguration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyDictionary&lt;Type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; allSections</span></span></span><span class="hljs-function">)</span></span> { IConfigurationBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder().SetBasePath(ConfigFiles.BasePath); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> configFile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> configFiles) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> directory = Path.GetDirectoryName(configFile); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(directory)) <span class="hljs-comment"><span class="hljs-comment">//can be empty if relative path is used { Directory.CreateDirectory(directory); } builder = builder.AddYamlFile(configFile, optional: true, reloadOnChange: true); } IConfigurationRoot config = builder.Build(); // load prepared files and merge them return new ServerConfigurationProvider&lt;TAppSettings&gt;(config, allSections); }</span></span></code> </pre><br>  En el c√≥digo presentado, ConfigurationBuilder probablemente no sea de especial inter√©s: todo el trabajo con √©l es similar al trabajo con configuraciones en ASP.NET Core.  Pero los siguientes puntos son de inter√©s.  En primer lugar, "fuera de la caja" tambi√©n tuvimos la oportunidad de combinar configuraciones de varios archivos.  Esto proporciona el requisito de tener al menos dos archivos de configuraci√≥n por servidor, como mencion√© anteriormente.  En segundo lugar, pasamos toda la configuraci√≥n de lectura a un determinado ServerConfigurationProvider.  Por qu√© <br><br><h3>  Secciones en el archivo YAML </h3><br>  Responderemos esta pregunta m√°s tarde, y ahora volveremos al requisito de almacenar configuraciones estructuradas jer√°rquicamente en un archivo YML. <br><br>  En principio, implementar esto es bastante simple.  Primero, en el archivo YML, presentamos la estructura que necesitamos: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br>  Ahora vamos a AppSettings y ens√©√±ele c√≥mo dividir nuestras propiedades en secciones.  Algo como esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">AutoNotifier</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerManagerAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGlobalCredentialsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IHeartBeatConfig</span></span>, <span class="hljs-title"><span class="hljs-title">IConcurrentAcceptorProperties</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IReadOnlyDictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Sections { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IDatabaseConfigStorage), <span class="hljs-string"><span class="hljs-string">"Database"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IWebSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Web"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Server"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IConcurrentAcceptorProperties), <span class="hljs-string"><span class="hljs-string">"ConcurrentAcceptor"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGraphiteAddressStorage), <span class="hljs-string"><span class="hljs-string">"Graphite"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IKeyCloackConfigFilePathProvider), <span class="hljs-string"><span class="hljs-string">"Keycloak"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPrometheusSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Prometheus"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IHeartBeatConfig), <span class="hljs-string"><span class="hljs-string">"Heartbeat"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerManagerAddressStorage), <span class="hljs-string"><span class="hljs-string">"ServerManager"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGlobalCredentialsStorage), <span class="hljs-string"><span class="hljs-string">"GlobalCredentials"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IBlackListStorage), <span class="hljs-string"><span class="hljs-string">"Blacklist"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IMetricsConfig), <span class="hljs-string"><span class="hljs-string">"Metrics"</span></span>} }; ...</code> </pre><br>  Como puede ver, agregamos un diccionario directamente a AppSettings, donde las claves son los tipos de interfaces que implementa la clase AppSettings, y los valores son los encabezados de las secciones correspondientes.  Ahora podemos comparar la jerarqu√≠a en el archivo YML con la jerarqu√≠a de propiedades en AppSettings (aunque no es m√°s profundo que un nivel de anidamiento, pero en nuestro caso esto fue suficiente). <br><br>  ¬øPor qu√© estamos haciendo esto aqu√≠, en AppSettings?  Porque de esta manera no difundimos la informaci√≥n sobre la configuraci√≥n de diferentes entidades, y adem√°s, este es el lugar m√°s natural, porque  en cada servicio y, en consecuencia, en cada AppSettings, su propia secci√≥n de configuraci√≥n. <br><br><h3>  Si no necesita una jerarqu√≠a en la configuraci√≥n? </h3><br>  En principio, es un caso extra√±o, pero lo tuvimos exactamente en la primera etapa, cuando simplemente cambiamos de XML a YAML, sin usar las ventajas de YAML. <br><br>  En este caso, esta lista completa de secciones no se puede almacenar, y ServerConfigurationProvider ser√° mucho m√°s simple (discutido m√°s adelante). <br><br>  Pero el punto importante es que si decidimos dejar una jerarqu√≠a plana, entonces podemos cumplir con el requisito de mantener la capacidad de acceder a la configuraci√≥n a trav√©s de AppSettings.Default.  Para hacer esto, agregue aqu√≠ un constructor p√∫blico tan simple en AppSettings: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Default = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Ahora podemos continuar accediendo a la clase de configuraci√≥n en todas partes a trav√©s de AppSettings.Default (siempre que la configuraci√≥n ya se haya le√≠do a trav√©s de IConfigurationRoot en ServerConfigurationProvider y, en consecuencia, AppSettings se haya instanciado). <br><br>  Si una jerarqu√≠a plana es inaceptable, entonces, de todos modos, debe deshacerse de AppSettings. Por defecto en todas partes por c√≥digo y trabajar con la configuraci√≥n solo a trav√©s de interfaces (lo cual es bueno en principio).  Por qu√© es as√≠, quedar√° claro a√∫n m√°s. <br><br><h3>  ServerConfigurationProvider </h3><br>  La clase especial ServerConfigurationProvider mencionada anteriormente trata con la misma magia que le permite trabajar completamente con la nueva configuraci√≥n jer√°rquica YAML con solo un AppSettings plano. <br><br>  Si no puedes esperar, aqu√≠ est√°. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de proveedor de configuraci√≥n de servidor completo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class ServerConfigurationProvider</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment"> : IServerConfigurationProvider where TAppSettings : new() { private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); private readonly IConfigurationRoot _configuration; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> _sectionsByInterface; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment"> _interfacesBySections; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Section name -&gt; config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment"> _cachedSections; public ServerConfigurationProvider(IConfigurationRoot configuration, IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> allSections) { _configuration = configuration; _cachedSections = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment">(); _sectionsByInterface = allSections; var interfacesBySections = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment">(); foreach (KeyValuePair</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> interfaceAndSection in _sectionsByInterface) { //section names must be unique interfacesBySections.Add(interfaceAndSection.Value, interfaceAndSection.Key); } _interfacesBySections = interfacesBySections; _configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, null); } private void OnConfigurationFileChanged(object _) { UpdateCache(); } private void UpdateCache() { foreach (string sectionName in _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; if (_cachedSections.TryGetValue(sectionName, out oldSection)) { UpdateSection(oldSection, newSection); } } } private void UpdateSection(TAppSettings oldConfig, TAppSettings newConfig) { foreach (PropertyInfo propertyInfo in typeof(TAppSettings).GetProperties().Where(p =&gt; p.GetMethod != null &amp;&amp; p.SetMethod != null)) { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } } public IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections =&gt; _sectionsByInterface.Keys; public TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class { return (TSettingsSectionInterface)FindSection(typeof(TSettingsSectionInterface)); } [CanBeNull] public object FindSection(Type sectionInterface) { string sectionName = FindSectionName(sectionInterface); if (sectionName == null) { return null; } //we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); } private string FindSectionName(Type sectionInterface) { string sectionName; if (!_sectionsByInterface.TryGetValue(sectionInterface, out sectionName)) { Logger.Debug("This server doesn't contain settings for {0}", sectionInterface.FullName); return null; } return sectionName; } private TAppSettings ReadSection(string sectionName, Type sectionInterface) { TAppSettings parsed; try { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment">(); if (parsed == null) { //means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } } private void CheckSection(IConfigurationSection section, string sectionName, Type sectionInterface) { ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> properties = GetPublicProperties(sectionInterface, needSetters: false); var configProperties = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">(section.GetChildren().Select(c =&gt; c.Key)); foreach (PropertyInfo propertyInfo in properties) { if (!configProperties.Remove(propertyInfo.Name)) { if (propertyInfo.PropertyType != typeof(string) &amp;&amp; typeof(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { //no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } } private static ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> GetPublicProperties(Type type, bool needSetters) { if (!type.IsInterface) { return type.GetProperties().Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null)).ToArray(); } var propertyInfos = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment">(); var considered = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); var queue = new Queue</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); considered.Add(type); queue.Enqueue(type); while (queue.Count &gt; 0) { Type subType = queue.Dequeue(); foreach (Type subInterface in subType.GetInterfaces()) { if (considered.Contains(subInterface)) { continue; } considered.Add(subInterface); queue.Enqueue(subInterface); } PropertyInfo[] typeProperties = subType.GetProperties(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.Instance); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> newPropertyInfos = typeProperties.Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null) &amp;&amp; !propertyInfos.Contains(x)); propertyInfos.InsertRange(0, newPropertyInfos); } return propertyInfos; } }</span></span></code> </pre><br></div></div><br>  ServerConfigurationProvider est√° parametrizado por la clase de configuraci√≥n de AppSettings: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProvider</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TAppSettings</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IServerConfigurationProvider</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TAppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">new</span></span>()</code> </pre><br>  Esto, como puede suponer, le permite usarlo de inmediato en todos los servicios. <br><br>  La configuraci√≥n de lectura en s√≠ (IConfigurationRoot), as√≠ como el diccionario de secci√≥n mencionado anteriormente (AppSettings.Sections) se pasan al constructor.  Hay una suscripci√≥n a las actualizaciones de archivos (¬øqueremos enviarnos inmediatamente estos cambios en caso de un cambio en el archivo YML?): <br><br><pre> <code class="cs hljs">_configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConfigurationFileChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cachedSections.TryGetValue(sectionName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> oldSection)) { UpdateSection(oldSection, newSection); } } }</code> </pre><br>  Como puede ver, aqu√≠, en caso de actualizar el archivo YML, revisamos todas las secciones que conocemos y leemos cada una.  Luego, si la secci√≥n ya se ha le√≠do anteriormente en la memoria cach√© (es decir, ya fue solicitada en alguna parte del c√≥digo por alguna clase), reescribimos los valores antiguos en la memoria cach√© con valores nuevos. <br><br>  Parecer√≠a: ¬øpor qu√© leer cada secci√≥n, por qu√© no leer solo las que est√°n en el cach√© (es decir, exigidas)?  Porque al leer la secci√≥n hemos implementado una verificaci√≥n para la configuraci√≥n correcta.  Y en caso de configuraci√≥n incorrecta, se descartan las alertas correspondientes y se registran los problemas.  Es mejor aprender sobre los problemas en los cambios de configuraci√≥n lo antes posible, de los cuales leemos todas las secciones de inmediato. <br><br>  Actualizar valores antiguos en el cach√© con valores nuevos es bastante trivial: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings oldConfig, TAppSettings newConfig</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">PropertyInfo propertyInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Where</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p =&gt; p.GetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; p.SetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">))</span></span> { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } }</code> </pre><br>  Pero leer secciones no es tan simple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TAppSettings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { TAppSettings parsed; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get&lt;TAppSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsed == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; }</span></span></code> </pre><br>  Aqu√≠, en primer lugar, leemos la secci√≥n en s√≠ usando el IConfigurationRoot.GetSection est√°ndar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego solo verifique la correcci√≥n de la secci√≥n de lectura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, leemos la secci√≥n bindim para el tipo de nuestra configuraci√≥n: secci√≥n. Aqu√≠ tenemos una caracter√≠stica del analizador YAML: no distingue entre una secci√≥n vac√≠a (sin par√°metros, es decir, ausente) de una secci√≥n en la que todos los par√°metros est√°n vac√≠os. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay un caso similar:</font></font><br><br><pre> <code class="plaintext hljs">VirtualFeed: Names: []</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ en la secci√≥n VirtualFeed hay un par√°metro de Nombres con una lista vac√≠a de valores, pero el analizador YAML, desafortunadamente, dir√° que la secci√≥n VirtualFeed generalmente est√° completamente vac√≠a. </font></font> Es triste <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y finalmente, en este m√©todo se implementa un poco de magia callejera para admitir propiedades IEnumerable en la configuraci√≥n. </font><font style="vertical-align: inherit;">No logramos lograr una lectura normal de las listas "fuera de la caja".</font></font><br><br><pre> <code class="cs hljs">ReadArrays(parsed, section); ... <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, encontramos todas las propiedades cuyo tipo se hereda de IEnumerable y les asignamos valores desde la "secci√≥n" ficticia, tambi√©n nombrada como la configuraci√≥n que nos interesa. Pero antes de eso, no olvide verificar: ¬øhay un valor anulado de esta propiedad enumerada en el segundo archivo de configuraci√≥n? Si lo hay, solo lo tomamos y borramos la configuraci√≥n le√≠da del archivo de configuraci√≥n base. Si no se hace esto, ambas propiedades (del archivo base y del archivo anulado) se fusionar√°n autom√°ticamente en una matriz en el nivel IConfigurationSection, y los √≠ndices de la matriz servir√°n como claves para la combinaci√≥n. Esto dar√° como resultado alg√∫n tipo de hash en lugar del valor anulado normal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo ReadSection que se muestra se utiliza en √∫ltima instancia en el m√©todo principal de la clase: FindSection.</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CanBeNull</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName = FindSectionName(sectionInterface); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sectionName == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principio, queda claro por qu√©, con el soporte de las secciones, no podemos admitir AppSettings. De forma predeterminada: cada acceso a una nueva secci√≥n de configuraci√≥n (previamente no le√≠da) a trav√©s de FindSection realmente nos dar√° una nueva instancia de la clase AppSettings, aunque est√© conectada a la interfaz deseada y, en consecuencia, si us√°ramos AppSettings.Default, se redefinir√≠a cada vez que se leyera una nueva secci√≥n y contendr√≠a solo las configuraciones que pertenecen a la √∫ltima secci√≥n le√≠da (el resto tendr√≠a valores predeterminados: NULL y 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La validaci√≥n de la configuraci√≥n en la secci√≥n se implementa de la siguiente manera:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IConfigurationSection section, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { ICollection&lt;PropertyInfo&gt; properties = GetPublicProperties(sectionInterface, needSetters: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(section.GetChildren().Select(c =&gt; c.Key)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (PropertyInfo propertyInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> properties) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!configProperties.Remove(propertyInfo.Name)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyInfo.PropertyType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { <span class="hljs-comment"><span class="hljs-comment">//no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠, en primer lugar, se extraen todas las propiedades p√∫blicas de la interfaz que nos interesa (secciones de configuraci√≥n de lectura). Y para cada una de estas propiedades se encuentra una coincidencia en la configuraci√≥n de lectura: si no se encuentra una coincidencia, se registra el problema correspondiente, porque esto significa que falta alguna configuraci√≥n en el archivo de configuraci√≥n. Al final, se verifica adicionalmente si alguna de las configuraciones de lectura permaneci√≥ incomparable con la interfaz. Si hay alguno, entonces el problema se registra nuevamente, porque Esto significa que las propiedades que no se describen en la interfaz se encontraron en el archivo de configuraci√≥n, que tampoco deber√≠a estar en una situaci√≥n normal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surge la pregunta: ¬øde d√≥nde viene el requisito, que en el archivo de lectura todas las configuraciones deben corresponder a las disponibles en la interfaz de forma individual? El hecho es que, de hecho, como se mencion√≥ anteriormente, en ese momento no se ley√≥ un archivo, sino dos a la vez, uno con la configuraci√≥n predeterminada y el otro con los anulados, y ambos son contiguos. En consecuencia, de hecho, no estamos mirando la configuraci√≥n de un archivo, sino los completos. Y en este caso, por supuesto, su conjunto debe corresponder a los ajustes esperados uno a uno.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n preste atenci√≥n en las fuentes anteriores al m√©todo GetPublicProperties, que, al parecer, solo devuelve todas las propiedades p√∫blicas de la interfaz. </font><font style="vertical-align: inherit;">Pero no es tan simple como podr√≠a ser, porque a veces tenemos una interfaz que describe la configuraci√≥n del servidor que se hereda de otra interfaz y, en consecuencia, es necesario observar toda la jerarqu√≠a de interfaces para encontrar todas las propiedades p√∫blicas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtener la configuraci√≥n del servidor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En base a lo anterior, para obtener la configuraci√≥n del servidor en todas partes por c√≥digo, recurrimos a la siguiente interfaz: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public interface IServerConfigurationProvider { TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class; object FindSection(Type sectionInterface); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections { get; } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El primer m√©todo de esta interfaz, FindSection, le permite acceder a la secci√≥n de configuraci√≥n de inter√©s. </font></font> Algo como esto: <br><br><pre> <code class="cs hljs">IThreadPoolProperties threadPoolProperties = ConfigurationProvider.FindSection&lt;IThreadPoolProperties&gt;();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPor qu√© se necesitan el segundo y el tercer m√©todo? Explicar√© m√°s a fondo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Registro de interfaces de configuraci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestro proyecto, Castle Windsor se utiliza como contenedor de IoC. Es √©l quien suministra, incluidas las interfaces de configuraci√≥n del servidor. En consecuencia, estas interfaces deben estar registradas en √©l. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para este prop√≥sito, se escribi√≥ una clase de extensi√≥n simple, que simplifica este procedimiento para no escribir el registro de todo el conjunto de interfaces en cada servidor:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProviderExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterAllConfigurationSections</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider</span></span></span><span class="hljs-function">)</span></span> { Register(container, configurationProvider, configurationProvider.AllSections.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type[] configSections</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registrations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IRegistration[configSections.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; registrations.Length; i++) { Type configSection = configSections[i]; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> section = configurationProvider.FindSection(configSection); registrations[i] = Component.For(configSection).Instance(section).Named(configSection.FullName); } container.Register(registrations); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer m√©todo le permite registrar todas las secciones de configuraci√≥n (para esto necesita la propiedad AllSections en la interfaz IServerConfigurationProvider). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y el segundo m√©todo se usa en el primero, y lee autom√°ticamente la secci√≥n de configuraci√≥n especificada utilizando nuestro ServerConfigurationProvider, escribi√©ndolo inmediatamente en la cach√© de ServerConfigurationProvider y registr√°ndolo en Windsor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es aqu√≠ donde se utiliza el segundo m√©todo FindSection, no parametrizado, de IServerConfigurationProvider. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo lo que queda es llamar a nuestro m√©todo de Extensi√≥n en el c√≥digo de registro del contenedor Windsor:</font></font><br><br><pre> <code class="cs hljs">container.RegisterAllConfigurationSections(configProvider);</code> </pre><br><h2>  Conclusi√≥n </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que paso </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la manera presentada, fue posible transferir sin problemas todas las configuraciones de nuestros servidores de XML a YAML, mientras se realizaban un m√≠nimo de cambios en el c√≥digo del servidor existente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las configuraciones de YAML, a diferencia de XML, resultaron ser m√°s legibles debido no solo a una mayor concisi√≥n, sino tambi√©n a la compatibilidad con la partici√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No inventamos nuestras propias bicicletas para analizar YAML, sino que utilizamos soluciones listas para usar. Sin embargo, para integrarlos en las realidades de nuestro proyecto, se requirieron algunos de los trucos descritos en este art√≠culo. Espero que sean √∫tiles para los lectores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era posible conservar la capacidad de detectar cambios en la configuraci√≥n de los bozales web de nuestros servidores sobre la marcha. </font><font style="vertical-align: inherit;">Adem√°s, como beneficio adicional, tambi√©n fue posible detectar cambios en el archivo YAML sobre la marcha (anteriormente, era necesario reiniciar el servidor para cualquier cambio en los archivos de configuraci√≥n). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conservamos la capacidad de fusionar dos archivos de configuraci√≥n: la configuraci√≥n predeterminada y la anulada, y lo hicimos utilizando soluciones de terceros listas para usar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lo que no funcion√≥ muy bien </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tuve que abandonar la capacidad previamente disponible para guardar los cambios aplicados desde las caras web de nuestros servidores a los archivos de configuraci√≥n, porque </font><font style="vertical-align: inherit;">el soporte para dicha funcionalidad requerir√≠a grandes gestos, y la tarea comercial que ten√≠amos ante nosotros en general no era tal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, tambi√©n tuve que rechazar el acceso a la configuraci√≥n a trav√©s de AppSettings.Default, pero esto es m√°s un plus que un minus.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438362/">https://habr.com/ru/post/438362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438350/index.html">Gu√≠a completa para la b√∫squeda profesional de c√°maras ocultas y dispositivos esp√≠a</a></li>
<li><a href="../438352/index.html">Video del descenso del rover "Yutu-2", sus primeros metros en la superficie de la luna. Dos semanas de sue√±o en la luna ha terminado</a></li>
<li><a href="../438354/index.html">Vue, Storybook, TypeScript: comenzar un nuevo proyecto con las mejores pr√°cticas en mente</a></li>
<li><a href="../438356/index.html">Arquitectura certificada de SQL Server Data Warehouse Fast Track (DWFT): qu√© significa y c√≥mo funciona</a></li>
<li><a href="../438358/index.html">Ex operativos de la NSA espiando iPhones de las v√≠ctimas por encargo de los EAU</a></li>
<li><a href="../438364/index.html">Replicaci√≥n del primer codificador digital de voz del mundo</a></li>
<li><a href="../438366/index.html">Otra revisi√≥n m√°s de la caracter√≠stica de tokens de hardware OATH en Azure Cloud MFA</a></li>
<li><a href="../438368/index.html">Las bombillas inteligentes arrojadas a la basura son una valiosa fuente de informaci√≥n personal.</a></li>
<li><a href="../438370/index.html">El cibercrimen como servicio: servicios y precios</a></li>
<li><a href="../438372/index.html">La NASA contin√∫a sus intentos de contactar con la oportunidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>