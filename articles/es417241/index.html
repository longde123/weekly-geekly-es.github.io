<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÑ üåí üë©üèΩ‚Äçüíº Metadatos S3 en PostgreSQL. Conferencia de Yandex üõ•Ô∏è üöÜ üë≥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda conferencia con J. Subbotnik sobre bases de datos, la primera que publicamos hace un par de semanas. 

 El jefe del grupo DBMS de p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metadatos S3 en PostgreSQL. Conferencia de Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/417241/"> Esta es la segunda conferencia con J. Subbotnik sobre bases de datos, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera</a> que publicamos hace un par de semanas. <br><br>  El jefe del grupo DBMS de prop√≥sito general Dmitry Sarafannikov habl√≥ sobre la evoluci√≥n del almac√©n de datos en Yandex: c√≥mo decidimos crear una interfaz compatible con S3, por qu√© elegimos PostgreSQL, qu√© tipo de rastrillo pisamos y c√≥mo lidiar con ellos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HqPYXZDt3VA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Hola a todos!  Mi nombre es Dima, en Yandex hago bases de datos. <a name="habracut"></a>  Te dir√© c√≥mo hicimos S3, c√≥mo llegamos a hacer exactamente S3 y qu√© tipo de almacenamiento era antes.  El primero de ellos es Elliptics, est√° publicado en c√≥digo abierto, disponible en GitHub.  Muchos pueden haberlo encontrado. <br><img src="https://habrastorage.org/webt/ji/kg/05/jikg05jprfdg32gcrus0iunyha4.jpeg"><br>  Esta es esencialmente una tabla hash distribuida con una clave de 512 bits, el resultado de SHA-512.  Forma un llavero que se divide aleatoriamente entre m√°quinas.  Si desea agregar m√°quinas all√≠, las claves se redistribuyen, se produce un reequilibrio.  Este repositorio tiene sus propios problemas asociados, en particular, con el reequilibrio.  Si tiene una cantidad suficientemente grande de claves, entonces con vol√∫menes en constante crecimiento necesita volcar constantemente los autom√≥viles all√≠, y en una cantidad muy grande de claves, el reequilibrio puede simplemente no converger.  Este fue un problema lo suficientemente grande. <br><br>  Pero al mismo tiempo, este almacenamiento es ideal para datos m√°s o menos est√°ticos, cuando carga una gran cantidad de una sola vez y luego carga una carga de solo lectura.  Para tales decisiones, encaja perfectamente. <br><br>  Vamos m√°s lejos  Los problemas con el reequilibrio eran bastante graves, por lo que apareci√≥ el siguiente almacenamiento. <br><img src="https://habrastorage.org/webt/s6/p-/0q/s6p-0qu2vq5zqtguekkjpyvljf4.jpeg"><br>  ¬øCu√°l es su esencia?  Esto no es almacenamiento de valor clave, es almacenamiento de valor.  Cuando carga alg√∫n objeto o archivo all√≠, le responde con una clave, con la cual puede recoger este archivo.  Que da  Te√≥ricamente, cien por ciento de acceso de escritura, si tiene espacio libre en el almacenamiento.  Si tiene una m√°quina de escribir, simplemente escribe a otras personas que no est√°n en las que hay espacio libre, obtiene otras claves y recoge sus datos con calma. <br><br>  Este almacenamiento es muy f√°cil de escalar, puede tirarlo con hierro, funcionar√°.  Es muy simple, confiable.  Su √∫nico inconveniente: el cliente no administra la clave, y todos los clientes deben almacenar las claves en alg√∫n lugar, almacenar la asignaci√≥n de sus claves.  Esto es inconveniente para todos.  De hecho, esta es una tarea muy similar para todos los clientes, y cada uno la resuelve a su manera en sus metabases, etc. Esto es inconveniente.  Pero al mismo tiempo, no quiero perder la confiabilidad y simplicidad de este almacenamiento, de hecho funciona con la velocidad de la red. <br><br>  Entonces comenzamos a mirar S3.  Este es el almacenamiento de valor clave, el cliente administra la clave, todo el almacenamiento se divide en los llamados cubos.  En cada segmento, el espacio clave es de menos infinito a m√°s infinito.  La clave es alg√∫n tipo de cadena de texto.  Y nos decidimos por esta opci√≥n.  ¬øPor qu√© S3? <br><br>  Todo es bastante simple.  En este momento, ya se han escrito muchos clientes listos para varios lenguajes de programaci√≥n, ya se han escrito muchas herramientas listas para almacenar algo en S3, por ejemplo, copias de seguridad de bases de datos.  Andrew <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habl√≥</a> sobre uno de los ejemplos.  Ya existe una API razonablemente bien pensada que se ha estado ejecutando en los clientes durante a√±os, y no necesita inventar nada all√≠.  La API tiene muchas caracter√≠sticas convenientes, como listados, cargas de varias partes, etc.  Por lo tanto, decidimos quedarnos en ello. <br><br>  ¬øC√≥mo hacer S3 desde nuestro almacenamiento?  ¬øQu√© te viene a la mente?  Dado que los propios clientes almacenan la asignaci√≥n de claves, simplemente tomamos, colocamos la base de datos junto a ellas y almacenaremos la asignaci√≥n de estas claves en ella.  Al leer, solo encontraremos las claves y el almacenamiento en nuestra base de datos, y le daremos al cliente lo que quiere.  Si bosquejas esto esquem√°ticamente, ¬øc√≥mo sucede el relleno? <br><img src="https://habrastorage.org/webt/99/kr/9t/99kr9tmubs8skxzhbl-yrxmq4iq.jpeg"><br>  Hay una cierta entidad, aqu√≠ se llama Proxy, el llamado backend.  Acepta el archivo, lo carga en el almacenamiento, obtiene la clave desde all√≠ y lo guarda en la base de datos. Todo es bastante simple. <br><img src="https://habrastorage.org/webt/jx/m3/q8/jxm3q8hbv-qzn7qohrpaqw8cgv8.jpeg"><br>  ¬øC√≥mo es el recibo?  El proxy encuentra la clave necesaria en la base de datos, va con la clave de almacenamiento, descarga el objeto desde all√≠ y se la entrega al cliente.  Todo es simple tambi√©n. <br><img src="https://habrastorage.org/webt/tb/w3/hw/tbw3hwknk1vjapsvw9af7pvquig.jpeg"><br>  ¬øC√≥mo es la eliminaci√≥n?  Al eliminar directamente del almacenamiento, el proxy no funciona, ya que es dif√≠cil coordinar la base de datos y el almacenamiento, por lo que solo va a la base de datos, le dice que este objeto se elimina, all√≠ el objeto se mueve a la cola de eliminaci√≥n y, en segundo plano, un profesional especialmente capacitado el robot toma estas claves, las elimina del almacenamiento y de la base de datos.  Todo aqu√≠ tambi√©n es bastante simple. <br><br>  Elegimos PostgreSQL como la base de datos para esta metabase. <br><br>  Ya sabes que lo amamos mucho.  Con la transferencia de Yandex.Mail, adquirimos suficiente experiencia en PostgreSQL, y cuando se movieron diferentes servicios de correo, desarrollamos varios patrones de fragmentaci√≥n.  Uno de ellos cay√≥ bien en el S3 con ligeras modificaciones, pero sali√≥ bien all√≠. <br><br>  ¬øCu√°les son las opciones de fragmentaci√≥n?  Este es un repositorio grande. En una escala de Yandex, debe pensar de inmediato que habr√° muchos objetos, debe pensar de inmediato en c√≥mo fragmentarlo todo.  Puede fragmentar por hash en nombre del objeto, esta es la forma m√°s confiable, pero no funcionar√° aqu√≠, porque S3 tiene, por ejemplo, listados que deber√≠an mostrar la lista de claves en orden ordenado, cuando almacena en cach√©, todas las clasificaciones desaparecer√°n, debe eliminarlas todos los objetos para que la salida cumpla con la especificaci√≥n API. <br><br>  La siguiente opci√≥n, puede fragmentar por hash en nombre o id del dep√≥sito.  Un dep√≥sito puede vivir dentro de un fragmento de base de datos. <br><br>  Otra opci√≥n es fragmentar entre rangos clave.  Dentro del cubo, hay espacio desde menos infinito hasta m√°s infinito, podemos dividirlo en cualquier n√∫mero de rangos, llamamos a este rango un fragmento, puede vivir en un solo fragmento. <br><img src="https://habrastorage.org/webt/yw/d3/vh/ywd3vh23mont7zoqjcw6xmcmrbi.jpeg"><br>  Elegimos la tercera opci√≥n, fragmentar por trozos, porque te√≥ricamente puede haber un n√∫mero infinito de objetos en un cubo, y est√∫pidamente no cabe en una sola pieza de hierro.  Habr√° grandes problemas, por lo que cortaremos y organizaremos los fragmentos a nuestro gusto.  Eso es todo. <br><img src="https://habrastorage.org/webt/yu/l-/cu/yul-cuz5u4eb5w1hrtzfguio9ro.jpeg"><br>  Que paso  La base de datos completa consta de tres componentes.  Proxy S3: un grupo de hosts, tambi√©n hay una base de datos.  PL / Proxy est√°n bajo el equilibrador, las solicitudes de ese backend vuelan all√≠.  Adem√°s S3Meta, un grupo de graves, que almacena informaci√≥n sobre cubos y fragmentos.  Y S3DB, fragmentos donde se almacenan los objetos, una cola de eliminaci√≥n.  Si se representa esquem√°ticamente, se ve as√≠. <br><img src="https://habrastorage.org/webt/3y/0n/y9/3y0ny9npaewsndqfusttbvlqczk.jpeg"><br>  Una solicitud llega a S3Proxy, va a S3Meta y S3DB y emite informaci√≥n al principio. <br><img src="https://habrastorage.org/webt/uw/1s/j1/uw1sj1zph_sjghozg404mmdzhnw.jpeg"><br>  Consideremos con m√°s detalle.  S3Proxy, las funciones dentro de √©l se crean en el lenguaje de procedimiento PLProxy, es un lenguaje que le permite ejecutar procedimientos o solicitudes almacenados de forma remota.  As√≠ es como se ve el c√≥digo de la funci√≥n ObjectInfo, en esencia, una solicitud Get. <br><br>  El cl√∫ster LProxy tiene el operador Cluster, en este caso db_ro.  ¬øQu√© significa esto? <br><img src="https://habrastorage.org/webt/59/f8/sp/59f8spslkiczmbu6arwngghstoq.jpeg"><br>  Si una configuraci√≥n t√≠pica de fragmento de base de datos, hay un maestro y dos r√©plicas.  Master ingresa al cl√∫ster db_rw, los tres hosts ingresan db-ro, aqu√≠ es donde puede enviar solo una solicitud de lectura y se env√≠a una solicitud de escritura a db_rw.  El cl√∫ster db_rw incluye todos los maestros de todos los fragmentos. <br><br>  La siguiente instrucci√≥n RUN ON, toma el valor all, lo que significa ejecutar en todos los fragmentos una matriz o alg√∫n tipo de fragmento.  En este caso, recibe el resultado de la funci√≥n get_object_shard como entrada; este es el n√∫mero del fragmento en el que se encuentra el objeto dado. <br><br>  Y objetivo: qu√© funci√≥n invocar en el fragmento remoto.  Llamar√° a esta funci√≥n y sustituir√° los argumentos que llegaron a esta funci√≥n. <br><img src="https://habrastorage.org/webt/kw/y3/ib/kwy3ib0cemkqipnlkceiaf_vny8.jpeg"><br>  La funci√≥n get_object_shard tambi√©n est√° escrita en PLProxy, que ya es un cl√∫ster meta_ro, la solicitud volar√° al fragmento S3Meta, que devolver√° esta funci√≥n get_bucket_meta_shard. <br><br>  S3Meta tambi√©n se puede fragmentar, tambi√©n lo instalamos, mientras que esto es irrelevante, pero hay una oportunidad.  Y llamar√° a la funci√≥n get_object_shard en S3Meta. <br><img src="https://habrastorage.org/webt/cx/t2/am/cxt2amhwudlblfjx2l8vrrzsxce.jpeg"><br>  get_bucket_meta_shard es solo un hash de texto en nombre de un cubo, barajamos S3Meta solo por un hash en nombre de un cubo. <br><img src="https://habrastorage.org/webt/sd/r9/1x/sdr91x352qh8xpccft-yay_ozqq.jpeg"><br>  Considere S3Meta lo que est√° sucediendo en √©l.  La informaci√≥n m√°s importante que existe es una tabla con fragmentos.  Recort√© un poco de informaci√≥n innecesaria, lo m√°s importante que queda es bucket_id, la tecla de inicio, la tecla de finalizaci√≥n y el fragmento en el que se encuentra este fragmento. <br><img src="https://habrastorage.org/webt/-n/74/zv/-n74zv7ncle8hcvuj7-_utprjta.jpeg"><br>  ¬øC√≥mo ser√≠a una consulta en dicha tabla, que nos devolver√≠a el fragmento en el que, por ejemplo, se encuentra el objeto de prueba?  Me gusta esto  Menos infinito en forma de texto, lo presentamos como un valor nulo, hay puntos tan sutiles que debe verificar start_key y end_key para Null. <br><img src="https://habrastorage.org/webt/ay/1f/cl/ay1fclvy9w-_0xillystohcq8v4.jpeg"><br>  La solicitud no se ve muy bien y el plan se ve a√∫n peor.  Como una de las opciones para un plan para dicha solicitud, BitmapOr.  Y 6,000 huesos valen ese plan. <br><img src="https://habrastorage.org/webt/qn/m6/ze/qnm6zelrf6qh2q1gpf4-eaxgzle.jpeg"><br>  ¬øC√≥mo puede ser diferente?  Hay algo tan maravilloso en PostgreSQL como el √≠ndice general, que puede indexar el tipo de rango, el rango es esencialmente lo que necesitamos.  Hicimos este tipo, la funci√≥n s3.to_keyrange nos devuelve, de hecho, el rango.  Podemos verificar con el operador contiene, encontrar el fragmento en el que est√° nuestra clave.  Y para esto, la restricci√≥n de exclusi√≥n se construye aqu√≠, lo que garantiza la no intersecci√≥n de estos fragmentos.  Necesitamos permitir, preferiblemente a nivel de la base de datos, alguna restricci√≥n para asegurarnos de que los fragmentos no puedan cruzarse entre s√≠, de modo que solo se devuelva una l√≠nea en respuesta a la solicitud.  De lo contrario, no ser√° lo que quer√≠amos.  As√≠ es como se ve el plan para dicha solicitud, el index_scan habitual.  Esta condici√≥n encaja completamente en la condici√≥n de √≠ndice, y dicho plan tiene solo 700 huesos, 10 veces menos. <br><img src="https://habrastorage.org/webt/fz/ii/el/fziielc9cnipflupcktsoowvmle.jpeg"><br>  ¬øQu√© es Excluir restricci√≥n? <br><img src="https://habrastorage.org/webt/f8/zc/ai/f8zcaicub3p9ob_7n2fkcefww3k.jpeg"><br>  Creemos una tabla de prueba con dos columnas, y agreguemos dos restricciones, una √∫nica que todos conozcan, y una restricci√≥n de exclusi√≥n, que tiene par√°metros iguales, tales operadores.  Vamos a configurarlo con dos operadores iguales, tal placa fue construida. <br><img src="https://habrastorage.org/webt/2o/gb/jx/2ogbjxuanf1sfqxvsaz2nm81a9o.jpeg"><br>  Luego intentamos insertar dos l√≠neas id√©nticas, obtenemos el error de violaci√≥n de la unicidad de la clave en la primera restricci√≥n.  Si lo dejamos, ya hemos violado la restricci√≥n de exclusi√≥n.  Este es un caso com√∫n de una restricci√≥n √∫nica. <br><img src="https://habrastorage.org/webt/rf/jo/5c/rfjo5cabxypgt7ox6nfrptpccgc.jpeg"><br>  De hecho, una restricci√≥n √∫nica es la misma restricci√≥n de exclusi√≥n con los operadores iguales, pero en el caso de la restricci√≥n de exclusi√≥n, puede construir algunos casos m√°s generales. <br><img src="https://habrastorage.org/webt/t4/r5/pw/t4r5pw1rosp_z4hdf72djmkddfy.jpeg"><br>  Tenemos tales √≠ndices.  Si observa detenidamente, ver√° que ambos son √≠ndices esenciales y, en general, son lo mismo.  Probablemente se pregunte por qu√© duplicar este negocio en absoluto.  Te lo dir√© <br><img src="https://habrastorage.org/webt/lj/rr/tp/ljrrtplgolj6ipalh4quhrpbqq8.jpeg"><br>  Los √≠ndices son tales, especialmente el √≠ndice esencial, que la tabla vive su propia vida, se producen actualizaciones, se dividen y as√≠ sucesivamente, el √≠ndice va mal all√≠, deja de ser √≥ptimo.  Y existe tal pr√°ctica, en particular la extensi√≥n pg repack, los √≠ndices se reconstruyen peri√≥dicamente, de vez en cuando se reconstruyen. <br><br>  ¬øC√≥mo reconstruir un √≠ndice bajo una restricci√≥n √∫nica?  Cree crear √≠ndice actualmente, cree el mismo √≠ndice con calma junto a √©l sin bloquear, y luego la expresi√≥n alterar tabla de restricci√≥n user_index es tal y tal.  Y todo, todo est√° claro y bien aqu√≠, funciona. <br><br>  En el caso de la restricci√≥n de exclusi√≥n, puede reconstruirla solo mediante el bloqueo de reindexaci√≥n, m√°s precisamente, su √≠ndice se bloquear√° exclusivamente y, de hecho, le quedar√°n todas las consultas.  Esto es inaceptable, el √≠ndice general se puede construir el tiempo suficiente.  Por lo tanto, nos mantenemos al lado del segundo √≠ndice, que es m√°s peque√±o en volumen, ocupa menos espacio, el planeador lo usa y podemos reconstruir ese √≠ndice de manera competitiva sin bloquearlo. <br><img src="https://habrastorage.org/webt/4t/5i/j_/4t5ij__ami8qcaik9hwlvyku4sk.jpeg"><br>  Aqu√≠ hay un gr√°fico del consumo del procesador.  La l√≠nea verde es el consumo del procesador en user_space, salta del 50% al 60%.  En este punto, el consumo cae bruscamente, este es el momento en que se reconstruye el √≠ndice.  Reconstruimos el √≠ndice, eliminamos el anterior, el consumo de nuestro procesador se redujo dr√°sticamente.  Este es un problema de √≠ndice esencial, lo es, y este es un buen ejemplo de c√≥mo puede ser esto. <br><br>  Cuando hicimos todo esto, comenzamos con la versi√≥n 9.5 S3DB, de acuerdo con el plan, planeamos apilar 10 mil millones de objetos en cada fragmento.  Como sabe, m√°s de mil millones e incluso problemas anteriores comienzan cuando una tabla tiene muchas filas, todo se vuelve mucho peor.  Hay una pr√°ctica de despedida.  En ese momento hab√≠a dos opciones, est√°ndar a trav√©s de herencia, pero esto no funciona muy bien, ya que hay una velocidad de selecci√≥n de partici√≥n lineal.  Y a juzgar por la cantidad de objetos, necesitamos muchas particiones.  Los chicos de Postgres Pro luego cortaron activamente la extensi√≥n pg_pathman. <br><img src="https://habrastorage.org/webt/hs/vp/ex/hsvpexzv7ox6fs7ajmyctotqlcw.jpeg"><br>  Elegimos pg_pathman, no ten√≠amos otra opci√≥n.  Incluso la versi√≥n 1.4.  Y como puede ver, usamos 256 particiones.  Dividimos toda la tabla de objetos en 256 particiones. <br><br>  ¬øQu√© hace pg_pathman?  Con esta expresi√≥n, puede crear 256 particiones divididas por hash de la columna de oferta. <br><img src="https://habrastorage.org/webt/5k/5h/x7/5k5hx738e1mzf4f2jcimr7snb9g.jpeg"><br>  ¬øC√≥mo funciona pg_pathman? <br><img src="https://habrastorage.org/webt/e7/_b/c2/e7_bc24xsopwt5pvme1xw27lhj4.jpeg"><br>  Registra sus ganchos en el planeador y, m√°s adelante, solicita que reemplace, en esencia, el plan.  Vemos que no busc√≥ 256 particiones para una consulta de b√∫squeda regular de un objeto con la prueba de nombre, pero inmediatamente determin√≥ que era necesario subir a la tabla objects_54, pero aqu√≠ no todo iba bien, pg_pathman tiene sus propios problemas.  En primer lugar, hab√≠a bastantes errores al principio, mientras estaba aserrando, pero gracias a los chicos de Postgres Pro, los repararon r√°pidamente y los arreglaron. <br><br>  El primer problema es la dificultad de actualizarlo.  El segundo problema son las declaraciones preparadas. <br><br>  Consideremos con m√°s detalle.  En particular, la actualizaci√≥n.  ¬øEn qu√© consiste pg_pathman? <br><img src="https://habrastorage.org/webt/zj/fp/on/zjfpond4kxp6jbx23zuuls_xxmc.jpeg"><br>  Consiste esencialmente en c√≥digo C, que est√° empaquetado en una biblioteca.  Y consta de la parte SQL, todo tipo de funciones para crear particiones, etc.  Adem√°s, interact√∫a con las funciones que est√°n en la biblioteca.  Estas dos partes no se pueden actualizar al mismo tiempo. <br><br>  A partir de aqu√≠ surgen dificultades, algo como este algoritmo para actualizar la versi√≥n de pg_pathman, primero lanzamos un nuevo paquete con una nueva versi√≥n, pero PostgreSQL tiene versiones antiguas cargadas en la memoria, lo usa.  Esto es inmediatamente en cualquier caso, la base debe reiniciarse. <br><br>  Luego, llamamos a la funci√≥n set_enable_parent, activa la funci√≥n en la tabla principal, que est√° desactivada de manera predeterminada.  Luego, apague a pathman, reinicie la base de datos, diga ALTER EXTENSION UPDATE, en este momento todo cae en la tabla principal. <br><br>  A continuaci√≥n, active pathman y ejecute la funci√≥n, que se encuentra en la extensi√≥n, que transfiere los objetos de la tabla principal que los atac√≥ en este corto per√≠odo de tiempo, los transfiere nuevamente a las tablas donde deber√≠an estar.  Y luego apague el uso de la tabla principal, busque en ella. <br><img src="https://habrastorage.org/webt/i0/vi/wp/i0viwpliiv3stsq2vhn2xoid9su.jpeg"><br>  El siguiente problema son las declaraciones preparadas. <br><img src="https://habrastorage.org/webt/7a/kn/3v/7akn3vmg3-owux9ywqyqocpn1e0.jpeg"><br>  Si bloqueamos la misma solicitud ordinaria, busque por oferta y clave, intente ejecutarla.  Realice cinco veces, todo est√° bien.  Llevamos a cabo el sexto, vemos ese plan.  Y a este respecto vemos las 256 particiones.  Si observa de cerca estas condiciones, vemos d√≥lar 1, d√≥lar 2, este es el llamado plan gen√©rico, el plan general.  Las primeras cinco consultas se crearon individualmente, se usaron planes individuales para estos par√°metros, pg_pathman pudo determinar de inmediato, ya que el par√°metro se conoce de antemano, podr√≠a determinar inmediatamente la tabla a d√≥nde ir.  En este caso, no puede hacer esto.  En consecuencia, el plan debe tener las 256 particiones, y cuando el ejecutor va a hacer esto, va y toma un bloqueo compartido para las 256 particiones, y el rendimiento de dicha soluci√≥n no funcionar√° de inmediato.  Simplemente pierde todas sus ventajas, y cualquier solicitud se lleva a cabo incre√≠blemente larga. <br><img src="https://habrastorage.org/webt/pg/ny/vr/pgnyvrsmxkaizxhi1ifdazcith8.jpeg"><br>  ¬øC√≥mo salimos de esta situaci√≥n?  Tuve que envolver todo dentro de los procedimientos almacenados en ejecuci√≥n, en SQL din√°mico, para que las declaraciones preparadas no se usaran y el plan se construyera cada vez.  As√≠ es como funciona. <br><br>  La desventaja es que debe agrupar todo el c√≥digo en estructuras que toquen estas tablas.  Esto es m√°s dif√≠cil de leer aqu√≠. <br><img src="https://habrastorage.org/webt/rh/6i/p9/rh6ip927nxvaryx5lq7uw80kc_w.jpeg"><br>  ¬øC√≥mo es la distribuci√≥n de los objetos?  En cada fragmento S3DB, los contadores de fragmentos se almacenan, tambi√©n hay informaci√≥n sobre qu√© fragmentos est√°n en este fragmento y los contadores se almacenan para ellos.  Para cada operaci√≥n de mutaci√≥n en un objeto (agregar, eliminar, cambiar, reescribir) estos contadores para el cambio de fragmento.  Para no actualizar la misma l√≠nea cuando el vertido activo est√° en este fragmento, utilizamos una t√©cnica bastante est√°ndar cuando insertamos un contador delta en una tabla separada, y una vez por minuto un robot especial pasa y agrega todo esto, actualiza los contadores en el fragmento . <br><img src="https://habrastorage.org/webt/xe/rn/hv/xernhvrnmssloj0y6mngbtwi9zg.jpeg"><br>  Adem√°s, estos contadores se entregan a S3Meta con cierto retraso, ya hay una imagen completa de cu√°ntos contadores hay en cada fragmento, luego puede ver la distribuci√≥n por fragmentos, cu√°ntos objetos hay en qu√© fragmento y, en funci√≥n de esto, se toma una decisi√≥n donde cae el nuevo fragmento.  Cuando crea un dep√≥sito, de forma predeterminada, se crea un solo fragmento de menos infinito a m√°s infinito, dependiendo de la distribuci√≥n actual de objetos que S3Meta conoce, cae en alg√∫n tipo de fragmento. <br><br>  Cuando vierte datos en este dep√≥sito, todos estos datos se vierten en este fragmento, cuando se alcanza un cierto tama√±o, un robot especial llega y comparte este fragmento. <br><img src="https://habrastorage.org/webt/6g/9x/jx/6g9xjxmouaqfyz9-lt-d-qnl-fy.jpeg"><br>  Hacemos estos trozos peque√±os.  Hacemos esto para que en este caso este peque√±o fragmento se pueda arrastrar a otro fragmento.  ¬øC√≥mo se produce una divisi√≥n de fragmentos?  Aqu√≠ hay un robot normal, se va y divide esta porci√≥n en S3DB con confirmaci√≥n en dos fases y actualiza la informaci√≥n en S3Meta. <br><img src="https://habrastorage.org/webt/9p/ec/pg/9pecpg4ivr6x4fbtp4dwgv6rhie.jpeg"><br>  La transferencia de fragmentos es una operaci√≥n un poco m√°s complicada; es una confirmaci√≥n de dos fases sobre tres bases, S3Meta y dos fragmentos, S3DB, arrastra de una a otra. <br><img src="https://habrastorage.org/webt/re/1o/so/re1osogppbljsj7camywvynnjg4.jpeg"><br>  S3 tiene una caracter√≠stica como listados, esto es lo m√°s dif√≠cil, y tambi√©n hubo problemas con √©l.  De hecho, los listados, dices S3, mu√©strame los objetos que tengo.  El par√°metro resaltado en rojo ahora es nulo.  Este par√°metro, del√≠metro, separador, puede especificar los listados con qu√© separador desea. <br><img src="https://habrastorage.org/webt/ws/pg/ld/wspgldab_p7mtvwl1p-2rahx48s.jpeg"><br>  ¬øQu√© significa esto?  Si el delimitador no est√° configurado, vemos que simplemente se nos da una lista de archivos.  Si establecemos el del√≠metro, en esencia, S3 deber√≠a mostrarnos las carpetas.  Debo entender que existen tales carpetas y, de hecho, muestra todas las carpetas y archivos en la carpeta actual.  La carpeta actual tiene el prefijo, este par√°metro es Nulo.  Vemos que hay 10 carpetas. <br><br>  Todas las claves no se almacenan en alg√∫n tipo de estructura jer√°rquica de √°rbol, como en el sistema de archivos.  Cada objeto se almacena como una cadena y tienen un prefijo com√∫n simple.  S3 debe entender que esto es un asno <br><img src="https://habrastorage.org/webt/pi/3p/dq/pi3pdqgonztctekxsrwxg_go5ra.jpeg"><br>        SQL,      .      ,     PL/pgSQL.       ,   repeatable read.      ,      . ,  -     - ,    . <br><br>        Recursive CTE,       ,   -  ,       execute  PL/pgSQL.   ,      .  , ,  ,    list objects. ,     . <br><img src="https://habrastorage.org/webt/bn/ng/t5/bnngt5vw2so41bmailmlzscffom.jpeg"><br>   ,    . <br><br>      .       ,         . <br><img src="https://habrastorage.org/webt/df/am/2x/dfam2xo8k6ohr6gkv9mo1d5pmsa.jpeg"><br>     Docker,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Behave</a>   Behave   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  .  ,   , ,    . <br><br>      .   ,    ,   CPU  S3Meta. Gist index    CPU,         , . CPU  S3Meta   .   ,      .       PLProxy  ,        S3Meta  S3DB.  ,      .          S3Meta   .  ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la replicaci√≥n l√≥gica, hay una serie de problemas que resolveremos, trataremos de impulsarlo hacia arriba. </font><font style="vertical-align: inherit;">La segunda opci√≥n: puede rechazar el histograma, intente poner este rango de texto en btree. </font><font style="vertical-align: inherit;">Este no es un tipo unidimensional, y btree solo funciona con tipos unidimensionales. </font><font style="vertical-align: inherit;">Pero la condici√≥n de que los fragmentos no se superpongan con nosotros nos permitir√° poner nuestro caso en btree. </font><font style="vertical-align: inherit;">Justo ayer hicimos un prototipo que funciona. </font><font style="vertical-align: inherit;">Se implementa en funciones PL / pgSQL. </font><font style="vertical-align: inherit;">Obtuvimos una aceleraci√≥n notable, optimizaremos en esta direcci√≥n.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417241/">https://habr.com/ru/post/es417241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417231/index.html">Merch corporativo con IU humana</a></li>
<li><a href="../es417233/index.html">C√≥digo de Google en 2017</a></li>
<li><a href="../es417235/index.html">C√≥mo las tiendas en l√≠nea pierden dinero debido a una direcci√≥n de formulario de pedido</a></li>
<li><a href="../es417237/index.html">Lo que escuchan los desarrolladores: desde los cl√°sicos hasta las bandas sonoras de los juegos: hablamos de los temas m√°s interesantes</a></li>
<li><a href="../es417239/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 261 (9 de julio - 15 de julio)</a></li>
<li><a href="../es417243/index.html">Instale 3CX SBC Session Edge Controller en Windows, Raspberry Pi o Debian 9</a></li>
<li><a href="../es417245/index.html">Erlang para IoT</a></li>
<li><a href="../es417247/index.html">VSCE # 1: Podcast de emprendedores de medios</a></li>
<li><a href="../es417249/index.html">La C√°mara de Auditor√≠a de EE. UU. Advierte: SpaceX y Boeing est√°n esperando nuevas demoras, es posible la interrupci√≥n de EE. UU. En los vuelos a la EEI</a></li>
<li><a href="../es417251/index.html">Usando el ojo de pez en Raspberry Pi 3 con ROS - Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>