<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😕 👨🏽‍⚖️ 🤳 Cluster hierárquico de dados categóricos em R 👨🏾‍🏭 👨🏽‍🏭 🧚🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A tradução foi preparada para os alunos do curso "Applied Analytics on R" . 




 Esta foi minha primeira tentativa de agrupar clientes com base em da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cluster hierárquico de dados categóricos em R</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/461741/">  <i>A tradução foi preparada para os alunos do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Applied Analytics on R"</a> .</i> <br><br><img src="https://habrastorage.org/webt/wq/q0/sp/wqq0sphqihtnsg1f8eor15ffkgi.png"><br><hr><br><br>  Esta foi minha primeira tentativa de agrupar clientes com base em dados reais e me proporcionou uma experiência valiosa.  Existem muitos artigos na Internet sobre clustering usando variáveis ​​numéricas, mas encontrar soluções para dados categóricos, o que é um pouco mais difícil, não era tão simples.  Os métodos de clustering para dados categóricos ainda estão em desenvolvimento e, em outro post, tentarei outro. <br><a name="habracut"></a><br>  Por outro lado, muitas pessoas pensam que o agrupamento de dados categóricos pode não produzir resultados significativos - e isso é parcialmente verdade (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente discussão sobre CrossValidated</a> ).  A certa altura, pensei: “O que estou fazendo?  Eles podem simplesmente ser divididos em coortes. ”  No entanto, a análise de coorte também nem sempre é aconselhável, especialmente com um número significativo de variáveis ​​categóricas com um grande número de níveis: você pode lidar facilmente com 5-7 coortes, mas se você tiver 22 variáveis ​​e cada uma tiver 5 níveis (por exemplo, uma pesquisa de cliente com estimativas discretas 1 , 2, 3, 4 e 5), e você precisa entender quais grupos característicos de clientes você está lidando - você obterá coortes 22x5.  Ninguém quer se preocupar com essa tarefa.  E aqui o agrupamento pode ajudar.  Portanto, nesta postagem, falarei sobre o que eu gostaria de saber assim que comecei a agrupar. <br><br>  O próprio processo de armazenamento em cluster consiste em três etapas: <br><br><ol><li>  Construir uma matriz de dissimilaridade é sem dúvida a decisão mais importante no agrupamento.  Todas as etapas subsequentes serão baseadas na matriz de dissimilaridade que você criou. </li><li>  A escolha do método de agrupamento. </li><li>  Avaliação de cluster. </li></ol><br>  Este post será um tipo de introdução que descreve os princípios básicos do clustering e sua implementação no ambiente R. <br><br><h2>  Matriz de dissimilaridade </h2><br>  A base para o agrupamento será a matriz de dissimilaridade, que em termos matemáticos descreve quão diferentes os pontos no conjunto de dados são (removidos) um do outro.  Permite combinar ainda mais nos grupos os pontos mais próximos um do outro ou separar os mais distantes entre si - essa é a principal idéia do agrupamento. <br><br>  Nesse estágio, as diferenças entre os tipos de dados são importantes, uma vez que a matriz de dissimilaridade é baseada nas distâncias entre os pontos de dados individuais.  É fácil imaginar as distâncias entre os pontos dos dados numéricos (um exemplo bem conhecido são as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">distâncias euclidianas</a> ), mas no caso de dados categóricos (fatores em R), tudo não é tão óbvio. <br><br>  Para construir uma matriz de dissimilaridade nesse caso, deve-se usar a chamada distância de Gover.  Não vou me aprofundar na parte matemática desse conceito, simplesmente fornecerei links: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ali</a> .  Para isso, prefiro usar <code>daisy()</code> com a <code>metric = c("gower")</code> do pacote de <code>cluster</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#-----   -----# #    ,       ,     ,   ,    library(dplyr) #     set.seed(40) #     #    ;   data.frame()     #    ,   200   1  200 id.s &lt;- c(1:200) %&gt;% factor() budget.s &lt;- sample(c("small", "med", "large"), 200, replace = T) %&gt;% factor(levels=c("small", "med", "large"), ordered = TRUE) origins.s &lt;- sample(c("x", "y", "z"), 200, replace = T, prob = c(0.7, 0.15, 0.15)) area.s &lt;- sample(c("area1", "area2", "area3", "area4"), 200, replace = T, prob = c(0.3, 0.1, 0.5, 0.2)) source.s &lt;- sample(c("facebook", "email", "link", "app"), 200, replace = T, prob = c(0.1,0.2, 0.3, 0.4)) ##   —      dow.s &lt;- sample(c("mon", "tue", "wed", "thu", "fri", "sat", "sun"), 200, replace = T, prob = c(0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.2)) %&gt;% factor(levels=c("mon", "tue", "wed", "thu", "fri", "sat", "sun"), ordered = TRUE) #  dish.s &lt;- sample(c("delicious", "the one you don't like", "pizza"), 200, replace = T) #   data.frame()      synthetic.customers &lt;- data.frame(id.s, budget.s, origins.s, area.s, source.s, dow.s, dish.s) #-----   -----# library(cluster) #       #   : daisy(), diana(), clusplot() gower.dist &lt;- daisy(synthetic.customers[ ,2:7], metric = c("gower")) # class(gower.dist) ## , </span></span></code> </pre> <br>  A matriz de dissimilaridade está pronta.  Para 200 observações, ele é construído rapidamente, mas pode exigir uma quantidade muito grande de computação se você estiver lidando com um grande conjunto de dados. <br><br>  Na prática, é muito provável que você primeiro precise limpar o conjunto de dados, executar as transformações necessárias das linhas em fatores e rastrear os valores ausentes.  No meu caso, o conjunto de dados também continha linhas de valores ausentes que foram agrupados maravilhosamente a cada vez, por isso parecia um tesouro - até que eu olhei para os valores (infelizmente!). <br><br><h2>  Algoritmos de cluster </h2><br>  Você já deve saber que o clustering é <i>k-means e hierárquico</i> .  Neste post, focalizo o segundo método, já que é mais flexível e permite várias abordagens: você pode escolher o algoritmo de agrupamento <i>aglomerativo</i> (de baixo para cima) ou <i>divisional</i> (de cima para baixo). <br><br><img src="https://habrastorage.org/webt/nl/vp/u4/nlvpu4e8ykoh_nd_el_4i6plh8q.png"><br>  <i>Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia de programação do UC Business Analytics R</a></i> <br><br>  O agrupamento aglomerativo começa com <code>n</code> agrupamentos, em que <code>n</code> é o número de observações: assume-se que cada um deles é um agrupamento separado.  Em seguida, o algoritmo tenta encontrar e agrupar os pontos de dados mais semelhantes entre si - é assim que a formação de cluster começa. <br><br>  O agrupamento por divisão é realizado da maneira oposta - assume-se inicialmente que todos os n pontos de dados que temos são um cluster grande e, em seguida, os menos semelhantes são divididos em grupos separados. <br><br>  Ao decidir qual desses métodos escolher, sempre faz sentido tentar todas as opções, no entanto, em geral, o <i>clustering aglomerativo é melhor para identificar pequenos agrupamentos e é usado pela maioria dos programas de computador, e o agrupamento por divisão é mais apropriado para identificar agrupamentos grandes</i> . <br><br>  Pessoalmente, antes de decidir qual método usar, prefiro olhar para os dendrogramas - uma representação gráfica do agrupamento.  Como você verá mais adiante, alguns dendrogramas são bem equilibrados, enquanto outros são muito caóticos. <br><br>  # A entrada principal para o código abaixo é a diferença (matriz de distância) <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#             #            —         —    #------------  ------------# divisive.clust &lt;- diana(as.matrix(gower.dist), diss = TRUE, keep.diss = TRUE) plot(divisive.clust, main = "Divisive")</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/54/mp/m1/54mpm19v8jkkpmj6usehxlgr5qk.png"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#------------   ------------# #      #         —     ,      #    (complete linkages) aggl.clust.c &lt;- hclust(gower.dist, method = "complete") plot(aggl.clust.c, main = "Agglomerative, complete linkages")</span></span></code> </pre> <br><h2>  Avaliação de qualidade de cluster </h2><br>  Nesse estágio, é necessário escolher entre diferentes algoritmos de armazenamento em cluster e um número diferente de clusters.  Você pode usar diferentes métodos de avaliação, sem esquecer de ser guiado pelo <b>senso comum</b> .  Eu destaquei essas palavras em negrito e itálico, porque a <b>importância</b> da escolha é <b>muito importante</b> - o número de clusters e o método de dividir os dados em grupos devem ser práticos do ponto de vista prático.  O número de combinações de valores de variáveis ​​categóricas é finito (uma vez que são discretos), mas nenhum detalhamento baseado nelas será significativo.  Você também pode não querer ter muito poucos clusters - nesse caso, eles serão muito generalizados.  No final, tudo depende do seu objetivo e das tarefas da análise. <br><br>  Em geral, ao criar clusters, você está interessado em obter grupos de pontos de dados claramente definidos, para que a distância entre esses pontos dentro do cluster ( <i>ou compactação</i> ) seja mínima e a distância entre grupos ( <i>separabilidade</i> ) seja a máxima possível.  Isso é fácil de entender intuitivamente: a distância entre os pontos é uma medida de sua dissimilaridade, obtida com base na matriz de dissimilaridade.  Assim, a avaliação da qualidade do agrupamento é baseada na avaliação da compactação e separabilidade. <br><br>  A seguir, demonstrarei duas abordagens e mostrarei que uma delas pode fornecer resultados sem sentido. <br><br><ul><li>  <i>Método do cotovelo</i> : comece com ele se o fator mais importante para sua análise for a compactação dos clusters, ou seja, a semelhança entre os grupos. </li><li>  <i>Método de avaliação de silhuetas</i> : O gráfico de <i>silhueta</i> usado como uma medida da consistência dos dados mostra o quão perto cada ponto de um cluster está dos pontos nos clusters vizinhos. </li></ul><br>  Na prática, esses dois métodos geralmente oferecem resultados diferentes, o que pode levar a alguma confusão - a compactação máxima e a separação mais clara serão alcançadas com um número diferente de clusters, de modo que o bom senso e a compreensão do que seus dados realmente significam desempenharão um papel importante ao tomar uma decisão final. <br><br>  Há também várias métricas que você pode analisar.  Vou adicioná-los diretamente ao código. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,        #      ,     ,   —   #     ,      ,         ,   ,     library(fpc) cstats.table &lt;- function(dist, tree, k) { clust.assess &lt;- c("cluster.number","n","within.cluster.ss","average.within","average.between", "wb.ratio","dunn2","avg.silwidth") clust.size &lt;- c("cluster.size") stats.names &lt;- c() row.clust &lt;- c() output.stats &lt;- matrix(ncol = k, nrow = length(clust.assess)) cluster.sizes &lt;- matrix(ncol = k, nrow = k) for(i in c(1:k)){ row.clust[i] &lt;- paste("Cluster-", i, " size") } for(i in c(2:k)){ stats.names[i] &lt;- paste("Test", i-1) for(j in seq_along(clust.assess)){ output.stats[j, i] &lt;- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j] } for(d in 1:k) { cluster.sizes[d, i] &lt;- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d] dim(cluster.sizes[d, i]) &lt;- c(length(cluster.sizes[i]), 1) cluster.sizes[d, i] } } output.stats.df &lt;- data.frame(output.stats) cluster.sizes &lt;- data.frame(cluster.sizes) cluster.sizes[is.na(cluster.sizes)] &lt;- 0 rows.all &lt;- c(clust.assess, row.clust) # rownames(output.stats.df) &lt;- clust.assess output &lt;- rbind(output.stats.df, cluster.sizes)[ ,-1] colnames(output) &lt;- stats.names[2:k] rownames(output) &lt;- rows.all is.num &lt;- sapply(output, is.numeric) output[is.num] &lt;- lapply(output[is.num], round, 2) output } #     :      7 #     ,            stats.df.divisive &lt;- cstats.table(gower.dist, divisive.clust, 7) stats.df.divisive</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/r-/g_/ou/r-g_oukwyorhqnsls_cbg4c8spw.png"><br><br>  Portanto, o indicador average.within, que representa a distância média entre as observações nos clusters, diminui, assim como within.cluster.ss (a soma dos quadrados das distâncias entre as observações em um cluster).  A largura média da silhueta (avg.silwidth) não muda de maneira tão inequívoca; no entanto, um relacionamento inverso ainda pode ser percebido. <br>  Observe como os tamanhos de cluster são desproporcionais.  Eu não me apressaria a trabalhar com um número incomparável de observações dentro de clusters.  Uma das razões é que o conjunto de dados pode estar desequilibrado e um grupo de observações supera todos os outros na análise - isso não é bom e provavelmente levará a erros. <br><br> <code>stats.df.aggl &lt;-cstats.table(gower.dist, aggl.clust.c, 7) #      </code> <br> <br> <code>stats.df.aggl</code> <br> <br><img src="https://habrastorage.org/webt/a_/-u/aa/a_-uaa_nff99nuyobulroyk_hka.png"><br><br>  Observe quão melhor o número de observações por grupo é balanceado por cluster hierárquico aglomerativo com base no método de comunicação completo. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment"># ---------    ---------# #   «»       #    ,     7  library(ggplot2) #  #   ggplot(data = data.frame(t(cstats.table(gower.dist, divisive.clust, 15))), aes(x=cluster.number, y=within.cluster.ss)) + geom_point()+ geom_line()+ ggtitle("Divisive clustering") + labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") + theme(plot.title = element_text(hjust = 0.5))</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/kw/kz/xy/kwkzxyuuzwhe0yst9kteg9inias.png"><br><br>  Então, criamos um gráfico do "cotovelo".  Ele mostra como a soma das distâncias quadradas entre as observações (nós a usamos como uma medida da proximidade das observações - quanto menor, mais próximas são as medidas dentro do cluster) para um número diferente de clusters.  Idealmente, devemos ver uma distinta “curva do cotovelo” no ponto em que aglomerados adicionais dão apenas uma ligeira diminuição na soma dos quadrados (SS).  Para o gráfico abaixo, eu pararia em cerca de 7. Embora neste caso, um dos clusters seja composto por apenas duas observações.  Vamos ver o que acontece durante o agrupamento aglomerado. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#       ggplot(data = data.frame(t(cstats.table(gower.dist, aggl.clust.c, 15))), aes(x=cluster.number, y=within.cluster.ss)) + geom_point()+ geom_line()+ ggtitle("Agglomerative clustering") + labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") + theme(plot.title = element_text(hjust = 0.5))</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/y0/ck/q-/y0ckq-zxtzg0fbjr9gcq1jgorvq.png"><br><br>  O “cotovelo” aglomerativo é semelhante ao da divisão, mas o gráfico parece mais suave - as curvas não são tão pronunciadas.  Assim como no agrupamento por divisão, eu focaria em 7 agrupamentos, no entanto, ao escolher entre esses dois métodos, gosto mais dos tamanhos de agrupamento que são obtidos pelo método aglomerativo - é melhor que sejam comparáveis ​​entre si. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#  ggplot(data = data.frame(t(cstats.table(gower.dist, divisive.clust, 15))), aes(x=cluster.number, y=avg.silwidth)) + geom_point()+ geom_line()+ ggtitle("Divisive clustering") + labs(x = "Num.of clusters", y = "Average silhouette width") + theme(plot.title = element_text(hjust = 0.5))</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/u9/nj/nf/u9njnfcjqbxbzlfgpl5sxqailra.png"><br><br>  Ao usar o método de estimativa de silhueta, você deve escolher a quantidade que fornecer o coeficiente máximo de silhueta, porque você precisa de clusters suficientemente afastados para serem considerados separados. <br><br>  O coeficiente da silhueta pode variar de –1 a 1, com 1 correspondendo a boa consistência dentro dos clusters e –1 não muito bom. <br>  No caso do gráfico acima, você escolheria 9 em vez de 5 clusters. <br><br>  Para comparação: no caso “simples”, o gráfico da silhueta é semelhante ao gráfico abaixo.  Não é como o nosso, mas quase. <br><br><img src="https://habrastorage.org/webt/18/yw/uj/18ywujz8uh4q5hhnhtxlzrgs1nm.png"><br>  <i>Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Marinheiros de Dados</a></i> <br><br><pre> <code class="sql hljs">ggplot(data = data.frame(t(cstats.table(gower.dist, aggl.clust.c, 15))), aes(x=cluster.number, y=avg.silwidth)) + geom_point()+ geom_line()+ ggtitle("Agglomerative clustering") + labs(x = "Num.of clusters", y = "Average silhouette width") + theme(plot.title = element_text(hjust = 0.5))</code> </pre> <br><img src="https://habrastorage.org/webt/vk/f1/fl/vkf1fln-v-nedwuh6rzbjkxz2pg.png"><br><br>  O gráfico de largura da silhueta nos diz: quanto mais você divide o conjunto de dados, mais claros os clusters se tornam.  No entanto, no final, você alcançará pontos individuais e não precisará disso.  No entanto, é exatamente isso que você verá se começar a aumentar o número de clusters <i>k</i> .  Por exemplo, para <code>k=30</code> obtive o seguinte gráfico: <br><br><img src="https://habrastorage.org/webt/sz/nq/sy/sznqsykdros9uf8clfabfg8yb94.png"><br><br>  Para resumir: quanto mais você divide o conjunto de dados, melhores são os clusters, mas não podemos alcançar pontos individuais (por exemplo, no gráfico acima, selecionamos 30 clusters e temos apenas 200 pontos de dados). <br><br>  Portanto, o agrupamento aglomerativo no nosso caso me parece muito mais equilibrado: os tamanhos dos agrupamentos são mais ou menos comparáveis ​​(basta olhar para um agrupamento de apenas duas observações ao dividir pelo método de divisão!), E eu pararia em 7 agrupamentos obtidos por esse método.  Vamos ver como eles se parecem e do que são feitos. <br><br>  O conjunto de dados consiste em 6 variáveis ​​que precisam ser visualizadas em 2D ou 3D, para que você tenha que trabalhar duro!  A natureza dos dados categóricos também impõe algumas limitações, portanto, soluções prontas podem não funcionar.  Eu preciso: a) ver como as observações são divididas em grupos; b) entender como as observações são categorizadas.  Portanto, criei a) um dendograma de cores, b) um mapa de calor do número de observações por variável dentro de cada cluster. <br><br><pre> <code class="sql hljs">library("ggplot2") library("reshape2") library("purrr") library("dplyr") <span class="hljs-comment"><span class="hljs-comment">#    library("dendextend") dendro &lt;- as.dendrogram(aggl.clust.c) dendro.col &lt;- dendro %&gt;% set("branches_k_color", k = 7, value = c("darkslategray", "darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3", "gold3")) %&gt;% set("branches_lwd", 0.6) %&gt;% set("labels_colors", value = c("darkslategray")) %&gt;% set("labels_cex", 0.5) ggd1 &lt;- as.ggdend(dendro.col) ggplot(ggd1, theme = theme_minimal()) + labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 7")</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/iy/hf/jx/iyhfjxt9q7vztvwbaazmqlzzno0.png"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#     ( ) ggplot(ggd1, labels = T) + scale_y_reverse(expand = c(0.2, 0)) + coord_polar(theta="x")</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/if/4g/yv/if4gyv42vtgecjd9n-b_0bb91rs.png"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#  —   #    —       #    ,      clust.num &lt;- cutree(aggl.clust.c, k = 7) synthetic.customers.cl &lt;- cbind(synthetic.customers, clust.num) cust.long &lt;- melt(data.frame(lapply(synthetic.customers.cl, as.character), stringsAsFactors=FALSE), id = c("id.s", "clust.num"), factorsAsStrings=T) cust.long.q &lt;- cust.long %&gt;% group_by(clust.num, variable, value) %&gt;% mutate(count = n_distinct(id.s)) %&gt;% distinct(clust.num, variable, value, count) # heatmap.c ,      — ,   ,     heatmap.c &lt;- ggplot(cust.long.q, aes(x = clust.num, y = factor(value, levels = c("x","y","z", "mon", "tue", "wed", "thu", "fri","sat","sun", "delicious", "the one you don't like", "pizza", "facebook", "email", "link", "app", "area1", "area2", "area3", "area4", "small", "med", "large"), ordered = T))) + geom_tile(aes(fill = count))+ scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") #            cust.long.p &lt;- cust.long.q %&gt;% group_by(clust.num, variable) %&gt;% mutate(perc = count / sum(count)) %&gt;% arrange(clust.num) heatmap.p &lt;- ggplot(cust.long.p, aes(x = clust.num, y = factor(value, levels = c("x","y","z", "mon", "tue", "wed", "thu", "fri","sat", "sun", "delicious", "the one you don't like", "pizza", "facebook", "email", "link", "app", "area1", "area2", "area3", "area4", "small", "med", "large"), ordered = T))) + geom_tile(aes(fill = perc), alpha = 0.85)+ labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) + geom_hline(yintercept = 3.5) + geom_hline(yintercept = 10.5) + geom_hline(yintercept = 13.5) + geom_hline(yintercept = 17.5) + geom_hline(yintercept = 21.5) + scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") heatmap.p</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/c5/gg/y5/c5ggy5vih07qcfi4h26mgcvkfgy.png"><br><br>  O mapa de calor mostra graficamente quantas observações são feitas para cada nível de fator para os fatores iniciais (as variáveis ​​com as quais começamos).  A cor azul escuro corresponde a um número relativamente grande de observações dentro do cluster.  Esse mapa de calor também mostra que, para o dia da semana (dom, sáb ... seg) e o tamanho da cesta (grande, médio e pequeno), o número de clientes em cada célula é quase o mesmo - isso pode significar que essas categorias não são determinantes para a análise Talvez eles não precisem ser levados em consideração. <br><br><h2>  Conclusão </h2><br>  Neste artigo, calculamos a matriz de dissimilaridade, testamos os métodos aglomerativos e de divisão de agrupamento hierárquico e nos familiarizamos com os métodos de cotovelo e silhueta para avaliar a qualidade dos clusters. <br><br>  O cluster hierárquico de divisão e aglomeração é um bom começo para estudar o tópico, mas não pare por aí se você realmente deseja dominar a análise de cluster.  Existem muitos outros métodos e técnicas.  A principal diferença dos dados numéricos em cluster é o cálculo da matriz de dissimilaridade.  Ao avaliar a qualidade do agrupamento, nem todos os métodos padrão fornecerão resultados confiáveis ​​e significativos - o método da silhueta provavelmente não é adequado. <br><br>  E, finalmente, já que já passou algum tempo desde que eu fiz esse exemplo, agora vejo várias deficiências em minha abordagem e ficarei feliz em receber algum feedback.  Um dos problemas significativos da minha análise não estava relacionado ao agrupamento como tal - <i>meu conjunto de dados estava desequilibrado</i> de várias maneiras e esse momento permaneceu inexplicado.  Isso teve um efeito notável no agrupamento: 70% dos clientes pertenciam a um nível do fator “cidadania”, e esse grupo dominou a maioria dos clusters obtidos, por isso era difícil calcular as diferenças em outros níveis do fator.  Na próxima vez, tentarei equilibrar o conjunto de dados e comparar os resultados do cluster.  Mas mais sobre isso em outro post. <br><br>  Por fim, se você deseja clonar meu código, aqui está o link para o github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/khunreus/cluster-categorical</a> <br>  Espero que você tenha gostado deste artigo! <br><br><h3>  <i>Fontes que me ajudaram:</i> </h3><br>  Guia hierárquico de armazenamento em cluster (preparação de dados, armazenamento em cluster, visualização) - este blog será interessante para quem estiver interessado em análise de negócios no ambiente R: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://uc-r.github.io/hc_clustering</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https: // uc-r. github.io/kmeans_clustering</a> <br><br>  Validação de cluster: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.sthda.com/english/articles/29-cluster-validation-essentials/97-cluster-validation-statistics-must-know-methods/</a> <br><br>    (   k-): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://eight2late.wordpress.com/2015/07/22/a-gentle-introduction-to-cluster-analysis-using-r/</a> <br><br>    denextend,        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://cran.r-project.org/web/packages/dendextend/vignettes/introduction.html#the-set-function</a> <br><br>    ,   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.r-statistics.com/2010/06/clustergram-visualization-and-diagnostics-for-cluster-analysis-r-code/</a> <br><br>     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://jcoliver.github.io/learn-r/008-ggplot-dendrograms-and-heatmaps.html</a> <br><br>       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5025633/</a> (  GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/khunreus/EnsCat</a> ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461741/">https://habr.com/ru/post/pt461741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461731/index.html">DPKI: Abordando as desvantagens da PKI centralizada por meio de Blockchain</a></li>
<li><a href="../pt461733/index.html">Aprendendo inglês: 9 expressões ao estilo americano</a></li>
<li><a href="../pt461735/index.html">Prática de decodificação de hardware FFmpeg DXVA2</a></li>
<li><a href="../pt461737/index.html">Coletamos o ambiente para o TDD moderno em JavaScript + código VS</a></li>
<li><a href="../pt461739/index.html">Back-end United 4: Okroshka. Incidentes</a></li>
<li><a href="../pt461743/index.html">Semana 31 de Segurança: Vulnerabilidade no VLC e telefone quebrado</a></li>
<li><a href="../pt461745/index.html">DeviceLock DLP: Preços do mercado negro russo pela quebra de dados pessoais (mais uma resposta à resposta do Tinkoff Bank)</a></li>
<li><a href="../pt461747/index.html">Como implementamos o ML em um aplicativo com quase 50 milhões de usuários. Experiência Sberbank</a></li>
<li><a href="../pt461749/index.html">Beleza nos olhos de quem vê</a></li>
<li><a href="../pt461751/index.html">Contribuição do designer para o desenvolvimento de aplicativos para dispositivos móveis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>