<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏾 🔡 🀄️ Bagaimana Discord secara bersamaan melayani 2,5 juta obrolan suara menggunakan WebRTC 🌑 👩🏻‍💼 👍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak awal, kami merencanakan solusi teknik dan produk sehingga Discord sangat cocok untuk obrolan suara saat bermain dengan teman-teman. Solusi ini m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Discord secara bersamaan melayani 2,5 juta obrolan suara menggunakan WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423171/"><img src="https://habrastorage.org/webt/no/3o/oj/no3oojc_pnuwknb6hcrplkrhtmq.jpeg"><br><br>  Sejak awal, kami merencanakan solusi teknik dan produk sehingga Discord sangat cocok untuk obrolan suara saat bermain dengan teman-teman.  Solusi ini memungkinkan untuk meningkatkan skala sistem, memiliki tim kecil dan sumber daya terbatas. <br><br>  Artikel ini membahas berbagai teknologi yang digunakan Discord untuk obrolan audio / video. <br><br>  <i>Untuk kejelasan, kami akan memanggil seluruh grup pengguna dan menyalurkan "grup" (serikat) - di klien mereka disebut "server".</i>  <i>Sebaliknya, istilah "server" mengacu pada infrastruktur server kami.</i> <br><a name="habracut"></a><br><h1>  Prinsip utama </h1><br>  Setiap obrolan audio / video dalam Perselisihan mendukung banyak peserta.  Kami menyaksikan seribu orang mengobrol dalam obrolan grup besar.  Dukungan semacam itu membutuhkan arsitektur klien-server, karena jaringan peer-to-peer peer-to-peer menjadi sangat mahal dengan peningkatan jumlah peserta. <br><br>  Routing lalu lintas jaringan melalui server Discord juga memastikan bahwa alamat IP Anda tidak pernah terlihat - dan tidak ada yang akan meluncurkan serangan DDoS.  Routing melalui server memiliki kelebihan lain: misalnya, moderasi.  Administrator dapat dengan cepat mematikan suara dan video ke pengganggu. <br><br><h1>  Arsitektur klien </h1><br>  Perselisihan berjalan di banyak platform. <br><br><ul><li>  Web (Chrome / Firefox / Edge, dll.) </li><li>  Aplikasi mandiri (Windows, MacOS, Linux) </li><li>  Telepon (iOS / Android) </li></ul><br>  Kami dapat mendukung semua platform ini hanya dalam satu cara: melalui penggunaan kembali kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebRTC</a> .  Spesifikasi untuk komunikasi waktu-nyata ini mencakup komponen jaringan, audio, dan video.  Standar ini diadopsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh World Wide Web Consortium</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Internet Engineering Group</a> .  WebRTC tersedia di semua browser modern dan sebagai pustaka asli untuk implementasi dalam aplikasi. <br><br>  Audio dan video dalam Discord berjalan di WebRTC.  Dengan demikian, aplikasi browser bergantung pada implementasi WebRTC di browser.  Namun, aplikasi untuk desktop, iOS dan Android menggunakan mesin multimedia C ++ tunggal yang dibangun di atas pustaka WebRTC mereka sendiri, yang secara khusus disesuaikan dengan kebutuhan pengguna kami.  Ini berarti bahwa beberapa fungsi dalam aplikasi berfungsi lebih baik daripada di browser.  Misalnya, dalam aplikasi asli kami, kami dapat: <br><br><ul><li>  Bypass Volume Windows Mute secara default, ketika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semua aplikasi secara otomatis dimatikan saat menggunakan headset</a> .  Ini tidak diinginkan ketika Anda dan teman Anda melakukan razia dan mengoordinasi kegiatan obrolan Discord. </li><li>  Gunakan kontrol volume Anda sendiri alih-alih mixer sistem operasi global. </li><li>  Memproses data audio asli untuk mendeteksi aktivitas suara dan menyiarkan audio dan video dalam game. </li><li>  Kurangi konsumsi bandwidth dan CPU selama periode hening - bahkan dalam obrolan suara paling banyak pada waktu tertentu, hanya beberapa orang yang berbicara pada saat yang sama. </li><li>  Menyediakan fungsionalitas seluruh sistem untuk mode push to talk. </li><li>  Kirimkan bersama paket audio-video informasi tambahan (misalnya, indikator prioritas dalam obrolan). </li></ul><br>  Memiliki versi WebRTC Anda sendiri berarti pembaruan yang sering dilakukan untuk semua pengguna: ini adalah proses yang memakan waktu yang kami coba lakukan secara otomatis.  Namun, upaya ini terbayar berkat fitur khusus untuk pemain kami. <br><br>  Dalam Perselisihan, komunikasi suara dan video dimulai dengan memasukkan saluran suara atau panggilan.  Artinya, koneksi selalu diprakarsai oleh klien - ini mengurangi kompleksitas bagian klien dan server, dan juga meningkatkan toleransi kesalahan.  Jika terjadi kegagalan infrastruktur, peserta dapat menyambung kembali ke server internal baru. <br><br><h3>  Di bawah kendali kami </h3><br>  Kontrol perpustakaan asli memungkinkan Anda untuk mengimplementasikan beberapa fungsi secara berbeda dari pada implementasi browser WebRTC. <br><br>  Pertama, WebRTC mengandalkan Session Description Protocol ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDP</a> ) untuk menegosiasikan audio / video antara peserta (hingga 10 KB per pertukaran paket).  Di perpustakaannya sendiri, API tingkat rendah dari WebRTC ( <code>webrtc::Call</code> ) digunakan untuk membuat aliran - masuk dan keluar.  Ketika terhubung ke saluran suara, ada pertukaran informasi yang minimal.  Ini adalah alamat dan port server backend, metode enkripsi, kunci, codec dan identifikasi aliran (sekitar 1000 byte). <br><br><pre> <code class="cpp hljs">webrtc::<span class="hljs-function"><span class="hljs-function">AudioSendStream* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAudioSendStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ssrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payloadType, webrtc::Transport* transport, rtc::scoped_refptr&lt;webrtc::AudioEncoderFactory&gt; audioEncoderFactory, webrtc::Call* call)</span></span></span><span class="hljs-function"> </span></span>{ webrtc::AudioSendStream::Config config{transport}; config.rtp.ssrc = ssrc; config.rtp.extensions = {{<span class="hljs-string"><span class="hljs-string">"urn:ietf:params:rtp-hdrext:ssrc-audio-level"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}}; config.encoder_factory = audioEncoderFactory; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webrtc::SdpAudioFormat kOpusFormat = {<span class="hljs-string"><span class="hljs-string">"opus"</span></span>, <span class="hljs-number"><span class="hljs-number">48000</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; config.send_codec_spec = webrtc::AudioSendStream::Config::SendCodecSpec(payloadType, kOpusFormat); webrtc::AudioSendStream* audioStream = call-&gt;CreateAudioSendStream(config); audioStream-&gt;Start(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> audioStream; }</code> </pre> <br>  Selain itu, WebRTC menggunakan Interactive Connectivity Establishment ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICE</a> ) untuk menentukan rute terbaik antara peserta.  Karena kami memiliki setiap klien yang terhubung ke server, kami tidak perlu ICE.  Ini memungkinkan Anda untuk menyediakan koneksi yang jauh lebih andal jika Anda berada di belakang NAT, dan juga merahasiakan alamat IP Anda dari peserta lain.  Klien secara berkala melakukan ping agar firewall mempertahankan koneksi terbuka. <br><br>  Akhirnya, WebRTC menggunakan Protokol Transport Real-time Aman ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SRTP</a> ) untuk mengenkripsi media.  Kunci enkripsi diatur menggunakan protokol Datagram Transport Layer Security ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DTLS</a> ) berdasarkan TLS standar.  Pustaka WebRTC bawaan memungkinkan Anda untuk mengimplementasikan lapisan transport Anda sendiri menggunakan <code>webrtc::Transport</code> API. <br><br>  Alih-alih DTLS / SRTP, kami memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">enkripsi Salsa20</a> lebih cepat.  Selain itu, kami tidak mengirim data audio selama periode hening - kejadian umum, terutama di ruang obrolan besar.  Ini mengarah pada penghematan yang signifikan dalam bandwidth dan sumber daya CPU, namun, baik klien dan server harus siap kapan saja untuk berhenti menerima data dan menulis ulang nomor seri paket audio / video. <br><br>  Karena aplikasi web menggunakan implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API WebRTC</a> berbasis web, SDP, ICE, DTLS, dan SRTP tidak dapat diabaikan.  Klien dan server bertukar semua informasi yang diperlukan (kurang dari 1200 byte saat bertukar paket) - dan sesi SDP dibuat berdasarkan informasi ini untuk klien.  Backend bertanggung jawab untuk menyelesaikan perbedaan antara aplikasi desktop dan browser. <br><br><h1>  Arsitektur backend </h1><br>  Ada beberapa layanan obrolan suara di backend, tetapi kami akan fokus pada tiga: Discord Gateway, Discord Guilds dan Discord Voice.  Semua server sinyal kami ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elixir</a> , yang memungkinkan kami untuk menggunakan kembali kode berulang kali. <br><br>  Saat Anda online, klien Anda mendukung koneksi WebSocket ke Discord Gateway (kami menyebutnya koneksi <i>gateway</i> WebSocket).  Melalui koneksi ini, klien Anda menerima acara yang terkait dengan grup dan saluran, pesan teks, paket kehadiran, dll. <br><br>  Saat terhubung ke saluran suara, status koneksi ditampilkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek</a> status suara.  Klien memperbarui objek ini melalui koneksi gateway. <br><br><pre> <code class="hljs pgsql">defmodule VoiceStates.VoiceState <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> t :: %{ session_id: String.t(), user_id: Number.t(), channel_id: Number.t() | nil, token: String.t() | nil, mute: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, deaf: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_mute: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_deaf: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_video: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, suppress: <span class="hljs-type"><span class="hljs-type">boolean</span></span> } defstruct session_id: nil, user_id: nil, token: nil, channel_id: nil, mute: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, deaf: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_mute: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_deaf: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_video: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, suppress: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Saat terhubung ke saluran suara, Anda ditugaskan ke salah satu server Voice Discord.  Dia bertanggung jawab untuk mentransmisikan suara ke setiap peserta di saluran.  Semua saluran suara dalam grup ditugaskan ke satu server.  Jika Anda yang pertama mengobrol, server Perselisihan Perselisihan bertanggung jawab untuk menetapkan server Suara Perselisihan untuk seluruh grup menggunakan proses yang dijelaskan di bawah ini. <br><br><h3>  Perselisihan Tujuan Server Suara </h3><br>  Setiap server Discord Voice secara berkala melaporkan status dan pemuatannya.  Informasi ini ditempatkan dalam sistem penemuan layanan (kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">etcd</a> ), seperti yang dibahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br><br>  Server Discord Guilds memonitor sistem penemuan layanan dan memberikan grup Discord Voice server yang paling sedikit digunakan di wilayah tersebut.  Ketika dipilih, semua objek status suara (juga didukung oleh server Discord Guilds) ditransfer ke server Voice Discord sehingga dapat mengkonfigurasi penerusan audio / video.  Klien diberi tahu server Discord Voice yang dipilih.  Kemudian klien membuka koneksi WebSocket <i>kedua</i> dengan server suara (kami menyebutnya koneksi <i>suara</i> WebSocket), yang digunakan untuk mengonfigurasi penerusan multimedia dan indikasi ucapan. <br><br>  Ketika klien menampilkan status <i>Endpoint Menunggu</i> , ini berarti bahwa server Discord Guilds sedang mencari server Voice Discord yang optimal.  Pesan <i>Voice Connected</i> menunjukkan bahwa klien telah berhasil menukar paket UDP dengan server Voice Discord yang dipilih. <br><br>  Server Suara Discord berisi dua komponen: modul sinyal dan unit relai multimedia, yang disebut unit penerusan selektif ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SFU</a> ).  Modul sinyal sepenuhnya mengontrol SFU dan bertanggung jawab untuk menghasilkan pengidentifikasi aliran dan kunci enkripsi, mengarahkan indikator bicara, dll. <br><br>  SFU kami (dalam C ++) bertanggung jawab untuk mengarahkan lalu lintas audio dan video antar saluran.  Ini dikembangkan sendiri: untuk kasus khusus kami, SFU memberikan kinerja maksimum dan, dengan demikian, penghematan terbesar.  Ketika moderator melanggar (membisukan server), paket audio mereka tidak diproses.  SFU juga berfungsi sebagai jembatan antara aplikasi asli dan berbasis browser: ia mengimplementasikan transportasi dan enkripsi untuk aplikasi browser dan asli, mengonversi paket selama transmisi.  Akhirnya, SFU bertanggung jawab untuk memproses protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTCP</a> , yang digunakan untuk mengoptimalkan kualitas video.  SFU mengumpulkan dan memproses laporan RTCP dari penerima - dan memberi tahu pengirim pita mana yang tersedia untuk transmisi video. <br><br><h1>  Toleransi kesalahan </h1><br>  Karena hanya server Voice Discord yang tersedia langsung dari Internet, kami akan membicarakannya. <br><br>  Modul sinyal terus memonitor SFU.  Jika crash, ia langsung restart dengan jeda minimum dalam layanan (beberapa paket hilang).  Status SFU dipulihkan oleh modul sinyal tanpa ada interaksi dengan klien.  Meskipun crash SFU jarang terjadi, kami menggunakan mekanisme yang sama untuk memperbarui SFU tanpa gangguan dalam layanan. <br><br>  Ketika server Voice Discord crash, itu tidak menanggapi ping - dan dihapus dari sistem penemuan layanan.  Klien juga melihat server crash karena koneksi suara WebSocket yang rusak, kemudian meminta <i>ping server suara</i> melalui koneksi gateway WebSocket.  Server Discord Guilds mengkonfirmasi kegagalan, berkonsultasi dengan sistem penemuan layanan, dan menetapkan server Voice Discord baru untuk grup.  Kelompok Perselisihan kemudian mengirim semua objek status suara ke server suara baru.  Semua klien menerima pemberitahuan tentang server baru dan terhubung ke sana untuk memulai pengaturan multimedia. <br><br><img src="https://habrastorage.org/webt/tw/1r/kz/tw1rkzplhbqsax95lajz9-ylluu.gif"><br><br>  Cukup sering, server Voice Discord berada di bawah DDoS (kita melihat ini dengan peningkatan cepat dalam paket IP yang masuk).  Dalam hal ini, kami melakukan prosedur yang sama seperti ketika server crash: kami menghapusnya dari sistem penemuan layanan, memilih server baru, mentransfer semua objek keadaan komunikasi suara ke sana dan memberi tahu klien tentang server baru.  Ketika serangan DDoS mereda, server kembali ke sistem penemuan layanan. <br><br>  Jika pemilik grup memutuskan untuk memilih wilayah baru untuk pemungutan suara, kami mengikuti prosedur yang sangat mirip.  Discord Guilds Server memilih server suara terbaik yang tersedia di wilayah baru dengan berkonsultasi dengan sistem penemuan layanan.  Kemudian dia menerjemahkan semua objek dari status komunikasi suara dan memberi tahu klien tentang server baru.  Klien memutus koneksi WebSocket saat ini dengan server Voice Discord lama dan membuat koneksi baru dengan server Voice Discord baru. <br><br><h1>  Scaling </h1><br>  Seluruh infrastruktur Discord Gateway, Discord Guilds dan Discord Voice mendukung penskalaan horizontal.  Discord Gateway dan Discord Guilds berfungsi di Google Cloud. <br><br>  Kami memiliki lebih dari 850 server suara di 13 wilayah (berlokasi di lebih dari 30 pusat data) di seluruh dunia.  Infrastruktur ini memberikan redundansi yang lebih besar jika terjadi kegagalan pada pusat data dan DDoS.  Kami bekerja dengan beberapa mitra dan menggunakan server fisik kami di pusat data mereka.  Baru-baru ini, wilayah Afrika Selatan telah ditambahkan.  Berkat upaya rekayasa dalam arsitektur klien dan server, Discord sekarang dapat secara bersamaan melayani lebih dari 2,6 juta pengguna obrolan suara dengan lalu lintas keluar lebih dari 220 Gbit / detik dan 120 juta paket per detik. <br><br><h1>  Apa selanjutnya </h1><br>  Kami terus memantau kualitas komunikasi suara (metrik dikirim dari sisi klien ke server backend).  Di masa depan, informasi ini akan membantu dalam deteksi otomatis dan penghapusan degradasi. <br><br>  Meskipun kami meluncurkan obrolan dan screencast video setahun yang lalu, tetapi sekarang mereka hanya dapat digunakan dalam pesan pribadi.  Dibandingkan dengan audio, video secara signifikan membutuhkan lebih banyak daya CPU dan bandwidth.  Tantangannya adalah menyeimbangkan jumlah bandwidth dan sumber daya CPU / GPU yang digunakan untuk memastikan kualitas video terbaik, terutama ketika sekelompok gamer dalam suatu saluran berada di perangkat yang berbeda.  Teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scalable Video Coding</a> (SVC), perpanjangan dari standar AVC H.264 / MPEG-4, dapat menjadi solusi untuk masalah tersebut. <br><br>  Screencasts bahkan membutuhkan bandwidth lebih banyak daripada video, karena FPS dan resolusi lebih tinggi daripada webcam konvensional.  Kami saat ini sedang mengerjakan dukungan untuk encoding video berbasis perangkat keras di aplikasi desktop. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423171/">https://habr.com/ru/post/id423171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423161/index.html">Bisnis menginginkan data pribadi</a></li>
<li><a href="../id423163/index.html">Menghubungkan CryptoPro ke Mono</a></li>
<li><a href="../id423165/index.html">Gambar jala dinamis dalam Mesin Unreal 4</a></li>
<li><a href="../id423167/index.html">Apa yang Mark Zuckerberg bicarakan tentang masalah Facebook. Hal utama dari artikel The New Yorker</a></li>
<li><a href="../id423169/index.html">Startup of the day (Juli-Agustus 2018)</a></li>
<li><a href="../id423173/index.html">Waktu minimum - nyeri maksimum</a></li>
<li><a href="../id423175/index.html">Mengapa menulis mesin gim Anda sendiri?</a></li>
<li><a href="../id423177/index.html">Buku Infrastruktur Keamanan Microsoft Azure</a></li>
<li><a href="../id423179/index.html">Buku Panduan Aplikasi Arsitektur Cloud</a></li>
<li><a href="../id423181/index.html">Buku Panduan Pengembang Azure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>