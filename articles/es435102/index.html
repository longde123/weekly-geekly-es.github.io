<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèΩ üèûÔ∏è ü•ì Un poco sobre an√°lisis l√©xico üë©üèø‚Äçü§ù‚Äçüë©üèª ü•Ç üè¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√ârase una vez, cuando el cielo era azul, la hierba era m√°s verde y los dinosaurios deambulaban por la Tierra ... No, olv√≠date de los dinosaurios. Buen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un poco sobre an√°lisis l√©xico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  √ârase una vez, cuando el cielo era azul, la hierba era m√°s verde y los dinosaurios deambulaban por la Tierra ... No, olv√≠date de los dinosaurios.  Bueno, en general, una vez surgi√≥ la idea de distraerme de la programaci√≥n web est√°ndar y hacer algo m√°s loco.  Podr√≠a, por supuesto, ser cualquier cosa, pero la elecci√≥n recay√≥ en escribir su propio int√©rprete.  ¬øQu√© puedo decir? <i>Nunca escriba sus propios lenguajes de programaci√≥n</i> .  Pero obtuve algo de experiencia de todo esto, as√≠ que decid√≠ compartirlo.  Comencemos con la base misma: el lexer. <br><a name="habracut"></a><br><h2>  Pr√≥logo </h2><br>  Antes de comenzar a comprender qu√© tipo de animal es "lexer", vale la pena averiguar de qu√© est√°n hechos los YaP. <br><br>  En el mundo moderno, cada compilador / int√©rprete / transpilador / algo similar (digamos simplemente "compilador" adicional, sin distinci√≥n entre tipos) se divide en dos partes.  En la terminolog√≠a de los t√≠os inteligentes, tales piezas se denominan "frontend" y "backend".  No, esto no es en absoluto lo que, cuando trabajamos con la web, lo que sol√≠amos llamar y el frente no est√° escrito en JS con HTML.  Aunque ... est√° bien. <br><br>  La tarea de la primera interfaz es tomar el <b>texto</b> y convertirlo en un <b>AST</b> (√°rbol de sintaxis abstracta), verificando la sintaxis (y a veces la sem√°ntica) en el camino.  La tarea del segundo backend es hacer que todo funcione.  Si el c√≥digo se ensambla dentro del int√©rprete, el AST crea un conjunto de instrucciones para el procesador virtual (m√°quina virtual), si el compilador, entonces el conjunto de instrucciones para el procesador real.  En la vida, todo es bastante m√°s complicado y puede que no se implemente de esa manera.  Por ejemplo, en el caso del compilador GCC, todo est√° mezclado, pero Clang ya es m√°s can√≥nico, LLVM es un representante t√≠pico del "backend" para compiladores. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  Ahora conozcamos una pieza llamada frontend. <br><br><h2>  An√°lisis l√©xico </h2><br>  La tarea del lexer y la etapa del an√°lisis l√©xico es obtener muchas, muchas letras en la entrada y agruparlas en algunas categor√≠as: "tokens".  Por lo tanto, el an√°lisis l√©xico tambi√©n se llama "tokenizaci√≥n".  Esta es la primera etapa del procesamiento de texto que produce cada compilador existente. <br><br>  Algo como esto: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  Por cierto, aqu√≠ ya hemos escrito un mont√≥n de herramientas para hacer la vida m√°s f√°cil.  Las mismas funciones <i>preg</i> que sol√≠amos usar para analizar el texto son bastante <i>capaces de</i> esta tarea.  Sin embargo, existen herramientas m√°s convenientes para este asunto: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phlexy</a> , escrita por Nikita Popov. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoa</a> es un kit de herramientas que consta de Lexer + Parser + Grammar. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Port Yacc</a> , escrito por Anthony Ferrara, que tambi√©n es un conjunto de herramientas completo, y en el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°</a> escrito el conocido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizador</a> Popov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP</a> , aplicable en herramientas que utilizan an√°lisis de c√≥digo. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Railt Lexer</a> mi implementaci√≥n para PHP 7.1+ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parle</a> es una extensi√≥n para PHP que permite un conjunto limitado de expresiones PCRE (sin anticipaci√≥n y otras construcciones de sintaxis). </li><li>  Y finalmente, la funci√≥n php est√°ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">token_get_all</a> , que est√° destinada directamente para el an√°lisis l√©xico de PHP. </li></ul><br>  Bueno, est√° claro que hay muchos artilugios que pueden dividir el texto por tokens, tal vez incluso olvid√© algo, como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Doctrine</a> lexer.  Pero que sigue? <br><br><h2>  Tipos de Lexers </h2><br>  Y como siempre, no todo es tan simple como parec√≠a.  Hay al menos dos categor√≠as diferentes de lexers.  Existe la opci√≥n habitual, bastante trivial, a la que deslizas las reglas, y ya divide todo en tokens.  La configuraci√≥n de los mismos no es muy diferente del ejemplo que he mostrado anteriormente.  Sin embargo, hay otra opci√≥n llamada <b>multiestado</b> .  Tales lexers son un poco m√°s dif√≠ciles de entender, por lo tanto, quiero hablar un poco m√°s sobre ellos. <br><br>  La tarea de un lexer multiestado es mostrar varios tokens dependiendo del estado anterior.  Bueno, por ejemplo, en PHP, tales estados de "transici√≥n" se forman usando las etiquetas &lt;? Php +?&gt;, L√≠neas internas, comentarios y construcciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NOWDOC</a> . <br><br>  ¬øRecuerdas el ejemplo anterior con 4 tokens anteriores?  Modif√≠quelo un poco para comprender cu√°les son estos estados: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  En este caso, si tenemos el lexer m√°s simple sin las amplias capacidades de PCRE, obtenemos el siguiente conjunto de tokens: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  Como puede ver, obtuvimos una jamba completamente banal en los elementos 3-5: el comentario se recibi√≥ de manera inesperada y se dividi√≥ en tokens, aunque deber√≠a haberse considerado como una pieza completa. <br><br>  Por supuesto, con el PCRE funcional, tal token podr√≠a ser arrancado con la ayuda de una simple regularidad " <i>// [^ \ n] * \ n</i> ", pero si no es as√≠?  ¬øO queremos cortarlo con nuestras manos?  En resumen, en el caso de un lexer multiestado, podemos decir que todos los tokens deber√≠an estar en el grupo <b>No1</b> , tan pronto como se encuentre el token " <i>//</i> ", entonces deber√≠a ocurrir una transici√≥n al grupo <b>No2</b> .  Y dentro del segundo grupo, la transici√≥n inversa, si se encuentra el token " <i>\ n</i> ", la transici√≥n de regreso al primer grupo. <br><br>  Algo como esto: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  Creo que ahora se est√° volviendo m√°s claro c√≥mo se analiza un poco de HEREDOC, porque incluso con todo el poder de PCRE, escribir un peri√≥dico para este caso es extremadamente problem√°tico, dado que esta sintaxis de HEREDOC admite interpolaci√≥n variable.  Solo intenta analizar algo como esto con la funci√≥n incorporada <i>token_get_all</i> (nota&gt; token 12): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Bueno, parece que estamos listos para comenzar a practicar. <br><br><h2>  Practica </h2><br>  ¬øRecordemos lo que tenemos en PHP para tales cosas?  Bueno, por supuesto, preg_match!  De acuerdo, baja.  El algoritmo basado en preg_match se implementa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoa</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en esta implementaci√≥n de Phelxy</a> .  Su tarea es bastante simple: <br><br><ol><li>  Tenemos a mano el texto fuente y una serie de clientes habituales. </li><li>  Emparejamos hasta que se encuentre algo adecuado. </li><li>  Tan pronto como encuentre una pieza, c√≥rtela del texto y combine m√°s. </li></ol><br>  En forma de c√≥digo, se ver√° m√°s o menos as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Hoja de c√≥digo</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Usando una hoja de c√≥digo</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Este enfoque es bastante trivial y permite que un par de pulsaciones del teclado modifiquen el lexer en la regi√≥n del m√©todo next (), agregando una transici√≥n entre estados y convirtiendo esta divisi√≥n de la masturbaci√≥n en un lexer multiestado primitivo.  En el √°rea <i>$ this-&gt; tokens,</i> simplemente agregue algo como <i>$ this-&gt; tokens [$ this-&gt; state]</i> . <br><br>  Sin embargo, adem√°s del primitivismo en s√≠, hay otro inconveniente, no fatal como podr√≠a resultar, pero a√∫n as√≠ ... Tal implementaci√≥n es incre√≠blemente lenta.  En el i7 7600k, cuyo propietario era por casualidad, un algoritmo similar procesa alrededor de 400 tokens por segundo y con un aumento en sus variaciones (es decir, las definiciones que pasamos al constructor), puede disminuir la velocidad de los presidentes cambiantes en Rusia ... ejem lo siento  Quer√≠a decir, por supuesto, que funcionar√° <b>muy lentamente</b> . <br><br>  Ok, que podemos hacer?  Para empezar, puedes entender lo que va mal.  El hecho es que cada vez que llamamos <b>preg_match</b> dentro de la naturaleza del lenguaje, surge un compilador con su JIT llamado PCRE (y con PHP 7.3, PCRE2 ya lo es).  Cada vez que analiza los clientes habituales y recopila un analizador para ellos, con el que analizamos el texto para crear tokens.  Suena un poco extra√±o y tautol√≥gico.  Pero en resumen, cada token requiere compilaci√≥n de 1 a N regulares, donde N es el n√∫mero de definiciones de estos tokens.  Al mismo tiempo, vale la pena se√±alar que incluso la bandera " <i>S</i> " aplicada y la optimizaci√≥n usando " <i>\ G</i> " en el constructor, donde se generan expresiones regulares para tokens, no ayudan. <br><br>  Solo hay una forma de salir de esta situaci√≥n: debe analizar todo este texto de una sola vez, es decir.  ejecutando solo una funci√≥n <b>preg_match</b> .  Queda por resolver dos problemas: <br><br><ol><li>  ¬øC√≥mo indicar que el resultado de la expresi√≥n regular N1 corresponde al token N2?  Es decir  c√≥mo indicar que " <i>\ w +</i> ", por ejemplo, es <i>T_CONST</i> . </li><li>  C√≥mo determinar la secuencia de tokens como resultado.  Como sabes, el resultado de <b>preg_match</b> o <b>preg_match_all</b> contendr√° todo mezclado.  E incluso con la ayuda de banderas aprobadas como el cuarto argumento, la situaci√≥n no cambiar√°. </li></ol><br>  Aqu√≠ puedes hacer una pausa y pensar un poco.  Bien o no. <br><br>  La soluci√≥n al primer problema se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">denomina grupos PCRE</a> , que tambi√©n se denominan "subm√°scaras".  Usando las reglas: " <i>(? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> " puede obtener todos los tokens en una pasada compar√°ndolos con sus nombres.  Como resultado de la coincidencia, se formar√° una matriz asociativa, que consta de los pares " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> ". <br><br>  El segundo es un poco m√°s complicado.  Pero aqu√≠ puede aplicar un truco t√°ctico y usar la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">preg_replace_callback</a> .  Su peculiaridad es que el an√≥nimo pasado como el segundo argumento se llamar√° estrictamente secuencialmente para cada token, desde el primero hasta el √∫ltimo. <br><br>  Para no languidecer, la implementaci√≥n es la siguiente: <br><br><div class="spoiler">  <b class="spoiler_title">Otra solapa de c√≥digo</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  Y su uso no es diferente de la versi√≥n anterior.  Al mismo tiempo, la velocidad de trabajo aumenta de <b>400</b> a <b>57,000</b> fichas por segundo.  Es este algoritmo el que apliqu√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en mi implementaci√≥n</a> , retomando la reescritura del c√≥digo fuente de Hoa.  Por cierto, si usa Parle, puede exprimir hasta <b>600,000</b> tokens por segundo.  Y la imagen general se ve m√°s o menos as√≠ (con XDebug activado en PHP 7.1, por lo que los n√∫meros son m√°s bajos, pero la proporci√≥n puede representarse aproximadamente). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  El amarillo es la extensi√≥n nativa de Parle. </li><li>  Azul: implementaci√≥n a trav√©s de <i>preg_replace_callback</i> con premontado regular. </li><li>  Rojo: de todos modos, pero con la <i>regularidad</i> generada durante la llamada a <i>preg_replace_callback</i> . </li><li>  Verde: implementaci√≥n a trav√©s de <i>preg_match</i> . </li></ul><br><h2>  Por qu√© </h2><br>  Bueno, todo esto, por supuesto, es maravilloso, pero los impacientes est√°n ansiosos por hacer la pregunta: "¬øQui√©n necesita esto?"  En el mundo abstracto de PHP, donde domina el principio de "fig-fig-and-site-ready": tales bibliotecas no son necesarias, seremos honestos.  Pero si hablamos del ecosistema como un todo, entonces podemos recordar las bibliotecas notorias como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symfony / Yaml</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Doctrine</a> .  Las anotaciones en Symfony son el mismo sub-lenguaje dentro de PHP, que requieren un an√°lisis l√©xico y sint√°ctico por separado.  Adem√°s, hay incluso transpiladores CoffeeScript, Less y Scss / Sass poco menos conocidos escritos en PHP.  Bueno, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yay</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">preprocese</a> basado en eso.  Ni siquiera mencionar√© herramientas de an√°lisis de c√≥digo como phpmd o phpcs.  Y los generadores de documentaci√≥n como phpDocumentnor o Sami son bastante triviales.  Cada uno de estos proyectos, en un grado u otro, utiliza el an√°lisis l√©xico en la primera etapa de an√°lisis de texto / c√≥digo. <br><br>  Esta no es una lista completa de proyectos y quiz√°s espero que mi historia lo ayude a descubrir algo nuevo y reponerlo. <br><br><h2>  Ep√≠logo </h2><br>  Mirando hacia el futuro, si hay alguien interesado en el tema de analizadores y compiladores, entonces hay algunos informes interesantes sobre este tema, en particular de los chicos de JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  A√∫n as√≠, por supuesto, la mayor√≠a de las actuaciones de Andrei Breslav ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">abreslav</a> ), que se pueden encontrar en la inmensidad de YouTube, te aconsejo que mires. <br><br>  Bueno, para los fan√°ticos de la ficci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">existe un recurso</a> que fue personalmente extremadamente √∫til para m√≠. <br><br>  Post post scriptum.  Si est√°s en alg√∫n lugar sellado en la inmensidad de esta epopeya, entonces puedes informar al autor de manera segura en cualquier forma conveniente para ti. <br><br>  Como beneficio adicional, me gustar√≠a dar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo de un simple PHP lexer</a> , parece que ahora no da tanto miedo, y ahora incluso est√° claro lo que hace, ¬øverdad?  Aunque a quien estoy enga√±ando, los ojos sangran de los habituales.  =) <br><br>  Gracias </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435102/">https://habr.com/ru/post/es435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435088/index.html">El gigante chino de streaming Tencent Music se convierte en IPO p√∫blica: ¬øqu√© significa y qu√© deben esperar los competidores?</a></li>
<li><a href="../es435090/index.html">Hyundai Motor Group introdujo el concepto de carga inal√°mbrica y estacionamiento aut√≥nomo</a></li>
<li><a href="../es435094/index.html">Gamepad de Sega Mega Drive y Raspberry Pi Parte 2 (seis botones finales)</a></li>
<li><a href="../es435096/index.html">El efecto de la radio de tubo caliente.</a></li>
<li><a href="../es435098/index.html">ADB vs Spy Cam & Mic</a></li>
<li><a href="../es435106/index.html">Una vez m√°s sobre passport.js</a></li>
<li><a href="../es435108/index.html">Usando Prolog</a></li>
<li><a href="../es435112/index.html">Entrevista corporativa</a></li>
<li><a href="../es435114/index.html">Spring data jpa</a></li>
<li><a href="../es435118/index.html">Save File Me: un servicio de copia de seguridad gratuito con cifrado del lado del cliente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>