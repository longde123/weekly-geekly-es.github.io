<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèΩ üö° üß¢ √úberpr√ºfen des OpenCvSharp Wrapper auf OpenCV mit PVS-Studio üßïüèΩ üë©üèº üïù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenCV ist eine Open-Source-Bibliothek mit Computer Vision- und Bildverarbeitungsalgorithmen sowie universellen numerischen Algorithmen. Die Bibliothe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfen des OpenCvSharp Wrapper auf OpenCV mit PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/473478/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/0s/oi/mr0soiovipbs1ma0roktme3nj1i.png" alt="Abbildung 2"></div><br>  OpenCV ist eine Open-Source-Bibliothek mit Computer Vision- und Bildverarbeitungsalgorithmen sowie universellen numerischen Algorithmen.  Die Bibliothek ist unter C ++ - Entwicklern bekannt.  Neben C ++ gibt es auch Versionen f√ºr Python, Java, Ruby, Matlab, Lua und andere Sprachen.  Da C #, die Sprache, auf die ich mich spezialisiert habe, nicht auf dieser Liste steht, habe ich OpenCvSharp, einen C # -Wrapper von OpenCV, ausgew√§hlt, um dies mit PVS-Studio zu √ºberpr√ºfen.  Die Ergebnisse dieser √úberpr√ºfung werden in diesem Artikel erl√§utert. <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Bevor ich Teil des PVS-Studio-Teams wurde, war ich an der Herstellung von Robotern beteiligt, die auf Ausstellungen pr√§sentiert werden sollten.  Zu meinen Aufgaben geh√∂rten die grundlegendsten Reparaturarbeiten (gr√∂√üere Fehler wurden von einer anderen Person behoben) sowie die Entwicklung von Software und Dienstprogrammen aller Art. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/s9/sk/p-/s9skp-nztgw-u2nt8j0dfuvae3m.png" alt="Abbildung 1"></div><br>  <i>Ich, m√ºde und neu in der Stadt, mit einem frisch ausgepackten KIKI-Roboter.</i> <br><br>  Der Entwicklungsteil war √ºbrigens ziemlich lustig.  Jedes Mal, wenn einer von uns eine Idee hatte, um die Ausstellungsbesucher zu √ºberraschen, brachten wir sie zur Diskussion, und wenn es allen gefiel, machten wir uns an die Arbeit.  Einmal kam uns der Gedanke, einen Roboter zu bauen, der ein menschliches Gesicht erkennen und mit einer Begr√º√üungsrede antworten konnte. <br><br>  Ich googelte nach einer Bibliothek f√ºr meine Bed√ºrfnisse und stie√ü auf OpenCV, eine Bibliothek mit Computer-Vision-Algorithmen.  Aber ich wurde sehr bald entt√§uscht, als ich herausfand, dass OpenCV in C ++ implementiert war.  Meine Kenntnisse in C ++, die ich am College studiert hatte, reichten offensichtlich nicht aus.  Also habe ich ein bisschen mehr gegoogelt und OpenCvSharp gefunden, einen Wrapper der Bibliothek f√ºr C #, die Sprache, auf die ich mich spezialisiert habe.  Seitdem ist ungef√§hr ein halbes Jahr vergangen, das Programm wurde lange geschrieben und verwendet, und jetzt habe ich mich endlich entschlossen, "unter die Haube" von OpenCvSharp zu schauen und seinen Quellcode mit dem statischen Analysator PVS-Studio zu scannen. <br><br><h2>  Das zu analysierende Projekt </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCvSharp</a> ist ein OpenCV-Wrapper zur Verwendung in C # -Projekten.  √úbrigens haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir</a> OpenCV bereits in der Vergangenheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberpr√ºft</a> .  Die St√§rken von OpenCvSharp sind die gro√üe Sammlung von Codebeispielen, die plattform√ºbergreifende Unterst√ºtzung (die auf jeder von Mono unterst√ºtzten Plattform ausgef√ºhrt werden kann) und die einfache Installation. <br><br>  Der Wrapper ist ein kleines Projekt mit etwa 112.200 Zeilen C # -Code.  1,2% davon sind Kommentare, die, wie ich sagen sollte, verd√§chtig wenige sind.  Auf der anderen Seite gibt es einige Fehler f√ºr ein so kleines Projekt.  Ich habe √ºber 20 Beispiele f√ºr diesen Artikel ausgew√§hlt, aber der Analysator hat tats√§chlich viele weitere gefunden, die nicht so interessant oder offensichtlich sind. <br><br><h2>  PVS-Studio </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> ist ein Tool zum Erkennen von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # und Java geschrieben wurden.  Es l√§uft unter Windows, Linux und MacOS.  Neben nicht erreichbarem Code, Programmierfehlern und Tippfehlern kann PVS-Studio, wie bereits erw√§hnt, potenzielle Sicherheitsprobleme erkennen.  Daher kann es als SAST-Tool (Static Application Security Testing) angesehen werden. <br><br><h2>  Die interessantesten Warnungen </h2><br>  Das Besondere an der <i>WriteableBitmapConverter-</i> Methode ist, dass vier Warnungen desselben Typs gleichzeitig ausgel√∂st wurden: <br><br><ul><li>  V3005 Die Variable 'optimumChannels [PixelFormats.Indexed1]' wird sich selbst zugewiesen.  WriteableBitmapConverter.cs 22 </li><li>  V3005 Die Variable 'optimumChannels [PixelFormats.Indexed8]' wird sich selbst zugewiesen.  WriteableBitmapConverter.cs 23 </li><li>  V3005 Die Variable 'optimumTypes [PixelFormats.Indexed1]' wird sich selbst zugewiesen.  WriteableBitmapConverter.cs 50 </li><li>  V3005 Die Variable 'optimumTypes [PixelFormats.Indexed8]' wird sich selbst zugewiesen.  WriteableBitmapConverter.cs 51 </li></ul><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteableBitmapConverter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { optimumChannels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary &lt;PixelFormat, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); optimumChannels[PixelFormats.Indexed1] = <span class="hljs-comment"><span class="hljs-comment">// &lt;= optimumChannels[PixelFormats.Indexed8] = // &lt;= optimumChannels[PixelFormats.Gray2] = optimumChannels[PixelFormats.Gray4] = optimumChannels[PixelFormats.Gray8] = optimumChannels[PixelFormats.Gray16] = optimumChannels[PixelFormats.Gray32Float] = optimumChannels[PixelFormats.Indexed1] = // &lt;= optimumChannels[PixelFormats.Indexed2] = optimumChannels[PixelFormats.Indexed4] = optimumChannels[PixelFormats.Indexed8] = // &lt;= .... optimumTypes = new Dictionary &lt;PixelFormat, MatType&gt;(); optimumTypes[PixelFormats.Indexed1] = // &lt;= optimumTypes[PixelFormats.Indexed8] = // &lt;= optimumTypes[PixelFormats.Gray2] = optimumTypes[PixelFormats.Gray4] = optimumTypes[PixelFormats.Gray8] = optimumTypes[PixelFormats.Indexed1] = // &lt;= optimumTypes[PixelFormats.Indexed2] = optimumTypes[PixelFormats.Indexed4] = optimumTypes[PixelFormats.Indexed8] = // &lt;= optimumTypes[PixelFormats.BlackWhite] = .... } .... public static class PixelFormats { .... public static PixelFormat Indexed8 { get; } .... public static PixelFormat Indexed1 { get; } .... }</span></span></code> </pre> <br>  Die <i>PixelFormats-</i> Klasse wird im <i>System.Windows.Media-</i> Namespace definiert und ist eine Sammlung verschiedener Pixelformate.  Der Analysator weist darauf hin, dass den Elementen <i>optimumChannels [PixelFormats.Indexed1]</i> und <i>optimumChannels [PixelFormats.Indexed8]</i> in der <i>WriteableBitmapConverter-</i> Methode zum zweiten Mal Werte zugewiesen werden, was keinen Sinn ergibt.  Es ist unklar, ob dies nur ein Tippfehler ist oder der Programmierer etwas anderes gemeint hat.  √úbrigens ist dieses Snippet ein anschauliches Beispiel daf√ºr, wie hilfreich statische Analyseger√§te sein k√∂nnen: Wenn Sie sich eine Reihe √§hnlicher Zeilen ansehen, werden Sie weniger fokussiert - kein Wunder, dass Tippfehler trotz der Code√ºberpr√ºfung unbemerkt bleiben.  Statische Analyseger√§te haben jedoch keine Probleme, die Aufmerksamkeit aufrechtzuerhalten, und sie ben√∂tigen keine Ruhe, sodass sie solche Fehler ohne Anstrengung erkennen k√∂nnen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/1g/ok/vg/1gokvgep_oiqjqsqy9btoh3nncg.png" alt="Abbildung 5"></div><br>  <i>F√ºhle die Macht der statischen Analyse.</i> <br><br>  <b>PVS-Studio-Diagnosemeldung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3021</a> Es gibt zwei if-Anweisungen mit identischen bedingten Ausdr√ºcken.  Die erste 'if'-Anweisung enth√§lt die Methodenr√ºckgabe.  Dies bedeutet, dass die zweite 'if'-Anweisung sinnlos ist. InputArray.cs 394 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MatType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EstimateType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type t</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Vec2b)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MatType.CV_8UC2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Vec3b)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MatType.CV_8UC3; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Vec4b)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MatType.CV_8UC4; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Vec6b)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MatType.CV_8UC(<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Vec2s)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return MatType.CV_16SC2; .... if (t == typeof(Vec2s)) // &lt;= return MatType.CV_32SC2; .... }</span></span></code> </pre> <br>  Dieser Fehler √§hnelt dem vorherigen.  Der Entwickler √ºberpr√ºft denselben Zustand zweimal.  Es macht hier keinen Sinn, da der then-Zweig der "duplicate" <i>if-</i> Anweisung niemals ausgef√ºhrt wird, weil: <br><br><ul><li>  Wenn die erste Bedingung erf√ºllt ist, gibt die Methode zur√ºck. </li><li>  Wenn die erste Bedingung falsch ist, ist auch die zweite falsch, da sich die zu pr√ºfende Variable <i>t</i> zwischen den beiden Pr√ºfungen nicht √§ndert. </li></ul><br>  Dieser Code muss √ºberarbeitet werden.  Es ist sehr wahrscheinlich, dass die zweite Kopie von <i>Vec2s</i> tats√§chlich eine andere Variable sein sollte. <br><br>  <b>PVS-Studio-Diagnosemeldung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3010</a> Der R√ºckgabewert der Funktion 'ToString' muss verwendet werden.  ImgProcTest.cs 80 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RectanglesIntersectTypes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotatedRectangleIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RotatedRect rect1, RotatedRect rect2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point2f[] intersectingRegion</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intersectingRegionVec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorOfPoint2f()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = NativeMethods .imgproc_rotatedRectangleIntersection_vector( rect1, rect2, intersectingRegionVec.CvPtr); intersectingRegion = intersectingRegionVec.ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (RectanglesIntersectTypes) ret; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotatedRectangleIntersectionVector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotatedRect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point2f(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size2f(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotatedRect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point2f(<span class="hljs-number"><span class="hljs-number">130</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size2f(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); Cv2.RotatedRectangleIntersection(rr1, rr2, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intersectingRegion); .... intersectingRegion.ToString(); }</code> </pre> <br>  Auf die <i>RotatedRectangleIntersection-</i> Methode wird √ºber den Parameter <i>intersectingRegion</i> zugegriffen, und es wird ein Array von Elementen vom Typ <i>Point2f zur√ºckgegeben</i> .  Sobald die <i>intersectingRegion</i> mit Werten gef√ºllt wurde, wird die <i>ToString ()</i> -Methode f√ºr das Array aufgerufen.  Dies wirkt sich in keiner Weise auf die Elemente des Arrays aus, und in der letzten Zeile werden keine n√ºtzlichen Arbeiten ausgef√ºhrt. Es ist daher fair anzunehmen, dass der Entwickler einfach vergessen hat, dieses Teil zu entfernen. <br><br>  <b>PVS-Studio-Diagnosemeldungen:</b> <br><br><ul><li>  V3021 Es gibt zwei 'if'-Anweisungen mit identischen bedingten Ausdr√ºcken.  Die erste 'if'-Anweisung enth√§lt die Methodenr√ºckgabe.  Dies bedeutet, dass die zweite 'if'-Anweisung sinnlos ist. Cv2_calib3d.cs 1370 </li><li>  V3022 Der Ausdruck 'objectPoints == null' ist immer falsch.  Cv2_calib3d.cs 1372 </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalibrateCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objectPoints == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(objectPoints)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objectPoints == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(objectPoints)); .... }</code> </pre> <br>  Wir haben hier Code geklont, daher die beiden Warnungen.  Der erste besagt, dass beide <i>if-</i> Anweisungen dieselbe Bedingung pr√ºfen.  Wenn diese Bedingung erf√ºllt ist, wird die Methode in der then-Verzweigung der ersten <i>if-</i> Anweisung zur√ºckgegeben.  Folglich wird die zweite Bedingung immer falsch sein, was uns die zweite Warnung sagt.  Es scheint, dass der Programmierer dieses Fragment mit Copy-Paste geklont hat, aber vergessen hat, es zu √§ndern. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/cy/db/s1/cydbs1dussvael3m4ihcmwdfw4y.png" alt="Abbildung 6"></div><br><br>  <i>Nettes Kopieren-Einf√ºgen.</i> <br><br>  Andere Warnungen dieses Typs: <br><br><ul><li>  V3021 Es gibt zwei 'if'-Anweisungen mit identischen bedingten Ausdr√ºcken.  Die erste 'if'-Anweisung enth√§lt die Methodenr√ºckgabe.  Dies bedeutet, dass die zweite 'if'-Anweisung sinnlos ist. Cv2_calib3d.cs 1444 </li><li>  V3022 Der Ausdruck 'objectPoints == null' ist immer falsch.  Cv2_calib3d.cs 1446 </li></ul><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'label == MarkerValue' ist immer falsch.  Labeller.cs 135 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Labeller</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MarkerValue = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mat img, CvBlobs blobs</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> label = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastLabel = <span class="hljs-number"><span class="hljs-number">0</span></span>; CvBlob lastBlob = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; h; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; w; x++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imgIn[x + y * step] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> labeled = labels[y, x] != <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { labeled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Label contour. label++; if (label == MarkerValue) // &lt;= throw new Exception(); .... } .... } .... } } }</span></span></code> </pre> <br>  Eine Variable mit dem Namen <i>label</i> wird erstellt und auf 0 initialisiert. Wenn eine bestimmte Bedingung erf√ºllt ist, wird sie um eins erh√∂ht.  Dar√ºber hinaus wird diese Variable in diesem Snippet nie dekrementiert.  Daher macht es keinen Sinn, die Konstante -1 zu √ºberpr√ºfen, wie in der Zeile, auf die der Analysator zeigt. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3038</a> Das Argument wurde mehrmals an die Methode √ºbergeben.  Es ist m√∂glich, dass stattdessen ein anderes Argument √ºbergeben wird.  Cv2_photo.cs 124 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FastNlMeansDenoisingMulti</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... NativeMethods.photo_fastNlMeansDenoisingMulti( srcImgPtrs, srcImgPtrs.Length, dst.CvPtr, imgToDenoiseIndex, templateWindowSize, h, templateWindowSize, searchWindowSize); .... }</code> </pre> <br>  Um zu verstehen, was der Analysator uns sagt, werfen wir einen Blick auf die Parameter der <i>photo_fastNlMeansDenoisingMulti-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">photo_fastNlMeansDenoisingMulti</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr[] srcImgs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcImgsLength, IntPtr dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imgToDenoiseIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> temporalWindowSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> templateWindowSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> searchWindowSize</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Vereinfachen wir es noch weiter, um es ganz einfach zu machen.  Vergleichen Sie diese Zeilen: <br><br><pre> <code class="cs hljs">NativeMethods.photo_fastNlMeansDenoisingMulti( .... templateWindowSize, .... templateWindowSize, ....); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">photo_fastNlMeansDenoisingMulti</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> temporalWindowSize, .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> templateWindowSize, ....</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Die Variable <i>templateWindowSize</i> wird zweimal deklariert, aber das erste Mal, wenn sie erw√§hnt wird, sollte tats√§chlich die Deklaration von <i>temporalWindowSize sein</i> .  Eine andere Sache, die dem Analysator nicht gefallen hat, ist, dass der Wert von <i>temporalWindowSize</i> in der <i>photo_fastNlMeansDenoisingMulti-</i> Methode √ºberhaupt nicht verwendet wird.  Dies k√∂nnte eine bewusste Entscheidung sein, aber ich w√ºrde mir diesen Code genauer ansehen, wenn ich der Autor w√§re. <br><br>  Andere Warnungen dieses Typs: <br><br><ul><li>  V3038 Das Argument wurde mehrmals an method √ºbergeben.  Es ist m√∂glich, dass stattdessen ein anderes Argument √ºbergeben wird.  Cv2_photo.cs 149 </li><li>  V3038 Das Argument wurde mehrmals an method √ºbergeben.  Es ist m√∂glich, dass stattdessen ein anderes Argument √ºbergeben wird.  Cv2_photo.cs 180 </li><li>  V3038 Das Argument wurde mehrmals an method √ºbergeben.  Es ist m√∂glich, dass stattdessen ein anderes Argument √ºbergeben wird.  Cv2_photo.cs 205 </li></ul><br>  Das n√§chste Beispiel ist dem vorherigen etwas √§hnlich. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3066</a> M√∂glicherweise falsche Reihenfolge der an die Methode 'calib3d_Rodrigues_MatToVec' √ºbergebenen Argumente: 'matrixM.CvPtr' und 'vectorM.CvPtr'.  Cv2_calib3d.cs 86 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rodrigues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] vector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] jacobian</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jacobianM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;()) { NativeMethods.calib3d_Rodrigues_MatToVec (matrixM.CvPtr, vectorM.CvPtr, jacobianM.CvPtr); .... } }</code> </pre> <br>  Schauen wir uns die Parameter der <i>calib3d_Rodrigues_MatToVec-</i> Methode an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calib3d_Rodrigues_MatToVec</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr vector, IntPtr matrix, IntPtr jacobian</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Es scheint, dass die Methode <i>calib3d_Rodrigues_MatToVec</i> aufgerufen wird, wobei die Argumente <i>matrixM.CvPtr</i> und <i>vectorM.CvPtr</i> versehentlich ausgetauscht wurden.  Die Autoren sollten dieses Snippet √ºberpr√ºfen: M√∂glicherweise liegt ein Fehler vor, der die korrekte Berechnung behindert. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3063</a> Ein Teil des bedingten Ausdrucks ist immer falsch, wenn er ausgewertet wird: data == null.  Mat.cs 3539 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckArgumentsForConvert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(data)); MatType t = Type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || (data.Length * dataDimension) <span class="hljs-comment"><span class="hljs-comment">// &lt;= (data.Length * dataDimension) % t.Channels != 0) .... }</span></span></code> </pre> <br>  Der Analysator meldet, dass die zweiten Pr√ºfdaten <i>== null</i> niemals <i>wahr sind,</i> da eine Ausnahme ausgel√∂st wird und die Ausf√ºhrung niemals die zweite Pr√ºfung erreicht, wenn die <i>Daten</i> in der ersten Bedingung gleich <i>null sind</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/b1/xf/c1b1xfih5imz4n4cifsucaqzrrw.png" alt="Abbildung 7"></div><br>  <i>Ich wei√ü, dass du m√ºde bist, aber wir sind fast fertig.</i> <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3127</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und anstelle von 'src2' Cv2_imgproc.cs 1547 sollte die Variable 'window' verwendet werden <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point2d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhaseCorrelateRes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(src1)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(src2)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(src2)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Der Analysator hat in diesem Ausschnitt einen Tippfehler entdeckt.  Die Variablen werden auf <i>null</i> gepr√ºft, und wenn dies der Fall ist, l√∂st jede Pr√ºfung eine Ausnahme aus.  Es funktioniert jedoch nicht ganz richtig f√ºr die <i>Fenstervariable</i> .  Wenn sein Wert gleich <i>null ist</i> , wird auch eine entsprechende Ausnahme ausgel√∂st, jedoch mit dem falschen Text.  Es wird kein <i>Fenster erw√§hnt</i> ;  es wird stattdessen <i>src2 sein</i> .  Die Bedingung sollte anscheinend wie folgt ge√§ndert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(window));</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3142</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  MatOfT.cs 873 <br><br>  Schauen wir uns zur Abwechslung einmal den Fall an, in dem der Analysator in Bezug auf nicht erreichbaren Code technisch korrekt ist, aber tats√§chlich kein Fehler vorliegt.  Es ist eine Warnung, die gleichzeitig als wahr und falsch bezeichnet werden kann. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new Mat&lt;TElem&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubMat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Range[] ranges</span></span></span><span class="hljs-function">)</span></span> { Mat result = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.SubMat(ranges); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Wrap(result); }</code> </pre> <br>  Der Analysator teilt uns mit, dass die <i>return-</i> Anweisung nicht erreichbar ist.  Schauen wir uns den Hauptteil der <i>SubMat-</i> Methode an, um <i>festzustellen</i> , ob der Analysator die Wahrheit sagt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubMat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Range[] ranges</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); <span class="hljs-comment"><span class="hljs-comment">/* if (ranges == null) throw new ArgumentNullException(); ThrowIfDisposed(); CvSlice[] slices = new CvSlice[ranges.Length]; for (int i = 0; i &lt; ranges.Length; i++) { slices[i] = ranges[i]; } IntPtr retPtr = NativeMethods.core_Mat_subMat1(ptr, ranges.Length, ranges); Mat retVal = new Mat(retPtr); return retVal;*/</span></span> }</code> </pre> <br>  Wie Sie sehen k√∂nnen, ist die Funktion derzeit unvollst√§ndig und l√∂st immer eine Ausnahme aus.  Der Analysator weist absolut korrekt auf den nicht erreichbaren Code hin - aber es ist kein echter Fehler. <br><br>  Die n√§chsten drei Fehler sind vom gleichen Typ, aber sie sind so cool, dass ich nicht anders konnte, als alle drei einzuschlie√üen. <br><br>  <b>PVS-Studio-Diagnosemeldung: Der</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022-</a> Ausdruck 'String.IsNullOrEmpty ("winName")' ist immer falsch.  Cv2_highgui.cs 46 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> winName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(<span class="hljs-string"><span class="hljs-string">"winName"</span></span>)) .... }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'string.IsNullOrEmpty ("fileName")' ist immer falsch.  FrameSource.cs 37 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FrameSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFrameSource_Video</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(<span class="hljs-string"><span class="hljs-string">"fileName"</span></span>)) .... }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'string.IsNullOrEmpty ("fileName")' ist immer falsch.  FrameSource.cs 53 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FrameSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFrameSource_Video_CUDA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(<span class="hljs-string"><span class="hljs-string">"fileName"</span></span>)) .... }</code> </pre> <br>  Manchmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deuten V3022-</a> Warnungen (√ºber immer wahre / falsche Ausdr√ºcke) auf wirklich seltsame oder lustige Fehler hin.  Alle drei obigen Beispiele haben den gleichen Fehler.  Die Methode verf√ºgt √ºber einen Parameter vom Typ <i>string,</i> dessen Wert √ºberpr√ºft werden muss.  Stattdessen wird jedoch ein Zeichenfolgenliteral √ºberpr√ºft, dessen Text der Name der Variablen ist, d. H. Der Name der Variablen in Anf√ºhrungszeichen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/rr/fm/mkrrfmqeimdl5l_osrff2p-ime4.png" alt="Abbildung 18"></div><br>  Der Programmierer muss einmal einen fehlerhaften Codeblock geschrieben und ihn dann durch Kopieren und Einf√ºgen geklont haben. <br><br><h2>  Fazit </h2><br>  Die Entwickler von OpenCvSharp haben einen gro√üen und wichtigen Job gemacht, und als Benutzer ihrer Bibliothek bin ich daf√ºr absolut dankbar.  Danke Jungs! <br><br>  Aber jetzt, da ich Teil des PVS-Studio-Teams geworden bin und den Code der Bibliothek gesehen habe, muss ich sagen, dass dem Qualit√§tsaspekt nicht die richtige Aufmerksamkeit geschenkt wurde.  Das Projekt sieht nicht so aus, als w√ºrde eines regelm√§√üig mit statischen Analyseger√§ten √ºberpr√ºft, und viele der Fehler werden anscheinend mit teureren Techniken (wie Tests oder Benutzerfeedback) behoben, und einige der Fehler leben einfach weiter im Code und es sind sie das fangen wir mit unserem analyzer.  Dieses Thema wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem kleinen Beitrag</a> zur Philosophie der statischen Analyse ausf√ºhrlicher behandelt. <br><br>  Da OpenCvSharp Open Source ist und auf GitHub frei verf√ºgbar ist, k√∂nnen seine Autoren eine der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen Lizenzoptionen</a> f√ºr PVS-Studio verwenden, um es regelm√§√üig zu verwenden. <br><br>  Danke f√ºrs Lesen.  Z√∂gern Sie nicht, eine Testversion von PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterzuladen</a> , um Ihre eigenen Projekte zu √ºberpr√ºfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473478/">https://habr.com/ru/post/de473478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473456/index.html">Die letzte Grenze der Verteidigungs-Qualit√§tssicherung: automatische Fehlererkennung</a></li>
<li><a href="../de473460/index.html">Zur Frage der Mathematik</a></li>
<li><a href="../de473462/index.html">Sicherheitswoche 44: NordVPN, TorGuard und Half Hack</a></li>
<li><a href="../de473468/index.html">Bayes-Theorem verstehen</a></li>
<li><a href="../de473476/index.html">√úberpr√ºfen des OpenCvSharp-Wrappers √ºber OpenCV mit PVS-Studio</a></li>
<li><a href="../de473482/index.html">Die Erfolge der saudischen Kampagne, Halloween-PR und ein bisschen √ºber Werbekampagnen von Japan Airlines</a></li>
<li><a href="../de473484/index.html">C ++ - Kurs im CS Center, zweiter Teil</a></li>
<li><a href="../de473488/index.html">Plattform√ºbergreifende Navigation: Warum NavController Angular / Router in Ionic 4 besiegt hat</a></li>
<li><a href="../de473490/index.html">Warum Spitzenphysiker die Stringtheorie lieben</a></li>
<li><a href="../de473500/index.html">Anwendung auf TSD und Kommunikation mit 1C: Enterprise 8.3 √ºber HTTP-Service. Teil 1 (Auswahl einer Austauschmethode. Beschreibung der API)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>