<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖊️ 👨🏾‍🚀 👨‍👦 Cara melakukan transaksi BTC tanpa menyetor koin kecil ⬜️ 👩🏾‍⚖️ 🦊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak dompet bitcoin ketika memilih koin untuk dikirim lebih suka menggunakan koin besar, saldo yang lebih besar dari jumlah yang dikirim. Setelah se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara melakukan transaksi BTC tanpa menyetor koin kecil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465041/"><p><img src="https://habrastorage.org/webt/fn/ez/kn/fnezknn373mov5izqcr1u0nppfk.png" alt="Tujuan: mengemas barang-barang berharga sejauh mungkin dalam ransel, asalkan kapasitas ransel terbatas"></p><br><p> Banyak dompet bitcoin ketika memilih koin untuk dikirim lebih suka menggunakan koin besar, saldo yang lebih besar dari jumlah yang dikirim.  Setelah setiap transaksi tersebut, koin perubahan terbentuk.  Setelah beberapa waktu, seluruh dompet ditumbuhi dengan koin seperti itu dari urutan 0,001 (~ $ 10 saat ini), yang sudah tidak ada lagi untuk dibelanjakan.  Ketika, sekali lagi, saya perlu melakukan transaksi, terpikir oleh saya apakah mungkin untuk mengumpulkan transaksi sehingga tidak ada perubahan.  Dompet itu dengan keras kepala menawarkan untuk "memotong" koin lain yang lebih besar, jadi saya memutuskan untuk mengambil koin dengan tangan saya untuk mengumpulkan jumlah yang diperlukan.  Namun, ini ternyata tidak sesederhana itu: jumlahnya ternyata kurang dari nilai yang diinginkan atau terlampau banyak.  Akibatnya, saya memutuskan bahwa harus ada algoritma yang dengannya Anda dapat mengumpulkan jumlah yang diinginkan dari koin atau lebih sedikit.  Ternyata ini tidak hanya mungkin, tetapi bekerja dengan sangat baik yang membuat saya menulis artikel ini.  Tetapi hal pertama yang pertama. </p><a name="habracut"></a><br><h2 id="zadacha-o-ryukzake">  Masalah ransel </h2><br><p>  Masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ransel</a> diketahui secara luas: untuk mengemas barang-barang berharga sebanyak mungkin ke dalam ransel, asalkan kapasitas ransel terbatas.  Dalam hal ini, kami memiliki kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah ransel 0-1</a> , karena setiap item (koin) tersedia untuk dikemas dalam ransel hanya sekali.  Selain itu, bobot masing-masing "item" bertepatan dengan nilainya, jadi kita berhadapan dengan kasus yang lebih khusus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah jumlah himpunan bagian dari himpunan bagian</a> .  Wikipedia menyarankan menggunakan algoritma genetika, tetapi saya memutuskan untuk mencari solusi yang tepat menggunakan pemrograman dinamis, karena ini cukup dapat dicapai dalam hal sumber daya dan terlihat sederhana. </p><br><p>  Untuk mengurangi masalah memilih koin untuk tugas ransel, Anda perlu melakukan sedikit konversi data input.  Faktanya adalah bahwa menyelesaikan masalah ransel (lebih tepatnya, jumlah himpunan bagian) akan memberi kita bagian dari himpunan asli yang memiliki jumlah maksimum tidak melebihi parameter (kapasitas pembawa ransel).  Tetapi kami tidak puas dengan kombinasi koin, memberikan jumlah yang kurang dari jumlah yang ingin kami kirim.  Namun, kami merasa nyaman dengan kombinasi yang sedikit lebih unggul.  Misalnya, jika kami perlu mengirim 0,005 bitcoin, dan kami menemukan kombinasi yang memberi 0,00499, maka itu tidak berguna bagi kami, karena kurang dari jumlah yang diinginkan penjual.  Tetapi jika kita menemukan 0,005001, itu benar.  Satoshiki tambahan dapat digunakan sebagai komisi (kami akan membicarakannya secara rinci di bawah) atau memberikannya kepada penjual jika ia mengizinkan pengiriman jumlah yang lebih besar.  Oleh karena itu, dengan bantuan masalah ransel, kita perlu memilih bukan koin yang perlu <strong>dikirim</strong> , tetapi yang perlu <strong>dibiarkan</strong> .  Maka "kekurangan" secara maksimal akan berubah menjadi "gagal" dalam hal masalah aslinya. </p><br><p><img src="https://habrastorage.org/webt/ew/3q/su/ew3qsuzkpbzdy68chuyleel8vrm.png" alt="Pemilihan koin secara otomatis dan manual untuk dikirim"></p><br><p>  Sebuah contoh  Misalkan kita memiliki koin seperti itu: 0,1 BTC, 0,002 BTC, 0,00832423 BTC.  Dan kami perlu mengirim 0,01 BTC.  Kami akan menemukan koin semacam itu, yang jumlahnya akan maksimum, tetapi kurang dari atau sama dengan jumlah total koin kami dikurangi jumlah yang dikirim, yaitu, jumlah tersebut: 0,1 + 0,002 + 0,00832423 - 0,01 = 0,10032423.  Dalam hal ini, pencarian sederhana menemukan bahwa itu adalah koin 0,1.  Kami meninggalkannya, yang berarti kami mengirimkan sisanya: 0,002 BTC dan 0,00832423 BTC, yang totalnya memberikan 0,01032423 BTC, yang lebih dari 0,01 BTC dan cocok untuk kami.  (Benar, komisi keluar sekitar $ 3, tetapi katakanlah bahwa jaringan sedang sibuk dan kami ingin melakukan pengiriman secepat mungkin.) </p><br><h2 id="komissii">  Komisi </h2><br><p>  Untuk memperhitungkan biaya transaksi, saya memodifikasi setiap koin input, mengurangi saldonya dengan jumlah yang harus dibayar untuk dimasukkan dalam transaksi sebagai input.  Ini dapat dilakukan dengan mengetahui ukuran input dan komisi (misalnya, 2 satoshi per byte).  Selain itu, saya memodifikasi jumlah yang akan dikirim, menambahkan kepadanya harga bagian dari transaksi yang tidak bergantung pada koin yang dipilih: heading dan exit.  Pengguna dapat menentukan semua parameter ini menggunakan flag.  Anda juga dapat menonaktifkan penyesuaian untuk komisi secara umum dengan menetapkan komisi 0 Satoshi per byte. </p><br><p>  Saya mengambil informasi tentang ukuran input dan output dalam berbagai versi alamat (klasik, terbungkus segwit, dan segwit asli dari sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bitcoin.stackexchange.com/a/84006</a> </p><br><h2 id="algoritmy-i-realizaciya">  Algoritma dan implementasi </h2><br><p>  Saya langsung menjatuhkan algoritma genetika, mungkin sia-sia.  Berfokus pada algoritma yang akurat.  Upaya pertama saya adalah mewujudkan melalui pencarian lengkap semua kombinasi, tetapi bahkan pada 40 koin itu bekerja berjam-jam dan harus meninggalkannya.  Kemudian saya mencoba pemrograman dinamis yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disarankan di Wikipedia</a> .  Di dalamnya, Anda tidak dapat menyimpan dalam memori seluruh matriks, tetapi hanya baris saat ini dan sebelumnya.  Selain itu, kita tidak perlu menyimpan nilainya, karena bertepatan dengan berat dan merupakan nomor kolom.  Tetapi kita perlu mengingat kombinasinya - saya memutuskan untuk menyimpannya dalam bentuk bitset.  Selain itu, Anda dapat menyimpan hanya satu baris, membangun baris berikutnya di tempat darinya.  Setiap catatan baris nol tetap di tempatnya dan disalin (dengan penambahan bit yang sesuai) ke sel lain sejumlah sel di sebelah kanan (jika kosong di sana sebelumnya).  Jika Anda menggunakan urutan terbalik, menyortir sel tempat "lompatan" masuk, maka Anda dapat mengisi semuanya dengan benar: </p><br><p><img src="https://habrastorage.org/webt/fa/qb/ts/faqbtspntkfkjgzwy6koiubabvi.png" alt="Ilustrasi transisi ke baris berikutnya, yaitu menambahkan koin lain ke pemrograman dinamis"><br>  <em>Setiap sel bukan nol di baris saat ini menghasilkan di baris berikutnya sendiri dan sel lain untuk sejumlah sel tertentu (sama dengan nilai koin yang ditambahkan) di sebelah kanan.</em>  <em>Jika sel itu sudah memiliki nilai, maka opsi dengan jumlah terbesar yang dipilih (yaitu, tidak termasuk dalam transaksi) koin "menang", karena kami ingin mengirim koin sesedikit mungkin, hal lain dianggap sama.</em> </p><br><p>  Pada satu sel saya menghabiskan 8 byte untuk bitset, dan jumlah sel sama dengan jumlah saldo dari 0 hingga jumlah koin dikurangi jumlah yang dikirim.  Misalnya, jika hanya ada 1 bitcoin di dompet, dan 0,1 dikirim, maka akan ada 100'000'000-10'000'000 = 90'000'000 sel, masing-masing 8 byte, yaitu 720 megabyte - sedikit untuk komputer modern.  Jika jumlah koin kurang dari 32, maka dimungkinkan untuk menggunakan 4 byte per koin, tetapi saya tidak mengoptimalkannya.  Selain itu, jika ada lebih dari 64 koin, maka program tidak berfungsi - ini juga harus diperbaiki dengan membuat bitet dengan panjang sewenang-wenang.  Akhirnya, Anda bisa membuang tanda terakhir di saldo, kehilangan sedikit akurasi, tetapi menang 10 kali dalam memori.  Tapi sejauh ini akan berhasil. </p><br><p> Saya menyebut <strong>program tidak berubah</strong> dan meletakkannya di gitlab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gitlab.com/starius/changeless</a> .  Itu ditulis dalam Go, dirakit menggunakan <code>go get</code> , seperti biasa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binari untuk Linux, Windows, Mac</a> , dikumpulkan dalam CI tersedia. </p><br><p>  Ketika saya meluncurkan program dengan koin asli, saya kagum pada seberapa akurat dia mengambil kombinasi yang diperlukan.  Ketika jumlah koin besar, hampir semua jumlah yang sepadan dengan saldo koin dapat dipilih dengan akurasi hingga satoshi!  Anda mengubah jumlah yang diperlukan untuk 1 satoshi dan program ini memberikan kombinasi koin yang sama sekali berbeda dengan jumlah ini.  Di bawah ini adalah contoh bekerja pada 50 koin acak dengan saldo dari 0 hingga 1 bitcoin. </p><br><pre> <code class="plaintext hljs">$ cat coins50.txt 0.01331611 0.03906237 0.04847086 0.08453118 0.09748168 0.10395389 0.10619825 0.12156721 0.12923149 0.13587973 0.14798976 0.16053788 0.19011834 0.21570038 0.21946913 0.31861430 0.33435508 0.33718842 0.33789473 0.35976748 0.37360122 0.44944553 0.47572926 0.49927495 0.50992142 0.53062326 0.53079433 0.53542072 0.54715225 0.55019714 0.55313907 0.56656642 0.56673333 0.65879650 0.66228482 0.68424322 0.70436496 0.75638055 0.79095597 0.82438005 0.83684407 0.85151564 0.86862948 0.90054250 0.90239402 0.91636213 0.93087757 0.93579251 0.97207439 0.98248384 $ changeless -amount 10.00000000 -coins coins50.txt Processing item 50/50. 0.09748168 + 0.33435508 + 0.47572926 + 0.53542072 + 0.66228482 + 0.70436496 + 0.75638055 + 0.82438005 + 0.9005425 + 0.90239402 + 0.91636213 + 0.93579251 + 0.97207439 + 0.98248384 = 10.00004651 Tx size: 2118 vBytes. Total fees: 0.00004651 BTC (2.2 sats/vByte). $ changeless -amount 10.00000001 -coins coins50.txt Processing item 50/50. 0.01331611 + 0.09748168 + 0.53079433 + 0.56656642 + 0.70436496 + 0.75638055 + 0.82438005 + 0.86862948 + 0.9005425 + 0.91636213 + 0.93087757 + 0.93579251 + 0.97207439 + 0.98248384 = 10.00004652 Tx size: 2118 vBytes. Total fees: 0.00004651 BTC (2.2 sats/vByte).</code> </pre> <br><p>  Program ini berhasil mengambil kombinasi koin untuk mengirim tepat 10 bitcoin dan tepat 10,00000001 bitcoin (10 bitcoin dan 1 satoshi).  Untuk melihat ini, Anda harus mengurangi komisi dari jumlah koin: 10.00004651 - 0,00004651 = 10, 10.00004652 - 0,00004651 = 10.00000001. </p><br><h2 id="kak-poluchit-spisok-balansov-monet">  Cara mendapatkan daftar saldo koin </h2><br><p>  Untuk program Electrum, saya menemukan cara ini (perintah konsol): </p><br><pre> <code class="plaintext hljs">' '.join((x["value"]) for x in listunspent())</code> </pre> <br><p>  Jika Anda ingin mengecualikan koin tertentu, misalnya di alamat tertentu, maka ini dapat dilakukan seperti ini: </p><br><pre> <code class="plaintext hljs">' '.join((x["value"]) for x in listunspent() if x["address"] != "bad address")</code> </pre> <br><p>  Untuk dompet lain, saya tidak menemukan cara yang mudah dan harus mengetik ulang dengan tangan saya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465041/">https://habr.com/ru/post/id465041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465027/index.html">10 pertanyaan naif tetapi penting tentang CRM</a></li>
<li><a href="../id465029/index.html">[MUNGKIN] SORM mendekripsi lalu lintas HTTPS ke Mail.ru dan ICQ</a></li>
<li><a href="../id465031/index.html">Tampilan dalam: RFID di dunia modern. Bagian 2: RFID Cina</a></li>
<li><a href="../id465033/index.html">Datang dengan teknologi Powercheck</a></li>
<li><a href="../id465039/index.html">Pekan Keamanan 35: statistik kata sandi dan serangan yang bocor melalui Google Drive</a></li>
<li><a href="../id465045/index.html">Kali Linux NetHunter di Android: mengapa dan cara menginstal</a></li>
<li><a href="../id465047/index.html">Tes unit dalam DBMS - bagaimana kami melakukannya di Sportmaster, bagian dua</a></li>
<li><a href="../id465049/index.html">10 Buku tentang Manajemen Proyek Agile yang Layak Dibawa Bersama Anda pada tahun 2020</a></li>
<li><a href="../id465055/index.html">Enam keterampilan untuk membawa karier Ilmu Data Anda ke tingkat selanjutnya.</a></li>
<li><a href="../id465057/index.html">Wadah dan Windows. Dari Hello World ke Kubernetes. Bagian Satu, Pengantar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>