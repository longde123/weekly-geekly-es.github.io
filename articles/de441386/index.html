<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèì üë¶üèΩ üßîüèª Spring Data JPA: Was ist gut und was ist schlecht? ‚úãüèæ ‚úçüèª üç∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der kleine Sohn kam zu seinem Vater 
 Und fragte das Baby 
 - Was ist gut? 
 und was ist schlecht 
 
 Vladimir Mayakovsky 


 In diesem Artikel geht e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA: Was ist gut und was ist schlecht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441386/"><p> <em>Der kleine Sohn kam zu seinem Vater</em> <em><br></em>  <em>Und fragte das Baby</em> <em><br></em>  <em>- Was ist gut?</em> <em><br></em>  <em>und was ist schlecht</em> <em><br></em> <br>  Vladimir Mayakovsky </p><br><p>  In diesem Artikel geht es um Spring Data JPA, n√§mlich in dem Unterwasserschwader, den ich auf meinem Weg getroffen habe, und nat√ºrlich ein wenig um Leistung. </p><a name="habracut"></a><br><p>  Die im Artikel beschriebenen Beispiele k√∂nnen in der Testumgebung ausgef√ºhrt werden, auf die √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenz zugegriffen werden kann</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Hinweis f√ºr diejenigen, die noch nicht zu Spring Boot 2 gewechselt sind</b> <div class="spoiler_text"><p> In Versionen von Spring Data JPA 2. * wurde die Hauptschnittstelle f√ºr die Arbeit mit Repositorys, n√§mlich <code>CrudRepository</code> , von dem <code>JpaRepository</code> geerbt wird, <code>JpaRepository</code> .  In Version 1. * sahen die Hauptmethoden folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> <br><p>  In neuen Versionen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> </div></div><br><p>  Also fangen wir an. </p><br><h4 id="select-t-from-t-where-tid-in-">  W√§hlen Sie t. * aus t, wobei t.id in (...) </h4><br><p>  Eine der h√§ufigsten Abfragen ist eine Abfrage der Form "Alle Datens√§tze ausw√§hlen, f√ºr die der Schl√ºssel in den √ºbertragenen Satz f√§llt".  Ich bin sicher, fast alle von Ihnen haben so etwas geschrieben oder gesehen </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> List&lt;Long&gt; ids)</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Dies sind funktionierende, geeignete Anforderungen, es gibt keine Fang- oder Leistungsprobleme, aber es gibt einen kleinen, v√∂llig unauff√§lligen Nachteil. </p><br><div class="spoiler">  <b class="spoiler_title">Versuchen Sie, selbst zu denken, bevor Sie den Liner √∂ffnen.</b> <div class="spoiler_text"><p>  Der Nachteil ist, dass die Schnittstelle zu eng ist, um Schl√ºssel zu √ºbertragen.  "Na und?"  - Du sagst.  "Nun, die Liste, nun das Set, ich sehe hier kein Problem."  Wenn wir uns jedoch die Methoden der Root-Schnittstelle ansehen, die viele Werte <code>Iterable</code> sehen wir √ºberall <code>Iterable</code> : </p><br><p>  "Na und? Und ich m√∂chte eine Liste. Warum ist es schlimmer?" <br>  Nicht schlimmer, seien Sie einfach darauf vorbereitet, dass in Ihrer Anwendung √§hnlicher Code auf einer h√∂heren Ebene angezeigt wird: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Long&gt; userIds)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(userIds); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findByUserIds(ids); } <span class="hljs-comment"><span class="hljs-comment">// public List&lt;BankAccount&gt; findByUserIds(Set&lt;Long&gt; userIds) { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(userIds); return repository.findByUserIds(ids); }</span></span></code> </pre> <br><p>  Dieser Code macht nichts anderes, als die Sammlungen umzukehren.  Es kann sich herausstellen, dass das Argument f√ºr die Methode eine Liste ist und die Repository-Methode die Menge akzeptiert (oder umgekehrt), und Sie m√ºssen sie nur neu anordnen, um die Kompilierung zu bestehen.  Dies wird nat√ºrlich vor dem Hintergrund der Gemeinkosten f√ºr die Anfrage selbst kein Problem sein, sondern es geht eher um unn√∂tige Gesten. </p><br><p>  Daher <code>Iterable</code> es sich, <code>Iterable</code> zu verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Z.Y.  Wenn es sich um eine Methode aus <code>*RepositoryCustom</code> , ist es sinnvoll, <code>Collection</code> zu verwenden, um die Berechnung der Gr√∂√üe innerhalb der Implementierung zu vereinfachen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> </div></div><br><h4 id="lishniy-kod-nepovtoryayuschiesya-klyuchi">  Zus√§tzlicher Code: nicht doppelte Schl√ºssel </h4><br><p>  In Fortsetzung des letzten Abschnitts m√∂chte ich auf ein h√§ufiges Missverst√§ndnis aufmerksam machen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Andere Manifestationen des gleichen Fehlers: </p><br><pre> <code class="java hljs">Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(notUniqueIds); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); List&lt;Long&gt; ids = ts.stream().map(T::id).distinct().collect(toList()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); Set&lt;Long&gt; ids = ts.stream().map(T::id).collect(toSet()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids);</code> </pre> <br><p>  Auf den ersten Blick nichts Ungew√∂hnliches, oder? </p><br><div class="spoiler">  <b class="spoiler_title">Nehmen Sie sich Zeit, denken Sie selbst;)</b> <div class="spoiler_text"><p>  HQL / JPQL-Abfragen des Formulars <code>select t from t where t.field in ...</code> schlie√ülich zu einer Abfrage wird </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> BankAccount b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.user_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (?, ?, ?, ?, ?, ‚Ä¶)</code> </pre> <br><p>  Dies wird immer das Gleiche zur√ºckgeben, unabh√§ngig davon, ob Wiederholungen im Argument vorhanden sind.  Daher ist es nicht erforderlich, die Eindeutigkeit der Schl√ºssel sicherzustellen.  Es gibt einen Sonderfall - Oracle, bei dem das Dr√ºcken von&gt; 1000 Eingaben zu einem Fehler f√ºhrt.  Wenn Sie jedoch versuchen, die Anzahl der Schl√ºssel durch Ausschlie√üen von Wiederholungen zu verringern, sollten Sie lieber √ºber den Grund f√ºr deren Auftreten nachdenken.  H√∂chstwahrscheinlich liegt der Fehler irgendwo oben. </p><br><p>  Verwenden <code>Iterable</code> also in gutem Code <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> </div></div><br><h4 id="samopis">  Samopis </h4><br><p>  Schauen Sie sich diesen Code genau an und finden Sie hier drei Fehler und einen m√∂glichen Fehler: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"from User u where u.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Denken Sie noch etwas nach</b> <div class="spoiler_text"><ul><li>  Alles ist bereits in <code>SimpleJpaRepository::findAllById</code> </li><li>  Leerlaufanforderung beim √úbergeben einer leeren Liste (in <code>SimpleJpaRepository::findAllById</code> gibt es eine entsprechende Pr√ºfung) </li><li>  Alle mit <code>@Query</code> beschriebenen <code>@Query</code> werden in der Phase des <code>@Query</code> √ºberpr√ºft, was <code>SimpleJpaRepository::findAllById</code> Zeit in <code>SimpleJpaRepository::findAllById</code> nimmt (im Gegensatz zu <code>SimpleJpaRepository::findAllById</code> ). </li><li>  Wenn Oracle verwendet wird und die Schl√ºsselsammlung leer ist, wird der Fehler <code>ORA-00936: missing expression</code> (der bei Verwendung von <code>SimpleJpaRepository::findAllById</code> nicht <code>SimpleJpaRepository::findAllById</code> , siehe Punkt 2). </li></ul></div></div><br><h4 id="garri-potter-i-sostavnoy-klyuch">  Harry Potter und zusammengesetzter Schl√ºssel </h4><br><p>  Schauen Sie sich zwei Beispiele an und w√§hlen Sie Ihr bevorzugtes aus: </p><br><p>  Methodennummer mal </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EmbeddedId</span></span> CompositeKey key; }</code> </pre> <br><p>  Methode Nummer zwei </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@IdClass</span></span>(value = CompositeKey.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key1; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key2; }</code> </pre> <br><p>  Auf den ersten Blick gibt es keinen Unterschied.  Probieren Sie nun die erste Methode aus und f√ºhren Sie einen einfachen Test durch: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @EmbeddedId @Test public void findAll() { int size = entityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  Im Abfrageprotokoll (Sie behalten es, richtig?) Werden wir Folgendes sehen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ?</code> </pre> <br><p>  Nun zweites Beispiel </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @Id @Id @Test public void _findAll() { int size = anotherEntityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  Das Abfrageprotokoll sieht anders aus: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=?</code> </pre> <br><p>  Das ist der ganze Unterschied: Im ersten Fall erhalten wir immer 1 Anfrage, im zweiten - n Anfragen. <br>  Der Grund f√ºr dieses Verhalten liegt in <code>SimpleJpaRepository::findAllById</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ... if (entityInfo.hasCompositeId()) { List&lt;T&gt; results = new ArrayList&lt;&gt;(); for (ID id : ids) { findById(id).ifPresent(results::add); } return results; } // ...</span></span></code> </pre> <br><p>  Welche Methode f√ºr Sie am besten geeignet ist, k√∂nnen Sie anhand der Anzahl der Anforderungen bestimmen. </p><br><h4 id="lishniy-crudrepositorysave">  Extra CrudRepository :: speichern </h4><br><p>  Oft gibt es im Code ein solches Antimuster: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  Der Leser ist ratlos: Wo ist das Antimuster?  Dieser Code sieht einfach sehr logisch aus: Wir erhalten die Entit√§t - Update - Speichern.  Alles ist wie in den besten H√§usern von St. Petersburg.  Ich wage zu sagen, dass das Aufrufen von <code>CrudRepository::save</code> hier √ºberfl√ºssig ist. </p><br><p>  Erstens: Die <code>updateRate</code> Methode <code>updateRate</code> Transaktionsmethode. Daher werden alle √Ñnderungen in der verwalteten Entit√§t von Hibernate verfolgt und bei der Ausf√ºhrung von <code>Session::flush</code> in eine Anforderung umgewandelt, die in diesem Code beim <code>updateRate</code> Methode auftritt. </p><br><p>  Zweitens werfen <code>CrudRepository::save</code> einen Blick auf die <code>CrudRepository::save</code> Methode.  Wie Sie wissen, basieren alle Repositorys auf <code>SimpleJpaRepository</code> .  Hier ist die Implementierung von <code>CrudRepository::save</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } }</code> </pre> <br><p>  Es gibt eine Subtilit√§t, an die sich nicht jeder erinnert: Der Ruhezustand funktioniert durch Ereignisse.  Mit anderen Worten, jede Benutzeraktion generiert ein Ereignis, das in die Warteschlange gestellt und verarbeitet wird, wobei andere Ereignisse in derselben Warteschlange ber√ºcksichtigt werden.  In diesem Fall generiert ein Aufruf von <code>EntityManager::merge</code> ein <code>MergeEvent</code> , das standardm√§√üig in der <code>DefaultMergeEventListener::onMerge</code> .  Es enth√§lt eine ziemlich verzweigte, aber einfache Logik f√ºr jeden Zustand des Entit√§tsarguments.  In unserem Fall wird die Entit√§t aus dem Repository innerhalb der Transaktionsmethode abgerufen und befindet sich im Status PERSISTENT (d. H. Im Wesentlichen vom Framework gesteuert): </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityIsPersistent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MergeEvent event, Map copyCache)</span></span></span><span class="hljs-function"> </span></span>{ LOG.trace(<span class="hljs-string"><span class="hljs-string">"Ignoring persistent instance"</span></span>); Object entity = event.getEntity(); EventSource source = event.getSession(); EntityPersister persister = source.getEntityPersister(event.getEntityName(), entity); ((MergeContext)copyCache).put(entity, entity, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cascadeOnMerge(source, persister, entity, copyCache); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- this.copyValues(persister, entity, entity, source, copyCache); //&lt;---- event.setResult(entity); }</span></span></code> </pre> <br><p>  Der Teufel <code>DefaultMergeEventListener::cascadeOnMerge</code> im Detail, n√§mlich in den Methoden <code>DefaultMergeEventListener::cascadeOnMerge</code> und <code>DefaultMergeEventListener::copyValues</code> .  H√∂ren wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">direkte Rede von Vlad Mikhalche an</a> , einem der wichtigsten Entwickler von Hibernate: </p><br><blockquote>  Beim Methodenaufruf copyValues ‚Äã‚Äãwird der hydratisierte Zustand erneut kopiert, sodass redundant ein neues Array erstellt wird, wodurch CPU-Zyklen verschwendet werden.  Wenn die Entit√§t untergeordnete Zuordnungen hat und die Zusammenf√ºhrungsoperation auch von √ºbergeordneten zu untergeordneten Entit√§ten kaskadiert wird, ist der Overhead sogar noch gr√∂√üer, da jede untergeordnete Entit√§t ein MergeEvent weitergibt und der Zyklus fortgesetzt wird. </blockquote><p>  Mit anderen Worten, es wird gearbeitet, was Sie nicht tun k√∂nnen.  Infolgedessen kann unser Code vereinfacht und gleichzeitig die Leistung verbessert werden: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> account; }</code> </pre> <br><p>  Es ist nat√ºrlich unpraktisch, dies beim Entwickeln und Korrekturlesen des Codes eines anderen zu ber√ºcksichtigen. <code>JpaRepository::save</code> m√∂chten wir √Ñnderungen auf Drahtgitterebene <code>JpaRepository::save</code> , damit die <code>JpaRepository::save</code> Methode ihre sch√§dlichen Eigenschaften verliert.  Ist es m√∂glich? </p><br><div class="spoiler">  <b class="spoiler_title">Ja, vielleicht</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } // @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else if (!em.contains(entity)) { return em.merge(entity); } return entity; }</span></span></code> </pre> <br><p>  Diese √Ñnderungen wurden tats√§chlich im Dezember 2017 vorgenommen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://jira.spring.io/browse/DATAJPA-931</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/spring-projects/spring-data-jpa/pull/237</a> </p></div></div><br><p>  Der anspruchsvolle Leser sp√ºrte jedoch wahrscheinlich bereits, dass etwas nicht stimmte.  In der Tat wird diese √Ñnderung nichts zerst√∂ren, sondern nur in dem einfachen Fall, in dem es keine untergeordneten Entit√§ten gibt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; }</code> </pre> <br><p>  Angenommen, sein Besitzer ist an das Konto gebunden: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; }</code> </pre> <br><p>  Es gibt eine Methode, mit der Sie den Benutzer vom Konto trennen und diesen auf den neuen Benutzer √ºbertragen k√∂nnen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, User newUser)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setUser(newUser); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  Was wird jetzt passieren?  <code>em.contains(entity)</code> wird true zur√ºckgegeben. <code>em.merge(entity)</code> bedeutet, dass <code>em.merge(entity)</code> nicht aufgerufen wird.  Wenn der <code>User</code> auf der Grundlage der Sequenz erstellt wird (einer der h√§ufigsten F√§lle), wird er erst erstellt, wenn die Transaktion abgeschlossen ist (oder <code>Session::flush</code> manuell aufgerufen wird), d. H. Der Benutzer befindet sich im Status DETACHED und seine √ºbergeordnete Entit√§t ( Konto) - im Zustand PERSISTENT.  In einigen F√§llen kann dies die Anwendungslogik besch√§digen, was passiert ist: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">02/03/2018 DATAJPA-931 bricht die Zusammenf√ºhrung mit RepositoryItemWriter ab</a> </p><br><p>  In diesem Zusammenhang wurde die Aufgabe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierungen f√ºr vorhandene Entit√§ten in CrudRepository :: save r√ºckg√§ngig machen erstellt</a> und die √Ñnderungen vorgenommen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DATAJPA-931 zur√ºcksetzen</a> . </p><br><h4 id="slepoy-crudrepositoryfindbyid">  Blind CrudRepository :: findById </h4><br><p>  Wir betrachten weiterhin dasselbe Datenmodell: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-comment"><span class="hljs-comment">// ... } @Entity public class BankAccount { @Id Long id; @ManyToOne @JoinColumn(name = "user_id") User user; }</span></span></code> </pre> <br><p>  Die Anwendung verf√ºgt √ºber eine Methode, mit der ein neues Konto f√ºr den angegebenen Benutzer erstellt wird: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); userRepository.findById(userId).ifPresent(account::setUser); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  Bei Version 2. * ist das durch den Pfeil gekennzeichnete Antimuster nicht so auff√§llig - es ist bei √§lteren Versionen deutlicher zu erkennen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.findOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wenn Sie den Fehler nicht "mit dem Auge" sehen, sehen Sie sich die folgenden Fragen an:</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, u.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ? <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> </div></div><br><p>  Bei der ersten Anfrage erhalten wir den Benutzer per Schl√ºssel.  Als n√§chstes erhalten wir den Schl√ºssel f√ºr das neugeborene Konto aus der Datenbank und f√ºgen ihn in die Tabelle ein.  Und das einzige, was wir dem Benutzer abnehmen, ist der Schl√ºssel, den wir bereits als Methodenargument haben.  Auf der anderen Seite enth√§lt <code>BankAccount</code> das Feld "Benutzer" und wir k√∂nnen es nicht leer lassen (als anst√§ndige Leute setzen wir eine Einschr√§nkung im Schema).  Erfahrene Entwickler sehen wahrscheinlich schon einen Weg <del>  und iss einen Fisch und reite ein Pferd </del>  Holen Sie sich sowohl den Benutzer als auch die Anfrage, nicht: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.getOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  <code>JpaRepository::getOne</code> gibt einen Wrapper √ºber den Schl√ºssel zur√ºck, der denselben Typ wie die lebende "Entit√§t" hat.  Dieser Code gibt nur zwei Anfragen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> <br><p>  Wenn eine zu erstellende Entit√§t viele Felder mit einer Beziehung von vielen zu eins / eins zu eins enth√§lt, hilft diese Technik, das Speichern zu beschleunigen und die Belastung der Datenbank zu verringern. </p><br><h4 id="ispolnenie-hql-zaprosov">  Ausf√ºhren von HQL-Abfragen </h4><br><p>  Dies ist ein separates und interessantes Thema :).  Das Domain-Modell ist das gleiche und es gibt eine solche Anfrage: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" join ba.user user "</span></span> + <span class="hljs-string"><span class="hljs-string">" where user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Betrachten Sie die "reine" HQL: </p><br><pre> <code class="plaintext hljs">select count(ba) from BankAccount ba join ba.user user where user.id = :id</code> </pre> <br><p>  Bei der Ausf√ºhrung wird die folgende SQL-Abfrage erstellt: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ba.user_id = u.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ?</code> </pre> <br><p>  Das Problem ist hier selbst bei einem weisen Leben und einem guten Verst√§ndnis der SQL-Entwickler nicht sofort ersichtlich: Durch die <code>inner join</code> mit dem Benutzerschl√ºssel werden Konten mit fehlender Benutzer- <code>user_id</code> von der Auswahl ausgeschlossen (und das Einf√ºgen dieser Konten sollte auf <code>user_id</code> verboten sein), was bedeutet, dass es √ºberhaupt nicht <code>user_id</code> , der <code>user</code> beizutreten m√ºssen.  Die Anfrage kann vereinfacht (und beschleunigt) werden: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  Es gibt eine M√∂glichkeit, dieses Verhalten in c mithilfe von HQL einfach zu erreichen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" where ba.user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Diese Methode erstellt eine "Lite" -Anforderung. </p><br><h4 id="annotaciya-query-protiv-metoda">  Abfrage vs. Methodenzusammenfassung </h4><br><p>  Eine der Hauptfunktionen von Spring Data ist die M√∂glichkeit, eine Abfrage aus dem Methodennamen zu erstellen. Dies ist sehr praktisch, insbesondere in Kombination mit dem intelligenten Add-On von IntelliJ IDEA.  Die im vorherigen Beispiel beschriebene Abfrage kann einfach umgeschrieben werden: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Query("select count(ba) " + " from BankAccount ba " + " where ba.user.id = :id") long countUserAccounts(@Param("id") Long id); // long countByUserAccount_Id(Long id);</span></span></code> </pre> <br><p>  Es scheint einfacher und k√ºrzer und lesbarer zu sein, und vor allem m√ºssen Sie die Anfrage selbst nicht ansehen.  Ich habe den Namen der Methode gelesen - und es ist bereits klar, was und wie sie ausw√§hlt.  Aber der Teufel steckt hier im Detail.  Die letzte Abfrage f√ºr die mit <code>@Query</code> gekennzeichnete Methode <code>@Query</code> wir bereits gesehen.  Was wird im zweiten Fall passieren? </p><br><div class="spoiler">  <b class="spoiler_title">Babah!</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> // &lt;<span class="hljs-comment"><span class="hljs-comment">--- !!!!!!! user u on ba.user_id = u.id where u.id = ?</span></span></code> </pre> </div></div><br><p>  "Was zur H√∂lle !?"  - Der Entwickler wird ausrufen.  Immerhin haben wir das schon gesehen <del>  Geiger </del>  <code>join</code> nicht ben√∂tigt. </p><br><p>  Der Grund ist prosaisch: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JPADATAJPA-729 Unn√∂tige OUTER JOIN werden zum Z√§hlen einer einzelnen Tabelle generiert</a> </li><li><del>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DATAJPA-1238 Unn√∂tig LEFT OUTER JOIN, wenn ein WHERE h√§tte verwendet werden k√∂nnen</a> </del></li></ul><br><p>  Wenn Sie noch kein Upgrade auf die gepatchten Versionen durchgef√ºhrt haben und das Hinzuf√ºgen der Tabelle die Abfrage hier und jetzt verlangsamt, verzweifeln Sie nicht: Es gibt zwei M√∂glichkeiten, um die Schmerzen zu lindern: </p><br><ul><li><p>  Ein guter Weg ist, <code>optional = false</code> hinzuzuf√ºgen (wenn die Schaltung dies zul√§sst): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, optional = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) User user; }</code> </pre> <br></li><li><p>  Die Kr√ºckenmethode besteht darin, eine Spalte des gleichen Typs wie der <code>User</code> hinzuzuf√ºgen und sie in Abfragen anstelle des <code>user</code> verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) Long userId; }</code> </pre> <br><p>  Jetzt wird die Anfrage-von-Methode sch√∂ner: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span></span>;</code> </pre> <br><p>  gibt </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  Was haben wir erreicht? </p><br></li></ul><br><h4 id="ogranichenie-vyborki">  Probenahmegrenze </h4><br><p>  F√ºr unsere Zwecke m√ºssen wir die Auswahl einschr√§nken (z. B. m√∂chten wir <code>Optional</code> von der <code>*RepositoryCustom</code> Methode zur√ºckgeben): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ba.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ba.rate <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> ?</code> </pre> <br><p>  Jetzt Java: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; BankAccount account = em .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .getSingleResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.ofNullable(bankAccount); }</code> </pre> <br><p>  Der angegebene Code hat eine unangenehme Eigenschaft: Falls die Anforderung eine leere Auswahl zur√ºckgibt, wird eine Ausnahme ausgel√∂st </p><br><pre> <code class="plaintext hljs">Caused by: javax.persistence.NoResultException: No entity found for query</code> </pre> <br><p>  In den Projekten, die ich gesehen habe, wurde dies auf zwei Arten gel√∂st: </p><br><ul><li>  try-catch mit Variationen von unverbl√ºmtem <code>Optonal.empty()</code> Ausnahme und Zur√ºckgeben von <code>Optonal.empty()</code> auf fortgeschrittenere Methoden, z. B. √úbergeben eines Lambda mit einer Anforderung an eine Dienstprogrammmethode </li><li>  Aspekt, in dem Repository-Methoden verpackt sind und <code>Optional</code> </li></ul><br><p>  Und sehr selten sah ich die richtige L√∂sung: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.unwrap(Session.class) .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .uniqueResultOptional(); }</code> </pre> <br><p>  <code>EntityManager</code> ist Teil des JPA-Standards, w√§hrend <code>Session</code> zu Hibernate geh√∂rt und meiner Meinung nach ein erweitertes Tool ist, das oft vergessen wird. </p><br><h4 id="inogda-vrednoe-uluchshenie">  [Manchmal] sch√§dliche Verbesserung </h4><br><p>  Wenn Sie ein kleines Feld von einer "dicken" Entit√§t erhalten m√∂chten, gehen wir folgenderma√üen vor: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select a.available from BankAccount a where a.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIfAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Mit der Anforderung k√∂nnen Sie ein Feld vom Typ <code>boolean</code> abrufen, ohne die gesamte Entit√§t zu laden (mit Hinzuf√ºgen eines Caches der ersten Ebene, √úberpr√ºfen auf √Ñnderungen am Ende der Sitzung und anderer Kosten).  Manchmal verbessert dies nicht nur nicht die Leistung, sondern auch umgekehrt - es entstehen unn√∂tige Abfragen von Grund auf.  Stellen Sie sich einen Code vor, der einige √úberpr√ºfungen durchf√ºhrt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findIfAvailable(id); }</span></span></code> </pre> <br><p>  Dieser Code macht mindestens 2 Anfragen, obwohl die zweite vermieden werden k√∂nnte: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findById(id) //    .map(BankAccount::isAvailable) .orElseThrow(IllegalStateException::new); }</span></span></code> </pre> <br><p>  Die Schlussfolgerung ist einfach: Vernachl√§ssigen Sie nicht den Cache der ersten Ebene, im Rahmen einer Transaktion verweist nur das erste <code>JpaRepository::findById</code> auf die Datenbank, <code>JpaRepository::findById</code> Cache der ersten Ebene immer aktiv ist und an eine Sitzung gebunden ist, die normalerweise an die aktuelle Transaktion gebunden ist. </p><br><p>  Tests zum Spielen (Link zum Repository finden Sie am Anfang des Artikels): </p><br><ul><li>  schmaler Schnittstellentest: <code>InterfaceNarrowingTest</code> </li><li>  Testen Sie ein Beispiel mit einem zusammengesetzten Schl√ºssel: <code>EntityWithCompositeKeyRepositoryTest</code> </li><li>  Test√ºberschuss <code>CrudRepository::save</code> : <code>ModifierTest.java</code> </li><li>  Blindtest <code>CrudRepository::findById</code> : <code>ChildServiceImplTest</code> </li><li>  unn√∂tiger <code>BankAccountControlRepositoryTest</code> <code>left join</code> Test: <code>BankAccountControlRepositoryTest</code> </li></ul><br><p>  Die Kosten f√ºr einen zus√§tzlichen Aufruf von <code>CrudRepository::save</code> k√∂nnen mit <code>RedundantSaveBenchmark</code> berechnet werden.  Es wird mit der <code>BenchmarkRunner</code> Klasse gestartet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441386/">https://habr.com/ru/post/de441386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441376/index.html">Jenseits der Reinheit: Was kann und was nicht Umkehrosmosemembran</a></li>
<li><a href="../de441378/index.html">Forscher von Google: Zum Schutz vor Spectre ist eine √Ñnderung der Prozessorarchitektur erforderlich. Software-Patches helfen nicht</a></li>
<li><a href="../de441380/index.html">7 Punkte Conversion-Wachstum oder wie man die Klickbarkeit von Schaltfl√§chen erh√∂ht</a></li>
<li><a href="../de441382/index.html">Chinesische Wissenschaftler haben einen piezoelektrischen Generator f√ºr Herzschrittmacher entwickelt</a></li>
<li><a href="../de441384/index.html">Massendruck unter Windows</a></li>
<li><a href="../de441388/index.html">Zebrastreifen - es ist eine Flugverbotszone f√ºr M√ºcken</a></li>
<li><a href="../de441390/index.html">Nicht nur ein faltbares Telefon: Samsung hat seine gesamte Palette an tragbaren Ger√§ten aktualisiert</a></li>
<li><a href="../de441392/index.html">RDRAND- und RDSEED-CPU-Funktionen jetzt verf√ºgbar</a></li>
<li><a href="../de441394/index.html">"Angewandte" ASCII-Kunst</a></li>
<li><a href="../de441398/index.html">Cruise √ñffnet den Quellcode von Worldview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>