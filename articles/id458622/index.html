<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“® ğŸ“« ğŸ¤½ğŸ½ Otomasi Untuk Yang Terkecil. Bagian satu (yang setelah nol). Virtualisasi jaringan ğŸ™ğŸ¾ ğŸ‘ŠğŸ¼ ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam rilis sebelumnya, saya menggambarkan kerangka kerja otomatisasi jaringan. Menurut ulasan dari beberapa orang, bahkan pendekatan pertama untuk ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomasi Untuk Yang Terkecil. Bagian satu (yang setelah nol). Virtualisasi jaringan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458622/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis sebelumnya,</a> saya menggambarkan kerangka kerja otomatisasi jaringan.  Menurut ulasan dari beberapa orang, bahkan pendekatan pertama untuk masalah ini telah mengajukan beberapa pertanyaan di rak.  Dan ini membuat saya sangat senang, karena tujuan kami dalam siklus ini bukan untuk menutupi yang mungkin dengan skrip Python, tetapi untuk membangun sistem. <br><br>  Kerangka kerja yang sama menetapkan urutan di mana kita akan menangani pertanyaan. <br>  Dan virtualisasi jaringan, yang didedikasikan untuk masalah ini, tidak benar-benar cocok dengan tema ADSM, tempat kami menganalisis otomatisasi. <br><br>  Tapi mari kita lihat dari sudut yang berbeda. <br><br>  Sudah sejak lama banyak layanan menggunakan satu jaringan.  Dalam kasus pembawa, ini adalah 2G, 3G, LTE, broadband dan B2B, misalnya.  Dalam kasus DC: konektivitas untuk klien yang berbeda, Internet, penyimpanan blok, penyimpanan objek. <br><br>  Dan semua layanan membutuhkan isolasi satu sama lain.  Jadi muncul jaringan overlay. <br><br>  Dan semua layanan tidak ingin menunggu seseorang mengkonfigurasinya secara manual.  Maka muncullah orkestra dan SDN. <br><br>  Pendekatan pertama untuk otomatisasi sistematis jaringan, atau lebih tepatnya, bagian dari itu, telah lama dilakukan dan telah diterapkan di banyak tempat: VMWare, OpenStack, Google Compute Cloud, AWS, Facebook. <br><br>  Di sini kita berurusan dengannya hari ini. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b14/278/742/b142787424b1da02432df0291faaca95.jpg" width="800"></a> <br><a name="habracut"></a><br><h1>  Isi </h1><br><ul><li>  <b>Alasan</b> </li><li>  <b>Terminologi</b> </li><li>  <b>Underlay - Jaringan Fisik</b> </li><li>  <b>Overlay - jaringan virtual</b> <br><br><ul><li>  Overlay dengan ToR </li><li>  Hamparan dari host </li><li>  Studi Kasus Kain Tungsten <br><br><ul><li>  Komunikasi dalam satu mesin fisik </li><li>  Komunikasi antara VM terletak di berbagai mesin fisik </li><li>  Keluar ke dunia luar </li></ul><br></li></ul><br></li><li>  <b>Faq</b> </li><li>  <b>Kesimpulan</b> </li><li>  <b>Tautan yang bermanfaat</b> </li></ul><br><hr><br><br><h1>  Alasan </h1><br>  Dan karena kita membicarakan hal ini, perlu disebutkan prasyarat untuk virtualisasi jaringan.  Sebenarnya, proses ini tidak dimulai kemarin. <br><br>  Anda mungkin pernah mendengar lebih dari sekali bahwa jaringan selalu menjadi bagian yang paling lembam dari sistem apa pun.  Dan ini benar dalam segala hal.  Jaringan adalah dasar di mana semuanya didasarkan, dan membuat perubahan di atasnya cukup sulit - layanan tidak mentolerir ketika jaringan berada.  Seringkali, menonaktifkan satu node dapat menambah sebagian besar aplikasi dan mempengaruhi banyak klien.  Ini adalah sebagian alasan mengapa tim jaringan dapat menolak perubahan apa pun - karena sekarang ini entah bagaimana berfungsi ( <i>kita mungkin bahkan tidak tahu caranya</i> ), tetapi di sini kita perlu mengkonfigurasi sesuatu yang baru, dan tidak diketahui bagaimana hal itu akan mempengaruhi jaringan. <br><br>  Agar tidak menunggu penyedia jaringan untuk lulus VLAN dan tidak mendaftarkan layanan pada setiap node jaringan, orang memutuskan untuk menggunakan overlay - jaringan yang ditumpangkan - yang ada beragam: GRE, IPinIP, MPLS, MPLS L2 / L3VPN, VXLAN, GENEVE, MPLSoverUDP, MPLSoverGRE, dll. <br><br>  Daya tarik mereka terletak pada dua hal sederhana: <br><br><ul><li>  Hanya node akhir yang dikonfigurasi - Anda tidak perlu menyentuh node transit.  Ini secara signifikan mempercepat proses, dan kadang-kadang bahkan memungkinkan Anda untuk mengecualikan departemen infrastruktur jaringan dari proses memperkenalkan layanan baru. </li><li>  Beban disembunyikan jauh di dalam header - node transit tidak perlu tahu apa-apa tentang hal itu, tentang mengatasi host, rute dari jaringan yang dikenakan.  Dan ini berarti Anda perlu menyimpan lebih sedikit informasi dalam tabel, jadi gunakan perangkat yang lebih sederhana / lebih murah. </li></ul><br>  Dalam masalah yang tidak sepenuhnya lengkap ini, saya tidak berencana untuk menganalisis semua teknologi yang mungkin, melainkan menggambarkan kerangka kerja untuk pengoperasian jaringan overlay di DC. <br><br>  Seluruh seri akan menjelaskan pusat data, yang terdiri dari barisan rak yang sama di mana peralatan server yang sama dipasang. <br><br>  Peralatan ini menjalankan mesin virtual / wadah / serverless yang mengimplementasikan layanan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/525/54b/f0352554b58d82955bd7c08f3034cd4f.jpg" width="600" title="Dataline nord dc"><br><br><hr><br><br><h1>  Terminologi </h1><br>  Dalam loop, saya akan memanggil <b>server</b> program yang mengimplementasikan sisi server dari komunikasi client-server. <br><br>  Mesin fisik di rak <b>tidak</b> akan disebut server. <br><br>  <b>Mesin fisik</b> adalah komputer yang dipasang di rak x86.  Paling sering kita menggunakan istilah <b>host</b> .  Jadi kita akan menyebutnya " <b>mesin</b> " atau <b>host</b> . <br><br>  <b>Hypervisor</b> adalah aplikasi yang berjalan pada mesin fisik yang mengemulasi sumber daya fisik yang dijalankan Mesin Virtual.  Terkadang dalam literatur dan jaringan kata "hypervisor" digunakan sebagai sinonim untuk "host". <br><br>  <b>Mesin virtual</b> adalah sistem operasi yang berjalan pada mesin fisik di atas hypervisor.  Bagi kami, dalam kerangka siklus ini, tidak begitu penting apakah itu sebenarnya mesin virtual atau hanya sebuah wadah.  Kami akan menyebutnya " <b>VM</b> " <br><br>  <b>Penyewa</b> adalah konsep luas yang akan saya definisikan dalam artikel ini sebagai layanan terpisah atau klien terpisah. <br><br>  <b>Multi-tenancy</b> atau multi-tenancy - penggunaan aplikasi yang sama oleh klien / layanan yang berbeda.  Pada saat yang sama, isolasi klien dari satu sama lain dicapai karena arsitektur aplikasi, dan bukan contoh yang berjalan secara terpisah. <br><br>  <b>ToR - Top of the Rack switch</b> - <b>sakelar</b> yang dipasang di rak yang terhubung dengan semua mesin fisik. <br><blockquote>  Selain topologi ToR, penyedia yang berbeda mempraktikkan End of Row (EoR) atau Middle of Row (meskipun yang terakhir adalah kelangkaan yang meremehkan dan saya belum melihat singkatan MoR). <br></blockquote>  <b>Jaringan</b> dasar atau <b>jaringan</b> dasar atau dasar - infrastruktur jaringan fisik: sakelar, router, kabel. <br><br>  <b>Overlay network</b> atau overlay network atau overlay - jaringan virtual terowongan yang berjalan di atas yang fisik. <br><br>  <b>Pabrik L3 atau pabrik IP</b> adalah penemuan luar biasa umat manusia, yang memungkinkan wawancara untuk tidak mengulangi STP dan tidak untuk belajar TRILL.  Sebuah konsep di mana seluruh jaringan hingga tingkat akses secara eksklusif L3, tanpa VLAN dan domain siaran yang sangat luas.  Dari mana asal kata "pabrik" di bagian selanjutnya. <br><br>  <b>SDN</b> - Jaringan Buatan Perangkat Lunak.  Hampir tidak membutuhkan pengantar.  Suatu pendekatan untuk manajemen jaringan ketika perubahan pada jaringan tidak dilakukan oleh seseorang, tetapi oleh suatu program.  Biasanya berarti memindahkan Control Plane di luar perangkat jaringan akhir ke controller. <br><br>  <b>NFV</b> - Virtualisasi Fungsi Jaringan - virtualisasi perangkat jaringan, yang mengasumsikan bahwa bagian dari fungsi jaringan dapat diluncurkan dalam bentuk mesin atau wadah virtual untuk mempercepat implementasi layanan baru, mengorganisasikan Service Chaining dan skalabilitas horizontal yang lebih sederhana. <br><br>  <b>VNF</b> - Fungsi Jaringan Virtual.  Perangkat virtual spesifik: router, switch, firewall, NAT, IPS / IDS, dll. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/501/33c/ca950133ca98bd1e2ca613342432c535.png" width="700"><br><blockquote>  Sekarang saya sengaja menyederhanakan deskripsi ke implementasi tertentu agar tidak membingungkan pembaca.  Untuk bacaan yang lebih bijaksana, kirimkan ke bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> .  Selain itu, Roma Gorge, yang mengkritik artikel ini karena ketidakakuratannya, berjanji untuk menulis masalah terpisah tentang teknologi virtualisasi server dan jaringan, lebih dalam dan lebih memperhatikan detail. </blockquote><br><hr><br>  Sebagian besar jaringan saat ini dapat dengan jelas dibagi menjadi dua bagian: <br><br>  <b>Underlay</b> - jaringan fisik dengan konfigurasi stabil. <br>  <b>Overlay</b> - Abstraksi <b>overlay</b> untuk mengisolasi penyewa. <br><br>  Ini berlaku baik untuk kasus DC (yang akan kami analisis dalam artikel ini) dan untuk ISP (yang tidak akan kami analisis, karena sudah ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDSM</a> ).  Dengan jaringan perusahaan, tentu saja, situasinya agak berbeda. <br><br>  Gambar Fokus Jaringan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/133/b41/5f8/133b415f8b32264e2fa877f4a4139267.png" width="800"><br><br><hr><br><br><h1>  Mendasari </h1><br>  Underlay adalah jaringan fisik: sakelar dan kabel perangkat keras.  Perangkat yang ada di bawah tahu cara menuju ke mesin fisik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/117/d04/880/117d04880232fa2c00ef303cf5f059a0.png" width="800"><br><br>  Itu bergantung pada protokol dan teknologi standar.  Paling tidak karena perangkat hardware masih bekerja pada perangkat lunak berpemilik yang tidak memungkinkan pemrograman chip atau implementasi protokol mereka, masing-masing, kompatibilitas dengan vendor lain dan standardisasi diperlukan. <br><blockquote>  Tetapi seseorang seperti Google mampu mengembangkan sakelar sendiri dan mengabaikan protokol yang diterima secara umum.  Tapi LAN_DC bukan Google. <br></blockquote>  Underlay relatif jarang berubah, karena tugasnya adalah konektivitas IP dasar antara mesin fisik.  Underlay tidak tahu apa-apa tentang layanan yang berjalan di atasnya, klien, penyewa - hanya perlu mengirimkan paket dari satu mesin ke mesin lain. <br>  Underlay bisa seperti ini: <br><br><ul><li>  IPv4 + OSPF </li><li>  IPv6 + ISIS + BGP + L3VPN </li><li>  L2 + TRILL </li><li>  L2 + STP </li></ul><br>  Jaringan Underlay dikonfigurasikan dengan cara klasik: CLI / GUI / NETCONF. <br><br>  Secara manual, skrip, utilitas milik. <br><br>  Secara lebih rinci, artikel selanjutnya dalam seri ini akan dikhususkan untuk lapisan bawah. <br><br><hr><br><h1>  Hamparan </h1><br>  Overlay - jaringan terowongan virtual yang terbentang di Underlay, memungkinkan VMs dari satu klien untuk berkomunikasi satu sama lain, sambil memberikan isolasi dari klien lain. <br><br>  Data klien dienkapsulasi dalam header tunneling apa pun untuk transmisi melalui jaringan bersama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c1/3ed/8d2/9c13ed8d2e6cec8f1b9fe500660f1c47.png" width="800"><br><br>  Jadi VMs dari satu klien (satu layanan) dapat berkomunikasi satu sama lain melalui Overlay, tanpa mengetahui apa sebenarnya paket tersebut. <br><br>  Overlay dapat misalnya sama dengan yang saya sebutkan di atas: <br><br><ul><li>  Terowongan GRE </li><li>  VXLAN </li><li>  EVPN </li><li>  L3VPN </li><li>  GENEVE </li></ul><br>  Jaringan overlay biasanya dikonfigurasikan dan dikelola melalui pengontrol pusat.  Dari sana, konfigurasi, Control Plane dan Data Plane dikirimkan ke perangkat yang merutekan dan merangkum lalu lintas klien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di bawah ini</a> kami akan menganalisis ini dengan contoh. <br><br>  <b>Ya, ini adalah SDN murni.</b> <br><br>  Ada dua pendekatan yang berbeda secara mendasar untuk mengatur jaringan Hamparan: <br><br><ol><li>  Overlay dengan ToR </li><li>  Hamparan dari host </li></ol><br><br><h2>  Overlay dengan ToR </h2><br>  Overlay dapat dimulai pada sakelar akses yang dipasang di rak (rack-mount access switch, ToR), seperti halnya, misalnya, dalam kasus pabrik VXLAN. <br><br>  Ini adalah mekanisme yang telah teruji oleh waktu pada jaringan ISP dan semua vendor peralatan jaringan mendukungnya. <br><br>  Namun, dalam kasus ini, switch ToR harus dapat berbagi layanan yang berbeda, masing-masing, dan administrator jaringan harus sedikit banyak bekerja sama dengan administrator mesin virtual dan membuat perubahan (walaupun secara otomatis) ke konfigurasi perangkat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/0a1/87d/5e30a187dd5796e2a4232cb4e9db0b97.png" width="600"><br><br>  Di sini saya akan merujuk pembaca ke artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VxLAN di hub</a> teman lama kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@bormoglotx</a> . <br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan ENOG</a> , pendekatan untuk pembangunan jaringan DC dengan pabrik EVPN VXLAN dijelaskan secara rinci. <br><br>  Dan untuk perendaman yang lebih lengkap dalam kenyataan, Anda dapat membaca buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A Modern, Open, and Scalable Fabric: VXLAN EVPN</a> . <br><blockquote>  Saya perhatikan bahwa VXLAN hanyalah metode enkapsulasi dan pemutusan terowongan tidak dapat terjadi pada ToR, tetapi pada host, seperti halnya dengan OpenStack, misalnya. <br><br>  Namun, pabrik VXLAN tempat overlay dimulai pada ToR adalah salah satu desain jaringan overlay yang sudah mapan. <br></blockquote><br><h2>  Hamparan dari host </h2><br>  Pendekatan lain adalah memulai dan mengakhiri terowongan pada host akhir. <br>  Dalam hal ini, jaringan (Underlay) tetap sesederhana dan statis mungkin. <br>  Dan tuan rumah itu sendiri melakukan semua enkapsulasi yang diperlukan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d7/400/c60/5d7400c60036ba0b6666bb0f733c172f.png" width="600"><br><br>  Untuk melakukan ini, Anda tentu perlu menjalankan aplikasi khusus pada host, tetapi itu sepadan. <br><br>  Pertama, menjalankan klien pada mesin linux lebih sederhana, atau, katakanlah, secara umum mungkin, saat beralih, Anda kemungkinan besar harus beralih ke solusi SDN eksklusif untuk saat ini, yang mematikan gagasan multi-vendor. <br><br>  Kedua, sakelar ToR dalam hal ini dapat dibuat sesederhana mungkin, baik dari sudut pandang Control Plane dan Data Plane.  Memang - maka dia tidak perlu berkomunikasi dengan pengontrol SDN, dan untuk menyimpan jaringan / ARP dari semua klien yang terhubung - juga - hanya tahu alamat IP dari mesin fisik, yang sangat menyederhanakan tabel switching / routing. <br><br><hr><br>  Dalam seri ADSM, saya memilih pendekatan overlay dari host - maka kita hanya membicarakannya dan kita tidak akan kembali ke pabrik VXLAN. <br><br><hr><br>  Cara termudah untuk mempertimbangkan contoh.  Dan sebagai subjek uji, kami akan menggunakan platform OpenSource SDN OpenContrail, yang sekarang dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tungsten Fabric</a> . <br><blockquote>  Di akhir artikel saya akan memberikan beberapa pemikiran tentang analogi dengan OpenFlow dan OpenvSwitch. <br></blockquote><br><h2>  Studi Kasus Kain Tungsten </h2><br>  Setiap mesin fisik memiliki <b>vRouter</b> - router virtual yang tahu tentang jaringan yang terhubung dengannya dan klien mana yang mereka miliki - bahkan - router PE.  Untuk setiap klien, ia memelihara tabel routing yang terisolasi (baca VRF).  Dan sebenarnya vRouter melakukan tunneling Overlay. <br><br>  Lebih banyak tentang vRouter ada di akhir artikel. <br><br>  Setiap VM yang terletak di hypervisor terhubung ke vRouter mesin ini melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka TAP</a> . <br><br>  <b>TAP</b> - Terminal Access Point - antarmuka virtual dalam kernel linux yang memungkinkan jaringan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a2/fc4/20f/7a2fc420f086b1588236ddc7d4f1c97e.png" width="500"><br><br>  Jika ada beberapa jaringan di belakang vRouter, maka antarmuka virtual dibuat untuk masing-masingnya, yang ditetapkan untuk alamat IP - itu akan menjadi alamat gateway default. <br>  Semua jaringan dari satu klien ditempatkan dalam satu <b>VRF</b> (satu tabel), berbeda - beda. <br>  <i>Saya akan membuat reservasi di sini bahwa itu tidak begitu sederhana, dan mengirim pembaca yang ingin tahu ke akhir artikel</i> . <br><br>  Agar vRouter'y berkomunikasi satu sama lain, dan, sesuai dengan itu, VM yang berada di belakang mereka, mereka bertukar informasi routing melalui <b>pengontrol SDN</b> . <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3cd/6c5/c73/3cd6c5c7399e314b779a4b9ecf18e17e.png" width="900"></a> <br><br>  Untuk masuk ke dunia luar, ada titik keluar dari matriks - gateway jaringan virtual <b>VNGW</b> - GateWay Jaringan Virtual ( <i>istilah saya</i> ). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d8/75f/a55/4d875fa552a4f144fb9338fa0093235c.png" width="900"></a> <br><br><hr><br>  Sekarang perhatikan contoh-contoh komunikasi - dan akan ada kejelasan. <br><br><br><h3>  Komunikasi dalam satu mesin fisik </h3><br>  VM0 ingin mengirim paket ke VM2.  Asumsikan untuk saat ini bahwa ini adalah VM klien tunggal. <br><br><h4>  Pesawat data </h4><br><ol><li>  VM-0 memiliki rute default di antarmuka eth0-nya.  Paket dikirim ke sana. <br>  Antarmuka eth0 ini sebenarnya terhubung ke router virtual vRouter melalui antarmuka tap0 TAP. </li><li>  vRouter menganalisis antarmuka yang menjadi tujuan paket, yaitu, klien mana (VRF) miliknya, memeriksa alamat penerima dengan tabel routing klien ini. </li><li>  Setelah menemukan bahwa penerima pada mesin yang sama berada di belakang port yang berbeda, vRouter hanya mengirim paket ke sana tanpa header tambahan - dalam hal ini, vRouter sudah memiliki catatan ARP. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6be/2e5/1f0/6be2e51f0530a6fc7e9f2c6370c6e0d2.png" width="700"><br><br>  Paket dalam hal ini tidak masuk ke jaringan fisik - itu diarahkan di dalam vRouter. <br><br><br><h4>  Kontrol pesawat </h4><br>  Ketika mesin virtual dimulai, hypervisor memberitahunya: <br><br><ul><li>  Alamat IP-nya sendiri. </li><li>  Rute default adalah melalui alamat IP vRouter di jaringan ini. </li></ul><br>  Melalui API khusus, hypervisor melaporkan ke vRouter: <br><br><ul><li>  Apa yang Anda butuhkan untuk membuat antarmuka virtual. </li><li>  Yang mana (VM) perlu membuat Jaringan Virtual. </li><li>  Ke mana VRF mengikatnya (VN). </li><li>  Catatan ARP statis untuk VM ini adalah antarmuka yang memiliki alamat IP dan alamat MAC yang dilampirkan. </li></ul><br><blockquote>  Dan lagi, prosedur interaksi yang sebenarnya disederhanakan demi memahami konsep. <br></blockquote><img src="https://habrastorage.org/getpro/habr/post_images/e14/f52/d49/e14f52d4935eb6d5fd5213c1bd3baeec.png" width="800"><br><br>  Dengan demikian, semua VM dari satu klien pada mesin yang diberikan, vRouter melihat sebagai jaringan yang terhubung langsung dan dapat merutekan di antara mereka sendiri. <br><br><hr><br>  Tetapi VM0 dan VM1 milik klien yang berbeda, masing-masing, dalam tabel yang berbeda vRouter'a. <br><br>  Apakah mereka dapat berkomunikasi satu sama lain secara langsung tergantung pada pengaturan vRouter dan desain jaringan. <br>  Misalnya, jika VM kedua klien menggunakan alamat publik, atau NAT muncul pada vRouter itu sendiri, maka perutean langsung ke vRouter juga dapat dilakukan. <br><br>  Dalam situasi yang berlawanan, dimungkinkan untuk melintasi ruang alamat - Anda harus melewati server NAT untuk mendapatkan alamat publik - ini mirip dengan mengakses jaringan eksternal, yang dijelaskan di bawah ini. <br><br><hr><br><br><h3>  Komunikasi antara VM terletak di berbagai mesin fisik </h3><br><h4>  Pesawat data </h4><br><ol><li>  Permulaannya persis sama: VM-0 mengirimkan paket dengan tujuan VM-7 (172.17.3.2) secara default. </li><li>  vRouter menerimanya dan kali ini melihat bahwa tujuan berada di komputer lain dan dapat diakses melalui terowongan Tunnel0. </li><li>  Pertama, ia menggantung label MPLS yang mengidentifikasi antarmuka jarak jauh, sehingga di bagian belakang vRouter dapat menentukan di mana menempatkan paket ini tanpa kait tambahan. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/322/f94/328/322f943287f0e8956acc02654bdae580.png" width="1000"></a> <br></li><li>  Tunnel0 memiliki sumber 10.0.0.2, penerima: 10.0.1.2. <br>  vRouter menambahkan header GRE (atau UDP) dan IP baru ke paket aslinya. </li><li>  Tabel perutean vRouter memiliki rute default melalui alamat ToR1 10.0.0.1.  Di sana dan mengirim. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9a/696/b8a/b9a696b8a0e97aba81107a3ad112f001.png" width="700"><br><br></li><li>  ToR1 sebagai anggota jaringan Underlay tahu (misalnya, melalui OSPF) cara mencapai 10.0.1.2, dan mengirimkan paket di sepanjang rute.  Harap dicatat bahwa ECMP termasuk di sini.  Dalam ilustrasi ada dua nexstops, dan aliran yang berbeda akan diletakkan di dalamnya oleh hash.  Dalam kasus pabrik nyata, kemungkinan akan ada 4 nextops. <br><br>  Pada saat yang sama, ia tidak perlu tahu apa yang ada di bawah header IP eksternal.  Faktanya, di bawah IP ada sandwich dari IPv6 melalui MPLS melalui Ethernet melalui MPLS lebih dari GRE lebih dari pada bahasa Yunani. </li><li>  Dengan demikian, di sisi penerima, vRouter menghapus GRE dan, menggunakan label MPLS, memahami antarmuka mana paket ini harus ditransmisikan ke, strip dan kirimkan ke penerima dalam bentuk aslinya. </li></ol><br><br><h4>  Kontrol pesawat </h4><br>  Saat Anda memulai mesin, semua yang terjadi dijelaskan di atas. <br><br>  Dan ditambah yang berikut ini: <br><br><ul><li>  Untuk setiap klien, vRouter mengalokasikan tag MPLS.  Ini adalah label layanan L3VPN di mana pelanggan akan dibagi di mesin fisik yang sama. <br><blockquote>  Sebenarnya, tag MPLS selalu dialokasikan oleh vRouter'om selalu - karena tidak diketahui sebelumnya bahwa mesin hanya akan berinteraksi dengan mesin lain di belakang vRouter'om yang sama dan ini kemungkinan besar tidak terjadi. <br></blockquote></li><li>  vRouter membuat koneksi dengan pengontrol SDN melalui BGP (atau serupa - dalam kasus TF, ini XMPP 0_o). </li><li>  Melalui sesi ini, vRouter memberi tahu pengontrol SDN rute ke jaringan yang terhubung: <br><br><ul><li>  Alamat jaringan </li><li>  Metode Enkapsulasi (MPLSoGRE, MPLSoUDP, VXLAN) </li><li>  Label MPLS klien </li><li>  Alamat IP Anda sebagai nexthop </li></ul><br></li><li>  Pengontrol SDN menerima rute tersebut dari semua vRouter'ov yang terhubung, dan mencerminkannya ke orang lain.  Artinya, dia bertindak sebagai Route Reflector. </li></ul><br>  Hal yang sama terjadi pada arah yang berlawanan. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e3a/b17/5aae3ab177a4ed58279e4c767618f770.png" width="1000"></a> <br><br>  Hamparan dapat berubah setidaknya setiap menit.  Sesuatu seperti ini terjadi di cloud publik, ketika klien secara teratur memulai dan mematikan mesin virtual mereka. <br><br>  Pengontrol pusat menangani semua kesulitan mempertahankan konfigurasi dan mengendalikan tabel peralihan / perutean pada vRouter. <br><br>  Secara kasar, controller dimatikan dengan semua vRouter melalui BGP (atau protokol yang serupa dengan itu) dan hanya mentransmisikan informasi routing.  BGP, misalnya, sudah memiliki Keluarga Alamat untuk mentransmisikan metode enkapsulasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MPLS-in-GRE</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MPLS-in-UDP</a> . <br><br>  Pada saat yang sama, konfigurasi jaringan Underlay tidak berubah dengan cara apa pun, yang, secara kebetulan, jauh lebih sulit untuk diotomatisasi, dan lebih mudah untuk putus dengan gerakan yang canggung. <br><br><hr><br><br><h3>  Keluar ke dunia luar </h3><br>  Di suatu tempat, simulasi harus berakhir, dan dari dunia virtual Anda harus masuk ke dunia nyata.  Dan Anda memerlukan gateway <s>telepon umum</s> . <br><br>  Dua pendekatan dipraktikkan: <br><br><ol><li>  Perute perangkat keras diinstal. </li><li>  Sebuah alat diluncurkan yang mengimplementasikan fungsi router (ya, kami menghadapi VNF setelah SDN).  Sebut saja gateway virtual. </li></ol><br><blockquote>        â€”    â€”      .    ,     , ,  ,   ,  , , , ,         . <br><br>       ,           ,   ,      ,    ( <i></i> ).     ,  -   ,   ,          â€”    . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan satu kaki, gateway melihat ke dalam jaringan virtual Overlay, seperti Mesin Virtual normal, dan dapat berinteraksi dengan semua VM lainnya. </font><font style="vertical-align: inherit;">Pada saat yang sama, ia dapat mengakhiri sendiri semua jaringan klien dan, dengan demikian, melakukan perutean di antara mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan kaki yang lain, gateway sudah melihat jaringan backbone dan tahu bagaimana menuju ke Internet.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/930/3d2/d1a/9303d2d1a6777510d3bc87bc19349da2.png" width="800"><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesawat data </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artinya, prosesnya terlihat seperti ini: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VM-0, setelah default semua di vRouter yang sama, mengirim paket dengan tujuan di dunia luar (185.147.83.177) ke antarmuka eth0. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vRouter menerima paket ini dan membuat pencarian alamat tujuan di tabel routing - ia menemukan rute default melalui gateway VNGW1 melalui Tunnel 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia juga melihat bahwa ini adalah terowongan GRE dengan SIP 10.0.0.2 dan DIP 10.0.255.2, dan juga pertama-tama menutup MPLS- Label klien ini yang VNGW1 harapkan.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vRouter mengemas paket asli dalam MPLS, GRE, dan header IP baru dan mengirimkannya ke ToR1 10.0.0.1 secara default. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jaringan underlay mengirimkan paket ke gateway VNGW1. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gateway VNGW1 menghapus header tunneling GRE dan MPLS, melihat alamat tujuan, berkonsultasi dengan tabel peruteannya, dan memahami bahwa itu diarahkan ke Internet - ini berarti melalui Tampilan Penuh atau Default. </font><font style="vertical-align: inherit;">Jika perlu, lakukan terjemahan NAT.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari VNGW ke perbatasan, mungkin ada jaringan IP biasa, yang sepertinya tidak mungkin. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini bisa berupa jaringan MPLS klasik (IGP + LDP / RSVP TE), bisa berupa pabrik kembali dengan BGP LU, atau terowongan GRE dari VNGW ke perbatasan melalui jaringan IP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun demikian, VNGW1 melakukan enkapsulasi yang diperlukan dan mengirimkan paket asli ke perbatasan.</font></font></li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d9e/49b/c01/d9e49bc0141200d07b7dbd6710495c83.png" width="1000"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lalu lintas di arah yang berlawanan melewati langkah yang sama dalam urutan yang berlawanan. </font></font><br><br><ol><li>     VNGW1 </li><li>   ,      ,      Tunnel1 (MPLSoGRE  MPLSoUDP). </li><li> ,   MPLS,  GRE/UDP   IP     ToR3 10.0.255.1. <br>    â€” IP- vRouter',      â€” 10.0.0.2. </li><li>       vRouter'. </li><li>  vRouter  GRE/UDP,  MPLS-      IP-   TAP-,   eth0 . </li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d4d/f49/892/d4df4989216a42c06343ba883b8f5db2.png" width="1000"></a> <br><br><br><h4> Control Plane </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGW1 menetapkan lingkungan BGP dengan pengontrol SDN, yang darinya ia menerima semua informasi perutean tentang klien: alamat IP (vRouter'om) mana yang menjadi klien, dan dengan label MPLS mana ia mengidentifikasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demikian pula, ia sendiri memberi tahu pengendali SDN rute default dengan label klien ini, menunjukkan dirinya sebagai nexthop. Dan kemudian default ini datang ke vRouter'y. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGW biasanya agregasi rute atau terjemahan NAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan di arah yang berlawanan, dia memberikan rute agregat ini ke sesi dengan boarders atau Route Reflectors. Dan dari mereka menerima rute default atau Tampilan Penuh, atau sesuatu yang lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal enkapsulasi dan pertukaran lalu lintas, VNGW tidak berbeda dengan vRouter.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda sedikit memperluas area, Anda dapat menambahkan perangkat jaringan lain ke VNGW dan vRouter, seperti firewall, pemurnian lalu lintas atau peternakan pengayaan, IPS, dan sebagainya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan dengan bantuan penciptaan VRF berturut-turut dan pengumuman rute yang benar, Anda dapat membuat perulangan lalu lintas sesuai keinginan, yang disebut dengan Chaining Layanan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yaitu, di sini SDN-controller bertindak sebagai Route-Reflector antara VNGW, vRouter'ami dan perangkat jaringan lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun pada kenyataannya, pengontrol juga merilis informasi tentang ACL dan PBR (Policy Based Routing), memaksa arus lalu lintas individual untuk pergi berbeda dari rute yang mereka minta.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/917/7f6/97a/9177f697a1ff4a7560153286ac04f287.png" width="1000"></a> <br><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faq </font></font></h1><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Anda selalu melakukan komentar GRE / UDP?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara umum, dapat dikatakan spesifik untuk Tungsten Fabric - Anda dapat mengabaikannya sama sekali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika Anda mengambilnya, maka TF itu sendiri, sementara masih OpenContrail, mendukung kedua enkapsulasi: MPLS di GRE dan MPLS di UDP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP bagus karena di Source Port di header-nya sangat mudah untuk kode fungsi hash dari IP + Proto + Port yang asli, yang akan memungkinkan penyeimbangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus GRE, sayangnya, hanya ada IP eksternal dan header GRE yang sama untuk semua lalu lintas yang dienkapsulasi dan tidak ada pembicaraan penyeimbangan - hanya sedikit orang yang dapat melihat begitu dalam di dalam paket.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sampai suatu saat, router, jika mereka tahu cara menggunakan terowongan dinamis, hanya di MPLSoGRE, dan baru-baru ini, belajar di MPLSoUDP. Karena itu, Anda selalu harus membuat komentar tentang kemungkinan dua enkapsulasi yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam keadilan, perlu dicatat bahwa TF sepenuhnya mendukung konektivitas L2 menggunakan VXLAN. </font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda berjanji untuk menggambar paralel dengan OpenFlow.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mereka benar-benar memohon. vSwitch di OpenStack yang sama melakukan hal yang sangat mirip menggunakan VXLAN, yang, kebetulan, juga memiliki header UDP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Data Plane mereka bekerja kurang lebih sama, Control Plane berbeda secara signifikan. Tungsten Fabric menggunakan XMPP untuk mengirimkan informasi rute ke vRouter, sementara Openflow bekerja di OpenStack. </font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah saya mendapat sedikit informasi tentang vRouter?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dibagi menjadi dua bagian: Agen vRouter dan vRouter Forwarder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama diluncurkan di Ruang Pengguna OS host dan berkomunikasi dengan pengontrol SDN, bertukar informasi tentang rute, VRF, dan ACL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang kedua mengimplementasikan Data Plane - biasanya di Kernel Space, tetapi juga dapat diluncurkan pada SmartNICs - kartu jaringan dengan CPU dan chip switching yang dapat diprogram terpisah, yang memungkinkan Anda untuk menghapus beban dari CPU mesin host, dan membuat jaringan lebih cepat dan lebih dapat diprediksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario lain dimungkinkan ketika vRouter adalah aplikasi DPDK di Ruang Pengguna. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agen vRouter menjatuhkan pengaturan pada vRouter Forwarder. </font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu Jaringan Virtual?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sebutkan di awal artikel tentang VRF bahwa setiap penyewa melekat pada VRF-nya. Dan jika ini cukup untuk pemahaman yang dangkal tentang pekerjaan jaringan overlay, maka sudah pada iterasi berikutnya perlu untuk membuat klarifikasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya dalam mekanisme virtualisasi, entitas Jaringan Virtual (Anda dapat menganggapnya sebagai nama yang tepat) diperkenalkan secara terpisah dari klien / penyewa / mesin virtual - ini merupakan hal yang cukup independen. Dan Jaringan Virtual ini melalui antarmuka sudah dapat dihubungkan di satu penyewa, di yang lain, di dua, tapi setidaknya di mana. Jadi, misalnya, Service Chaining diimplementasikan, ketika lalu lintas harus dilewatkan melalui node tertentu dalam urutan yang diinginkan, cukup membuat dan menggunakan Jaringan Virtual dalam urutan yang benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, dengan demikian, tidak ada korespondensi langsung antara Jaringan Virtual dan penyewa.</font></font><br><br><hr><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah deskripsi yang sangat dangkal dari operasi jaringan virtual dengan overlay dari host dan pengontrol SDN. Tetapi terlepas dari platform virtualisasi mana yang Anda gunakan hari ini, itu akan bekerja dengan cara yang sama, baik itu VMWare, ACI, OpenStack, CloudStack, Tungsten Fabric atau Juniper Contrail. Mereka akan berbeda dalam jenis enkapsulasi dan header, protokol untuk mengirimkan informasi ke perangkat jaringan akhir, tetapi prinsip jaringan overlay yang disesuaikan dengan perangkat lunak yang bekerja di atas jaringan underlay yang relatif sederhana dan statis akan tetap sama.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengatakan bahwa area menciptakan cloud pribadi hingga saat ini, SDN berdasarkan jaringan overlay telah dimenangkan. </font><font style="vertical-align: inherit;">Namun, ini tidak berarti bahwa Openflow tidak memiliki tempat di dunia modern - ini digunakan di OpenStacke dan di VMWare NSX yang sama, sejauh yang saya tahu, Google menggunakannya untuk mengkonfigurasi jaringan yang mendasari. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini saya memberikan tautan ke materi yang lebih rinci, jika Anda ingin mempelajari masalah ini lebih dalam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan apa yang mendasari kita? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi secara umum, tidak ada. </font><font style="vertical-align: inherit;">Dia tidak berubah sepenuhnya. </font><font style="vertical-align: inherit;">Yang perlu dia lakukan jika overlay dari tuan rumah adalah memperbarui rute dan ARP ketika vRouter / VNGW muncul dan menghilang dan menyeret paket di antara mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita merumuskan daftar persyaratan untuk jaringan Underlay.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk dapat menggunakan beberapa protokol routing, dalam situasi kami - BGP. </font></font></li><li>   ,   ,     - . </li><li>  ECMP â€”   . </li><li>   QoS,     ,  ECN. </li><li>  NETCONF â€”   . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mencurahkan sangat sedikit waktu di sini untuk pekerjaan jaringan Underlay itu sendiri. </font><font style="vertical-align: inherit;">Ini karena nanti dalam seri saya akan fokus padanya, dan kami akan menyentuh Overlay hanya secara sepintas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, saya sangat membatasi kita semua, menggunakan sebagai contoh jaringan DC yang dibangun di pabrik Klose dengan routing IP murni dan overlay dari host. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, saya yakin bahwa jaringan apa pun yang memiliki desain dapat dijelaskan secara formal dan otomatis. </font><font style="vertical-align: inherit;">Hanya saja saya mengejar tujuan untuk memahami pendekatan untuk otomatisasi, dan tidak membingungkan semua orang, menyelesaikan masalah secara umum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai bagian dari ADSM, Roman Gorge dan saya berencana untuk menerbitkan masalah terpisah tentang virtualisasi daya komputasi dan interaksinya dengan virtualisasi jaringan. </font><font style="vertical-align: inherit;">Tetap berkomunikasi.</font></font><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tautan yang bermanfaat </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur Kain Tungsten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang: cloud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">6 jam tentang Yandex.Cloud, di mana jaringan virtual pada TF juga terpengaruh.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu Open vSwitch?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar VxLAN</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 7348. Virtual eXtensible Local Area Network (VXLAN): Kerangka untuk Overlay Jaringan Layer 2 yang Tervirtualisasi melalui Jaringan Layer 3.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan Scaleway ke VXLAN EVPN Fabric</a> .  Ini menceritakan tentang seluruh jaringan DC, termasuk Underlay, Overlay, pendekatan multi-homing dan manajemen. </li></ul><br><h5>  Terima kasih </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Roman Gorge</a> , mantan pembawa acara utama podcast linkmeup, dan sekarang menjadi pakar di bidang platform cloud.  Untuk komentar dan pengeditan.  Nah, kami menantikan artikel yang lebih dalam tentang virtualisasi dalam waktu dekat. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Shalimov</a> , kolega dan pakar saya dalam pengembangan jaringan virtual.  Untuk komentar dan pengeditan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Valentina Sinitsyna</a> , kolega saya dan pakar Tungsten Fabric.  Untuk komentar dan pengeditan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artyom Chernobay</a> - ilustrator linkmeup.  Untuk KDPV. </li><li>  Alexander Limonov.  Untuk meme "automato". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458622/">https://habr.com/ru/post/id458622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458604/index.html">Mengapa dua produsen elektronik terbesar bergabung dalam proyek GPU baru</a></li>
<li><a href="../id458606/index.html">Jalankan OpenVPN di Docker dalam 2 detik</a></li>
<li><a href="../id458608/index.html">Alat Pengembang Node.js Antrian pekerjaan</a></li>
<li><a href="../id458612/index.html">Kosmos 7 tahun</a></li>
<li><a href="../id458614/index.html">Membuat hook UsePosition () reaktif untuk mendapatkan dan melacak koordinat browser</a></li>
<li><a href="../id458624/index.html">Bagaimana kami belajar menggambar teks di atas kanvas</a></li>
<li><a href="../id458626/index.html">StealthWatch: konsep dasar dan persyaratan minimum. Bagian 1</a></li>
<li><a href="../id458630/index.html">Sedikit sejarah mengembangkan game Anda di Windows Forms + C # murni dalam 16 tahun saya</a></li>
<li><a href="../id458632/index.html">Benar-benar mengetik vue</a></li>
<li><a href="../id458634/index.html">"Jangan jahat" atau apa yang disembunyikan Facebook dari kami</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>