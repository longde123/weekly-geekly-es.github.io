<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤭 🤜🏽 🤳🏼 toString: Hebat dan Mengerikan 🎎 💆🏾 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fungsi toString dalam JavaScript mungkin adalah yang paling "implisit" yang dibahas baik di antara pengembang js sendiri maupun di antara pengamat eks...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>toString: Hebat dan Mengerikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414495/"><p><img src="https://habrastorage.org/webt/on/px/4c/onpx4cu-vxqkdask5tvj3so9va4.jpeg" alt="gambar"></p><br><p>  Fungsi <em>toString</em> dalam <strong>JavaScript</strong> mungkin <strong>adalah</strong> yang paling "implisit" yang dibahas baik di antara pengembang js sendiri maupun di antara pengamat eksternal.  Dia adalah penyebab banyak lelucon dan meme tentang banyak operasi aritmatika yang mencurigakan, transformasi yang masuk ke dalam <em>objek [objek Obyek] yang</em> pingsan.  Ini kebobolan, mungkin, hanya mengejutkan ketika bekerja dengan float64. </p><br><p>  Kasus-kasus menarik yang harus saya amati, gunakan atau atasi, memotivasi saya untuk menulis tanya jawab.  Kami akan berpacu dengan spesifikasi bahasa dan menggunakan contoh-contoh untuk menganalisis fitur <em>toString yang</em> tidak jelas. </p><br><p> Jika Anda mengharapkan panduan yang bermanfaat dan memadai, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini,</a> dan materi itu lebih cocok untuk Anda.  Jika rasa ingin tahu Anda masih menang atas pragmatisme, maka silakan, di bawah kucing. </p><a name="habracut"></a><br><h3 id="vse-chto-nuzhno-znat">  Yang perlu Anda ketahui </h3><br><p>  Fungsi <em>toString</em> adalah properti dari objek prototipe <em>Object</em> , dengan kata sederhana metodenya.  Ini digunakan untuk konversi string objek dan harus mengembalikan nilai primitif dengan cara yang baik.  Objek prototipe juga memiliki implementasinya: <em>Fungsi, Array, String, Boolean, Number, Symbol, Date, RegExp, Error</em> .  Jika Anda mengimplementasikan objek prototipe (kelas), maka <em>toString</em> akan menjadi bentuk yang baik untuk itu. </p><br><p>  <em>JavaScript</em> adalah bahasa dengan sistem tipe lemah: yang artinya memungkinkan kita untuk mencampur jenis yang berbeda, melakukan banyak operasi secara implisit.  Dalam konversi, <em>toString</em> dipasangkan dengan <em>valueOf</em> untuk mengurangi objek ke primitif yang diperlukan untuk operasi.  Misalnya, operator tambahan berubah menjadi penggabungan jika ada setidaknya satu baris di antara operator.  Beberapa fungsi standar bahasa sebelum pekerjaan mereka menyebabkan argumen ke string: <em>parseInt, decodeURI, JSON.parse, btoa,</em> dan sebagainya. </p><br><p>  Cukup banyak yang telah dikatakan dan diejek tentang casting implisit.  Kami akan mempertimbangkan implementasi <em>toString</em> objek prototipe bahasa utama. </p><br><h3 id="objectprototypetostring">  Object.prototype.toString </h3><br><p>  Jika kita beralih ke bagian yang sesuai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari</a> spesifikasi, kita menemukan bahwa tugas utama dari default <em>toString</em> adalah untuk mendapatkan <strong>tag yang</strong> disebut untuk menyambung ke string yang dihasilkan: </p><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"[object "</span></span> + tag + <span class="hljs-string"><span class="hljs-string">"]"</span></span></code> </pre> <br><p>  Untuk melakukan ini: </p><br><ol><li>  Panggilan ke simbol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>toStringTag</em></a> internal (atau properti pseudo <em>[[Kelas]]</em> dalam edisi lama) terjadi: ia memiliki banyak objek prototipe bawaan ( <em>Peta, Matematika, JSON,</em> dan lainnya). </li><li>  Jika ada yang hilang atau bukan string, maka sejumlah properti pseudo-internal lainnya dan metode yang memberi sinyal jenis objek disebutkan: <em>[[Panggil]]</em> untuk <em>Fungsi</em> , <em>[[Nilai</em> <em>Tanggal</em> <em>]]</em> untuk <em>Tanggal,</em> dan sebagainya. </li><li>  Nah, jika tidak ada sama sekali, maka <em>tag</em> adalah <em>"Objek"</em> . </li></ol><br><p>  Mereka yang dipengaruhi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refleksi</a> akan segera mencatat kemungkinan mendapatkan jenis objek dengan operasi sederhana (tetapi tidak direkomendasikan oleh spesifikasi, tetapi mungkin): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getObjT = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(obj).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br><p>  Keunikan dari <em>toString</em> default adalah bahwa ia bekerja dengan nilai <em>ini</em> .  Jika primitif, maka akan dilemparkan ke objek ( <em>null</em> dan <em>undefined</em> diperiksa secara terpisah).  Tidak Ada <em>TypeError</em> : </p><br><pre> <code class="javascript hljs">[<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}].map(getObjT); &gt; [<span class="hljs-string"><span class="hljs-string">"Number"</span></span>, <span class="hljs-string"><span class="hljs-string">"Null"</span></span>, <span class="hljs-string"><span class="hljs-string">"Function"</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>, <span class="hljs-string"><span class="hljs-string">"GeneratorFunction"</span></span>]</code> </pre> <br><p>  Bagaimana ini bisa berguna?  Misalnya, ketika mengembangkan alat untuk analisis kode dinamis.  Memiliki kumpulan variabel dadakan yang digunakan selama kerja aplikasi, Anda dapat mengumpulkan statistik homogen yang berguna saat run-time. </p><br><p>  Pendekatan ini memiliki satu kelemahan utama: tipe pengguna.  Tidak sulit untuk menebak bahwa untuk contoh mereka, kita hanya mendapatkan <em>"Objek"</em> . </p><br><h3 id="kastomnyy-symboltostringtag-i-functionname">  Kustom Symbol.toStringTag dan Function.name </h3><br><p>  OOP dalam JavaScript didasarkan pada prototipe, dan bukan pada kelas (seperti di Jawa), dan kami tidak memiliki metode <em>getClass ()</em> siap pakai.  Definisi eksplisit karakter <em>toStringTag</em> untuk tipe pengguna akan membantu menyelesaikan masalah: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Cat'</span></span>; } }</code> </pre> <br><p>  atau dalam gaya prototipe: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} Dog.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>;</code> </pre> <br><p>  Ada solusi alternatif melalui <em>Function.name</em> properti read-only, yang belum menjadi bagian dari spesifikasi, tetapi didukung oleh sebagian besar browser.  Setiap instance dari objek / kelas prototipe memiliki tautan ke fungsi konstruktor yang dengannya ia dibuat.  Jadi kita bisa mengetahui nama jenisnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Cat'</span></span></code> </pre> <br><p>  atau dalam gaya prototipe: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Dog'</span></span></code> </pre> <br><p>  Tentu saja, solusi ini tidak berfungsi untuk objek yang dibuat menggunakan fungsi anonim ( <em>"anonim"</em> ) atau <em>Object.create (null)</em> , atau untuk primitif tanpa objek pembungkus ( <em>null, undefined</em> ). </p><br><p>  Dengan demikian, untuk manipulasi jenis variabel yang andal, ada baiknya menggabungkan teknik-teknik terkenal, terutama berdasarkan pada tugas yang dihadapi.  Dalam sebagian besar kasus, jenis dan <em>contoh</em> sudah cukup. </p><br><h3 id="functionprototypetostring">  Function.prototype.toString </h3><br><p>  Kami sedikit terganggu, tetapi akibatnya kami sampai pada fungsi yang memiliki <em>toString yang</em> menarik.  Pertama, lihat kode berikut: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'('</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee.toString() + <span class="hljs-string"><span class="hljs-string">')()'</span></span>); })()</code> </pre> <br><p>  Banyak yang mungkin menduga bahwa ini adalah contoh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quine</a> .  Jika Anda memuat skrip dengan konten seperti itu ke badan halaman, maka salinan kode sumber yang tepat akan ditampilkan di konsol.  Ini karena panggilan <em>toString</em> dari fungsi <em>arguments.callee</em> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> <em>toString dari</em> objek prototipe <em>Function yang digunakan</em> mengembalikan representasi string dari kode sumber fungsi, mempertahankan sintaks yang digunakan dalam definisi: <em>FunctionDeclaration, FunctionExpression, ClassDeclaration, ArrowFunction</em> , dll. </p><br><p>  Misalnya, kami memiliki fungsi panah: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(ctx, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br><p>  Memanggil <em>bind.toString ()</em> akan mengembalikan kepada kami representasi string dari <em>ArrowFunction</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"(f, ctx) =&gt; function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Dan memanggil <em>toString</em> dari fungsi yang dibungkus sudah merupakan representasi string dari <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Contoh <em>bind</em> ini tidak disengaja, karena kami memiliki solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">siap pakai</a> dengan <em>Function.prototype.bind yang</em> mengikat konteks, dan mengenai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi terikat</a> asli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> ada fitur <em>Function.prototype.toString yang</em> bekerja dengannya.  Bergantung pada implementasinya, representasi dari fungsi yang dibungkus itu sendiri dan fungsi <em>target</em> dapat diperoleh.  V8 dan SpiderMonkey versi terbaru dari chrome and ff: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } getx.bind({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).toString() &lt; <span class="hljs-string"><span class="hljs-string">"function () { [native code] }"</span></span></code> </pre> <br><p>  Karena itu, kehati-hatian harus dilakukan dengan fitur yang didekorasi secara asli. </p><br><h3 id="praktika-ispolzovaniya-ftostring">  Berlatih menggunakan f.toString </h3><br><p>  Ada banyak opsi untuk menggunakan <em>toString yang</em> dimaksud, tetapi hanya mendesak sebagai alat pemrograman atau debug.  Memiliki aplikasi tipikal yang serupa dalam logika bisnis cepat atau lambat akan menyebabkan palung yang tidak didukung. </p><br><p>  Hal paling sederhana yang terlintas dalam pikiran adalah <strong>menentukan panjang fungsi</strong> : </p><br><pre> <code class="javascript hljs">f.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Lokasi dan jumlah karakter spasi putih dari hasil <em>toString</em> diberikan oleh spesifikasi untuk pembelian implementasi tertentu, oleh karena itu, untuk kebersihan, pertama-tama kami menghapus kelebihannya, yang mengarah ke tampilan umum.  Omong-omong, di versi Gecko engine yang lebih lama, fungsinya memiliki parameter <em>indentasi</em> khusus yang membantu memformat indentasi. </p><br><p>  <strong>Definisi nama parameter fungsi</strong> langsung terlintas dalam pikiran, yang dapat berguna untuk refleksi: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/^function(?:\s+\w+)?\s*\(([^\)]+)/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-regexp"><span class="hljs-regexp">/\s*,\s*/</span></span>)</code> </pre> <br><p>  Solusi lutut ini cocok untuk sintaks <em>FunctionDeclaration</em> dan <em>FunctionExpression</em> .  Jika Anda memerlukan yang lebih rinci dan akurat, saya sarankan Anda mencari contoh kode sumber kerangka kerja favorit Anda, yang mungkin memiliki beberapa jenis injeksi ketergantungan di bawah tenda, berdasarkan nama-nama parameter yang dinyatakan. </p><br><p>  Opsi berbahaya dan menarik untuk <strong>mengganti fungsi</strong> melalui <em>eval</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prod = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(sum.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\+(?=\s*(?:a|b))/gm</span></span>, <span class="hljs-string"><span class="hljs-string">'*'</span></span>)); sum(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">15</span></span> prod(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span></code> </pre> <br><p>  Mengetahui struktur fungsi asli, kami membuat yang baru dengan mengganti operator tambahan yang digunakan dalam tubuhnya dengan argumen dengan perkalian.  Dalam hal kode yang dibuat oleh perangkat lunak atau tidak adanya antarmuka ekstensi fungsi, ini bisa berguna secara ajaib.  Misalnya, jika Anda meneliti model matematika, memilih fungsi yang sesuai, bermain dengan operator dan koefisien. </p><br><p>  Penggunaan yang lebih praktis adalah <strong>kompilasi dan distribusi template</strong> .  Banyak implementasi mesin template mengkompilasi kode sumber template dan menyediakan fungsi data yang sudah membentuk HTML akhir (atau lainnya).  Berikut ini adalah contoh dari fungsi <a href="">_.template</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloJst = <span class="hljs-string"><span class="hljs-string">"Hello, &lt;%= user %&gt;"</span></span> _.template(helloJst)({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Tetapi bagaimana jika mengkompilasi template membutuhkan sumber daya perangkat keras atau klien sangat tipis?  Dalam hal ini, kita bisa mengkompilasi template di sisi server dan memberikan klien bukan teks template, tetapi representasi string dari fungsi yang sudah selesai.  Selain itu, Anda tidak perlu memuat pustaka template pada klien. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloStr = _.template(helloJst).toString() helloStr &lt; <span class="hljs-string"><span class="hljs-string">"function(obj) { obj || (obj = {}); var __t, __p = ''; with (obj) { __p += 'Hello, ' + ((__t = ( user )) == null ? '' : __t); } return __p }"</span></span></code> </pre> <br><p>  Sekarang kita perlu menjalankan kode ini pada klien sebelum digunakan.  Bahwa saat dikompilasi tidak ada <em>Sintaksis</em> karena sintaks <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(helloStr.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^function\(obj\)/</span></span>, <span class="hljs-string"><span class="hljs-string">'obj=&gt;'</span></span>));</code> </pre> <br><p>  atau lebih: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`const f = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${helloStr}</span></span></span><span class="hljs-string">;f`</span></span>);</code> </pre> <br><p>  Atau sesuka Anda.  Bagaimanapun: </p><br><pre> <code class="javascript hljs">helloFn({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Ini mungkin bukan praktik terbaik untuk mengkompilasi template di sisi server dan mendistribusikannya ke klien lebih lanjut.  Hanya sebuah contoh menggunakan sekelompok <em>Function.prototype.toString</em> dan <em>eval</em> . </p><br><p>  Akhirnya, tugas lama untuk <strong>mendefinisikan nama fungsi</strong> (sebelum properti <em>Function.name</em> muncul) melalui <em>toString</em> : </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Tentu saja, ini berfungsi baik dengan sintaks <em>FunctionDeclaration</em> .  Solusi yang lebih cerdas akan membutuhkan kecocokan ekspresi reguler atau pencocokan pola. </p><br><p>  Internet penuh dengan solusi menarik berdasarkan <em>Function.prototype.toString</em> , tanyakan saja.  Bagikan pengalaman Anda dalam komentar: sangat menarik. </p><br><h3 id="arrayprototypetostring">  Array.prototype.toString </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> <em>toString dari</em> objek prototipe <em>Array</em> bersifat generik dan dapat dipanggil untuk objek apa pun.  Jika objek memiliki metode <em>bergabung</em> , maka hasil <em>toString</em> akan menjadi panggilannya, jika tidak, <em>Object.prototype.toString</em> . </p><br><p>  <em>Array</em> , secara logis, memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode</a> gabungan yang menggabungkan representasi string dari semua elemennya melalui <em>pemisah yang</em> dilewatkan sebagai parameter (defaultnya adalah koma). </p><br><p>  Misalkan kita perlu menulis fungsi yang membuat serial daftar argumennya.  Jika semua parameter adalah primitif, maka dalam banyak kasus kita dapat melakukannya tanpa <em>JSON.stringify</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>).toString(); }</code> </pre> <br><p>  atau lebih: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seria = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.toString();</code> </pre> <br><p>  Ingatlah bahwa string '10' dan nomor 10 akan diserialisasi dengan yang sama.  Dalam masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memoizer terpendek</a> pada satu tahap, solusi ini digunakan. </p><br><p>  Gabungan asli elemen array bekerja melalui siklus aritmatika dari 0 hingga <em>panjang</em> dan tidak memfilter untuk elemen yang hilang ( <em>null</em> dan <em>tidak terdefinisi</em> ).  Sebaliknya, rangkaian terjadi dengan <em>pemisah</em> .  Ini mengarah pada hal berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); ar.toString() &lt; <span class="hljs-string"><span class="hljs-string">",,,...,,,"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1000 times</span></span></code> </pre> <br><p>  Oleh karena itu, jika karena satu dan lain alasan Anda menambahkan elemen dengan indeks besar ke array (misalnya, ini adalah id alami yang dihasilkan), dalam kasus apa pun tidak bergabung dan, karenanya, tidak mengarah ke string tanpa persiapan awal.  Jika tidak, mungkin ada konsekuensi: <em>Panjang string tidak valid, kehabisan memori</em> atau hanya skrip yang menggantung.  Gunakan fungsi-fungsi objek <em>Nilai</em> - <em>nilai objek</em> dan <em>kunci</em> untuk beralih di atas properti yang disebutkan sendiri dari objek saja: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> k = []; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">20</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1,2,3"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1024,1048576,1073741824"</span></span></code> </pre> <br><p>  Tetapi jauh lebih baik untuk menghindari penanganan array seperti itu: kemungkinan besar objek bernilai kunci sederhana akan cocok untuk Anda sebagai penyimpanan. </p><br><p>  Ngomong-ngomong, bahaya yang sama muncul saat membuat serial melalui <em>JSON.stringify</em> .  Hanya lebih serius, karena elemen kosong dan tidak didukung sudah direpresentasikan sebagai <em>"null"</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(ar); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">]" // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1000</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">times</span></span></span></span></span></span></code> </pre> <br><p>  Mengakhiri bagian ini, saya ingin mengingatkan Anda bahwa Anda dapat mendefinisikan metode <em>bergabung</em> Anda untuk tipe pengguna dan memanggil <em>Array.prototype.toString.call</em> sebagai alternatif untuk string, tetapi saya ragu bahwa ia memiliki penggunaan praktis. </p><br><h3 id="numberprototypetostring-i-parseint">  Number.prototype.toString dan parseInt </h3><br><p>  Salah satu tugas favorit saya untuk kuis js adalah Apa yang akan mengembalikan panggilan <em>parseInt</em> berikutnya? </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Hal pertama yang dilakukan <em>parseInt</em> adalah secara implisit melemparkan argumen ke string dengan memanggil fungsi abstrak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>ToString</em></a> , yang, tergantung pada jenis argumen, mengeksekusi cabang cast yang diinginkan.  Untuk <em>nomor</em> jenis, berikut ini dilakukan: </p><br><ol><li>  Jika nilainya <em>NaN, 0,</em> atau <em>Infinity</em> , maka kembalikan string yang sesuai. </li><li>  Jika tidak, algoritma mengembalikan catatan nomor yang paling nyaman untuk manusia: dalam bentuk desimal atau eksponensial. </li></ol><br><p>  Saya tidak akan menduplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma untuk</a> menentukan formulir yang disukai di sini, saya hanya akan mencatat yang berikut: jika jumlah digit dalam notasi desimal melebihi <strong>21</strong> , maka formulir eksponensial akan dipilih.  Dan ini berarti bahwa dalam kasus kami <em>parseInt</em> tidak bekerja dengan "100 ... 000" tetapi dengan "1e30".  Karena itu, jawabannya sama sekali tidak diharapkan 2 ^ 30.  Siapa yang tahu sifat sihir nomor 21 ini - tulis! </p><br><p>  Selanjutnya, <em>parseInt</em> melihat dasar sistem nomor <em>radix</em> yang digunakan (secara default 10, kita memiliki 2) dan memeriksa karakter string yang diterima untuk kompatibilitas dengan itu.  Setelah bertemu 'e', ​​ia memotong seluruh ekor, hanya menyisakan "1".  Hasilnya akan berupa bilangan bulat yang diperoleh dengan mengkonversi dari sistem dengan basis radix ke desimal - dalam kasus kami, ini adalah 1. </p><br><p>  Prosedur Mundur: </p><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Di sinilah fungsi <em>toString</em> dipanggil dari objek prototipe <em>Number</em> , yang menggunakan algoritma yang sama untuk melemparkan <em>nomor</em> ke string.  Ini juga memiliki parameter <em>radix</em> opsional.  Hanya itu melempar <em>RangeError</em> untuk nilai yang tidak valid (harus bilangan bulat dari 2 hingga 36 inklusif), sementara <em>parseInt</em> mengembalikan <em>NaN</em> . </p><br><p>  Perlu diingat batas atas sistem angka jika Anda berencana untuk mengimplementasikan fungsi hash yang eksotis: <em>toString</em> ini mungkin tidak bekerja untuk Anda. </p><br><p>  Tugas untuk mengalihkan perhatian sejenak: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'3113'</span></span>.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(<span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>)</code> </pre> <br><p>  Apa yang akan kembali dan bagaimana cara memperbaikinya? </p><br><h3 id="obdelennoe-vnimaniem">  Kehilangan perhatian </h3><br><p>  Kami memeriksa <em>toString</em> tidak berarti bahkan semua objek prototipe asli.  Sebagian, karena secara pribadi saya tidak perlu mendapat masalah dengan mereka, dan tidak ada banyak yang menarik di dalamnya.  Selain itu, kami tidak menyentuh fungsi <em>toLocaleString</em> , karena akan menyenangkan untuk membicarakannya secara terpisah.  Jika saya melakukan sesuatu dengan sia-sia kehilangan perhatian, kehilangan pandangan atau disalahpahami - pastikan untuk menulis! </p><br><h3 id="prizyv-k-bezdeystviyu">  Panggilan untuk tidak bertindak </h3><br><p>  Contoh-contoh yang saya kutip bukanlah resep siap pakai - hanya makanan yang dipikirkan.  Selain itu, saya merasa tidak ada gunanya dan sedikit bodoh untuk membahas ini pada wawancara teknis: untuk ini ada topik abadi tentang penutupan, bergabung, loop acara, pola modul / fasad / mediator, dan pertanyaan “tentu saja” tentang [kerangka yang digunakan]. </p><br><p>  Artikel ini ternyata gado-gado, dan saya harap Anda menemukan sesuatu yang menarik untuk diri sendiri.  PS Bahasa JavaScript - Luar Biasa! </p><br><h3 id="bonus">  Bonus </h3><br><p>  Dalam mempersiapkan materi ini untuk dipublikasikan, saya menggunakan Google Translate.  Dan secara tidak sengaja saya menemukan efek yang menghibur.  Jika Anda memilih terjemahan dari bahasa Rusia ke bahasa Inggris, masukkan "toString" dan mulai menghapusnya menggunakan tombol Backspace, maka kami akan mengamati: </p><br><p><img src="https://habrastorage.org/webt/op/yl/g3/opylg3burl5dlqv5ojibfeis0c4.gif" alt="bonus"></p><br><p>  Ironi sekali!  Saya pikir saya jauh dari yang pertama, tetapi kalau-kalau saya mengirim tangkapan layar dengan skrip pemutaran.  Sepertinya XSS diri yang tidak berbahaya, itu sebabnya saya membagikannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414495/">https://habr.com/ru/post/id414495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414483/index.html">Ketik Safe SQL di Kotlin</a></li>
<li><a href="../id414485/index.html">GNMT, kegagalan epik atau seluk-beluk terjemahan mesin</a></li>
<li><a href="../id414487/index.html">Perwakilan tipe brute-force yang langka: sejarah satu serangan</a></li>
<li><a href="../id414489/index.html">AS berencana untuk secara serius mengatasi masalah puing-puing luar angkasa</a></li>
<li><a href="../id414493/index.html">Cara menulis kontrak pintar untuk ICO dalam 5 menit</a></li>
<li><a href="../id414497/index.html">API UI Consulo dari ide ke prototipe</a></li>
<li><a href="../id414499/index.html">Laporan Club of Rome 2018, Bab 1.1.3: “Dunia yang Kosong versus Perdamaian Penuh”</a></li>
<li><a href="../id414501/index.html">Laporan Club of Rome 2018, Bab 3.11: “Reformasi Sektor Keuangan”</a></li>
<li><a href="../id414503/index.html">Intel NUC Hades Canyon dengan AMD Vega Graphics - VR or Not VR?</a></li>
<li><a href="../id414505/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>