<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóØÔ∏è üë©üèΩ‚Äçüåæ üíÇ Fale sobre o PAKE üê¢ üî¥ üç¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Agora vamos falar sobre seguran√ßa da informa√ß√£o. Esta publica√ß√£o √© dedicada ao lan√ßamento do curso "Seguran√ßa da Informa√ß√£o Criptogr√°fica" , que come√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fale sobre o PAKE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453334/">  Agora vamos falar sobre seguran√ßa da informa√ß√£o.  Esta publica√ß√£o √© dedicada ao lan√ßamento do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Seguran√ßa da Informa√ß√£o Criptogr√°fica"</a> , que come√ßar√° em 30 de maio.  Vamos l√° <br><br>  Primeira regra do PAKE: nunca fale sobre o PAKE.  A segunda regra do PAKE afirma que a primeira regra n√£o faz sentido, pois o PAKE ou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Password Authenticated Key Exchange</a> (rus. Troca de chaves com autentica√ß√£o por senha) √© uma das tecnologias mais √∫teis que praticamente nunca √© usada em nenhum lugar.  Deve ser implementado sempre que poss√≠vel, mas n√£o t√£o simples. <br><br><img src="https://habrastorage.org/webt/gk/qt/xa/gkqtxaksei42embld2iyquekz44.png"><br><br><a name="habracut"></a><br>  Para entender por que estamos falando de bobagens, vejamos um problema real. <br><br>  Suponha que eu trabalhe com um servidor que armazene senhas de usu√°rios.  Existe uma maneira tradicional de armazenar - hash de cada senha de usu√°rio e armazenamento do resultado em um banco de dados de senhas.  H√° muitas id√©ias sobre como lidar com o processo de hash.  A recomenda√ß√£o mais comum hoje em dia √© usar uma fun√ß√£o de hash de senha com mem√≥ria dif√≠cil (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">scrypt</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">argon2</a> (com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sal exclusivo</a> ) para cada senha) e armazenar o resultado do hash.  Existem opini√µes diferentes sobre qual fun√ß√£o hash usar e se ela pode usar algum valor secreto (chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"pimenta"</a> ), mas, por enquanto, n√£o falaremos sobre isso. <br><br>  Independentemente da abordagem escolhida, todas essas solu√ß√µes t√™m um calcanhar de Aquiles: <br>  <i>Quando o usu√°rio retornar para entrar no site, ele ainda precisar√° enviar sua senha (aberta) ao servidor para que ele fa√ßa a verifica√ß√£o</i> . <br><br>  Essa necessidade pode levar a conseq√º√™ncias desagrad√°veis ‚Äã‚Äãse o servidor estiver comprometido ou se os desenvolvedores cometerem algum erro est√∫pido.  Por exemplo, no in√≠cio do ano passado, o Twitter pediu a todos os seus usu√°rios (e esses 330 milh√µes!) Que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alterassem senhas</a> - porque a empresa armazenava senhas de texto (sem hash). <br><br>  No momento, o problema de fazer login n√£o contradiz os benef√≠cios do hash de senha.  No entanto, voc√™ precisa encontrar uma solu√ß√£o melhor: aquela em que a senha nunca seja enviada ao servidor em texto n√£o criptografado.  A ferramenta criptogr√°fica que nos ajudar√° a conseguir isso √© o PAKE e, em particular, um novo protocolo chamado OPAQUE, que abordaremos no final deste artigo. <br><br><h2>  O que √© o PAKE? </h2><br>  O protocolo PAKE, proposto pela primeira vez por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bellovin e Merritt</a> , √© um tipo espec√≠fico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de protocolo de troca de chaves</a> .  Os protocolos de troca de chaves (ou "contratos de chave") s√£o projetados para ajudar as duas partes (vamos cham√°-las de cliente e servidor) a concordar com uma chave compartilhada usando criptografia de chave p√∫blica.  Os primeiros protocolos de troca de chaves (por exemplo, o cl√°ssico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Diffie-Hellman</a> ) n√£o eram autorizados, o que os tornava vulner√°veis ‚Äã‚Äãa ataques como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">homem do meio</a> .  Uma caracter√≠stica distintiva dos protocolos PAKE √© que o cliente se autentica no servidor com uma senha.  Por raz√µes √≥bvias, sup√µe-se que a senha ou seu hash j√° seja conhecido pelo servidor, o que permite a verifica√ß√£o. <br><br>  Se isso fosse tudo o que era necess√°rio, os protocolos PAKE seriam f√°ceis de construir.  Mas o que torna o PAKE realmente √∫til √© que ele tamb√©m fornece prote√ß√£o por senha do cliente.  Uma garantia mais s√©ria pode ser formulada da seguinte maneira: ap√≥s uma tentativa de entrar no sistema (bem-sucedida ou malsucedida), o cliente e o servidor devem saber apenas se a senha do cliente corresponde ao valor esperado pelo servidor e n√£o h√° mais informa√ß√µes adicionais.  Esta √© uma defesa muito boa.  De fato, isso n√£o √© diferente do que exigimos de uma prova de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">divulga√ß√£o zero</a> . <br><br><img src="https://habrastorage.org/webt/fv/s6/kt/fvs6ktjjxphiyeae5k13gtw0w4y.png"><br><blockquote>  Uma representa√ß√£o idealizada do protocolo PAKE.  A entrada de ambos os lados inclui alguma aleatoriedade, que n√£o √© mostrada aqui.  O bisbilhoteiro n√£o precisa descobrir a chave secreta compartilhada K, que √© aleat√≥ria e n√£o √© uma fun√ß√£o da senha. </blockquote><br>  Obviamente, o problema √≥bvio com o PAKE √© que muitos desenvolvedores n√£o desejam executar o protocolo de ‚Äútroca de chaves‚Äù em primeiro lugar!  Eles s√≥ querem garantir que o usu√°rio saiba a senha. <br><br>  O melhor do PAKE √© que o caso de uso "somente login" √© muito f√°cil de executar.  Suponha que eu tenha um protocolo PAKE padr√£o que permita que o cliente e o servidor concordem com uma chave comum K. Se ele souber a senha correta (e somente neste caso), tudo o que precisamos implementar √© uma verifica√ß√£o simples de que ambas as partes receberam a mesma chave.  (Isso pode ser feito, por exemplo, se as partes calcularem alguma fun√ß√£o criptogr√°fica e verificarem os resultados.) Assim, o PAKE pode ser √∫til mesmo que voc√™ queira apenas verificar a senha. <br><br><h2>  SRP: PAKE, sobre o qual o pr√≥prio tempo esqueceu </h2><br>  O conceito PAKE parece fornecer uma vantagem √≥bvia de seguran√ßa em rela√ß√£o √† abordagem ing√™nua que usamos hoje para entrar no servidor.  E os m√©todos em si s√£o antigos, no sentido de que o PAKE √© conhecido desde 1992!  Apesar disso, a luz nunca o viu.  Por que isso est√° acontecendo? <br><br>  Existem v√°rias raz√µes √≥bvias.  O mais √≥bvio est√° relacionado √†s limita√ß√µes da Internet: √© muito mais f√°cil colocar um formul√°rio de senha em uma p√°gina da Web do que implementar criptografia sofisticada em um navegador.  No entanto, essa explica√ß√£o n√£o √© suficiente.  Mesmo aplicativos nativos raramente implementam o PAKE para opera√ß√µes de login.  Outra explica√ß√£o poss√≠vel est√° relacionada √†s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patentes</a> , embora a maioria j√° tenha expirado.  Para mim, h√° duas raz√µes prov√°veis ‚Äã‚Äãpara n√£o ter PAKE: <br><br><ul><li>  Falta de implementa√ß√µes PAKE de alta qualidade em idiomas populares, o que torna dif√≠cil o uso; </li><li>  Os especialistas em criptografia n√£o transmitem mal a ess√™ncia e o valor de seu trabalho; portanto, a maioria das pessoas nem sabe que o PAKE existe. </li></ul><br>  Apesar de eu ter dito que o PAKE n√£o √© usado agora, ainda existem exce√ß√µes √†s regras. <br><br>  H√° um √≥timo protocolo desenvolvido em 1998 por Tom Wu (que n√£o deve ser confundido com Tim Wu), que √© chamado de "SRP" (abrevia√ß√£o de "Secure Remote Password").  Na verdade, √© apenas um PAKE de tr√™s est√°gios, com algumas fun√ß√µes adicionais que n√£o foram implementadas nos primeiros trabalhos.  At√© onde eu sei, o SRP difere por ser o protocolo PAKE mais comum no mundo.  Darei duas provas desta afirma√ß√£o: <br><br><ol><li>  O SRP foi padronizado como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TLS ciphersuite</a> e implementado em bibliotecas como, por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenSSL</a> , embora ningu√©m pare√ßa us√°-lo especialmente. </li><li>  A Apple faz amplo uso do SRP em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">iCloud Key Vault</a> </li></ol><br>  O segundo fato em si poderia fazer do SRP um dos protocolos criptogr√°ficos mais usados ‚Äã‚Äãno mundo, o n√∫mero de dispositivos que a Apple carimba √© t√£o grande.  E n√£o h√° nada engra√ßado. <br><br>  O fato de a ind√∫stria ter aceito o SRP √© certamente bom, mas por outro lado, e n√£o muito.  Principalmente porque, embora qualquer endosso do PAKE seja legal, o SRP por si s√≥ n√£o √© a melhor implementa√ß√£o do PAKE.  Eu pensei em entrar na selva de discuss√µes sobre SRP, mas esse discurso j√° estava se arrastando, e discordo da hist√≥ria sobre um protocolo realmente bom, sobre o qual falaremos abaixo.  Se voc√™ ainda est√° interessado na discuss√£o sobre SRP, eu trouxe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em vez desses detalhes desnecess√°rios, deixe-me escrever um breve resumo dos meus pensamentos sobre SRP: <br><br><ol><li>  O SRP faz algumas coisas corretamente.  Primeiro, ao contr√°rio das vers√µes anteriores do PAKE, voc√™ n√£o precisa armazenar a senha bruta no servidor (ou, equivalente, um hash que poderia ser usado por um invasor em vez de uma senha).  Em vez disso, o servidor armazena um "verificador", que √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√£o</a> unidirecional do hash da senha.  Isso significa que um vazamento no banco de dados de senhas n√£o permite que um invasor substitua imediatamente um usu√°rio se ele n√£o realizar mais ataques de dicion√°rio dispendiosos.  (O nome t√©cnico para isso √© PAKE "assim√©trico".) </li><li>  H√° not√≠cias melhores, a vers√£o atual do SRP (v4 v6a) ainda n√£o foi invadida! </li><li>  No entanto (n√£o se ofenda com os desenvolvedores), a arquitetura do protocolo SRP √© completamente louca e suas vers√µes anteriores foram hackeadas v√°rias vezes - e √© por isso que agora temos a vers√£o 6a.  Al√©m disso, a "prova de seguran√ßa" no artigo de pesquisa original <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o prova nada</a> . </li><li>  Atualmente, o SRP √© baseado em aritm√©tica inteira (final) e, por v√°rias raz√µes (veja a se√ß√£o 3 acima), sua arquitetura claramente n√£o pode ser transferida para uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">curva</a> el√≠ptica.  Isso requer mais largura de banda e computa√ß√£o; portanto, o SRP n√£o pode tirar proveito das muitas melhorias de desempenho que desenvolvemos em complementos como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curve25519</a> . </li><li>  O SRP √© vulner√°vel a ataques de pr√©-computa√ß√£o, porque passa o sal do usu√°rio para qualquer invasor que possa iniciar uma sess√£o SRP.  Isso significa que posso solicitar o seu servidor e criar um dicion√°rio de poss√≠veis hashes de senha antes que o servidor seja comprometido. </li><li>  Apesar de todas essas defici√™ncias, o SRP √© extremamente simples e tamb√©m vem com c√≥digo de trabalho.  Al√©m disso, o OpenSSL possui um c√≥digo de trabalho que at√© se integra ao TLS, o que facilita a implementa√ß√£o. </li></ol><br>  De todos esses pontos, o √∫ltimo √© quase certamente respons√°vel pelo (relativamente) alto grau de sucesso comercial que o SRP alcan√ßou em rela√ß√£o a outros protocolos PAKE.  Ele n√£o √© perfeito, mas real.  Era isso que eu queria transmitir aos especialistas em seguran√ßa criptogr√°fica. <br><br><h2>  OPAQUE: PAKE nova gera√ß√£o </h2><br>  Quando comecei a pensar no PAKE, h√° alguns meses, n√£o pude deixar de notar que a maioria das implementa√ß√µes existentes teve um desempenho ruim.  Eles tiveram problemas, como no SRP, exigiram que o usu√°rio armazenasse a senha (ou senha efetiva) no servidor ou o "salt" foi mostrado ao invasor, dando a oportunidade de realizar o ataque antes do c√°lculo. <br><br>  Ent√£o, no in√≠cio do ano passado, Jarecki, Kravczyk e Xu revelaram ao mundo um novo protocolo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OPAQUE</a> .  Tem v√°rias vantagens significativas: <br><br><ol><li>  Pode ser implementado mesmo se houver problemas de Diffie-Hellman e logaritmos discretos.  Isso significa que, ao contr√°rio do SRP, ele pode ser facilmente instanciado usando curvas el√≠pticas eficazes. </li><li>  Ainda melhor: OPAQUE n√£o revela sal para um atacante.  Ele resolve esse problema usando o "PRF esquecido" para combinar o salt com a senha, para que o cliente n√£o receba o salt e o servidor n√£o receba a senha. </li><li> OPAQUE trabalha com qualquer fun√ß√£o de hash de senha.  Como todo o trabalho de hash √© realizado no cliente, o OPAQUE pode realmente retirar a carga do servidor, liberando o servi√ßo online, por exemplo, para usar configura√ß√µes de seguran√ßa extremamente volumosas, por exemplo, configurar o <code>scrypt</code> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muita RAM</a> . </li><li>  Em termos de contagem de mensagens e expoente, OPAQUE n√£o √© muito diferente do SRP.  Mas, como pode ser implementado com par√¢metros mais eficientes, √© prov√°vel que funcione com muito mais efici√™ncia. </li><li>  Diferente do SRP, o OPAQUE possui evid√™ncias razo√°veis ‚Äã‚Äãde seguran√ßa (em um modelo muito forte). </li></ol><br>  Existe at√© uma proposta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">preliminar da Internet</a> para o OPAQUE, que voc√™ pode ler aqui.  Infelizmente, no momento n√£o sei nada sobre a qualidade da implementa√ß√£o do c√≥digo, exceto que j√° existem v√°rias implementa√ß√µes em potencial.  Espero que esse problema seja resolvido em breve. <br>  O protocolo OPAQUE completo est√° listado abaixo.  No restante desta se√ß√£o, vou falar sobre como isso funciona. <br><br>  <b>Problema 1: Manter o sal em segredo.</b>  Como mencionei acima, o principal problema com as vers√µes anteriores do PAKE √© a necessidade de transferir sal do servidor para o cliente (ainda n√£o autenticado).  Isso permite que um invasor realize ataques antes da computa√ß√£o, onde pode gerar um dicion√°rio com base nos dados recebidos. <br><br>  O problema aqui √© que o salt geralmente √© passado para uma fun√ß√£o hash (por exemplo, scrypt) junto com a senha.  Intuitivamente, algu√©m precisa calcular essa fun√ß√£o.  Se for um servidor, o servidor dever√° ver uma senha, que mata qualquer significado.  Se este √© um cliente, ele precisa de sal. <br><br>  Teoricamente, voc√™ pode solucionar esse problema computando a fun√ß√£o de hash de senha usando o protocolo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">computa√ß√£o de duas partes seguro (2PC)</a> .  Na pr√°tica, essas solu√ß√µes quase certamente ser√£o ineficazes, principalmente porque as fun√ß√µes de hash de senha s√£o complexas e demoradas.  Isso aumentar√° incrivelmente a complexidade de qualquer sistema 2PC. <br><br>  OPAQUE contorna isso da seguinte maneira.  Deixa um hash de senha no lado do cliente, mas n√£o mostra sal.  Em vez disso, ele usa um protocolo bidirecional especial chamado PRF esquecido para calcular outro salt (vamos cham√°-lo de salt2) para que o cliente possa usar salt2 na fun√ß√£o hash, mas n√£o possa acessar o salt original. <br><br>  Funciona mais ou menos assim: <br><blockquote>  <i>O servidor armazena "salt" e o cliente possui password.salt2 = PRF (salt, senha); isso √© calculado entre o cliente e o servidor usando um protocolo no qual o cliente nunca reconhecer√° o salt e o servidor saber√° a senha.</i>  <i>O cliente recebe salt2K = PasswordHash (salt2, senha) - e tudo isso √© considerado no cliente.</i> </blockquote><br>  A implementa√ß√£o real do PRF esquecido pode ser feita usando v√°rios elementos e expoentes do grupo.  Melhor ainda, se o cliente digitar a senha incorreta, o protocolo receber√° um valor fict√≠cio "salt2", que n√£o diz nada sobre o valor real do sal. <br><br>  <b>Problema 2: Prova de que o cliente recebeu a chave correta K.</b> √â claro que no momento o cliente recebeu a chave K, mas o servidor n√£o tem id√©ia do que √©.  O servidor tamb√©m n√£o sabe se esta √© a chave correta. <br><br>  A solu√ß√£o OPAQUE √© baseada na velha id√©ia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gentry, Mackenzie e Ramzan</a> .  Quando um usu√°rio faz logon no servidor, ele gera uma chave p√∫blica e privada confi√°vel para o protocolo de contrato seguro (por exemplo, HMQV) e criptografa a chave privada recebida em K junto com a chave p√∫blica do servidor.  A cifra autenticada resultante (e chave p√∫blica) √© armazenada no banco de dados de senhas. <br><br>  <b><i>C = Criptografar (K, chave secreta do cliente | chave p√∫blica do servidor)</i></b> <br><br><img src="https://habrastorage.org/webt/9z/tb/uk/9ztbukhcywebjlgyrlbbaltk-0a.png"><br>  <i>Vers√£o completa do protocolo OPAQUE, trecho do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> .</i> <br><br>  Quando o cliente deseja autenticar usando o protocolo OPAQUE, o servidor envia o c√≥digo <b>C</b> armazenado.  Se o cliente digitou a senha correta na primeira fase, ele pode obter <b>K</b> e descriptografar essa cifra.  Caso contr√°rio, √© in√∫til.  Usando uma chave secreta com fio, ele agora pode executar um protocolo de contrato padr√£o com uma chave autenticada para concluir o aperto de m√£o.  (O servidor verifica a entrada dos clientes, comparando-os com sua c√≥pia da chave p√∫blica do cliente, e o cliente faz o mesmo.) <br><br>  <b>Agora vamos juntar tudo.</b>  Todas essas etapas podem ser combinadas em um protocolo, que possui o mesmo n√∫mero de etapas do SRP.  Se voc√™ n√£o prestar aten√ß√£o √†s etapas de verifica√ß√£o, ser√° semelhante ao protocolo acima.  Em princ√≠pio, a ideia √© apenas em duas mensagens: uma do cliente e a segunda √© enviada de volta ao servidor. <br><br>  O √∫ltimo aspecto do trabalho da OPAQUE √© que ele possui boas evid√™ncias de seguran√ßa que nos dizem que o protocolo resultante pode ser considerado seguro se tomarmos um ou mais logaritmos discretos em um modelo aleat√≥rio da Oracle, que √© uma suposi√ß√£o padr√£o, que aparentemente , ocorre nas configura√ß√µes com as quais trabalhamos. <br><br><h2>  Conclus√£o </h2><br>  Portanto, em resumo, temos uma tecnologia confi√°vel que pode facilitar o processo de uso de senhas e tamb√©m permite lidar com elas de forma mais eficiente - com muitos par√¢metros de hash e mais carga de trabalho no lado do cliente.  Por que isso n√£o √© usado em todos os lugares?  Talvez nos pr√≥ximos anos tudo mude.  O tempo dir√°. <br><br>  De acordo com a tradi√ß√£o estabelecida, aguardamos seus coment√°rios e convidamos voc√™ a visitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o dia de portas abertas</a> , que ser√° realizado no dia 27 de maio pela nossa professora, criptoanalista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elena Kirshanova</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453334/">https://habr.com/ru/post/pt453334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453324/index.html">Diodo como retificador</a></li>
<li><a href="../pt453326/index.html">Como automatizar o gerenciamento da infraestrutura de TI - discuta tr√™s tend√™ncias</a></li>
<li><a href="../pt453328/index.html">Dez anos em um site remoto</a></li>
<li><a href="../pt453330/index.html">O que fazer se a RAM travar. Anamnese e m√©todos de tratamento</a></li>
<li><a href="../pt453332/index.html">Sobre o m√©todo estranho de economizar espa√ßo no disco r√≠gido</a></li>
<li><a href="../pt453336/index.html">Guia de sele√ß√£o de m√°quina de grava√ß√£o CNC</a></li>
<li><a href="../pt453338/index.html">Vers√£o Rust 1.35.0: implementa√ß√µes de caracter√≠sticas funcionais e outras inova√ß√µes</a></li>
<li><a href="../pt453340/index.html">Lan√ßamento do Perl 5.30</a></li>
<li><a href="../pt453342/index.html">Mitos sobre funcion√°rios remotos que nos destru√≠mos</a></li>
<li><a href="../pt453346/index.html">Tecnologias de armazenamento e prote√ß√£o de dados - o terceiro dia no VMware EMPOWER 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>