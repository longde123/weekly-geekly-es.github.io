<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏾 👋🏼 🙇🏾 Faire de Tower Defense un jeu d'unité - Partie 1 👨🏿‍🔧 🐎 👩‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les jeux de tower defense gagnent en popularité, et cela n'est pas surprenant - peu de choses peuvent être comparées au plaisir d'observer vos propres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire de Tower Defense un jeu d'unité - Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="image"></div><br>  Les jeux de tower defense gagnent en popularité, et cela n'est pas surprenant - peu de choses peuvent être comparées au plaisir d'observer vos propres lignes de défense qui détruisent les ennemis maléfiques!  Dans ce tutoriel en deux parties, nous allons créer un jeu de tower defense sur le moteur <em>Unity</em> ! <br><br>  Vous apprendrez comment procéder comme suit: <br><br><ul><li>  Créez des vagues d'ennemis </li><li>  Faites-leur suivre les points de l'itinéraire </li><li>  Construisez et améliorez des tours et apprenez-leur également à briser les ennemis en petits pixels </li></ul><br>  En fin de compte, nous obtenons le cadre du jeu, qui peut être développé davantage! <br><a name="habracut"></a><br><blockquote>  <em>Remarque</em> : vous avez besoin des connaissances de base d'Unity (par exemple, vous devez savoir comment les actifs et les composants sont ajoutés, quels préfabriqués sont) et les bases de <em>C #</em> .  Pour tout savoir, je vous recommande de parcourir les tutoriels sur Unity de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sean Duffy</a> ou la série <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Beginning C # with Unity</a> de Brian Mockley. </blockquote><br>  Je travaillerai dans Unity pour OS X, mais ce tutoriel convient également pour Windows. <br><br><h2>  À travers les fenêtres de la tour d'ivoire </h2><br>  Dans ce tutoriel, nous allons créer un jeu de tower defense dans lequel les ennemis (petits bugs) rampent vers un cookie vous appartenant et vos serviteurs (bien sûr, ce sont des monstres!).  Le joueur peut placer des monstres à des points stratégiques et les améliorer en or. <br><br>  Le joueur doit tuer tous les bugs jusqu'à ce qu'ils arrivent au cookie.  Chaque nouvelle vague d'ennemis devient de plus en plus difficile à vaincre.  Le jeu se termine lorsque vous survivez à toutes les vagues (victoire!) Ou lorsque cinq ennemis rampent vers les cookies (perte!). <br><br>  Voici une capture d'écran du jeu terminé: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>Monstres, unissez-vous!</i>  <i>Protégez le cookie!</i> <br><br><h2>  Se rendre au travail </h2><br>  Téléchargez ce <a href="">projet vierge</a> , décompressez-le et ouvrez le projet <em>TowerDefense-Part1-Starter</em> dans Unity. <br><br>  Le projet de projet a des atouts graphiques et sonores, des animations toutes faites et plusieurs scripts utiles.  Les scripts ne sont pas directement liés aux jeux de tower defense, donc je n'en parlerai pas ici.  Cependant, si vous souhaitez en savoir plus sur la création d'animations 2D dans Unity, consultez ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Tutoriel Unity 2D">didacticiel Unity 2D</a> . <br><br>  Le projet contient également des préfabriqués, que nous ajouterons plus tard pour créer des personnages.  Enfin, il y a une scène dans le projet avec un arrière-plan et une interface utilisateur personnalisée. <br><br>  Ouvrez le <em>GameScene</em> situé dans le dossier <em>Scenes</em> et réglez le mode Game sur un rapport d'aspect de <em>4: 3</em> afin que toutes les étiquettes correspondent correctement à l'arrière-plan.  En mode Jeu, vous verrez ce qui suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>Paternité:</em> <br><br><ul><li>  Les graphismes du projet sont tirés du pack Wiki Wenderlich gratuit!  D'autres œuvres graphiques peuvent être trouvées sur son site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="gameartguppy">gameartguppy</a> . </li><li>  Super musique tirée de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Benound">BenSound</a> , qui a d'autres bandes sonores impressionnantes! </li><li>  Je remercie également Michael Jesper pour la fonction très utile de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="tremblement de l'appareil photo">bougé de l'appareil photo.</a> </li></ul>  . <br><h2>  L'endroit est marqué d'une croix: l'emplacement des monstres </h2><br>  Les monstres ne peuvent être placés que sur des points marqués d'un <em>x</em> . <br><br>  Pour les ajouter à la scène, faites glisser <em>Images \ Objects \ Openspot</em> de <em>Project Browser</em> vers la fenêtre <em>Scene</em> .  Alors que la position n'est pas importante pour nous. <br><br>  Une fois que vous avez sélectionné <em>Openspot</em> dans la hiérarchie, cliquez sur <em>Ajouter un composant</em> dans l' <em><em>inspecteur</em></em> et sélectionnez <em>Box Collider 2D</em> .  Dans la fenêtre Scène, Unity affichera un collisionneur rectangulaire avec une ligne verte.  Nous utiliserons ce collisionneur pour reconnaître les clics de souris à cet endroit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br>  Ajoutez le composant <em>Audio \ Source audio</em> à <em>Openspot de la</em> même manière.  Pour le paramètre <em>AudioClip</em> du composant Audio Source, sélectionnez le fichier <em>tower_place</em> situé dans le dossier <em>Audio</em> et désactivez <em>Play On Awake</em> . <br><br>  Nous devons créer 11 points supplémentaires.  Bien qu'il y ait une tentation de répéter toutes ces étapes, Unity a une meilleure solution: <em>Prefab</em> ! <br><br>  Faites glisser <em>Openspot</em> de la <em>hiérarchie</em> vers le dossier <em>Prefabs</em> dans l' <em>arborescence</em> du <em>projet</em> .  Son nom deviendra bleu dans la Hiérarchie, ce qui signifie qu'il est attaché au préfabriqué.  Quelque chose comme ça: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br>  Maintenant que nous avons le blanc préfabriqué, nous pouvons créer autant de copies que nous voulons.  <em>Faites</em> simplement glisser et déposez <em>Openspot</em> depuis le dossier <em>Prefabs</em> dans le <em>Navigateur du projet</em> dans la fenêtre <em>Scène</em> .  Répétez cette opération 11 fois et 12 objets Openspot apparaîtront dans la scène. <br><br>  Utilisez maintenant l' <em>inspecteur</em> pour définir ces 12 objets Openspot avec les coordonnées suivantes: <br><br><ul><li>  (X: -5,2, Y: 3,5, Z: 0) </li><li>  (X: -2,2, Y: 3,5, Z: 0) </li><li>  (X: 0,8, Y: 3,5, Z: 0) </li><li>  (X: 3,8, Y: 3,5, Z: 0) </li><li>  (X: -3,8, Y: 0,4, Z: 0) </li><li>  (X: -0,8, Y: 0,4, Z: 0) </li><li>  (X: 2,2, Y: 0,4, Z: 0) </li><li>  (X: 5,2, Y: 0,4, Z: 0) </li><li>  (X: -5,2, Y: -3,0, Z: 0) </li><li>  (X: -2,2, Y: -3,0, Z: 0) </li><li>  (X: 0,8, Y: -3,0, Z: 0) </li><li>  (X: 3,8, Y: -3,0, Z: 0) </li></ul><br>  Lorsque vous faites cela, la scène ressemblera à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2>  Nous plaçons des monstres </h2><br>  Pour simplifier le placement, il existe un préfabriqué <em>Monster</em> dans le dossier <em>Prefab</em> du projet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Prefab prêt à l'emploi</i> <br><br>  À l'heure actuelle, il se compose d'un objet de jeu vide avec trois sprites différents et des animations de tir en tant qu'enfants. <br><br>  Chaque sprite est un monstre avec différents niveaux de puissance.  Le préfabriqué contient également le composant <em>Source audio</em> , qui sera lancé pour jouer du son lorsqu'un monstre tire un laser. <br><br>  Nous allons maintenant créer un script qui <em>hébergera</em> <em>Monster</em> sur <em>Openspot</em> . <br><br>  Dans l' <em>arborescence du projet,</em> sélectionnez l'objet <em>Openspot</em> dans le dossier <em>Prefabs</em> .  Dans l' <em>inspecteur,</em> cliquez sur <em>Ajouter un composant</em> , puis sélectionnez <em>Nouveau script</em> et nommez le script <em>PlaceMonster</em> .  Sélectionnez <em>C Sharp</em> comme langue et cliquez sur <em>Créer et ajouter</em> .  Depuis que nous avons ajouté le script au préfabriqué <i>Openspot</i> , tous les objets Openspot de la scène auront désormais ce script.  Super! <br><br>  Double-cliquez sur le script pour l'ouvrir dans l'EDI.  Ajoutez ensuite deux variables: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br>  Nous allons créer une instance de l'objet stocké dans <code>monsterPrefab</code> pour créer le monstre, et le stocker dans <code>monster</code> afin qu'il puisse être manipulé pendant le jeu. <br><br><h3>  Un monstre par point </h3><br>  Pour qu'un seul monstre puisse être placé sur un point, ajoutez la méthode suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Dans <code>CanPlaceMonster()</code> nous pouvons vérifier si la variable <code>monster</code> est toujours <code>null</code> .  Si c'est le cas, alors il n'y a pas de monstre à ce point, et nous pouvons le placer. <br><br>  Ajoutez maintenant le code suivant pour placer le monstre lorsque le joueur clique sur ce GameObject: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Ce code localise le monstre lorsque vous cliquez sur la souris ou touchez l'écran.  Comment fonctionne-t-il? <br><br><ol><li>  Unity appelle automatiquement <code>OnMouseUp</code> lorsqu'un joueur touche le collisionneur physique GameObject. </li><li>  Lorsqu'elle est appelée, cette méthode place un monstre si <code>CanPlaceMonster()</code> renvoie <code>true</code> . </li><li>  Nous créons un monstre à l'aide de la méthode <code>Instantiate</code> , qui crée une instance du préfabriqué donné avec la position et la rotation spécifiées.  Dans ce cas, nous copions <code>monsterPrefab</code> , lui donnons la position actuelle de GameObject et aucune rotation, transférons le résultat vers <code>GameObject</code> et l'enregistrons dans <code>monster</code> </li><li>  À la fin, nous appelons <code>PlayOneShot</code> pour lire l'effet sonore attaché au composant <code>AudioSource</code> de l'objet. </li></ol><br>  Maintenant, notre script <code>PlaceMonster</code> peut avoir un nouveau monstre, mais nous devons toujours spécifier un préfabriqué. <br><br><h3>  Utiliser le bon préfabriqué </h3><br>  Enregistrez le fichier et revenez à Unity. <br><br>  Pour définir la variable <em>monsterPrefab</em> , sélectionnez d'abord l'objet <em>Openspot</em> dans le dossier <em>Prefabs</em> du navigateur du projet. <br><br>  Dans l' <em><em>inspecteur,</em></em> cliquez sur le cercle à droite du champ <em>Monster Prefab</em> du <em>composant PlaceMonster (Script)</em> et sélectionnez <em>Monster</em> dans la boîte de dialogue qui apparaît. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br>  C’est tout.  Lancez la scène et créez des monstres à différents endroits en cliquant sur la souris ou en touchant l'écran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br>  Super!  Maintenant, nous pouvons créer des monstres.  Cependant, ils ressemblent à un étrange gâchis, car tous les sprites enfants du monstre sont dessinés.  Maintenant, nous allons le réparer. <br><br><h2>  Augmentez le niveau des monstres </h2><br>  La figure ci-dessous montre qu'avec une augmentation de niveau, les monstres ont de plus en plus peur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>Quelle mignonne!</i>  <i>Mais si vous essayez de voler ses cookies, ce monstre se transformera en tueur.</i> <br><br>  Le script est utilisé comme base pour la mise en œuvre du système de niveaux de monstre.  Il suit la puissance du monstre à chaque niveau et, bien sûr, le niveau actuel du monstre. <br><br>  Ajoutez ce script. <br><br>  Sélectionnez le préfabriqué <em>Prefab / Monster</em> dans l' <em>arborescence du projet</em> .  Ajoutez un nouveau script <em>C #</em> appelé <em>MonsterData</em> .  Ouvrez le script dans l'EDI et ajoutez le code suivant <i>au</i> - <i>dessus de</i> la classe <code>MonsterData</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br>  Nous créons donc <code>MonsterLevel</code> .  Il regroupe le prix (en or, que nous soutiendrons ci-dessous) et une représentation visuelle du niveau du monstre. <br><br>  Nous ajoutons au-dessus de <code>[System.Serializable]</code> afin que les instances de classe puissent être modifiées dans l'inspecteur.  Cela nous permet de changer rapidement toutes les valeurs de la classe Level, même lorsque le jeu est en cours d'exécution.  C'est incroyablement utile pour équilibrer le jeu. <br><br><h3>  Définition des niveaux de monstre </h3><br>  Dans notre cas, nous stockons le <code>MonsterLevel</code> spécifié dans la <code>List&lt;T&gt;</code> . <br><br>  Pourquoi ne pas simplement utiliser <code>MonsterLevel[]</code> ?  Nous aurons besoin de l'index d'un objet <code>MonsterLevel</code> spécifique plusieurs fois.  Bien qu'il soit facile d'écrire du code pour cela, nous devons encore utiliser <code>IndexOf()</code> , qui implémente la fonctionnalité <code>Lists</code> .  Cela n'a aucun sens de réinventer la roue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>Réinventer le vélo est généralement une mauvaise idée.</i> <br><br>  En haut de <em>MonsterData.cs,</em> ajoutez ce qui suit à l' <code>using</code> construction: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Il nous donne accès à des structures de données généralisées afin que nous puissions utiliser la classe <code>List&lt;T&gt;</code> dans le script. <br><br><blockquote>  <em>Remarque</em> : les généralisations sont un puissant concept C #.  Ils vous permettent de spécifier des structures de données de type sécurisé sans avoir à adhérer au type.  Ceci est utile pour les classes de conteneurs telles que les listes et les ensembles.  Pour en savoir plus sur les structures génériques, lisez le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Introduction aux génériques C #">Introduction aux génériques C #</a> . </blockquote><br>  Ajoutez maintenant la variable suivante à <code>MonsterData</code> pour contenir la liste <code>MonsterLevel</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br>  Grâce aux généralisations, nous pouvons garantir que la <code>List</code> partir du <code>level</code> ne contiendra que des objets <code>MonsterLevel</code> . <br><br>  Enregistrez le fichier et passez à Unity pour configurer chaque niveau. <br><br>  Sélectionnez <em>Prefabs / Monster</em> dans le <em>navigateur de projet</em> .  L' <em><em>inspecteur</em></em> affiche désormais le champ <em>Niveaux</em> du <em>composant MonsterData (Script)</em> .  Définissez la <em>taille</em> sur <em>3</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br>  Ensuite, définissez le <em>coût</em> pour chaque niveau: <br><br><ul><li>  <em>Élément 0</em> : <em>200</em> </li><li>  <em>Élément 1</em> : <em>110</em> </li><li>  <em>Élément 2</em> : <em>120</em> </li></ul><br>  Maintenant, nous attribuons les valeurs des champs d'affichage visuel. <br><br>  Développez <em>Prefabs / Monster</em> dans le navigateur du projet pour voir ses enfants.  Faites glisser l'enfant <em>Monster0</em> dans le champ <em>Elément de</em> <em>visualisation</em> <em>0</em> . <br><br>  Ensuite, définissez l' <em>élément 1</em> sur <em>Monster1</em> et l' <em>élément 2</em> sur <em>Monster2</em> .  Le GIF montre ce processus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br>  Lorsque vous sélectionnez <em>Prefabs / Monster</em> , le préfabriqué devrait ressembler à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3>  Définir le niveau actuel </h3><br>  Revenez à <em>MonsterData.cs</em> dans l'EDI et ajoutez une autre variable à <code>MonsterData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br>  Dans la variable privée <code>currentLevel</code> nous stockons le niveau actuel du monstre. <br><br>  <code>currentLevel</code> maintenant <code>currentLevel</code> et rendez-le visible pour les autres scripts.  Ajoutez les lignes suivantes à <code>MonsterData</code> avec la déclaration des variables d'instance: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br>  Assez gros morceau de code C #, non?  Prenons-le dans l'ordre: <br><br><ol><li>  Définissez la <em>propriété de la</em> variable privée <code>currentLevel</code> .  En définissant la propriété, nous pouvons l'appeler comme n'importe quelle autre variable: soit comme <code>CurrentLevel</code> (à l'intérieur de la classe), soit comme <code>CurrentLevel</code> (à l'extérieur).  Nous pouvons définir n'importe quel comportement dans la méthode getter ou setter d'une propriété, et en créant uniquement un getter, un setter ou les deux, vous pouvez contrôler les propriétés de la propriété: lecture seule, écriture seule et écriture / lecture. </li><li>  Dans le getter, nous retournons la valeur de <code>currentLevel</code> . </li><li>  Dans le setter, nous attribuons à <code>currentLevel</code> nouvelle valeur.  Ensuite, nous obtenons l'indice du niveau actuel.  Enfin, nous parcourons tous les <em>niveaux</em> et activons / désactivons l'affichage visuel en fonction de <code>currentLevelIndex</code> .  C'est formidable car lorsque <code>currentLevel</code> change, le sprite se met à jour automatiquement.  Les propriétés sont une chose très pratique! </li></ol><br>  Ajoutez l'implémentation <code>OnEnable</code> suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  Ici, nous définissons <code>CurrentLevel</code> lors du placement.  Cela garantit que seul le sprite souhaité est affiché. <br><br><blockquote>  <em>Remarque</em> : il est important d'initialiser la propriété dans <code>OnEnable</code> , et non dans <code>OnStart</code> , car nous appelons les méthodes ordinales lors de la création d'instances préfabriquées. <br><br>  <code>OnEnable</code> sera appelé immédiatement lorsque le préfabriqué est créé (si le préfabriqué a été enregistré dans l'état activé), mais <code>OnStart</code> appelé que lorsque l'objet commence à s'exécuter dans le cadre de la scène. <br><br>  Nous devons vérifier ces données avant de placer le monstre, nous l'initialisons donc sur <code>OnEnable</code> . </blockquote><br>  Enregistrez le fichier et revenez à Unity.  Exécutez le projet et placez les monstres;  ils affichent maintenant les sprites corrects du niveau le plus bas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3>  Mise à niveau de monstre </h3><br>  Revenez à l'EDI et ajoutez la méthode suivante à <code>MonsterData</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  Dans <code>GetNextLevel</code> nous obtenons l'index <code>currentLevel</code> et l'index de niveau le plus élevé;  si le monstre n'a pas atteint le niveau maximum, le niveau suivant revient.  Sinon, <code>null</code> renvoyé. <br><br>  Vous pouvez utiliser cette méthode pour savoir si une mise à niveau de monstre est possible. <br><br>  Pour élever le niveau du monstre, ajoutez la méthode suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br>  Ici, nous obtenons l'index du niveau actuel, puis nous nous assurons que ce n'est pas le niveau maximum, en vérifiant qu'il est inférieur aux <code>levels.Count - 1</code> .  Si tel est le cas, <code>CurrentLevel</code> au niveau suivant. <br><br><h3>  Vérification de la fonctionnalité de mise à niveau </h3><br>  Enregistrez le fichier et revenez à <em>PlaceMonster.cs</em> dans l'IDE.  Ajoutez une nouvelle méthode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Nous vérifions d'abord s'il existe un monstre qui peut être amélioré en comparant la variable <code>monster</code> avec <code>null</code> .  Si cela est vrai, nous obtenons le niveau actuel du monstre à partir de ses <code>MonsterData</code> . <br><br>  Ensuite, nous vérifions si le niveau suivant est disponible, c'est-à-dire si <code>GetNextLevel()</code> ne retourne pas <code>null</code> .  Si une augmentation de niveau est possible, alors nous retournons <code>true</code> ;  sinon retournez <code>false</code> . <br><br><h3>  Nous mettons en œuvre des améliorations pour l'or </h3><br>  Pour activer l'option de mise à niveau, ajoutez la branche <code>else if</code> à <code>OnMouseUp</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br>  Nous vérifions la possibilité d'une mise à niveau en utilisant <code>CanUpgradeMonster()</code> .  Si possible, nous <code>MonsterData</code> composant <code>MonsterData</code> aide de <code>GetComponent()</code> et appelons <code>IncreaseLevel()</code> , ce qui augmente le niveau du monstre.  Enfin, nous lançons Monster <em>AudioSource</em> . <br><br>  Enregistrez le fichier et revenez à Unity.  Exécutez le jeu, placez et améliorez <i>n'importe quel nombre de</i> monstres (mais pour l'instant). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2>  Payer l'or - Game Manager </h2><br>  Bien que nous puissions immédiatement construire et améliorer des monstres, mais sera-t-il intéressant dans le jeu? <br><br>  Examinons la question de l'or.  Le problème avec le suivi est que nous devons transférer des informations entre différents objets de jeu. <br><br>  La figure ci-dessous montre tous les objets qui devraient y participer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>Tous les objets de jeu sélectionnés doivent savoir combien d'or un joueur possède.</i> <br><br>  Pour stocker ces données, nous utiliserons un objet commun auquel d'autres objets peuvent accéder. <br><br>  Cliquez avec le bouton droit sur la <em>hiérarchie</em> et sélectionnez <em>Créer vide</em> .  Nommez le nouvel objet <em>GameManager</em> . <br><br>  Ajoutez un nouveau script <em>C #</em> appelé <em>GameManagerBehavior à GameManager</em> , puis ouvrez-le dans l'EDI.  Nous afficherons la quantité totale d'or du joueur dans l'étiquette, donc en haut du fichier, ajoutez la ligne suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br>  Cela nous permettra d'accéder à des classes d'interface utilisateur comme <code>Text</code> , qui est utilisé pour les étiquettes.  Ajoutez maintenant la variable suivante à la classe: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br>  Il stockera un lien vers le composant <code>Text</code> utilisé pour afficher la quantité d'or d'un joueur. <br><br>  Maintenant que le <code>GameManager</code> connaît l'étiquette, comment synchroniser la quantité d'or stockée dans la variable et la valeur affichée sur l'étiquette?  Nous allons créer une propriété. <br><br>  Ajoutez le code suivant à <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br>  Semble-t-il familier?  Le code est similaire à <code>CurrentLevel</code> , que nous avons défini dans <code>Monster</code> .  Nous créons d'abord un <code>gold</code> variable privé pour contenir la quantité d'or actuelle.  Ensuite, nous définissons la propriété <code>Gold</code> (de manière inattendue, non?) Et implémentons le getter et le setter. <br><br>  Le getter renvoie simplement la valeur de l' <code>gold</code> .  Le passeur est plus intéressant.  En plus de définir la valeur de la variable, il définit également le champ de <code>text</code> pour <code>goldLabel</code> pour afficher la nouvelle valeur d'or. <br><br>  Sommes-nous généreux?  Ajoutez la ligne suivante à <code>Start()</code> pour donner au joueur <em>1000 pièces d'</em> or, ou moins si vous vous sentez désolé pour l'argent: <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3>  Affectation d'un objet d'étiquette à un script </h3><br>  Enregistrez le fichier et revenez à Unity.  Dans la <em>hiérarchie,</em> sélectionnez <em>GameManager</em> .  Dans l' <em><em>inspecteur,</em></em> cliquez sur le cercle à droite du <em>Gold Label</em> .  Dans la boîte de dialogue <em>Sélectionner le texte</em> , sélectionnez l'onglet <em>Scène</em> et sélectionnez <em>GoldLabel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br>  Exécutez la scène et l'étiquette affichera <em>Gold: 1000</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3>  Vérification du "portefeuille" du joueur </h3><br>  Ouvrez le script <em>PlaceMonster.cs</em> dans l'EDI et ajoutez la variable d'instance suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  Nous utiliserons <code>gameManager</code> pour accéder au composant <code>GameManagerBehavior</code> de l'objet <code>GameManagerBehavior</code> <em>dans la</em> scène.  Pour le spécifier, ajoutez ce qui suit à <code>Start()</code> : <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Nous obtenons un GameObject appelé GameManager à l'aide de la fonction <code>GameObject.Find()</code> , qui renvoie le premier objet de jeu trouvé avec ce nom.  Ensuite, nous obtenons son composant <code>GameManagerBehavior</code> et l'enregistrons pour l'avenir. <br><br><blockquote>  <em>Remarque</em> : vous pouvez le faire en définissant un champ dans l'éditeur Unity ou en ajoutant à <code>GameManager</code> une méthode statique qui renvoie une instance du singleton à partir de laquelle nous pouvons obtenir <code>GameManagerBehavior</code> . <br><br>  Cependant, dans le bloc de code ci-dessus, il y a un cheval noir: la méthode <code>Find</code> , qui fonctionne plus lentement pendant l'exécution de l'application;  mais il est pratique et peut être utilisé avec modération. </blockquote><br><h3>  Prends mon argent! </h3><br>  Nous n'avons pas encore soustrait d'or, nous allons donc ajouter cette ligne <em>deux fois</em> à <code>OnMouseUp()</code> , en remplaçant chacun des commentaires <code>// TODO:  </code> : <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br>  Enregistrez le fichier et revenez à Unity, mettez à niveau certains monstres et regardez la mise à jour de la valeur Gold.  Maintenant, nous déduisons de l'or, mais les joueurs peuvent construire des monstres tant qu'ils ont suffisamment d'espace;  ils empruntent juste de l'argent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>Crédit infini?</i>  <i>Super!</i>  <i>Mais nous ne pouvons pas le permettre.</i>  <i>Le joueur doit pouvoir parier des monstres tant qu'il a suffisamment d'or.</i> <br><br><h3>  Chèque d'or pour les monstres </h3><br>  Basculez l'IDE vers <em>PlaceMonster.cs</em> et remplacez le contenu de <code>CanPlaceMonster()</code> suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br>  Nous <code>MonsterData</code> prix de placement des monstres à partir des <code>levels</code> dans ses <code>MonsterData</code> .  Ensuite, nous vérifions que le <code>monster</code> pas <code>null</code> et que <code>gameManager.Gold</code> supérieur à ce prix. <br><br>  La tâche pour vous: ajouter indépendamment à <code>CanUpgradeMonster()</code> vérification si le joueur a suffisamment d'or. <br><br><div class="spoiler">  <b class="spoiler_title">Solution à l'intérieur</b> <div class="spoiler_text">  Remplacez la ligne: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  à ce sujet: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br>  Il vérifiera si le joueur a plus d' <em>or</em> que le prix de mise à niveau. </div></div><br>  Enregistrez et exécutez la scène dans Unity.  Essayez maintenant de savoir comment ajouter des monstres à volonté! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>Maintenant, nous ne pouvons construire qu'un nombre limité de monstres.</i> <br><br><h2>  Politique de la tour: ennemis, vagues et waypoints </h2><br>  Il est temps de «préparer le terrain» à nos ennemis.  Les ennemis apparaissent au premier point de l'itinéraire, passent au suivant et répètent le processus jusqu'à ce qu'ils atteignent le cookie. <br><br>  Vous pouvez faire bouger les ennemis comme ceci: <br><br><ol><li>  Définissez la route que les ennemis suivront </li><li>  Déplacez l'ennemi le long de la route </li><li>  Tournez l'ennemi pour qu'il regarde vers l'avant </li></ol><br><h3>  Création d'une route à partir de waypoints </h3><br>  Cliquez avec le bouton droit sur la <em>hiérarchie</em> et sélectionnez <em>Créer vide</em> pour créer un nouvel objet de jeu vide.  Nommez-le <em>Road</em> et placez-le à <em>(0, 0, 0)</em> . <br><br>  Maintenant, faites un clic droit sur <em>Road</em> dans la <em>hiérarchie</em> et créez un autre objet de jeu vide en tant qu'enfant de Road.  Nommez-le <em>Waypoint0</em> et placez-le au point <em>(-12, 2, 0)</em> - à partir de là, les ennemis commenceront leur mouvement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br>  De même, créez cinq autres points d'itinéraire avec les noms et positions suivants: <br><br><ul><li>  Waypoint1: (X: 7, Y: 2, Z: 0) </li><li>  Waypoint2: (X: 7, Y: -1, Z: 0) </li><li>  Waypoint3: (X: -7,3, Y: -1, Z: 0) </li><li>  Waypoint4: (X: -7,3, Y: -4,5, Z: 0) </li><li>  Point de cheminement5: (X: 7, Y: -4,5, Z: 0) </li></ul><br>  La capture d'écran ci-dessous montre les points de l'itinéraire et le chemin résultant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2>  Se faire des ennemis </h2><br>  Créez maintenant des ennemis pour qu'ils puissent se déplacer le long de la route.  Il y a un préfabriqué <em>ennemi</em> dans le dossier <em>Prefabs</em> .  Sa position est <em>(-20, 0, 0)</em> , donc de nouvelles instances seront créées hors écran. <br><br>  À tous les autres égards, il est configuré presque de la même manière que le préfabriqué Monster, a <code>AudioSource</code> et une filiale <code>Sprite</code> , et nous pouvons faire pivoter ce sprite à l'avenir sans tourner la barre de santé. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3>  Nous déplaçons des ennemis le long de la route </h3><br>  Ajoutez un nouveau script <em>C #</em> appelé <em>MoveEnemy</em> au <em>préfabriqué Prefabs \ Enemy</em> .  Ouvrez le script dans l'EDI et ajoutez les variables suivantes: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br>  Dans les <code>waypoints</code> , une copie des <code>waypoints</code> est stockée dans le tableau, et la ligne <code>[HideIn <em>inspector</em> ]</code> au-dessus des <code>waypoints</code> garantit que nous ne pouvons pas modifier accidentellement ce champ dans l' <em><em>inspecteur</em></em> , mais y aurons toujours accès à partir d'autres scripts. <br><br>  <code>currentWaypoint</code> conserve la trace de la route de l'ennemi à l'heure actuelle et <code>lastWaypointSwitchTime</code> stocke l'heure à laquelle l'ennemi l'a traversé.  De plus, nous stockons la <code>speed</code> ennemi. <br><br>  Ajoutez cette ligne à <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br>  Nous initialisons donc <code>lastWaypointSwitchTime</code> avec la valeur de l'heure actuelle. <br><br>  Pour que l'ennemi se déplace le long de l'itinéraire, ajoutez le code suivant à <code>Update()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Analysons le code étape par étape: <br><br><ol><li>  À partir du tableau de points d'itinéraire, nous obtenons les positions de début et de fin du segment d'itinéraire actuel. </li><li>  Nous calculons le temps nécessaire pour parcourir toute la distance en utilisant la formule <em>temps = distance / vitesse</em> , puis déterminons l'heure actuelle sur l'itinéraire.  En utilisant <code>Vector2.Lerp</code> , nous interpolons la position actuelle de l'ennemi entre le segment exact de début et de fin. </li><li>  Vérifiez si l'ennemi a atteint <code>endPosition</code> .  Si oui, alors nous traitons deux scénarios possibles: <br><ol><li>  L'ennemi n'a pas encore atteint le dernier point de l'itinéraire, alors augmentez la valeur de <code>currentWaypoint</code> et mettez à jour <code>lastWaypointSwitchTime</code> .  Plus tard, nous ajouterons un code pour retourner l'ennemi afin qu'il regarde dans la direction de son mouvement. </li><li>  L'ennemi a atteint le dernier point de la route, puis nous le détruisons et commençons l'effet sonore.  Plus tard, nous ajouterons un code qui réduit la <code>health</code> du joueur. </li></ol></li></ol><br>  Enregistrez le fichier et revenez à Unity. <br><br><h3>  Nous informons les ennemis de la direction du mouvement </h3><br>  Dans leur état actuel, les ennemis ne connaissent pas l'ordre des points de route. <br><br>  Sélectionnez <em>Road</em> dans la <em>hiérarchie</em> et ajoutez un nouveau script <em>C #</em> appelé <em>SpawnEnemy</em> .  Ouvrez-le dans l'EDI et ajoutez la variable suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br>  Nous utiliserons des <code>waypoints</code> pour stocker les références au waypoint dans la scène dans l'ordre souhaité. <br><br>  Enregistrez le fichier et revenez à Unity.  Sélectionnez <em>Route</em> dans la <em>hiérarchie</em> et définissez la <em>taille du</em> tableau de <em>waypoints</em> sur <em>6</em> . <br><br>  Faites glisser chacun des enfants Road dans les champs en collant <em>Waypoint0</em> dans l' <em>élément 0</em> , <em>Waypoint1</em> dans l' <em>élément 1,</em> etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br>  Nous avons maintenant un tableau contenant les points de route dans le bon ordre - attention, les ennemis ne reculent jamais, ils s'efforcent constamment d'obtenir une douce récompense. <br><br><h3>  Vérifiez comment tout cela fonctionne </h3><br>  Ouvrez <em>SpawnEnemy</em> dans l'EDI et ajoutez la variable suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br>  Il stockera une référence au <code>testEnemyPrefab</code> <em>Enemy</em> dans <code>testEnemyPrefab</code> . <br><br>  Pour créer un ennemi lors de l'exécution du script, ajoutez le code suivant à <code>Start()</code> : <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br>  Nous allons donc créer une nouvelle copie du préfabriqué stocké dans <code>testEnemy</code> et lui affecter un itinéraire. <br><br>  Enregistrez le fichier et revenez à Unity.  Sélectionnez l'objet <em>Route</em> dans la <em>hiérarchie</em> et sélectionnez le préfabriqué <em>ennemi</em> pour le paramètre <em>Test Enemy</em> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancez le projet et voyez comment l'ennemi se déplace le long de la route (en GIF, pour plus de clarté, la vitesse est augmentée de 20 fois). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous avez remarqué qu'il ne regarde pas toujours où il va? </font><font style="vertical-align: inherit;">C'est drôle, mais nous essayons de créer un jeu professionnel. </font><font style="vertical-align: inherit;">Par conséquent, dans la deuxième partie du didacticiel, nous apprendrons aux ennemis à regarder en avant.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Où aller ensuite? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons déjà beaucoup fait et nous nous dirigeons rapidement vers la création de notre propre jeu de tower defense. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les joueurs peuvent créer un nombre limité de monstres, et l'ennemi court le long de la route, se dirigeant vers notre cookie. </font><font style="vertical-align: inherit;">Les joueurs ont de l'or et ils peuvent améliorer les monstres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez le résultat final </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxième partie,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous considérerons la création d'énormes vagues d'ennemis et leur destruction. </font><font style="vertical-align: inherit;">A très bientôt!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413837/">https://habr.com/ru/post/fr413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413817/index.html">Traitement concurrentiel hétérogène et en temps réel des données strictement une fois</a></li>
<li><a href="../fr413819/index.html">Honnêtement sur le marché informatique en Russie</a></li>
<li><a href="../fr413823/index.html">Le boom de l'emploi insignifiant</a></li>
<li><a href="../fr413827/index.html">Le projet Kubernetes fête ses 4 ans</a></li>
<li><a href="../fr413831/index.html">La nouvelle version de Tesla Autopilot sortira en août, pour la première fois avec des «fonctions de conduite entièrement autonomes»</a></li>
<li><a href="../fr413839/index.html">AI, cours pratique. Collection et recherche d'images</a></li>
<li><a href="../fr413841/index.html">Alternatives aux produits Google</a></li>
<li><a href="../fr413843/index.html">Waymo devance les autres: les robots de la société ont parcouru 11 millions de kilomètres</a></li>
<li><a href="../fr413847/index.html">Monument déclencheur "vivant"</a></li>
<li><a href="../fr413849/index.html">Histoire de la marque Sennheiser: liberté et vision</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>