<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💬 👐 😭 Buat shader air kartun untuk web. Bagian 2 🕌 ✊🏿 🙀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama, kami melihat pengaturan lingkungan dan permukaan air. Pada bagian ini, kita akan memberikan daya apung objek, menambahkan garis a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat shader air kartun untuk web. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama,</a> kami melihat pengaturan lingkungan dan permukaan air.  Pada bagian ini, kita akan memberikan daya apung objek, menambahkan garis air pada permukaan dan membuat garis busa dengan penyangga kedalaman di sekitar batas objek yang bersinggungan dengan permukaan. <br><br>  Untuk membuat adegan terlihat sedikit lebih baik, saya membuat sedikit perubahan padanya.  Anda dapat menyesuaikan adegan dengan cara yang Anda inginkan, tetapi saya melakukan yang berikut: <br><br><ul><li>  Menambahkan model mercusuar dan gurita. </li><li> Menambahkan model dasar dengan warna <code>#FFA457</code> . </li><li>  Menambahkan warna langit <code>#6CC8FF</code> . </li><li>  Menambahkan warna latar <code>#FFC480</code> ke adegan (parameter ini dapat ditemukan di pengaturan adegan). </li></ul><br>  Adegan asli saya sekarang terlihat seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Daya apung </h2><br>  Cara termudah untuk menciptakan daya apung adalah dengan menggunakan skrip untuk mendorong objek ke atas dan ke bawah.  Buat skrip <strong>Buoyancy.js</strong> baru dan tetapkan yang berikut ini di inisialisasi: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Sekarang dalam pembaruan, kami menjalankan penambahan waktu dan memutar objek: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  Terapkan skrip ini ke perahu dan lihat bagaimana lompatannya ke atas dan ke bawah air!  Anda dapat menerapkan skrip ini ke beberapa objek (termasuk kamera - coba)! <br><br><h2>  Tekstur permukaan </h2><br>  Sementara kita bisa melihat ombaknya, kita melihat ujung-ujung permukaan air.  Menambahkan tekstur akan membuat gerakan permukaan lebih terlihat.  Selain itu, ini adalah cara berbiaya rendah untuk mensimulasikan pantulan dan kaustik. <br><br>  Anda dapat mencoba menemukan beberapa tekstur kaustik atau membuatnya sendiri.  Saya menggambar <a href="" rel="external">tekstur</a> di Gimp yang bisa Anda gunakan dengan bebas.  Tekstur apa pun cocok, asalkan itu bisa ubin tanpa sendi yang terlihat. <br><br>  Setelah memilih tekstur yang Anda suka, seret ke jendela Aset proyek Anda.  Kita perlu mereferensikan tekstur ini dari skrip Water.js, jadi mari kita buat atribut untuk itu: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  Dan kemudian menempatkannya di editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Sekarang kita harus meneruskannya ke shader.  Pergilah ke <strong>Water.js</strong> dan atur fungsi <code>CreateWaterMaterial</code> parameter baru: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Sekarang kembali ke <strong>Water.frag</strong> dan nyatakan seragam baru: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  Kami hampir selesai.  Untuk membuat tekstur pada bidang, kita perlu tahu di mana setiap piksel berada di jala.  Artinya, kita perlu mentransfer data dari vertex shader ke fragmen. <br><br><h3>  Variabel yang Bervariasi </h3><br>  Variabel yang <em>bervariasi</em> memungkinkan Anda untuk mentransfer data dari vertex shader ke yang fragmen.  Ini adalah tipe ketiga dari variabel khusus yang dapat digunakan dalam shader (dua yang pertama adalah <em>seragam</em> dan <em>atribut</em> ).  Variabel diatur untuk setiap simpul dan setiap piksel dapat mengaksesnya.  Karena terdapat lebih banyak piksel daripada titik, nilainya diinterpolasi di antara titik (karena itu nama "bervariasi" - itu menyimpang dari nilai yang diteruskan ke sana). <br><br>  Untuk mengujinya dalam operasi, deklarasikan variabel baru di <strong>Water.vert</strong> sebagai beragam: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  Dan kemudian berikan nilai <code>gl_Position</code> setelah menghitungnya: <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  Sekarang kembali ke <strong>Water.frag</strong> dan deklarasikan variabel yang sama.  Kami tidak bisa mendapatkan output data debug dari shader, tetapi kami bisa menggunakan warna untuk debugging visual.  Inilah cara melakukannya: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Pesawat sekarang akan terlihat hitam dan putih, dan garis pemisah warna akan pergi ke tempat <code>ScreenPosition.x</code> = 0. Nilai warna hanya berubah dari 0 ke 1, tetapi nilai-nilai di <code>ScreenPosition</code> mungkin berada di luar kisaran ini.  Mereka secara otomatis terbatas, oleh karena itu, ketika Anda melihat hitam, itu bisa 0 atau angka negatif. <br><br>  Apa yang baru saja kita lakukan adalah untuk melewatkan posisi layar dari setiap simpul ke setiap piksel.  Anda dapat melihat bahwa garis yang memisahkan sisi hitam dan putih akan selalu lewat di tengah layar, terlepas dari di mana permukaan sebenarnya di dunia. <br><br><blockquote>  <em>Tugas 1: buat variabel baru yang bervariasi untuk mentransfer posisi di dunia alih-alih posisi layar.</em>  <em>Visualisasikan dengan cara yang sama.</em>  <em>Jika warnanya tidak berubah dengan pergerakan kamera, maka semuanya dilakukan dengan benar.</em> </blockquote><br><h3>  Menggunakan UV </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">UV</a> adalah koordinat 2D dari setiap simpul dalam mesh, dinormalisasi dari 0 hingga 1. Mereka diperlukan untuk pengambilan sampel yang benar dari tekstur ke pesawat, dan kami sudah mengkonfigurasi mereka di bagian sebelumnya. <br><br>  <strong>Kami akan</strong> mendeklarasikan atribut baru di <strong>Water.vert</strong> (nama ini diambil dari definisi shader di Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  Dan sekarang kita hanya perlu meneruskannya ke fragmen shader, jadi buat saja yang berbeda-beda dan tetapkan nilai atributnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Sekarang kita akan mendeklarasikan variabel berbeda yang sama di shader fragmen.  Untuk memastikan semuanya bekerja, kita dapat memvisualisasikan debugging seperti sebelumnya, dan kemudian Water.frag akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Anda akan melihat gradien yang mengonfirmasi bahwa kami memiliki nilai 0 dari satu ujung dan 1 dari yang lain.  Sekarang untuk mencicipi tekstur nyata, yang perlu kita lakukan adalah: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  Setelah itu, kita akan melihat tekstur di permukaan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Penataan tekstur </h3><br>  Alih-alih hanya mengatur tekstur sebagai warna baru, mari kita gabungkan dengan warna biru yang ada: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  Ini berfungsi karena warna teksturnya hitam (0) di mana-mana kecuali garis air.  Menambahkannya, kita tidak mengubah warna biru awal, dengan pengecualian tempat dengan garis-garis di mana ia menjadi lebih terang. <br><br>  Namun, ini bukan satu-satunya cara untuk menggabungkan warna. <br><br><blockquote>  <em>Tugas 2: Bisakah Anda menggabungkan warna untuk mendapatkan efek yang lebih lemah seperti yang ditunjukkan di bawah ini?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Tekstur bergerak </h3><br>  Sebagai efek terakhir, kami ingin garis-garis bergerak di sepanjang permukaan dan itu tidak terlihat begitu statis.  Untuk melakukan ini, kita akan mengambil keuntungan dari fakta bahwa nilai apa pun di luar interval dari 0 hingga 1, diteruskan ke fungsi <code>texture2D</code> , akan ditransfer (misalnya, 1,5 dan 2,5 menjadi sama dengan 0,5).  Oleh karena itu, kita dapat meningkatkan posisi kita dengan variabel waktu seragam yang telah kita atur untuk menambah atau mengurangi kerapatan garis pada permukaan, yang akan memberikan fragmen akhir berupa bentuk ini: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  Garis Busa dan Buffer Kedalaman </h2><br>  Rendering garis busa di sekitar benda-benda di air membuatnya lebih mudah untuk melihat seberapa terbenam benda-benda itu dan di mana mereka melintasi permukaan.  Selain itu, dengan cara ini air kita menjadi jauh lebih dapat dipercaya.  Untuk mewujudkan garis-garis busa, kita perlu mencari tahu di mana batas-batas masing-masing objek, dan melakukannya secara efektif. <br><br><h3>  Trick </h3><br>  Kita perlu belajar untuk menentukan apakah suatu piksel pada permukaan air dekat dengan objek.  Jika demikian, maka kita bisa mengecatnya dengan warna busa.  Tidak ada cara sederhana untuk menyelesaikan masalah ini (sejauh yang saya tahu).  Oleh karena itu, untuk menyelesaikannya, saya menggunakan teknik yang berguna untuk memecahkan masalah: Saya akan mengambil contoh yang kita tahu jawabannya dan melihat apakah kita dapat menggeneralisasikannya. <br><br>  Lihatlah gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  Pixel apa yang harus menjadi bagian dari busa?  Kita tahu itu akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  Jadi mari kita lihat dua piksel spesifik.  Di bawah ini saya menandainya dengan tanda bintang.  Hitam akan berada di busa, dan merah tidak akan.  Bagaimana kita membedakan mereka dalam shader? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  Kita tahu bahwa meskipun kedua piksel dalam ruang layar ini berdekatan satu sama lain (keduanya berada di atas mercusuar), sebenarnya keduanya sangat jauh di ruang dunia.  Kami dapat memverifikasi ini dengan melihat pemandangan yang sama dari sudut yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Perhatikan bahwa bintang merah tidak terletak di mercusuar, seperti yang terlihat bagi kita, tetapi bintang hitam sebenarnya ada di sana.  Kita dapat membedakan dari menggunakan jarak ke kamera, yang biasanya disebut "kedalaman".  Kedalaman 1 berarti titik tersebut sangat dekat dengan kamera, kedalaman 0 berarti sangat jauh.  Tapi ini bukan hanya masalah jarak absolut di dunia, kedalaman atau kamera.  Kedalaman <em>relatif terhadap piksel di belakangnya adalah</em> penting. <br><br>  Lihat lagi pada tampilan pertama.  Katakanlah mercusuar memiliki nilai kedalaman 0,5.  Kedalaman bintang hitam akan sangat dekat dengan 0,5.  Artinya, dan piksel di bawahnya memiliki nilai kedalaman yang sangat dekat.  Di sisi lain, tanda bintang merah akan memiliki kedalaman yang jauh lebih besar, karena lebih dekat ke kamera, katakanlah 0,7.  Dan meskipun piksel di belakangnya masih di mercusuar, ia memiliki nilai kedalaman 0,5, yaitu, ada lebih banyak perbedaan. <br><br>  Ini triknya.  <em>Ketika kedalaman piksel pada permukaan air cukup dekat dengan kedalaman piksel tempat gambar itu diambil, maka kita cukup dekat dengan batas beberapa objek</em> dan dapat membuat piksel seperti busa. <br><br>  Artinya, kami membutuhkan informasi lebih banyak daripada yang kami miliki di piksel mana pun.  Entah bagaimana, kita perlu mencari tahu kedalaman piksel tempat gambar itu harus ditarik.  Dan di sini buffer kedalaman berguna bagi kita. <br><br><h3>  Penyangga Kedalaman </h3><br>  Anda dapat menganggap penyangga bingkai atau penyangga bingkai sebagai render atau tekstur target di luar layar.  Ketika kita perlu membaca data, kita perlu membuat di luar layar.  Teknik ini digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">efek asap</a> . <br><br>  Buffer kedalaman adalah render target khusus yang berisi informasi tentang nilai kedalaman setiap piksel.  Jangan lupa bahwa nilai dalam <code>gl_Position</code> dihitung dalam vertex shader adalah nilai ruang layar, tetapi juga memiliki koordinat ketiga - nilai Z. Nilai Z ini digunakan untuk menghitung kedalaman, yang ditulis ke buffer kedalaman. <br><br>  Buffer kedalaman dimaksudkan untuk rendering adegan yang benar tanpa perlu menyortir objek dari belakang ke depan.  Setiap piksel yang akan ditarik terlebih dahulu memeriksa buffer kedalaman.  Jika nilai kedalamannya lebih besar dari nilai dalam buffer, maka itu ditarik, dan nilainya sendiri menimpa nilai buffer.  Kalau tidak, itu dibuang (karena itu berarti ada objek lain di depannya). <br><br>  Bahkan, Anda dapat menonaktifkan penulisan ke buffer kedalaman untuk melihat bagaimana segala sesuatu akan terlihat tanpa itu.  Mari kita coba melakukannya di Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Anda akan melihat bahwa air sekarang akan selalu diambil dari atas, bahkan jika itu di belakang benda buram. <br><br><h3>  Visualisasi Penyangga Kedalaman </h3><br>  Mari kita tambahkan cara untuk membuat buffer kedalaman untuk keperluan debugging.  Buat skrip <strong>DepthVisualize.js</strong> baru.  Pasang ke kamera. <br><br>  Untuk mengakses buffer kedalaman di PlayCanvas, cukup tulis yang berikut ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  Jadi kami secara otomatis menyuntikkan variabel seragam ke semua shader kami, yang dapat kami gunakan dengan mendeklarasikannya sebagai berikut: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  Di bawah ini adalah contoh skrip yang meminta peta mendalam dan merendernya di atas layar.  Dia telah mengkonfigurasi restart panas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Cobalah untuk menyalin kode dan komentar keluar / batalkan komentar pada baris <code>this.app.scene.drawCalls.push(this.command);</code>  untuk mengaktifkan / menonaktifkan rendering mendalam.  Seharusnya terlihat seperti gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>Tugas 3: permukaan air tidak ditarik ke dalam buffer kedalaman.</em>  <em>Mesin PlayCanvas sengaja melakukan ini.</em>  <em>Bisakah Anda mencari tahu mengapa?</em>  <em>Apa yang spesial dari material air?</em>  <em>Dengan kata lain, mengingat aturan kami untuk memeriksa kedalaman, apa yang akan terjadi jika piksel air ditulis ke buffer kedalaman?</em> </blockquote><br>  <em>Petunjuk: Anda dapat mengubah satu baris di Water.js, yang memungkinkan Anda untuk menulis air ke buffer kedalaman.</em> <br><br>  Perlu juga dicatat bahwa dalam fungsi inisialisasi, saya mengalikan nilai kedalaman dengan 30. Ini perlu untuk melihatnya dengan jelas, karena jika tidak, rentang nilai akan terlalu kecil untuk menampilkan nada warna. <br><br><h3>  Penerapan Trick </h3><br>  Ada beberapa fungsi tambahan di mesin PlayCanvas untuk bekerja dengan nilai kedalaman, tetapi pada saat penulisan, mereka tidak dirilis dalam produksi, jadi kita harus mengonfigurasinya sendiri. <br><br>  Kami <strong>mendefinisikan</strong> variabel seragam berikut di <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  Kami mendefinisikan fungsi bantu ini di atas fungsi utama: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Kami akan memberikan informasi shader tentang kamera di <strong>Water.js</strong> .  Rekatkan ini ke tempat Anda meneruskan variabel seragam lainnya seperti uTime: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Akhirnya, kita membutuhkan posisi di dunia setiap piksel untuk shader fragmen kita.  Kita harus mendapatkannya dari vertex shader.  Oleh karena itu, kita akan mendefinisikan variabel yang bervariasi di <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  Tentukan variabel bervariasi yang sama di <strong>Water.vert</strong> .  Kemudian kami menempatkannya pada posisi terdistorsi dari vertex shader sehingga kode lengkapnya terlihat seperti ini: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  Kami menyadari triknya dengan nyata </h3><br>  Sekarang kita akhirnya siap untuk mengimplementasikan teknik yang dijelaskan di awal bagian ini.  Kami ingin membandingkan kedalaman piksel di mana kami berada dengan kedalaman piksel di bawahnya.  Pixel tempat kita berada diambil dari posisi di dunia, dan piksel di bawahnya diperoleh dari posisi layar.  Karena itu, kami mengambil dua kedalaman ini: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>Tugas 4: salah satu dari nilai-nilai ini tidak akan pernah lebih besar dari yang lain (dengan asumsi depthTest = true).</em>  <em>Bisakah Anda menentukan yang mana?</em> </blockquote><br>  Kita tahu bahwa busa akan berada di tempat jarak antara kedua nilai tersebut kecil.  Karenanya, mari kita render perbedaan ini untuk setiap piksel.  Tempel ini di akhir shader (dan matikan skrip visualisasi kedalaman dari bagian sebelumnya): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  Dan seharusnya terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  Artinya, kita dengan benar memilih batas-batas benda apa pun yang direndam dalam air secara real time!  Tentu saja, Anda dapat mengukur perbedaannya untuk membuat busa lebih tebal atau kurang umum. <br><br>  Kami sekarang memiliki banyak pilihan untuk menggabungkan hasil ini dengan permukaan air untuk membuat garis busa yang indah.  Anda dapat meninggalkan mereka dengan gradien, gunakan untuk sampel dari tekstur yang berbeda, atau menetapkan warna tertentu jika perbedaannya kurang dari atau sama dengan nilai batas tertentu. <br><br>  Yang paling saya sukai adalah penugasan warna yang mirip dengan garis-garis air statis, jadi fungsi utama saya yang sudah selesai terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Untuk meringkas </h2><br>  Kami menciptakan daya apung benda yang terbenam dalam air, menerapkan tekstur bergerak ke permukaan untuk mensimulasikan kaustik, dan mempelajari cara menggunakan buffer kedalaman untuk membuat garis-garis buih yang dinamis. <br><br>  Pada bagian ketiga dan terakhir, kami akan menambahkan efek post-processing dan belajar bagaimana menggunakannya untuk menciptakan efek distorsi bawah air. <br><br><h2>  Kode sumber </h2><br>  Proyek PlayCanvas yang sudah selesai dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> .  Repositori kami juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">port proyek di bawah Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416983/">https://habr.com/ru/post/id416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416961/index.html">Resolusi konflik otomatis menggunakan transformasi operasional</a></li>
<li><a href="../id416967/index.html">Seperti yang kami lakukan BelAZ. Bagian 3 - commissioning bagian</a></li>
<li><a href="../id416969/index.html">Pembenaran matematis Pythagoras dari skala musik</a></li>
<li><a href="../id416977/index.html">Perangkat Lunak Rumah Pintar # 2</a></li>
<li><a href="../id416979/index.html">Scrum to tim besar: LeSS Day 2018</a></li>
<li><a href="../id416985/index.html">Ke seperseratus terdekat: Top 10 SmartData 2017 laporan</a></li>
<li><a href="../id416987/index.html">Gartner: hal utama di pasar IaaS pada 2018</a></li>
<li><a href="../id416989/index.html">Untuk robot bionik: laba-laba dan gurita di pabrik masa depan?</a></li>
<li><a href="../id416991/index.html">Merekam video dari layar Anda tidak terlalu rahasia. King Burger Version dan Appsee</a></li>
<li><a href="../id416993/index.html">Temui Sofia: robot yang hampir tidak bisa dibedakan dari manusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>