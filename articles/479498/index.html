<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçä üëå üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© C√≥mo el tiempo lineal se convierte en Windows en O (n¬≤) ‚úçÔ∏è üëè üêøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente me encontr√© con retrasos de varios minutos en mi estaci√≥n de trabajo. Despu√©s de la investigaci√≥n, result√≥ que la causa del problema era...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo el tiempo lineal se convierte en Windows en O (n¬≤)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479498/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png" alt="imagen"></div><br>  Recientemente me encontr√© con retrasos de varios minutos en mi estaci√≥n de trabajo.  Despu√©s de la investigaci√≥n, result√≥ que la causa del problema era un bloqueo, que pod√≠a durar cinco minutos, durante los cuales la fuente del bloqueo b√°sicamente giraba en un ciclo de nueve instrucciones. <br><br>  Es muy importante para m√≠ seleccionar buenos encabezados para mis publicaciones, pero inmediatamente record√© que el nombre apropiado "48 n√∫cleos est√°n bloqueados por nueve instrucciones" <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">ya</a> fue <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">tomado</a> [ <a href="https://habr.com/ru/post/472552/">traducci√≥n</a> en Habr√©] por una publicaci√≥n escrita hace menos de un mes.  La cantidad de procesadores bloqueados es diferente, y el ciclo es un poco m√°s largo, pero de hecho, todo esto te hace experimentar un deja vu.  Por lo tanto, mientras explico el nuevo problema encontrado, quer√≠a reflexionar sobre <em>por qu√© sucede esto todo el tiempo</em> . <br><br><h2>  ¬øPor qu√© est√° pasando esto? </h2><br>  Hablando en t√©rminos generales, tales problemas surgen como resultado de una observaci√≥n que llamar√© <em>la Primera Ley de Computaci√≥n de Dawson:</em> <a href="https://twitter.com/BruceDawson0xB/status/1120381406700429312" rel="nofollow">O (n <sup>2</sup> ) es un im√°n para algoritmos que no escalan bien</a> : son lo suficientemente r√°pidos como para entrar en producci√≥n, pero lo suficientemente lentos como para estropear todo, cuando lleguen <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/017/fb8/bea017fb89b90af6566d8ad77298efb9.png"></div><br>  <i>O (n <sup>2</sup> ) en acci√≥n: datos tomados de mi caso</i> <br><a name="habracut"></a><br>  Que esta pasando  El desarrollador escribe el c√≥digo y usa el algoritmo O (n <sup>2</sup> ).  Quiz√°s no se da cuenta de esto, o el algoritmo se convierte en O (n <sup>2</sup> ) <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">debido a un error</a> , o el desarrollador sabe que √©l es O (n <sup>2</sup> ), pero cree que nunca ser√° importante.  En condiciones de laboratorio, la velocidad del c√≥digo es aceptable, y es aceptable para la mayor√≠a de los usuarios en el mundo real, pero luego alguien crea <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">7,000 procesos</a> con App Verifier activado o crea un <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">archivo binario con 180,000 elementos CFG</a> , o recopila una DLL tan grande que es <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">constantemente se escanea una lista enlazada</a> , que toma todo el procesador.  Al trabajar en el tiempo de inicio del motor Valve Source 2, encontr√© <em>muchos</em> algoritmos O (n <sup>2</sup> ), cada uno de los cuales agreg√≥ aproximadamente 30 segundos al tiempo de inicio del motor, es decir, este problema ocurre con desarrolladores muy diferentes. <br><br>  <em>O (n <sup>2</sup> ) es un im√°n para algoritmos que no escalan bien: son lo suficientemente r√°pidos como para entrar en producci√≥n, pero lo suficientemente lentos como para estropear todo cuando llegan all√≠.</em> <br><br>  Exactamente <br><br>  Por ejemplo, la <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">creaci√≥n de los nombres de los archivos de registro del verificador de la aplicaci√≥n se realiza en tiempo lineal</a> para cada proceso en ejecuci√≥n, y esto es normal hasta que se da cuenta de que esto conduce a O (n <sup>2</sup> ) si se est√°n ejecutando muchos procesos.  A veces ni siquiera es obvio que hay bucles anidados, o que <em>formalmente</em> no es O (n <sup>2</sup> ), o no es obvio que los bucles pueden funcionar durante tanto tiempo que puede afectar significativamente la velocidad ... <br><br>  Por lo tanto, tenga en cuenta esta caracter√≠stica, piense en ello cuando escriba c√≥digo, monitoree c√≥mo se escala el rendimiento bajo cargas pesadas y examine partes sospechosas del c√≥digo al perfilar esas cargas pesadas.  O d√©jemelo a m√≠ para que pueda buscarlos y escribir art√≠culos en mi blog. <br><br><h2>  Volvamos a nuestras quejas habituales. </h2><br>  Como de costumbre, me dediqu√© a trabajar en mi estaci√≥n de trabajo desactualizada pero poderosa con 48 procesadores l√≥gicos y 96 GB de RAM.  Introduje <em>ninja chrome</em> para construir Chromium, pero ... no pas√≥ nada.  Mir√© y esper√© veinte segundos, pero la asamblea nunca comenz√≥.  Entonces, por supuesto, <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/" rel="nofollow"><em>cambi√©</em></a> a <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/" rel="nofollow"><em>UIforETW</em></a> para grabar el rastro <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/" rel="nofollow"><em>ETW</em></a> .  M√°s precisamente, trat√© de hacerlo.  Al intentar iniciar la grabaci√≥n de seguimiento, <em>UIforETW se congela</em> .  ¬°Por primera vez en mi pr√°ctica, un error utiliz√≥ medidas de protecci√≥n para evitar que lo explorara! <br><br>  Despu√©s de uno o dos minutos, comenz√≥ el ensamblaje de Chromium, y <em>UIforETW</em> comenz√≥ la traza, pero comenz√≥ demasiado tarde y no ten√≠a la m√°s m√≠nima informaci√≥n sobre lo que sucedi√≥. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/485/76e/b86/48576eb86c46f3254d1b891d180cc25e.png"></div><br>  <i>Opciones de UIforETW con seguimiento de b√∫fer circular seleccionado</i> <br><br>  Cuando sucedi√≥ lo mismo un par de d√≠as despu√©s, <em>UIforETW</em> nuevamente no pudo hacer nada.  Esta vez, dej√© el rastro para trabajar en memorias intermedias circulares, para estar preparados para el hecho de que el bloqueo se producir√≠a por tercera vez.  Sin embargo, esto redujo en gran medida la velocidad de mis herramientas de construcci√≥n, as√≠ que despu√©s de unas horas me di por vencido. <br><br>  Entonces esta situaci√≥n se repiti√≥ <em>nuevamente</em> .  Esta vez ejecut√© la herramienta de <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>registro de</em></a> rastreo ETW creada por Microsoft - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>wprui</em></a> , y pude comenzar a grabar.  ¬°Aproximadamente 40 segundos despu√©s, el ensamblaje comenz√≥ a funcionar y obtuve un rastro! <br><br><h2>  ¬øPuedo comenzar la investigaci√≥n ahora? </h2><br>  Anteriormente, not√© en el "Administrador de tareas" que <em>WinMgmt.exe se</em> estaba <em>ejecutando</em> durante estas <em>congelaciones</em> .  Al <em>observar los</em> datos de Uso de CPU (Preciso) en WPA, me convenc√≠ de que despu√©s de m√°s de cuarenta segundos, durante los cuales <em>WinMgmt.exe</em> fue casi el √∫nico proceso de trabajo, mi m√°quina cobr√≥ vida despu√©s de que <em>WinMgmt.exe se apagara</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02a/cd4/35d/02acd435d1b3dec571ae9ebb5b56b67a.png"></div><br>  <i>Esperamos el despertar de los procesos despu√©s de que se complete WinMgmt.exe</i> <br><br>  Todo esto es bastante sospechoso, pero mis sabios lectores saben que "despu√©s" no significa "debido a", y requerir√°n pruebas. <br><br>  Como la <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">√∫ltima vez</a> , aproxim√© el momento del desbloqueo en el gr√°fico, clasificando los cambios de contexto por <em>Tiempo de cambio</em> y buscando el primer cambio con un valor de <em>Tiempo desde el √∫ltimo</em> largo (que indica el per√≠odo de tiempo durante el cual el hilo no se ejecut√≥).  Habiendo perdido una docena de hilos que solo fueron cortos tiempos de inactividad, encontr√© el primero de muchos que esper√≥ 41.57 segundos.  El hilo dormido no despert√≥ <em>WinMgmt.exe</em> , pero r√°pidamente descubr√≠ que se despert√≥ con el hilo que despert√≥ <em>WinMgmt.exe</em> una fracci√≥n de milisegundo antes. <br><br><blockquote>  Para obtener una explicaci√≥n de los gr√°ficos de Uso de CPU (Preciso) y los conceptos de preparaci√≥n de subprocesos / subprocesos nuevos, consulte <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">este tutorial</a> o <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">esta documentaci√≥n</a> . </blockquote><br>  En la captura de pantalla con los datos de cambio de contenido, la l√≠nea 17 contiene la secuencia <em>72.748 (WinMgmt.exe)</em> , que activa la secuencia <em>74.156 (svchost.exe).</em>  A continuaci√≥n, en la l√≠nea 19, el subproceso <em>74,156 (svchost.exe)</em> activa el subproceso <em>58,704 (svchost.exe)</em> , que esperaba 41,57 segundos.  Este es el primer hilo que se despierta despu√©s de un largo sue√±o y a partir de esto contin√∫a la cadena de activaci√≥n de los flujos.  Los subprocesos que se acaban de activar se pueden ver en la columna <em>Nuevo Id. De subproceso</em> , y luego bajar unas l√≠neas y verlos en la columna <em>Id. De subproceso de preparaci√≥n</em> , activando otro subproceso.  Los nombres y las ID de proceso lo ayudan a comprender el contexto.  La l√≠nea 17 est√° asociada con las l√≠neas 18 y 19, la l√≠nea 19 est√° asociada con 20, que est√° asociada con la l√≠nea 23, que est√° asociada con la l√≠nea 27, y as√≠ sucesivamente;  cada hilo es activado por el hilo anterior en la cadena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png"></div><br>  <i>El monstruo despierta: los largos hilos inactivos cobran vida</i> <br><br>  41.57 es mucho tiempo para bloquear un hilo, pero en realidad se bloquearon cientos de hilos, y se bloquearon <em>mucho</em> m√°s tiempo.  La √∫nica raz√≥n por la que su valor <em>Tiempo desde el √∫ltimo</em> es aproximadamente 41.5 segundos es porque la longitud del rastreo antes de que se resuelva el bloqueo. <br><br>  Parece que los resultados son consistentes con la teor√≠a de que el problema est√° en <em>WinMgmt.exe</em> , pero no lo prueban.  Mi confianza aument√≥ cuando mir√© <em>svchost.exe (3024)</em> en <em>Seguimiento-&gt; Configuraci√≥n del sistema-&gt; Servicios</em> y descubr√≠ que es un servicio <em>Winmgmt</em> , pero a√∫n necesitaba m√°s certeza. <br><br>  Habiendo hurgado un poco m√°s (avanzando y retrocediendo en el tiempo), decid√≠ que las interacciones son demasiado complicadas para analizarlas en detalle, especialmente sin <a href="https://randomascii.wordpress.com/2015/10/26/thread-naming-in-windows-time-for-something-better/" rel="nofollow">nombres de flujo</a> que podr√≠an indicarnos qu√© est√°n haciendo 25 hilos diferentes en <em>svchost.exe (3024)</em> . <br><br><h2>  Prueba! </h2><br>  Entonces decid√≠ <em>acercarme a la prueba de</em> culpabilidad <em>WinMgmt.exe de manera</em> diferente.  Quiz√°s vali√≥ la pena comenzar con esto, pero ser√≠a demasiado simple.  Tom√© la l√≠nea de comando <em>WinMgmt.exe</em> de la tabla <em>Procesos</em> en WPA y la inici√© manualmente.  El comando tiene la forma: <br><br><blockquote>  winmgmt.exe / verificadorepository </blockquote><br>  y tard√≥ unos cinco minutos en completarse.  Si bien funcion√≥ (y tuve mucho tiempo), descubr√≠ que no pod√≠a iniciar el seguimiento de ETW desde <em>UIforETW</em> .  Tal evidencia era mejor que cualquier an√°lisis complejo que pudiera hacer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/c6f/d64/1a0c6fd64820226eddd120b5e9ab2ab7.png"></div><br>  <i>Configuraci√≥n para mostrar solo subprocesos inactivos largos</i> <br><br>  Luego corr√≠ repro nuevamente con el rastro ya corriendo;  Despu√©s de analizar el rastro, descubr√≠ m√°s de <em>cien</em> procesos cuyos hilos fueron bloqueados durante m√°s de <em>cinco minutos.</em> <br><br><h2>  Y de nuevo al grano ... </h2><br>  Por costumbre, volv√≠ a mirar los datos de Uso de la CPU (Muestreo) para ver en qu√© <em>WinMgmt.exe estaba</em> perdiendo el tiempo.  R√°pidamente descubr√≠ que el 96.5% de las muestras estaban en <em>repdrvfs.dll! CPageCache :: Read ()</em> , llamado en cuatro pilas diferentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/7d9/5f1/5447d95f1b431681cdd83ad42df7e731.png"></div><br>  <i>Cuatro caminos que me llevaron a CPageCache :: Leer</i> <br><br>  Aqu√≠ se muestra un √°rbol de pilas completas para esta funci√≥n, principalmente para las personas de Microsoft que desean investigar este problema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e6/6b3/519/0e66b35191db016e98ded6eb08445569.png"></div><br>  <i>Pilas completas que conducen a CPageCache :: Leer de tres maneras</i> <br><br>  Agregu√© una columna de direcci√≥n y descubr√≠ que el 95.3% de las muestras estaban en un ciclo de nueve instrucciones (las muestras siempre cayeron en solo siete de nueve instrucciones (si desea saber por qu√©, vea <a href="https://travisdowns.github.io/blog/2019/08/20/interrupts.html" rel="nofollow">aqu√≠</a> ), pero el depurador mostr√≥ el tama√±o completo del ciclo) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/8e6/04a/ecf8e604adbd110fdfaf77bb87dd378a.png"></div><br>  <i>Muestras por direcci√≥n: siete direcciones muy "calientes"</i> <br><br>  Luego comenc√© <em>winmgmt.exe / verifiedrepository</em> manualmente, y al <em>mismo tiempo</em> <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">recopil√© datos del contador de la CPU sobre las instrucciones de rama que se estaban ejecutando</a> .  A partir de esto, podr√≠a calcular aproximadamente cu√°ntas veces se ejecut√≥ el ciclo.  Esto probablemente no era necesario, pero quer√≠a asegurarme de que el bucle se ejecutara muchas veces y que no se ejecutara lentamente (por alguna raz√≥n).  Pens√© que era genial poder hacerlo simplemente, solo hacer un <a href="" rel="nofollow">peque√±o cambio</a> en el archivo por lotes.  Descubr√≠ que <em>WinMgmt.exe</em> ejecut√≥ aproximadamente una instrucci√≥n de ramificaci√≥n por ciclo, es decir, el ciclo (que, como ya sab√≠a, consum√≠a la mayor parte del tiempo de la CPU) fue extremadamente r√°pido, y la desaceleraci√≥n se debi√≥ al hecho de que corri√≥ cientos de millones tiempos <br><br><h2>  Retardo Xperf </h2><br>  Solo por meticulosidad, decid√≠ ver por qu√© <em>UIforETW</em> no pod√≠a comenzar a rastrear durante este incidente.  <em>Result√≥</em> que <em>UIforETW estaba</em> ejecutando <em>xperf</em> , pero <em>xperf estuvo</em> inactivo durante 41.5 segundos (en realidad m√°s) en esta pila de llamadas: <br><br><blockquote>  xperf.exe! wmain <br>  xperf.exe! CStopTrace :: Ejecutar <br>  perfctrl.dll! LoggingSession :: EnumLoggers <br>  perfctrl.dll! LoggingSession :: LoggingSession <br>  perfctrl.dll! LoggingSession :: CreateProviderList <br>  perfctrl.dll! GetProviderInfoCache <br>  perfctrl.dll! CProviderInfoCache :: CProviderInfoCache <br>  tdh.dll! TdhfEnumerateProviders <br>  tdh.dll! TdhpWbemConnect <br>  wbemprox.dll! CLocator :: ConnectServer <br>  wbemprox.dll! CDCOMTrans :: DoActualConnection </blockquote><br>  En resumen, <em>xperf</em> es llamado por <em>Wbem</em> y, por lo tanto, est√° bloqueado por este problema.  <em>xperf</em> intenta detener el rastreo antes de iniciarlo, porque agregu√© este comportamiento para que el <a href="https://github.com/google/UIforETW/commit/092fa4d3c30137eca658a86d58fc8230ced56c7c" rel="nofollow">inicio del rastreo sea m√°s tolerante a fallas</a> .  Sospecho que a√∫n se producir√≠a un bloqueo, pero no estoy seguro. <br><br><h2>  Creamos gr√°ficos de complejidad computacional. </h2><br>  Me di cuenta de que <em>WinMgmt.exe</em> escanea el <em>directorio</em> <em>c: \ windows \ System32 \ wbem \ Repository</em> , que tiene 1.9 GB en mi m√°quina, por lo que ped√≠ en el trabajo y en Twitter que dijera cu√°nto tarda este directorio en obtener puntos de datos.  Tambi√©n le ped√≠ a la gente que arreglara el tiempo de ejecuci√≥n de <em>winmgmt.exe / verificadorepository</em> y comenc√© a programar.  Aunque estas pruebas se llevaron a cabo en m√°quinas completamente diferentes con diferentes velocidades de CPU, el gr√°fico result√≥ ser bastante claro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/dd8/23d/539dd823d7fb9b33df39dc61f9e183dd.png"></div><br>  <i>La relaci√≥n entre la ra√≠z cuadrada del tiempo y el tama√±o del repositorio</i> <br><br>  Este gr√°fico de la relaci√≥n de sqrt (tiempo) al tama√±o del repositorio es incre√≠blemente ideal para los datos recibidos de seis m√°quinas diferentes y, sin embargo, es real.  Obviamente, la funci√≥n <em>VerifyRepository</em> tiene un rendimiento O (n <sup>2</sup> ).  Si n es el tama√±o del directorio del repositorio en <a href="https://randomascii.wordpress.com/2016/02/13/base-ten-for-almost-everything/" rel="nofollow">GB</a> , entonces <em>VerifyRepository</em> demora aproximadamente 1.6 * n <sup>2</sup> minutos.  Esta es una buena estimaci√≥n aproximada para todos los valores, desde una fracci√≥n de segundo hasta diez minutos. <br><br><h2>  Relevancia </h2><br>  O tengo suerte o solo estoy atento, porque durante un par de semanas ya nadie ha encontrado este problema; pens√© que cosas extra√±as estaban sucediendo con mi autom√≥vil.  Pero de repente comenc√© a escuchar quejas sospechosamente similares de colegas.  Uno de ellos ten√≠a un repositorio de 2.6 GB, que tard√≥ diez minutos en verificar.  El problema afect√≥ a algunos de nuestros desarrolladores de <a href="https://en.wikipedia.org/wiki/Continuous_integration" rel="nofollow">CI</a> y, en diferentes grados, a otras personas diferentes.  Mis colegas generalmente saben que en caso de problemas con el rendimiento de las m√°quinas con Windows, tengo que decirme esto, sin embargo, probablemente hay muchos otros empleados de Google que trabajan con Windows que se ven impedidos por este error, pero no se dan cuenta de esto. <br><br>  Afortunadamente, ya he comenzado a trabajar con nuestro departamento de TI.  Encontr√© el script que lanz√≥ <em>WinMgmt</em> y descubr√≠ que se ejecuta cada hora.  Esto significaba que mi m√°quina estaba <em>ejecutando WinMgmt.exe / verificadorepository el</em> 10% del tiempo, y algunos de mis colegas ten√≠an m√°s del 16% del tiempo.  Hay una probabilidad bastante alta de obtener un retraso de diez minutos antes del montaje. <br><br>  Para cuando comenzaron a llegar los informes, la soluci√≥n ya estaba en camino a la producci√≥n.  El script era opcional, y ciertamente no val√≠a la pena por los problemas que caus√≥, por lo que la soluci√≥n fue desactivar su llamada. <br><br><h2>  Resumen </h2><br>  <em>winmgmt.exe / verifiedrepository</em> contiene un ciclo de nueve instrucciones, cuyo n√∫mero de iteraciones de ejecuci√≥n es proporcional al cuadrado del tama√±o del <em>repositorio wbem</em> .  Debido a esto, la ejecuci√≥n del comando puede tomar hasta diez minutos, aunque en realidad deber√≠a ejecutarse en solo unos segundos.  Esto es malo en s√≠ mismo. <br><br>  Pero a√∫n peor, el equipo realiza un bloqueo WMI ( <a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page" rel="nofollow">Instrumental de administraci√≥n de Windows</a> ) durante su operaci√≥n, por lo que cualquier proceso que realice operaciones WMI se congelar√°. <br><br><h2>  Acertijos incre√≠bles </h2><br>  El script que <em>ejecutaba winmgmt.exe / verificadorepository</em> cada hora hizo esto durante muchos a√±os, pero el comportamiento problem√°tico comenz√≥ a aparecer hace solo uno o dos meses.  Presumiblemente, esto significa que el repositorio wbem se ha vuelto mucho m√°s grande recientemente.  Los retrasos a 0.5 GB se pasan por alto f√°cilmente, pero a partir de 1.0 GB y m√°s ya pueden forzar.  Como se <a href="https://twitter.com/itoleck/status/1192647636085592069" rel="nofollow">sugiri√≥ en Twitter,</a> ejecut√© <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" rel="nofollow">strings.exe</a> para el archivo <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" rel="nofollow">objects.data</a> .  Muchas de las cadenas m√°s comunes contienen polmkr en el nombre, pero no s√© qu√© significa eso. <br><br>  <a href="https://twitter.com/BruceDawson0xB/status/1189979046135750657" rel="nofollow">Publiqu√© un informe de error en Twitter</a> , y al principio caus√≥ <a href="https://twitter.com/djammmer/status/1192634563421495297" rel="nofollow">algunos movimientos del equipo de WMI</a> , pero luego dej√© de recibir respuestas, por lo que no s√© cu√°l es la situaci√≥n ahora. <br><br>  Me gustar√≠a ver una soluci√≥n para el problema de rendimiento, y me gustar√≠a que nuestro departamento de TI pueda encontrar y solucionar el problema que hace que nuestros repositorios wbem sean tan grandes.  Pero por ahora, el departamento de TI ha prometido no ejecutar el comando / verifique el repositorio cada hora m√°s, lo que deber√≠a ayudarnos a evitar los peores s√≠ntomas. <br><br><h2>  Referencias </h2><br><ul><li>  Una lista general de tutoriales, investigaciones y documentaci√≥n de ETW est√° disponible aqu√≠: <a href="https://tinyurl.com/etwcentral" rel="nofollow">https://tinyurl.com/etwcentral</a> </li><li>  El tutorial sobre el uso de la CPU (muestreado) (para averiguar en qu√© se dedica el tiempo de la CPU) est√° <a href="https://randomascii.wordpress.com/2013/04/23/xperf-for-excess-cpu-consumption-wpa-edition/" rel="nofollow">aqu√≠</a> , y la documentaci√≥n est√° <a href="https://randomascii.wordpress.com/2012/05/08/the-lost-xperf-documentationcpu-sampling/" rel="nofollow">aqu√≠.</a> </li><li>  El tutorial de Uso de CPU (Preciso) (para encontrar las razones por las que no se pueden ejecutar hilos) est√° <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">aqu√≠</a> , y la documentaci√≥n est√° <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">aqu√≠.</a> </li><li>  Los enlaces a art√≠culos individuales se encuentran en el cuerpo de la publicaci√≥n, tambi√©n puede encontrarlos en mi categor√≠a <a href="https://randomascii.wordpress.com/category/investigative-reporting/" rel="nofollow">Investigar informes</a> </li><li>  Otras historias sobre algoritmos O (n <sup>2</sup> ) se pueden leer en <a href="https://accidentallyquadratic.tumblr.com/" rel="nofollow">Accidentally Quadratic</a> </li></ul><br>  Una discusi√≥n del art√≠culo sobre Reddit est√° <a href="https://www.reddit.com/r/programming/comments/e87dpb/on2_again_now_in_wmi/" rel="nofollow">aqu√≠</a> , una discusi√≥n sobre noticias de hackers est√° <a href="https://news.ycombinator.com/item%3Fid%3D21743424" rel="nofollow">aqu√≠</a> , un hilo en Twitter est√° <a href="https://twitter.com/BruceDawson0xB/status/1203905010716643328" rel="nofollow">aqu√≠,</a> y posiblemente <a href="https://twitter.com/BruceDawson0xB/status/1203922370957721600" rel="nofollow">aqu√≠</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479498/">https://habr.com/ru/post/479498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479482/index.html">SDK de SARIF y sus errores</a></li>
<li><a href="../479486/index.html">Programaci√≥n heterog√©nea y oneAPI Toolkit. Conferencia improvisada experta de Intel responde sus preguntas</a></li>
<li><a href="../479488/index.html">Desde una computadora port√°til: un servidor dom√©stico con alimentaci√≥n redundante al enrutador Mikrotik</a></li>
<li><a href="../479492/index.html">Computaci√≥n sin servidor basada en OpenWhisk, parte 3</a></li>
<li><a href="../479496/index.html">An√°lisis de tareas de WTF en JavaScript</a></li>
<li><a href="../479502/index.html">¬øC√≥mo sobrevivir a la edad de hielo m√°s severa en la historia de la Tierra?</a></li>
<li><a href="../479504/index.html">Cree un cliente ligero RDP basado en Raspberry Pi</a></li>
<li><a href="../479508/index.html">Antipatterns PostgreSQL: uniones da√±inas y OR</a></li>
<li><a href="../479510/index.html">Revisi√≥n de PocketBook X: un enorme lector de 10.3 pulgadas con una pantalla E Ink Carta Mobius y una carcasa de metal</a></li>
<li><a href="../479512/index.html">MVCC en PostgreSQL-4. Instant√°neas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>