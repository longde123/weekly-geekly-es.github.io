<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüç≥ üèóÔ∏è ü§∂üèΩ Flatter App Architektur 101: Vanille, Scoped Model, BLoC üé• üêá üê®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(urspr√ºnglich auf Medium ver√∂ffentlicht ) 


 Flutter bietet ein modernes Framework im Reaktionsstil, eine umfangreiche Widget-Sammlung und Tools, abe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flatter App Architektur 101: Vanille, Scoped Model, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438524/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (urspr√ºnglich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium ver√∂ffentlicht</a> ) </p><br><p>  Flutter bietet ein modernes Framework im Reaktionsstil, eine umfangreiche Widget-Sammlung und Tools, aber es gibt nichts Vergleichbares zu Android's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handbuch zur App-Architektur</a> . </p><br><p>  In der Tat gibt es keine ultimative Architektur, die alle m√∂glichen Anforderungen erf√ºllt. Stellen wir uns jedoch der Tatsache, dass die meisten mobilen Apps, an denen wir arbeiten, mindestens einige der folgenden Funktionen aufweisen: </p><br><ol><li>  Daten vom / zum Netzwerk anfordern / hochladen. </li><li>  Ordnen Sie Daten zu, transformieren Sie sie, bereiten Sie sie vor und pr√§sentieren Sie sie dem Benutzer. </li><li>  Daten in / aus der Datenbank ablegen / abrufen. </li></ol><br><p>  In Anbetracht dessen habe ich eine Beispiel-App erstellt, die genau das gleiche Problem mit drei verschiedenen Ans√§tzen f√ºr die Architektur l√∂st. <a name="habracut"></a></p><br><p>  Dem Benutzer wird in der Mitte des Bildschirms die Schaltfl√§che ‚ÄûBenutzerdaten laden‚Äú angezeigt.  Wenn der Benutzer auf die Schaltfl√§che klickt, wird das Laden asynchroner Daten ausgel√∂st und die Schaltfl√§che durch eine Ladeanzeige ersetzt.  Nach dem Laden der Daten wird die Ladeanzeige durch die Daten ersetzt. </p><br><p>  Fangen wir an. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="data">  Daten </h2><br><p> Der Einfachheit halber habe ich eine <code>Repository</code> Klasse erstellt, die die Methode <code>getUser()</code> enth√§lt, die einen asynchronen Netzwerkaufruf emuliert und das <code>Future&lt;User&gt;</code> -Objekt mit fest codierten Werten zur√ºckgibt. </p><br><p>  Wenn Sie mit Futures und asynchroner Programmierung in Dart nicht vertraut sind, k√∂nnen Sie mehr dar√ºber erfahren, indem Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Tutorial</a> folgen und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument</a> lesen. </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanille </h2><br><p>  Lassen Sie uns die App so erstellen, wie es die meisten Entwickler nach dem Lesen der offiziellen Flutter-Dokumentation tun w√ºrden. </p><br><p>  Navigieren zum <code>VanillaScreen</code> Bildschirm mit <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Da sich der Status des Widgets w√§hrend der Lebensdauer des Widgets mehrmals √§ndern kann, sollten wir <code>StatefulWidget</code> .  F√ºr die Implementierung eines Stateful-Widgets ist au√üerdem eine <code>State</code> Klasse erforderlich.  Die Felder <code>bool _isLoading</code> und <code>User _user</code> in der <code>_VanillaScreenState</code> Klasse repr√§sentieren den Status des Widgets.  Beide Felder werden initialisiert, bevor die <code>build(BuildContext context)</code> Methode <code>build(BuildContext context)</code> aufgerufen wird. </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Wenn das Widget- <code>build(BuildContext context)</code> erstellt wird <code>build(BuildContext context)</code> wird die <code>build(BuildContext context)</code> Methode <code>build(BuildContext context)</code> aufgerufen, um die Benutzeroberfl√§che zu erstellen.  Alle Entscheidungen √ºber die Widgets, die zur Darstellung des aktuellen Status erstellt werden sollen, werden im UI-Deklarationscode getroffen. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Um die Fortschrittsanzeige anzuzeigen, wenn der Benutzer auf die Schaltfl√§che "Benutzerdetails laden" klickt, gehen wir wie folgt vor. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><blockquote>  Durch Aufrufen von setState () wird das Framework benachrichtigt, dass sich der interne Status dieses Objekts so ge√§ndert hat, dass sich dies auf die Benutzeroberfl√§che in diesem Teilbaum auswirken kann. Dadurch plant das Framework einen Build f√ºr dieses Statusobjekt. </blockquote><p>  Das bedeutet, dass nach dem Aufruf der <code>setState()</code> -Methode die <code>build(BuildContext context)</code> Methode <code>build(BuildContext context)</code> erneut vom Framework aufgerufen wird und <strong>der gesamte Widget-Baum neu erstellt wird</strong> .  Da <code>_isLoading</code> jetzt auf <code>true</code> gesetzt ist, wird <code>_buildLoading()</code> anstelle von <code>_buildBody()</code> und die Ladeanzeige wird auf dem Bildschirm angezeigt.  Genau das gleiche passiert, wenn wir den R√ºckruf von <code>getUser()</code> und <code>setState()</code> <code>_user</code> Felder <code>_isLoading</code> und <code>_user</code> neu <code>_isLoading</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="pros">  Vorteile </h3><br><ol><li>  Leicht zu lernen und zu verstehen. </li><li>  Es sind keine Bibliotheken von Drittanbietern erforderlich. </li></ol><br><h3 id="cons">  Nachteile </h3><br><ol><li>  Der gesamte Widget-Baum wird jedes Mal neu erstellt, wenn sich der Widget-Status √§ndert. </li><li>  Es bricht das Prinzip der Einzelverantwortung.  Widget ist nicht nur f√ºr die Erstellung der Benutzeroberfl√§che verantwortlich, sondern auch f√ºr das Laden von Daten, die Gesch√§ftslogik und die Statusverwaltung. </li><li>  Entscheidungen dar√ºber, wie der aktuelle Status dargestellt werden soll, werden im UI-Deklarationscode getroffen.  Wenn wir einen etwas komplexeren Statuscode h√§tten, w√ºrde die Lesbarkeit abnehmen. </li></ol><br><h2 id="scoped-model">  Modell mit G√ºltigkeitsbereich </h2><br><p>  Scoped Model ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket von Drittanbietern,</a> das nicht im Flutter-Framework enthalten ist.  So beschreiben es die Entwickler von Scoped Model: </p><br><blockquote>  Eine Reihe von Dienstprogrammen, mit denen Sie ein Datenmodell einfach von einem √ºbergeordneten Widget an seine Nachkommen √ºbergeben k√∂nnen.  Dar√ºber hinaus werden alle untergeordneten Elemente neu erstellt, die das Modell verwenden, wenn das Modell aktualisiert wird.  Diese Bibliothek wurde urspr√ºnglich aus der Fuchsia-Codebasis extrahiert. </blockquote><p>  Erstellen wir denselben Bildschirm mit Scoped Model.  Zuerst m√ºssen wir das Scoped Model-Paket installieren, indem <code>scoped_model</code> Abh√§ngigkeit <code>pubspec.yaml</code> zu <code>pubspec.yaml</code> im Abschnitt Abh√§ngigkeiten <code>pubspec.yaml</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Schauen wir uns das <code>UserModelScreen</code> Widget an und vergleichen es mit dem vorherigen Beispiel, das ohne Verwendung des Bereichsmodells erstellt wurde.  Schauen wir uns das UserModelScreen-Widget an und vergleichen es mit dem vorherigen Beispiel, das ohne Verwendung des Bereichsmodells erstellt wurde.  Da wir unser Modell allen Nachkommen des Widgets zur Verf√ºgung stellen m√∂chten, sollten wir es mit generischem ScopedModel umschlie√üen und ein Widget und ein Modell bereitstellen. </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Im vorherigen Beispiel wurde der gesamte Widget-Baum neu erstellt, als sich der Status des Widgets √§nderte.  Aber m√ºssen wir tats√§chlich den gesamten Bildschirm neu erstellen?  Zum Beispiel sollte sich AppBar √ºberhaupt nicht √§ndern, sodass es keinen Sinn macht, sie neu zu erstellen.  Im Idealfall sollten wir nur die aktualisierten Widgets neu erstellen.  Scoped Model kann uns dabei helfen, das zu l√∂sen. </p><br><p>  <code>ScopedModelDescendant&lt;UserModel&gt;</code> Widget <code>ScopedModelDescendant&lt;UserModel&gt;</code> wird verwendet, um <code>UserModel</code> in der Widget- <code>UserModel</code> zu finden.  Es wird automatisch neu erstellt, wenn das <code>UserModel</code> benachrichtigt, dass eine √Ñnderung stattgefunden hat. </p><br><p>  Eine weitere Verbesserung besteht darin, dass <code>UserModelScreen</code> nicht mehr f√ºr die <code>UserModelScreen</code> und die Gesch√§ftslogik verantwortlich ist. </p><br><p>  <code>UserModel</code> wir einen Blick auf den <code>UserModel</code> Code. </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  Jetzt h√§lt <code>UserModel</code> den <code>UserModel</code> und verwaltet ihn.  Um Listener zu benachrichtigen (und Nachkommen neu zu <code>notifyListeners()</code> ), dass die √Ñnderung stattgefunden hat, sollte die Methode <code>notifyListeners()</code> aufgerufen werden. </p><br><h3 id="pros-1">  Vorteile </h3><br><ol><li>  Gesch√§ftslogik, Statusverwaltung und UI-Codetrennung. </li><li>  Leicht zu lernen. <br><h3 id="cons">  Nachteile </h3></li><li>  Ben√∂tigt eine Bibliothek eines Drittanbieters. </li><li>  Da das Modell immer komplexer wird, ist es schwierig zu verfolgen, wann Sie <code>notifyListeners()</code> aufrufen <code>notifyListeners()</code> . </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC (Business Logic Components) ist ein von Google-Entwicklern empfohlenes Muster.  Es nutzt die Stream-Funktionalit√§t, um Status√§nderungen zu verwalten und weiterzugeben. </p><br><p>  <strong>F√ºr Android-Entwickler:</strong> Sie k√∂nnen sich das <code>Bloc</code> Objekt als <code>ViewModel</code> und <code>StreamController</code> als <code>LiveData</code> .  Dies macht den folgenden Code sehr einfach, da Sie bereits mit den Konzepten vertraut sind. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  Es sind keine zus√§tzlichen Methodenaufrufe erforderlich, um Teilnehmer zu benachrichtigen, wenn sich der Status √§ndert. </p><br><p>  Ich habe 3 Klassen erstellt, um m√∂gliche Zust√§nde des Bildschirms darzustellen: </p><br><p>  <code>UserInitState</code> f√ºr den Status, in dem der Benutzer einen Bildschirm mit einer Schaltfl√§che in der Mitte √∂ffnet. </p><br><p>  <code>UserLoadingState</code> f√ºr den Status, in dem die Ladeanzeige angezeigt wird, w√§hrend Daten geladen werden. </p><br><p>  <code>UserDataState</code> f√ºr den Status, in dem Daten geladen und auf dem Bildschirm angezeigt werden. </p><br><p>  Durch die Weitergabe von Status√§nderungen auf diese Weise k√∂nnen wir die gesamte Logik im UI-Deklarationscode entfernen.  Im Beispiel mit Scoped Model haben wir immer noch √ºberpr√ºft, ob <code>_isLoading</code> im UI-Deklarationscode <code>true</code> ist, um zu entscheiden, welches Widget <code>_isLoading</code> soll.  Im Fall von BLoC verbreiten wir den Status des Bildschirms und die einzige Verantwortung des <code>UserBlocScreen</code> Widgets besteht darin, die Benutzeroberfl√§che f√ºr diesen Status zu rendern. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  <code>UserBlocScreen</code> Code wurde im Vergleich zu den vorherigen Beispielen noch einfacher.  Um die √Ñnderungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Status√§nderungen</a> zu h√∂ren, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamBuilder</a> .  <code>StreamBuilder</code> ist ein <code>StatefulWidget</code> , das sich selbst basierend auf dem neuesten Snapshot der Interaktion mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream erstellt</a> . </p><br><h3 id="pros-2">  Vorteile </h3><br><p>  Es werden keine Bibliotheken von Drittanbietern ben√∂tigt. <br>  Gesch√§ftslogik, Statusverwaltung und UI-Logiktrennung. <br>  Es ist reaktiv.  Es sind keine zus√§tzlichen Aufrufe erforderlich, wie im Fall von <code>notifyListeners()</code> Scoped Model. </p><br><h3 id="cons-1">  Nachteile </h3><br><p>  Erfahrung im Umgang mit Streams oder RXDART ist erforderlich. </p><br><h2 id="links">  Links </h2><br><p>  Sie k√∂nnen den Quellcode der obigen Beispiele aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Github-Repo auschecken.</a> </p><br><p>  Urspr√ºnglich wurde der Artikel auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium ver√∂ffentlicht</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438524/">https://habr.com/ru/post/de438524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438512/index.html">Huffman-Datenkomprimierung</a></li>
<li><a href="../de438514/index.html">Wie ich seit einem Jahr nicht mehr bei der Sberbank gearbeitet habe</a></li>
<li><a href="../de438516/index.html">Wann wird die L√§nge eines Arrays in einer lokalen Variablen in C # gespeichert?</a></li>
<li><a href="../de438518/index.html">Erstellen Sie Ihre jsfiddle, Teil 2</a></li>
<li><a href="../de438522/index.html">Strategischer Equalizer</a></li>
<li><a href="../de438526/index.html">K√ºnstliche neuronale Netze wachsen Navigationszellen wie im Gehirn</a></li>
<li><a href="../de438530/index.html">Hipster Podcasts # 1</a></li>
<li><a href="../de438534/index.html">Modbus auf dem russischen Mikrocontroller K1986BE92QI</a></li>
<li><a href="../de438536/index.html">Unter der Haube des Chatbots: Was RocketBot kann und wie es funktioniert</a></li>
<li><a href="../de438538/index.html">Teamlead Conf 2019 Msk: √ºber ein anderes Kommunikationsformat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>