<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥Ô∏è üç≠ üßëüèΩ‚Äçü§ù‚Äçüßëüèº Montagem din√¢mica e implanta√ß√£o de imagens do Docker com werf usando o site de exemplo da documenta√ß√£o com vers√£o üçÑ ‚úäüèΩ üßúüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° falamos sobre a ferramenta GitOps do werf mais de uma vez , mas desta vez gostar√≠amos de compartilhar a experi√™ncia de criar o site com a documenta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Montagem din√¢mica e implanta√ß√£o de imagens do Docker com werf usando o site de exemplo da documenta√ß√£o com vers√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/478690/">  J√° falamos sobre a ferramenta GitOps do werf mais <a href="https://github.com/flant/werf">de uma vez</a> , mas desta vez gostar√≠amos de compartilhar a experi√™ncia de criar o site com a documenta√ß√£o do projeto - <a href="https://werf.io/">werf.io</a> (a vers√£o russa √© <a href="https://ru.werf.io/">ru.werf.io</a> ).  Este √© um site est√°tico comum, mas sua montagem √© interessante porque √© constru√≠da usando um n√∫mero din√¢mico de artefatos. <br><br><img src="https://habrastorage.org/webt/m_/ox/od/m_oxod8ckyfsipscttspcn5opd8.png"><br><br>  Entre nas nuances da estrutura do site: gerando um menu geral para todas as vers√µes, p√°ginas com informa√ß√µes sobre lan√ßamentos, etc.  - n√≥s n√£o vamos.  Em vez disso, focamos nos problemas e recursos da montagem din√¢mica e um pouco nos processos de CI / CD que o acompanham. <a name="habracut"></a><br><br><h2>  Introdu√ß√£o: como o site est√° organizado </h2><br>  Para come√ßar, a documenta√ß√£o do werf √© armazenada junto com seu c√≥digo.  Isso cria certos requisitos de desenvolvimento que geralmente v√£o al√©m do escopo deste artigo, mas pelo menos podemos dizer que: <br><br><ul><li>  As novas fun√ß√µes do werf n√£o devem ser liberadas sem atualizar a documenta√ß√£o e, inversamente, quaisquer altera√ß√µes na documenta√ß√£o implicam o lan√ßamento de uma nova vers√£o do werf; </li><li>  O projeto tem um desenvolvimento bastante intenso: novas vers√µes podem sair v√°rias vezes ao dia; </li><li>  Qualquer implanta√ß√£o manual de um site com uma nova vers√£o da documenta√ß√£o √© pelo menos entediante; </li><li>  O projeto adotou a abordagem de <a href="https://ru.werf.io/releases.html">versionamento</a> sem√¢ntico, com 5 canais de estabilidade.  O processo de libera√ß√£o envolve a passagem seq√ºencial de vers√µes pelos canais, a fim de aumentar a estabilidade: do alfa ao s√≥lido; </li><li>  O site possui uma vers√£o em russo, que "vive e se desenvolve" (ou seja, cujo conte√∫do √© atualizado) em paralelo com a vers√£o principal (ou seja, em ingl√™s). </li></ul><br>  Para ocultar ao usu√°rio toda essa "cozinha interna", oferecendo a ele algo que "simplesmente funciona", fizemos uma <b>ferramenta separada de instala√ß√£o e atualiza√ß√£o do werf</b> - este √© o <a href="https://github.com/flant/multiwerf">multiwerf</a> .  Basta indicar o n√∫mero do release e o canal de estabilidade que voc√™ est√° pronto para usar, e o multiwerf verificar√° se h√° uma nova vers√£o no canal e far√° o download, se necess√°rio. <br><br>  A vers√£o mais recente do werf em cada canal est√° dispon√≠vel no menu de sele√ß√£o de vers√£o no site.  Por padr√£o, a vers√£o do canal mais est√°vel para a vers√£o mais recente √© aberta em <a href="https://werf.io/documentation/">werf.io/documentation</a> - tamb√©m √© indexada pelos mecanismos de pesquisa.  A documenta√ß√£o do canal est√° dispon√≠vel em endere√ßos individuais (por exemplo, <a href="https://werf.io/v1.0-beta/documentation/">werf.io/v1.0-beta/documentation</a> para a vers√£o beta 1.0). <br><br>  Total, o site tem as seguintes vers√µes: <br><br><ol><li>  raiz (abre por padr√£o) </li><li>  para cada canal de atualiza√ß√£o ativo para cada vers√£o (por exemplo, <a href="https://werf.io/v1.0-beta/">werf.io/v1.0-beta</a> ). </li></ol><br>  Para gerar uma vers√£o espec√≠fica de um site no caso geral, basta compil√°-lo usando as ferramentas <a href="https://jekyllrb.com/">Jekyll</a> executando o comando apropriado ( <code>jekyll build</code> ) no diret√≥rio <code>/docs</code> do reposit√≥rio werf, ap√≥s alternar para a tag Git da vers√£o requerida. <br><br>  Resta apenas acrescentar que: <br><br><ul><li>  o pr√≥prio utilit√°rio (werf) √© usado para montagem; </li><li>  Os processos de IC / CD s√£o baseados no IC do GitLab; </li><li>  e tudo isso, √© claro, funciona em Kubernetes. </li></ul><br><h2>  As tarefas </h2><br>  Agora, formulamos tarefas que levam em conta todas as especificidades descritas: <br><br><ol><li>  Ap√≥s alterar a vers√£o do werf em qualquer canal de atualiza√ß√£o, a <b>documenta√ß√£o no site deve ser atualizada automaticamente</b> . </li><li>  Para o desenvolvimento, voc√™ precisa poder ocasionalmente <b>visualizar vers√µes preliminares do site</b> . </li></ol><br>  A recompila√ß√£o do site deve ser realizada ap√≥s a altera√ß√£o da vers√£o em qualquer canal das tags Git correspondentes, mas no processo de cria√ß√£o da imagem, obteremos os seguintes recursos: <br><br><ul><li>  Como a lista de vers√µes nos canais est√° mudando, √© necess√°rio remontar a documenta√ß√£o dos canais nos quais a vers√£o foi alterada.  Afinal, remontar tudo de novo n√£o √© muito bonito. </li><li>  O conjunto de canais para lan√ßamentos pode variar.  Em algum momento, por exemplo, a vers√£o nos canais pode n√£o ser mais est√°vel que a vers√£o 1.1 do acesso antecipado, mas com o tempo eles aparecer√£o - n√£o altere o conjunto manualmente neste caso? </li></ul><br>  Acontece que a <b>montagem depende da altera√ß√£o de dados externos</b> . <br><br><h2>  Implementa√ß√£o </h2><br><h3>  Escolha da abordagem </h3><br>  Como alternativa, voc√™ pode executar cada vers√£o necess√°ria com um pod separado no Kubernetes.  Essa op√ß√£o implica em um n√∫mero maior de objetos no cluster, que crescer√° com um aumento no n√∫mero de libera√ß√µes de werf est√°veis.  E isso, por sua vez, implica um servi√ßo mais complexo: cada vers√£o possui seu pr√≥prio servidor HTTP e com uma pequena carga.  Obviamente, isso implica custos mais altos para os recursos. <br><br>  N√≥s seguimos o caminho de <b>reunir todas as vers√µes necess√°rias em uma imagem</b> .  As est√°ticas compiladas de todas as vers√µes do site est√£o em um cont√™iner com o NGINX, e o tr√°fego para a Implanta√ß√£o correspondente √© feito pelo NGINX Ingress.  Uma estrutura simples - um aplicativo sem estado - facilita o dimensionamento da implanta√ß√£o (dependendo da carga) usando o pr√≥prio Kubernetes. <br><br>  Para ser mais preciso, coletamos duas imagens: uma para o circuito de produ√ß√£o e outra para o circuito de desenvolvimento.  Uma imagem adicional √© usada (lan√ßada) apenas no circuito dev juntamente com a principal e cont√©m a vers√£o do site a partir da confirma√ß√£o de revis√£o, e o roteamento entre eles √© realizado usando os recursos do Ingress. <br><br><h3>  artefatos e clone werf vs git </h3><br>  Como j√° mencionado, para gerar est√°tica do site para uma vers√£o espec√≠fica da documenta√ß√£o, voc√™ precisa construir alternando para a tag do reposit√≥rio correspondente.  Tamb√©m √© poss√≠vel fazer isso clonando o reposit√≥rio todas as vezes durante a montagem, selecionando as tags apropriadas na lista.  No entanto, essa √© uma opera√ß√£o que consome bastante recursos e, al√©m disso, requer a grava√ß√£o de instru√ß√µes n√£o triviais ... Outro ponto negativo grave - com essa abordagem, n√£o h√° como armazenar algo em cache durante a montagem. <br><br>  Aqui, o utilit√°rio werf vem em nosso aux√≠lio, o que implementa o <b>cache inteligente</b> e permite o uso de <a href="https://ru.werf.io/documentation/configuration/stapel_image/git_directive.html"><b>reposit√≥rios externos</b></a> .  O uso do werf para adicionar c√≥digo do reposit√≥rio acelerar√° significativamente a compila√ß√£o, pois  O werf essencialmente faz a clonagem de reposit√≥rio uma vez e, em seguida, <i>apenas</i> <code>fetch</code> se necess√°rio.  Al√©m disso, ao adicionar dados do reposit√≥rio, podemos selecionar apenas os diret√≥rios necess√°rios (no nosso caso, este √© o diret√≥rio <code>docs</code> ), o que reduzir√° significativamente a quantidade de dados adicionados. <br><br>  Como Jekyll √© uma ferramenta projetada para compilar est√°tica e n√£o √© necess√°ria na imagem final, seria l√≥gico compilar no <a href="https://ru.werf.io/documentation/configuration/stapel_artifact.html">artefato werf</a> e <b>importar apenas o resultado da compila√ß√£o</b> na imagem final. <br><br><h3>  Escrevendo werf.yaml </h3><br>  Ent√£o, decidimos que iremos compilar cada vers√£o em um artefato werf separado.  No entanto, <b>n√£o sabemos quantos desses artefatos ser√£o durante a montagem</b> ; portanto, n√£o podemos escrever uma configura√ß√£o de montagem fixa (a rigor, ainda podemos, mas n√£o ser√° completamente eficaz). <br><br>  O werf permite que voc√™ use <a href="https://ru.werf.io/documentation/configuration/introduction.html">Go-templates</a> no seu arquivo de configura√ß√£o ( <code>werf.yaml</code> ), e isso possibilita <b>gerar uma configura√ß√£o "on the fly",</b> dependendo dos dados externos (o que voc√™ precisa!).  Dados externos em nosso caso s√£o informa√ß√µes sobre vers√µes e libera√ß√µes, com base nas quais coletamos o n√∫mero necess√°rio de artefatos e, como resultado, obtemos duas imagens: <code>werf-doc</code> e <code>werf-dev</code> para rodar em caminhos diferentes. <br><br>  Dados externos s√£o passados ‚Äã‚Äãpor vari√°veis ‚Äã‚Äãde ambiente.  Aqui est√° sua composi√ß√£o: <br><br><ul><li>  <code>RELEASES</code> - uma linha com uma lista de lan√ßamentos e a vers√£o atual correspondente do werf, na forma de uma lista, separada por um espa√ßo, no formato <code>&lt;_&gt;%&lt;_&gt;</code> .  Exemplo: <code>1.0%v1.0.4-beta.20</code> </li><li>  <code>CHANNELS</code> - uma linha com uma lista de canais e a vers√£o atual correspondente do werf, na forma de uma lista com um espa√ßo de valores no formato <code>&lt;&gt;%&lt;_&gt;</code> .  Exemplo: <code>1.0-beta%v1.0.4-beta.20 1.0-alpha%v1.0.5-alpha.22</code> </li><li>  <code>ROOT_VERSION</code> - A vers√£o do werf release para exibi√ß√£o por padr√£o no site (nem sempre √© necess√°rio exibir a documenta√ß√£o para o n√∫mero de release mais alto).  Exemplo: <code>v1.0.4-beta.20</code> </li><li>  <code>REVIEW_SHA</code> - hash do commit de revis√£o a partir do qual voc√™ precisa coletar a vers√£o para o loop de teste. </li></ul><br>  Essas vari√°veis ‚Äã‚Äãser√£o preenchidas no IC do GitLab do pipeline e como exatamente √© descrito abaixo. <br><br>  Primeiro, por conveni√™ncia, definimos vari√°veis ‚Äã‚Äãde modelo Go em <code>werf.yaml</code> atribuindo valores a partir de vari√°veis ‚Äã‚Äãde ambiente: <br><br><pre> <code class="go hljs">{{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfVersions"</span></span> (cat (env <span class="hljs-string"><span class="hljs-string">"CHANNELS"</span></span>) (env <span class="hljs-string"><span class="hljs-string">"RELEASES"</span></span>) | splitList <span class="hljs-string"><span class="hljs-string">" "</span></span>) }} {{ $Root := . }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfRootVersion"</span></span> (env <span class="hljs-string"><span class="hljs-string">"ROOT_VERSION"</span></span>) }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfReviewCommit"</span></span> (env <span class="hljs-string"><span class="hljs-string">"REVIEW_SHA"</span></span>) }}</code> </pre> <br>  A descri√ß√£o do artefato para compilar a est√°tica da vers√£o do site geralmente √© a mesma para todos os casos que precisamos (incluindo a gera√ß√£o da vers√£o raiz, bem como a vers√£o do circuito dev).  Portanto, n√≥s o colocaremos em um bloco separado usando a fun√ß√£o <code>define</code> - para reutiliza√ß√£o subsequente com <code>include</code> .  Passaremos os seguintes argumentos para o modelo: <br><br><ul><li>  <code>Version</code> gerada por vers√£o (nome da tag); </li><li>  <code>Channel</code> - o nome do canal de atualiza√ß√£o para o qual o artefato √© gerado; </li><li>  <code>Commit</code> - hash de confirma√ß√£o se artefato for gerado para confirma√ß√£o de revis√£o; </li><li>  contexto. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Descri√ß√£o do Modelo de Artefato</b> <div class="spoiler_text"><pre> <code class="go hljs">{{- define <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> -}} {{- $Root := index . <span class="hljs-string"><span class="hljs-string">"Root"</span></span> -}} artifact: doc-{{ .Channel }} from: jekyll/builder:<span class="hljs-number"><span class="hljs-number">3</span></span> mount: - from: build_dir to: /usr/local/bundle ansible: install: - shell: | export PATH=/usr/jekyll/bin/:$PATH - name: <span class="hljs-string"><span class="hljs-string">"Install Dependencies"</span></span> shell: bundle install args: executable: /bin/bash chdir: /app/docs beforeSetup: {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .Commit }} - shell: echo <span class="hljs-string"><span class="hljs-string">"Review SHA - {{ .Commit }}."</span></span> {{- end }} {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> eq .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} - name: <span class="hljs-string"><span class="hljs-string">"releases.yml HASH: {{ $Root.Files.Get "</span></span>releases.yml<span class="hljs-string"><span class="hljs-string">" | sha256sum }}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ $Root.Files.Get <span class="hljs-string"><span class="hljs-string">"releases.yml"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /app/docs/_data/releases.yml {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} - file: path: /app/docs/_data/releases.yml state: touch {{- end }} - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/ - /app/ru_site/ - file: dest: /app/docs/pages_ru/cli state: link src: /app/docs/pages/cli - shell: | echo -e <span class="hljs-string"><span class="hljs-string">"werfVersion: {{ .Version }}\nwerfChannel: {{ .Channel }}"</span></span> &gt; /tmp/_config_additional.yml export PATH=/usr/jekyll/bin/:$PATH {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> and (ne .Version <span class="hljs-string"><span class="hljs-string">"review"</span></span>) (ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span>) }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> ( printf <span class="hljs-string"><span class="hljs-string">"v%s"</span></span> .Channel ) }} {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> .Channel }} {{- end }} jekyll build -s /app/docs -d /app/_main_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/tmp/_config_additional.yml jekyll build -s /app/docs -d /app/_ru_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/app/docs/_config_ru.yml,/tmp/_config_additional.yml args: executable: /bin/bash chdir: /app/docs git: - url: https:<span class="hljs-comment"><span class="hljs-comment">//github.com/flant/werf.git to: /app/ owner: jekyll group: jekyll {{- if .Commit }} commit: {{ .Commit }} {{- else }} tag: {{ .Version }} {{- end }} stageDependencies: install: ['docs/Gemfile','docs/Gemfile.lock'] beforeSetup: '**/*' includePaths: 'docs' excludePaths: '**/*.sh' {{- end }}</span></span></code> </pre> </div></div><br>  O nome do artefato deve ser exclusivo.  Podemos conseguir isso, por exemplo, adicionando o nome do canal (valor da vari√°vel <code>.Channel</code> ) como um sufixo para o nome do artefato: <code>artifact: doc-{{ .Channel }}</code> .  Mas voc√™ precisa entender que, ao importar de artefatos, ser√° necess√°rio consultar os mesmos nomes. <br><br>  Ao descrever um artefato, um recurso werf como <a href="https://ru.werf.io/documentation/configuration/stapel_image/mount_directive.html">mount √© usado</a> .  A montagem com o diret√≥rio de servi√ßo <code>build_dir</code> permite salvar o cache Jekyll entre as partidas do pipeline, o que <b>acelera bastante a reconstru√ß√£o</b> . <br><br>  Voc√™ tamb√©m deve ter notado o uso do arquivo <code>releases.yml</code> - este √© o arquivo YAML com os dados da libera√ß√£o solicitados no <a href="https://github.com/flant/werf">github.com</a> (o artefato obtido pela execu√ß√£o do pipeline).  √â necess√°rio ao compilar o site, mas no contexto do artigo, estamos interessados ‚Äã‚Äãno fato de que <b>apenas um artefato</b> , o <b>artefato</b> raiz da vers√£o do site <b>,</b> depende de seu estado (em outros artefatos n√£o √© necess√°rio). <br><br>  Isso √© implementado usando o operador condicional para modelos <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> go e ‚Äã‚Äão <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code>  <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> no <a href="https://ru.werf.io/documentation/reference/stages_and_images.html">palco</a> .  Isso funciona da seguinte maneira: ao montar um artefato para a vers√£o raiz (a vari√°vel <code>.Channel</code> √© <code>root</code> ), o hash do arquivo <code>releases.yml</code> afeta a assinatura de todo o est√°gio, pois √© um componente do nome do trabalho Ansible (par√¢metro <code>name</code> ).  Portanto, ao alterar o <b>conte√∫do do</b> arquivo <code>releases.yml</code> , o artefato correspondente ser√° reconstru√≠do. <br><br>  Preste aten√ß√£o tamb√©m ao trabalho com um reposit√≥rio externo.  Somente o diret√≥rio <code>/docs</code> √© inclu√≠do na imagem do artefato do <a href="">reposit√≥rio werf</a> e, dependendo dos par√¢metros passados, os dados da tag ou confirma√ß√£o necess√°ria s√£o adicionados imediatamente. <br><br>  Para usar o modelo de artefato para gerar uma descri√ß√£o de artefato das vers√µes transferidas de canais e libera√ß√µes, organizamos um loop na vari√°vel <code>.WerfVersions</code> em <code>werf.yaml</code> : <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> $VersionsDict._1 <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> $VersionsDict._0 <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{ end -}}</code> </pre> <br>  Porque  o loop ir√° gerar v√°rios artefatos (esperamos que sim), √© necess√°rio levar em considera√ß√£o o separador entre eles - a sequ√™ncia <code>---</code> (para obter mais informa√ß√µes sobre a sintaxe do arquivo de configura√ß√£o, consulte a <a href="https://ru.werf.io/documentation/configuration/introduction.html">documenta√ß√£o</a> ).  Conforme determinado anteriormente, quando voc√™ chama o modelo em um loop, passamos os par√¢metros de vers√£o, URL e contexto raiz. <br><br>  Da mesma forma, mas j√° sem um loop, chamamos o modelo de artefato para "casos especiais": para a vers√£o raiz, bem como a vers√£o do commit de revis√£o: <br><br><pre> <code class="go hljs">{{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> .WerfRootVersion <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"root"</span></span> <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .WerfReviewCommit }} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Commit"</span></span> .WerfReviewCommit <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} {{- end }}</code> </pre> <br>  Observe que o artefato para a confirma√ß√£o de revis√£o ser√° coletado apenas se a vari√°vel <code>.WerfReviewCommit</code> estiver <code>.WerfReviewCommit</code> . <br><br>  Os artefatos est√£o prontos - √© hora de importar! <br><br>  A imagem final, projetada para ser executada no Kubernetes, √© um NGINX regular, no qual o arquivo de configura√ß√£o do servidor <code>nginx.conf</code> e as est√°ticas dos artefatos s√£o adicionados.  Al√©m do artefato da vers√£o raiz do site, precisamos repetir o loop na vari√°vel <code>.WerfVersions</code> para importar artefatos das vers√µes dos canais e releases + observe a regra de nomenclatura do artefato que adotamos anteriormente.  Como cada artefato armazena vers√µes do site para dois idiomas, n√≥s os importamos para os locais fornecidos pela configura√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Descri√ß√£o da imagem final do werf-doc</b> <div class="spoiler_text"><pre> <code class="go hljs">image: werf-doc from: nginx:stable-alpine ansible: setup: - name: <span class="hljs-string"><span class="hljs-string">"Setup /etc/nginx/nginx.conf"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ .Files.Get <span class="hljs-string"><span class="hljs-string">".werf/nginx.conf"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /etc/nginx/nginx.conf - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/assets - /app/ru_site/assets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_main_site to: /app/main_site/v{{ $Channel }} before: setup {{ end -}} {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_ru_site to: /app/ru_site/v{{ $Channel }} before: setup {{ end -}}</code> </pre> </div></div><br>  A imagem adicional, que, juntamente com a imagem principal, √© lan√ßada no circuito de desenvolvimento, cont√©m apenas duas vers√µes do site: a vers√£o do commit de revis√£o e a vers√£o raiz do site (existem ativos gerais e, se voc√™ se lembrar, libera dados).  Assim, a imagem adicional da imagem principal diferir√° apenas na se√ß√£o de importa√ß√£o (e, √© claro, no nome): <br><br><pre> <code class="plaintext hljs">image: werf-dev ... import: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{- if .WerfReviewCommit }} - artifact: doc-review add: /app/_main_site to: /app/main_site/review before: setup - artifact: doc-review add: /app/_ru_site to: /app/ru_site/review before: setup {{- end }}</code> </pre> <br>  Como j√° mencionado acima, o artefato para a confirma√ß√£o de revis√£o ser√° gerado apenas quando o werf iniciar com a vari√°vel de ambiente <code>REVIEW_SHA</code> .  Seria poss√≠vel n√£o gerar uma imagem werf-dev, se n√£o <code>REVIEW_SHA</code> ambiente <code>REVIEW_SHA</code> , mas, para que a <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">limpeza de</a> imagem baseada em werf, <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">para que as</a> imagens do Docker funcionem para a imagem werf-dev, deixamos que seja coletada apenas com o artefato da vers√£o raiz (de qualquer forma, j√° montado), para simplificar a estrutura do oleoduto. <br><br>  Montagem est√° pronta!  Passamos para o CI / CD e nuances importantes. <br><br><h3>  Pipeline no IC do GitLab e recursos de montagem din√¢mica </h3><br>  Ao iniciar a montagem, precisamos definir as vari√°veis ‚Äã‚Äãde ambiente usadas no <code>werf.yaml</code> .  Isso n√£o se aplica √† vari√°vel REVIEW_SHA, que definiremos quando o pipeline for chamado a partir do gancho do GitHub. <br><br>  Geraremos os dados externos necess√°rios no script Bash <code>generate_artifacts</code> , que gerar√° dois artefatos do GitLab de pipeline: <br><br><ul><li>  arquivo <code>releases.yml</code> com dados da libera√ß√£o, </li><li>  arquivo <code>common_envs.sh</code> contendo vari√°veis ‚Äã‚Äãde ambiente para exporta√ß√£o. </li></ul><br>  Voc√™ encontrar√° o conte√∫do do arquivo <code>generate_artifacts</code> em nosso <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">reposit√≥rio de exemplo</a> .  A obten√ß√£o de dados n√£o √© o assunto do artigo, mas o arquivo <code>common_envs.sh</code> √© importante para n√≥s, porque  o trabalho de werf depende disso.  Um exemplo de seu conte√∫do: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> RELEASES=<span class="hljs-string"><span class="hljs-string">'1.0%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CHANNELS=<span class="hljs-string"><span class="hljs-string">'1.0-alpha%v1.0.7-1 1.0-beta%v1.0.7-1 1.0-ea%v1.0.6-4 1.0-stable%v1.0.6-4 1.0-rock-solid%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ROOT_VERSION=<span class="hljs-string"><span class="hljs-string">'v1.0.6-4'</span></span></code> </pre> <br>  Voc√™ pode usar a sa√≠da desse script, por exemplo, usando a fun√ß√£o Bash de <code>source</code> . <br><br>  E agora a parte divertida.  Para que os aplicativos de compila√ß√£o e implanta√ß√£o funcionem corretamente, voc√™ deve tornar o <code>werf.yaml</code> <b>mesmo</b> para pelo menos <b>um pipeline</b> .  Se essa condi√ß√£o n√£o for atendida, as assinaturas dos est√°gios que foram calculados durante a montagem e, por exemplo, a implanta√ß√£o, ser√£o diferentes.  Isso levar√° a um erro de implanta√ß√£o, pois  a imagem necess√°ria para implanta√ß√£o estar√° ausente. <br><br>  Em outras palavras, se durante a montagem da imagem do site as informa√ß√µes sobre releases e vers√µes forem uma, e no momento do release uma nova vers√£o for lan√ßada e as vari√°veis ‚Äã‚Äãde ambiente tiverem valores diferentes, a implanta√ß√£o falhar√°: afinal, o artefato da nova vers√£o ainda n√£o foi coletado. <br><br>  Se a gera√ß√£o do <code>werf.yaml</code> depender de dados externos (por exemplo, uma lista de vers√µes atuais, como no nosso caso), a composi√ß√£o e os valores desses dados dever√£o ser registrados no pipeline.  Isso √© especialmente importante se os par√¢metros externos mudarem com bastante frequ√™ncia. <br><br>  <b>Receberemos e capturaremos dados externos</b> no primeiro est√°gio do pipeline no <i>GitLab</i> ( <i>Prebuild</i> ) e os transferiremos ainda mais como um <b>artefato de IC do GitLab</b> .  Isso permitir√° que voc√™ inicie e reinicie as tarefas de pipeline (compila√ß√£o, implanta√ß√£o, limpeza) com a mesma configura√ß√£o no <code>werf.yaml</code> . <br><br>  O conte√∫do do est√°gio <i>Prebuild do</i> arquivo <i>.gitlab</i> - <i>ci.yml</i> : <br><br><pre> <code class="plaintext hljs">Prebuild: stage: prebuild script: - bash ./generate_artifacts 1&gt; common_envs.sh - cat ./common_envs.sh artifacts: paths: - releases.yml - common_envs.sh expire_in: 2 week</code> </pre> <br>  Ao capturar dados externos em um artefato, voc√™ pode construir e implantar usando os est√°gios de pipeline do IC do GitLab padr√£o: Build and Deploy.  Iniciamos o pipeline por ganchos do reposit√≥rio gerHub werf (ou seja, ao alterar o reposit√≥rio no GitHub).  Os dados para eles podem ser obtidos nas propriedades do projeto GitLab na se√ß√£o <i>Configura√ß√µes de CI / CD -&gt; gatilhos de pipeline</i> e, em seguida, criar o Webhook correspondente ( <i>Configura√ß√µes -&gt; Webhooks</i> ) no GitHub. <br><br>  O est√°gio de constru√ß√£o ter√° a seguinte apar√™ncia: <br><br><pre> <code class="plaintext hljs">Build: stage: build script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf build-and-publish --stages-storage :local except: refs: - schedules dependencies: - Prebuild</code> </pre> <br>  O GitLab adicionar√° dois artefatos do est√°gio <i>Pr√©</i> -constru√ß√£o √† fase de constru√ß√£o, portanto exportamos as vari√°veis ‚Äã‚Äãcom entrada preparada usando a <code>source common_envs.sh</code> .  Iniciamos a fase de montagem em todos os casos, exceto no lan√ßamento do pipeline dentro do prazo.  De acordo com o cronograma, o oleoduto ser√° lan√ßado para limpeza - n√£o precisamos construir neste caso. <br><br>  No est√°gio de implanta√ß√£o, descrevemos duas tarefas - separadamente para a implanta√ß√£o nos circuitos de produ√ß√£o e desenvolvimento, usando o modelo YAML: <br><br><pre> <code class="plaintext hljs">.base_deploy: &amp;base_deploy stage: deploy script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf deploy --stages-storage :local dependencies: - Prebuild except: refs: - schedules Deploy to Production: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: prod environment: name: production url: werf.io only: refs: - master except: variables: - $REVIEW_SHA refs: - schedules Deploy to Test: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: dev environment: name: test url: werf.test.flant.com except: refs: - schedules only: variables: - $REVIEW_SHA</code> </pre> <br>  As tarefas essencialmente diferem apenas indicando o contexto do cluster no qual o werf deve executar a implanta√ß√£o ( <code>WERF_KUBE_CONTEXT</code> ) e configurando as vari√°veis ‚Äã‚Äãde ambiente do contorno ( <code>environment.name</code> e <code>environment.url</code> ), que s√£o usadas nos modelos de gr√°fico Helm.  O conte√∫do dos modelos n√£o ser√° fornecido, porque  n√£o h√° nada interessante para este t√≥pico, mas voc√™ pode encontr√°-los no <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">reposit√≥rio do artigo</a> . <br><br><h3>  Toque final </h3><br>  Como as vers√µes werf s√£o lan√ßadas com bastante frequ√™ncia, novas imagens geralmente s√£o coletadas e o Docker Registry cresce constantemente.  Portanto, √© necess√°rio configurar a limpeza autom√°tica de imagens por pol√≠tica.  √â muito f√°cil de fazer. <br><br>  Para implementa√ß√£o, voc√™ precisar√° de: <br><br><ul><li>  Adicione uma etapa de purifica√ß√£o ao <code>.gitlab-ci.yml</code> ; </li><li>  Adicione tarefas de limpeza peri√≥dicas; </li><li>  Defina a vari√°vel de ambiente com token de acesso de grava√ß√£o. </li></ul><br>  Adicione o est√°gio de limpeza ao <code>.gitlab-ci.yml</code> : <br><br><pre> <code class="plaintext hljs">Cleanup: stage: cleanup script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - docker login -u nobody -p ${WERF_IMAGES_CLEANUP_PASSWORD} ${WERF_IMAGES_REPO} - werf cleanup --stages-storage :local only: refs: - schedules</code> </pre><br>  Quase todos n√≥s j√° vimos isso um pouco mais alto - apenas para a limpeza, √© necess√°rio primeiro fazer logon no Docker Registry com um token com direitos para excluir imagens no Docker Registry (o token de tarefa do GitLab CI emitido automaticamente n√£o possui esses direitos).  O token deve ser inserido no GitLab antecipadamente e seu valor deve ser especificado na vari√°vel de ambiente <code>WERF_IMAGES_CLEANUP_PASSWORD</code> projeto <i>(Configura√ß√µes de CI / CD -&gt; Vari√°veis)</i> . <br><br>  A adi√ß√£o de uma tarefa de limpeza com a programa√ß√£o necess√°ria √© feita em <i>CI / CD -&gt;</i> <i><br></i>  <i>Hor√°rios</i> <br><br>  √â isso: o projeto no Docker Registry n√£o crescer√° mais constantemente a partir de imagens n√£o utilizadas. <br><br>  No final da parte pr√°tica, lembro que as listagens completas do artigo est√£o dispon√≠veis no <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">Git</a> : <br><br><ul><li>  <a href="">.gitlab-ci.yml</a> ; </li><li>  <a href="">werf.yaml</a> . </li></ul><br><h2>  Resultado </h2><br><ol><li>  Temos uma estrutura de constru√ß√£o l√≥gica: um artefato por vers√£o. </li><li>  A montagem √© universal e n√£o requer altera√ß√µes manuais quando novas vers√µes do werf s√£o lan√ßadas: a documenta√ß√£o no site √© atualizada automaticamente. </li><li>  S√£o coletadas duas imagens para contornos diferentes. </li><li>  Funciona r√°pido porque  o armazenamento em cache √© usado ao m√°ximo - quando uma nova vers√£o do werf √© lan√ßada ou um gancho do GitHub √© chamado para uma confirma√ß√£o de revis√£o, apenas o artefato correspondente com uma vers√£o modificada √© reconstru√≠do. </li><li>  N√£o √© necess√°rio pensar em excluir imagens n√£o utilizadas: a limpeza da pol√≠tica werf manter√° a ordem no Docker Registry. </li></ol><br><h2>  Conclus√µes </h2><br><ul><li>  O uso do werf permite que o assembly trabalhe rapidamente, gra√ßas ao armazenamento em cache do pr√≥prio assembly e ao trabalhar com reposit√≥rios externos. </li><li>    Git-               . werf        ,    <code>fetch</code>    . </li><li>   Go-     <code>werf.yaml</code>   ,      . </li><li>    werf     ‚Äî   ,     pipeline. </li><li> werf    ,      . </li></ul><br><h2>  PS </h2><br>     : <br><br><ul><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/476320/">         Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/469541/">      werf  GitLab CI</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/468049/"> werf    Helm-</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/481306/"> werf 1.0 stable:    GitOps,   </a> ¬ª. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478690/">https://habr.com/ru/post/pt478690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478666/index.html">Placa de som USB no YM3812</a></li>
<li><a href="../pt478672/index.html">Teste e inicializa√ß√£o da IA: Entrevista com Adam Carmi (Applitools)</a></li>
<li><a href="../pt478680/index.html">Por que, e mais importante, para onde as pessoas v√£o da TI?</a></li>
<li><a href="../pt478684/index.html">Introdu√ß√£o ao SSD. Parte 2. Interface</a></li>
<li><a href="../pt478688/index.html">Como foi estudar Ci√™ncia de Dados em 2019</a></li>
<li><a href="../pt478692/index.html">Como o Java 8 √© suportado no Android</a></li>
<li><a href="../pt478694/index.html">Como recomendamos os cat√°logos mais recentes no cinema online ivi (+ c√≥digo Python)</a></li>
<li><a href="../pt478696/index.html">Como visitei o Urban Tech 2019. Relat√≥rio de eventos</a></li>
<li><a href="../pt478698/index.html">Fazemos um plano interativo do terreno em 15 minutos</a></li>
<li><a href="../pt478702/index.html">Truques de processamento m√©trico em Kapacitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>