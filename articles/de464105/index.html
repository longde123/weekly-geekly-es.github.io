<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≠ üëèüèº üÜô Native Commento-Server mit Docker Compose üë∏üèΩ üèä üôçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis: Dies ist eine √úbersetzung meines Beitrags (Englisch), die die Implementierung des Kommentarservers beschreibt, der auf derselben Site verwend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Native Commento-Server mit Docker Compose</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464105/"><p>  <em>Hinweis: Dies ist eine √úbersetzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meines Beitrags</a> (Englisch), die die Implementierung des Kommentarservers beschreibt, der auf derselben Site verwendet wird, auf der sich das Original befindet.</em> </p><br><blockquote>  TL; DR-Version: Ich habe die Commento-Serverkonfiguration entwickelt, die einfach und einfach im halbautomatischen Modus bereitgestellt werden kann.  Kopieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Repository</a> von GitHub in sich selbst und folgen Sie den Anweisungen in <a href="">README</a> . </blockquote><p>  Vor einiger Zeit wollte ich Disqus - das vielleicht h√§ufigste System zum Hinzuf√ºgen von Kommentaren zu Seiten - unwiderstehlich in ein freies und offenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commento</a> √§ndern. </p><br><h2 id="pochemu-imenno-commento">  Warum Commento? </h2><br><p>  Das Problem bei Disqus ist, wie bei vielen anderen "kostenlosen" Produkten, dass das Produkt in diesem Fall der Benutzer ist - das hei√üt Sie.  Dar√ºber hinaus ‚Äûbereichert‚Äú Disqus jede Seite, auf der es verwendet wird, mit Megabyte an Skripten und mehr als <em>hundert</em> zus√§tzlichen HTTP-Anforderungen. </p><br><p>  Au√üerdem werden in der kostenlosen Version Anzeigen geschaltet, mit denen Sie "nur" 9 US-Dollar pro Monat auszahlen k√∂nnen (Plus-Plan).  Dies allein reicht aus, um etwas Besseres finden zu wollen. </p><br><p>  Irgendwann bin ich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Beitrag</a> gesto√üen und habe herausgefunden, dass es einen kostenlosen Kommentarserver namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commento gibt</a> .  Durch einen gl√ºcklichen Zufall wurde Commento erst k√ºrzlich vollst√§ndig ge√∂ffnet - bevor es in zwei Versionen erh√§ltlich war: Free <em>Community</em> und Commercial <em>Enterprise</em> .  Dank seines Entwicklers Adhityaa Chandrasekar. </p><a name="habracut"></a><br><p>  Commento ist <em>um Gr√∂√üenordnungen</em> effizienter als Disqus, die typische Gr√∂√üe der zus√§tzlichen Last betr√§gt etwa <strong>11 KB</strong> , plus die Kommentare selbst nat√ºrlich.  Ungef√§hr die gleiche Situation mit den erforderlichen HTTP-Anforderungen. </p><br><p>  Ein weiteres Plus des Commento-Servers ist, dass er sehr schnell ist, da er in Go geschrieben ist. </p><br><p>  Nun, als Kirsche auf dem Kuchen hat er eine Menge Kommentare von Disqus, wovon k√∂nnte er sonst noch tr√§umen? </p><br><h2 id="varianty-ispolzovaniya-commento">  Anwendungsf√§lle f√ºr Commento </h2><br><p>  F√ºr nicht fortgeschrittene (technisch) Benutzer bietet Commento einen einsatzbereiten Cloud-Dienst auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">commento.io</a> .  Der Autor bietet Ihnen an, die monatliche Geb√ºhr selbst zu w√§hlen, sie darf jedoch "aus technischen Gr√ºnden" nicht unter 3 US-Dollar liegen. </p><br><p>  Herr Chandrasekar bietet auch gro√üz√ºgig ein kostenloses Konto auf Commento.io an, um ‚Äûnicht triviale Patches‚Äú f√ºr das Produkt zu erhalten. </p><br><p>  Nun, ich habe die dritte Option gew√§hlt: den Commento-Server selbst zu erh√∂hen.  In diesem Fall sind Sie von niemandem abh√§ngig (au√üer nat√ºrlich vom Hoster), und ich liebe die Unabh√§ngigkeit. </p><br><h2 id="trudnosti">  Schwierigkeiten </h2><br><p>  Ich bin ein gro√üer Fan von Docker-Containern und verwende h√§ufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Compose</a> , ein Tool zum Verwalten von Gruppen mehrerer verwandter Container.  Commento verf√ºgt √ºber ein gebrauchsfertiges Docker-Image in der GitLab-Containerregistrierung. </p><br><p>  Daher reifte die Entscheidung, Container zu verwenden, von selbst - aber zun√§chst mussten einige Dinge entschieden werden. </p><br><h3 id="trudnost-1-postgresql">  Schwierigkeit Nr. 1: PostgreSQL </h3><br><p>  F√ºr Commento ist eine relativ neue Version des PostgreSQL-Servers erforderlich. Leider werden keine anderen SQL-Server unterst√ºtzt. </p><br><p>  Nun, wir lassen immer noch alles in Containern laufen, also ist es ziemlich einfach. </p><br><h3 id="trudnost-2-net-podderzhki-https">  Schwierigkeit Nr. 2: Keine HTTPS-Unterst√ºtzung </h3><br><p>  Commento selbst ist ein Webserver, unterst√ºtzt jedoch nur das unsichere HTTP-Protokoll. </p><br><p>  Es ist zu beachten, dass diese Vorgehensweise heutzutage weit verbreitet ist: In diesem Fall ist der Server hinter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reverse-Proxy</a> versteckt, der auch das SSL-Offloading durchf√ºhrt.  Die Sache ist, dass SSL / HTTPS-Unterst√ºtzung in diesem Fall schlie√ülich in der Werft 2019 absolut notwendig ist und es sehr schwierig sein wird, Versuche zu versuchen, einen Benutzer unter Verwendung eines ungesicherten Internetprotokolls zu autorisieren. </p><br><p>  Ich habe mich f√ºr den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nginx-</a> Server entschieden. Erstens hatte ich betr√§chtliche Erfahrung damit, und zweitens ist er sehr schnell, wirtschaftlich und stabil.  Und ver√∂ffentlicht die offiziellen Builds von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-Images</a> . </p><br><p>  Die zweite Zutat im HTTPS-Rezept ist das SSL-Zertifikat f√ºr die Domain.  Ich bin EFF und Mozilla auf ewig dankbar, dass sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Encrypt</a> Certificate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Authority erstellt haben</a> , die jeden Monat Millionen kostenloser Zertifikate ausstellt. </p><br><p>  Let's Encrypt bietet auch ein kostenloses Befehlszeilenprogramm namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">certbot</a> , das das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrufen</a> und Aktualisieren eines Zertifikats erheblich vereinfacht.  Nun, und nat√ºrlich ein Docker-Image f√ºr ihn! </p><br><h3 id="trudnost-3-problema-kuricy-yayca-certbot">  Schwierigkeit Nr. 3: Certbot-H√ºhnerei-Problem </h3><br><p>  Aber dieser Trick ist schwieriger. </p><br><p>  Wir m√∂chten in der Konfiguration unseres Reverse-Proxys auf Nginx auf das SSL-Zertifikat verweisen, was bedeutet, dass es ohne Zertifikat einfach nicht gestartet werden kann.  Um <em>ein</em> SSL-Zertifikat f√ºr eine Domain zu erhalten, ben√∂tigen Sie gleichzeitig einen funktionierenden HTTP-Server, mit dem Let's Encrypt Ihren Besitz dieser Domain nachweist. </p><br><p>  Ich habe es geschafft, dieses Problem zu l√∂sen, und es scheint mir ziemlich elegant: </p><br><ol><li>  Zun√§chst wird ein ung√ºltiges Dummy-Zertifikat generiert, dessen einziger Zweck darin besteht, Nginx starten zu lassen. </li><li>  Nginx und certbot erhalten gemeinsam ein neues, jetzt g√ºltiges Zertifikat. </li><li>  Sobald das Zertifikat empfangen wurde, wechselt certbot in den ‚ÄûStandby-Modus‚Äú und wacht alle 12 Stunden auf, um zu √ºberpr√ºfen, ob es aktualisiert werden muss - gem√§√ü den Empfehlungen von Let's Encrypt. </li><li>  Wenn der Moment gekommen ist und das Zertifikat erneuert wurde, signalisiert certbot Nginx, neu zu starten. </li></ol><br><h3 id="trudnost-4-chto-to-dolzhno-sohranyatsya">  Schwierigkeit Nr. 4: Etwas muss erhalten bleiben </h3><br><p>  Ich vermute sehr, dass Sie m√∂chten, dass Benutzerkommentare nach einem Neustart oder einem Systemupdate gespeichert werden. </p><br><p>  Damit Let's Encrypt Sie nicht aufgrund zu h√§ufiger Anfragen sperrt, sollten Sie die erhaltenen Zertifikate f√ºr das gesamte Ablaufdatum aufbewahren. </p><br><p> Beide Punkte wurden in der vorgeschlagenen Konfiguration unter Verwendung der Volumes des Dockers gel√∂st, die von <em>systemd</em> beim ersten Start von Commento automatisch erstellt wurden.  Volumes werden als "extern" markiert, sodass Docker sie √ºberspringt, wenn Container mit <code>docker-compose down -v</code> . </p><br><h2 id="svodim-vsyo-voedino">  Bring alles zusammen </h2><br><p>  Jetzt k√∂nnen Sie sehen, wie alles zusammenarbeitet. </p><br><p>  Die folgende Abbildung zeigt die Interaktion und den Verkehr zwischen den vier Containern: </p><br><p><img src="https://habrastorage.org/webt/zl/kr/y3/zlkry3l9lxx8mfwzzlsnuvubi6a.png"></p><br><p>  Ich habe die <code>depends_on</code> Option Docker Compose <code>depends_on</code> um sicherzustellen, dass die Container in der richtigen Reihenfolge beginnen. </p><br><p>  Wenn Sie nur Ihren eigenen Commento-Server starten m√∂chten, k√∂nnen Sie den Rest des Artikels √ºberspringen und direkt zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code auf GitHub wechseln</a> . </p><br><p>  Nun, ich werde sp√§ter ausf√ºhrlicher auf diese Implementierung eingehen. </p><br><h2 id="kak-eto-vsyo-rabotaet">  Wie funktioniert das alles? </h2><br><h3 id="fayl-compose">  Datei erstellen </h3><br><p>  Wie Sie im Bild oben sehen k√∂nnen, besteht meine ‚ÄûKomposition‚Äú aus vier Diensten: </p><br><ol><li>  <code>certbot</code> - Dienstprogramm <code>certbot</code> von EFF </li><li>  <code>nginx</code> - Reverse Proxy, der SSL-Offloading implementiert </li><li>  <code>app</code> - Commento Server </li><li>  <code>postgres</code> - PostgreSQL-Datenbank </li></ol><br><p>  Die <a href=""><code>docker-compose.yml</code></a> enth√§lt Deklarationen des eigenen Docker-Netzwerks mit dem Namen <code>commento_network</code> und drei Volumes, von denen zwei extern sind ( <a href=""><code>docker-compose.yml</code></a> au√üerhalb von Compose erstellt werden m√ºssen): </p><br><ul><li>  <code>commento_postgres_volume</code> speichert PostgreSQL-Serverdaten f√ºr Commento: Benutzer, Moderatoren, Kommentare usw. </li><li>  <code>certbot_etc_volume</code> enth√§lt Zertifikate, die von <code>certbot</code> empfangen wurden. </li></ul><br><h3 id="nginx">  Nginx </h3><br><p>  Der Nginx-Container basiert auf einem einfachen offiziellen Image, das auf Alpine basiert, und verwendet das folgende Skript zum Ausf√ºhren: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait for the certificate file to arrive wait_for_certs() { echo 'Waiting for config files from certbot...' i=0 while [[ ! -f /etc/letsencrypt/options-ssl-nginx.conf ]]; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo 'No files after 10 seconds, aborting' &amp;&amp; exit 2 done } # Watches for a "reload flag" (planted by certbot container) file and reloads nginx config once it's there watch_restart_flag() { while :; do [[ -f /var/www/certbot/.nginx-reload ]] &amp;&amp; rm -f /var/www/certbot/.nginx-reload &amp;&amp; echo 'Reloading nginx' &amp;&amp; nginx -s reload sleep 10 done } # Wait for certbot wait_for_certs # Start "reload flag" watcher watch_restart_flag &amp; # Run nginx in the foreground echo 'Starting nginx' exec nginx -g 'daemon off;'</span></span></code> </pre> <br><ul><li>  Zeile <strong>3</strong> ( <em>ARRGHHH, Habr unterst√ºtzt die Anzeige von Zeilennummern im Code nicht - ca. Transl.</em> ) Ein Interrupt-Handler wird registriert, damit Nginx und der Hintergrund√ºberwachungsprozess die Arbeit erfolgreich abschlie√üen, wenn der Container stoppt. </li><li>  Zeile <strong>27</strong> ruft die <code>certbot</code> auf, die den Nginx-Startvorgang <code>certbot</code> , bis die vom <code>certbot</code> Container erstellten SSL-Konfigurationsdateien <code>certbot</code> .  Ohne dies w√ºrde Nginx den Start verweigern. </li><li>  Zeile <strong>30</strong> erstellt einen Hintergrundprozess, der regelm√§√üig alle zehn Sekunden das Vorhandensein einer Flag-Datei mit dem Namen <code>.nginx-reload</code> √ºberpr√ºft und Nginx anweist, die Konfiguration neu zu <code>.nginx-reload</code> , sobald sie <code>.nginx-reload</code> .  Diese Datei erstellt auch certbot, wenn das Zertifikat aktualisiert wird. </li><li>  Zeile <strong>34</strong> startet Nginx im normalen Modus.  In diesem Fall bedeutet <code>exec</code> , dass der aktuelle Shell-Prozess <em>durch</em> den Nginx-Prozess ersetzt wird. </li></ul><br><p>  Eine weitere wichtige Datei in diesem Bild ist die Konfiguration des virtuellen Commento-Servers, die Nginx dazu zwingt, HTTPS-Anforderungen an den <code>commento</code> weiterzuleiten: </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">443</span></span> ssl ipv6only=<span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">443</span></span> ssl; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/html; <span class="hljs-attribute"><span class="hljs-attribute">index</span></span> index.html index.htm index.nginx-debian.html; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://app:8080/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$http_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$proxy_add_x_forwarded_for</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/__DOMAIN__/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/__DOMAIN__/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="hljs-attribute"><span class="hljs-attribute">ssl_dhparam</span></span> /etc/letsencrypt/ssl-dhparams.pem; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /.well-known/acme-challenge/ { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/certbot; } <span class="hljs-comment"><span class="hljs-comment"># Redirect to HTTPS on port 80 location / { return 301 https://$host$request_uri; } }</span></span></code> </pre> <br><p>  Der erste Serverblock (Zeilen <strong>1-21</strong> ) beschreibt die Arbeit mit HTTPS und der Weiterleitungsregel.  Hier werden Let's Encrypt-Zertifikatdateien erw√§hnt (oder stattdessen verwendete Stubs). </p><br><p>  Die vom Server bereitgestellte Dom√§ne wird beim Erstellen des Images als Argument √ºbergeben.  Es ersetzt die Zeile <code>__DOMAIN__</code> in der Serverkonfiguration. </p><br><p>  Der zweite Block (Zeilen <strong>23-38</strong> ) ist die Konfiguration des HTTP-Servers, der vom Certbot zur Best√§tigung des Dom√§nenbesitzes verwendet wird (die sogenannte ‚ÄûACME-Herausforderung‚Äú).  Alle anderen Anfragen bewirken eine Umleitung √ºber HTTPS an die entsprechende Adresse. </p><br><h3 id="certbot">  certbot </h3><br><p>  Unser Certbot-Image basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Build</a> mit dem folgenden Skript: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait until nginx is up and running, up to 10 seconds wait_for_nginx() { echo 'Waiting for nginx...' i=0 while ! nc -z nginx 80 &amp;&gt;/dev/null; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo "nginx isn't online after 10 seconds, aborting" &amp;&amp; exit 4 done echo 'nginx is up and running' } # Check vars [[ -z "$DOMAIN" ]] &amp;&amp; echo "Environment variable 'DOMAIN' isn't defined" &amp;&amp; exit 2 [[ -z "$EMAIL" ]] &amp;&amp; echo "Environment variable 'EMAIL' isn't defined" &amp;&amp; exit 2 TEST="${TEST:-false}" # Check external mounts data_dir='/etc/letsencrypt' www_dir='/var/www/certbot' [[ ! -d "$data_dir" ]] &amp;&amp; echo "Directory $data_dir must be externally mounted" [[ ! -d "$www_dir" ]] &amp;&amp; echo "Directory $www_dir must be externally mounted" # If the config/certificates haven't been initialised yet if [[ ! -e "$data_dir/options-ssl-nginx.conf" ]]; then # Copy config over from the initial location echo 'Initialising nginx config' cp /conf/options-ssl-nginx.conf /conf/ssl-dhparams.pem "$data_dir/" # Copy dummy certificates mkdir -p "$data_dir/live/$DOMAIN" cp /conf/privkey.pem /conf/fullchain.pem "$data_dir/live/$DOMAIN/" # Wait for nginx wait_for_nginx # Remove dummy certificates rm -rf "$data_dir/live/$DOMAIN/" # Run certbot to validate/renew certificate test_arg= $TEST &amp;&amp; test_arg='--test-cert' certbot certonly --webroot -w /var/www/certbot -n -d "$DOMAIN" $test_arg -m "$EMAIL" --rsa-key-size 4096 --agree-tos --force-renewal # Reload nginx config touch /var/www/certbot/.nginx-reload # nginx config has been already initialised - just give nginx time to come up else wait_for_nginx fi # Run certbot in a loop for renewals while :; do certbot renew # Reload nginx config touch /var/www/certbot/.nginx-reload sleep 12h done</span></span></code> </pre> <br><p>  Ein kurzer √úberblick √ºber seine Linien: </p><br><ul><li>  Zeile <strong>3</strong> ist wie im vorherigen Skript f√ºr die regelm√§√üige Fertigstellung des Containers erforderlich. </li><li>  Die Zeilen <strong>17-19</strong> √ºberpr√ºfen die erforderlichen Variablen. </li><li>  Und in den Zeilen <strong>22-25</strong> - dass die Verzeichnisse, die f√ºr das Funktionieren von certbot erforderlich sind, korrekt bereitgestellt werden. </li><li>  Die Gabel folgt: <br><ul><li>  Die Zeilen <strong>30-50</strong> werden nur beim ersten Start des Containers ausgef√ºhrt: <br><ul><li>  Ein Dummy-Zertifikat wird kopiert, sodass Nginx normal gestartet werden kann. </li><li>  Nginx wartet unterdessen auf das Ende dieses Prozesses, wonach der Download fortgesetzt wird. </li><li>  Nach dem Start von Nginx leitet certbot den Prozess zum Abrufen eines g√ºltigen Zertifikats von Let's Encrypt ein. </li><li>  Und schlie√ülich wird, sobald das Zertifikat empfangen wurde, die <code>.nginx-reload</code> Datei erstellt, was Nginx darauf hinweist, dass es Zeit ist, die Konfiguration neu zu laden. </li></ul></li><li>  Zeile <strong>54</strong> wartet auf den Start von Nginx - falls bereits ein vollst√§ndiges Zertifikat verf√ºgbar ist. </li></ul></li><li>  Nach all dem (Zeilen <strong>58-63</strong> ) f√§hrt er alle 12 Stunden mit dem Zyklus fort, √ºberpr√ºft die Notwendigkeit, das Zertifikat zu erneuern, und signalisiert Nginx den Neustart. </li></ul><br><h3 id="commento-i-postgresql">  Commento und PostgreSQL </h3><br><p>  Die <code>postgres</code> und <code>postgres</code> Container verwenden die von den Entwicklern bereitgestellten Originalbilder ohne √Ñnderungen. </p><br><h3 id="servis-systemd">  Systemd Service </h3><br><p>  Das letzte Teil dieses Puzzles ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd</a> <code>commento.service</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einheitendatei</a> , f√ºr die Sie in <code>/etc/systemd/system/commento.service</code> einen Symlink <code>/etc/systemd/system/commento.service</code> damit sie zu einem guten Zeitpunkt beim Systemstart <code>/etc/systemd/system/commento.service</code> : </p><br><pre> <code class="plaintext hljs">[Unit] Description=Commento server [Service] TimeoutStopSec=30 WorkingDirectory=/opt/commento ExecStartPre=-/usr/bin/docker volume create commento_postgres_volume ExecStartPre=-/usr/bin/docker volume create certbot_etc_volume ExecStartPre=-/usr/local/bin/docker-compose -p commento down -v ExecStart=/usr/local/bin/docker-compose -p commento up --abort-on-container-exit ExecStop=/usr/local/bin/docker-compose -p commento down -v [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Zeilen: </p><br><ul><li>  Zeile <strong>6</strong> impliziert, dass der Projektcode in das Verzeichnis <code>/opt/commento</code> geklont wird - dies ist viel einfacher. </li><li>  In den Zeilen <strong>7 bis 8 werden</strong> externe Volumes erstellt, sofern dies noch nicht geschehen ist. </li><li>  In Zeile <strong>9</strong> werden die m√∂glichen Reste der vorherigen Container gel√∂scht.  Externe Volumes bleiben erhalten. </li><li>  Zeile <strong>10</strong> markiert den tats√§chlichen Start von Docker Compose.  Das <code>--abort-on-container-exit</code> gesamte Herde von Containern, wenn einer von ihnen <code>--abort-on-container-exit</code> .  Dank dessen wird systemd zumindest bewusst sein, dass der Dienst gestoppt wird. </li><li>  In Zeile <strong>11</strong> werden erneut Container, Netzwerke und Volumes bereinigt und gel√∂scht. </li></ul><br><h2 id="ishodnyy-kod">  Quellcode </h2><br><p>  Eine voll funktionsf√§hige Implementierung, die nur die Konfiguration von Variablen in <code>docker-compose.yml</code> , ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> verf√ºgbar.  Sie m√ºssen nur die in <a href="">README</a> beschriebenen Schritte sorgf√§ltig <a href="">ausf√ºhren</a> . </p><br><p>  Der Code unterliegt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Lizenz</a> . </p><br><p>  Vielen Dank f√ºr das Lesen zu diesem Ort, Kommentare sind herzlich willkommen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464105/">https://habr.com/ru/post/de464105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464093/index.html">Digitale Waren: Was tun, wenn ein Kunde in einem Jahr einen Kauf abholt?</a></li>
<li><a href="../de464095/index.html">Getter und Setter in Dart und Flutter</a></li>
<li><a href="../de464097/index.html">Die Evolution der Intelligenz: Warum Roboter Emotionen brauchen</a></li>
<li><a href="../de464099/index.html">VKScript-Sprachanalyse: JavaScript, oder?</a></li>
<li><a href="../de464103/index.html">OpenUNB-Entwurf eines nationalen IoT-Standards: kritische √úberpr√ºfung</a></li>
<li><a href="../de464107/index.html">Digitale Veranstaltungen in Moskau vom 19. bis 25. August</a></li>
<li><a href="../de464109/index.html">Weltraum-√úberschallfallschirme</a></li>
<li><a href="../de464111/index.html">Natas Web. Passage der CTF-Plattform zur Ausnutzung von Web-Schwachstellen</a></li>
<li><a href="../de464113/index.html">"CAD f√ºr alle, kostenlos, und lassen Sie niemanden los ..." oder die ersten Schritte bei der Programmierung von FreeCAD in Python</a></li>
<li><a href="../de464115/index.html">Wie man Freunde, Designer, Layouter und ‚ÄûFigma‚Äú mit einem Designsystem, einer Brechstange und einer Art Mutter ‚Ñ¢ zu Freunden macht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>