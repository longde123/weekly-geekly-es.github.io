<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèø ‚úäüèø üßê Shaders 3D para principiantes: efectos ü§òüèæ üçÅ ‚ùî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ La primera parte ] 

 Habiendo tratado los conceptos b√°sicos, en esta parte del art√≠culo implementamos efectos como contornos de objetos, floraci√≥n,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders 3D para principiantes: efectos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera parte</a> ] <br><br>  Habiendo tratado los conceptos b√°sicos, en esta parte del art√≠culo implementamos efectos como contornos de objetos, floraci√≥n, SSAO, desenfoque, profundidad de campo, pixelaci√≥n y otros. <br><br><h2>  Esquemas </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  Crear contornos alrededor de la geometr√≠a de la escena le da al juego un aspecto √∫nico que se asemeja a los c√≥mics o dibujos animados. <br><br><h3>  Material difuso </h3><br>  El sombreador de contorno necesita una textura de entrada para reconocer y colorear los bordes.  Los candidatos para tal textura entrante pueden ser un color difuso de los materiales, colores de texturas difusas, v√©rtices normales o incluso colores de mapas normales. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Este es un sombreador de fragmentos peque√±os que convierte el color difuso de un material de geometr√≠a en una textura de b√∫fer de cuadro.  Esta textura de color difusa del b√∫fer de cuadro ser√° la textura de entrada para el sombreador de ruta. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Esta es la textura del color difuso del material del b√∫fer de cuadros, que muestra los colores que configuramos en Blender.  El sombreador de contorno reconocer√° los bordes de la escena y los colorear√°. <br><br>  Cabe se√±alar que el color difuso de los materiales no funcionar√° si ciertas partes de la escena no tienen su propio color difuso del material. <br><br><h3>  Crear bordes </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  Crear bordes es similar a usar filtros de reconocimiento de bordes en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GIMP</a> . <br><br>  Todos los c√°lculos para esta t√©cnica de sombreado se realizan en un sombreador de fragmentos.  Para crear contornos para el sombreador de v√©rtices, es suficiente pasar cuatro v√©rtices de la malla rectangular a la salida para que se ajuste a la pantalla. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Antes de comenzar a reconocer los bordes, debe preparar la textura entrante, con la que trabajaremos.  Como la textura tiene un tama√±o de pantalla, podemos calcular las coordenadas UV, conociendo las coordenadas del fragmento y el tama√±o de la textura entrante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> se puede personalizar para adaptarse a su gusto.  Cuanto mayor es la separaci√≥n, m√°s gruesos son los bordes o l√≠neas. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  La t√©cnica de reconocimiento de bordes encuentra cambios en los colores de la textura entrante.  Centr√°ndose en el fragmento actual, utiliza la ventana de fragmentos 3x3 para encontrar los colores m√°s brillantes y oscuros de las nueve muestras.  Luego resta del brillo de un color al brillo de otro, obteniendo su diferencia. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Esta diferencia se usa en el canal alfa del color de salida.  Si no hay diferencia, entonces el borde o la l√≠nea no se dibuja.  Si hay una diferencia, entonces se dibuja el borde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Intenta experimentar con el valor umbral.  Ahora es cero.  Cualquier valor distinto de cero se convierte en un borde; este umbral se puede cambiar.  Esto es especialmente √∫til para texturas entrantes m√°s ruidosas con peque√±as diferencias.  En el caso de una textura entrante ruidosa, generalmente necesita crear contornos solo para grandes diferencias. <br><br><h3>  C√≥digo fuente </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-diffuse.frag</a> </li><li>  <a href="">esquema.frag</a> </li></ul><br><h2>  Niebla </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  La niebla (o neblina, como se llama en Blender) agrega niebla atmosf√©rica a la escena, creando misteriosas partes salientes suavizadas.  Las partes sobresalientes aparecen cuando parte de la geometr√≠a cae repentinamente en la pir√°mide de visibilidad de la c√°mara. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D tiene una estructura de datos conveniente que contiene todos los par√°metros de niebla, pero puede transferirlos a su sombreador manualmente. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  En el ejemplo de c√≥digo, se usa un modelo lineal para calcular el brillo de la niebla cuando se aleja de la c√°mara.  En cambio, puede usar el modelo exponencial.  El brillo de la niebla es cero antes o al comienzo de la niebla.  Cuando la posici√≥n del v√©rtice se acerca al final de la niebla, <code>fogIntensity</code> acerca a la unidad.  Para todos los v√©rtices despu√©s del final de la niebla, <code>fogIntensity</code> limita a 1 desde arriba. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  Seg√∫n el brillo de la niebla, mezclamos el color de la niebla con el color de salida.  A medida que <code>fogIntensity</code> acerca a la unidad, habr√° cada vez menos <code>outputColor</code> y m√°s y m√°s color de niebla.  Cuando <code>fogIntensity</code> alcanza la unidad, solo quedar√° el color de la niebla. <br><br><h3>  Niebla en los contornos </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  El Path Shader aplica niebla a los colores de los bordes para obtener una imagen m√°s hol√≠stica.  Si no hiciera esto, la niebla oscurecer√≠a la geometr√≠a de los contornos, lo que se ver√≠a extra√±o.  Sin embargo, todav√≠a crea contornos en los bordes m√°s exteriores de la geometr√≠a de la etapa con el molino, porque los bordes van m√°s all√° de la geometr√≠a, a donde no hay posiciones de v√©rtices. <br><br>  <code>positionTexture</code> es una textura de b√∫fer de cuadro que contiene las posiciones de los v√©rtices del espacio de vista.  Aprender√° sobre esto cuando implementemos el sombreador SSAO. <br><br><h3>  C√≥digo fuente </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">esquema.frag</a> </li></ul><br><h2>  Bloom </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Agregar flor a la escena puede crear una ilusi√≥n convincente del modelo de iluminaci√≥n.  Los objetos emisores de luz se vuelven m√°s convincentes, y los reflejos de luz reciben una cantidad adicional de brillo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Puede personalizar esta configuraci√≥n a su gusto.  La separaci√≥n aumenta el tama√±o del desenfoque.  Las muestras determinan la intensidad del desenfoque.  El umbral determina qu√© ser√° y no ser√° afectado por este efecto.  Cantidad controla la cantidad de salida de floraci√≥n. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Esta t√©cnica comienza pasando <code>samples</code> tama√±o de ventana a <code>samples</code> centradas en relaci√≥n con el fragmento actual.  Parece una ventana utilizada para crear caminos. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Este c√≥digo obtiene el color de la textura entrante y convierte los valores de rojo, verde y azul en un valor en escala de grises.  Si el valor en escala de grises es inferior al umbral, descarta este color y lo convierte en negro. <br><br>  Al pasar por todas las muestras dentro de la ventana, acumula todos sus valores como <code>result</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Una vez completada la colecci√≥n de muestras, divide la suma de las muestras de color por el n√∫mero de muestras tomadas.  El resultado es el color medio del fragmento en s√≠ y sus vecinos.  Al hacerlo para cada fragmento, obtenemos una imagen borrosa.  Este tipo de desenfoque se denomina desenfoque de cuadro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Aqu√≠ puede ver el proceso de ejecuci√≥n del algoritmo de floraci√≥n. <br><br><h3>  C√≥digo fuente </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Oclusi√≥n ambiental de espacio de pantalla (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO es uno de esos efectos que no sabes que existen, pero tan pronto como sabes que ya no puedes vivir sin ellos.  ¬°Puede convertir una escena mediocre en una incre√≠ble!  En escenas est√°ticas, la oclusi√≥n ambiental se puede hornear en la textura, pero para escenas m√°s din√°micas necesitamos un sombreador.  SSAO es una de las t√©cnicas de sombreado m√°s sofisticadas, pero una vez que lo descubras, te convertir√°s en un sombreador maestro. <br><br>  Tenga en cuenta que el t√©rmino "espacio de pantalla" en el t√≠tulo no es del todo correcto, porque no todos los c√°lculos se realizan en el espacio de pantalla. <br><br><h3>  Datos entrantes </h3><br>  El sombreador SSAO necesitar√° la siguiente entrada. <br><br><ul><li>  Vectores de posiciones de v√©rtices en el espacio de visualizaci√≥n. </li><li>  Vectores normales a los v√©rtices en el espacio de visualizaci√≥n. </li><li>  Vectores de muestra en espacio tangente. </li><li>  Vectores de ruido en el espacio tangente. </li><li>  La matriz de proyecci√≥n en la lente de la c√°mara. </li></ul><br><h3>  Posici√≥n </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  No es necesario almacenar posiciones de v√©rtices en la textura del b√∫fer de cuadro.  Podemos recrearlos desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">el b√∫fer de profundidad</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">la c√°mara</a> .  Estoy escribiendo una gu√≠a para principiantes, por lo que no utilizaremos esta optimizaci√≥n y nos pondremos manos a la obra de inmediato.  En su implementaci√≥n, puede usar f√°cilmente el b√∫fer de profundidad. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Si decide usar el b√∫fer de profundidad, as√≠ es como puede configurarlo en Panda3D. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Aqu√≠ hay un sombreador simple para representar las posiciones de v√©rtice en el espacio de visualizaci√≥n en una textura de b√∫fer de cuadro.  Una tarea m√°s dif√≠cil es ajustar la textura de la memoria intermedia de trama para que los componentes del vector de fragmento obtenido por √©l no se limiten al intervalo <code>[0, 1]</code> , y que cada uno tenga una precisi√≥n suficientemente alta (un n√∫mero suficientemente grande de bits).  Por ejemplo, si alg√∫n tipo de posici√≥n de v√©rtice interpolado es <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , entonces no puede guardarlo en la textura como <code>&lt;0.0, 0.0, 1.0&gt;</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Aqu√≠ hay un c√≥digo de ejemplo que prepara una textura de b√∫fer de marco para almacenar posiciones de v√©rtice.  Necesita 32 bits para rojo, verde, azul y alfa, por lo que desactiva la restricci√≥n de valores por el intervalo <code>[0, 1]</code> .  La llamada a <code>set_rgba_bits(32, 32, 32, 32)</code> establece el volumen de bits y deshabilita la restricci√≥n. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Aqu√≠ hay una llamada similar en OpenGL.  <code>GL_RGB32F</code> establece los bits y deshabilita la restricci√≥n. <br><br><blockquote>  Si el b√∫fer de color tiene una coma fija, entonces los componentes de los valores iniciales y finales, as√≠ como los √≠ndices de mezcla, antes de calcular la ecuaci√≥n de mezcla est√°n limitados a [0, 1] o [‚àí1, 1], respectivamente, para los b√∫feres de color normalizados y firmados normalizados sin signo.  Si el b√∫fer de color tiene un punto flotante, entonces no se cumple la restricci√≥n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Fuente</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Aqu√≠ ves las posiciones de los v√©rtices;  el eje y est√° arriba. <br><br>  Recuerde que Panda3D define el eje z como un vector que apunta hacia arriba, mientras que en OpenGL el eje y mira hacia arriba.  El sombreador de posici√≥n muestra las posiciones de los v√©rtices con una z hacia arriba, porque en Panda3D <br>  el par√°metro <code>gl-coordinate-system default</code> est√° configurado. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  Para la orientaci√≥n correcta de las muestras obtenidas en el sombreador SSAO, necesitamos las normales a los v√©rtices.  El c√≥digo de muestra genera varios vectores de muestreo distribuidos en el hemisferio, pero puede usar la esfera y resolver completamente el problema de la necesidad de valores normales. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Al igual que el sombreador de posici√≥n, el sombreador normal es muy simple.  Recuerde normalizar las normales a los v√©rtices y recuerde que est√°n en el espacio de visualizaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Las normales a los v√©rtices se muestran aqu√≠;  el eje y est√° arriba. <br><br>  Recuerde que Panda3D considera que el eje z es el vector ascendente y OpenGL al eje y.  El sombreador normal muestra las posiciones de v√©rtice con el eje z apuntando hacia arriba, porque el <code>gl-coordinate-system default</code> configurado en Panda3D. <br><br><h3>  Muestras </h3><br>  Para determinar el valor de oclusi√≥n ambiental para cualquier fragmento individual, necesitamos muestrear el √°rea circundante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  El c√≥digo de muestra genera 64 muestras aleatorias distribuidas en un hemisferio.  Estos <code>ssaoSamples</code> se pasar√°n al sombreador SSAO. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Si desea distribuir sus muestras a trav√©s de una esfera, cambie el intervalo del componente aleatorio z para que cambie de menos uno a uno. <br><br><h3>  El ruido </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Para cubrir bien el √°rea muestreada, necesitamos generar vectores de ruido.  Estos vectores de ruido pueden rotar muestras alrededor de la parte superior de la superficie. <br><br><h3>  Oclusi√≥n ambiental </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO cumple su tarea al muestrear el espacio de visualizaci√≥n alrededor del fragmento.  Cuantas m√°s muestras debajo de la superficie, m√°s oscuro ser√° el color del fragmento.  Estas muestras se encuentran en el fragmento e indican en la direcci√≥n general de lo normal al v√©rtice.  Cada muestra se utiliza para buscar una posici√≥n en la textura de la posici√≥n del b√∫fer de cuadros.  La posici√≥n devuelta se compara con la muestra.  Si la muestra est√° m√°s lejos de la c√°mara que la posici√≥n, entonces la muestra hacia el fragmento est√° ocluida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Aqu√≠ puede ver el espacio sobre la superficie muestreada para oclusi√≥n. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Como algunas otras t√©cnicas, el sombreador SSAO tiene varios par√°metros de control que se pueden cambiar para obtener la apariencia deseada.  El sesgo se agrega a la distancia de la muestra a la c√°mara.  Este par√°metro puede usarse para combatir las manchas.  el radio aumenta o disminuye el √°rea de cobertura del espacio muestral.  lowerRange y upperRange cambian el rango est√°ndar de la m√©trica del factor de <code>[0, 1]</code> a cualquier valor que seleccione.  Al aumentar el rango, puede aumentar el contraste. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Obtenemos la posici√≥n, el vector normal y aleatorio para su uso posterior.  Recuerde que en el ejemplo del c√≥digo, se crearon 16 vectores aleatorios.  Se selecciona un vector aleatorio en funci√≥n de la posici√≥n de la pantalla de los fragmentos actuales. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  Usando un vector aleatorio y un vector normal, recolectamos la matriz de la tangente, binormal y normal.  Necesitamos esta matriz para transformar los vectores de muestra del espacio tangente al espacio topogr√°fico. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Al tener una matriz, el sombreador puede recorrer todas las muestras del ciclo, restando el n√∫mero de muestras sin abrir. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  Usando la matriz, coloque la muestra al lado de la posici√≥n del v√©rtice / fragmento y escale por el radio. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  Usando la posici√≥n de la muestra en el espacio de visualizaci√≥n, la transformamos del espacio de visualizaci√≥n al espacio de recorte y luego al espacio UV. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  No olvide que los componentes del espacio de recorte est√°n en el rango de menos uno a uno, y las coordenadas UV est√°n en el rango de cero a uno.  Para convertir las coordenadas del espacio de recorte en coordenadas UV, multipl√≠quelas por un segundo y agregue un segundo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  Usando las coordenadas de desplazamiento UV obtenidas al proyectar la muestra 3D sobre la textura de posici√≥n 2D, encontramos el vector de posici√≥n correspondiente.  Esto nos lleva del espacio de visualizaci√≥n al espacio de recorte al espacio UV y luego de vuelta al espacio de visualizaci√≥n.  El sombreador ejecuta este bucle para determinar si hay alguna geometr√≠a detr√°s de la muestra, en la ubicaci√≥n de la muestra o en frente de la muestra.  Si la muestra se encuentra enfrente o en alguna geometr√≠a, entonces esta muestra simplemente no se tiene en cuenta en relaci√≥n con el fragmento superpuesto.  Si la muestra est√° detr√°s de alguna geometr√≠a, entonces esta muestra se tiene en cuenta en relaci√≥n con el fragmento superpuesto. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  Ahora agregue peso a esta posici√≥n muestreada seg√∫n lo lejos que est√© dentro o fuera del radio.  Luego, reste esta muestra de la m√©trica de oclusi√≥n porque supone que todas las muestras se solaparon antes del bucle. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Divida el n√∫mero de superposici√≥n por el n√∫mero de muestras para convertir el indicador de oclusi√≥n del intervalo <code>[0, NUM_SAMPLES]</code> al intervalo <code>[0, 1]</code> .  Cero significa oclusi√≥n completa, unidades significa que no hay oclusi√≥n.  Ahora asigne la m√©trica de oclusi√≥n al color del fragmento, y eso es todo. <br><br>  Tenga en cuenta que en el c√≥digo de ejemplo, al canal alfa se le asigna el valor alfa de la textura de posici√≥n del b√∫fer de cuadros para evitar la superposici√≥n de fondo. <br><br><h3>  Desenfoque </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  La textura del b√∫fer de cuadro SSAO es un poco ruidosa, por lo que debe desenfocarlo para suavizarlo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  El sombreador de desenfoque SSAO es un desenfoque de cuadro normal.  Al igual que el sombreador de flores, dibuja una ventana sobre la textura entrante y promedia cada fragmento con los valores de sus vecinos. <br><br>  Tenga en cuenta que los <code>parameters.x</code> es un par√°metro de separaci√≥n. <br><br><h3>  Color ambiental </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  El desaf√≠o final para SSAO est√° nuevamente en los c√°lculos de iluminaci√≥n.  Aqu√≠ vemos c√≥mo se encuentra la oclusi√≥n en el b√∫fer de textura SSAO de textura y se incluye en el c√°lculo de la luz ambiental. <br><br><h3>  C√≥digo fuente </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Profundidad de campo </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  La profundidad de campo tambi√©n es un efecto de este tipo, habiendo aprendido sobre cu√°l, no puedes vivir sin √©l.  Desde un punto de vista art√≠stico, puede usarlo para atraer la atenci√≥n del espectador a un objeto espec√≠fico.  Pero en el caso general, la profundidad de campo a costa de un peque√±o esfuerzo agrega una gran parte de realismo. <br><br><h3>  En foco </h3><br>  El primer paso es renderizar la escena completamente en foco.  Render√≠zalo a la textura del buffer de cuadro  Ser√° uno de los valores de entrada para el b√∫fer de profundidad de campo. <br><br><h3>  Fuera de foco </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  El segundo paso es desenfocar la escena como si estuviera completamente desenfocada.  Al igual que con Bloom y SSAO, puede usar el cuadro borroso.  Renderice esta escena desenfocada a la textura del b√∫fer de cuadro.  Ser√° otro valor de entrada para la profundidad del sombreador de campo. <br><br>  Tenga en cuenta que los <code>parameters.x</code> es un par√°metro de separaci√≥n. <br><br><h3>  Confusi√≥n </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Puede personalizar estas opciones a su gusto.  <code>focalLengthSharpness</code> afecta la <code>focalLengthSharpness</code> la escena a la distancia focal.  Cuanto m√°s peque√±a sea la <code>focalLengthSharpness</code> , m√°s desenfocada ser√° la escena a la distancia focal.  <code>blurRate</code> afecta la velocidad de desenfoque de la escena cuando se aleja de la distancia focal.  Cuanto m√°s peque√±a sea la <code>blurRate</code> , menos borrosa ser√° la escena al alejarse del punto de enfoque. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Necesitaremos colores enfocados y en una imagen desenfocada. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  Tambi√©n es posible que necesitemos la posici√≥n del v√©rtice en el espacio de visualizaci√≥n.  Puede volver a aplicar la textura de las posiciones desde el b√∫fer de trama que se utiliz√≥ para SSAO. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y aqu√≠ tiene lugar la confusi√≥n. </font><font style="vertical-align: inherit;">Cuanto m√°s cerca </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de uno, m√°s usar√° </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un valor de cero </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que este fragmento est√° completamente enfocado. </font><font style="vertical-align: inherit;">Con </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este fragmento queda completamente desenfocado.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profundidad de campo.</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posterizaci√≥n </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La posterizaci√≥n, o muestreo de color, es el proceso de reducir la cantidad de colores √∫nicos en una imagen. </font><font style="vertical-align: inherit;">Puedes usar este sombreador para darle al juego un aspecto c√≥mico o retro. </font><font style="vertical-align: inherit;">Si lo combinas con un contorno, obtienes un verdadero estilo de dibujos animados.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puedes experimentar con este par√°metro. </font><font style="vertical-align: inherit;">Cuanto m√°s grande sea, m√°s flores quedar√°n como resultado.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Necesitaremos el color entrante. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No he visto tal m√©todo de posterizaci√≥n. </font><font style="vertical-align: inherit;">Despu√©s de verificarlo, vi que crea resultados m√°s hermosos en comparaci√≥n con los m√©todos convencionales. </font><font style="vertical-align: inherit;">Para reducir la paleta de colores, primero convierta el color a un valor en escala de grises. </font><font style="vertical-align: inherit;">Discretamos el color vincul√°ndolo a uno de los niveles. </font><font style="vertical-align: inherit;">Calculamos la diferencia entre el valor muestreado en escala de grises y el valor no muestreado en escala de grises. </font><font style="vertical-align: inherit;">Agregue esta diferencia al color de entrada. </font><font style="vertical-align: inherit;">Esta diferencia es la cantidad por la cual el color debe aumentar / disminuir para lograr un valor discretizado en escala de grises.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No olvide asignar el valor del color de entrada al color del fragmento. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cel shading </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La posterizaci√≥n puede dar a una imagen la apariencia de sombreado cel, porque el sombreado cel es el proceso de discretizar colores difusos y difusos en tonos discretos. </font><font style="vertical-align: inherit;">Queremos utilizar solo colores difusos s√≥lidos sin detalles finos del mapa normal y un valor peque√±o </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixelizaci√≥n </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pixelaci√≥n de un juego en 3D puede darle una apariencia interesante, o puede ahorrarle tiempo que hubiera requerido la creaci√≥n manual de todos los p√≠xeles. </font><font style="vertical-align: inherit;">Comb√≠nalo con posterizaci√≥n para crear un verdadero look retro.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ajustar el tama√±o del p√≠xel usted mismo. </font><font style="vertical-align: inherit;">Cuanto m√°s grande sea, m√°s rugosa ser√° la imagen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta t√©cnica une cada fragmento al centro de su ventana de tama√±o de p√≠xel no superpuesta m√°s cercana. </font><font style="vertical-align: inherit;">Estas ventanas se alinean sobre la textura entrante. </font><font style="vertical-align: inherit;">Los fragmentos en el centro de la ventana determinan el color de otros fragmentos en su ventana.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de determinar la coordenada del fragmento deseado para usar, tome su color de la textura entrante y as√≠gnelo al color del fragmento. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afilar </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El efecto de nitidez (nitidez) aumenta el contraste en los bordes de la imagen. </font><font style="vertical-align: inherit;">Resulta √∫til cuando los gr√°ficos resultan demasiado suaves.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al cambiar el valor, podemos controlar la magnitud de la nitidez del resultado. </font><font style="vertical-align: inherit;">Si el valor es cero, la imagen no cambiar√°. </font><font style="vertical-align: inherit;">Con valores negativos, la imagen comienza a verse extra√±a.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los fragmentos adyacentes se multiplican por </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El fragmento actual se multiplica por </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los fragmentos vecinos est√°n en la parte superior, inferior, izquierda y derecha. </font><font style="vertical-align: inherit;">Despu√©s de multiplicar los vecinos y el fragmento actual por sus valores, se suma el resultado.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta cantidad es el color final del fragmento. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grano de la pel√≠cula </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El grano de la pel√≠cula (en peque√±as dosis, y no como en el ejemplo) puede agregar realismo, que es invisible hasta que se elimine este efecto. </font><font style="vertical-align: inherit;">Por lo general, estas son las imperfecciones que hacen que la imagen generada digitalmente sea m√°s convincente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que el grano de pel√≠cula suele ser el √∫ltimo efecto que se aplica al fotograma antes de mostrarse.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valor </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controla la visibilidad del grano de la pel√≠cula. </font><font style="vertical-align: inherit;">Cuanto mayor sea el valor, m√°s "nieve" en la imagen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brillo aleatorio </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este c√≥digo calcula el brillo aleatorio necesario para ajustar el valor. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proporcionado por</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D. </font><font style="vertical-align: inherit;">Un tiempo de cuadro es una marca de tiempo con informaci√≥n sobre cu√°ntos segundos han pasado desde el primer cuadro. </font><font style="vertical-align: inherit;">El c√≥digo de muestra lo utiliza para animar el grano de la pel√≠cula, que </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° diferente en cada fotograma.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para grano est√°tico, las pel√≠culas deben reemplazarse con un </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gran n√∫mero. </font><font style="vertical-align: inherit;">Para evitar ver patrones, puedes probar diferentes n√∫meros.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear puntos, o manchas de grano de pel√≠cula, se utilizan ambas coordenadas, y x, e y. </font><font style="vertical-align: inherit;">Si usa x, solo se mostrar√°n las l√≠neas verticales, si usa y, solo se mostrar√°n las l√≠neas horizontales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el c√≥digo, una coordenada se multiplica por otra para destruir la simetr√≠a diagonal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, puede deshacerse del multiplicador de coordenadas y obtener un efecto de lluvia completamente aceptable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que para animar el efecto de lluvia, multiplique la salida </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimente con las coordenadas x e y para cambiar la direcci√≥n de la lluvia. </font><font style="vertical-align: inherit;">Para una ducha descendente, deje solo la coordenada x.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado como una funci√≥n hash. </font><font style="vertical-align: inherit;">Las coordenadas del fragmento se combinan con valores de salida </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gracias a esto, aparece una propiedad conveniente: sean cuales sean los datos de entrada (grandes o peque√±os), el intervalo de salida estar√° en el rango de menos uno a uno.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en combinaci√≥n con </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n se utiliza como generador de n√∫meros pseudoaleatorios.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero mira la primera fila de n√∫meros, y luego la segunda. </font><font style="vertical-align: inherit;">Cada fila es determinista, pero el patr√≥n es menos notable en el segundo que en el segundo. </font><font style="vertical-align: inherit;">Por lo tanto, a pesar de que el resultado es </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinista, el patr√≥n se reconoce mucho m√°s d√©bil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ vemos c√≥mo el factor </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es primero 1, luego 10, luego 100 y luego 1000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medida que aumenta el multiplicador de los valores de salida, el </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patr√≥n se vuelve menos notable. </font><font style="vertical-align: inherit;">Por esta raz√≥n, el c√≥digo </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se multiplica por 10,000.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color del fragmento </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convierta las coordenadas del fragmento en coordenadas UV. </font><font style="vertical-align: inherit;">Usando estas coordenadas UV, buscamos el color de la textura para el fragmento actual.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambie el valor a un brillo aleatorio y agr√©guelo al color. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Establece el color del fragmento, y eso es todo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-grain.frag</font></font></a> </li></ul><br><h2>  Agradecimientos </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453692/">https://habr.com/ru/post/453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453676/index.html">Conexi√≥n a Windows a trav√©s de SSH como en Linux</a></li>
<li><a href="../453678/index.html">C√≥mo ver la reverberaci√≥n o la transmisi√≥n de video por sonido a trav√©s del agua - 2</a></li>
<li><a href="../453682/index.html">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd. Parte 2. C√≥digo del programa</a></li>
<li><a href="../453686/index.html">Semana de la seguridad 22: estad√≠sticas de amenazas, troyanos bancarios y haza√±as populares</a></li>
<li><a href="../453688/index.html">Java no solo es una empresa sangrienta, sino tambi√©n aplicaciones r√°pidas sensibles a la latencia</a></li>
<li><a href="../453694/index.html">Con√©ctese a Windows a trav√©s de SSH como en Linux</a></li>
<li><a href="../453696/index.html">Enlace angular de dos v√≠as, un poco m√°s de comprensi√≥n</a></li>
<li><a href="../453698/index.html">Informaci√≥n cu√°ntica en la conciencia cu√°ntica</a></li>
<li><a href="../453700/index.html">Lecciones sobre SDL 2: Lecci√≥n 1 - Hola, SDL 2</a></li>
<li><a href="../453706/index.html">C√≥mo pas√© el examen de certificaci√≥n de ingeniero de datos de Google Cloud Professional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>