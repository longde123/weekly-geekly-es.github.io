<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ®Ô∏è ‚ú°Ô∏è üë®üèø‚Äç‚úàÔ∏è Wir passen AutoMapper f√ºr uns an üë®üèΩ‚Äçüç≥ üéûÔ∏è ‚òÆÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AutoMapper ist eines der Hauptwerkzeuge f√ºr die Entwicklung von Unternehmensanwendungen. Daher m√∂chte ich beim Definieren der Entit√§tszuordnung so wen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir passen AutoMapper f√ºr uns an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444934/"><p>  AutoMapper ist eines der Hauptwerkzeuge f√ºr die Entwicklung von Unternehmensanwendungen. Daher m√∂chte ich beim Definieren der Entit√§tszuordnung so wenig Code wie m√∂glich schreiben. </p><br><p>  Ich mag keine Vervielf√§ltigung in MapFrom mit breiten Projektionen. </p><br><pre><code class="cs hljs">CreateMap&lt;Pupil, PupilDto&gt;() .ForMember(x =&gt; x.Name, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Name)) .ForMember(x =&gt; x.Surname, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Surname)) .ForMember(x =&gt; x.Age, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Age)) .ForMember(x =&gt; x.Number, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Number))</code> </pre> <br><p>  Ich w√ºrde es gerne so umschreiben: </p><br><pre> <code class="cs hljs">CreateMap&lt;Pupil, PupilDto&gt;() .From(x=&gt;x.IdentityCard.Passport).To()</code> </pre> <a name="habracut"></a><br><h4>  Projectto </h4><br><p>  AutoMapper kann Mapping sowohl im Speicher erstellen als auch in SQL √ºbersetzen. Es vervollst√§ndigt Expression und projiziert in DTO gem√§√ü den Regeln, die Sie in den Profilen beschrieben haben. </p><br><pre> <code class="cs hljs">EntityQueryable.Select(dtoPupil =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PupilDto() { Name = dtoPupil.Identity.Passport, Surname = dtoPupil.Identity.Passport.Surname})</code> </pre> <br><p>  80% der Zuordnung, die ich schreiben muss, ist die Zuordnung, die Expression from IQueryble vervollst√§ndigt. </p><br><p>  Es ist sehr bequem: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ActionResult&lt;IEnumerable&lt;PupilDto&gt;&gt; GetAdultPupils(){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _context.Pupils .Where(x=&gt;x.Identity.Passport.Age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; ...) .ProjectTo&lt;PupilDto&gt;().ToList(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  In einem deklarativen Stil haben wir eine Abfrage f√ºr die Pupils-Tabelle erstellt, Filter hinzugef√ºgt, in das gew√ºnschte DTO projiziert und an den Client zur√ºckgegeben, damit Sie alle Lesemethoden einer einfachen CRUD-Schnittstelle schreiben k√∂nnen. All dies wird auf Datenbankebene durchgef√ºhrt. </p><br><p>  Es ist wahr, dass solche Aktionen bei ernsthaften Anwendungen die Kunden wahrscheinlich nicht zufrieden stellen. </p><br><h4>  Nachteile AutoMapper'a </h4><br><p>  1) Es ist sehr ausf√ºhrlich, bei "breiter" Zuordnung m√ºssen Sie Regeln schreiben, die nicht in eine Codezeile passen. </p><br><p>  Profile wachsen und werden zu Archiven von Code, der einmal geschrieben wird und sich nur √§ndert, wenn Namen umgestaltet werden. </p><br><p>  2) Wenn Sie die Zuordnung gem√§√ü der Konvention verwenden, geht der Name verloren <br>  Eigenschaften in DTO: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PupilDto</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  Pupil       IdentityCard // IdentityCard     Passport public string IdentityCardPassportName { get; set; } public string IdentityCardPassportSurname { get; set; } }</span></span></code> </pre> <br><p>  3) Mangelnde Typensicherheit </p><br><p>  1 und 2 sind unangenehme Momente, aber Sie k√∂nnen sie ertragen, aber mit der mangelnden Typensicherheit bei der Registrierung ist es bereits schwieriger zu ertragen, dies sollte nicht kompiliert werden: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Name - string // Age - int ForMember(x =&gt; x.Age, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Name)</span></span></code> </pre> <br><p>  Wir m√∂chten Informationen √ºber solche Fehler in der Kompilierungsphase und nicht zur Laufzeit erhalten. </p><br><p>  Verwenden von Erweiterungs-Wrappern, um diese Punkte zu entfernen. </p><br><h4>  Einen Wrapper schreiben </h4><br><p>  Warum sollte die Registrierung so geschrieben werden? </p><br><pre> <code class="cs hljs">CreateMap&lt;Pupil, PupilDto&gt;() .ForMember(x =&gt; x.Name, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Name)) .ForMember(x =&gt; x.Surname, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Surname)) .ForMember(x =&gt; x.Age, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Age)) .ForMember(x =&gt; x.House, s =&gt; s.MapFrom(x =&gt; x.Address.House)) .ForMember(x =&gt; x.Street, s =&gt; s.MapFrom(x =&gt; x.Address.Street)) .ForMember(x =&gt; x.Country, s =&gt; s.MapFrom(x =&gt; x.Address.Country)) .ForMember(x =&gt; x.Surname, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Age)) .ForMember(x =&gt; x.Group, s =&gt; s.MapFrom(x=&gt;x.EducationCard.StudyGroup.Number))</code> </pre><br><p>  So viel pr√§gnanter: </p><br><pre> <code class="cs hljs">CreateMap&lt;Pupil,PupilDto&gt;() <span class="hljs-comment"><span class="hljs-comment">//    // PassportName = Passport.Name, PassportSurname = Passport.Surname .From(x =&gt; x.IdentityCard.Passport).To() // House,Street,Country -   .From(x =&gt; x.Address).To() //    -  DTO,  -  .From(x =&gt; x.EducationCard.Group).To((x =&gt; x.Group,x =&gt; x.Number));</span></span></code> </pre> <br><p>  Die <em>To-</em> Methode akzeptiert Tupel, wenn Sie Zuordnungsregeln angeben m√ºssen </p><br><p>  IMapping &lt;TSource, TDest&gt; ist die Schnittstelle des Autoherstellers, in der die ForMember, ForAll () -Methoden definiert sind. Alle diese Methoden geben dies zur√ºck (Fluent Api). </p><br><p>  Wir werden den Wrapper zur√ºckgeben, um uns an die Expression from From-Methode zu erinnern </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MapperExpressionWrapper&lt;TSource, TDest, TProjection&gt; From&lt;TSource, TDest, TProjection&gt; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IMappingExpression&lt;TSource, TDest&gt; mapping, Expression&lt;Func&lt;TSource, TProjection&gt;&gt; expression) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapperExpressionWrapper&lt;TSource, TDest, TProjection&gt;(mapping, expression);</code> </pre> <br><p>  Jetzt wird der Programmierer, der die From-Methode geschrieben hat, sofort die √úberladung der <em>To-</em> Methode sehen, wodurch wir ihm die API mitteilen. In solchen F√§llen k√∂nnen wir alle Reize der Erweiterungsmethoden erkennen. Wir haben das Verhalten erweitert, ohne Schreibzugriff auf die Autos zu haben </p><br><h4>  Wir typisieren </h4><br><p>  Das Implementieren einer typisierten <em>To-</em> Methode ist komplizierter. </p><br><p>  Versuchen wir, diese Methode zu entwerfen. Wir m√ºssen sie so weit wie m√∂glich in Teile zerlegen und die gesamte Logik anderer Methoden herausnehmen.  Stimmen Sie sofort zu, dass wir die Anzahl der Tupelparameter auf zehn beschr√§nken. </p><br><p>  Wenn in meiner Praxis eine √§hnliche Aufgabe auftritt, schaue ich sofort in Richtung Roslyn. Ich habe keine Lust, viele der gleichen Methoden zu schreiben und Copy Paste auszuf√ºhren. Es ist einfacher, sie zu generieren. </p><br><p>  In diesem Generikum wird uns helfen.  Es ist erforderlich, 10 Methoden mit einer unterschiedlichen Anzahl von Generika und Parametern zu generieren </p><br><p>  Die erste Ann√§herung an das Projektil war etwas anders. Ich wollte die R√ºckgabetypen von Lambdas (int, string, boolean, DateTime) einschr√§nken und keine universellen Typen verwenden. </p><br><p>  Die Schwierigkeit besteht darin, dass wir selbst f√ºr 3 Parameter 64 verschiedene √úberladungen generieren m√ºssen und bei Verwendung von generischen nur 1: </p><br><pre> <code class="cs hljs">IMappingExpression&lt;TSource, TDest&gt; To&lt;TSource, TDest, TProjection,T,T1, T2, T3&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt; mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) arg0, (Expression&lt;Func&lt;TDest, T1&gt;&gt;, Expression&lt;Func&lt;TProjection, T1&gt;&gt;) arg1, (Expression&lt;Func&lt;TDest, T2&gt;&gt;, Expression&lt;Func&lt;TProjection, T2&gt;&gt;) arg2, (Expression&lt;Func&lt;TDest, T3&gt;&gt;, Expression&lt;Func&lt;TProjection, T3&gt;&gt;) arg3) { ... }</code> </pre> <br><p>  Dies ist jedoch nicht das Hauptproblem. Wir generieren den Code, es wird einige Zeit dauern und wir werden alle erforderlichen Methoden erhalten. </p><br><p>  Das Problem ist anders. ReSharper nimmt nicht so viele √úberlastungen auf und weigert sich einfach zu arbeiten. Sie verlieren die Intelligenz und laden die IDE. </p><br><p>  Wir implementieren eine Methode, die ein Tupel ben√∂tigt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IMappingExpression&lt;TSource, TDest&gt; To &lt;TSource, TDest, TProjection, T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt; mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) arg0) { <span class="hljs-comment"><span class="hljs-comment">//    RegisterByConvention(mapperExpressionWrapper); //    expreession RegisterRule(mapperExpressionWrapper, arg0); //  IMappingExpression,     //   extension  return mapperExpressionWrapper.MappingExpression; }</span></span></code> </pre> <br><p>  Lassen Sie uns zun√§chst pr√ºfen, welche Eigenschaftenzuordnung gem√§√ü Konvention gefunden werden kann. Dies ist eine ziemlich einfache Methode. F√ºr jede Eigenschaft im DTO suchen wir nach dem Pfad in der urspr√ºnglichen Entit√§t.  Methoden m√ºssen reflexiv aufgerufen werden, da Sie ein typisiertes Lambda ben√∂tigen und dessen Typ von der Requisite abh√§ngt. </p><br><p>  Es ist unm√∂glich, ein Lambda vom Typ Ausdruck &lt;Func &lt;TSource, Objekt &gt;&gt; zu registrieren. Dann ordnet AutoMapper alle DTO-Eigenschaften dem Typ Objekt zu </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RegisterByConvention&lt;TSource, TDest, TProjection&gt;( MapperExpressionWrapper&lt;TSource, TDest, TProjection&gt; mapperExpressionWrapper) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> properties = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TDest).GetProperties().ToList(); properties.ForEach(prop =&gt; { <span class="hljs-comment"><span class="hljs-comment">// mapperExpressionWrapper.FromExpression = x=&gt;x.Identity.Passport // prop.Name = Name // ruleByConvention Expression&lt;Func&lt;Pupil,string&gt;&gt; x=&gt;x.Identity.Passport.Name var ruleByConvention = _cachedMethodInfo .GetMethod(nameof(HelpersMethod.GetRuleByConvention)) .MakeGenericMethod(typeof(TSource), typeof(TProjection), prop.PropertyType) .Invoke(null, new object[] {prop, mapperExpressionWrapper.FromExpression}); if (ruleByConvention == null) return; // mapperExpressionWrapper.MappingExpression.ForMember(prop.Name, s =&gt; s.MapFrom((dynamic) ruleByConvention)); }); }</span></span></code> </pre> <br><p>  <em>RegisterRule</em> empf√§ngt ein Tupel, das die Zuordnungsregeln definiert. Es muss darin "verbunden" sein <br>  FromExpression und Ausdruck werden an das Tupel √ºbergeben. </p><br><p>  Dies wird uns helfen. Expression.Invoke, EF Core 2.0 unterst√ºtzte es nicht, sp√§tere Versionen begannen zu unterst√ºtzen.  Damit k√∂nnen Sie eine "Lambd-Komposition" erstellen: </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;Pupil,StudyGroup&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = x=&gt;x.EducationCard.StudyGroup; Expression&lt;Func&lt;StudyGroup,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; @<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> = x=&gt;x.Number; <span class="hljs-comment"><span class="hljs-comment">//invoke = x=&gt;x.EducationCard.StudyGroup.Number; var composition = Expression.Lambda&lt;Func&lt;Pupil, string&gt;&gt;( Expression.Invoke(@for,from.Body),from.Parameters.First())</span></span></code> </pre><br><p>  <em>RegisterRule-</em> Methode: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RegisterRule&lt;TSource, TDest, TProjection, T (MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt; mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) rule) { <span class="hljs-comment"><span class="hljs-comment">//rule = (x=&gt;x.Group,x=&gt;x.Number) var (from, @for) = rule; //      @for = (Expression&lt;Func&lt;TProjection, T&gt;&gt;) _interpolationReplacer.Visit(@for); //mapperExpressionWrapper.FromExpression = (x=&gt;x.EducationCard.StudyGroup) var result = Expression.Lambda&lt;Func&lt;TSource, T&gt;&gt;( Expression.Invoke(@for, mapperExpressionWrapper.FromExpression.Body), mapperExpressionWrapper.FromExpression.Parameters.First()); var destPropertyName = from.PropertiesStr().First(); // result = x =&gt; Invoke(x =&gt; x.Number, x.EducationCard.StudyGroup) //  ,  result = x=&gt;x.EducationCard.StudyCard.Number mapperExpressionWrapper.MappingExpression .ForMember(destPropertyName, s =&gt; s.MapFrom(result)); }</span></span></code> </pre> <br><p>  Die <em>To-</em> Methode ist so konzipiert, dass sie beim Hinzuf√ºgen von Tupelparametern einfach erweitert werden kann.  Wenn Sie den Parametern ein weiteres Tupel hinzuf√ºgen, m√ºssen Sie einen weiteren generischen Parameter hinzuf√ºgen und die <em>RegisterRule-</em> Methode f√ºr den neuen Parameter aufrufen. </p><br><p>  Ein Beispiel f√ºr zwei Parameter: </p><br><pre> <code class="cs hljs">IMappingExpression&lt;TSource, TDest&gt; To&lt;TSource, TDest, TProjection, T, T1&gt; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt;mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) arg0, (Expression&lt;Func&lt;TDest, T1&gt;&gt;, Expression&lt;Func&lt;TProjection, T1&gt;&gt;) arg1) { RegisterByConvention(mapperExpressionWrapper); RegisterRule(mapperExpressionWrapper, arg0); RegisterRule(mapperExpressionWrapper, arg1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapperExpressionWrapper.MappingExpression; }</code> </pre> <br><p>  Wir verwenden <em>CSharpSyntaxRewriter</em> . Dies ist ein Besucher, der durch die Knoten des Syntaxbaums geht.  Wir nehmen eine Methode mit <em>To</em> mit einem Argument als Basis und f√ºgen einen generischen Parameter hinzu und rufen <em>RegisterRule auf</em> ; </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitMethodDeclaration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodDeclarationSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     To if (node.Identifier.Value.ToString() != "To") return base.VisitMethodDeclaration(node); // returnStatement = return mapperExpressionWrapper.MappingExpression; var returnStatement = node.Body.Statements.Last(); //beforeReturnStatements: //[RegisterByConvention(mapperExpressionWrapper), // RegisterRule(mapperExpressionWrapper, arg0)] var beforeReturnStatements = node.Body.Statements.SkipLast(1); //   RegisterRule  returStatement var newBody = SyntaxFactory.Block( beforeReturnStatements.Concat(ReWriteMethodInfo.Block.Statements) .Concat(new[] {returnStatement})); //     return node.Update( node.AttributeLists, node.Modifiers, node.ReturnType, node.ExplicitInterfaceSpecifier, node.Identifier, node.TypeParameterList.AddParameters (ReWriteMethodInfo.Generics.Parameters.ToArray()), node.ParameterList.AddParameters (ReWriteMethodInfo.AddedParameters.Parameters.ToArray()), node.ConstraintClauses, newBody, node.SemicolonToken); }</span></span></code> </pre> <br><p>  Die <em>ReWriteMethodInfo</em> enth√§lt die generierten Syntaxbaumknoten, die Sie hinzuf√ºgen m√ºssen.  Danach erhalten wir eine Liste von 10 Objekten vom Typ MethodDeclarationSyntax (ein Syntaxbaum, der eine Methode darstellt). </p><br><p>  Im n√§chsten Schritt nehmen wir die Klasse, in der die Vorlagenmethode <em>To</em> liegt, und schreiben alle neuen Methoden mit einem anderen Besucher hinein, in dem wir VisitClassDeclatation neu definieren. </p><br><p>  Mit der <em>Update-</em> Methode k√∂nnen Sie einen vorhandenen Baumknoten bearbeiten, unter der Haube alle √ºbergebenen Argumente durchlaufen und, wenn sich mindestens eines vom urspr√ºnglichen unterscheidet, einen neuen Knoten erstellen. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitClassDeclaration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ClassDeclarationSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//todo refactoring it return node.Update( node.AttributeLists, node.Modifiers, node.Keyword, node.Identifier, node.TypeParameterList, node.BaseList, node.ConstraintClauses, node.OpenBraceToken, new SyntaxList&lt;MemberDeclarationSyntax&gt;(ReWriteMethods), node.CloseBraceToken, node.SemicolonToken); }</span></span></code> </pre> <br><p>  Am Ende erhalten wir einen SyntaxNode - eine Klasse mit hinzugef√ºgten Methoden, schreiben den Knoten in eine neue Datei. Jetzt haben wir die <em>To-</em> Methode √ºberladen, die 1 bis 10 Tupel und eine viel pr√§zisere Zuordnung ben√∂tigt. </p><br><h4>  Expansionspunkt </h4><br><p>  Betrachten wir AutoMapper als etwas mehr.  Der abfragbare Anbieter kann nicht viele Abfragen analysieren, und ein bestimmter Teil dieser Abfragen kann anders umgeschrieben werden.  Hier kommt AutoMapper ins Spiel. Die Erweiterung ist ein Erweiterungspunkt, an dem wir unsere eigenen Regeln hinzuf√ºgen k√∂nnen. </p><br><p>  Wir werden den Besucher aus dem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel verwenden, der</a> die Zeichenfolgeninterpolation durch Verkettung in der <em>RegusterRule-</em> Methode ersetzt. Infolgedessen werden alle Ausdr√ºcke, die die Zuordnung von der Entit√§t definieren, durch diesen Besucher geleitet, <em>sodass nicht</em> jedes Mal <em>ReWrite aufgerufen werden</em> muss. Dies ist kein Allheilmittel zu verwalten ist eine Projektion, aber es macht das Leben trotzdem einfacher. </p><br><p>  Wir k√∂nnen auch eine bequeme Erweiterung hinzuf√ºgen, zum Beispiel f√ºr die Zuordnung nach Bedingung: </p><br><pre> <code class="cs hljs">CreateMap&lt;Passport,PassportDto&gt;() .ToIf(x =&gt; x.Age, x =&gt; x &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>, x =&gt; <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Age}</span></span></span><span class="hljs-string">"</span></span>, x =&gt; <span class="hljs-string"><span class="hljs-string">"Adult"</span></span>)</code> </pre> <br><p>  Die Hauptsache ist, nicht damit zu spielen und keine komplexe Logik auf die Anzeigeebene zu √ºbertragen <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444934/">https://habr.com/ru/post/de444934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444924/index.html">Das erste WIAD in Moskau: wie es lief und wor√ºber sie sprachen</a></li>
<li><a href="../de444926/index.html">Design Digest: Kreativer Leiter, Produktivit√§t und das Headset der Wahrheit</a></li>
<li><a href="../de444928/index.html">95% des angek√ºndigten Handelsvolumens von Bitcoin erwiesen sich als F√§lschung</a></li>
<li><a href="../de444930/index.html">Sie krochen Github</a></li>
<li><a href="../de444932/index.html">Wie man die Prinzipien der Entwicklung der SOLID-Architektur nicht versteht</a></li>
<li><a href="../de444936/index.html">Firmware ZXHN H118N von Dom.ru ohne L√∂ten und Programmierer</a></li>
<li><a href="../de444938/index.html">N√ºtzliche und nicht sehr √∂ffentliche Dienste</a></li>
<li><a href="../de444940/index.html">Tipps und Tricks zur digitalen Forensik: So verbinden Sie ein Encase-Image mit der virtuellen Maschine</a></li>
<li><a href="../de444942/index.html">Als ich die legend√§re Schule 42 besuchte: ‚ÄûPool‚Äú, Katzen und das Internet statt Lehrer</a></li>
<li><a href="../de444944/index.html">Als ich die legend√§re Schule 42 besuchte: "Pool", Katzen und das Internet statt Lehrer. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>