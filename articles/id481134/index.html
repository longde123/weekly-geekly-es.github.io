<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸš€ â›½ï¸ ğŸ¡ Bagaimana mengevaluasi kapasitas layanan dan tidak jatuh di bawah beban ğŸ“¦ â™’ï¸ ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cepat atau lambat, setiap layanan yang berkembang harus mengevaluasi kemampuan teknisnya. Berapa banyak pengunjung yang bisa kami layani? Berapa kapas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana mengevaluasi kapasitas layanan dan tidak jatuh di bawah beban</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/481134/"><img src="https://habrastorage.org/webt/-s/kl/8y/-skl8ysedkaeho-x6lw7-laelwi.png"><br><br>  Cepat atau lambat, setiap layanan yang berkembang harus mengevaluasi kemampuan teknisnya.  Berapa banyak pengunjung yang bisa kami layani?  Berapa kapasitas sistem?  Sudahkah kami mencapai batas dan tidak akan jatuh jika kami menarik beberapa ribu pengguna lagi?  Berapa banyak sumber daya komputasi tambahan yang dianggarkan untuk tahun depan untuk memenuhi rencana pertumbuhan? <br><br>  Jawaban dapat diperoleh secara analitis dengan menjawab pertanyaan kepada pengembang / DevOps / SRE / admin yang berpengalaman.  Keandalan penilaian tergantung pada sejumlah besar faktor: mulai dari langkah mengisi sistem dengan fungsionalitas dan grafik hubungan antara komponen-komponen dan berakhir dengan waktu yang dihabiskan pakar dalam lalu lintas.  Semakin kompleks sistem, semakin banyak keraguan dalam kecukupan penilaian analitis. <br><br>  Nama saya Maxim Kupriyanov, selama lima tahun sekarang saya telah bekerja di Yandex.Market.  Hari ini saya akan memberi tahu para pembaca Habr bagaimana kami belajar untuk mengevaluasi kapasitas layanan kami dan apa yang terjadi. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/dj/-4/ho/dj-4hoqd3ddi5lpwrokluke77ok.png"><br><br><h2>  Kami pergi ke posisi itu </h2><br>  Struktur komponen Pasar agak rumit, jadi kami memutuskan untuk mengevaluasi kapasitas hanya layanan terbesar dan termahal dalam penskalaan.  Selain itu, jumlah permintaan harian untuk mereka harus jelas tergantung pada ukuran audiens harian Pasar (pengguna aktif harian, DAU).  Kenapa tepatnya dari DAU?  Karena analis, membuat ramalan selama berbulan-bulan dan bertahun-tahun ke depan, selalu menghitung ukuran audiens di masa depan, dan kami akan mengambil keuntungan dari keadaan yang menyenangkan ini. <br><br>  Sekarang mari kita bicara tentang yang tanpanya mustahil membangun penilaian objektif: tentang metrik layanan.  Jika jumlah permintaan layanan tergantung pada DAU, maka kita pasti membutuhkan metrik "permintaan per detik" (permintaan per detik, RPS).  Selain itu, untuk menilai kualitas layanan, Anda perlu mengetahui persentase kesalahan dan waktu respons (waktu permintaan).  Kesalahan akan dianggap sebagai respons dengan kode HTTP 500 atau lebih tinggi.  Kesalahan dari rentang 4xx adalah sisi klien dan dalam sistem yang biasanya berfungsi biasanya tidak mengatakan apa-apa tentang masalah layanan.  Mengenai waktu, di sini lazim untuk menghitung dan menyimpan persentil ke-80, 95, 99, dan 99,9 kali respons, tetapi rangkaian tertentu mungkin sedikit berbeda dari layanan ke layanan. <br><br>  Jadi, kami memiliki metrik frekuensi permintaan, persentase kesalahan, dan sekumpulan persentil waktu respons.  Dan kita juga tahu layanan DAU untuk setiap hari dan untuk periode mendatang (dalam bentuk perkiraan).  Mengingat bahwa pola rata-rata perilaku pengguna tidak berubah terlalu banyak dari hari ke hari, mari kita katakan yang berikut: mengetahui RPS dalam periode paling aktif hari kerja (RPS puncak), kami dapat memprediksi RPS puncak untuk periode mendatang, dengan ketentuan kami memiliki perkiraan DAU.  Dan sebaliknya: jika kita tahu berapa banyak permintaan per detik yang dapat ditahan sistem tanpa melanggar perjanjian tentang waktu tanggapan dan persentase kesalahan, maka kita dapat memperkirakan berapa banyak audiens yang dapat kita layani, yaitu, kita tahu kapasitas sistem. <br><br>  Yah, kami memutuskan tugas: untuk memperbaiki timing tanggapan dan persentase kesalahan dalam bentuk perjanjian dan menemukan RPS maksimum yang dapat ditahan oleh sistem dalam kondisi ini.  Bagaimana kita memutuskan? <br><br><img src="https://habrastorage.org/webt/wf/zk/ea/wfzkeajjy8urgrmv0xib56c9nj8.png"><br><br><h2>  Kami menembak sasaran </h2><br>  Berikut ini adalah pendekatan klasik untuk menyelesaikan masalah: kami mengumpulkan situs uji, mengambil log sistem akses dari lingkungan produksi, membuat kartrid mereka dan memecat sistem, meningkatkan frekuensi permintaan, hingga situs menunjukkan penurunan signifikan dalam pengaturan waktu tanggapan dan / atau kesalahan.  Pada titik ini, kami menghentikan dan memperbaiki frekuensi permintaan (RPS yang sama).  Kemenangan  Bagaimanapun caranya.  Dan inilah alasannya: <br><br><ul><li>  situs pengujian, sebagai suatu peraturan, tidak identik dengan platform di bawah layanan di lingkungan produksi; </li><li>  kode layanan berubah setiap hari, atau bahkan lebih sering; </li><li>  eksperimen dapat memengaruhi beban; </li><li>  keparahan permintaan pengguna tergantung pada waktu hari dan kondisi lainnya; </li><li>  layanan modern jarang bekerja secara terpisah, lebih sering mereka membuat subqueries ke layanan lain, dan ini harus diperhitungkan entah bagaimana. </li></ul><br>  Peningkatan: kami akan memecat layanan secara otomatis setiap hari, mengumpulkan kartrid dari majalah pada jam sibuk.  Dan agar tidak menyia-nyiakan sumber daya di lokasi pengujian, kami akan mulai membayar komponen yang menarik bagi kami pada saat yang bersamaan.  Kedengarannya rumit dan tidak menyelesaikan semua masalah.  Tapi opsi apa lagi yang ada? <br><br><img src="https://habrastorage.org/webt/sb/ub/zp/sbubzp0dbuxhrpqtdxt6fichhqk.png"><br><br><h2>  Simulasikan kenyataan </h2><br>  Ide umumnya adalah ini: kami menyalin bagian dari lalu lintas dari penyeimbang ke situs, tempat kami mengumpulkan analog penuh dari lingkungan produksi dalam miniatur dan, menyesuaikan volume lalu lintas yang disalin, kami mulai mencari titik degradasi.  Idenya indah, dan kami di Market melakukan ini untuk menguji fungsionalitas baru dan membandingkan perilaku versi baru dengan yang lama.  Rekan saya, Eugene, <a href="https://habr.com/ru/company/yandex/blog/475848/">membicarakan hal ini</a> secara mendetail - lihat bagian tentang kelompok bayangan.  Tetapi ada kesulitan yang jelas juga: <br><br><ul><li>  masalah berinteraksi dengan komponen eksternal tidak terpecahkan, karena sangat mahal untuk membuat salinan dari seluruh lingkungan produksi; </li><li>  log permintaan dari sistem cermin dapat secara tidak sengaja bercampur dengan log dari lingkungan produksi, yang berarti bahwa perlu untuk membangun suatu sistem dengan menandai lalu lintas cermin sehingga kemudian dapat ditemukan dan dibersihkan; </li><li>  permintaan biasanya dicerminkan baik secara penuh atau sebagai persentase dari total, dan keakuratan tersebut tidak sesuai dengan kami (tetapi ini dapat diselesaikan, kami sedang bekerja ke arah ini). </li></ul><br>  Secara umum, imitasi produksi adalah pendekatan yang sangat bagus dan menjanjikan, tetapi sangat mahal dan dengan keterbatasan yang signifikan. <br><br><img src="https://habrastorage.org/webt/bh/pd/-8/bhpd-89lwirxbq9ywgv73803qqo.png"><br><br><h2>  Pengujian langsung dalam produksi </h2><br>  Dan akhirnya kami sampai pada kelezatannya.  Untuk setiap komponen yang diuji, kami menaikkan contoh terpisah dalam produksi, frekuensi permintaan yang diatur dari penyeimbang dengan akurasi tinggi.  Terakhir kali, <a href="https://habr.com/ru/company/yandex/blog/475848/">pembaca bertanya kepada kami</a> : "Apakah HAProxy cukup untuk Anda?  Apakah ada kebutuhan untuk menulis sesuatu milik Anda sendiri? "  Jadi, ini adalah kasus yang sangat langka ketika itu tidak cukup dan saya harus menulis. <br><br>  Pada saat yang sama, ada layanan terpisah yang memonitor dengan ketat metrik instance yang dimuat dan, ketika indikator mendekati nilai kritis, ia menutup katup pada penyeimbang, mengurangi frekuensi permintaan.  Jika layanan bekerja dalam batas yang dapat diterima, katup, sebaliknya, terbuka.  Tentu saja, ambang batas waktu dan kesalahan saat memuat layanan langsung terasa lebih konservatif (biasanya sebesar 5-10%) daripada di tempat pelatihan, karena kami tidak ingin memperburuk interaksi dengan pengguna.  Jadi, instance yang dimuat selalu berfungsi hingga batasnya.  Kami memperbaiki indikator ini.  Dan kemudian kita memiliki aritmatika: kita tahu jumlah inti layanan yang dimuat setiap saat, kita tahu DAU kemarin.  Dari ini, kami mempertimbangkan opsi daur ulang, cadangan kapasitas dan perilaku sistem saat menonaktifkan satu atau lokasi lain.  Semua ini diletakkan di dasar di mana grafik yang indah dibangun.  Berdasarkan data ini, ketika kapasitas turun di bawah ambang batas, peringatan dipicu. <br><br><h2>  Mari kita lihat grafiknya </h2><br><img src="https://habrastorage.org/webt/lt/nb/pa/ltnbpanor5tjwa-ljrej4darzcm.png"><br><br>  Ini adalah bagaimana kami mengontrol arus lalu lintas ke contoh yang diuji.  Langkahnya dapat berupa kelipatan 1 RPS.  Pada grafik, sebagai ilustrasi, kami memodelkan pendakian dengan interval tiga menit: pertama, dari 650 ke 1K RPS dengan peningkatan 50, dan kemudian dari 200 hingga 1K RPS dengan peningkatan 100. Mari saya ingatkan Anda, ini adalah lalu lintas pengguna nyata yang menerima jawaban oleh pelanggan. <br><br><img src="https://habrastorage.org/webt/yl/hp/ma/ylhpma60p6keqxgzmsshgvqs1dm.png"><br><br>  Ini menunjukkan RPS untuk tiga contoh: satu di bawah beban dan dua kontrol.  Subjek secara artifisial menetapkan batas atas 600 RPS.  Layanan mungkin lebih, tetapi menjadi terlalu tidak stabil dan tergantung pada pengaruh eksternal.  Jelas terlihat bahwa pada paruh pertama permintaan layanan, rata-rata, lebih berat dan mesin virtual tidak dapat mencapai kapasitas puncaknya dalam kondisi yang dapat diterima, tetapi menjelang malam, semuanya kembali normal.  Semburan dan kelalaian pada bagan adalah contoh restart untuk meletakkan rilis dan pembaruan lainnya (mereka semua sedang diseimbangkan, tidak ada yang terluka).  Dan penyesuaian RPS selangkah demi selangkah pada subjek uji hanyalah karya algoritma yang mencari batas kemungkinan. <br><br><img src="https://habrastorage.org/webt/3y/du/mw/3ydumwukuqrnergvj0li5mqxary.png"><br><br>  Frekuensi permintaan layanan dan beban yang satu instance dapat tahan terlihat jelas. <br><br><img src="https://habrastorage.org/webt/hy/jj/mt/hyjjmtgnuwgdrkla6_k42za5x_c.png"><br><br>  Dan di sini kita menghitung ulang semuanya dalam persen pemanfaatan.  Grafik menunjukkan bahwa layanan dimuat cukup berat dan ketika salah satu lokasi dimatikan, ada risiko untuk pergi ke SLA.  Tapi sekarang semuanya baik-baik saja: sumber daya telah ditambahkan ke layanan, daur ulang telah kembali ke batas yang dapat diterima. <br><br>  Dengan demikian, pengujian beban dalam produksi memungkinkan Anda untuk dengan cepat mengevaluasi kapasitas sistem dan memperkirakan konsumsi sumber daya untuk periode mendatang.  Pada saat yang sama, sistem ini sebenarnya tidak menambah pengeluaran yang cukup besar dan Anda dapat bekerja dengan aman dengan layanan-layanan stateful, karena kami tidak menghasilkan traffic baru, tetapi hanya mendistribusikan secara akurat salah satunya.  Dan akhirnya: untuk bekerja, sebagai suatu peraturan, tidak diperlukan untuk mengubah kode dari sistem eksperimental itu sendiri, yang memungkinkan pengujian bahkan aplikasi warisan. <br><br><img src="https://habrastorage.org/webt/bn/fe/bd/bnfebdjggyt-wbi914qf_z9dcnu.png"><br><br><h2>  Renungkan </h2><br>  Metodologi ini belum bekerja di Pasar selama lebih dari satu tahun, dan kami dapat berbagi pengamatan dan rekomendasi: <br><br><ul><li>  Di sebelah instance yang dimuat, harus ada satu kontrol biasa, dan lebih disukai steam, karena degradasi sering terjadi bukan karena instance kelebihan beban, tetapi karena masalah umum dengan layanan secara keseluruhan. </li><li>  Teknik ini hanya berfungsi dengan baik pada komponen yang bebannya lebih tinggi dari ratusan permintaan per detik untuk suatu lokasi.  Alasannya cukup sederhana: kita perlu memuat instance yang diuji dan satu atau dua kontrol.  Jika tidak ada lalu lintas yang cukup, kami tidak akan mencapai kejenuhan atau kami tidak akan dapat membandingkan dengan jujur.  Dan jika batas RPS per instance sangat kecil, maka langkah minimum mengubah frekuensi permintaan menjadi 1 RPS mungkin terlalu kasar. </li><li>  Lebih baik untuk menguji front dan backend di lokasi yang berbeda, sehingga artefak backend pengujian beban tidak mempengaruhi estimasi kapasitas depan. </li><li>  Ketika kami menganalisis waktu respons dan mencari tanda-tanda degradasi, kami biasanya mengambil agregat lima menit dan menghitung median agar tidak bereaksi terhadap semburan acak. </li><li>  Alasan utama bahwa instance yang dimuat dari layanan macet adalah ruang disk untuk file log (log).  Mereka selalu melupakannya. </li><li>  Masuk ke disk I / O-load dari server-web adalah alasan yang sangat umum untuk pemburukan waktu, bahkan pada SSD.  Selalu nyalakan buffering, rekaman asinkron, dan yang lainnya, hanya untuk tidak menunggu sampai rekaman berakhir. </li><li>  Beban malam tidak bersifat indikatif, karena permintaan rata-rata lebih berat karena bagian robot yang lebih besar.  Oleh karena itu, untuk memperkirakan kapasitas, lebih baik untuk memperbaiki kisaran dari waktu cahaya konvensional hari itu, dan pada malam hari hanya untuk mengurangi aliran permintaan jika tanda-tanda degradasi muncul. </li><li>  Persentil ke-99 dari timing tanggapan tidak berguna untuk estimasi kapasitas, karena jaminan ketersediaan jaringan jarang melebihi 99%. </li><li>  Mulai jadwal waktu dan catat rilis layanan dan acara penting lainnya.  Ini membantu untuk menemukan apa yang menyebabkan penurunan kapasitas. </li><li>  Dalam analisis terperinci tentang penyebab degradasi, pelacakan juga berguna: header marker ditambahkan ke setiap permintaan layanan, yang bergerak dari depan ke backend terakhir dan memasukkan semua log.  Dengan cara ini Anda dapat melacak seluruh jalur permintaan dan memahami apa yang menyebabkan keterlambatan. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481134/">https://habr.com/ru/post/id481134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481120/index.html">Di mana dan bagaimana server tepi diterapkan?</a></li>
<li><a href="../id481122/index.html">PostgreSQL Antipatterns: meneruskan set dan pilihan ke SQL</a></li>
<li><a href="../id481124/index.html">Kiat untuk menulis kode dokumentasi diri</a></li>
<li><a href="../id481126/index.html">Serikat programmer? Jangan katakan sandal saya</a></li>
<li><a href="../id481130/index.html">TOP12 Penemuan Ilmiah Interdisipliner 2019</a></li>
<li><a href="../id481138/index.html">Orang-orang ini menciptakan kecerdasan buatan - 4 cerita spesialis AI dan ML</a></li>
<li><a href="../id481140/index.html">Lembar cheat format file data Python</a></li>
<li><a href="../id481142/index.html">Qt QJSEngine Halo dunia</a></li>
<li><a href="../id481146/index.html">Pendaftar lain memberikan blok terakhir dari alamat IPv4</a></li>
<li><a href="../id481148/index.html">Masalah fisika yang tidak biasa mengembangkan pemikiran ilmiah (untuk anak sekolah)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>