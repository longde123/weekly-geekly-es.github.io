<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙈 🍷 🧦 Membuat hook kucing di Unity. Bagian 1 🙄 🚁 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kait kucing menambah mekanisme yang menyenangkan dan menarik ke gim ini. Anda dapat menggunakannya untuk bergerak melewati level, bertarung di arena, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat hook kucing di Unity. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414887/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/348/a3e/e5d/348a3ee5d95a10273c8bc644e3dbc7d9.gif" alt="gambar"></div><br>  Kait kucing menambah mekanisme yang menyenangkan dan menarik ke gim ini.  Anda dapat menggunakannya untuk bergerak melewati level, bertarung di arena, dan mendapatkan item.  Namun terlepas dari kesederhanaan yang tampak, fisika manajemen tali dan penciptaan perilaku realistis bisa jadi menantang! <br><br>  Di bagian pertama tutorial ini, kami menerapkan sistem hook-cat dua dimensi kami sendiri dan mempelajari yang berikut: <br><br><ul><li>  Buat sistem yang bertujuan. </li><li>  Gunakan penyaji garis dan sambungan jarak untuk membuat tali. </li><li>  Kami akan mengajarkan tali untuk membungkus benda-benda permainan. </li><li>  Hitung sudut ayunan pada tali dan tambahkan kekuatan ke arah itu. </li></ul><br><blockquote>  <em>Catatan</em> : tutorial ini ditujukan untuk pengguna mahir dan berpengalaman, dan tidak mencakup topik seperti menambahkan komponen, membuat skrip GameObject baru, dan sintaksis C #.  Jika Anda perlu meningkatkan keterampilan Unity Anda, lihat tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memulai Penggunaan dengan Unity</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Script Unity kami</a> .  Karena <em>DistanceJoint2D</em> digunakan dalam tutorial ini, Anda juga harus melihat melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joint Fisika di Unity 2D</a> , dan hanya kemudian kembali ke tutorial ini. </blockquote><a name="habracut"></a><br><h2>  Mulai bekerja </h2><br>  Unduh <a href="">konsep</a> untuk tutorial ini dan kemudian buka di editor Unity.  Unity 2017.1 atau lebih tinggi diperlukan untuk pengoperasian. <br><br>  Buka adegan <em>Game</em> dari folder <em>Adegan</em> dan lihat di mana kita akan mulai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/819/22f/97381922f527deb0b338346d13083c13.png"></div><br>  Untuk saat ini, kami memiliki karakter pemain sederhana (siput) dan batu tergantung di udara. <br><br>  Komponen penting dari GameObject <em>Player</em> sejauh ini adalah capsule collider dan rigidbody, yang memungkinkannya berinteraksi dengan objek fisik di level tersebut.  Juga, skrip gerak sederhana ( <em>PlayerMovement</em> ) dilampirkan ke karakter, yang memungkinkannya untuk meluncur di tanah dan melakukan lompatan sederhana. <br><br>  Tekan tombol <em>Main</em> untuk memulai permainan, dan cobalah untuk mengontrol karakter.  <em>A</em> dan <em>D</em> gerakkan ke kiri / kanan, dan ketika Anda menekan <em>bilah spasi,</em> itu akan melompat.  Cobalah untuk tidak tergelincir dan jatuh dari tebing, jika tidak Anda akan mati! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b5/841/69a8b58415940671c3519ceccfcf6ed7.png"></div><br>  Kami sudah memiliki dasar-dasar manajemen, tetapi masalah terbesar sekarang adalah kurangnya kait kucing. <br><br><h2>  Membuat Kait dan Tali </h2><br>  Pada awalnya, sistem kait-kait tampaknya cukup sederhana, tetapi untuk penerapannya yang berkualitas tinggi, perlu mempertimbangkan banyak aspek.  Berikut adalah beberapa persyaratan untuk mekanisme kait kucing dua dimensi: <br><br><ul><li>  Line Renderer untuk menampilkan tali.  Ketika tali membungkus benda-benda, kita bisa menambahkan lebih banyak ruas ke garis renderer dan menempatkan simpul pada titik-titik yang sesuai dengan putusnya tali. </li><li>  DistanceJoint2D.  Hal ini dapat digunakan untuk memasang titik jangkar kait kucing saat ini sehingga siput kami dapat berayun.  Hal ini juga memungkinkan kita untuk mengatur jarak yang dapat digunakan untuk memperpanjang dan mengurangi tali. </li><li>  Child GameObject dengan RigidBody2D, yang dapat dipindahkan tergantung pada lokasi saat ini titik jangkar kail.  Intinya, itu akan menjadi titik suspensi / jangkar tali. </li><li>  Raycast karena melempar kail dan menempel pada benda. </li></ul><br>  Pilih objek <em>Player</em> di Hierarchy dan tambahkan GameObject anak baru bernama <em>RopeHingeAnchor</em> .  GameObject ini akan digunakan untuk memposisikan titik suspensi / jangkar kait kucing. <br><br>  Tambahkan komponen <em>SpriteRenderer</em> dan <em>RigidBody2D</em> ke <em>RopeHingeAnchor</em> . <br><br>  Untuk SpriteRenderer, setel properti <em>Sprite</em> untuk menggunakan nilai <em>UISprite</em> dan ubah <em>Order in Layer</em> menjadi <em>2</em> .  Nonaktifkan komponen dengan <em>menghapus centang pada kotak di</em> sebelah namanya. <br><br>  Untuk komponen <em>RigidBody2D,</em> setel properti Tipe Tubuh ke <em>Kinematik</em> .  Titik ini akan dipindahkan bukan oleh mesin fisik, tetapi oleh kode. <br><br>  Pilih layer <em>Rope</em> dan atur nilai komponen X dan Y Transform ke <em>4</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e18/4aa/8e4/e184aa8e457a1e1d3928966b2ae3bca7.png"></div><br>  Pilih <em>Player</em> lagi dan lampirkan komponen <em>DistanceJoint2D</em> baru. <br><br>  Seret <em>RopeHingeAnchor</em> dari Hierarchy ke properti <em>Connected Rigid Body</em> dari komponen <em>DistanceJoint2D</em> dan matikan <em>Auto Configure Distance</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/25b/b80/e4625bb804bb2ed2a0c5bee2aed0eade.gif"></div><br>  Buat skrip C # baru yang disebut <em>RopeSystem</em> di folder proyek <em>Scripts</em> dan buka di editor kode. <br><br>  Hapus metode <code>Update</code> . <br><br>  Di bagian atas skrip di dalam <code>RopeSystem</code> kelas <code>RopeSystem</code> tambahkan variabel baru, metode <code>Awake()</code> dan metode <code>Update</code> baru: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 public GameObject ropeHingeAnchor; public DistanceJoint2D ropeJoint; public Transform crosshair; public SpriteRenderer crosshairSprite; public PlayerMovement playerMovement; private bool ropeAttached; private Vector2 playerPosition; private Rigidbody2D ropeHingeAnchorRb; private SpriteRenderer ropeHingeAnchorSprite; void Awake() { // 2 ropeJoint.enabled = false; playerPosition = transform.position; ropeHingeAnchorRb = ropeHingeAnchor.GetComponent&lt;Rigidbody2D&gt;(); ropeHingeAnchorSprite = ropeHingeAnchor.GetComponent&lt;SpriteRenderer&gt;(); } void Update() { // 3 var worldMousePosition = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0f)); var facingDirection = worldMousePosition - transform.position; var aimAngle = Mathf.Atan2(facingDirection.y, facingDirection.x); if (aimAngle &lt; 0f) { aimAngle = Mathf.PI * 2 + aimAngle; } // 4 var aimDirection = Quaternion.Euler(0, 0, aimAngle * Mathf.Rad2Deg) * Vector2.right; // 5 playerPosition = transform.position; // 6 if (!ropeAttached) { } else { } }</span></span></code> </pre> <br>  Mari kita menganalisis setiap bagian dalam urutan: <br><br><ol><li>  Kami menggunakan variabel-variabel ini untuk melacak berbagai komponen yang akan berinteraksi dengan skrip RopeSystem. </li><li>  Metode <code>Awake</code> dimulai pada awal permainan dan menonaktifkan <code>ropeJoint</code> (komponen DistanceJoint2D).  Ini juga mengatur <code>playerPosition</code> ke posisi saat ini dari pemain. </li><li>  Ini adalah bagian terpenting dari loop <code>Update()</code> utama.  Pertama, kita mendapatkan posisi kursor mouse di dunia menggunakan <code>ScreenToWorldPoint</code> kamera <code>ScreenToWorldPoint</code> .  Lalu kami menghitung arah pandangan kami dengan mengurangi posisi pemain dari posisi mouse di dunia.  Kemudian kami menggunakannya untuk membuat <code>aimAngle</code> , yang merupakan representasi dari sudut bertujuan kursor.  Nilai menyimpan nilai positif dalam konstruk if. </li><li>  <code>aimDirection</code> adalah twist yang berguna nanti.  Kami hanya tertarik pada nilai Z, karena kami menggunakan kamera 2D, dan ini adalah satu-satunya OS yang sesuai.  Kami melewatkan <code>aimAngle * Mathf.Rad2Deg</code> , yang mengubah sudut radian menjadi sudut dalam derajat. </li><li>  Posisi pemain dimonitor menggunakan variabel nyaman yang memungkinkan Anda untuk tidak terus-menerus merujuk pada <code>transform.Position</code> . Posisi. </li><li>  Akhirnya, kami memiliki konstruksi <code>if..else</code> , yang akan segera kami gunakan untuk menentukan apakah tali tersebut terpasang ke titik jangkar. </li></ol><br>  Simpan skrip dan kembali ke editor. <br><br>  Lampirkan komponen <em>RopeSystem</em> ke objek Player dan gantung berbagai komponen pada bidang publik yang kami buat dalam skrip <em>RopeSystem</em> .  Seret <em>Player</em> , <em>Crosshair</em> , dan <em>RopeHingeAnchor</em> ke dalam bidang yang sesuai: <br><br><ul><li>  <em>Rope Hinge Anchor</em> : RopeHingeAnchor </li><li>  <em>Rope Joint</em> : Player </li><li>  <em>Crosshair</em> : Crosshair </li><li>  <em>Crosshair Sprite</em> : Crosshair </li><li>  <em>Gerakan</em> Pemain: Pemain </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e97/9ca/d2e/e979cad2e2690cc65e9fe237a9f6c47a.gif"></div><br>  Sekarang kami hanya melakukan semua perhitungan rumit ini, tetapi sejauh ini tidak ada visualisasi yang dapat menunjukkannya dalam tindakan.  Tapi jangan khawatir, kami akan segera melakukannya. <br><br>  Buka skrip <em>RopeSystem</em> dan tambahkan metode baru ke dalamnya: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCrosshairPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aimAngle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!crosshairSprite.enabled) { crosshairSprite.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = transform.position.x + <span class="hljs-number"><span class="hljs-number">1f</span></span> * Mathf.Cos(aimAngle); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = transform.position.y + <span class="hljs-number"><span class="hljs-number">1f</span></span> * Mathf.Sin(aimAngle); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> crossHairPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(x, y, <span class="hljs-number"><span class="hljs-number">0</span></span>); crosshair.transform.position = crossHairPosition; }</code> </pre> <br>  Metode ini memposisikan penglihatan berdasarkan tujuan yang ditransmisikan (nilai float yang kami hitung dalam <code>Update()</code> ) sehingga berputar di sekitar pemain dengan radius 1 unit.  Kami juga menyertakan ruang lingkup sprite jika belum dilakukan. <br><p>  Di <code>Update()</code> kami mengubah konstruksi <code>!ropeAttached</code> untuk memeriksa <code>!ropeAttached</code> sehingga terlihat seperti ini: <br><br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ropeAttached) { SetCrosshairPosition(aimAngle); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { crosshairSprite.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Simpan skrip dan jalankan game.  Sekarang siput kita harus bisa membidik dengan pandangan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/b1f/8ca/ffeb1f8ca53fbc0463aad677677fb837.gif"></div><br>  Bagian logika berikutnya yang perlu diimplementasikan adalah bidikan kucing-pengait.  Kami telah menentukan arah tujuan, jadi kami membutuhkan metode yang akan menerimanya sebagai parameter. <br><br>  Tambahkan variabel berikut di bawah variabel dalam skrip <em>RopeSystem</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LineRenderer ropeRenderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LayerMask ropeLayerMask; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ropeMaxCastDistance = <span class="hljs-number"><span class="hljs-number">20f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Vector2&gt; ropePositions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2&gt;();</code> </pre> <br>  <em>LineRenderer</em> akan berisi tautan ke renderer garis yang menarik tali.  <em>LayerMask</em> memungkinkan Anda untuk menyesuaikan lapisan fisika yang dapat berinteraksi dengan kail.  Nilai <code>ropeMaxCastDistance</code> menetapkan jarak maksimum yang bisa "ditembakkan" oleh raycast. <br><br>  Akhirnya, daftar posisi Vector2 akan digunakan untuk melacak titik pembungkus tali, yang akan kita bahas nanti. <br><br>  Tambahkan metode baru berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 private void HandleInput(Vector2 aimDirection) { if (Input.GetMouseButton(0)) { // 2 if (ropeAttached) return; ropeRenderer.enabled = true; var hit = Physics2D.Raycast(playerPosition, aimDirection, ropeMaxCastDistance, ropeLayerMask); // 3 if (hit.collider != null) { ropeAttached = true; if (!ropePositions.Contains(hit.point)) { // 4 //    ,    -  . transform.GetComponent&lt;Rigidbody2D&gt;().AddForce(new Vector2(0f, 2f), ForceMode2D.Impulse); ropePositions.Add(hit.point); ropeJoint.distance = Vector2.Distance(playerPosition, hit.point); ropeJoint.enabled = true; ropeHingeAnchorSprite.enabled = true; } } // 5 else { ropeRenderer.enabled = false; ropeAttached = false; ropeJoint.enabled = false; } } if (Input.GetMouseButton(1)) { ResetRope(); } } // 6 private void ResetRope() { ropeJoint.enabled = false; ropeAttached = false; playerMovement.isSwinging = false; ropeRenderer.positionCount = 2; ropeRenderer.SetPosition(0, transform.position); ropeRenderer.SetPosition(1, transform.position); ropePositions.Clear(); ropeHingeAnchorSprite.enabled = false; }</span></span></code> </pre> <br>  Inilah yang dilakukan oleh kode di atas: <br><br><ol><li>  HandleInput dipanggil dari loop <code>Update()</code> dan hanya meng-polling input dari tombol kiri dan kanan mouse. </li><li>  Ketika klik kiri didaftarkan, garis tali dinyalakan dan siaran-2D ditembakkan dari posisi pemain ke arah tujuan.  Jarak maksimum diatur sedemikian rupa sehingga kucing kait tidak dapat ditembak pada jarak tak terbatas, dan topeng diterapkan sehingga memungkinkan untuk memilih lapisan fisika yang dapat ditabrak oleh raycast. </li><li>  Jika hit raycast terdeteksi, maka <code>ropeAttached</code> <code>true</code> , dan daftar posisi simpul tali diperiksa untuk memastikan bahwa tidak ada titik di sana. </li><li>  Jika pengujian kembali benar, maka dorongan gaya kecil ditambahkan ke siput sehingga memantul di atas tanah, <code>ropeJoint</code> (DistanceJoint2D) dihidupkan, yang diatur ke jarak yang sama dengan jarak antara siput dan titik hit raycast.  Sprite titik jangkar juga disertakan. </li><li>  Jika raycast tidak mengenai apa pun, maka renderer baris dan ropeJoint dinonaktifkan, dan flag <code>ropeAttached</code> salah. </li><li>  Jika tombol kanan mouse ditekan, metode <code>ResetRope()</code> , yang menonaktifkan dan mengatur ulang semua parameter terkait dengan tali / kait ke nilai yang seharusnya jika kait tidak digunakan. </li></ol><br>  Di bagian paling bawah dari metode <code>Update</code> kami, tambahkan panggilan ke metode <code>HandleInput()</code> dan berikan nilai <code>aimDirection</code> ke <code>aimDirection</code> : <br><br><pre> <code class="cs hljs">HandleInput(aimDirection);</code> </pre> <br>  Simpan perubahan ke <em>RopeSystem.cs</em> dan kembali ke editor. <br><br><h2>  Menambahkan tali </h2><br>  Siput kami tidak akan bisa terbang di udara tanpa tali, jadi inilah saatnya untuk memberikan sesuatu yang akan menjadi representasi visual dari tali dan memiliki kemampuan untuk "berbalik" di tikungan. <br><br>  Pembuat baris sangat ideal untuk ini, karena memungkinkan kita untuk mentransfer jumlah poin dan posisinya di ruang dunia. <br><br>  Idenya di sini adalah bahwa kita selalu menyimpan simpul pertama dari tali (0) di posisi pemain, dan semua simpul lainnya diposisikan secara dinamis ketika tali harus membungkus sesuatu, termasuk posisi engsel saat ini, yang merupakan titik berikutnya di sepanjang tali. dari pemain. <br><br>  Pilih <em>Player</em> dan tambahkan komponen <em>LineRenderer</em> ke dalamnya.  Tetapkan <em>Lebar</em> ke <em>0,075</em> .  Perluas daftar <em>Bahan</em> dan, sebagai <em>Elemen 0,</em> pilih bahan <em>RopeMaterial</em> yang terletak di folder <em>Bahan</em> proyek.  Terakhir, untuk Pengurai Jalur, untuk <em>Mode Tekstur,</em> pilih <em>Distribusikan Per Segmen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/6aa/59f/c806aa59f875ac106babef5a8b57a6fc.png"></div><br>  Seret komponen Line Renderer ke bidang <em>Rope Renderer</em> pada komponen <em>System Rope</em> . <br><br>  Klik pada daftar drop-down dari <em>Rope Layer Mask</em> dan pilih sebagai lapisan mana Raycast <em>Default, Rope dan Pivot</em> dapat berinteraksi.  Karena itu, ketika "menembakkan" sebuah raycast, itu akan bertabrakan hanya dengan lapisan-lapisan ini, tetapi tidak dengan benda-benda lain, seperti seorang pemain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/eab/2c3/f9feab2c30cc84b83c94d39ce74acdea.gif"></div><br>  Jika Anda memulai permainan sekarang, Anda akan melihat perilaku aneh.  Ketika kami membidik sebuah batu di atas kepala siput dan menembak dengan kail, kami mendapat lompatan kecil ke atas, setelah itu teman kami mulai bersikap agak acak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/815/abd/ae6/815abdae693911ed0ba56f14775e5488.gif"></div><br>  Kami belum menetapkan jarak untuk sambungan jarak, di samping itu, simpul dari render garis belum dikonfigurasi.  Oleh karena itu, kita tidak melihat tali, dan karena jarak sambungan langsung di atas posisi siput, nilai jarak jarak sendi saat ini mendorongnya ke batu di bawahnya. <br><br>  Tapi jangan khawatir, sekarang kami akan menyelesaikan masalah ini. <br><br>  Dalam skrip <em>RopeSystem.cs,</em> tambahkan operator baru di awal kelas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq;</code> </pre> <br>  Ini memungkinkan kami untuk menggunakan kueri LINQ, yang dalam kasus kami cukup memungkinkan kami untuk dengan mudah menemukan elemen pertama atau terakhir dari daftar <code>ropePositions</code> . <br><br><blockquote>  <em>Catatan</em> : Language-Integrated Query (LINQ) adalah nama dari serangkaian teknologi yang didasarkan pada kemampuan permintaan penyertaan langsung di C #.  Anda dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </blockquote><br>  Tambahkan variabel pribadi bool baru yang disebut <code>distanceSet</code> bawah variabel lain: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> distanceSet;</code> </pre> <br>  Kami akan menggunakan variabel ini sebagai bendera sehingga skrip dapat mengenali bahwa jarak tali (untuk titik antara pemain dan titik referensi saat ini di mana kait kucing terpasang) diatur dengan benar. <br><br>  Sekarang tambahkan metode baru yang akan kita gunakan untuk mengatur posisi simpul tali untuk merender garis dan mengatur jarak sambungan jarak jauh dalam daftar posisi tersimpan dengan tali ( <code>ropePositions</code> ): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateRopePositions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!ropeAttached) { return; } // 2 ropeRenderer.positionCount = ropePositions.Count + 1; // 3 for (var i = ropeRenderer.positionCount - 1; i &gt;= 0; i--) { if (i != ropeRenderer.positionCount - 1) // if not the Last point of line renderer { ropeRenderer.SetPosition(i, ropePositions[i]); // 4 if (i == ropePositions.Count - 1 || ropePositions.Count == 1) { var ropePosition = ropePositions[ropePositions.Count - 1]; if (ropePositions.Count == 1) { ropeHingeAnchorRb.transform.position = ropePosition; if (!distanceSet) { ropeJoint.distance = Vector2.Distance(transform.position, ropePosition); distanceSet = true; } } else { ropeHingeAnchorRb.transform.position = ropePosition; if (!distanceSet) { ropeJoint.distance = Vector2.Distance(transform.position, ropePosition); distanceSet = true; } } } // 5 else if (i - 1 == ropePositions.IndexOf(ropePositions.Last())) { var ropePosition = ropePositions.Last(); ropeHingeAnchorRb.transform.position = ropePosition; if (!distanceSet) { ropeJoint.distance = Vector2.Distance(transform.position, ropePosition); distanceSet = true; } } } else { // 6 ropeRenderer.SetPosition(i, transform.position); } } }</span></span></code> </pre> <br>  Jelaskan kode yang ditunjukkan di atas: <br><br><ol><li>  Keluar dari metode jika tali tidak terpasang. </li><li>  Kami menetapkan nilai poin render dari garis tali ke jumlah posisi yang disimpan di <code>ropePositions</code> , ditambah 1 lebih (untuk posisi pemain). </li><li>  Kami melingkari daftar <code>ropePositions</code> dan <code>ropePositions</code> untuk setiap posisi (kecuali yang terakhir), menetapkan posisi vertex dari baris renderer ke nilai posisi Vector2 yang disimpan oleh indeks loop dalam daftar <code>ropePositions</code> . </li><li>  Tetapkan ke titik jangkar tali yang kedua dari posisi ujung tali, di mana titik engsel / jangkar saat ini harus, atau jika kita hanya memiliki satu posisi tali, maka jadikan sebagai titik jangkar.  Jadi kami mengatur jarak <code>ropeJoint</code> sama dengan jarak antara pemain dan posisi tali saat ini, yang kami <code>ropeJoint</code> dalam lingkaran. </li><li>  Konstruksi if menangani kasus di mana posisi tali saat ini di loop adalah yang kedua dari ujung;  yaitu titik di mana tali terhubung ke objek, yaitu  titik engsel / jangkar saat ini. </li><li>  Pegangan blok <code>else</code> ini menetapkan posisi simpul terakhir dari tali dengan nilai posisi pemain saat ini. </li></ol><br>  Ingatlah untuk menambahkan panggilan <code>UpdateRopePositions()</code> di akhir <code>Update()</code> <code>UpdateRopePositions()</code> : <br><br><pre> <code class="cs hljs">UpdateRopePositions();</code> </pre> <br>  Simpan perubahan pada skrip dan jalankan game lagi.  Buat "ruang kecil" lompatan kecil dengan membidik dan menembak dengan kait pada batu di atas karakter.  Sekarang Anda dapat menikmati hasil kerja Anda - siput itu bergoyang dengan tenang di atas batu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/f87/d7c/b94f87d7c533fdae336e3818f7cf3908.gif"></div><br>  Sekarang Anda dapat pergi ke jendela adegan, pilih Player, gunakan alat pindahkan (secara default, tombol <em>W</em> ) untuk memindahkannya dan menonton bagaimana dua simpul dari garis tali membuat mengikuti posisi kait dan posisi pemain untuk menarik tali.  Setelah kami melepaskan pemain, DistanceJoint2D dengan benar menghitung jarak dan siput akan terus mengayun pada engsel yang terhubung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/66e/18c/5e166e18ca7ff821025a920b1eaf849a.gif"></div><br><h2>  Menangani Poin Bungkus </h2><br>  Bermain dengan siput yang berayun sejauh ini tidak lebih berguna daripada handuk anti air, jadi kita pasti perlu menambahkannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/3bd/43e/6e93bd43eb1ebff2241cb89af3b09f0a.png"></div><br>  Kabar baiknya adalah bahwa metode yang baru ditambahkan untuk memproses posisi tali dapat digunakan di masa depan.  Sejauh ini kami hanya menggunakan dua posisi tali.  Satu terhubung ke posisi pemain, dan yang kedua ke posisi saat ini titik jangkar kail saat menembaknya. <br><br>  Satu-satunya masalah adalah bahwa sementara kita tidak melacak semua posisi potensial dari tali, dan ini membutuhkan sedikit usaha. <br><br>  Untuk mengenali posisi pada batu di mana tali harus dibungkus, menambahkan posisi simpul baru ke renderer garis, kita membutuhkan sistem yang menentukan apakah titik simpul collider berada di antara garis lurus antara posisi siput saat ini dan titik engsel / jangkar tali saat ini. <br><br>  Sepertinya ini berfungsi lagi untuk siaran lama yang bagus! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47a/52b/abe/47a52babe8fb16ef57a365b287dceb12.png"></div><br>  Pertama, kita perlu membuat metode yang dapat menemukan titik terdekat dalam collider berdasarkan pada hit point dari raycast dan tepi collider. <br><br>  Tambahkan metode baru ke skrip <em>RopeSystem.cs</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 private Vector2 GetClosestColliderPointFromRaycastHit(RaycastHit2D hit, PolygonCollider2D polyCollider) { // 2 var distanceDictionary = polyCollider.points.ToDictionary&lt;Vector2, float, Vector2&gt;( position =&gt; Vector2.Distance(hit.point, polyCollider.transform.TransformPoint(position)), position =&gt; polyCollider.transform.TransformPoint(position)); // 3 var orderedDictionary = distanceDictionary.OrderBy(e =&gt; e.Key); return orderedDictionary.Any() ? orderedDictionary.First().Value : Vector2.zero; }</span></span></code> </pre><br>  Jika Anda tidak terbiasa dengan query LINQ, maka kode ini mungkin tampak seperti semacam sihir C # yang rumit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/0d6/c88/9e80d6c88df7182190a87a8ca54dcb70.png"></div><br>  Jika demikian, maka jangan takut.  LINQ melakukan banyak pekerjaan untuk kami: <br><br><ol><li>  Metode ini mengambil dua parameter - objek <em>RaycastHit2D</em> dan <em>objek PolygonCollider2D</em> .  Semua batu di tingkat memiliki collider PolygonCollider2D, jadi jika kita selalu menggunakan bentuk PolygonCollider2D, itu akan berfungsi dengan baik. </li><li>  Di sinilah keajaiban permintaan LINQ dimulai!  Di sini kita mengubah kumpulan titik dari collider poligonal ke dalam kamus posisi <em>Vector2</em> (nilai setiap elemen kamus adalah posisi itu sendiri), dan kunci dari masing-masing elemen diberi nilai jarak dari titik ini ke posisi pemain pemain (nilai float).  Kadang-kadang sesuatu yang lain terjadi di sini: posisi yang dihasilkan dikonversi ke ruang dunia (secara default, posisi simpul collider disimpan di ruang lokal, mis., Relatif lokal ke objek yang dimiliki collider, dan kami membutuhkan posisi di ruang dunia). </li><li>  Kamus diurutkan berdasarkan kunci.  Dengan kata lain, dengan jarak terdekat dengan posisi pemain saat ini.  Jarak terdekat dikembalikan, yaitu, setiap titik yang dikembalikan oleh metode ini adalah titik collider antara pemain dan titik saat ini dari engsel tali! </li></ol><br>  Mari kita kembali ke skrip <em>RopeSystem.cs</em> dan menambahkan variabel bidang pribadi baru di atas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; wrapPointsLookup = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;();</code> </pre> <br>  Kami akan menggunakannya untuk melacak posisi di mana tali dapat membungkus. <br><br>  Di akhir metode <code>Update()</code> , temukan konstruk <code>else</code> yang berisi <code>crosshairSprite.enabled = false;</code>  dan tambahkan yang berikut ini: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 if (ropePositions.Count &gt; 0) { // 2 var lastRopePoint = ropePositions.Last(); var playerToCurrentNextHit = Physics2D.Raycast(playerPosition, (lastRopePoint - playerPosition).normalized, Vector2.Distance(playerPosition, lastRopePoint) - 0.1f, ropeLayerMask); // 3 if (playerToCurrentNextHit) { var colliderWithVertices = playerToCurrentNextHit.collider as PolygonCollider2D; if (colliderWithVertices != null) { var closestPointToHit = GetClosestColliderPointFromRaycastHit(playerToCurrentNextHit, colliderWithVertices); // 4 if (wrapPointsLookup.ContainsKey(closestPointToHit)) { ResetRope(); return; } // 5 ropePositions.Add(closestPointToHit); wrapPointsLookup.Add(closestPointToHit, 0); distanceSet = false; } } }</span></span></code> </pre> <br>  Jelaskan potongan kode ini: <br><br><ol><li>  Jika beberapa posisi disimpan dalam daftar <code>ropePositions</code> , maka ... </li><li>  Kami menembak dari posisi pemain ke arah pemain melihat posisi terakhir tali dari daftar - titik referensi di mana kail kucing terhubung ke batu - dengan jarak sinar yang sama dengan jarak antara pemain dan posisi titik referensi tali. </li><li>  Jika raycast bertabrakan dengan sesuatu, maka collider objek ini dengan aman <em>dilemparkan</em> ke tipe <em>PolygonCollider2D</em> .  Meskipun itu adalah PolygonCollider2D yang benar, posisi vertex terdekat dari collider ini dikembalikan menggunakan metode yang kami tulis sebelumnya sebagai <em>Vector2</em> . </li><li>  Itu diperiksa oleh <code>wrapPointsLookup</code> untuk memastikan bahwa posisi yang sama tidak dicentang lagi.  Jika dicentang, maka kami membuang tali dan memotongnya, menjatuhkan pemain. </li><li>  Kemudian daftar <code>ropePositions</code> : posisi ditambahkan di mana tali harus dibungkus.  Kamus <code>wrapPointsLookup</code> juga diperbarui.  Akhirnya, flag <code>distanceSet</code> diatur ulang sehingga metode <code>UpdateRopePositions()</code> dapat mendefinisikan kembali jarak tali dengan panjang tali dan segmen yang baru. </li></ol><br>  Di <code>ResetRope()</code> tambahkan baris berikut sehingga kamus <code>wrapPointsLookup</code> dihapus setiap kali pemain memutus tali: <br><br><pre> <code class="cs hljs">wrapPointsLookup.Clear();</code> </pre> <br>  Simpan dan luncurkan game.  Tembak kait kucing ke batu di atas siput dan gunakan alat Pindahkan di jendela Adegan untuk memindahkan siput di atas beberapa tepian batu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/999/f50/c62999f50094252b3850b8b4c54e2cdc.gif"></div><br>  Begitulah cara kami mengajar tali untuk membungkus benda! <br><br><h2>  Tambahkan kemampuan goyang </h2><br>  Siput yang tergantung di tali cukup statis.  Untuk mengatasinya, kita bisa menambahkan kemampuan berayun. <br><br>  Untuk melakukan ini, kita perlu mendapatkan posisi tegak lurus dengan posisi berayun ke depan (ke samping), terlepas dari sudut di mana dia melihat. <br><br>  Buka <em>PlayerMovement.cs</em> dan tambahkan dua variabel publik berikut ke bagian atas skrip: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 ropeHook; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swingForce = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br>  Variabel <code>ropeHook</code> akan diberi posisi apa pun di mana kait tali saat ini berada, dan <code>swingForce</code> adalah nilai yang kami gunakan untuk menambahkan gerakan ayunan. <br><br>  Ganti metode <code>FixedUpdate()</code> baru: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontalInput &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> || horizontalInput &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { animator.SetFloat(<span class="hljs-string"><span class="hljs-string">"Speed"</span></span>, Mathf.Abs(horizontalInput)); playerSprite.flipX = horizontalInput &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isSwinging) { animator.SetBool(<span class="hljs-string"><span class="hljs-string">"IsSwinging"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 -          var playerToHookDirection = (ropeHook - (Vector2)transform.position).normalized; // 2 -  ,     Vector2 perpendicularDirection; if (horizontalInput &lt; 0) { perpendicularDirection = new Vector2(-playerToHookDirection.y, playerToHookDirection.x); var leftPerpPos = (Vector2)transform.position - perpendicularDirection * -2f; Debug.DrawLine(transform.position, leftPerpPos, Color.green, 0f); } else { perpendicularDirection = new Vector2(playerToHookDirection.y, -playerToHookDirection.x); var rightPerpPos = (Vector2)transform.position + perpendicularDirection * 2f; Debug.DrawLine(transform.position, rightPerpPos, Color.green, 0f); } var force = perpendicularDirection * swingForce; rBody.AddForce(force, ForceMode2D.Force); } else { animator.SetBool("IsSwinging", false); if (groundCheck) { var groundForce = speed * 2f; rBody.AddForce(new Vector2((horizontalInput * groundForce - rBody.velocity.x) * groundForce, 0)); rBody.velocity = new Vector2(rBody.velocity.x, rBody.velocity.y); } } } else { animator.SetBool("IsSwinging", false); animator.SetFloat("Speed", 0f); } if (!isSwinging) { if (!groundCheck) return; isJumping = jumpInput &gt; 0f; if (isJumping) { rBody.velocity = new Vector2(rBody.velocity.x, jumpSpeed); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahan utama di sini adalah bahwa bendera diperiksa terlebih dahulu </font></font><code>isSwinging</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga tindakan dilakukan hanya ketika siput tergantung pada tali, dan kami juga menambahkan tegak lurus ke sudut siput, menunjukkan titik jangkar saat ini di bagian atas tali, tetapi tegak lurus terhadap arah ayunannya.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mendapatkan vektor arah dinormalisasi dari pemain ke titik lampiran kait. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tergantung pada apakah siput berayun ke kiri atau kanan, arah tegak lurus dihitung menggunakan </font></font><code>playerToHookDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Panggilan undian debug juga telah ditambahkan sehingga Anda dapat melihatnya di editor jika diinginkan.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buka </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RopeSystem.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font><font style="vertical-align: inherit;">tambahkan berikut ini </font><font style="vertical-align: inherit;">di bagian atas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blok lain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di dalam </font></font><code>if(!ropeAttached)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">playerMovement.isSwinging = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; playerMovement.ropeHook = ropePositions.Last();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blok if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan desain yang sama, </font></font><code>if(!ropeAttached)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambahkan berikut ini:</font></font><br><br><pre> <code class="cs hljs">playerMovement.isSwinging = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami menginformasikan skrip PlayerMovement bahwa pemain berayun, dan juga menentukan posisi tali terakhir (kecuali untuk posisi pemain) - dengan kata lain, titik jangkar tali. </font><font style="vertical-align: inherit;">Ini diperlukan untuk menghitung sudut tegak lurus yang baru saja kita tambahkan ke skrip PlayerMovement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini seperti apa jika Anda menghidupkan gizmos dalam game yang sedang berjalan dan tekan A atau D untuk mengayun ke kiri / kanan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5bd/6a5/4ed/5bd6a54ed3c8661e61b3bf765e50acfb.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menambahkan keturunan tali </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara kita tidak memiliki kemampuan untuk bergerak ke atas dan ke bawah tali. </font><font style="vertical-align: inherit;">Meskipun dalam kehidupan nyata siput tidak bisa dengan mudah naik dan turun di sepanjang tali, tetapi ini adalah permainan di mana segala sesuatu dapat terjadi, bukan? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian atas skrip </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RopeSystem,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambahkan dua variabel bidang baru:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> climbSpeed = <span class="hljs-number"><span class="hljs-number">3f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isColliding;</code> </pre> <br> <code>climbSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan mengatur kecepatan di mana siput dapat bergerak ke atas dan ke bawah tali, dan </font></font><code>isColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan digunakan sebagai bendera untuk menentukan apakah properti sambungan jarak tali sendi jarak dapat ditingkatkan atau dikurangi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode baru ini:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRopeLength</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (Input.GetAxis("Vertical") &gt;= 1f &amp;&amp; ropeAttached &amp;&amp; !isColliding) { ropeJoint.distance -= Time.deltaTime * climbSpeed; } else if (Input.GetAxis("Vertical") &lt; 0f &amp;&amp; ropeAttached) { ropeJoint.distance += Time.deltaTime * climbSpeed; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok ini </font></font><code>if..elseif</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membaca input di sepanjang sumbu vertikal (atas / bawah atau W / S pada keyboard), dan, dengan mempertimbangkan bendera, </font></font><code>ropeAttached iscColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambah atau mengurangi jarak </font></font><code>ropeJoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menciptakan efek memperpanjang atau memperpendek tali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengaitkan metode ini, menambahkan panggilannya ke akhir </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">HandleRopeLength();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga membutuhkan cara untuk mengatur bendera </font></font><code>isColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan dua metode berikut ke bagian bawah skrip:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerStay2D</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D colliderStay</span></span></span><span class="hljs-function">)</span></span> { isColliding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerExit2D</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D colliderOnExit</span></span></span><span class="hljs-function">)</span></span> { isColliding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua metode ini adalah metode asli dari kelas dasar skrip MonoBehaviour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Collider saat ini menyentuh objek fisik lain dalam gim, metode akan terus menyala </font></font><code>OnTriggerStay2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memberikan </font></font><code>isColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai </font><font style="vertical-align: inherit;">pada bendera </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini berarti bahwa ketika siput menyentuh batu, bendera isColliding diberi nilai </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini </font></font><code>OnTriggerExit2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipicu ketika satu collider meninggalkan area collider lain, mengatur flag ke false. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu diingat: metode </font></font><code>OnTriggerStay2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini bisa sangat mahal secara komputasi, jadi gunakan dengan hati-hati.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ke mana harus pergi selanjutnya? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mulai permainan lagi dan kali ini tekan tombol panah atau W / S untuk bergerak naik dan turun tali. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/348/a3e/e5d/348a3ee5d95a10273c8bc644e3dbc7d9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek yang sudah selesai dari bagian tutorial ini dapat diunduh di </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami telah menempuh perjalanan panjang - dari siput-siput non-ayun ke moluska gastropoda cangkang bebas-akrobatik! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda telah belajar cara membuat sistem membidik yang dapat menembakkan kait kucing pada benda apa pun yang memiliki tabrakan, melekat padanya dan secara bersamaan mengayunkannya, memutar tali dinamis di sekitar tepi benda! </font><font style="vertical-align: inherit;">Kerja bagus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dd/bb5/29d/4ddbb529d88b62441d7b2d91424bf906.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada fungsi penting yang hilang di sini - tali tidak bisa "lepas" saat diperlukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutorial, kita akan menyelesaikan masalah ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika Anda bersedia mengambil risiko, mengapa tidak mencoba melakukannya sendiri? </font><font style="vertical-align: inherit;">Anda dapat menggunakan kamus untuk ini </font></font><code>wrapPointsLookup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414887/">https://habr.com/ru/post/id414887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414877/index.html">Lensa yang tidak biasa untuk kamera biasa atau cara berhenti memikirkan fokus</a></li>
<li><a href="../id414879/index.html">Mengapa 2 ekstruder di printer 3D?</a></li>
<li><a href="../id414881/index.html">Sedikit di belakang panggung VK</a></li>
<li><a href="../id414883/index.html">Kenangan terdengar dengan cara baru: BBC memperbarui arsip suara proyek RemArc</a></li>
<li><a href="../id414885/index.html">Kami menangani kesalahan dan "penopang" dalam Daftar Badan Hukum Negara Bersatu - register negara dari badan hukum</a></li>
<li><a href="../id414889/index.html">Ketika Lembaga Digital Membutuhkan IaaS</a></li>
<li><a href="../id414891/index.html">Kebiasaan Pengembang</a></li>
<li><a href="../id414893/index.html">Viber, WhatsApp, Telegram - mana yang lebih baik?</a></li>
<li><a href="../id414895/index.html">Dan bagi kami semuanya "tegak" - DBMS Vertica</a></li>
<li><a href="../id414897/index.html">Akses data dalam aplikasi multi-pengguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>