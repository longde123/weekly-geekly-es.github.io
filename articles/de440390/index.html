<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÜ üëÅ‚Äçüó® ‚õ≥Ô∏è Die vielf√§ltige Welt der eingebetteten Systeme und der Platz von Embox darin üë©üèΩ‚Äçü§ù‚Äçüë©üèº ‚úãüèΩ üí¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Embox- Projekt ist bereits 9 Jahre alt geworden, aber viele verstehen nicht, was es ist und womit es gegessen wird und warum es ben√∂tigt wird. Ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die vielf√§ltige Welt der eingebetteten Systeme und der Platz von Embox darin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/440390/"><img src="https://habrastorage.org/webt/ep/jc/qp/epjcqpyctt_7bt0cwewzqkz1iyg.jpeg" align="right" width="320">  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox-</a> Projekt ist bereits 9 Jahre alt geworden, aber viele verstehen nicht, was es ist und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">womit</a> <s>es gegessen wird und</s> warum es ben√∂tigt wird.  Einige von denen, die von dem Projekt geh√∂rt haben und wissen, dass dies ein Betriebssystem ist, glauben, dass Embox ein ‚Äûinl√§ndisches Betriebssystem‚Äú ist.  In der Tat wurde Embox als Versuch konzipiert, "ihr" Betriebssystem mit "Blackjack und Booten" zu erstellen, aber die Hauptsache ist "Blackjack und Boote".  Das hei√üt, bestimmte Merkmale oder deren Kombination, die in anderen Projekten fehlten, wurden in den Vordergrund gestellt. <br><br>  Nat√ºrlich w√ºrde auch mit einigen Chips niemand ein universelles Betriebssystem schreiben.  Der Slogan Embox - ‚ÄûWesentliche Toolbox f√ºr die eingebettete Entwicklung‚Äú - impliziert, dass das Projekt auf eingebettete Systeme ausgerichtet ist.  Dieses Konzept ist jedoch sehr weit gefasst und umfasst: das Internet der Dinge (IoT) und Roboter, verschiedene Himbeeren (RaPi) und Bordsysteme, Arduinki und ASU-TP, ...  Wie Sie wissen, kann die Liste sehr lange dauern, es gibt Orte, an denen Linux gro√üartig lebt, und es gibt Orte, an denen Linux redundant ist und verschiedene kleine RTOS verwendet werden.  In diesem Artikel m√∂chte ich √ºber die eingebettete Welt in all ihrer Vielfalt und auch √ºber den Platz von Embox darin sprechen. <br><a name="habracut"></a><br><h2>  Single Board Computer </h2><br><h3>  Industriecomputer </h3><br>  Beginnen wir mit Single-Board-Computern.  Viele von ihnen werden im Industriedesign hergestellt.  Die meisten basieren auf Prozessoren mit ARM- und x86-Architekturen.  Viele Leute denken, dass x86-Prozessoren in diesem Segment nicht verwendet werden, und alles beschr√§nkt sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Himbeeren</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beagleboards</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bananen</a> und so weiter.  Doch lange vor RaPi gab es andere Single-Board-Maschinen f√ºr das industrielle PC-Segment, den sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PC / 104-</a> Formfaktor.  Sie waren in ihrer Leistung schlechter als herk√∂mmliche Desktops, da sie f√ºr Aufgaben gedacht waren, bei denen Zuverl√§ssigkeit Vorrang vor Funktionalit√§t hat.  Aus dem gleichen Grund wurde Linux nicht oft als Betriebssystem f√ºr diese Hardwareplattformen verwendet. Es gab verschiedene propriet√§re Betriebssysteme mit Echtzeit-Eigenschaften ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VxWorks</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QNX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LynxOS</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usw.</a> ).  Ich habe ‚ÄûRTOS‚Äú (zu dem ich alle drei Betriebssysteme beziehe) nicht geschrieben, weil sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows CE</a> und die Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Embedded h√§ufig</a> auf diesen Hardwareplattformen befanden.  Und ich drehe nicht die Zunge, um diesen ganzen Zoo dem RTOS zuzuschreiben. <br><br><h3>  Einzelzahler f√ºr Verbraucher </h3><br>  Malinki setzte einen ganz anderen Trend.  Sie richten sich in der Tat nicht an industrielle Echtzeitsysteme, sondern an das Verbrauchersegment, in dem das Preis-Leistungs-Verh√§ltnis bewertet wird, und Himbeeren (und Analoga) sind in diesem Parameter ihren Wettbewerbern deutlich voraus.  Wenn Sie f√ºr 30 bis 50 US-Dollar kaufen, erhalten Sie schlie√ülich eine vollwertige Systemeinheit, mit der Sie mit Linux-Tools problemlos ein Ger√§t mit ziemlich komplizierten Funktionen erstellen k√∂nnen.  Dies ist sehr n√ºtzlich f√ºr Prototyping oder DIY.  Au√üerdem kann Himbeere nat√ºrlich als PC oder kleiner Server verwendet werden.  Daher werden h√§ufig vorgefertigte Linux-Distributionen als Betriebssystem verwendet, zun√§chst nat√ºrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raspbian</a> - Debian f√ºr Raspberry Pi oder eine Distribution mit einem lustigen Namen f√ºr die russischsprachigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pidora</a> - Fedora f√ºr RaspberryPi.  F√ºr andere √§hnliche Plattformen gibt es auch vorgefertigte Distributionen, die sowohl von Ger√§teherstellern als auch von Betriebssystemgemeinschaften (Herstellern) bereitgestellt werden.  Stimmen Sie zu, wenn Sie einen Prototyp erstellen m√ºssen, ist es am einfachsten, vorgefertigte Pakete zu instruieren und Funktionen in Python zu schreiben.  So erhalten Sie schnell einen funktionierenden Prototyp.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispiel ist ein Roboter, der eine Linie mit OpenCV erkennt</a> . <br><br><h2>  Linux in eingebetteten Ger√§ten </h2><br>  Die eingebettete Welt ist jedoch viel breiter als Standard-ARM-Einplatinenkarten.  Dar√ºber hinaus machen sie einen relativ kleinen Teil der Ger√§te aus, und ihr Hauptbeitrag ist die Popularisierung und Vereinfachung des Einstiegs in die Entwicklung von Ger√§ten dieser Klasse.  Serielle Ger√§te werden auf der Grundlage derselben Prozessoren (Systeme auf einem Chip) oder √§hnlichem erstellt, die Karten sind jedoch f√ºr die Aufgabe (Projekt, Ger√§t) ausgelegt.  Folglich sind Standarddistributionen zumindest redundant, da sie h√§ufig eine Art Paketmanager verwenden und Sie leicht viele interessante Informationen liefern k√∂nnen (die jedoch f√ºr die L√∂sung einer bestimmten Aufgabe nicht erforderlich sind).  Eingebettete Ger√§te verf√ºgen normalerweise √ºber vollst√§ndige Funktionen und werden sogar als Firmware bezeichnet.  Es gibt eine andere Klasse von Linux-Distributionen zum Erstellen von Firmware.  Mit solchen Distributionen k√∂nnen Sie die erforderlichen Pakete statisch installieren, indem Sie sie im Root-Dateisystem und nicht dynamisch zusammenstellen, indem Sie den Paketmanager aus dem Repository verwenden.  In der Regel k√∂nnen diese Distributionen nicht nur Anwendungsanwendungen und Bibliotheken, sondern auch den Kernel in einer bestimmten Konfiguration erstellen.  Und oft auch ein Cross-Compiler, weil das Kompilieren auf dem Ger√§t selbst zumindest nicht effektiv ist. <br><br><h3>  Yocto-Projekt </h3><br>  Bis heute ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yocto-Projekt</a> die bekannteste Distribution dieser Art (ein Projekt zum Erstellen von Distributionen).  Es basiert wiederum auf einem anderen bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenEmbedded-</a> Projekt, das eine Art Build-System f√ºr Linux-Distributionen darstellt.  Wenn Sie den Raspberry Pi nicht als fertiges kleines System, sondern als benutzerdefiniertes Ger√§t unter Linux verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chten</a> , sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yocto</a> oder seine Analoga eine gute Option.  Pers√∂nlich sehe ich keine gro√üen Vorteile darin, nicht standardm√§√üige Linux-Distributionen mit Standard-Eisenst√ºcken zu verwenden. Wenn Sie jedoch √§hnliche Ger√§te entwickeln m√∂chten oder die Technologien selbst erlernen m√∂chten, ist dieser Ansatz am vielversprechendsten.  Schlie√ülich k√∂nnen Programmierer w√§hrend der Entwicklung einer speziellen Hardware ihre Systemteile (Algorithmen, Treiber, Bibliotheken usw.) entwickeln und debuggen.  Dies reduziert die Entwicklungszeit und damit das ber√ºchtigte TTM (Time-to-Market) erheblich. <br><br><h3>  Openwrt </h3><br>  Ein weiteres bekanntes Linux-basiertes Firmware-Projekt ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenWRT</a> .  Ich bin sicher, dass diejenigen, die Spa√ü am Anpassen von Routern haben, von ihm geh√∂rt haben.  Basierend auf diesem Projekt wird Firmware f√ºr verschiedene Router erstellt, die eine Bin√§rdatei sind, einschlie√ülich des Kernels und des Root-Dateisystems.  Die Verwendung von Firmware (anstelle von universellen Distributionen) in eingebetteten Systemen h√§ngt mit der Idee zusammen, dass die Funktionalit√§t des endg√ºltigen Systems zum Zeitpunkt seiner Entwicklung bekannt ist, dh, selbst wenn die Router-Version aktualisiert wird, √§ndert sich die Firmware vollst√§ndig mit allen Funktionen (oder ein Teil dieser Firmware wird auf besondere Weise ersetzt )  Die Installation von beispielsweise B√ºrosuiten ist normalerweise nicht erforderlich und h√§ufig generell verboten, da dies zu einer eigenen Unsicherheit f√ºhren kann.  Dieser Ansatz erm√∂glicht unter anderem eine erhebliche Einsparung an Hardware.  Dieselben Router haben beispielsweise einen viel weniger leistungsstarken Prozessor und viel weniger Speicher als Universaldr√ºsen. <br><br><h2>  Echtzeitsysteme </h2><br>  Um auf das Thema Industrierechner zur√ºckzukommen, muss der Begriff ‚ÄûEchtzeitsystem‚Äú er√∂rtert werden.  Viele Leute denken, dass Echtzeitsysteme schneller sind.  Dies ist ein Irrtum.  Wahrscheinlich ist es mit historischen R√§umlichkeiten verbunden.  Immerhin entstand der Begriff selbst, als Autos langsam waren.  Und der Benutzer bemerkte, dass die Reaktion des Systems m√∂glicherweise hinter seinen Aktionen zur√ºckbleibt.  Der Begriff ‚ÄûEchtzeit‚Äú bedeutete, dass das System auf alle Einfl√ºsse, einschlie√ülich Bedieneraktionen, reagieren musste.  Auf modernen Computern ist es jedoch unwahrscheinlich, dass der Benutzer (Bediener) eine Hemmung bemerkt.  In den allermeisten F√§llen wird beim Klicken auf Men√º, Symbol und Schaltfl√§che sofort eine Neuzeichnung des Bildschirms angezeigt, es sei denn, nat√ºrlich ist alles in Ordnung (das Internet ist vorhanden, der Vorgang h√§ngt nicht usw.).  Wenn jedoch etwas Unerwartetes passiert ist, zum Beispiel die Verbindung unterbrochen wird, werden wir sehen, wie sich Echtzeitsysteme unterscheiden (sollten sich unterscheiden).  Wir werden einfach das normale Smartphone neu starten.  Aber wenn dieses System das Kraftwerk steuert, dann verstehen Sie selbst, dass dies nicht immer m√∂glich ist.  Daraus schlie√üen wir, dass das Echtzeitsystem vorhersehbar und nicht schnell auf ein Ereignis oder eine Reihe von Ereignissen reagieren sollte, unabh√§ngig von seinem Zustand und seiner Umgebung. <br><br><h3>  Linux in Echtzeitsystemen </h3><br>  Nat√ºrlich gab (und gibt) es Versuche, aus Linux ein Echtzeitsystem zu machen.  Das bekannteste ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTLinux</a> , urspr√ºnglich war es ein Patch f√ºr Linux, der den urspr√ºnglichen ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">v√∂llig ehrlichen Scheduler</a> ‚Äú ersetzte, genauer gesagt, einen eigenen einf√ºgte, eine der Aufgaben, die vom Linux-Scheduler festgelegt wurden.  Dieser Scheduler arbeitete an statischen Aufgabenpriorit√§ten und dementsprechend viel vorhersehbarer.  Aber es war nicht mehr Linux, oder besser gesagt, die Linux-Funktionalit√§t war nicht in Echtzeit. <br><br><h3>  ARINC-653 </h3><br>  Ein weiterer Ansatz zur Bereitstellung von Echtzeit, der dem RT-Patch f√ºr Linux √§hnelt, ist der Ansatz, der vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ARINC653-</a> Standard oder vom sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MILS-</a> Ansatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefordert wird</a> .  Dieser Ansatz impliziert, dass das System in Schichten aufgebaut ist, die untere Schicht impliziert einen sehr leichten Hypervisor, auf dessen Grundlage Aufgaben mit unterschiedlichem Kritikalit√§tsgrad in statisch definierten Abschnitten ausgef√ºhrt werden.  Ich habe den Hypervisor als sehr leicht bezeichnet, weil er impliziert, dass er die h√∂chste Kritikalit√§t aufweist und daher sein Code (Algorithmen) so vollst√§ndig wie m√∂glich √ºberpr√ºft werden sollte (im Idealfall sollte das Fehlen unverarbeiteter Situationen mathematisch bewiesen werden).  Daher sollte der Code so klein wie m√∂glich sein.  Nun, und Linux befindet sich, wie Sie wahrscheinlich verstanden haben, in einem eigenen Bereich. <br><br><h3>  uCLinux </h3><br>  Versuche, Linux in eingebetteten Systemen zu verwenden, haben vor langer Zeit begonnen.  Einer der ersten war der Versuch, Linux in Systemen zu verwenden, in denen keine Hardwareunterst√ºtzung f√ºr virtuellen Speicher (MMU) vorhanden ist.  Dieses Projekt hie√ü <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uCLinux</a> und sein Beitrag zum Linux-Kernel war der <a href="">NOMMU-</a> oder MMU- <a href="">freie</a> Modus. <br><br><h3>  Linux in Echtzeitsystemen </h3><br>  Um die Versuche, Linux in Echtzeitsystemen zu verwenden, zusammenzufassen, m√ºssen Sie die Frage beantworten, warum dies geschieht.  Das hei√üt, einerseits ist Linux (im Moment und in seiner reinen Form) nicht speziell f√ºr Echtzeitsysteme angepasst, und andererseits wird st√§ndig versucht, dies zu tun.  Dies geschieht aufgrund der Einf√ºhrung von Einschr√§nkungen (Ersetzen des Schedulers, Einf√ºhrung eines Hypervisors, Einschr√§nkungen bei der Verwendung des virtuellen Speichers usw.).  Die Antwort liegt meiner Meinung nach in der Anwesenheit von Linux, einer gigantischen Codebasis.  Dies sind Treiber, dies sind funktionale Anwendungen und Bibliotheken.  Wenn Sie ein zuverl√§ssiges System erstellen m√∂chten, sollten Sie nat√ºrlich so viele vorgefertigte Teile wie m√∂glich verwenden, da die Entwicklung neuer Teile, ob Funktionslogik oder Treiber, immer die Wahrscheinlichkeit eines Fehlers enth√§lt.  Und da moderne Echtzeitsysteme ziemlich hohe funktionale Anforderungen haben, wird die Wiederverwendung vorgefertigter Funktionen unter Linux immer verlockender.  Mit anderen Worten, ein Upgrade von Linux auf ein Echtzeitsystem scheint im Vergleich zur Entwicklung von Funktionen nicht so teuer zu sein, obwohl es auf einem Echtzeitbetriebssystem basiert, da die Zuverl√§ssigkeit des gesamten Systems und nicht nur seines Teils in Form des Kernels des Betriebssystems zuverl√§ssig sein muss. <br><br><h3>  Windows in eingebetteten Ger√§ten </h3><br>  Ich m√∂chte f√ºr eine Weile zu Windows zur√ºckkehren.  Zu Beginn meiner Karriere hatte ich eine Diskussion mit einem erfahreneren Entwickler, dass Windows nicht in zuverl√§ssigen Systemen verwendet werden kann.  Wenn Sie ein bereits fertiggestelltes System mit der erforderlichen funktionalen Software testen und √Ñnderungen verbieten: Updates, Softwareinstallation usw., ist das System f√ºr viele Aufgaben, einschlie√ülich der von uns, zuverl√§ssig genug entschieden.  Jetzt habe ich keinen Zweifel daran, dass mein Gegner Recht hatte, nicht ich.  Dar√ºber hinaus wird sogar das alte MS-DOS seit sehr langer Zeit in industriellen Systemen verwendet.  Tatsache ist, dass Multitasking, das so notwendig erscheint, Unsicherheit mit sich bringt.  Und wenn Sie Software ausf√ºhren, die das gesamte System vollst√§ndig steuert, k√∂nnen Sie ein viel deterministischeres Verhalten erzielen.  Mit anderen Worten, wenn sich eine unbestimmte Anzahl von Aufgaben im System dreht, ist es unwahrscheinlich, dass es m√∂glich ist, Sicherheit in der Arbeit aller Funktionen des Systems zu erreichen.  Der einfachste Weg, die Vorhersagbarkeit des Systems zu verbessern, besteht daher darin, seine Funktionalit√§t und damit die Ablehnung der Universalit√§t zur Laufzeit einzuschr√§nken.  Was wir in der Tat in den oben erw√§hnten Beispielen f√ºr die Verwendung von Linux in Echtzeitsystemen beobachten. <br><br><h2>  Mikrocontroller </h2><br>  Das Beispiel von MS-DOS als Basisbetriebssystem f√ºr industrielle Echtzeitsysteme f√ºhrt uns zu der Idee, dass Sie ein vorhersehbares Verhalten des gesamten Systems erzielen k√∂nnen, wenn Sie nur Ihre eigene Software verwenden.  Und das ist es wirklich!  Richtig, Sie m√ºssen reservieren, dass dies nur m√∂glich ist, wenn die Funktionalit√§t des Systems klein und klar festgelegt ist.  Wenn die gesamte Funktionalit√§t des Systems darin besteht, den Motor √ºber das GPIO zu steuern und einen begrenzten Satz von Befehlen √ºber die UART-Schnittstelle zu empfangen (zu senden), ist es nicht erforderlich, das Betriebssystem zu verwenden. Sie k√∂nnen eine Firmware erstellen (was als Bare-Metal bezeichnet wird).  Dieser Ansatz wird h√§ufig in Mikrocontrollern verwendet.  Da die Mikrocontroller jedoch gro√ü wurden (32-Bit-ARM mit mehreren KB RAM gegen√ºber 8-Bit-AVR-OK mit 100 Byte RAM), nahmen die Anforderungen an die Funktionalit√§t zu.  Bei der Entwicklung von Firmware wird mindestens Software von Herstellern verwendet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sodass</a> Sie einige vorgefertigte Beispiele f√ºr die Arbeit mit einem Mikrocontroller verwenden k√∂nnen, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32Cube</a> . <br><br><h3>  RTOSes </h3><br>  Da die Anforderungen an die Funktionalit√§t jedoch st√§ndig steigen, wird die Firmware f√ºr Mikrocontroller zunehmend auf Basis des sogenannten RTOS erstellt.  Im Gegensatz zu gro√üen Echtzeitbetriebssystemen handelt es sich hierbei um relativ kleine Open Source-Projekte, die vollen Zugriff auf den gesamten Code im System bieten.  Das hei√üt, es gibt eine Kombination von Konzepten: Zum einen wird vorgefertigter Code verwendet, zum anderen hat der Entwickler vollen Zugriff auf alles im System, man kann sagen Bare-Metal-Firmware. <br><br>  Es gibt ziemlich viele RTOS f√ºr Mikrocontroller.  Daher ist es unm√∂glich, √ºber alle zu sprechen.  Ich werde meiner Meinung nach nur einige interessante Projekte herausgreifen und kurz √ºber deren Merkmale sprechen. <br><br><h4>  FreeRTOS </h4><br>  Wahrscheinlich ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRTOS</a> eines der beliebtesten RTOS-Projekte.  Einige sagen, dass dies kein vollst√§ndiges Betriebssystem ist, sondern nur ein Scheduler.  Wenn Sie jedoch die obige Diskussion √ºber Bare-Metal, die gro√üe Anzahl unterst√ºtzter Mikrocontroller und die Tatsache ber√ºcksichtigen, dass viel Anwendungssoftware geschrieben und integriert ist, dann sieht die kleine Funktionalit√§t eher nach einer Tugend als nach einem Nachteil aus.  Dies erm√∂glichte es uns, ein De-facto-Standard f√ºr Mikrocontroller zu werden, wie er auf der Projektwebsite beschrieben ist. <br><br><h4>  Contiki </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Contiki</a> - RTOS, entwickelt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adam Dunkels</a> , dem Entwickler bekannter TCP / IP-Stacks wie lwIP und uIP.  Ich w√ºrde sagen, dass das gesamte Betriebssystem um den Netzwerkstapel herum aufgebaut ist.  Das Vorhandensein von IPv6-Unterst√ºtzung und die geringen Ressourcenanforderungen machen dieses Projekt f√ºr die Erstellung verschiedener Arten von drahtlosen Ger√§ten interessant. <br><br><h4>  RTEMS </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTEMS</a> Real-Time Executive f√ºr Multiprozessorsysteme.  Urspr√ºnglich f√ºr das Milit√§r entwickelt, steht das Akronym f√ºr Real-Time Executive f√ºr Missile Systems und dann f√ºr Real-Time Executive f√ºr Military Systems.  Ziemlich altes, aber immer noch lebhaftes Open Source-Projekt.  Heller Vertreter des libOS-Ansatzes.  Wenn die entwickelte Software mit einem bereits zusammengestellten Betriebssystem verkn√ºpft ist, ist dies nicht nur der Kernel, sondern auch alle verf√ºgbaren Dienste.  Es wird kompiliert und als Bibliothek an den Compiler geliefert, was in den fr√ºhen Entwicklungsstadien sehr praktisch ist. <br><br><h4>  eCos </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eCos</a> Embedded konfigurierbares Betriebssystem.  Auch ein ziemlich altes Projekt, bisher sehr beliebt.  Die Hauptidee ist, ein sehr konfigurierbares Betriebssystem zu erstellen, dh nur das in den Kernel aufzunehmen, was Sie ben√∂tigen. <br><br><h4>  Andere RTOSes </h4><br>  Die Liste geht noch einige Zeit weiter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich</a> werde unten ein weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuttX-</a> Projekt erw√§hnen.  Und f√ºr diejenigen, die an einer detaillierteren Liste interessiert sind, empfehle ich Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> anzuschauen.  F√ºr Mikrocontroller w√ºrde ich auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChibiOS / RT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MicroC / OS (¬µC / OS)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nut / OS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RIOT</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erw√§hnen</a> .  Aber nat√ºrlich h√§ngt alles von der Aufgabe ab. <br><br><h2>  Arduino </h2><br>  Ich denke, √ºber Embedded zu sprechen w√§re unvollst√§ndig, ohne Arduino zu erw√§hnen.  Schlie√ülich sind sie wie RaPi sehr verbreitet und haben wesentlich zur Popularisierung von Mikrocontrollern beigetragen.  Ich selbst bin ziemlich skeptisch gegen√ºber dem Arduino-Thema, daher werde ich Kritik an Fans dieser Technologie √ºberspringen.  Aber √ºber die Tatsache, dass dies eine sehr interessante Technologie ist, kann ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel f√ºr eine Brotmaschine geben, die auf einem Hub beschrieben wird</a>  Sehr sch√∂ne L√∂sung.  Nun, oder das bereits zitierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel mit einem Roboter, der eine Linie von openCV erkennt</a> , aber auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino</a> wird dort verwendet. <br><br><h2>  Mikrokernel </h2><br>  Ich habe das Konzept eines Mikrokernels noch nie erw√§hnt, der, wie viele wissen, das System zuverl√§ssig und vorhersehbar macht.  Dies ist einerseits wahr, andererseits aber wie immer nicht ganz.  Genauer gesagt ist es nat√ºrlich wahr, aber der Glaube, dass dieses Konzept (Architektur) Ihr System sofort in ein hartes Echtzeitsystem verwandeln wird, ist eine T√§uschung.  Es ist eher ein Marketing-Slogan: "Wir sind ein Echtzeitsystem, weil wir auf dem Prinzip eines Mikronukleus aufbauen."  Das Prinzip eines Mikrokernels erm√∂glicht es jedoch lediglich, die Softwareentwicklung zu vereinfachen, da die meisten Teile im Benutzerbereich ausgef√ºhrt werden.  Aber was ist, wenn Sie einen kaputten Server haben, der f√ºr die Arbeit notwendig ist?  Sie starten es neu, aber es braucht Zeit, und wenn Sie es nicht haben?  Dar√ºber hinaus hat die klassische Mikrokernel-Architektur ihre Nachteile!  Zum Beispiel ist es langsam, weil es viele Systemaufrufe gibt (Nachrichten√ºbertragung zwischen Servern und Anwendungssoftware).  Andernfalls h√§tte vor langer Zeit jeder auf eine reine Mikrokernel-Architektur umgestellt, und wer zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekte auf L4 gesehen hat</a> , aber das sind sie.  Nun, und nat√ºrlich erinnern sich viele an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auseinandersetzung von Linus Torvalds mit Andrew Tanenbaum</a> . <br><br>  Das hei√üt, das Konzept eines Mikronukleus ist keine Silberkugel.  Aber als sehr gute Idee wird es in den meisten modernen Betriebssystemen bis zu dem einen oder anderen Grad angewendet.  Und die Schaffung eines zuverl√§ssigen Systems h√§ngt letztendlich immer noch vom Endentwickler und den F√§higkeiten ab, die das Betriebssystem f√ºr seine Konstruktion bereitstellt. <br><br><h2>  Embox's Platz in der Welt der eingebetteten Systeme </h2><br>  Ich habe bereits viel √ºber verschiedene Aspekte der eingebetteten Welt gesprochen, bin aber nie an den Ort von Embox gekommen.  Nun, ich kann sagen, dass in den oben beschriebenen Beispielen m√∂glicherweise keine Verwendung von Embox erforderlich ist.  Au√üerdem fragen wir Benutzer normalerweise, warum sie Embox ben√∂tigen.  Wenn die Verwendung von Embox keine Vorteile bietet, empfehlen wir, etwas aus der obigen Liste oder etwas anderes (z. B. Android) auszuprobieren.  Es gibt jedoch eine Reihe von F√§llen, in denen die Verwendung von Embox einen sp√ºrbaren Gewinn bringt. <br><br><h3>  Ger√§teentwicklungssystem </h3><br>  Ich werde mit der ersten Verwendung von Embox beginnen.  Er war damals noch nicht einmal eine Embox, sondern eine Art C- und Assembler-Code, mit dem Sie sehr schnell starten und n√ºtzlichen Code ausf√ºhren konnten.  In diesem Moment war es ein Projekt, das Ingenieuren beim Debuggen von Ger√§ten helfen sollte, die an FPGAs entwickelt wurden.  Er wusste, wie man sehr schnell l√§uft, viel schneller als √§hnlicher Code, der mit dem bereits erw√§hnten RTEMS geschrieben wurde.  ,         .        ‚Äú‚Äù,      ,     .     ,      TCL,      .             (   ),        . <br><br><h3>  Linux </h3><br>            .   ,   ,   :    (UDP),  ,    .          Linux.     x86   ARM.   .   ,    ,        .    Linux,    500 .  ,      #ifdef   .  ,     ,    . Embox       ,            .        Mybuild,         ,   .     ,          (  ) ,          . <br><br><h3> Linux  Linux </h3><br>      .       Linux,   -         .  Embox             Linux.       ,  Qt (embedded-)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   SIP-</a> .  ,    Embox    ,      . <br><br>   POSIX-             ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuttX</a> .  -     Embox,  - ‚Äî .   Qt  SIP-,   , NuttX   .     . <br><br>   ,   RTOS    POSIX. , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRTOS</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://archive.today/20130103183712/">RTEMS,       POSIX Profile 52,  ¬´ ,  ,  ¬ª</a> .  RTEMS       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt  </a> <br><br><h3>  Linux </h3><br>            RTOS,        ,   ,       ,   . ,  Linux      ,  -         ( ,  ,     .).  ,    ,  ,  ,      ,    .            . , ,       - , , ,    ,      . ,      ,  ,  .        ,      . <br><br><h3> Linux   </h3><br>       Linux     .     ,     .  ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     OpenCV</a> .    ,    ,  OpenCV   RaPi,        Arduino.     :  ‚Äî ,  ‚Äî ,      ,     Linux    .    ,  Embox         Linux.          OpenCV ,   . <br><br>   ,      Linux     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> ‚Äî  ,    -,     </a> .         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . <br><br><h3> Internet of Things </h3><br> Embox,     RTOS  ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>        stm32vl-discovery.  Embox   16- MSP-430 c 512  .   , ,      ,  ,      POSIX-,      (light threads). ,        , ,        .  ‚Äú‚Äù       IoT.         .      - .         Embox,   ,   ,  ,    .  -,  ,        ,    ,            .  -,        ,      . <br><br>                <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   CodeFreeze</a> . <br><br><h2>  Fazit </h2><br>         embedded .        , , , -.       ,       ‚Äú‚Äù   embedded. ,    ,   ,   - !        . <br><br> PS   , Embox   ‚Äúembedded‚Äù,    ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">opensource</a> ‚Äù.  ,        ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440390/">https://habr.com/ru/post/de440390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440376/index.html">20 Spiele, um Ihrem Kind das Programmieren beizubringen</a></li>
<li><a href="../de440378/index.html">Zur√ºck zu Microservices mit Istio. Teil 2</a></li>
<li><a href="../de440382/index.html">Ist 200 gut oder schlecht?</a></li>
<li><a href="../de440386/index.html">Fehlerbehebung durch Fehlerbehebung</a></li>
<li><a href="../de440388/index.html">Intervalle: Die bevorstehende C ++ - Evolution</a></li>
<li><a href="../de440392/index.html">WebRTC auf Ihrer Website - keine Fehler und kein Budget</a></li>
<li><a href="../de440394/index.html">Eskalation von PostgreSQL-Berechtigungen - CVE-2018-10915-Analyse</a></li>
<li><a href="../de440398/index.html">Geschichte der Teilnahme (und des Sieges) am russischen AI Cup 2018 - CodeBall</a></li>
<li><a href="../de440400/index.html">Apache Kafka + Spring Boot: Hallo, Microservices</a></li>
<li><a href="../de440402/index.html">SearchFace-Entwickler √ºber Algorithmusfunktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>