<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚆 👁‍🗨 ⛳️ Die vielfältige Welt der eingebetteten Systeme und der Platz von Embox darin 👩🏽‍🤝‍👩🏼 ✋🏽 💢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Embox- Projekt ist bereits 9 Jahre alt geworden, aber viele verstehen nicht, was es ist und womit es gegessen wird und warum es benötigt wird. Ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die vielfältige Welt der eingebetteten Systeme und der Platz von Embox darin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/440390/"><img src="https://habrastorage.org/webt/ep/jc/qp/epjcqpyctt_7bt0cwewzqkz1iyg.jpeg" align="right" width="320">  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox-</a> Projekt ist bereits 9 Jahre alt geworden, aber viele verstehen nicht, was es ist und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">womit</a> <s>es gegessen wird und</s> warum es benötigt wird.  Einige von denen, die von dem Projekt gehört haben und wissen, dass dies ein Betriebssystem ist, glauben, dass Embox ein „inländisches Betriebssystem“ ist.  In der Tat wurde Embox als Versuch konzipiert, "ihr" Betriebssystem mit "Blackjack und Booten" zu erstellen, aber die Hauptsache ist "Blackjack und Boote".  Das heißt, bestimmte Merkmale oder deren Kombination, die in anderen Projekten fehlten, wurden in den Vordergrund gestellt. <br><br>  Natürlich würde auch mit einigen Chips niemand ein universelles Betriebssystem schreiben.  Der Slogan Embox - „Wesentliche Toolbox für die eingebettete Entwicklung“ - impliziert, dass das Projekt auf eingebettete Systeme ausgerichtet ist.  Dieses Konzept ist jedoch sehr weit gefasst und umfasst: das Internet der Dinge (IoT) und Roboter, verschiedene Himbeeren (RaPi) und Bordsysteme, Arduinki und ASU-TP, ...  Wie Sie wissen, kann die Liste sehr lange dauern, es gibt Orte, an denen Linux großartig lebt, und es gibt Orte, an denen Linux redundant ist und verschiedene kleine RTOS verwendet werden.  In diesem Artikel möchte ich über die eingebettete Welt in all ihrer Vielfalt und auch über den Platz von Embox darin sprechen. <br><a name="habracut"></a><br><h2>  Single Board Computer </h2><br><h3>  Industriecomputer </h3><br>  Beginnen wir mit Single-Board-Computern.  Viele von ihnen werden im Industriedesign hergestellt.  Die meisten basieren auf Prozessoren mit ARM- und x86-Architekturen.  Viele Leute denken, dass x86-Prozessoren in diesem Segment nicht verwendet werden, und alles beschränkt sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Himbeeren</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beagleboards</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bananen</a> und so weiter.  Doch lange vor RaPi gab es andere Single-Board-Maschinen für das industrielle PC-Segment, den sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PC / 104-</a> Formfaktor.  Sie waren in ihrer Leistung schlechter als herkömmliche Desktops, da sie für Aufgaben gedacht waren, bei denen Zuverlässigkeit Vorrang vor Funktionalität hat.  Aus dem gleichen Grund wurde Linux nicht oft als Betriebssystem für diese Hardwareplattformen verwendet. Es gab verschiedene proprietäre Betriebssysteme mit Echtzeit-Eigenschaften ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VxWorks</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QNX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LynxOS</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usw.</a> ).  Ich habe „RTOS“ (zu dem ich alle drei Betriebssysteme beziehe) nicht geschrieben, weil sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows CE</a> und die Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Embedded häufig</a> auf diesen Hardwareplattformen befanden.  Und ich drehe nicht die Zunge, um diesen ganzen Zoo dem RTOS zuzuschreiben. <br><br><h3>  Einzelzahler für Verbraucher </h3><br>  Malinki setzte einen ganz anderen Trend.  Sie richten sich in der Tat nicht an industrielle Echtzeitsysteme, sondern an das Verbrauchersegment, in dem das Preis-Leistungs-Verhältnis bewertet wird, und Himbeeren (und Analoga) sind in diesem Parameter ihren Wettbewerbern deutlich voraus.  Wenn Sie für 30 bis 50 US-Dollar kaufen, erhalten Sie schließlich eine vollwertige Systemeinheit, mit der Sie mit Linux-Tools problemlos ein Gerät mit ziemlich komplizierten Funktionen erstellen können.  Dies ist sehr nützlich für Prototyping oder DIY.  Außerdem kann Himbeere natürlich als PC oder kleiner Server verwendet werden.  Daher werden häufig vorgefertigte Linux-Distributionen als Betriebssystem verwendet, zunächst natürlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raspbian</a> - Debian für Raspberry Pi oder eine Distribution mit einem lustigen Namen für die russischsprachigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pidora</a> - Fedora für RaspberryPi.  Für andere ähnliche Plattformen gibt es auch vorgefertigte Distributionen, die sowohl von Geräteherstellern als auch von Betriebssystemgemeinschaften (Herstellern) bereitgestellt werden.  Stimmen Sie zu, wenn Sie einen Prototyp erstellen müssen, ist es am einfachsten, vorgefertigte Pakete zu instruieren und Funktionen in Python zu schreiben.  So erhalten Sie schnell einen funktionierenden Prototyp.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispiel ist ein Roboter, der eine Linie mit OpenCV erkennt</a> . <br><br><h2>  Linux in eingebetteten Geräten </h2><br>  Die eingebettete Welt ist jedoch viel breiter als Standard-ARM-Einplatinenkarten.  Darüber hinaus machen sie einen relativ kleinen Teil der Geräte aus, und ihr Hauptbeitrag ist die Popularisierung und Vereinfachung des Einstiegs in die Entwicklung von Geräten dieser Klasse.  Serielle Geräte werden auf der Grundlage derselben Prozessoren (Systeme auf einem Chip) oder ähnlichem erstellt, die Karten sind jedoch für die Aufgabe (Projekt, Gerät) ausgelegt.  Folglich sind Standarddistributionen zumindest redundant, da sie häufig eine Art Paketmanager verwenden und Sie leicht viele interessante Informationen liefern können (die jedoch für die Lösung einer bestimmten Aufgabe nicht erforderlich sind).  Eingebettete Geräte verfügen normalerweise über vollständige Funktionen und werden sogar als Firmware bezeichnet.  Es gibt eine andere Klasse von Linux-Distributionen zum Erstellen von Firmware.  Mit solchen Distributionen können Sie die erforderlichen Pakete statisch installieren, indem Sie sie im Root-Dateisystem und nicht dynamisch zusammenstellen, indem Sie den Paketmanager aus dem Repository verwenden.  In der Regel können diese Distributionen nicht nur Anwendungsanwendungen und Bibliotheken, sondern auch den Kernel in einer bestimmten Konfiguration erstellen.  Und oft auch ein Cross-Compiler, weil das Kompilieren auf dem Gerät selbst zumindest nicht effektiv ist. <br><br><h3>  Yocto-Projekt </h3><br>  Bis heute ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yocto-Projekt</a> die bekannteste Distribution dieser Art (ein Projekt zum Erstellen von Distributionen).  Es basiert wiederum auf einem anderen bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenEmbedded-</a> Projekt, das eine Art Build-System für Linux-Distributionen darstellt.  Wenn Sie den Raspberry Pi nicht als fertiges kleines System, sondern als benutzerdefiniertes Gerät unter Linux verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">möchten</a> , sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yocto</a> oder seine Analoga eine gute Option.  Persönlich sehe ich keine großen Vorteile darin, nicht standardmäßige Linux-Distributionen mit Standard-Eisenstücken zu verwenden. Wenn Sie jedoch ähnliche Geräte entwickeln möchten oder die Technologien selbst erlernen möchten, ist dieser Ansatz am vielversprechendsten.  Schließlich können Programmierer während der Entwicklung einer speziellen Hardware ihre Systemteile (Algorithmen, Treiber, Bibliotheken usw.) entwickeln und debuggen.  Dies reduziert die Entwicklungszeit und damit das berüchtigte TTM (Time-to-Market) erheblich. <br><br><h3>  Openwrt </h3><br>  Ein weiteres bekanntes Linux-basiertes Firmware-Projekt ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenWRT</a> .  Ich bin sicher, dass diejenigen, die Spaß am Anpassen von Routern haben, von ihm gehört haben.  Basierend auf diesem Projekt wird Firmware für verschiedene Router erstellt, die eine Binärdatei sind, einschließlich des Kernels und des Root-Dateisystems.  Die Verwendung von Firmware (anstelle von universellen Distributionen) in eingebetteten Systemen hängt mit der Idee zusammen, dass die Funktionalität des endgültigen Systems zum Zeitpunkt seiner Entwicklung bekannt ist, dh, selbst wenn die Router-Version aktualisiert wird, ändert sich die Firmware vollständig mit allen Funktionen (oder ein Teil dieser Firmware wird auf besondere Weise ersetzt )  Die Installation von beispielsweise Bürosuiten ist normalerweise nicht erforderlich und häufig generell verboten, da dies zu einer eigenen Unsicherheit führen kann.  Dieser Ansatz ermöglicht unter anderem eine erhebliche Einsparung an Hardware.  Dieselben Router haben beispielsweise einen viel weniger leistungsstarken Prozessor und viel weniger Speicher als Universaldrüsen. <br><br><h2>  Echtzeitsysteme </h2><br>  Um auf das Thema Industrierechner zurückzukommen, muss der Begriff „Echtzeitsystem“ erörtert werden.  Viele Leute denken, dass Echtzeitsysteme schneller sind.  Dies ist ein Irrtum.  Wahrscheinlich ist es mit historischen Räumlichkeiten verbunden.  Immerhin entstand der Begriff selbst, als Autos langsam waren.  Und der Benutzer bemerkte, dass die Reaktion des Systems möglicherweise hinter seinen Aktionen zurückbleibt.  Der Begriff „Echtzeit“ bedeutete, dass das System auf alle Einflüsse, einschließlich Bedieneraktionen, reagieren musste.  Auf modernen Computern ist es jedoch unwahrscheinlich, dass der Benutzer (Bediener) eine Hemmung bemerkt.  In den allermeisten Fällen wird beim Klicken auf Menü, Symbol und Schaltfläche sofort eine Neuzeichnung des Bildschirms angezeigt, es sei denn, natürlich ist alles in Ordnung (das Internet ist vorhanden, der Vorgang hängt nicht usw.).  Wenn jedoch etwas Unerwartetes passiert ist, zum Beispiel die Verbindung unterbrochen wird, werden wir sehen, wie sich Echtzeitsysteme unterscheiden (sollten sich unterscheiden).  Wir werden einfach das normale Smartphone neu starten.  Aber wenn dieses System das Kraftwerk steuert, dann verstehen Sie selbst, dass dies nicht immer möglich ist.  Daraus schließen wir, dass das Echtzeitsystem vorhersehbar und nicht schnell auf ein Ereignis oder eine Reihe von Ereignissen reagieren sollte, unabhängig von seinem Zustand und seiner Umgebung. <br><br><h3>  Linux in Echtzeitsystemen </h3><br>  Natürlich gab (und gibt) es Versuche, aus Linux ein Echtzeitsystem zu machen.  Das bekannteste ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTLinux</a> , ursprünglich war es ein Patch für Linux, der den ursprünglichen „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">völlig ehrlichen Scheduler</a> “ ersetzte, genauer gesagt, einen eigenen einfügte, eine der Aufgaben, die vom Linux-Scheduler festgelegt wurden.  Dieser Scheduler arbeitete an statischen Aufgabenprioritäten und dementsprechend viel vorhersehbarer.  Aber es war nicht mehr Linux, oder besser gesagt, die Linux-Funktionalität war nicht in Echtzeit. <br><br><h3>  ARINC-653 </h3><br>  Ein weiterer Ansatz zur Bereitstellung von Echtzeit, der dem RT-Patch für Linux ähnelt, ist der Ansatz, der vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ARINC653-</a> Standard oder vom sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MILS-</a> Ansatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefordert wird</a> .  Dieser Ansatz impliziert, dass das System in Schichten aufgebaut ist, die untere Schicht impliziert einen sehr leichten Hypervisor, auf dessen Grundlage Aufgaben mit unterschiedlichem Kritikalitätsgrad in statisch definierten Abschnitten ausgeführt werden.  Ich habe den Hypervisor als sehr leicht bezeichnet, weil er impliziert, dass er die höchste Kritikalität aufweist und daher sein Code (Algorithmen) so vollständig wie möglich überprüft werden sollte (im Idealfall sollte das Fehlen unverarbeiteter Situationen mathematisch bewiesen werden).  Daher sollte der Code so klein wie möglich sein.  Nun, und Linux befindet sich, wie Sie wahrscheinlich verstanden haben, in einem eigenen Bereich. <br><br><h3>  uCLinux </h3><br>  Versuche, Linux in eingebetteten Systemen zu verwenden, haben vor langer Zeit begonnen.  Einer der ersten war der Versuch, Linux in Systemen zu verwenden, in denen keine Hardwareunterstützung für virtuellen Speicher (MMU) vorhanden ist.  Dieses Projekt hieß <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uCLinux</a> und sein Beitrag zum Linux-Kernel war der <a href="">NOMMU-</a> oder MMU- <a href="">freie</a> Modus. <br><br><h3>  Linux in Echtzeitsystemen </h3><br>  Um die Versuche, Linux in Echtzeitsystemen zu verwenden, zusammenzufassen, müssen Sie die Frage beantworten, warum dies geschieht.  Das heißt, einerseits ist Linux (im Moment und in seiner reinen Form) nicht speziell für Echtzeitsysteme angepasst, und andererseits wird ständig versucht, dies zu tun.  Dies geschieht aufgrund der Einführung von Einschränkungen (Ersetzen des Schedulers, Einführung eines Hypervisors, Einschränkungen bei der Verwendung des virtuellen Speichers usw.).  Die Antwort liegt meiner Meinung nach in der Anwesenheit von Linux, einer gigantischen Codebasis.  Dies sind Treiber, dies sind funktionale Anwendungen und Bibliotheken.  Wenn Sie ein zuverlässiges System erstellen möchten, sollten Sie natürlich so viele vorgefertigte Teile wie möglich verwenden, da die Entwicklung neuer Teile, ob Funktionslogik oder Treiber, immer die Wahrscheinlichkeit eines Fehlers enthält.  Und da moderne Echtzeitsysteme ziemlich hohe funktionale Anforderungen haben, wird die Wiederverwendung vorgefertigter Funktionen unter Linux immer verlockender.  Mit anderen Worten, ein Upgrade von Linux auf ein Echtzeitsystem scheint im Vergleich zur Entwicklung von Funktionen nicht so teuer zu sein, obwohl es auf einem Echtzeitbetriebssystem basiert, da die Zuverlässigkeit des gesamten Systems und nicht nur seines Teils in Form des Kernels des Betriebssystems zuverlässig sein muss. <br><br><h3>  Windows in eingebetteten Geräten </h3><br>  Ich möchte für eine Weile zu Windows zurückkehren.  Zu Beginn meiner Karriere hatte ich eine Diskussion mit einem erfahreneren Entwickler, dass Windows nicht in zuverlässigen Systemen verwendet werden kann.  Wenn Sie ein bereits fertiggestelltes System mit der erforderlichen funktionalen Software testen und Änderungen verbieten: Updates, Softwareinstallation usw., ist das System für viele Aufgaben, einschließlich der von uns, zuverlässig genug entschieden.  Jetzt habe ich keinen Zweifel daran, dass mein Gegner Recht hatte, nicht ich.  Darüber hinaus wird sogar das alte MS-DOS seit sehr langer Zeit in industriellen Systemen verwendet.  Tatsache ist, dass Multitasking, das so notwendig erscheint, Unsicherheit mit sich bringt.  Und wenn Sie Software ausführen, die das gesamte System vollständig steuert, können Sie ein viel deterministischeres Verhalten erzielen.  Mit anderen Worten, wenn sich eine unbestimmte Anzahl von Aufgaben im System dreht, ist es unwahrscheinlich, dass es möglich ist, Sicherheit in der Arbeit aller Funktionen des Systems zu erreichen.  Der einfachste Weg, die Vorhersagbarkeit des Systems zu verbessern, besteht daher darin, seine Funktionalität und damit die Ablehnung der Universalität zur Laufzeit einzuschränken.  Was wir in der Tat in den oben erwähnten Beispielen für die Verwendung von Linux in Echtzeitsystemen beobachten. <br><br><h2>  Mikrocontroller </h2><br>  Das Beispiel von MS-DOS als Basisbetriebssystem für industrielle Echtzeitsysteme führt uns zu der Idee, dass Sie ein vorhersehbares Verhalten des gesamten Systems erzielen können, wenn Sie nur Ihre eigene Software verwenden.  Und das ist es wirklich!  Richtig, Sie müssen reservieren, dass dies nur möglich ist, wenn die Funktionalität des Systems klein und klar festgelegt ist.  Wenn die gesamte Funktionalität des Systems darin besteht, den Motor über das GPIO zu steuern und einen begrenzten Satz von Befehlen über die UART-Schnittstelle zu empfangen (zu senden), ist es nicht erforderlich, das Betriebssystem zu verwenden. Sie können eine Firmware erstellen (was als Bare-Metal bezeichnet wird).  Dieser Ansatz wird häufig in Mikrocontrollern verwendet.  Da die Mikrocontroller jedoch groß wurden (32-Bit-ARM mit mehreren KB RAM gegenüber 8-Bit-AVR-OK mit 100 Byte RAM), nahmen die Anforderungen an die Funktionalität zu.  Bei der Entwicklung von Firmware wird mindestens Software von Herstellern verwendet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sodass</a> Sie einige vorgefertigte Beispiele für die Arbeit mit einem Mikrocontroller verwenden können, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32Cube</a> . <br><br><h3>  RTOSes </h3><br>  Da die Anforderungen an die Funktionalität jedoch ständig steigen, wird die Firmware für Mikrocontroller zunehmend auf Basis des sogenannten RTOS erstellt.  Im Gegensatz zu großen Echtzeitbetriebssystemen handelt es sich hierbei um relativ kleine Open Source-Projekte, die vollen Zugriff auf den gesamten Code im System bieten.  Das heißt, es gibt eine Kombination von Konzepten: Zum einen wird vorgefertigter Code verwendet, zum anderen hat der Entwickler vollen Zugriff auf alles im System, man kann sagen Bare-Metal-Firmware. <br><br>  Es gibt ziemlich viele RTOS für Mikrocontroller.  Daher ist es unmöglich, über alle zu sprechen.  Ich werde meiner Meinung nach nur einige interessante Projekte herausgreifen und kurz über deren Merkmale sprechen. <br><br><h4>  FreeRTOS </h4><br>  Wahrscheinlich ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRTOS</a> eines der beliebtesten RTOS-Projekte.  Einige sagen, dass dies kein vollständiges Betriebssystem ist, sondern nur ein Scheduler.  Wenn Sie jedoch die obige Diskussion über Bare-Metal, die große Anzahl unterstützter Mikrocontroller und die Tatsache berücksichtigen, dass viel Anwendungssoftware geschrieben und integriert ist, dann sieht die kleine Funktionalität eher nach einer Tugend als nach einem Nachteil aus.  Dies ermöglichte es uns, ein De-facto-Standard für Mikrocontroller zu werden, wie er auf der Projektwebsite beschrieben ist. <br><br><h4>  Contiki </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Contiki</a> - RTOS, entwickelt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adam Dunkels</a> , dem Entwickler bekannter TCP / IP-Stacks wie lwIP und uIP.  Ich würde sagen, dass das gesamte Betriebssystem um den Netzwerkstapel herum aufgebaut ist.  Das Vorhandensein von IPv6-Unterstützung und die geringen Ressourcenanforderungen machen dieses Projekt für die Erstellung verschiedener Arten von drahtlosen Geräten interessant. <br><br><h4>  RTEMS </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTEMS</a> Real-Time Executive für Multiprozessorsysteme.  Ursprünglich für das Militär entwickelt, steht das Akronym für Real-Time Executive für Missile Systems und dann für Real-Time Executive für Military Systems.  Ziemlich altes, aber immer noch lebhaftes Open Source-Projekt.  Heller Vertreter des libOS-Ansatzes.  Wenn die entwickelte Software mit einem bereits zusammengestellten Betriebssystem verknüpft ist, ist dies nicht nur der Kernel, sondern auch alle verfügbaren Dienste.  Es wird kompiliert und als Bibliothek an den Compiler geliefert, was in den frühen Entwicklungsstadien sehr praktisch ist. <br><br><h4>  eCos </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eCos</a> Embedded konfigurierbares Betriebssystem.  Auch ein ziemlich altes Projekt, bisher sehr beliebt.  Die Hauptidee ist, ein sehr konfigurierbares Betriebssystem zu erstellen, dh nur das in den Kernel aufzunehmen, was Sie benötigen. <br><br><h4>  Andere RTOSes </h4><br>  Die Liste geht noch einige Zeit weiter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich</a> werde unten ein weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuttX-</a> Projekt erwähnen.  Und für diejenigen, die an einer detaillierteren Liste interessiert sind, empfehle ich Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> anzuschauen.  Für Mikrocontroller würde ich auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChibiOS / RT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MicroC / OS (µC / OS)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nut / OS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RIOT</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwähnen</a> .  Aber natürlich hängt alles von der Aufgabe ab. <br><br><h2>  Arduino </h2><br>  Ich denke, über Embedded zu sprechen wäre unvollständig, ohne Arduino zu erwähnen.  Schließlich sind sie wie RaPi sehr verbreitet und haben wesentlich zur Popularisierung von Mikrocontrollern beigetragen.  Ich selbst bin ziemlich skeptisch gegenüber dem Arduino-Thema, daher werde ich Kritik an Fans dieser Technologie überspringen.  Aber über die Tatsache, dass dies eine sehr interessante Technologie ist, kann ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel für eine Brotmaschine geben, die auf einem Hub beschrieben wird</a>  Sehr schöne Lösung.  Nun, oder das bereits zitierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel mit einem Roboter, der eine Linie von openCV erkennt</a> , aber auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino</a> wird dort verwendet. <br><br><h2>  Mikrokernel </h2><br>  Ich habe das Konzept eines Mikrokernels noch nie erwähnt, der, wie viele wissen, das System zuverlässig und vorhersehbar macht.  Dies ist einerseits wahr, andererseits aber wie immer nicht ganz.  Genauer gesagt ist es natürlich wahr, aber der Glaube, dass dieses Konzept (Architektur) Ihr System sofort in ein hartes Echtzeitsystem verwandeln wird, ist eine Täuschung.  Es ist eher ein Marketing-Slogan: "Wir sind ein Echtzeitsystem, weil wir auf dem Prinzip eines Mikronukleus aufbauen."  Das Prinzip eines Mikrokernels ermöglicht es jedoch lediglich, die Softwareentwicklung zu vereinfachen, da die meisten Teile im Benutzerbereich ausgeführt werden.  Aber was ist, wenn Sie einen kaputten Server haben, der für die Arbeit notwendig ist?  Sie starten es neu, aber es braucht Zeit, und wenn Sie es nicht haben?  Darüber hinaus hat die klassische Mikrokernel-Architektur ihre Nachteile!  Zum Beispiel ist es langsam, weil es viele Systemaufrufe gibt (Nachrichtenübertragung zwischen Servern und Anwendungssoftware).  Andernfalls hätte vor langer Zeit jeder auf eine reine Mikrokernel-Architektur umgestellt, und wer zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekte auf L4 gesehen hat</a> , aber das sind sie.  Nun, und natürlich erinnern sich viele an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auseinandersetzung von Linus Torvalds mit Andrew Tanenbaum</a> . <br><br>  Das heißt, das Konzept eines Mikronukleus ist keine Silberkugel.  Aber als sehr gute Idee wird es in den meisten modernen Betriebssystemen bis zu dem einen oder anderen Grad angewendet.  Und die Schaffung eines zuverlässigen Systems hängt letztendlich immer noch vom Endentwickler und den Fähigkeiten ab, die das Betriebssystem für seine Konstruktion bereitstellt. <br><br><h2>  Embox's Platz in der Welt der eingebetteten Systeme </h2><br>  Ich habe bereits viel über verschiedene Aspekte der eingebetteten Welt gesprochen, bin aber nie an den Ort von Embox gekommen.  Nun, ich kann sagen, dass in den oben beschriebenen Beispielen möglicherweise keine Verwendung von Embox erforderlich ist.  Außerdem fragen wir Benutzer normalerweise, warum sie Embox benötigen.  Wenn die Verwendung von Embox keine Vorteile bietet, empfehlen wir, etwas aus der obigen Liste oder etwas anderes (z. B. Android) auszuprobieren.  Es gibt jedoch eine Reihe von Fällen, in denen die Verwendung von Embox einen spürbaren Gewinn bringt. <br><br><h3>  Geräteentwicklungssystem </h3><br>  Ich werde mit der ersten Verwendung von Embox beginnen.  Er war damals noch nicht einmal eine Embox, sondern eine Art C- und Assembler-Code, mit dem Sie sehr schnell starten und nützlichen Code ausführen konnten.  In diesem Moment war es ein Projekt, das Ingenieuren beim Debuggen von Geräten helfen sollte, die an FPGAs entwickelt wurden.  Er wusste, wie man sehr schnell läuft, viel schneller als ähnlicher Code, der mit dem bereits erwähnten RTEMS geschrieben wurde.  ,         .        “”,      ,     .     ,      TCL,      .             (   ),        . <br><br><h3>  Linux </h3><br>            .   ,   ,   :    (UDP),  ,    .          Linux.     x86   ARM.   .   ,    ,        .    Linux,    500 .  ,      #ifdef   .  ,     ,    . Embox       ,            .        Mybuild,         ,   .     ,          (  ) ,          . <br><br><h3> Linux  Linux </h3><br>      .       Linux,   -         .  Embox             Linux.       ,  Qt (embedded-)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   SIP-</a> .  ,    Embox    ,      . <br><br>   POSIX-             — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuttX</a> .  -     Embox,  - — .   Qt  SIP-,   , NuttX   .     . <br><br>   ,   RTOS    POSIX. , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRTOS</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://archive.today/20130103183712/">RTEMS,       POSIX Profile 52,  « ,  ,  »</a> .  RTEMS       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt  </a> <br><br><h3>  Linux </h3><br>            RTOS,        ,   ,       ,   . ,  Linux      ,  -         ( ,  ,     .).  ,    ,  ,  ,      ,    .            . , ,       - , , ,    ,      . ,      ,  ,  .        ,      . <br><br><h3> Linux   </h3><br>       Linux     .     ,     .  ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     OpenCV</a> .    ,    ,  OpenCV   RaPi,        Arduino.     :  — ,  — ,      ,     Linux    .    ,  Embox         Linux.          OpenCV ,   . <br><br>   ,      Linux     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> —  ,    -,     </a> .         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . <br><br><h3> Internet of Things </h3><br> Embox,     RTOS  ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>        stm32vl-discovery.  Embox   16- MSP-430 c 512  .   , ,      ,  ,      POSIX-,      (light threads). ,        , ,        .  “”       IoT.         .      - .         Embox,   ,   ,  ,    .  -,  ,        ,    ,            .  -,        ,      . <br><br>                <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   CodeFreeze</a> . <br><br><h2>  Fazit </h2><br>         embedded .        , , , -.       ,       “”   embedded. ,    ,   ,   - !        . <br><br> PS   , Embox   “embedded”,    “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">opensource</a> ”.  ,        ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440390/">https://habr.com/ru/post/de440390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440376/index.html">20 Spiele, um Ihrem Kind das Programmieren beizubringen</a></li>
<li><a href="../de440378/index.html">Zurück zu Microservices mit Istio. Teil 2</a></li>
<li><a href="../de440382/index.html">Ist 200 gut oder schlecht?</a></li>
<li><a href="../de440386/index.html">Fehlerbehebung durch Fehlerbehebung</a></li>
<li><a href="../de440388/index.html">Intervalle: Die bevorstehende C ++ - Evolution</a></li>
<li><a href="../de440392/index.html">WebRTC auf Ihrer Website - keine Fehler und kein Budget</a></li>
<li><a href="../de440394/index.html">Eskalation von PostgreSQL-Berechtigungen - CVE-2018-10915-Analyse</a></li>
<li><a href="../de440398/index.html">Geschichte der Teilnahme (und des Sieges) am russischen AI Cup 2018 - CodeBall</a></li>
<li><a href="../de440400/index.html">Apache Kafka + Spring Boot: Hallo, Microservices</a></li>
<li><a href="../de440402/index.html">SearchFace-Entwickler über Algorithmusfunktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>