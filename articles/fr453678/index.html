<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐁 📒 🌐 Comment voir la réverbération ou la transmission vidéo par le son dans l'eau - 2 👈🏾 ⏏️ 📃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour cher! 

 Aujourd'hui, nous transmettrons à nouveau l'image aux ultrasons dans l'eau: nous verrons littéralement la réverbération et l'écho, et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment voir la réverbération ou la transmission vidéo par le son dans l'eau - 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453678/"><h3>  Bonjour cher! </h3><br><br>  Aujourd'hui, nous transmettrons à nouveau l'image aux ultrasons dans l'eau: nous verrons littéralement la réverbération et l'écho, et même leur évolution en fonction des conditions.  Tout ce que je vais vous dire est simple, il est intéressant de le répéter moi-même et peut être fait par presque n'importe qui. <br><br>  Si quelque chose flotte dans votre âme à cause de ces mots, bienvenue à Kat, dans les eaux sombres de notre étang! <br><br><img src="https://habrastorage.org/webt/e7/dd/ql/e7ddqlsffkcu34ex7scxfsvt4fs.png"><br><a name="habracut"></a><br><br><blockquote>  "Le meilleur repos est d'interpréter des vérités bien connues."  (C) ABS, midi, XXIIe siècle </blockquote><br><br><h3>  Foreplay </h3><br>  La règle de base du club des témoins de l'hydroacoustique est que la vidéo utilisant l'hydroacoustique à une distance plus ou moins importante (plus de quelques mètres) dans le milieu de l'eau ne peut pas être transmise, et sera toujours impossible. <br>  Il y a de sérieuses raisons à cela - un canal de communication avec une très faible bande passante, une faible vitesse de propagation du signal (dans l'eau seulement 1 500 m / s) et une forte probabilité d'erreur.  La bande de fréquences disponible n'est que de quelques dizaines de kilohertz. <br>  Mais ce n'est pas tout - si, relativement parlant, un signal à des fréquences de l'ordre de 10 kHz se propage dans l'eau à une distance d'environ 8-10 km, alors à une fréquence de 20 kHz il est déjà de 3 à 5 km, et plus la fréquence est élevée, plus l'atténuation est forte .  Par exemple, nos plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petits</a> modems <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">uWAVE</a> au monde fonctionnent dans la bande 20-30 kHz et transmettent des données à une vitesse de 78 bit / s par 1000 mètres, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RedLINE</a> avec une bande de 5-15 à 8000 mètres.  Le record parmi les appareils commerciaux appartient à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EvoLogics</a> - 68 kBits par 300 mètres. <br>  La physique, hélas, ne peut pas être trompée et il est impossible d'être d'accord avec elle - elle peut être transmise très lentement et insensible au bruit, ou rapidement, mais sur de courtes distances. <br>  Cependant, dans certains cas, il est possible de «couper certains coins», lesquels coins que nous allons couper cette fois sont plus bas. <br><br><h3>  Que ferons-nous aujourd'hui et que faut-il pour cela? </h3><br>  Dans les articles précédents, nous avions déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transmis de la «vidéo» avec du son à travers l'eau</a> , je vous rappelle que là la trame était «tracée sur le spectre», c'est-à-dire que le spectre, ou plutôt le spectrogramme du signal était une image. <br>  Plus tard, nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fabriqué de simples antennes hydroacoustiques à partir de déchets</a> et fabriqué le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modem hydroacoustique</a> le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus simple</a> .  Là, nous avons également fait un préampli pour l'antenne (la conception du PCB pour l'auto-production par LUT-ohm est toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">là</a> ). <br><br>  Nous avons pensé comment autrement vous pourriez essayer de transmettre l'image afin que même un élève de <s>maternelle</s> puisse le comprendre, et comme il nous semble, ils ont trouvé un moyen encore plus simple qu'auparavant. <br><br>  Donc, pour résumer, établissez une liste de ce dont nous avons besoin: <br><br>  - une paire d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">antennes sonar de pie pickers</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">préamplificateur</a> fabriqué par LUT <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source du</a> projet C # <br>  - une paire de batteries au plomb à 12 volts <br>  - un amplificateur sur TDA, j'en ai pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> pour seulement 50 roubles sur Ali <br><br><h3>  Un peu de théorie </h3><br>  Rappelons que notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modem sonar</a> était basé sur un simple détecteur de tonalité, dont la fréquence est 4 fois inférieure à la fréquence d'échantillonnage.  Rappelez brièvement comment cela fonctionne. <br><img src="https://habrastorage.org/webt/__/zm/oe/__zmoe1u0jzgjderykrsaogn0k8.png"><br><br>  L'image montre deux oscillations décalées l'une par rapport à l'autre sur Pi / 2 - c'est-à-dire les phases sinus et cosinus.  Et si la fréquence est exactement quatre fois inférieure à la fréquence d'échantillonnage, alors seulement 4 échantillons tombent sur la période. <br>  Un habuchitel attentif a certainement remarqué que les deux signaux sont décalés vers Pi / 4.  Avec ce décalage, le signal ne prend que deux valeurs: √2 / 2 et -√2 / 2. <br>  Et les valeurs spécifiques ne sont même pas importantes, il est important que vous ne puissiez utiliser que les signes: "+" et "-". <br><br>  Maintenant, nous pouvons représenter la phase sinusoïdale comme une séquence de signes "+" "+" "-" "-", et la phase cosinusoïdale comme "+" "-" "-" "+". <br><br><div class="spoiler">  <b class="spoiler_title">Sous le becquet, répétez le détecteur:</b> <div class="spoiler_text"> Que le signal d'entrée soit dans le tampon sn, nous avons deux tampons de moyenne en anneau pour les phases sinus et cosinus - bs et bc de taille N. Ils ont des pointeurs de tête et de queue communs - bH et bT.  Au moment initial du temps, bH = N-1, bT = 0. Compteur de cycle de moyenne C = 0. <br>  Nous prenons 4 échantillons du tampon d'entrée et les ajoutons en fonction des séquences de caractères. <br><br> <code>a = sn(i) <br> bs(bH) = a <br> bc(bH) = a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+1) <br> bs(bH) = a <br> bc(bH) = -a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+2) <br> bs(bH) = -a <br> bc(bH) = -a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+3) <br> bs(bH) = -a <br> bc(bH) = a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br></code> <br><br>  Après avoir traité chacun quatre échantillons, nous vérifions le compteur des cycles de moyenne et s'il a dépassé N, nous calculons ensuite l'amplitude de la porteuse cA: <br><br> <code>if ++cycle &gt;= N <br> cA = sqrt(s1 * s1 + s2 * s2) <br> cycle = 0 <br> end <br></code> <br></div></div><br><br>  Nous prenons cette méthode comme base, elle sera chargée de la «synchronisation». <br>  Voyons maintenant comment l'image est encodée.  Je suggère d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la manipulation d'amplitude</a> .  La manipulation se produit lorsqu'un signal est divisé en segments égaux appelés puces ou symboles, et qu'un certain paramètre variable (dans notre cas, l'amplitude) est stocké sur la longueur de la puce. <br>  Si, par exemple, nous pouvons faire varier l'amplitude dans la plage de 0 à 32767 (échantillons 16 bits), et que nous devons transmettre 255 valeurs de luminosité des pixels, puis par unité de changement de luminosité du pixel, l'amplitude de la puce passera à 32768/255 = 128. <br>  Un autre paramètre important est la longueur de la puce, nous commençons par une période de support - quatre échantillons dans notre cas. <br>  Ainsi, l'image sera transmise pixel par pixel, chaque pixel dure 4 échantillons et l'amplitude pour cette période sera b [x, y] * 128, où b [x, y] est la valeur de luminosité du pixel avec les coordonnées x et y dans l'image b. <br><br>  Estimons quelle sera la vitesse de transmission. <br>  Dans l'exemple, j'ai utilisé une taille d'image de 120x120 pixels.  Cela signifie que pour transférer une image, nous avons besoin <br><br>  120x120x4 = 57600 échantillons, <br><br>  Si la fréquence d'échantillonnage est de 96 kHz, la transmission d'une trame prendra du temps: <br><br>  57600/96000 = 0,6 seconde <br><br>  Évidemment, nous avons besoin d'une sorte de pause, d'un certain intervalle de garde, pour que le détecteur puisse déterminer le début de la trame suivante.  Pour des raisons humaines, supposons que 0,1 seconde nous suffit, pendant laquelle tous les échos s'éteignent (en fait pas).  Ensuite, au final, le taux de transfert se révélera: <br><br>  1 / (0,6 + 0,1) = 1,428 images par seconde. <br><br>  Il est très facile de se tromper ici et d'essayer de calculer la vitesse en bits par seconde.  Voyez à quel point la vitesse de transmission est incroyable: <br><br>  120 * 120 * 8 / 1,428 = 80 627 bps <br><br>  Mais que se passe-t-il si je n'ai pas des pixels 8 bits, mais des pixels 16 bits? <br><br>  120 * 120 * 16 / 1,428 = 161344 bps <br><br>  Le hic ici est que, encore une fois, cette méthode de transmission ne peut pas être appelée numérique, et le concept de débit binaire n'est pas entièrement valable pour cela. <br>  Essayez de calculer le débit binaire d'un signal de télévision analogique.  Et pour le récepteur du détecteur?  :) <br><br>  Ainsi, par exemple, un morceau du signal ressemblera, transmettant la luminosité de 10 pixels, dont les valeurs changent alternativement: 1 2 1 2 1 2 1 2 1 2 <br><img src="https://habrastorage.org/webt/ul/kz/st/ulkzsthqa8tt4ykb7stgu7hehqe.png"><br><br>  Voyons maintenant comment cela fonctionne dans l'exemple.  Les méthodes Encode et Decode vivent dans la classe <a href="">Encoder</a> et sont responsables de la modulation et de la démodulation de l'image: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interframePauseMs</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFinished = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pSize; i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= pLimit) { phase -= pLimit; } samples.Add(alpha * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isFinished) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; pxAmplitude = (((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)frame.GetPixel(col, row).R) / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++row &gt;= rows) isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } samples.Add(alpha * pxAmplitude); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interframePauseMs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { samples.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)interframePauseMs) / <span class="hljs-number"><span class="hljs-number">1000.0</span></span>) * (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)sampleRate)]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples.ToArray(); }</code> </pre><br><br>  On peut voir d'après le code qu'avant de moduler l'image, un préfixe de synchronisation composé de tons purs (échantillons pSize) est ajouté au signal de sortie - cela est nécessaire pour que, du côté de la réception, la synchronisation puisse avoir lieu avant l'image elle <s>-</s> même <s>et en général, se produire</s> dans des conditions défavorables. <br>  La méthode Decode est la suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; Bitmap result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(cols, rows); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxAmplitude = WaveUtils.GetMaxAmplitude(samples); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMin = maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> smp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = pSize; (i &lt; samples.Length) &amp;&amp; (row &lt; rows); i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; chipAmplitude = (Math.Max(Math.Abs(pxMax), Math.Abs(pxMin)) / maxAmplitude); pxMin = maxAmplitude; pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gs = Convert.ToByte(chipAmplitude * <span class="hljs-number"><span class="hljs-number">255</span></span>); result.SetPixel(col, row, Color.FromArgb(<span class="hljs-number"><span class="hljs-number">255</span></span>, gs, gs, gs)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { col = <span class="hljs-number"><span class="hljs-number">0</span></span>; row++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { smp = samples[i] * alpha; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &gt; pxMax) pxMax = smp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &lt; pxMin) pxMin = smp; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  On peut voir que les deux méthodes ne sont liées à aucune fréquence particulière et peuvent être utilisées avec un autre détecteur. <br><br>  La recherche de signal elle-même (détection, synchronisation) se produit également comme dans notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modem hydroacoustique le plus simple</a> , à la seule différence que je le mets dans une classe distincte <a href="">FsBy4CarrierDetector</a> pour un changement. <br>  Toute magie simple se produit dans la méthode bool ProcessSample (abrégé a) <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessSample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ring1[ringHead] = a; ring2[ringHead] = a; s1 += a - ring1[ringTail]; s2 += a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ring1[ringHead] = a; ring2[ringHead] = -a; s1 += a - ring1[ringTail]; s2 += - a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">2</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = -a; s1 += -a - ring1[ringTail]; s2 += -a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = a; s1 += -a - ring1[ringTail]; s2 += a - ring2[ringTail]; } ringHead = (ringHead + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; ringTail = (ringTail + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++smpCount &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { smpCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= ringSize) { s = Math.Sqrt(s1 * s1 + s2 * s2) / ringSize; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; result = (s - sPrev) &gt;= Threshold; sPrev = s; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><br>  Il est appelé sur chaque échantillon entrant et retourne vrai en cas de détection de porteuse. <br><br>  Étant donné que le détecteur est loin d'être parfait et peut facilement être synchronisé au milieu de la ligne, j'ai ajouté un curseur spécial, mobile, ce qui vous permet d'obtenir une synchronisation plus précise. <br><br>  Maintenant, après avoir brièvement examiné comment tout cela fonctionne, passons à la partie la plus délicieuse: ce qui peut être obtenu à partir de tout cela. <br><br><h3>  Un peu de pratique </h3><br>  Tout d'abord, vérifions comment tout fonctionne sans canal sonar - simplement en reliant les antennes de réception et de transmission. <br>  Tout d'abord, l'image est plus grande (240x120) de sorte qu'au moins quelque chose peut être distingué: <br><img src="https://habrastorage.org/webt/ev/ys/1t/evys1t89oks6jpvgeyxtgafgbp4.gif"><br><br>  Et puis rapidement, pour qu'il y ait <s>plus de vie</s> plus comme une vidéo: <br><img src="https://habrastorage.org/webt/2j/2t/y_/2j2ty_dym0iowoiq_xgtf_oqdrg.gif"><br><br>  Ça semble pas mal?  Mais ne vous précipitez pas vers les conclusions et allez à la piscine: <br><img src="https://habrastorage.org/webt/_8/0u/jz/_80ujzh-1afojo46fevq6egccvg.jpeg"><br><br>  Et ici, comme je l'ai promis dans le titre, nous verrons un écho de nos propres yeux: <br><img src="https://habrastorage.org/webt/lb/aq/xe/lbaqxezsgyzwjik0zxymshqjysi.gif"><br><br>  Ça <s>vous plaît, Elon Musk?</s>  vous aimez la HD?  Pourquoi en est-il ainsi? <br>  Et tout est très simple - l'écho est en fait les copies retardées du signal d'origine, interférant avec lui au point de réception, se pliant dans une phase différente et donnant une telle image.  Puisque nous transférons l'image, nous obtenons finalement beaucoup de nombreuses images superposées les unes aux autres avec des amplitudes différentes.  Tout cela conduit finalement au flou et à la reproduction. <br><br>  Avec le recul, vérifions tout sur la grande image du modèle.  J'ai pris une photo au hasard: <br><img src="https://habrastorage.org/webt/oo/hd/jb/oohdjbgoj4pqq-k8f9st0b9rdre.jpeg"><br><br>  Je l'ai modulé, puis ajouté un écho et un peu de bruit, puis il a été décodé, et oui - le résultat ressemble à ce que nous avons obtenu dans la piscine: <br><img src="https://habrastorage.org/webt/bk/dp/y_/bkdpy_9ztpti3b91ulbakqzokes.png"><br><br>  En principe, il est possible d'effectuer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déconvolution</a> et de soustraire des réflexions, mais <s>que ce soit des personnes extérieures à notre zone qui</s> laissent ce point à un travail indépendant. <br><br>  Soit dit en passant, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">méthode précédente</a> dans le pool fonctionne un peu mieux, mais aussi mal - sur les signaux à large bande, les trajets multiples et la réverbération conduisent à un fondu sélectif en fréquence, qui dans l'image (lu sur le spectre) ressemble à des bandes noires et blanches - où le signal est en antiphase, et où il s'est développé en phase (en fait, il y a encore un tas d'options intermédiaires): <br><img src="https://habrastorage.org/webt/zo/f-/pp/zof-ppqayi-rbz2h9yfgjlvc8da.gif"><br><br>  En avril, nous avons saisi l'occasion et sommes allés à l'étang avec une maquette de planche à pain et vous y dorloter aussi: <br><img src="https://habrastorage.org/webt/mv/c-/v4/mvc-v4-m9tys6na8hip-8t8kzyc.jpeg"><br><br><img src="https://habrastorage.org/webt/pp/wc/8u/ppwc8uemc0xlmsmt_rz5h24s664.jpeg"><br><br>  Le résultat n'est pas très différent des résultats obtenus dans le pool: <br><img src="https://habrastorage.org/webt/1-/8j/et/1-8jetei8ly02aanoubjimfhlty.png"><br><br><img src="https://habrastorage.org/webt/_o/1q/ij/_o1qijulzi1p0pqxmch5dijhrcc.png"><br><br>  Et immédiatement pour comparaison, la méthode précédente: <br><img src="https://habrastorage.org/webt/dh/8o/nk/dh8onkjtu5jly6kr7ios0k3td44.png"><br><br>  Et voici les animations gif collectées à partir des images enregistrées, méthode 1: <br><img src="https://habrastorage.org/webt/b7/bq/nz/b7bqnzrvtoa1jkbc0cj4h0okv-u.gif"><br><br>  Et la méthode 2, dont nous discutons dans cet article: <br><img src="https://habrastorage.org/webt/of/vg/gb/ofvggbrbktqq30iy0ihoybpx6le.gif"><br><br><h3>  En conclusion </h3><br>  Comme promis, nous avons montré à quoi ressemblent l'écho et la réverbération, avons passé du temps avec profit et avons fait quelque chose avec nos mains. <br><br>  Sous cette forme, bien sûr, la méthode n'est pas applicable dans la pratique, mais travailler avec elle sera très utile pour les débutants. <br><br>  En général, nous avons vérifié dans un étang peu profond, où les conditions sont très défavorables, et ce serait cool si quelqu'un répétait nos expériences dans d'autres réservoirs et raconterait certainement leurs résultats. <br><br>  Si le lecteur veut juste essayer (même dans les airs avec un microphone et des haut-parleurs), voici les liens vers les versions: <br>  <a href="">Méthode 1</a> <br>  <a href="">Méthode 2 (de cet article)</a> <br><br><h3>  PS </h3>  Nous attendons vraiment avec impatience les commentaires des lecteurs, car il est très important de comprendre que vous faites quelque chose en vain (ou en vain, et cela devrait être arrêté immédiatement). <br><br><h3>  PS / 2 </h3>  Je répondrai tout de suite à une question commune: pour les poissons et autres animaux marins dans ces installations pour enfants, tout cela est tout simplement imperceptible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453678/">https://habr.com/ru/post/fr453678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453664/index.html">Spring Boot - OAuth2 et JWT</a></li>
<li><a href="../fr453666/index.html">Comment je conduisais un taxi sans pilote</a></li>
<li><a href="../fr453668/index.html">10 erreurs d'un jeune RO (partie I - trois erreurs)</a></li>
<li><a href="../fr453672/index.html">CardInfo - API pour déterminer le logo, les couleurs de la banque et d'autres choses par numéro de carte</a></li>
<li><a href="../fr453676/index.html">Connexion à Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453682/index.html">Développement du «firmware» le plus simple pour les FPGA installés dans Redd. Partie 2. Code de programme</a></li>
<li><a href="../fr453686/index.html">Semaine de la sécurité 22: statistiques sur les menaces, chevaux de Troie bancaires et exploits populaires</a></li>
<li><a href="../fr453688/index.html">Java n'est pas seulement une entreprise sanglante, mais aussi des applications sensibles à la latence rapide</a></li>
<li><a href="../fr453692/index.html">Shaders de jeu 3D pour débutants: Effets</a></li>
<li><a href="../fr453694/index.html">Connectez-vous à Windows via SSH comme sous Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>