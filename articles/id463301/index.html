<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏼 👪 💪🏻 Gonkey - Alat Penguji Microservice ✔️ 🤜🏾 👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gonkey sedang menguji layanan microser kami di Lamoda, dan kami pikir itu bisa menguji milik Anda, jadi kami menaruhnya di open source . Jika fungsion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gonkey - Alat Penguji Microservice</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/463301/"><p>  Gonkey sedang menguji layanan microser kami di Lamoda, dan kami pikir itu bisa menguji milik Anda, jadi kami menaruhnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open source</a> .  Jika fungsionalitas layanan Anda diimplementasikan terutama melalui API, dan JSON digunakan untuk pertukaran data, maka Gonkey hampir pasti cocok untuk Anda. </p><br><p><img src="https://habrastorage.org/webt/dz/ie/4z/dzie4z9vcjyrtf_n3mhfdistusm.jpeg" alt="gambar"></p><br><p>  Di bawah ini saya akan membicarakannya secara lebih rinci dan menunjukkan dengan contoh-contoh spesifik bagaimana menggunakannya. </p><a name="habracut"></a><br><h3 id="kak-rodilsya-gonkey">  Bagaimana Gonkey dilahirkan </h3><br><p>  Kami memiliki lebih dari seratus layanan mikro, yang masing-masing menyelesaikan tugas tertentu.  Semua layanan memiliki API.  Tentu saja, beberapa dari mereka juga merupakan antarmuka pengguna, tetapi, bagaimanapun, peran utama mereka adalah menjadi sumber data untuk situs, aplikasi seluler atau layanan internal lainnya, dan oleh karena itu menyediakan <em>antarmuka perangkat lunak</em> . </p><br><p>  Ketika kami menyadari bahwa ada banyak layanan, dan kemudian akan ada lebih banyak lagi, kami mengembangkan dokumen internal yang menggambarkan pendekatan standar untuk desain API dan menggunakan Swagger sebagai alat bantu deskripsi (dan bahkan menulis utilitas untuk membuat kode berdasarkan spesifikasi swagger).  Jika Anda tertarik mempelajari lebih lanjut tentang ini, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Andrey dengan Highload ++.</a> </p><br><p>  Pendekatan standar untuk desain API secara alami mengarah pada gagasan pendekatan standar untuk pengujian.  Inilah yang ingin saya capai: </p><br><ol><li>  <em>Tes layanan melalui API</em> , karena hampir semua fungsi layanan diimplementasikan melalui <em>API</em> </li><li>  <em>Kemampuan untuk mengotomatiskan peluncuran tes</em> untuk mengintegrasikannya ke dalam proses CI / CD kami, seperti yang mereka katakan, "dijalankan oleh tombol" </li><li>  <em>Tes menulis harus dapat diasingkan</em> , yaitu, sehingga tidak hanya seorang programmer dapat menulis tes, idealnya seseorang yang tidak terbiasa dengan pemrograman. </li></ol><br><p>  Jadi Gonkey lahir. </p><br><h3 id="itak-chto-zhe-eto">  Jadi apa ini? </h3><br><p> Gonkey adalah <em>perpustakaan</em> (untuk proyek-proyek di Golang) dan <em>utilitas konsol</em> (untuk proyek dalam bahasa dan teknologi apa pun), yang dengannya Anda dapat melakukan <em>pengujian fungsional dan regresi layanan</em> dengan mengakses API mereka sesuai dengan skrip yang telah ditentukan.  Script pengujian dijelaskan dalam file YAML. </p><br><p>  Sederhananya, Gonkey dapat: </p><br><ul><li>  bombardir layanan Anda dengan permintaan HTTP dan pastikan responsnya seperti yang diharapkan.  Ini mengasumsikan bahwa JSON digunakan dalam permintaan dan tanggapan, tetapi, kemungkinan besar, itu akan bekerja pada kasus-kasus sederhana dengan jawaban dalam format yang berbeda; </li><li>  menyiapkan database untuk pengujian dengan mengisinya dengan data dari perlengkapan (juga ditentukan dalam file YAML); </li><li>  meniru respons layanan eksternal menggunakan tiruan (fitur ini hanya tersedia jika Anda menghubungkan Gonkey sebagai perpustakaan); </li><li>  memberikan hasil pengujian ke konsol atau menghasilkan laporan Allure. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori proyek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar buruh pelabuhan</a> </p><br><h3 id="primer-testirovaniya-servisa-s-gonkey">  Contoh Pengujian Layanan dengan Gonkey </h3><br><p>  Agar tidak membebani Anda dengan teks, saya ingin beralih dari kata-kata ke tindakan dan di sini menguji beberapa API dan memberi tahu dan menunjukkan bagaimana skrip tes ditulis sepanjang jalan. </p><br><p>  Mari kita membuat sketsa layanan kecil di Go yang akan mensimulasikan pekerjaan lampu lalu lintas.  Ini menyimpan warna sinyal saat ini: merah, kuning atau hijau.  Anda bisa mendapatkan warna sinyal saat ini atau mengatur yang baru melalui API. </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    const ( lightRed = "red" lightYellow = "yellow" lightGreen = "green" ) //      type trafficLights struct { currentLight string `json:"currentLight"` mutex sync.RWMutex `json:"-"` } //   var lights = trafficLights{ currentLight: lightRed, } func main() { //       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { lights.mutex.RLock() defer lights.mutex.RUnlock() resp, err := json.Marshal(lights) if err != nil { log.Fatal(err) } w.Write(resp) }) //       http.HandleFunc("/light/set", func(w http.ResponseWriter, r *http.Request) { lights.mutex.Lock() defer lights.mutex.Unlock() request, err := ioutil.ReadAll(r.Body) if err != nil { log.Fatal(err) } var newTrafficLights trafficLights if err := json.Unmarshal(request, &amp;newTrafficLights); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } if err := validateRequest(&amp;newTrafficLights); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } lights = newTrafficLights }) //   () log.Fatal(http.ListenAndServe(":8080", nil)) } func validateRequest(lights *trafficLights) error { if lights.currentLight != lightRed &amp;&amp; lights.currentLight != lightYellow &amp;&amp; lights.currentLight != lightGreen { return fmt.Errorf("incorrect current light: %s", lights.currentLight) } return nil }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber lengkap untuk main.go ada di sini</a> . </p><br><p>  Jalankan program: </p><br><pre> <code class="plaintext hljs">go run .</code> </pre> <br><p>  Sketsa sangat cepat dalam 15 menit!  Tentunya dia salah di suatu tempat, jadi kami akan menulis tes dan memeriksa. </p><br><p>  Unduh dan jalankan Gonkey: </p><br><pre> <code class="plaintext hljs">mkdir -p tests/cases docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Perintah ini memulai gambar dengan gonkey melalui buruh pelabuhan, memasang direktori tes / kasus di dalam wadah dan memulai gonkey dengan parameter -tests test / cases / -host. </p><br><p>  Jika Anda tidak menyukai pendekatan buruh pelabuhan, maka alternatif untuk perintah semacam itu adalah menulis: </p><br><pre> <code class="plaintext hljs">go get github.com/lamoda/gonkey go run github.com/lamoda/gonkey -tests tests/cases -host localhost:8080</code> </pre> <br><p>  Diluncurkan dan dapatkan hasilnya: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/0</code> </pre> <br><p>  Tidak ada tes - tidak ada yang perlu diperiksa.  Mari kita tulis tes pertama.  Buat file test / cases / light_get.yaml dengan konten minimum: </p><br><pre> <code class="plaintext hljs">- name: WHEN currentLight is requested MUST return red method: GET path: /light/get response: 200: &gt; { "currentLight": "red" }</code> </pre> <br><p>  Pada level pertama adalah daftar.  Ini berarti bahwa kami telah mendeskripsikan satu test case, tetapi mungkin ada banyak dari mereka dalam file.  Bersama-sama mereka membuat skenario pengujian.  Jadi, satu file - satu skrip.  Anda dapat membuat sejumlah file dengan skrip uji, jika nyaman, mengaturnya menjadi subdirektori - gonkey membaca semua file yaml dan yml dari direktori yang ditransfer dan lebih rekursif. </p><br><p>  File di bawah ini menjelaskan detail permintaan yang akan dikirim ke server: metode, jalur.  Yang lebih rendah lagi adalah kode respons (200) dan badan respons yang kami harapkan dari server. </p><br><p>  Format file lengkap dijelaskan <a href="">dalam README</a> . </p><br><p>  Jalankan lagi: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Hasil: </p><br><pre> <code class="plaintext hljs"> Name: WHEN currentlight is requested MUST return red Request: Method: GET Path: /light/get Query: Body: &lt;no body&gt; Response: Status: 200 OK Body: {} Result: ERRORS! Errors: 1) at path $ values do not match: expected: { "currentLight": "red" } actual: {} Failed tests: 1/1</code> </pre> <br><p>  Kesalahan!  Struktur dengan bidangLightLight diharapkan, dan struktur kosong kembali.  Ini buruk.  Masalah pertama adalah bahwa hasilnya ditafsirkan sebagai string, ini ditunjukkan oleh fakta bahwa, sebagai tempat masalah, gonkey menyoroti seluruh jawaban tanpa perincian: </p><br><pre> <code class="plaintext hljs"> expected: { "currentLight": "red" }</code> </pre> <br><p>  Alasannya sederhana: Saya lupa menulis sehingga layanan dalam respons menunjukkan jenis konten aplikasi / json.  Kami memperbaiki: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { lights.mutex.RLock() defer lights.mutex.RUnlock() resp, err := json.Marshal(lights) if err != nil { log.Fatal(err) } w.Header().Add("Content-Type", "application/json") // &lt;--  w.Write(resp) })</span></span></code> </pre> <br><p>  Kami memulai kembali layanan dan menjalankan tes lagi: </p><br><pre> <code class="plaintext hljs"> Name: WHEN currentlight is requested MUST return red Request: Method: GET Path: /light/get Query: Body: &lt;no body&gt; Response: Status: 200 OK Body: {} Result: ERRORS! Errors: 1) at path $ key is missing: expected: currentLight actual: &lt;missing&gt;</code> </pre> <br><p>  Hebat, ada kemajuan.  Gonkey sekarang mengenali strukturnya, tetapi masih salah: jawabannya kosong.  Alasannya adalah bahwa saya menggunakan bidang currentLight yang tidak dapat diekspor dalam definisi tipe: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      type trafficLights struct { currentLight string `json:"currentLight"` mutex sync.RWMutex `json:"-"` }</span></span></code> </pre> <br><p>  Di Go, bidang struktur bernama dengan huruf kecil dianggap tidak dapat diekspor, yaitu, tidak dapat diakses dari paket lain.  Serializer JSON tidak melihatnya dan tidak dapat memasukkannya dalam respons.  Kami benar: kami membuat bidang dengan huruf kapital, yang artinya diekspor: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      type trafficLights struct { urrentLight string `json:"currentLight"` // &lt;--   mutex sync.RWMutex `json:"-"` }</span></span></code> </pre> <br><p>  Mulai ulang layanan.  Jalankan tes lagi. </p><br><pre> <code class="plaintext hljs">Failed tests: 0/1</code> </pre> <br><p>  Tes telah berlalu! </p><br><p>  Kami akan menulis skrip lain yang akan menguji metode yang ditetapkan.  Isi file test / cases / light_set.yaml dengan konten berikut: </p><br><pre> <code class="plaintext hljs">- name: WHEN set is requested MUST return no response method: POST path: /light/set request: &gt; { "currentLight": "green" } response: 200: '' - name: WHEN get is requested MUST return green method: GET path: /light/get response: 200: &gt; { "currentLight": "green" }</code> </pre> <br><p>  Tes pertama menetapkan nilai baru untuk sinyal lalu lintas, dan yang kedua memeriksa status untuk memastikan bahwa itu telah berubah. </p><br><p>  Jalankan tes dengan perintah yang sama: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Hasil: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/3</code> </pre> <br><p>  Hasil yang sukses, tetapi kami beruntung skrip dieksekusi dalam urutan yang kami butuhkan: light_get pertama, dan kemudian light_set.  Apa yang akan terjadi jika mereka melakukan yang sebaliknya?  Mari kita ganti nama: </p><br><pre> <code class="plaintext hljs">mv tests/cases/light_set.yaml tests/cases/_light_set.yaml</code> </pre> <br><p>  Dan jalankan lagi: </p><br><pre> <code class="plaintext hljs">Errors: 1) at path $.currentLight values do not match: expected: red actual: green Failed tests: 1/3</code> </pre> <br><p>  Pertama, set dieksekusi dan lampu lalu lintas dibiarkan dalam kondisi hijau, sehingga uji coba selanjutnya menemukan kesalahan - dia sedang menunggu merah. </p><br><p>  Salah satu cara untuk menghilangkan fakta bahwa tes tergantung pada konteksnya adalah dengan menginisialisasi layanan di awal skrip (yaitu, pada awal file), yang biasanya kita lakukan dalam set test - pertama kita menetapkan nilai yang diketahui, yang seharusnya menghasilkan efek yang diketahui, dan kemudian periksa apakah efeknya berpengaruh. </p><br><p>  Cara lain untuk menyiapkan konteks eksekusi jika layanan menggunakan database adalah dengan menggunakan perlengkapan dengan data yang dimuat ke dalam database di awal skrip, sehingga membentuk kondisi layanan yang dapat diprediksi yang dapat diperiksa.  Deskripsi dan contoh bekerja dengan perlengkapan di gonkey saya ingin mengeluarkan dalam artikel terpisah. </p><br><p>  Sementara itu, saya mengusulkan solusi berikut.  Karena dalam skrip set, kami sebenarnya menguji metode light / set dan metode light / get, kami tidak memerlukan skrip light_get, yang peka konteks.  Saya menghapusnya, dan mengganti nama skrip yang tersisa sehingga namanya mencerminkan esensi. </p><br><pre> <code class="plaintext hljs">rm tests/cases/light_get.yaml mv tests/cases/_light_set.yaml tests/cases/light_set_get.yaml</code> </pre> <br><p>  Sebagai langkah selanjutnya, saya ingin memeriksa beberapa skenario negatif bekerja dengan layanan kami, misalnya, apakah itu akan berfungsi dengan benar jika saya mengirim warna sinyal yang salah?  Atau tidak mengirim warna sama sekali? </p><br><p>  Buat skrip test / cases / light_set_get_negative.yaml baru: </p><br><pre> <code class="plaintext hljs">- name: WHEN set is requested MUST return no response method: POST path: /light/set request: &gt; { "currentLight": "green" } response: 200: '' - name: WHEN incorrect color is passed MUST return error method: POST path: /light/set request: &gt; { "currentLight": "blue" } response: 400: &gt; incorrect current light: blue - name: WHEN color is missing MUST return error method: POST path: /light/set request: &gt; {} response: 400: &gt; incorrect current light: - name: WHEN get is requested MUST have color untouched method: GET path: /light/get response: 200: &gt; { "currentLight": "green" }</code> </pre> <br><p>  Dia memeriksa bahwa: </p><br><ul><li>  ketika warna yang salah ditransmisikan, kesalahan terjadi; </li><li>  ketika warna tidak ditransmisikan, terjadi kesalahan; </li><li>  transmisi warna yang salah tidak mengubah kondisi internal lampu lalu lintas. </li></ul><br><p>  Jalankan: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/6</code> </pre> <br><p>  Semuanya baik-baik saja :) </p><br><h3 id="podklyuchaem-gonkey-kak-biblioteku">  Menghubungkan Gonkey sebagai perpustakaan </h3><br><p>  Seperti yang Anda perhatikan, kami sedang menguji API layanan, sepenuhnya abstrak dari bahasa dan teknologi yang digunakan untuk menuliskannya.  Dengan cara yang sama, kami dapat menguji API publik apa pun yang kami tidak memiliki akses ke kode sumber - itu cukup untuk mengirim permintaan dan menerima jawaban. </p><br><p>  Tetapi untuk aplikasi kita sendiri yang ditulis in go, ada cara yang lebih mudah untuk menjalankan gonkey - untuk menghubungkannya ke proyek sebagai perpustakaan.  Ini akan memungkinkan, tanpa mengkompilasi apa pun di muka - baik gonkey, maupun proyek itu sendiri - untuk menjalankan tes dengan hanya menjalankan <code>go test</code> . </p><br><p>  Dengan pendekatan ini, kita sepertinya mulai menulis unit test, dan di dalam body test kita melakukan hal berikut: </p><br><ul><li>  menginisialisasi server web dengan cara yang sama seperti ketika layanan dimulai; </li><li>  jalankan server aplikasi pengujian pada localhost dan port acak; </li><li>  kami memanggil fungsi dari pustaka gonkey, mengirimkannya ke alamat server pengujian dan parameter lainnya.  Di bawah ini saya akan menggambarkan ini. </li></ul><br><p>  Untuk melakukan ini, aplikasi kita perlu sedikit refactoring.  Poin kuncinya adalah membuat penciptaan server fungsi yang terpisah, karena kita sekarang membutuhkan fungsi ini di dua tempat: ketika layanan dimulai, dan bahkan ketika tes gonkey dijalankan. </p><br><p>  Saya meletakkan kode berikut dalam fungsi terpisah: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { //   }) //       http.HandleFunc("/light/set", func(w http.ResponseWriter, r *http.Request) { //   }) }</span></span></code> </pre> <br><p>  Fungsi utama akan seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { initServer() <span class="hljs-comment"><span class="hljs-comment">//   () log.Fatal(http.ListenAndServe(":8080", nil)) }</span></span></code> </pre> <br><p>  <a href="">File go utama yang dimodifikasi sepenuhnya</a> . </p><br><p>  Ini membebaskan tangan kami, jadi mari kita mulai menulis ujian.  Saya membuat file func_test.go: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_API</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { initServer() srv := httptest.NewServer(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) runner.RunWithTesting(t, &amp;runner.RunWithTestingParams{ Server: srv, TestsDir: <span class="hljs-string"><span class="hljs-string">"tests/cases"</span></span>, }) }</code> </pre> <br><p>  <a href="">Ini adalah file func_test.go lengkap</a> . </p><br><p>  Itu saja!  Kami memeriksa: </p><br><pre> <code class="plaintext hljs">go test ./...</code> </pre> <br><p>  Hasil: </p><br><pre> <code class="plaintext hljs">ok github.com/lamoda/gonkey/examples/traffic-lights-demo 0.018s</code> </pre> <br><p>  Tes telah berlalu.  Jika saya memiliki kedua tes unit dan tes gonkey, semuanya akan berjalan bersama - cukup nyaman. </p><br><h3 id="formiruem-otchet-allure">  Buat laporan Allure </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Allure</a> adalah format laporan pengujian untuk menampilkan hasil dengan cara yang jelas dan indah.  Gonkey dapat merekam hasil tes dalam format ini.  Mengaktifkan Allure sangat sederhana: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests -w /tests lamoda/gonkey -tests cases/ -host host.docker.internal:8080 -allure</code> </pre> <br><p>  Laporan tersebut akan ditempatkan di subdirektori allure-results dari direktori kerja saat ini (itu sebabnya saya menentukan -w / tes). </p><br><p>  Saat menghubungkan gonkey sebagai perpustakaan, laporan Allure diaktifkan dengan menetapkan variabel lingkungan tambahan GONKEY_ALLURE_DIR: </p><br><pre> <code class="plaintext hljs">GONKEY_ALLURE_DIR="tests/allure-results" go test ./…</code> </pre> <br><p>  Hasil tes yang direkam dalam file dikonversi menjadi laporan interaktif dengan perintah: </p><br><pre> <code class="plaintext hljs">allure generate allure serve</code> </pre> <br><p>  Seperti apa laporannya: <br><img src="https://habrastorage.org/webt/bq/z-/ds/bqz-dsu89nodwlzi_im5nxr0t-k.png" alt="gambar"></p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Dalam artikel berikut, saya akan membahas tentang penggunaan fixture di gonkey dan meniru tanggapan layanan lain menggunakan ejekan. </p><br><p>  Saya mengundang Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mencoba gonkey</a> di proyek Anda, berpartisipasi dalam pengembangannya (permintaan kumpulan dipersilahkan!) Atau tandai dengan tanda bintang di github jika proyek ini dapat berguna bagi Anda di masa depan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463301/">https://habr.com/ru/post/id463301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463291/index.html">Dadu atau Tulang</a></li>
<li><a href="../id463293/index.html">Pengumpul Sampah. Kursus lengkap + transfer dari BOTR</a></li>
<li><a href="../id463295/index.html">C ++ dan CMake - Brothers Forever, Bagian II</a></li>
<li><a href="../id463297/index.html">Kesetiaan dengan selera Anda</a></li>
<li><a href="../id463299/index.html">Kiat dan trik Kubernetes: cara meningkatkan produktivitas</a></li>
<li><a href="../id463303/index.html">Facebook akhirnya berhenti menargetkan iklan untuk nomor telepon yang dimasukkan orang untuk 2FA</a></li>
<li><a href="../id463305/index.html">Alat untuk menganalisis dan men-debug aplikasi .NET</a></li>
<li><a href="../id463307/index.html">Studi kasus tentang komunikasi dengan klien "berat"</a></li>
<li><a href="../id463311/index.html">CTT dalam solusi server. Versi kedua + pengumuman yang ketiga, dengan kemampuan untuk menyentuh</a></li>
<li><a href="../id463313/index.html">Pendekatan alternatif untuk berlangganan acara, atau apakah EventObject benar-benar diperlukan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>