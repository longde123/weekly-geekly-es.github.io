<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèø ‚õàÔ∏è üö£ Clang-Format verlangsamt das Programm üë©üèø‚Äç‚öïÔ∏è üçµ üë©‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir die Leistung verschiedener Implementierungen der Topper-Funktion messen, da dies dienstags der Fall ist. 

 Eigentlich interessiert m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clang-Format verlangsamt das Programm</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/">  Heute werden wir die Leistung verschiedener Implementierungen der Topper-Funktion messen, da dies dienstags der Fall ist. <br><br>  Eigentlich <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>interessiert</i></a> mich die <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>Topper-</i></a> Funktion nicht, ich habe erst k√ºrzlich einen weiteren Beitrag geschrieben und brauchte eine Art gemeinsamen Handlungskern, und <i>Topper</i> scheint ein ziemlich interessanter und harmloser Kandidat f√ºr Benchmarks zu sein.  Ich habe versucht, etwas so einfaches wie m√∂glich zu w√§hlen, das mich nicht zur Seite f√ºhrt, aber es ist einfach so passiert, dass ich in diesem Test auf ein seltsames Problem gesto√üen bin. <br><a name="habracut"></a><br>  Dieser Beitrag wird klein sein - ein umfassenderer Artikel zum urspr√ºnglichen, vielleicht interessanteren Thema wird in K√ºrze erwartet.  Wenn du die Ergebnisse mit mir reproduzieren willst, kannst du <a href="https://github.com/travisdowns/toupper-bench">den</a> Quellcode <a href="https://github.com/travisdowns/toupper-bench">auf github nehmen</a> . <br><br>  Schauen wir uns also drei Implementierungen der Funktion <i>toupper an</i> , mit der die Zeichen eines Arrays, das aus Elementen vom Typ <i>char besteht,</i> in Gro√übuchstaben konvertiert werden. Dabei wird ein Array als Argument verwendet und seine Elemente direkt so ge√§ndert, dass alle Kleinbuchstaben gro√ü geschrieben werden. <br><br>  In der ersten Implementierung rufen wir einfach <a href="https://linux.die.net/man/3/toupper">die Funktion toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">der</a> C-Standardbibliothek auf und f√ºhren eine Schleife im C-Stil aus: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br>  In der zweiten Implementierung verwenden wir einen <a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">moderneren</a> Ansatz, indem wir den Rohzyklus durch <i>std :: transform</i> ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br>  Schlie√ülich verwenden wir in der dritten Implementierung einen speziellen Algorithmus, der mit ASCII-Zeichen arbeitet.  Es pr√ºft, ob das Zeichen im Bereich von <i>a bis z liegt</i> , und ersetzt bei Erfolg den gleichen Buchstaben in Gro√übuchstaben, wobei die Zahl 32 vom Zeichencode [2] abgezogen wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br>  Sieht einfach aus, oder? <br><br>  Jetzt messen wir die Geschwindigkeit dieser Implementierungen auf meinem Laptop mit dem Skylake i7-6700HQ-Prozessor auf dem gcc 5.5-Compiler mit den Standardeinstellungen.  Die Ergebnisse werden in Form eines Streudiagramms angegeben [3]: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br>  Wir werden uns sofort mit drei Fragen befassen, die f√ºr unsere Aufgabe irrelevant sind. <br><br>  Schauen Sie sich zun√§chst das Diagramm des Verzweigungsalgorithmus an (gr√ºn dargestellt).  Sie variiert je nach Gr√∂√üe der Eingabedaten erheblich - die beiden anderen Diagramme bleiben nahezu flach.  Dies ist eigentlich nur ein Testartefakt.  Die eingegebenen ASCII-Zeichen werden zuf√§llig ausgew√§hlt [4], daher ist der entscheidende Faktor im Fall der dritten Implementierung die Operation des Verzweigungsvorhersagealgorithmus.  Mit einer kleinen Datenmenge wird die Reihenfolge der Elemente w√§hrend der Iteration vollst√§ndig gespeichert, sodass die Anzahl der Fehlschl√§ge gering und die Geschwindigkeit hoch ist, <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">wie in dieser Anmerkung gezeigt</a> .  Mit zunehmender Gr√∂√üe der Datensequenz merkt sich der Vorhersagealgorithmus immer weniger, bis er schlie√ülich mit jedem Gro√übuchstaben (0,27 Fehler pro Zeichen) zu verfehlen beginnt, und dann wird der Graph nivelliert. <br><br>  Achten Sie zweitens auf die Gruppe der gr√ºnen Punkte oben links, die den viel niedrigeren Geschwindigkeiten der Variante mit Verzweigung <i>toupper_branch entsprechen</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br>  Dies ist kein isoliertes Artefakt: Solche Stellen traten bei mehreren Starts auf.  Gleichzeitig k√∂nnen sie nicht reproduziert werden, wenn Sie den Algorithmus nur speziell f√ºr diese Datengr√∂√üen testen. Sie werden nur angezeigt, wenn der Test f√ºr alle Gr√∂√üen ausgef√ºhrt wird.  In diesem Fall werden sie jedoch nicht immer angezeigt.  Ich habe mich nicht speziell damit befasst, kann aber davon ausgehen, dass dies auf Konflikte bei Namen oder Aliasen im Algorithmus f√ºr die Verzweigungsvorhersage zur√ºckzuf√ºhren ist oder wenn physische Seiten mit 4 kB Arbeitsspeicher auf virtuell abgebildet werden (obwohl die Randomisierung des virtuellen Adressraums deaktiviert war). <br><br>  Drittens sieht die Implementierung von <i>toupper_rawloop</i> (in Blau dargestellt) in der Grafik wie zwei separate Linien aus: eine geringf√ºgig √ºber der Marke von 2 Kennzahlen pro Zeichen und die andere auf der Ebene von 1,5 Kennzahlen pro Zeichen.  Diese beiden Zeilen tauchten bei allen Testern auf.  Die schnellere Option mit einer Geschwindigkeit von 1,57 Zeichen pro Zyklus verlangsamt die Download-Ports tats√§chlich: Das Lesen der Daten an den Ports 2 und 3 erfolgt mit einer Geschwindigkeit von 1,54 Mikrooperationen pro Zyklus, sodass diese zu 98% ausgelastet sind.  Ich konnte den Grund f√ºr das langsamere ‚ÄûRegime‚Äú nicht feststellen. <br><br>  W√§hrend ich mich mit diesem Thema besch√§ftigte, verschwand das schnelle ‚ÄûRegime‚Äú pl√∂tzlich und nur das langsame blieb √ºbrig.  Vielleicht hat der Prozessor gemerkt, was ich versucht habe, und hat das Update f√ºr den Mikrocode heimlich heruntergeladen, um den Widerspruch zu beseitigen, aber ich habe (noch) Beweise - ein Vektorbild mit Diagrammen. <br><br>  Was interessiert uns dann an diesem Beispiel? <br><br>  Was uns jedoch interessiert, ist, dass die Version mit einem Rohzyklus 3-4 mal schneller ist als die Version mit <i>std :: transform</i> : 1,5-2 Zyklen pro Zeichen gegen√ºber 7 mit einigen Zyklen pro Zeichen. <br><br>  Was ist hier los?  Haben mich Standardalgorithmen gescheitert?  Hat <i>std :: transform</i> einen Fehler? <br><br>  Nicht wirklich.  Genauer gesagt, √ºberhaupt nicht. <br><br>  Es stellt sich heraus, dass solche Ergebnisse auftreten, wenn Funktionen in <a href="">verschiedenen Dateien</a> kompiliert <a href="">werden</a> .  Wenn Sie sie in dieselbe Datei einf√ºgen, ist ihre Leistung gleicherma√üen niedrig. <br><br>  Und nein, Ausrichtung hat nichts damit zu tun. <br><br>  Das ist aber noch nicht alles: Die schnelle Version mit einem Rohzyklus wird beim Kompilieren in einer separaten Datei langsamer, wenn Sie einfach die <i>&lt;algorithm&gt;</i> -Headerdatei anh√§ngen.  Ja, das ist richtig: Verbinden Sie einfach diese Datei, die nie verwendet wird und keinen Code in der endg√ºltigen Objektdatei generiert, und die Geschwindigkeit des "rohen" Zyklus wird 3-4 mal sinken.  Im Gegensatz dazu wird die Version mit <i>std :: transform</i> bis zum Limit beschleunigt, wenn Sie die Implementierung von <i>std :: transform</i> aus der Datei <i>&lt;algorithm&gt;</i> kopieren und einf√ºgen, diese Datei jedoch nicht einschlie√üen. <br><br>  Seltsamkeiten h√∂ren hier nicht auf (ich verspreche, es wird keine weiteren geben): Das Einbeziehen der <i>&lt;algorithm&gt;</i> -Datei f√ºhrt nicht immer zu dem beschriebenen Effekt.  Ein Geschwindigkeitsabfall tritt auf, wenn <i>&lt;algorithm&gt;</i> fr√ºher als <i>&lt;ctype.h&gt; verbunden</i> ist, wenn Sie sie jedoch <i>austauschen</i> , dann nein: <br><br>  <b>Langsamer Code:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>Kurzcode:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br>  Eigentlich ist mir diese Anomalie (in einem anderen Projekt) aufgefallen, als clang-format die enthaltenen Header-Dateien automatisch sortiert und den <i>&lt;Algorithmus&gt; ganz</i> am Anfang der Liste platziert hat, wo er hingeh√∂rt (daher der Clickbait-Header des Artikels). <br><br>  Nat√ºrlich mussten wir uns fr√ºher oder sp√§ter in die Liste der Assembler st√ºrzen.  Wir werden diesen unangenehmen Moment nicht aufhalten. <br><br>  Die <a href="https://godbolt.org/z/DwZBJM">schnellen und langsamen</a> Versionen der Funktionen [5] sind unten dargestellt, kleine Schleifen sind mit Anmerkungen versehen: <br><br>  <b>&lt;algorithm&gt; verbindet sich zuerst:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithm&gt; ist an zweiter Stelle verbunden:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br>  Der Hauptunterschied besteht darin, dass in der langsamen Version die toupper-Funktion einfach in einer Schleife aufgerufen wird, w√§hrend in der schnellen Version die Funktionsaufrufe vollst√§ndig fehlen und nur in der Entsprechungstabelle [6] gesucht wird, d. H  Der Body der Funktion <i>std :: toupper</i> wird an der Stelle des Aufrufs eingesetzt <br><br>  Wenn Sie sich den <a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">Quellcode</a> der glibc-Bibliothek ansehen, finden wir dort die Implementierung der <i>toupper-</i> Funktion: <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH ‚Äì  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br>  Wie wir sehen k√∂nnen, ist <i>toupper</i> als <i>externe Inline-</i> Funktion definiert, die zuerst pr√ºft, ob die Gr√∂√üe des <i>Zeichenzeichens</i> in ein Byte passt [7] und dann in der von der Funktion <i>__ctype_toupper_loc () zur√ºckgegebenen</i> Entsprechungstabelle nach dem Zeichen sucht.  Diese Funktion gibt einen lokalen Datenstromzeiger (vom Typ <i>const int **</i> ) zur√ºck, der wiederum auf eine Entsprechungstabelle verweist, aus der auf eine Anfrage nach unserem Symbol hin die Gro√übuchstabenversion zur√ºckgegeben wird [8]. <br><br>  Jetzt ist klar, was in der Auflistung passiert.  In der schnellen Version des Algorithmus ersetzt der Compiler den Body der Funktion <i>toupper</i> , kann jedoch den Aufruf der Funktion <i>__ctype_toupper_loc ()</i> nicht ersetzen [9].  Dieser Aufruf wird jedoch als <i>__attribute __ ((const))</i> deklariert, was bedeutet, dass der R√ºckgabewert nur von den Argumenten abh√§ngt (die nicht hier sind).  Der Compiler wei√ü, dass diese Funktion jedes Mal den gleichen Wert zur√ºckgibt und daher ihren Aufruf au√üerhalb der Schleife ausf√ºhrt. In der Schleife selbst gibt es nur wenige Leseoperationen, die mit dem Zugriff auf die Entsprechungstabelle, dem Schreiben eines neuen Werts in den Puffer und der Schleifensteuerung verbunden sind. <br><br>  In der langsamen Version bleibt der Aufruf von <i>toupper ()</i> im Rumpf der Schleife.  Die Schleife selbst ist um einen Befehl k√ºrzer, aber jetzt m√ºssen Sie nat√ºrlich noch den gesamten Code innerhalb der <i>toupper-</i> Funktion ausf√ºhren.  Auf meinem System sieht es so aus: <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br>  Da dies ein nicht eingebetteter Aufruf ist, erledigt das Programm mehr Arbeit.  Es gibt mindestens f√ºnf aufeinanderfolgende Operationen zum Zugreifen auf den Speicher (das sogenannte Verfolgen von Zeigern, <i>Zeigerjagen</i> ).  In der Schnellversion bleiben nur zwei √ºbrig, da alle anderen aus der Schleife genommen werden.  Die Verz√∂gerung zwischen dem Aufruf und dem Verlassen einer Funktion sollte ungef√§hr 25 Zyklen betragen, und es werden ungef√§hr 7 Zyklen ausgegeben. Dies bedeutet, dass der Prozessor den Aufruf parallelisieren konnte, was unter den gegebenen Umst√§nden recht gut ist. <br><br>  Warum ist das so? <br><br>  In einer langen Kette von Include-Dateien enthalten C ++ - Header-Dateien wie <i>&lt;algorithm&gt;</i> wiederum die Datei <i>&lt;bits / os_defines.h&gt;</i> , die die folgende Zeile enth√§lt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br>  Wenn die Datei <i>&lt;ctype.h&gt;</i> endg√ºltig verbunden ist, kann aufgrund dieser Anweisung der Code, in dem <i>toupper</i> als <i>extern inline</i> definiert ist, nicht eingeschlossen werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br>  Beachten Sie, dass beim Verbinden von <i>&lt;ctype.h&gt; die</i> C ++ - Version von <i>toupper</i> niemals als Makro definiert wird - maximal als <i>externes</i> <i>Inline</i> -, da die Definitionen der Makros durch die <i>! Defined __cplusplus-Pr√ºfung</i> gesch√ºtzt sind und daher niemals wirksam werden. <br><br>  Im Allgemeinen wei√ü ich nicht genau, ob <i>__NO_CTYPE</i> in diesem Fall die als <i>extern inline</i> deklarierten K√∂rper der <i>tolower-</i> und <i>toupper-</i> Funktionen ausschlie√üen soll, aber genau das passiert - und damit eine signifikante <i>Verringerung</i> der Geschwindigkeit unseres Zyklus.  Zusammenfassend kann ich sagen, dass, wenn Sie <i>&lt;cctype&gt;</i> anstelle von <i>&lt;ctype.h&gt; einf√ºgen</i> (d. H. C ++ ist die Version der C-Header-Datei, die Funktionen in den <i>std ::</i> <i>-Namensraum schreibt</i> ), der Code in diesem Fall langsam arbeitet weil <i>&lt;cctype&gt;</i> letztendlich <i>&lt;bits / os_defines.h&gt; enth√§lt</i> . <br><br>  Ist das alles so wichtig?  Ja Nein. <br><br>  Die Funktion <i>toupper</i> eignet sich nicht f√ºr ernsthafte Arbeiten mit Zeichen verschiedener Sprachen. Wenn Sie also nur ASCII-Zeichen verarbeiten m√ºssen, k√∂nnen Sie Ihre eigene schnellere Implementierung <i>erstellen</i> .  Wenn Sie ernsthaft mit Text arbeiten m√ºssen, werden Sie h√∂chstwahrscheinlich UTF-8 verwenden und eine Art ICU verwenden m√ºssen, um regionale Einstellungen zu unterst√ºtzen, oder warten, bis die Unicode-Unterst√ºtzung in C ++ angezeigt wird (das Warten kann lange dauern). .  Die Aussage ‚ÄûClang-Format kann zu einem 4x Leistungseinbruch f√ºhren‚Äú eignet sich daher nur als Clickbait-Header. <br><br>  Wird dieser Effekt in allen libc-Versionen beobachtet?  Ja, in fast allen F√§llen, aber auch hier ist es nicht so einfach. <br><br>  Die oben gezeigten Ergebnisse gelten f√ºr gcc 5.5 und glibc 2.23, da ich diese Versionen verwendet habe, aber in den neuen Versionen passiert etwas Neues (ab ungef√§hr glibc 2.27).  Dort f√ºhrt das Einschalten von <i>&lt;algorithm&gt;</i> vor <i>&lt;ctype.h&gt;</i> immer noch zu demselben Effekt, aber jetzt verursacht <i>&lt;stdlib.h&gt;</i> [10] auch Probleme: Wenn Sie es vor <i>&lt;ctype.h&gt; einschalten</i> , sinkt auch die Leistung, was nicht der Fall ist in fr√ºheren Versionen beobachtet.  In neueren Versionen enth√§lt die Datei <i>&lt;stdlib.h&gt;</i> <i>nat√ºrlich</i> auch die Definition <i>__NO_CTYPE</i> .  Zumindest wird es jetzt nicht m√∂glich sein, das Clang-Format f√ºr das Sortieren verantwortlich zu machen - hier kann es nur helfen, das Problem zu l√∂sen (wenn die Liste der verbundenen Dateien keine anderen Problemdateien enth√§lt). <br><br>  Ich habe <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">einen Fehlerbericht in libc</a> gepostet, daher ist es wahrscheinlich, dass dieser Fehler behoben wird. Es besteht jedoch kein Zweifel, dass Fehler in Bezug auf die Reihenfolge, in der Header-Dateien verbunden sind, uns weiter bel√§stigen. <br><br><h2>  Kommentare </h2><br>  Ich habe kein Kommentarsystem auf meiner Website, arbeite jedoch daran (das hei√üt, ich jammere regelm√§√üig, was bei statischen Websites schwierig ist, Kommentare abzugeben). <br><br>  In der Zwischenzeit k√∂nnen Sie diesen Artikel auf der <a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News-</a> Website oder unter <a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs diskutieren</a> . <br><br><h2>  Danksagung </h2><br>  <i>Wir danken</i> dem ufo-Benutzer von Hacker News, der <a href="https://news.ycombinator.com/item%3Fid%3D21579483">darauf hingewiesen hat,</a> dass es nicht erforderlich ist, die Lambda-Funktion zu verwenden, um <i>std :: toupper</i> f√ºr die Verwendung in <i>std :: transform</i> anzupassen, und auch Jonathan Muller, der <a href="https://twitter.com/foonathan/status/1197051249822195712">erkl√§rte,</a> dass die Lambda-Funktion weiterhin ben√∂tigt wird. <br><br><ol><li>  Ja, die Funktion <i>toupper (3)</i> aus der Header-Datei <i>&lt;ctype.h&gt;</i> ist nicht f√ºr die Arbeit mit den meisten Nicht-ASCII-Zeichen geeignet  Es k√∂nnen keine Zeichen verarbeitet werden, die gr√∂√üer als ein Byte sind, dies ist jedoch f√ºr unsere Aufgabe geeignet, da nur ASCII-Zeichenfolgen √ºbergeben werden. </li><li>  In der ASCII-Tabelle befinden sich Klein- und Gro√übuchstaben sehr bequem in einem Abstand von 32 Positionen voneinander. Dies bedeutet, dass Sie Zeichen von einer Gro√ü- / Kleinschreibung in eine andere √ºbertragen k√∂nnen, indem Sie einfach 32 subtrahieren oder addieren. Wenn wir sicher w√§ren, dass alle Eingaben vorhanden sind <i>Da es sich</i> bei den Daten um ASCII-Buchstaben handelt, k√∂nnten wir das 5. Bit ohne Pr√ºfung zur√ºcksetzen (z. B. <i>c &amp; 0b11011111</i> ), um jeden Gro√übuchstaben in Kleinbuchstaben <i>umzuwandeln</i> , was sich jedoch nicht in Kleinbuchstaben niederschl√§gt.  Aber wir wissen es wahrscheinlich nicht, deshalb m√ºssen wir pr√ºfen, ob es sich bei dem Zeichen um einen Buchstaben handelt, um nicht versehentlich Buchstaben wie <i>char zu unterbrechen</i> . </li><li>  Es sollte ein Streudiagramm mit dem Zusatz von "Rauschen" an der Stelle der Punkte genannt werden.  In der Tat ist dies ein gew√∂hnliches Streudiagramm, in dem der f√ºr uns interessante Parameter (die Gr√∂√üe der Eingabedaten) auf der x-Achse und die Arbeitsgeschwindigkeit auf der y-Achse aufgetragen sind (Ma√üe pro Symbol - je <i>niedriger der Wert, desto h√∂her die Geschwindigkeit</i> ).  Das Hauptmerkmal dieses Diagramms ist, dass f√ºr jeden Parameterwert auf der x-Achse die Abtastung mehrmals durchgef√ºhrt wird. In diesem Fall wird der Test f√ºr jede Arraygr√∂√üe zehnmal wiederholt. </li><li>  Die Zeichen werden n√§mlich zuf√§llig und gleichm√§√üig aus dem Bereich [32, 127] ausgew√§hlt, sodass die Bedingung in der Funktion in etwa 27% der F√§lle erf√ºllt ist. </li><li>  Beide Auflistungen beziehen sich auf eine Raw-Cycle-Implementierung und unterscheiden sich nur in der Reihenfolge, in der die <i>Dateien</i> <i>&lt;algorithm&gt;</i> und <i>&lt;ctype.h&gt; enthalten sind</i> .  Der generierte Quellcode ist f√ºr alle Implementierungen gleich - sowohl in schnellen als auch in langsamen Versionen.  Eine Implementierung mit <i>std :: transform</i> erzeugt beispielsweise denselben langsamen Assembler-Code, wenn Sie die Datei <i>&lt;algorithm&gt;</i> einschlie√üen, und denselben schnellen Code, wenn Sie nur die Funktionsdefinition kopieren und die Datei nicht einschlie√üen. </li><li>  Diese schnelle Schleife ist jedoch langsamer als m√∂glich, da der Zeiger auf die Entsprechungstabelle innerhalb der Schleife zu oft gelesen wird ( <i>mov rdx, QWORD PTR [rax]</i> ).  Dieser Zeiger kann abh√§ngig von den regionalen Einstellungen unterschiedlich sein, wird jedoch w√§hrend der Ausf√ºhrung des Zyklus nicht aktualisiert und kann daher au√üerhalb des Zyklus verschoben werden.  Es muss sein, dass der Compiler der Ansicht ist, dass es nicht genug Gr√ºnde daf√ºr gibt, da wir in ein Array von Elementen vom Typ <i>char</i> schreiben, und sie k√∂nnen im Prinzip als Aliase f√ºr <i>[rax]</i> dh verwendet werden  Zeiger auf die Tabelle.  Jedenfalls wird auch <i>__restrict__</i> hier nicht helfen.  In einer anderen Version der Schleife, in der <i>lediglich die oberen</i> Werte hinzugef√ºgt und nichts in das Array geschrieben wird, wird <a href="https://godbolt.org/z/Kb6pc8">diese Optimierung angewendet</a> - der Zeiger wird au√üerhalb der Schleife gelesen. </li><li>  Diese √úberpr√ºfung spiegelt sich nicht im austauschbaren Assembler-Code wider, da der Compiler bereits wei√ü, dass die <i>Zeichenwerte</i> immer im Bereich <i>[-128, 255] liegen</i> .  Die Pr√ºfung ist nur erforderlich, weil die API der <i>toupper ¬©</i> -Funktion einen Wert vom Typ <i>int</i> anstelle von <i>char</i> akzeptiert, sodass der Benutzer eine beliebige Anzahl von Typ <i>int an sie √ºbergeben kann</i> , w√§hrend Entsprechungstabellen nur f√ºr Werte vom Typ <i>char konzipiert</i> sind. Die Pr√ºfung hilft daher, das Lesen au√üerhalb des Puffers zu vermeiden . </li><li>  Dies erkl√§rt √ºbrigens, warum die <i>std :: toupper-</i> Prozeduren unabh√§ngig von der Gr√∂√üe der Eingabedaten sind: Sie verwenden keine Verzweigungen (mit Ausnahme von Bereichspr√ºfungen, die bemerkenswerterweise vorhergesagt werden), sondern eine verzweigungsunabh√§ngige Entsprechungstabelle.  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">‚Üµ</a> </li><li>  Das Ersetzen dieses Aufrufs funktioniert auch bei einem sehr starken Wunsch nicht: Der Hauptteil der Funktion ist in der Header-Datei nicht verf√ºgbar. </li><li>  Ich kann nichts an <i>stdlib.h</i> (oder <i>&lt;algorithm&gt;</i> ) <i>bem√§ngeln</i> - es ist gut m√∂glich, dass viele andere C-Header-Dateien und alle C ++ - Header-Dateien ebenfalls dieses Verhalten verursachen. Ich habe sie nur nicht getestet.  Ich habe <i>stdlib.h</i> angeschlossen, um <i>size_t zu</i> bestimmen. </li></ol><br>  <b>Hinweis</b>  Dieser Artikel wurde erstmals auf der Website von <a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a> ver√∂ffentlicht.  √úbersetzte Artikel werden hier mit Genehmigung des Autors ver√∂ffentlicht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480012/">https://habr.com/ru/post/de480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480000/index.html">Server WebRTC-Kanalqualit√§tsanzeige √ºber TCP</a></li>
<li><a href="../de480002/index.html">R√ºckblick DevOpsDays Moskau: Einblicke aus 6 Berichten</a></li>
<li><a href="../de480006/index.html">Kanalqualit√§tsindikator f√ºr Server WebRTC √ºber TCP</a></li>
<li><a href="../de480008/index.html">Yuri Rogachev: "Ich bin gekommen, um das M-1 zu machen, ohne Computertechnologie zu kennen"</a></li>
<li><a href="../de480010/index.html">Top 3 HTML-Elemente, die wir vergessen haben</a></li>
<li><a href="../de480016/index.html">39% der russischen KMUs sind gezielten Cyberangriffen ausgesetzt</a></li>
<li><a href="../de480018/index.html">Mobile App-Entwicklung in Python. KivyMD-Bibliothek</a></li>
<li><a href="../de480022/index.html">Python-Instanziierung</a></li>
<li><a href="../de480024/index.html">Immergr√ºn: Einzelanweisungsprozessor</a></li>
<li><a href="../de480026/index.html">Ank√ºndigung der Vorschau von virtuellen Azure Spot-Maschinen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>