<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 ⛈️ 🚣 Clang-Format verlangsamt das Programm 👩🏿‍⚕️ 🍵 👩‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir die Leistung verschiedener Implementierungen der Topper-Funktion messen, da dies dienstags der Fall ist. 

 Eigentlich interessiert m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clang-Format verlangsamt das Programm</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/">  Heute werden wir die Leistung verschiedener Implementierungen der Topper-Funktion messen, da dies dienstags der Fall ist. <br><br>  Eigentlich <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>interessiert</i></a> mich die <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>Topper-</i></a> Funktion nicht, ich habe erst kürzlich einen weiteren Beitrag geschrieben und brauchte eine Art gemeinsamen Handlungskern, und <i>Topper</i> scheint ein ziemlich interessanter und harmloser Kandidat für Benchmarks zu sein.  Ich habe versucht, etwas so einfaches wie möglich zu wählen, das mich nicht zur Seite führt, aber es ist einfach so passiert, dass ich in diesem Test auf ein seltsames Problem gestoßen bin. <br><a name="habracut"></a><br>  Dieser Beitrag wird klein sein - ein umfassenderer Artikel zum ursprünglichen, vielleicht interessanteren Thema wird in Kürze erwartet.  Wenn du die Ergebnisse mit mir reproduzieren willst, kannst du <a href="https://github.com/travisdowns/toupper-bench">den</a> Quellcode <a href="https://github.com/travisdowns/toupper-bench">auf github nehmen</a> . <br><br>  Schauen wir uns also drei Implementierungen der Funktion <i>toupper an</i> , mit der die Zeichen eines Arrays, das aus Elementen vom Typ <i>char besteht,</i> in Großbuchstaben konvertiert werden. Dabei wird ein Array als Argument verwendet und seine Elemente direkt so geändert, dass alle Kleinbuchstaben groß geschrieben werden. <br><br>  In der ersten Implementierung rufen wir einfach <a href="https://linux.die.net/man/3/toupper">die Funktion toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">der</a> C-Standardbibliothek auf und führen eine Schleife im C-Stil aus: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br>  In der zweiten Implementierung verwenden wir einen <a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">moderneren</a> Ansatz, indem wir den Rohzyklus durch <i>std :: transform</i> ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br>  Schließlich verwenden wir in der dritten Implementierung einen speziellen Algorithmus, der mit ASCII-Zeichen arbeitet.  Es prüft, ob das Zeichen im Bereich von <i>a bis z liegt</i> , und ersetzt bei Erfolg den gleichen Buchstaben in Großbuchstaben, wobei die Zahl 32 vom Zeichencode [2] abgezogen wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br>  Sieht einfach aus, oder? <br><br>  Jetzt messen wir die Geschwindigkeit dieser Implementierungen auf meinem Laptop mit dem Skylake i7-6700HQ-Prozessor auf dem gcc 5.5-Compiler mit den Standardeinstellungen.  Die Ergebnisse werden in Form eines Streudiagramms angegeben [3]: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br>  Wir werden uns sofort mit drei Fragen befassen, die für unsere Aufgabe irrelevant sind. <br><br>  Schauen Sie sich zunächst das Diagramm des Verzweigungsalgorithmus an (grün dargestellt).  Sie variiert je nach Größe der Eingabedaten erheblich - die beiden anderen Diagramme bleiben nahezu flach.  Dies ist eigentlich nur ein Testartefakt.  Die eingegebenen ASCII-Zeichen werden zufällig ausgewählt [4], daher ist der entscheidende Faktor im Fall der dritten Implementierung die Operation des Verzweigungsvorhersagealgorithmus.  Mit einer kleinen Datenmenge wird die Reihenfolge der Elemente während der Iteration vollständig gespeichert, sodass die Anzahl der Fehlschläge gering und die Geschwindigkeit hoch ist, <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">wie in dieser Anmerkung gezeigt</a> .  Mit zunehmender Größe der Datensequenz merkt sich der Vorhersagealgorithmus immer weniger, bis er schließlich mit jedem Großbuchstaben (0,27 Fehler pro Zeichen) zu verfehlen beginnt, und dann wird der Graph nivelliert. <br><br>  Achten Sie zweitens auf die Gruppe der grünen Punkte oben links, die den viel niedrigeren Geschwindigkeiten der Variante mit Verzweigung <i>toupper_branch entsprechen</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br>  Dies ist kein isoliertes Artefakt: Solche Stellen traten bei mehreren Starts auf.  Gleichzeitig können sie nicht reproduziert werden, wenn Sie den Algorithmus nur speziell für diese Datengrößen testen. Sie werden nur angezeigt, wenn der Test für alle Größen ausgeführt wird.  In diesem Fall werden sie jedoch nicht immer angezeigt.  Ich habe mich nicht speziell damit befasst, kann aber davon ausgehen, dass dies auf Konflikte bei Namen oder Aliasen im Algorithmus für die Verzweigungsvorhersage zurückzuführen ist oder wenn physische Seiten mit 4 kB Arbeitsspeicher auf virtuell abgebildet werden (obwohl die Randomisierung des virtuellen Adressraums deaktiviert war). <br><br>  Drittens sieht die Implementierung von <i>toupper_rawloop</i> (in Blau dargestellt) in der Grafik wie zwei separate Linien aus: eine geringfügig über der Marke von 2 Kennzahlen pro Zeichen und die andere auf der Ebene von 1,5 Kennzahlen pro Zeichen.  Diese beiden Zeilen tauchten bei allen Testern auf.  Die schnellere Option mit einer Geschwindigkeit von 1,57 Zeichen pro Zyklus verlangsamt die Download-Ports tatsächlich: Das Lesen der Daten an den Ports 2 und 3 erfolgt mit einer Geschwindigkeit von 1,54 Mikrooperationen pro Zyklus, sodass diese zu 98% ausgelastet sind.  Ich konnte den Grund für das langsamere „Regime“ nicht feststellen. <br><br>  Während ich mich mit diesem Thema beschäftigte, verschwand das schnelle „Regime“ plötzlich und nur das langsame blieb übrig.  Vielleicht hat der Prozessor gemerkt, was ich versucht habe, und hat das Update für den Mikrocode heimlich heruntergeladen, um den Widerspruch zu beseitigen, aber ich habe (noch) Beweise - ein Vektorbild mit Diagrammen. <br><br>  Was interessiert uns dann an diesem Beispiel? <br><br>  Was uns jedoch interessiert, ist, dass die Version mit einem Rohzyklus 3-4 mal schneller ist als die Version mit <i>std :: transform</i> : 1,5-2 Zyklen pro Zeichen gegenüber 7 mit einigen Zyklen pro Zeichen. <br><br>  Was ist hier los?  Haben mich Standardalgorithmen gescheitert?  Hat <i>std :: transform</i> einen Fehler? <br><br>  Nicht wirklich.  Genauer gesagt, überhaupt nicht. <br><br>  Es stellt sich heraus, dass solche Ergebnisse auftreten, wenn Funktionen in <a href="">verschiedenen Dateien</a> kompiliert <a href="">werden</a> .  Wenn Sie sie in dieselbe Datei einfügen, ist ihre Leistung gleichermaßen niedrig. <br><br>  Und nein, Ausrichtung hat nichts damit zu tun. <br><br>  Das ist aber noch nicht alles: Die schnelle Version mit einem Rohzyklus wird beim Kompilieren in einer separaten Datei langsamer, wenn Sie einfach die <i>&lt;algorithm&gt;</i> -Headerdatei anhängen.  Ja, das ist richtig: Verbinden Sie einfach diese Datei, die nie verwendet wird und keinen Code in der endgültigen Objektdatei generiert, und die Geschwindigkeit des "rohen" Zyklus wird 3-4 mal sinken.  Im Gegensatz dazu wird die Version mit <i>std :: transform</i> bis zum Limit beschleunigt, wenn Sie die Implementierung von <i>std :: transform</i> aus der Datei <i>&lt;algorithm&gt;</i> kopieren und einfügen, diese Datei jedoch nicht einschließen. <br><br>  Seltsamkeiten hören hier nicht auf (ich verspreche, es wird keine weiteren geben): Das Einbeziehen der <i>&lt;algorithm&gt;</i> -Datei führt nicht immer zu dem beschriebenen Effekt.  Ein Geschwindigkeitsabfall tritt auf, wenn <i>&lt;algorithm&gt;</i> früher als <i>&lt;ctype.h&gt; verbunden</i> ist, wenn Sie sie jedoch <i>austauschen</i> , dann nein: <br><br>  <b>Langsamer Code:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>Kurzcode:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br>  Eigentlich ist mir diese Anomalie (in einem anderen Projekt) aufgefallen, als clang-format die enthaltenen Header-Dateien automatisch sortiert und den <i>&lt;Algorithmus&gt; ganz</i> am Anfang der Liste platziert hat, wo er hingehört (daher der Clickbait-Header des Artikels). <br><br>  Natürlich mussten wir uns früher oder später in die Liste der Assembler stürzen.  Wir werden diesen unangenehmen Moment nicht aufhalten. <br><br>  Die <a href="https://godbolt.org/z/DwZBJM">schnellen und langsamen</a> Versionen der Funktionen [5] sind unten dargestellt, kleine Schleifen sind mit Anmerkungen versehen: <br><br>  <b>&lt;algorithm&gt; verbindet sich zuerst:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithm&gt; ist an zweiter Stelle verbunden:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br>  Der Hauptunterschied besteht darin, dass in der langsamen Version die toupper-Funktion einfach in einer Schleife aufgerufen wird, während in der schnellen Version die Funktionsaufrufe vollständig fehlen und nur in der Entsprechungstabelle [6] gesucht wird, d. H  Der Body der Funktion <i>std :: toupper</i> wird an der Stelle des Aufrufs eingesetzt <br><br>  Wenn Sie sich den <a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">Quellcode</a> der glibc-Bibliothek ansehen, finden wir dort die Implementierung der <i>toupper-</i> Funktion: <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH –  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br>  Wie wir sehen können, ist <i>toupper</i> als <i>externe Inline-</i> Funktion definiert, die zuerst prüft, ob die Größe des <i>Zeichenzeichens</i> in ein Byte passt [7] und dann in der von der Funktion <i>__ctype_toupper_loc () zurückgegebenen</i> Entsprechungstabelle nach dem Zeichen sucht.  Diese Funktion gibt einen lokalen Datenstromzeiger (vom Typ <i>const int **</i> ) zurück, der wiederum auf eine Entsprechungstabelle verweist, aus der auf eine Anfrage nach unserem Symbol hin die Großbuchstabenversion zurückgegeben wird [8]. <br><br>  Jetzt ist klar, was in der Auflistung passiert.  In der schnellen Version des Algorithmus ersetzt der Compiler den Body der Funktion <i>toupper</i> , kann jedoch den Aufruf der Funktion <i>__ctype_toupper_loc ()</i> nicht ersetzen [9].  Dieser Aufruf wird jedoch als <i>__attribute __ ((const))</i> deklariert, was bedeutet, dass der Rückgabewert nur von den Argumenten abhängt (die nicht hier sind).  Der Compiler weiß, dass diese Funktion jedes Mal den gleichen Wert zurückgibt und daher ihren Aufruf außerhalb der Schleife ausführt. In der Schleife selbst gibt es nur wenige Leseoperationen, die mit dem Zugriff auf die Entsprechungstabelle, dem Schreiben eines neuen Werts in den Puffer und der Schleifensteuerung verbunden sind. <br><br>  In der langsamen Version bleibt der Aufruf von <i>toupper ()</i> im Rumpf der Schleife.  Die Schleife selbst ist um einen Befehl kürzer, aber jetzt müssen Sie natürlich noch den gesamten Code innerhalb der <i>toupper-</i> Funktion ausführen.  Auf meinem System sieht es so aus: <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br>  Da dies ein nicht eingebetteter Aufruf ist, erledigt das Programm mehr Arbeit.  Es gibt mindestens fünf aufeinanderfolgende Operationen zum Zugreifen auf den Speicher (das sogenannte Verfolgen von Zeigern, <i>Zeigerjagen</i> ).  In der Schnellversion bleiben nur zwei übrig, da alle anderen aus der Schleife genommen werden.  Die Verzögerung zwischen dem Aufruf und dem Verlassen einer Funktion sollte ungefähr 25 Zyklen betragen, und es werden ungefähr 7 Zyklen ausgegeben. Dies bedeutet, dass der Prozessor den Aufruf parallelisieren konnte, was unter den gegebenen Umständen recht gut ist. <br><br>  Warum ist das so? <br><br>  In einer langen Kette von Include-Dateien enthalten C ++ - Header-Dateien wie <i>&lt;algorithm&gt;</i> wiederum die Datei <i>&lt;bits / os_defines.h&gt;</i> , die die folgende Zeile enthält: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br>  Wenn die Datei <i>&lt;ctype.h&gt;</i> endgültig verbunden ist, kann aufgrund dieser Anweisung der Code, in dem <i>toupper</i> als <i>extern inline</i> definiert ist, nicht eingeschlossen werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br>  Beachten Sie, dass beim Verbinden von <i>&lt;ctype.h&gt; die</i> C ++ - Version von <i>toupper</i> niemals als Makro definiert wird - maximal als <i>externes</i> <i>Inline</i> -, da die Definitionen der Makros durch die <i>! Defined __cplusplus-Prüfung</i> geschützt sind und daher niemals wirksam werden. <br><br>  Im Allgemeinen weiß ich nicht genau, ob <i>__NO_CTYPE</i> in diesem Fall die als <i>extern inline</i> deklarierten Körper der <i>tolower-</i> und <i>toupper-</i> Funktionen ausschließen soll, aber genau das passiert - und damit eine signifikante <i>Verringerung</i> der Geschwindigkeit unseres Zyklus.  Zusammenfassend kann ich sagen, dass, wenn Sie <i>&lt;cctype&gt;</i> anstelle von <i>&lt;ctype.h&gt; einfügen</i> (d. H. C ++ ist die Version der C-Header-Datei, die Funktionen in den <i>std ::</i> <i>-Namensraum schreibt</i> ), der Code in diesem Fall langsam arbeitet weil <i>&lt;cctype&gt;</i> letztendlich <i>&lt;bits / os_defines.h&gt; enthält</i> . <br><br>  Ist das alles so wichtig?  Ja Nein. <br><br>  Die Funktion <i>toupper</i> eignet sich nicht für ernsthafte Arbeiten mit Zeichen verschiedener Sprachen. Wenn Sie also nur ASCII-Zeichen verarbeiten müssen, können Sie Ihre eigene schnellere Implementierung <i>erstellen</i> .  Wenn Sie ernsthaft mit Text arbeiten müssen, werden Sie höchstwahrscheinlich UTF-8 verwenden und eine Art ICU verwenden müssen, um regionale Einstellungen zu unterstützen, oder warten, bis die Unicode-Unterstützung in C ++ angezeigt wird (das Warten kann lange dauern). .  Die Aussage „Clang-Format kann zu einem 4x Leistungseinbruch führen“ eignet sich daher nur als Clickbait-Header. <br><br>  Wird dieser Effekt in allen libc-Versionen beobachtet?  Ja, in fast allen Fällen, aber auch hier ist es nicht so einfach. <br><br>  Die oben gezeigten Ergebnisse gelten für gcc 5.5 und glibc 2.23, da ich diese Versionen verwendet habe, aber in den neuen Versionen passiert etwas Neues (ab ungefähr glibc 2.27).  Dort führt das Einschalten von <i>&lt;algorithm&gt;</i> vor <i>&lt;ctype.h&gt;</i> immer noch zu demselben Effekt, aber jetzt verursacht <i>&lt;stdlib.h&gt;</i> [10] auch Probleme: Wenn Sie es vor <i>&lt;ctype.h&gt; einschalten</i> , sinkt auch die Leistung, was nicht der Fall ist in früheren Versionen beobachtet.  In neueren Versionen enthält die Datei <i>&lt;stdlib.h&gt;</i> <i>natürlich</i> auch die Definition <i>__NO_CTYPE</i> .  Zumindest wird es jetzt nicht möglich sein, das Clang-Format für das Sortieren verantwortlich zu machen - hier kann es nur helfen, das Problem zu lösen (wenn die Liste der verbundenen Dateien keine anderen Problemdateien enthält). <br><br>  Ich habe <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">einen Fehlerbericht in libc</a> gepostet, daher ist es wahrscheinlich, dass dieser Fehler behoben wird. Es besteht jedoch kein Zweifel, dass Fehler in Bezug auf die Reihenfolge, in der Header-Dateien verbunden sind, uns weiter belästigen. <br><br><h2>  Kommentare </h2><br>  Ich habe kein Kommentarsystem auf meiner Website, arbeite jedoch daran (das heißt, ich jammere regelmäßig, was bei statischen Websites schwierig ist, Kommentare abzugeben). <br><br>  In der Zwischenzeit können Sie diesen Artikel auf der <a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News-</a> Website oder unter <a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs diskutieren</a> . <br><br><h2>  Danksagung </h2><br>  <i>Wir danken</i> dem ufo-Benutzer von Hacker News, der <a href="https://news.ycombinator.com/item%3Fid%3D21579483">darauf hingewiesen hat,</a> dass es nicht erforderlich ist, die Lambda-Funktion zu verwenden, um <i>std :: toupper</i> für die Verwendung in <i>std :: transform</i> anzupassen, und auch Jonathan Muller, der <a href="https://twitter.com/foonathan/status/1197051249822195712">erklärte,</a> dass die Lambda-Funktion weiterhin benötigt wird. <br><br><ol><li>  Ja, die Funktion <i>toupper (3)</i> aus der Header-Datei <i>&lt;ctype.h&gt;</i> ist nicht für die Arbeit mit den meisten Nicht-ASCII-Zeichen geeignet  Es können keine Zeichen verarbeitet werden, die größer als ein Byte sind, dies ist jedoch für unsere Aufgabe geeignet, da nur ASCII-Zeichenfolgen übergeben werden. </li><li>  In der ASCII-Tabelle befinden sich Klein- und Großbuchstaben sehr bequem in einem Abstand von 32 Positionen voneinander. Dies bedeutet, dass Sie Zeichen von einer Groß- / Kleinschreibung in eine andere übertragen können, indem Sie einfach 32 subtrahieren oder addieren. Wenn wir sicher wären, dass alle Eingaben vorhanden sind <i>Da es sich</i> bei den Daten um ASCII-Buchstaben handelt, könnten wir das 5. Bit ohne Prüfung zurücksetzen (z. B. <i>c &amp; 0b11011111</i> ), um jeden Großbuchstaben in Kleinbuchstaben <i>umzuwandeln</i> , was sich jedoch nicht in Kleinbuchstaben niederschlägt.  Aber wir wissen es wahrscheinlich nicht, deshalb müssen wir prüfen, ob es sich bei dem Zeichen um einen Buchstaben handelt, um nicht versehentlich Buchstaben wie <i>char zu unterbrechen</i> . </li><li>  Es sollte ein Streudiagramm mit dem Zusatz von "Rauschen" an der Stelle der Punkte genannt werden.  In der Tat ist dies ein gewöhnliches Streudiagramm, in dem der für uns interessante Parameter (die Größe der Eingabedaten) auf der x-Achse und die Arbeitsgeschwindigkeit auf der y-Achse aufgetragen sind (Maße pro Symbol - je <i>niedriger der Wert, desto höher die Geschwindigkeit</i> ).  Das Hauptmerkmal dieses Diagramms ist, dass für jeden Parameterwert auf der x-Achse die Abtastung mehrmals durchgeführt wird. In diesem Fall wird der Test für jede Arraygröße zehnmal wiederholt. </li><li>  Die Zeichen werden nämlich zufällig und gleichmäßig aus dem Bereich [32, 127] ausgewählt, sodass die Bedingung in der Funktion in etwa 27% der Fälle erfüllt ist. </li><li>  Beide Auflistungen beziehen sich auf eine Raw-Cycle-Implementierung und unterscheiden sich nur in der Reihenfolge, in der die <i>Dateien</i> <i>&lt;algorithm&gt;</i> und <i>&lt;ctype.h&gt; enthalten sind</i> .  Der generierte Quellcode ist für alle Implementierungen gleich - sowohl in schnellen als auch in langsamen Versionen.  Eine Implementierung mit <i>std :: transform</i> erzeugt beispielsweise denselben langsamen Assembler-Code, wenn Sie die Datei <i>&lt;algorithm&gt;</i> einschließen, und denselben schnellen Code, wenn Sie nur die Funktionsdefinition kopieren und die Datei nicht einschließen. </li><li>  Diese schnelle Schleife ist jedoch langsamer als möglich, da der Zeiger auf die Entsprechungstabelle innerhalb der Schleife zu oft gelesen wird ( <i>mov rdx, QWORD PTR [rax]</i> ).  Dieser Zeiger kann abhängig von den regionalen Einstellungen unterschiedlich sein, wird jedoch während der Ausführung des Zyklus nicht aktualisiert und kann daher außerhalb des Zyklus verschoben werden.  Es muss sein, dass der Compiler der Ansicht ist, dass es nicht genug Gründe dafür gibt, da wir in ein Array von Elementen vom Typ <i>char</i> schreiben, und sie können im Prinzip als Aliase für <i>[rax]</i> dh verwendet werden  Zeiger auf die Tabelle.  Jedenfalls wird auch <i>__restrict__</i> hier nicht helfen.  In einer anderen Version der Schleife, in der <i>lediglich die oberen</i> Werte hinzugefügt und nichts in das Array geschrieben wird, wird <a href="https://godbolt.org/z/Kb6pc8">diese Optimierung angewendet</a> - der Zeiger wird außerhalb der Schleife gelesen. </li><li>  Diese Überprüfung spiegelt sich nicht im austauschbaren Assembler-Code wider, da der Compiler bereits weiß, dass die <i>Zeichenwerte</i> immer im Bereich <i>[-128, 255] liegen</i> .  Die Prüfung ist nur erforderlich, weil die API der <i>toupper ©</i> -Funktion einen Wert vom Typ <i>int</i> anstelle von <i>char</i> akzeptiert, sodass der Benutzer eine beliebige Anzahl von Typ <i>int an sie übergeben kann</i> , während Entsprechungstabellen nur für Werte vom Typ <i>char konzipiert</i> sind. Die Prüfung hilft daher, das Lesen außerhalb des Puffers zu vermeiden . </li><li>  Dies erklärt übrigens, warum die <i>std :: toupper-</i> Prozeduren unabhängig von der Größe der Eingabedaten sind: Sie verwenden keine Verzweigungen (mit Ausnahme von Bereichsprüfungen, die bemerkenswerterweise vorhergesagt werden), sondern eine verzweigungsunabhängige Entsprechungstabelle.  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">↵</a> </li><li>  Das Ersetzen dieses Aufrufs funktioniert auch bei einem sehr starken Wunsch nicht: Der Hauptteil der Funktion ist in der Header-Datei nicht verfügbar. </li><li>  Ich kann nichts an <i>stdlib.h</i> (oder <i>&lt;algorithm&gt;</i> ) <i>bemängeln</i> - es ist gut möglich, dass viele andere C-Header-Dateien und alle C ++ - Header-Dateien ebenfalls dieses Verhalten verursachen. Ich habe sie nur nicht getestet.  Ich habe <i>stdlib.h</i> angeschlossen, um <i>size_t zu</i> bestimmen. </li></ol><br>  <b>Hinweis</b>  Dieser Artikel wurde erstmals auf der Website von <a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a> veröffentlicht.  Übersetzte Artikel werden hier mit Genehmigung des Autors veröffentlicht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480012/">https://habr.com/ru/post/de480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480000/index.html">Server WebRTC-Kanalqualitätsanzeige über TCP</a></li>
<li><a href="../de480002/index.html">Rückblick DevOpsDays Moskau: Einblicke aus 6 Berichten</a></li>
<li><a href="../de480006/index.html">Kanalqualitätsindikator für Server WebRTC über TCP</a></li>
<li><a href="../de480008/index.html">Yuri Rogachev: "Ich bin gekommen, um das M-1 zu machen, ohne Computertechnologie zu kennen"</a></li>
<li><a href="../de480010/index.html">Top 3 HTML-Elemente, die wir vergessen haben</a></li>
<li><a href="../de480016/index.html">39% der russischen KMUs sind gezielten Cyberangriffen ausgesetzt</a></li>
<li><a href="../de480018/index.html">Mobile App-Entwicklung in Python. KivyMD-Bibliothek</a></li>
<li><a href="../de480022/index.html">Python-Instanziierung</a></li>
<li><a href="../de480024/index.html">Immergrün: Einzelanweisungsprozessor</a></li>
<li><a href="../de480026/index.html">Ankündigung der Vorschau von virtuellen Azure Spot-Maschinen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>