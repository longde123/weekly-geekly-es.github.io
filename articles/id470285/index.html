<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙊 🐲 👨🏾‍🚀 Seekor harimau yang meringkuk bersembunyi di SQLAlchemy. Dasar-dasarnya 👩🏻‍🎨 👨🏽‍🚒 ⏲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari yang baik 


 Hari ini saya ingin berbicara tentang ORM SQLAlchemy. Mari kita bicara tentang apa itu tentang kemampuan dan fleksibilitasnya, dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seekor harimau yang meringkuk bersembunyi di SQLAlchemy. Dasar-dasarnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470285/"><p><img src="https://habrastorage.org/webt/3o/ji/ei/3ojiei46dcl8pihke7rjjojlgn4.jpeg"></p><br><p>  Hari yang baik </p><br><p>  Hari ini saya ingin berbicara tentang ORM SQLAlchemy.  Mari kita bicara tentang apa itu tentang kemampuan dan fleksibilitasnya, dan juga mempertimbangkan kasus-kasus yang tidak selalu dijelaskan dengan jelas. </p><br><p>  ORM ini memiliki ambang masuk di atas rata-rata, jadi saya akan mencoba menjelaskan semuanya dalam bahasa yang sederhana dan dengan contoh.  Artikel ini akan berguna bagi mereka yang sudah bekerja dengan sqlalchemy dan ingin meningkatkan keterampilan mereka atau hanya berkenalan dengan perpustakaan ini. </p><a name="habracut"></a><br><p>  Bahasa pemrograman yang digunakan adalah python 3.6. <br>  DB - PostgreSQL. <br>  Tautan Github </p><br><p>  Jadi apa itu ORM? </p><br><p>  ORM (Object-Relational Mapping) adalah teknologi yang memungkinkan Anda memetakan model yang tipenya tidak kompatibel.  Sebagai contoh: tabel database dan objek bahasa pemrograman. </p><br><p> Dengan kata lain, Anda bisa mengakses objek kelas untuk mengelola data dalam tabel database.  Anda juga dapat membuat, memodifikasi, menghapus, memfilter dan, yang paling penting, mewarisi objek kelas yang dipetakan ke tabel database, yang secara signifikan mengurangi konten basis kode. </p><br><p>  Untuk menggunakan SQLAlchemy, Anda perlu memahami cara kerjanya. </p><br><p>  Pengembang yang menggunakan Django-ORM harus sedikit membangun kembali pola pikir mereka untuk membuat permintaan ORM.  Menurut pendapat saya, SQLAlchemy adalah monster fungsional yang kemampuannya dapat dan harus digunakan, tetapi Anda perlu memahami bahwa ORM tidak selalu sempurna.  Karena itu, kita akan membahas saat-saat ketika penggunaan teknologi ini disarankan. </p><br><p>  SQLAlchemy memiliki konsep definisi model deklaratif dan non-deklaratif. </p><br><p>  Definisi non-deklaratif menyiratkan penggunaan mapper (), yang menggambarkan pemetaan setiap kolom basis data dan kelas model. </p><br><p>  Artikel ini menggunakan definisi model deklaratif. </p><br><p>  Lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> </p><br><h3 id="struktura-bd">  Struktur DB </h3><br><p>  Untuk konsistensi data yang lengkap, mari kita buat tabel berikut. </p><br><p>  Model dasar digunakan untuk menentukan kolom dasar dalam database. </p><br><pre><code class="plaintext hljs">class BaseModel(Base): __abstract__ = True id = Column(Integer, nullable=False, unique=True, primary_key=True, autoincrement=True) created_at = Column(TIMESTAMP, nullable=False) updated_at = Column(TIMESTAMP, nullable=False) def __repr__(self): return "&lt;{0.__class__.__name__}(id={0.id!r})&gt;".format(self)</code> </pre> <br><p>  Karyawan - tabel yang menggambarkan karyawan yang bekerja di kantor </p><br><pre> <code class="plaintext hljs">class Employee(BaseModel): __tablename__ = 'employees' first_name = Column(VARCHAR(255), nullable=False) last_name = Column(VARCHAR(255), nullable=False) phone = Column(VARCHAR(255), unique=True, nullable=True) description = Column(VARCHAR(255), nullable=True)</code> </pre> <br><p>  EmployeeWithSkills bukan sebuah tabel.  Kelas diwarisi dari Karyawan.  Kesempatan besar untuk memisahkan logika dan menggunakan kelas seolah-olah itu adalah tabel yang terpisah. </p><br><pre> <code class="plaintext hljs">class EmployeeWithSkills(Employee): skills = relation(Skill, secondary=EmployeesSkills.__tablename__, lazy='joined')</code> </pre> <br><p>  Departemen - departemen tempat karyawan ini bekerja.  Seseorang dapat terdiri dari beberapa departemen. </p><br><pre> <code class="plaintext hljs">class Department(BaseModel): __tablename__ = 'departments' name = Column(VARCHAR(255), nullable=False) description = Column(VARCHAR(255), nullable=False)</code> </pre> <br><p>  Tabel korespondensi karyawan dan unit di mana ia menjadi anggota. </p><br><pre> <code class="plaintext hljs">class EmployeeDepartments(BaseModel): __tablename__ = 'employee_departments' employee_id = Column(Integer, ForeignKey('employees.id', ondelete='CASCADE'), nullable=False, index=True) department_id = Column(Integer, ForeignKey('departments.id', ondelete='CASCADE'), nullable=False, index=True)</code> </pre> <br><p>  Tabel korespondensi karyawan dan keterampilan mereka. </p><br><pre> <code class="plaintext hljs">class EmployeesSkills(BaseModel): __tablename__ = 'employees_skills' employee_id = Column(ForeignKey('employee.id', ondelete='CASCADE'), nullable=False, index=True) skill_id = Column(ForeignKey('skills.id', ondelete='CASCADE'), nullable=False, index=True)</code> </pre> <br><p>  Kami membuat migrasi menggunakan paket alembic, yang memungkinkan Anda untuk membuatnya secara otomatis.  Dalam pelajaran ini, pembuatan migrasi secara otomatis dapat diterima. </p><br><p>  Migrasi terbaru berisi data uji yang akan mengisi basis data. <br>  Cara mengkonfigurasi alembic dapat dibaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br>  Kami melakukan peningkatan kepala alembic yang berharga untuk melakukan migrasi. </p><br><h3 id="zaprosy-i-relations">  Permintaan dan hubungan </h3><br><p>  Mari kita membuat permintaan pertama dan mendapatkan informasi tentang karyawan dengan id-nya. <br>  Permintaan akan terlihat seperti ini: </p><br><p>  lesson1: </p><br><pre> <code class="plaintext hljs">employee = session.query(Employee).filter(Employee.id == eid).one() output: ID: 2, Tony Stark</code> </pre> <br><p>  <code>.one()</code> pada akhirnya berarti kami hanya ingin mendapatkan satu entri.  Jika ada beberapa entri, pengecualian yang sesuai akan dimunculkan. </p><br><p>  Jika kami ingin mendapatkan semua departemen yang tersedia, maka kami dapat menggunakan kueri berikut menggunakan <code>.all()</code> </p><br><p>  lesson2: </p><br><pre> <code class="plaintext hljs">emmployee = session.query(Department).all() output: ID: 2, name: Guards ID: 4, name: Legions</code> </pre> <br><p>  Pertimbangkan bekerja dengan fungsi agregasi. </p><br><p>  Kami bisa mendapatkan jumlah departemen yang tersedia menggunakan fungsi bawaan. <br>  <code>.count()</code> atau gunakan <code>func.count()</code> .  Menggunakan metode kedua, Anda dapat mengakses fungsi SQL apa pun dengan <code>select</code> atau menghitung hasil antara. </p><br><p>  lesson3: </p><br><pre> <code class="plaintext hljs">def get_departments_count(session: DBSession) -&gt; int: count = session.query(Department).count() return count def get_departments_func_count(session: DBSession) -&gt; int: count = session.query(func.count(Department.id)).scalar() return count</code> </pre> <br><p>  Banyak pengembang menggunakan fungsi <code>count()</code> untuk memeriksa data dalam permintaan.  Ini bukan praktik yang baik, menyebabkan penggunaan sumber daya basis data tambahan dan meningkatkan waktu eksekusi kueri.  Solusi yang baik adalah dengan menggunakan fungsi <code>exists()</code> yang mengembalikan nilai skalar: <br>  lesson3: </p><br><pre> <code class="plaintext hljs">def check_department_exists(session: DBSession, department_name: str) -&gt; bool: is_exists = session.query(exists().where(Department.name == department_name)).scalar() return is_exists</code> </pre> <br><p>  Selanjutnya, kami menyulitkan tugas dan berkenalan dengan <code>relation</code> entitas atau <code>relationship</code> .  Faktanya adalah bahwa dalam <code>SQLAlchemy</code> selain menggunakan foreign_key <br>  di tingkat basis data, hubungan antar objek juga digunakan. </p><br><p>  Dengan demikian, kita bisa mendapatkan baris basis data bergantung pada kunci asing di objek. <br>  Objek-objek ini adalah proyeksi pada tabel database, saling berhubungan. </p><br><p>  <code>Relations</code> dalam <code>SQLAlchemy</code> memiliki konfigurasi yang fleksibel, memungkinkan Anda untuk mendapatkan data dari database dengan cara yang berbeda pada waktu yang berbeda menggunakan argumen bernama <code>lazy</code> . </p><br><p>  Tingkat utama "kemalasan": </p><br><ul><li>  <code>select</code> adalah default.  ORM membuat permintaan hanya ketika mengakses data.  Itu dilakukan dalam permintaan terpisah. </li><li>  <code>dynamic</code> - memungkinkan Anda mendapatkan objek permintaan, yang dapat dimodifikasi sesuai keinginan.  Ini menerima data dari database hanya setelah memanggil semua () atau satu () atau metode lain yang tersedia. </li><li>  <code>joined</code> - ditambahkan ke permintaan utama menggunakan LEFT JOIN.  Itu dilakukan segera. </li><li>  <code>subquery</code> - mirip dengan memilih, tetapi dieksekusi sebagai subquery. </li></ul><br><p>  Defaultnya adalah <code>select</code> . </p><br><p>  Pemfilteran dalam kueri bisa statis dan dinamis.  Penyaringan dinamis memungkinkan mengisi permintaan dengan filter, yang dapat bervariasi tergantung pada progres fungsi. </p><br><p>  lesson4: </p><br><pre> <code class="plaintext hljs">def dynamic_filter(session: DBSession, filter: DFilter = None): query = session.query(Employee) if filter is not None: query = query.filter(*filter.conds) employees = query.all() return employees</code> </pre> <br><p>  Kelas filter DFilter mendefinisikan filter berdasarkan input apa pun.  Jika kelas filter ditentukan, tetapi lebih lanjut dalam kondisi permintaan berlaku. </p><br><p>  Fungsi .filter () menerima menerima kondisi biner SQLAlchemy, sehingga dapat direpresentasikan menggunakan * </p><br><p>  Penggunaan filter dinamis hanya dibatasi oleh imajinasi.  Hasil kueri menunjukkan pahlawan mana yang saat ini tidak aktif. </p><br><pre> <code class="plaintext hljs">output: Inactive_heros: Name: Tony Stark Name: Scott Lang Name: Peter Parker</code> </pre> <br><p>  Saya sarankan bekerja dengan hubungan banyak ke banyak. </p><br><p>  Kami memiliki tabel Karyawan di mana ada hubungannya dengan tabel korespondensi EmployeesSkills.  Ini berisi foreign_key di tabel karyawan dan foreign_key <br>  ke meja keterampilan. </p><br><p>  pelajaran 5: </p><br><pre> <code class="plaintext hljs">def get_employee_with_skills(session: DBSession, eid: int): employee = session.query(EmployeeWithSkills).filter(EmployeeWithSkills.id == eid).one() return employee output: Employee Tony Stark has skills: Skill: Fly, Desc: I belive I can Fly. I belive I can touch the sky Skill: Light Shield, Desc: Light protect. Perfect for everything</code> </pre> <br><p>  Menggunakan kelas EmployeeWithSkills dalam kueri di atas, kami menyebutnya sebagai tabel database, tetapi pada kenyataannya tabel seperti itu tidak ada.  Kelas ini berbeda dari Karyawan yang memiliki hubungan, yang memiliki hubungan banyak ke banyak.  Jadi kita bisa membedakan logika kelas, mengisinya dengan serangkaian hubungan yang berbeda.  Sebagai hasil dari permintaan, kami akan melihat keterampilan salah satu karyawan. </p><br><p>  Karena karyawan dapat berada di beberapa departemen, buat hubungan yang memungkinkan Anda mendapatkan informasi ini. </p><br><p>  Buat kelas EmployeeWithDepartments yang diwarisi dari Karyawan dan tambahkan berikut ini: </p><br><pre> <code class="plaintext hljs">class EmployeeWithDepartments(Employee): departments = relation( Department, # primaryjoin=EmployeeDepartments.employee_id == Employee.id, secondary=EmployeeDepartments.__tablename__, # secondaryjoin=EmployeeDepartments.department_id == Department.id, )</code> </pre> <br><p>  Kelas yang dibuat bukan tabel database baru.  Ini masih tabel Karyawan yang sama, hanya diperluas menggunakan <code>relation</code> .  Dengan cara ini Anda bisa mengakses tabel <code>EmployeeWithDepartments</code> atau <code>EmployeeWithDepartments</code> dalam kueri.  Perbedaannya hanya akan ada / tidak adanya <code>relation</code> . </p><br><p>  Argumen pertama menunjukkan tabel mana yang akan kita buat <code>relation</code> . <br>  <code>primaryjoin</code> adalah kondisi di mana tabel kedua akan terhubung sebelum terpasang ke objek. <br>  <code>secondary</code> adalah nama tabel yang berisi foreign_keys untuk dicocokkan.  Digunakan untuk banyak-banyak. <br>  <code>secondaryjoin</code> - kondisi untuk mencocokkan tabel perantara dengan yang terakhir. </p><br><p>  <code>primaryjoin</code> dan <code>primaryjoin</code> berfungsi untuk secara eksplisit menunjukkan korespondensi dalam situasi yang kompleks. </p><br><p>  Kadang-kadang situasi muncul ketika perlu untuk membuat filter yang bidangnya dinyatakan dalam relasi, dan relasi, pada gilirannya, adalah relasi dari kelas asli. </p><br><pre> <code class="plaintext hljs">EmployeeWithCadreMovements -&gt; relation(CadreMovement) -&gt; field</code> </pre> <br><p>  Jika relasi menampilkan daftar nilai, maka .any () harus digunakan, jika hanya satu nilai yang diberikan, maka .has () harus digunakan </p><br><p>  Untuk pemahaman yang lebih baik, konstruk ini akan ditafsirkan dalam bahasa SQL ke dalam konstruk exist (). </p><br><p>  Kami memanggil fungsi get dengan parameter parameter alasan, misalnya, <code>simple</code> . </p><br><p>  pelajaran6 </p><br><pre> <code class="plaintext hljs">def has_in_relations(session: DBSession, reason: str): employees = session.query(EmployeeWithCadreMovements).filter(EmployeeWithCadreMovements.cadre_movements.any(CadreMovement.reason == reason)).all() return employees output: [Steve Rogers, Tony Stark]</code> </pre> <br><p>  lession7 </p><br><p>  Pertimbangkan kemungkinan untuk memperoleh hubungan menggunakan fungsi agregasi.  Sebagai contoh, kami mendapatkan perpindahan personel terakhir dari pengguna tertentu. <br>  primaryjoin adalah kondisi untuk bergabung dengan tabel (jika lazy = 'bergabung' digunakan).  Ingat bahwa pilih digunakan secara default. <br>  Dalam hal ini, permintaan terpisah dihasilkan ketika mengakses atribut kelas.  Untuk permintaan ini kita dapat menentukan kondisi penyaringan. <br>  Seperti yang Anda ketahui, Anda tidak dapat menggunakan fungsi agregasi dalam bentuk "murni" dalam kondisi WHERE, jadi kami dapat mengimplementasikan fitur ini dengan menentukan relasi <br>  dengan parameter berikut: </p><br><pre> <code class="plaintext hljs">last_cadre_movement = relation( CadreMovement, primaryjoin=and_( CadreMovement.employee == Employee.id, uselist=False, CadreMovement.id == select([func.max(CadreMovement.id)]).where(CadreMovement.employee == Employee.id) ) )</code> </pre> <br><p>  Ketika dieksekusi, permintaan dikompilasi seperti ini: </p><br><pre> <code class="plaintext hljs">SELECT cadre_movements.id AS cadre_movements_id, cadre_movements.created_at AS cadre_movements_created_at, cadre_movements.updated_at AS cadre_movements_updated_at, cadre_movements.employee AS cadre_movements_employee, cadre_movements.old_department AS cadre_movements_old_department, cadre_movements.new_department AS cadre_movements_new_department, cadre_movements.reason AS cadre_movements_reason FROM cadre_movements WHERE cadre_movements.employee = %(param_1)s AND cadre_movements.id = ( SELECT max(cadre_movements.id) AS max_1 FROM cadre_movements WHERE cadre_movements.employee = %(param_1)s )</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan Github</a> </p><br><h3 id="itog">  Ringkasan </h3><br><p>  SQLAlchemy adalah alat pembuat kueri yang kuat yang mengurangi waktu pengembangan dengan mendukung warisan. </p><br><p>  Tetapi Anda harus menjaga garis tegas antara menggunakan ORM dan menulis pertanyaan kompleks.  Dalam beberapa kasus, ORM dapat membingungkan pengembang atau membuat kode rumit dan tidak dapat dibaca. <br>  Semoga beruntung </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470285/">https://habr.com/ru/post/id470285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470275/index.html">F # 8: Serikat yang Didiskriminasi</a></li>
<li><a href="../id470277/index.html">Bagaimana jaringan global di Federasi Rusia terorganisir dan terorganisir?</a></li>
<li><a href="../id470279/index.html">AI, Pembelajaran Mesin, Big Data, Pengenalan Bicara dan kata-kata lain yang TIDAK akan membantu Anda belajar bahasa Inggris</a></li>
<li><a href="../id470281/index.html">Wajah perangkat lunak Rusia. Atau beberapa statistik dari Unified Register program komputer dan basis data Rusia</a></li>
<li><a href="../id470283/index.html">Mesin pencari adalah seorang Wanita</a></li>
<li><a href="../id470287/index.html">Migran</a></li>
<li><a href="../id470289/index.html">Bahasa pemrograman impian saya</a></li>
<li><a href="../id470295/index.html">Enkripsi SQlite DB sederhana</a></li>
<li><a href="../id470299/index.html">Manajemen Koneksi SignalR yang Efisien</a></li>
<li><a href="../id470301/index.html">Pohon Kata Kunci: analisis grafik untuk ekstraksi semantik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>