<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👙 🕸️ 👨🏻‍🏭 Mengembangkan Kelas Deskripsi C ++ / CLI 🚙 🥓 🤙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam C ++ / CLI, yang disebut kelas deskriptor sering digunakan - kelas yang dikelola yang memiliki pointer ke kelas asli sebagai anggota. Artikel in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengembangkan Kelas Deskripsi C ++ / CLI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426411/"><hr><p>  <i>Dalam C ++ / CLI, yang disebut kelas deskriptor sering digunakan - kelas yang dikelola yang memiliki pointer ke kelas asli sebagai anggota.</i>  <i>Artikel ini membahas skema yang mudah dan ringkas untuk mengelola masa pakai objek asli yang sesuai, berdasarkan penggunaan template yang dikelola.</i>  <i>Kasus finalisasi yang kompleks dipertimbangkan.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Daftar isi </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Pola Buang Dasar di C ++ / CLI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Definisi destruktor dan finalizer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan tumpukan semantik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Template yang dikelola</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pointer pintar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh penggunaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opsi finalisasi yang lebih kompleks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunci Finalizer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan SafeHandle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi</a> <br></p><br><a name="id-introdaction"></a><br><h1>  Pendahuluan </h1><br><p> C ++ / CLI - salah satu bahasa dari .NET Framework - jarang digunakan untuk mengembangkan proyek independen besar.  Tujuan utamanya adalah untuk membuat rakitan untuk interaksi .NET dengan kode asli (tidak dikelola).  Dengan demikian, kelas yang disebut kelas deskriptor banyak digunakan, kelas yang dikelola yang memiliki pointer ke kelas asli sebagai anggota.  Biasanya, kelas deskriptor tersebut memiliki objek asli yang sesuai, yaitu, ia harus menghapusnya pada waktu yang tepat.  Sangat wajar untuk membuat kelas seperti itu dikecualikan, yaitu, mengimplementasikan <code>System::IDisposable</code> .  Implementasi antarmuka ini dalam .NET harus mengikuti pola khusus yang disebut Basic Buang [Cwalina].  Fitur luar biasa dari C ++ / CLI adalah bahwa kompiler melakukan hampir semua pekerjaan rutin penerapan templat ini, sementara di C # hampir semuanya harus dikerjakan dengan tangan. </p><br><a name="id-1"></a><br><h1>  1. Pola Buang Dasar di C ++ / CLI </h1><br><p>  Ada dua cara utama untuk mengimplementasikan template ini. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Definisi destruktor dan finalizer </h2><br><p>  Dalam hal ini, destructor dan finalizer harus didefinisikan dalam kelas yang dikelola, kompiler akan melakukan sisanya. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span>    ~X() {<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} <span class="hljs-comment"><span class="hljs-comment">//     !X() {/* ... */} //  // ... };</span></span></code> </pre> <br><p>  Secara khusus, kompiler melakukan hal berikut: </p><br><ol><li>  Untuk kelas <code>X</code> mengimplementasikan <code>System::IDisposable</code> . </li><li>  Di <code>X::Dispose()</code> menyediakan panggilan ke destruktor, panggilan ke destruktor dari kelas dasar (jika ada), dan panggilan ke <code>GC::SupressFinalize()</code> . </li><li>  Overrides <code>System::Object::Finalize()</code> , di mana ia menyediakan panggilan ke finalizer dan finalizers dari kelas dasar (jika ada). </li></ol><br><p>  Anda dapat menentukan warisan dari <code>System::IDisposable</code> secara eksplisit, tetapi Anda tidak dapat menentukan sendiri <code>X::Dispose()</code> . </p><br><a name="id-1-2"></a><br><h2>  1.2.  Menggunakan tumpukan semantik </h2><br><p>  Pola Buang Dasar juga diterapkan oleh kompiler jika kelas memiliki anggota dari tipe yang dibebaskan dan dideklarasikan menggunakan stack semantik.  Ini berarti bahwa nama tipe tanpa sampul (' <code>^</code> ') digunakan untuk deklarasi, dan inisialisasi terjadi dalam daftar inisialisasi konstruktor, dan tidak menggunakan <code>gcnew</code> .  Semantik tumpukan dijelaskan dalam [Hogenson]. </p><br><p>  Berikut ini sebuah contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> :</span></span> System::IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    R(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  // ... }; public ref class X {    R m_R; //   R^ m_R public:    X(/*  */) //         : m_R(/*  */) //   m_R = gcnew R(/*  */)    {/* ... */} // ... };</span></span></code> </pre> <br><p>  Kompiler dalam hal ini melakukan hal berikut: </p><br><ol><li>  Untuk kelas <code>X</code> mengimplementasikan <code>System::IDisposable</code> . </li><li>  Di <code>X::Dispose()</code> <code>m_R</code> panggilan ke <code>R::Dispose()</code> untuk <code>m_R</code> . </li></ol><br><p>  Finalisasi ditentukan oleh fungsionalitas kelas <code>R</code> sesuai.  Seperti dalam kasus sebelumnya, warisan dari <code>System::IDisposable</code> dapat ditentukan secara eksplisit, tetapi Anda tidak dapat mendefinisikan <code>X::Dispose()</code> sendiri.  Tentu saja, kelas mungkin memiliki anggota lain dinyatakan menggunakan semantik stack, dan panggilan <code>Dispose()</code> mereka juga disediakan untuk mereka. </p><br><a name="id-2"></a><br><h1>  2. Template yang dikelola </h1><br><p>  Dan akhirnya, fitur hebat lain dari C ++ / CLI memungkinkan untuk menyederhanakan pembuatan kelas deskriptor sebanyak mungkin.  Kita berbicara tentang template yang dikelola.  Ini bukan generik, tetapi templat nyata, seperti pada C ++ klasik, tetapi templat bukan asli, tetapi kelas yang dikelola.  Instansiasi pola tersebut mengarah pada penciptaan kelas yang dikelola yang dapat digunakan sebagai kelas dasar atau sebagai anggota kelas lain dalam suatu majelis.  Templat yang dikelola dijelaskan dalam [Hogenson]. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Pointer pintar </h2><br><p>  Template terkelola memungkinkan Anda membuat kelas seperti pointer pintar yang berisi pointer ke objek asli sebagai anggota dan menyediakan penghapusannya di destruktor dan finalizer.  Pointer pintar tersebut dapat digunakan sebagai kelas dasar atau anggota (secara alami, menggunakan stack semantik) ketika mengembangkan kelas deskriptor yang secara otomatis menjadi dibebaskan. </p><br><p>  Berikut adalah contoh dari pola tersebut.  Template pertama adalah template dasar, yang kedua dimaksudkan untuk digunakan sebagai kelas dasar, dan yang ketiga sebagai anggota kelas.  Templat ini memiliki parameter templat (asli) yang dirancang untuk menghapus objek.  Kelas penghapusan, secara default, menghapus objek dengan operator <code>delete</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  , -  , T —   template &lt;typename T&gt; struct DefDeleter {    void operator()(T* p) const { delete p; } }; //  , //      //  , T —  , D — - template &lt;typename T, typename D&gt; public ref class ImplPtrBase : System::IDisposable {    T* m_Ptr;    void Delete()    {        if (m_Ptr != nullptr)        {            D del;            del(m_Ptr);            m_Ptr = nullptr;        }    }    ~ImplPtrBase() { Delete(); }    !ImplPtrBase() { Delete(); } protected:    ImplPtrBase(T* p) : m_Ptr(p) {}    T* Ptr() { return m_Ptr; } }; //        template &lt;typename T, typename D = DefDeleter&lt;T&gt;&gt; public ref class ImplPtr : ImplPtrBase&lt;T, D&gt; { protected:    ImplPtr(T* p) : ImplPtrBase(p) {} public:    property bool IsValid    {        bool get() { return (ImplPtrBase::Ptr() != nullptr); }    } }; //        template &lt;typename T, typename D = DefDeleter&lt;T&gt;&gt; public ref class ImplPtrM sealed : ImplPtrBase&lt;T, D&gt; { public:    ImplPtrM(T* p) : ImplPtrBase(p) {}    operator bool() { return ( ImplPtrBase::Ptr() != nullptr); }    T* operator-&gt;() { return ImplPtrBase::Ptr(); }    T* Get() { return ImplPtrBase::Ptr(); } };</span></span></code> </pre> <br><a name="id-2-2"></a><br><h2>  2.2.  Contoh penggunaan </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class"> //   {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    N();    ~N();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... }; using NPtr = ImplPtr&lt;N&gt;; //   public ref class U : NPtr //  - { public:    U() : NPtr(new N()) {}    void DoSomething() { if (IsValid) Ptr()-&gt;DoSomething(); } // ... }; public ref class V //  -,   {    ImplPtrM&lt;N&gt; m_NPtr; //   public:    V() : m_NPtr(new N()) {}    void DoSomething() { if (m_NPtr) m_NPtr-&gt;DoSomething(); } // ... };</span></span></code> </pre> <br><p>  Dalam contoh-contoh ini, kelas <code>U</code> dan <code>V</code> menjadi dibebaskan tanpa upaya tambahan; <code>Dispose()</code> mereka <code>Dispose()</code> memberikan panggilan ke operator <code>delete</code> untuk sebuah pointer ke <code>N</code>  Opsi kedua, menggunakan <code>ImplPtrM&lt;&gt;</code> , memungkinkan Anda untuk mengelola beberapa kelas asli dalam satu kelas deskriptor tunggal. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Opsi finalisasi yang lebih kompleks </h2><br><p>  Finalisasi adalah aspek yang agak bermasalah dari .NET.  Dalam skenario aplikasi normal, penyelesai tidak boleh dipanggil; sumber daya harus dirilis di <code>Dispose()</code> .  Tetapi dalam skenario darurat ini bisa terjadi dan finalizers harus bekerja dengan benar. </p><br><a name="id-2-3-1"></a><br><h3>  2.3.1.  Kunci Finalizer </h3><br><p>  Jika kelas asli terletak di DLL yang memuat dan membongkar secara dinamis - menggunakan <code>LoadLibrary()/FreeLibrary()</code> , maka situasi dapat muncul ketika setelah membongkar DLL ada objek yang belum dirilis yang memiliki referensi ke instance dari kelas ini.  Dalam hal ini, setelah beberapa saat pemulung akan mencoba menyelesaikannya, dan karena DLL diturunkan, program kemungkinan besar akan macet.  (Fitur karakteristik adalah crash beberapa detik setelah aplikasi tampaknya ditutup.) Oleh karena itu, setelah membongkar DLL, penyelesai harus diblokir.  Ini dapat dicapai dengan sedikit modifikasi templat <code>ImplPtrBase</code> dasar. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DllFlag</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> s_Loaded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLoaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loaded)</span></span></span><span class="hljs-function"> </span></span>{ s_Loaded = loaded; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplPtrBase</span></span></span><span class="hljs-class"> :</span></span> DllFlag, System::IDisposable { <span class="hljs-comment"><span class="hljs-comment">// ...    !ImplPtrBase() { if (s_Loaded) Delete(); } // ... };</span></span></code> </pre> <br><p>  Setelah memuat DLL, Anda perlu memanggil <code>DllFlag::SetLoaded(true)</code> , dan sebelum membongkar <code>DllFlag::SetLoaded(false)</code> . </p><br><a name="id-2-3-2"></a><br><h3>  2.3.2.  Menggunakan <code>SafeHandle</code> </h3><br><p>  Kelas <code>SafeHandle</code> mengimplementasikan algoritma finalisasi yang agak rumit dan paling dapat diandalkan, lihat [Richter].  <code>ImplPtrBase&lt;&gt;</code> dapat dirancang ulang untuk menggunakan <code>SafeHandle</code> .  Templat yang tersisa tidak perlu diubah. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SH = System::Runtime::InteropServices::SafeHandle; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PtrType = System::IntPtr; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplPtrBase</span></span></span><span class="hljs-class"> :</span></span> SH { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ImplPtrBase(T* p) : SH(PtrType::Zero, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)    {        handle = PtrType(p);    }    <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(handle.ToPointer()); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReleaseHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override    </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsInvalid)        {            D del;            del(Ptr());            handle = PtrType::Zero;        }        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    property <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInvalid    {        <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override        </span></span>{            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (handle == PtrType::Zero);        }    } };</code> </pre> <br><a name="id-refs"></a><br><h1>  Referensi </h1><br><p>  [Lebih kaya] <br>  Richter, Jeffrey.  Pemrograman pada platform Microsoft .NET Framework 4.5 di C #.  Edisi ke-4: Per.  dari bahasa inggris  - St. Petersburg: Peter, 2016. </p><br><p>  [Cwalina] <br>  Tsvalina, Krzhishtov.  Abrams, Brad.  Infrastruktur proyek perangkat lunak: konvensi, idiom, dan templat untuk pustaka .NET yang dapat digunakan kembali.: Terjemahan.  dari bahasa inggris  - M.: LLC “Saya.  Williams, 2011. </p><br><p>  [Hogenson] <br>  Hogenson, Gordon.  C ++ / CLI: Bahasa Visual C ++ untuk lingkungan .NET: Per.  dari bahasa inggris  - M.: LLC “Saya.  Williams, 2007. </p><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426411/">https://habr.com/ru/post/id426411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426399/index.html">Kronos: tidak ada perjalanan waktu bahkan dalam sistem terdistribusi</a></li>
<li><a href="../id426401/index.html">Amazon akan mengajarkan AI-nya untuk mendefinisikan emosi manusia</a></li>
<li><a href="../id426405/index.html">Peretas dalam kerangka hukum Federasi Rusia</a></li>
<li><a href="../id426407/index.html">Bagaimana membuat perjalanan ke konferensi tidak berguna</a></li>
<li><a href="../id426409/index.html">Peretas Alexei, yang melindungi router MikroTik tanpa izin dari pemiliknya, telah menjadi terkenal</a></li>
<li><a href="../id426413/index.html">Prinsip SOLID yang Harus Diketahui Setiap Pengembang</a></li>
<li><a href="../id426415/index.html">Fintech-digest: kontrol digitalisasi oleh Bank Sentral, gaji cryptocurrency, kartu Mir dalam bentuk gelang dan gantungan kunci</a></li>
<li><a href="../id426417/index.html">Pavel 2.0: konsultan reptiloid pada JS, node.js dengan soket dan telepon</a></li>
<li><a href="../id426419/index.html">Metode overload atau jembatan terlarang di Jawa</a></li>
<li><a href="../id426421/index.html">EHCI secara manusiawi dalam bahasa Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>