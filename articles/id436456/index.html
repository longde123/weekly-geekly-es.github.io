<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏽 👩🏻‍🍳 🍞 Buat efek distribusi warna di Unity 🍔 🔝 👨🏻‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Efek ini terinspirasi oleh episode Powerpuff Girls . Saya ingin membuat efek penyebaran warna di dunia hitam dan putih, tetapi untuk menerapkannya dal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat efek distribusi warna di Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436456/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/i5/in/iai5inmdx06iz81yoz8pu_2oyui.gif"></div><br>  Efek ini terinspirasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">episode Powerpuff Girls</a> .  Saya ingin membuat efek penyebaran warna di dunia hitam dan putih, tetapi untuk <strong>menerapkannya dalam koordinat ruang dunia</strong> , untuk melihat bagaimana <strong>warna melukis objek</strong> , dan tidak hanya menyebar datar di layar, seperti dalam kartun. <br><br>  Saya menciptakan efek dalam <strong>Pipa Render Ringan yang</strong> baru <strong>dari</strong> mesin Unity, contoh bawaan dari pipa Pipa Rendering Scriptable.  Semua konsep berlaku untuk saluran pipa lain, tetapi beberapa fungsi atau matriks bawaan mungkin memiliki nama yang berbeda.  Saya juga menggunakan tumpukan pemrosesan pasca baru, tetapi dalam tutorial saya akan menghilangkan deskripsi rinci pengaturannya, karena dijelaskan dengan sangat baik dalam manual lain, misalnya, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video ini</a> . <br><a name="habracut"></a><br><hr><br><h1>  Efek post-processing dalam skala abu-abu </h1><br>  Hanya untuk referensi, seperti inilah pemandangan tanpa efek pasca pemrosesan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/283/6ad/43b2836ad62ee59df7efdd98494d0140.png"></div><br>  Untuk efek ini, saya menggunakan paket Pasca Pemrosesan Unity 2018 yang baru, yang dapat diunduh dari manajer paket.  Jika Anda tidak tahu cara menggunakannya, maka saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial ini</a> . <br><br>  Saya menulis efek saya sendiri dengan memperluas kelas PostProcessingEffectSettings dan PostProcessEffectRenderer yang ditulis dalam C #, kode sumbernya dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Sebenarnya, saya tidak melakukan sesuatu yang sangat menarik dengan efek ini pada sisi CPU (dalam kode C #) kecuali bahwa saya menambahkan sekelompok properti umum ke Inspektur, jadi saya tidak akan menjelaskan bagaimana melakukan ini dalam tutorial.  Saya harap kode saya berbicara sendiri. <br><br>  Mari kita beralih ke kode shader dan mulai dengan efek grayscale.  Dalam tutorial, kami tidak akan memodifikasi file shaderlab, struktur input, dan vertex shader, sehingga Anda dapat melihat kode sumbernya di <a href="">sini</a> .  Sebagai gantinya, kami akan mengurus shader fragmen. <br><br>  Untuk mengonversi warna menjadi skala abu-abu, kami <strong>mengurangi nilai setiap piksel menjadi nilai luminance</strong> yang menjelaskan <strong>kecerahannya</strong> .  Ini dapat dilakukan dengan mengambil produk skalar dari <strong>nilai warna tekstur kamera</strong> dan <strong>vektor tertimbang</strong> , yang menggambarkan kontribusi setiap saluran warna terhadap kecerahan warna secara keseluruhan. <br><br>  <strong>Mengapa kami menggunakan produk skalar?</strong>  Jangan lupa bahwa produk skalar dihitung sebagai berikut: <br><br> <code>dot(a, b) = a <sub>x</sub> * b <sub>x</sub> + a <sub>y</sub> * b <sub>y</sub> + a <sub>z</sub> * b <sub>z</sub></code> <br> <br>  Dalam hal ini, kami mengalikan setiap saluran dari <strong>nilai warna</strong> berdasarkan <strong>berat</strong> .  Lalu kami menambahkan produk-produk ini untuk mengurangi mereka ke nilai skalar tunggal.  Ketika warna RGB memiliki nilai yang sama di saluran R, G, dan B, warnanya berubah menjadi abu-abu. <br><br>  Seperti apa bentuk kode shader: <br><br><pre> <code class="cpp hljs">float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); float3 weight = float3(<span class="hljs-number"><span class="hljs-number">0.299</span></span>, <span class="hljs-number"><span class="hljs-number">0.587</span></span>, <span class="hljs-number"><span class="hljs-number">0.114</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> luminance = dot(fullColor.rgb, weight); float3 greyscale = luminance.xxx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(greyscale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Jika shader dasar dikonfigurasikan dengan benar, maka efek post-processing akan mewarnai seluruh layar dalam skala abu-abu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/217/fc5/596217fc5e9caed9176480f1f9eb2bb1.png"></div><br><hr><br><h1>  Rendering efek warna di ruang dunia </h1><br>  Karena ini adalah efek pasca pemrosesan, <strong>kami tidak memiliki informasi tentang geometri</strong> adegan di vertex shader.  Pada tahap pasca pemrosesan, satu-satunya informasi yang kami miliki adalah <strong>gambar yang diberikan oleh kamera</strong> dan <strong>ruang koordinat terpotong</strong> untuk pengambilan sampelnya.  Namun, kami ingin efek pewarnaan menyebar ke seluruh objek, seolah-olah itu terjadi di dunia, dan tidak hanya di layar datar. <br><br>  Untuk menggambar efek ini dalam geometri pemandangan, kita membutuhkan <strong>koordinat ruang dunia dari</strong> setiap piksel.  Untuk berpindah dari <strong>koordinat ruang koordinat terpotong</strong> ke <strong>koordinat ruang dunia</strong> , kita perlu melakukan <strong>transformasi ruang koordinat</strong> . <br><br>  Biasanya, untuk berpindah dari satu ruang koordinat ke yang lain, diperlukan sebuah matriks yang mendefinisikan transformasi dari ruang koordinat A ke ruang B. Untuk beralih dari A ke B, kita mengalikan vektor dalam ruang koordinat A dengan matriks transformasi ini.  Dalam kasus kami, kami akan melakukan transisi berikut: <strong>ruang koordinat terpotong (ruang klip)</strong> -&gt; <strong>ruang tampilan (ruang tampilan)</strong> -&gt; <strong>ruang dunia (ruang dunia)</strong> .  Artinya, kita membutuhkan matriks clip-to-view-space dan matriks view-to-world-space yang disediakan Unity. <br><br>  Namun, <strong>Koordinat kesatuan dari ruang koordinat terpotong tidak memiliki nilai z</strong> yang menentukan kedalaman piksel, atau jarak ke kamera.  Kita membutuhkan nilai ini untuk bergerak dari ruang koordinat terpotong ke ruang spesies.  Mari kita mulai dengan ini! <br><br><h2>  Mendapatkan nilai buffer kedalaman </h2><br>  Jika pipa rendering diaktifkan, maka ia menggambar tekstur di <strong>viewport</strong> yang menyimpan <strong>nilai z</strong> dalam struktur yang disebut <strong>buffer kedalaman</strong> .  Kami dapat mencicipi buffer ini untuk mendapatkan nilai <strong>z yang</strong> hilang <strong>dari</strong> ruang koordinat kami dari koordinat terpotong! <br><br>  Pertama, pastikan bahwa <strong>buffer kedalaman</strong> benar-benar diberikan dengan mengklik bagian "Tambahkan Data Tambahan" dari kamera di Inspektur dan memeriksa bahwa kotak "Membutuhkan Tekstur Kedalaman" dicentang.  Pastikan juga bahwa opsi Allow MSAA diaktifkan untuk kamera.  Saya tidak tahu mengapa efek ini perlu diperiksa, tetapi itu benar.  Jika buffer kedalaman digambar, maka di <strong>frame debugger</strong> Anda akan melihat tahap <strong>"Depth Prepass"</strong> . <br><br>  Buat sampler _CameraDepthTexture dalam <strong>file hlsl</strong> <br><br><pre> <code class="cpp hljs">TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);</code> </pre> <br>  Sekarang mari kita menulis fungsi GetWorldFromViewPosition dan untuk saat ini kita akan menggunakannya untuk memeriksa <strong>buffer kedalaman</strong> .  (Nanti kita akan mengembangkannya untuk mendapatkan posisi di dunia.) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z.xxx; }</code> </pre> <br>  Di shader fragmen, gambarkan nilai sampel tekstur kedalaman. <br><br><pre> <code class="cpp hljs">float3 depth = GetWorldFromViewPosition(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(depth, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Ini adalah hasil saya terlihat ketika hanya ada satu dataran berbukit di tempat kejadian (saya mematikan semua pohon untuk lebih menyederhanakan pengujian nilai-nilai ruang dunia).  Hasil Anda harus terlihat serupa.  Nilai hitam dan putih menggambarkan jarak dari geometri ke kamera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/6b6/5cc/b106b65cc3d1441aacd5042ee21b25a6.png"></div><br>  Berikut adalah beberapa langkah yang dapat Anda ambil jika Anda mengalami masalah: <br><br><ul><li>  Pastikan kamera telah mengaktifkan rendering dalam. </li><li>  Pastikan kamera telah mengaktifkan MSAA. </li><li>  Coba ganti bidang dekat dan jauh dari kamera. </li><li>  Pastikan bahwa objek yang Anda harapkan untuk melihat di buffer kedalaman menggunakan shader dengan pass kedalaman.  Ini memastikan bahwa objek menarik ke buffer kedalaman.  Semua shader standar di LWRP melakukan ini. </li></ul><br><h2>  Mendapatkan nilai dalam ruang dunia </h2><br>  Sekarang kita memiliki semua informasi yang diperlukan untuk <strong>ruang koordinat terpotong</strong> , mari kita beralih ke <strong>ruang spesies</strong> , dan kemudian ke <strong>ruang dunia</strong> . <br><br>  Perhatikan bahwa matriks transformasi yang diperlukan untuk operasi ini sudah ada di perpustakaan SRP.  Namun, mereka terkandung dalam pustaka C # engine Unity, jadi saya memasukkannya ke shader di fungsi Render dari skrip <a href="">ColorSpreadRenderer</a> : <br><br><pre> <code class="cpp hljs">sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_ViewToWorldMatrix"</span></span>, context.camera.cameraToWorldMatrix); sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_InverseProjectionMatrix"</span></span>, projectionMatrix.inverse);</code> </pre> <br>  Sekarang mari kita memperluas fungsi GetWorldFromViewPosition kami. <br><br>  Pertama, kita perlu mendapatkan posisi di viewport dengan <strong>mengalikan posisi dalam ruang koordinat terpotong oleh InverseProjectionMatrix</strong> .  Kita juga perlu melakukan beberapa sihir voodoo dengan posisi layar, yang terkait dengan bagaimana Unity menyimpan posisinya di ruang koordinat terpotong. <br><br>  Akhirnya, kita dapat <strong>melipatgandakan posisi di viewport dengan ViewToWorldMatrix</strong> untuk mendapatkan posisi di <strong>ruang dunia</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; //      float4 result = mul(unity_InverseProjectionMatrix, float4(2*i.screenPos-1.0, z, 1.0)); float3 viewPos = result.xyz / result.w; //      float3 worldPos = mul(unity_ViewToWorldMatrix, float4(viewPos, 1.0)); return worldPos; }</span></span></code> </pre> <br>  Mari kita lakukan pemeriksaan untuk memastikan bahwa posisi di ruang global sudah benar.  Untuk melakukan ini, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader</a> yang hanya mengembalikan posisi objek di <strong>ruang dunia</strong> ;  ini adalah perhitungan yang cukup sederhana berdasarkan shader biasa, kebenarannya dapat dipercaya.  Matikan efek pasca-pemrosesan dan ambil tangkapan layar dari shader uji ini untuk <strong>ruang dunia</strong> .  Setelah saya menerapkan shader ke permukaan bumi dalam adegan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/4f2/b78/a914f2b787501e385ef27746865429bd.png"></div><br>  (Perhatikan bahwa nilai-nilai di ruang dunia jauh lebih besar dari 1,0, jadi jangan khawatir bahwa warna-warna ini masuk akal; sebagai gantinya, pastikan saja hasilnya sama untuk jawaban "benar" dan "dihitung"). Selanjutnya, mari kita kembali ke tes objek adalah bahan biasa (dan bukan bahan uji ruang dunia), dan kemudian nyalakan efek pasca-pemrosesan lagi.  Hasil saya terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/deb/7ce/f9edeb7cea30fb33b72705a568264638.png"></div><br>  Ini benar-benar mirip dengan uji shader yang saya tulis, yaitu, perhitungan ruang dunia kemungkinan besar benar! <br><br><h2>  Menggambar lingkaran di ruang dunia </h2><br>  Sekarang kita memiliki <strong>posisi di ruang dunia</strong> , kita dapat menggambar lingkaran warna di TKP!  Kita perlu mengatur <strong>radius</strong> di mana efeknya akan menggambar warna.  Di luar, efeknya akan membuat gambar dalam skala abu-abu.  Untuk mengaturnya, Anda perlu menyesuaikan nilai untuk <strong>radius</strong> efek ( <strong>_MaxSize</strong> ) dan pusat lingkaran (_Center).  Saya mengatur nilai-nilai ini di kelas C # <a href="">ColorSpread</a> sehingga mereka terlihat di inspektur.  Mari perluas shader fragmen kami dengan memaksanya <strong>untuk memeriksa apakah piksel saat ini ada di dalam radius lingkaran</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ float3 worldPos = GetWorldFromViewPosition(i); <span class="hljs-comment"><span class="hljs-comment">// ,      .  //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= _MaxSize? 0 : 1; //   float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); //   float luminance = dot(fullColor.rgb, float3(0.2126729, 0.7151522, 0.0721750)); float3 greyscale = luminance.xxx; // ,       float3 color = (1-blend)*fullColor + blend*greyscale; return float4(color, 1.0); }</span></span></code> </pre> <br>  Akhirnya, kita bisa menggambar warna berdasarkan apakah itu berada dalam <strong>radius</strong> di <strong>ruang dunia</strong> .  Seperti inilah efek dasarnya! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/6be/fb0/9836befb050f5a354b1eb4e6faee50d5.png"></div><br><hr><br><h1>  Menambahkan Efek Khusus </h1><br>  Saya akan melihat beberapa teknik lagi yang digunakan untuk membuat warna menyebar di tanah.  Ada banyak lagi untuk efek penuh, tetapi tutorial sudah menjadi terlalu besar, jadi kita akan membatasi diri kita pada yang paling penting. <br><br><h2>  Animasi Lingkaran Pembesaran </h2><br>  Kami ingin efeknya menyebar ke seluruh dunia, yaitu, seolah tumbuh.  Untuk melakukan ini, Anda perlu mengubah <strong>jari</strong> - <strong>jari</strong> tergantung pada waktu. <br><br>  _StartTime menunjukkan waktu di mana lingkaran harus mulai tumbuh.  Dalam proyek saya, saya menggunakan skrip tambahan yang memungkinkan Anda mengklik di mana saja di layar untuk memulai pertumbuhan lingkaran;  dalam hal ini, waktu mulai sama dengan waktu mouse diklik. <br><br>  _GrowthSpeed ​​mengatur kecepatan meningkatkan lingkaran. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           float timeElapsed = _Time.y - _StartTime; float effectRadius = min(timeElapsed * _GrowthSpeed, _MaxSize); //  ,      effectRadius = clamp(effectRadius, 0, _MaxSize);</span></span></code> </pre> <br>  Kita juga perlu memperbarui pemeriksaan jarak untuk membandingkan jarak saat ini dengan meningkatnya <strong>radius efek</strong> , dan bukan dengan _MaxSize. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,         //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= effectRadius? 0 : 1; //     ...</span></span></code> </pre> <br>  Seperti apa hasilnya nanti: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3bc/761/ecb3bc76112c56270745db56f2272e7c.gif"></div><br><h2>  Menambah radius noise </h2><br>  Saya ingin efeknya lebih seperti buram cat, bukan hanya lingkaran yang tumbuh.  Untuk melakukan ini, mari kita <strong>tambahkan noise ke radius efek</strong> sehingga distribusinya tidak merata. <br><br>  Pertama, kita perlu sampel tekstur di <strong>ruang dunia</strong> .  Koordinat UV dari i.screenPos terletak di <strong>ruang layar</strong> , dan jika kami sampel berdasarkan pada mereka, bentuk efeknya akan bergerak dengan kamera;  jadi mari kita gunakan koordinat di <strong>ruang dunia</strong> .  Saya menambahkan parameter <strong>_NoiseTexScale</strong> untuk mengontrol <strong>skala sampel tekstur noise</strong> , karena koordinat di ruang dunia cukup besar. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          float2 worldUV = worldPos.xz; worldUV *= _NoiseTexScale;</span></span></code> </pre> <br>  Sekarang mari kita sampel tekstur noise dan tambahkan nilai ini ke radius efek.  Saya menggunakan skala _NoiseSize untuk kontrol lebih besar atas ukuran noise. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     float noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, worldUV).r; effectRadius -= noise * _NoiseSize;</span></span></code> </pre> <br>  Beginilah hasilnya setelah beberapa penyesuaian: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/b77/f57/51fb77f570eb4ba77fa4e8eaa8cadb20.gif"></div><br><hr><br><h1>  Kesimpulannya </h1><br>  Anda dapat mengikuti pembaruan tutorial di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> saya, dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitch</a> saya menghabiskan stream coding!  (Juga, saya mengalirkan game dari waktu ke waktu, jadi jangan heran jika Anda melihat saya duduk di piyama dan bermain Kingdom Hearts 3.) <br><br>  Ucapan Terima Kasih: <br><br><ul><li>  Semua model proyek diambil dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket Lingkungan LowPoly</a> ini dari toko Unity. </li><li>  <a href="">Efek ScreenSpaceReflections dari mesin Unity</a> benar-benar membantu saya mengetahui cara mendapatkan posisi tiga dimensi dalam viewport dari koordinat UV dua dimensi ruang layar. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436456/">https://habr.com/ru/post/id436456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436444/index.html">Penyebaran aplikasi monolitik yang tak terlihat dalam produksi di AWS. Pengalaman pribadi</a></li>
<li><a href="../id436448/index.html">Tinjau 27 "monitor IPS Acer HA270bid: untuk perbaikan diri</a></li>
<li><a href="../id436450/index.html">Terpencil dan terkendali, kebebasan dan pemerintahan. Percakapan dengan Staply</a></li>
<li><a href="../id436452/index.html">7 area pengembangan Linux pada 2019</a></li>
<li><a href="../id436454/index.html">Tanya Jawab JavaScript</a></li>
<li><a href="../id436458/index.html">Kemajuan dan sensasi dalam penelitian ai</a></li>
<li><a href="../id436460/index.html">Pilihan teknologi, arsitektur, dan desain dalam proyek perangkat lunak - tanpa uang tunai</a></li>
<li><a href="../id436464/index.html">2. Periksa Log Analisis Titik: SmartEvent</a></li>
<li><a href="../id436466/index.html">Elektron: mengembangkan aplikasi desktop menggunakan HTML, CSS dan JavaScript</a></li>
<li><a href="../id436468/index.html">Eksperimen legislatif dengan inovasi digital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>