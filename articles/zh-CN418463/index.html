<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 💇🏿 🤶🏿 在Angular中处理数据 🏅 🤝 ↩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好，我叫Sergey，我是网络开发人员。 原谅德米特里·卡洛夫斯基 （ Dmitry Karlovsky）的借用介绍，但正是他的出版物启发了我写这篇文章。 


 今天，我想谈谈在Angular应用程序中，特别是在领域模型中使用数据的问题。 


 假设我们有一个以表格形式从服务器接收的用户列表...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Angular中处理数据</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418463/"><p> 大家好，我叫Sergey，我是网络开发人员。 原谅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">德米特里·卡洛夫斯基</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dmitry Karlovsky）</a>的借用介绍，但正是他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出版物</a>启发了我写这篇文章。 </p><br><p> 今天，我想谈谈在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Angular</a>应用程序中，特别是在领域模型中使用数据的问题。 </p><a name="habracut"></a><br><p> 假设我们有一个以表格形式从服务器接收的用户列表 </p><br><pre><code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"first_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"James"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hetfield"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"Web developer"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"first_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Elvis"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"Project manager"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"first_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Steve"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Vai"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"QA engineer"</span></span> } ]</code> </pre> <br><p> 您需要将其显示为图片中的 </p><br><p><img src="https://habrastorage.org/webt/k9/ck/_2/k9ck_2oagut_woosbkn9zzar4ku.png" alt="用户名单"></p><br><p> 看起来很简单-试试吧。 当然，获得这个名单中，我们将服务<code>UserService</code>以下方式。 请注意，指向用户头像的链接不会立即出现在响应中，而是基于用户<code>id</code>形成的。 </p><br><pre> <code class="hljs pgsql">// UserService <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {UserServerResponse} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./user-server-response.interface'</span></span>; @Injectable() export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserService { constructor(private http: HttpClient) { } getUsers(): Observable&lt;UserServerResponse[]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;UserServerResponse[]&gt;(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); } getUserAvatar(userId: number): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `/users/${userId}/avatar`; } }</code> </pre> <br><p>  <code>UserListComponent</code>组件将负责显示用户列表。 </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">// UserListComponent import {Component} from '@angular/core'; import {UserService} from '../services/user.service'; @Component({ selector: 'app-user-list', template: ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let user of users | async"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"userService.getUserAvatar(user.id)"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{user.first_name}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{user.last_name}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">, </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{user.position}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ` }) export class UserListComponent { users = this.userService.getUsers(); constructor(public userService: UserService) { } }</span></span></code> </pre> <br><p> 在这里，我们已经有了一个<strong>确定的问题</strong> 。 注意服务器响应。  <code>last_name</code>字段可能为空，如果我们以这种形式保留组件，则在逗号前会收到不需要的空格。 解决方案有哪些？ </p><br><ol><li><p> 您可以稍微更正显示模板 </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>{{[user.first_name, user.last_name].filter(el =&gt; !!el).join(' ')}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>, {{user.position}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 但是通过这种方式，我们使模板超载了逻辑，即使对于这样一个简单的任务，其可读性也很差。 但是应用程序仍然必须不断增长... </p><br></li><li><p> 通过添加类型方法将代码从模板拉入组件类 </p><br><pre> <code class="hljs pgsql">getUserFullName(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: UserServerResponse): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.first_name, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.last_name].<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(el =&gt; !!el).<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>); }</code> </pre> <br><p> 更好，但完整的用户名很可能不会显示在应用程序的某个位置，因此我们将不得不重复此代码。 您可以从组件到服务采用这种方法。 这样，我们将消除可能的代码重复，但是我也不太喜欢该选项。 我不喜欢它，因为事实证明，一些更通用的实体（ <code>UserService</code> ）应该知道传递给它的较小<code>User</code>实体的结构。 在我看来，这不是她的责任等级。 </p><br></li></ol><br><p> 在我看来，该问题主要是由于我们仅将服务器响应视为数据集这一事实引起的。 尽管实际上，这是我们应用程序主题领域中的实体的列表-用户列表。 而且，如果我们正在谈论使用实体，那么值得为此使用最合适的工具-面向对象编程方法。 </p><br><p> 让我们从创建User类开始 </p><br><pre> <code class="hljs powershell">// User export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span> { readonly id; readonly firstName; readonly lastName; readonly position; constructor(userData: UserServerResponse) { this.id = userData.id; this.firstName = userData.first_name; this.lastName = userData.last_name; this.position = userData.position; } fullName(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-type"><span class="hljs-type">this.firstName</span></span>, <span class="hljs-type"><span class="hljs-type">this.lastName</span></span>].filter(el =&gt; !!el).join(<span class="hljs-string"><span class="hljs-string">' '</span></span>); } avatar(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `/users/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.id}/avatar`; } }</code> </pre> <br><p> 类构造函数是服务器响应反序列化器。 用于确定完整用户名的逻辑自然地变为<code>User</code>类的对象的方法，以及用于获得化身的逻辑。 现在，我们将重新制作<code>UserService</code>以便作为处理服务器响应的结果返回<code>User</code>类的对象 </p><br><pre> <code class="hljs pgsql">// UserService <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {map} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {UserServerResponse} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./user-server-response.interface'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./user.model'</span></span>; @Injectable() export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserService { constructor(private http: HttpClient) { } getUsers(): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>[]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;UserServerResponse[]&gt;(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>) .pipe(map(listOfUsers =&gt; listOfUsers.map(singleUser =&gt; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(singleUser)))); } }</code> </pre> <br><p> 结果，我们组件的代码变得更加清晰和易读。 可以称为业务逻辑的所有内容都封装在模型中，并且可以完全重用。 </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Component} from <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {UserService} from <span class="hljs-string"><span class="hljs-string">'../services/user.service'</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-user-list'</span></span></span><span class="hljs-meta">, template: ` &lt;div *ngFor=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"let user of users | async"</span></span></span><span class="hljs-meta">&gt; &lt;img [src]=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"user.avatar()"</span></span></span><span class="hljs-meta">&gt; &lt;p&gt;&lt;b&gt;{{user.fullName()</span></span>}}&lt;/b&gt;, {{user.position}}&lt;/p&gt; &lt;/div&gt; ` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserListComponent</span></span></span><span class="hljs-class"> </span></span>{ users = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.getUsers(); <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> userService: UserService) { } }</code> </pre> <br><p> 现在让我们扩展模型的功能。 从理论上讲（在这种情况下，我喜欢使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ActiveRecord</code></a>模式进行类比），用户模型对象不仅应负责获取有关其自身的数据，而且还应负责更改它们。 例如，我们也许可以更改用户的个人资料图片。 用这种功能扩展的用户模型将是什么样？ </p><br><pre> <code class="hljs powershell">// User export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span> { // ... constructor(userData: UserServerResponse, private http: HttpClient, private storage: StorageService, private auth: AuthService) { // ... } // ... updateAvatar(file: Blob) { const <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = new FormData(); data.append(<span class="hljs-string"><span class="hljs-string">'avatar'</span></span>, file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.http.put(`/users/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.id}/avatar`, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p> 看起来不错，但该模型<code>User</code>正在使用该服务<code>HttpClient</code>和，一般来说，它可以很好地连接，并使用各种其他服务-在这种情况下<code>StorageService</code>和<code>AuthService</code> （他们不习惯，只是添加为例）。 事实证明，如果要在其他服务或组件中使用<code>User</code>模型，则必须连接与其关联的所有服务才能创建该模型的对象。 看起来非常不便。您可以使用<code>Injector</code>服务（当然，它也必须实现，但可以保证只有一个），甚至可以创建不必实现的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://stackoverflow.com/questions/49507928/how-to-inject-">外部注射器实体</a> ，但是我看到了将<code>User</code>类对象的创建委托给<code>UserService</code>服务的更正确方法他负责获取用户列表。 </p><br><pre> <code class="hljs pgsql">// UserService <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {map} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {UserServerResponse} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./user-server-response.interface'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./user.model'</span></span>; @Injectable() export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserService { constructor(private http: HttpClient, private <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>: StorageService, private auth: AuthService) { } createUser(userData: UserServerResponse) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(userData, this.http, this.<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>, this.auth); } getUsers(): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>[]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;UserServerResponse[]&gt;(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>) .pipe(map(listOfUsers =&gt; listOfUsers.map(singleUser =&gt; this.createUser(singleUser)))); } }</code> </pre> <br><p> 因此，我们将用户创建方法移至<code>UserService</code> ，现在更适合调用工厂，并将所有实现依赖项的工作转移到Angular的肩膀上-我们只需要在构造函数中连接<code>UserService</code> 。 </p><br><p> 最后，让我们从方法名称中删除重复项，并为注入的依赖项的名称引入约定。 在我看来，该服务的最终版本应如下所示。 </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} from <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} from <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable} from <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {map} from <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {UserServerResponse} from <span class="hljs-string"><span class="hljs-string">'./user-server-response.interface'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {User} from <span class="hljs-string"><span class="hljs-string">'./user.model'</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> http: HttpClient, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> storage: StorageService, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> auth: AuthService) { } create(userData: UserServerResponse) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new User(userData, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storage, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.auth); } list(): Observable&lt;User[]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;UserServerResponse[]&gt;(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>) .pipe(map(listOfUsers =&gt; listOfUsers.map(singleUser =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.create(singleUser)))); } }</code> </pre> <br><p> 并建议以<code>User</code>名<code>UserFactory</code>实现 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {UserFactory} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./services/user.service'</span></span>; @Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, <span class="hljs-attr"><span class="hljs-attr">templateUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, <span class="hljs-attr"><span class="hljs-attr">styleUrls</span></span>: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; users = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.User.list(); <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private User: UserFactory) { } }</code> </pre> <br><p> 在这种情况下， <code>UserFactory</code>类的对象看起来像<code>User</code>类，具有用于获取用户列表的静态方法和用于创建新实体的特殊方法，并且其对象包含与特定实体关联的所有必需的业务逻辑方法。 </p><br><p> 在此，我告诉了我想要的一切。 我期待在评论中进行讨论。 </p><br><h3 id="update"> 更新资料 </h3><br><p> 我想对所有发表评论的人表示感谢。 您正确地指出，要解决显示名称的问题，值得使用<code>Pipe</code> 。 我完全同意并感到惊讶，为什么我没有做出这个决定。 尽管如此，本文的主要目标是显示一个创建域模型（在本例中为<code>User</code> ）的示例，该模型可以方便地封装与其本质相关的所有业务逻辑。 同时，我尝试解决依赖注入带来的问题。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418463/">https://habr.com/ru/post/zh-CN418463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418451/index.html">3D打印课程。 在实践中通过3Dtool进行有效的支撑和层高更改</a></li>
<li><a href="../zh-CN418453/index.html">引力观测进一步验证了广义相对论</a></li>
<li><a href="../zh-CN418455/index.html">公开网络研讨会“掌舵专家：初次经验和错误”</a></li>
<li><a href="../zh-CN418457/index.html">感谢帖子：系统管理员之日</a></li>
<li><a href="../zh-CN418459/index.html">具有两个DisplayPort接口的LVDS定标器的开发</a></li>
<li><a href="../zh-CN418465/index.html">发现了新的Spectre攻击选项，能够通过网络远程接收数据</a></li>
<li><a href="../zh-CN418467/index.html">武术发展商分类</a></li>
<li><a href="../zh-CN418469/index.html">什么时候不使用STL算法。 设置例子</a></li>
<li><a href="../zh-CN418475/index.html">Windows 10使用机器学习技术来确定是否可以升级</a></li>
<li><a href="../zh-CN418477/index.html">DEFCON会议23.我如何失去视线，或对数据破坏的进一步研究。 第一部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>