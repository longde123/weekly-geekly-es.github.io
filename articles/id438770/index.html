<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚬 🏿 👩‍👩‍👧‍👦 Menangani penekanan tombol alias pintasan dan debugging 🏼 😛 👨🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Kami akan berbicara tentang kunci pintas dalam WEBAPI + JavaScript, mempertimbangkan metode dan masalah organisasi mereka yang muncul terutama dal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menangani penekanan tombol alias pintasan dan debugging</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438770/"><p>  Hai  Kami akan berbicara tentang kunci pintas dalam WEBAPI + JavaScript, mempertimbangkan metode dan masalah organisasi mereka yang muncul terutama dalam aplikasi besar. <br><img src="https://habrastorage.org/webt/zl/e2/zq/zle2zqvpyquemp6mux7dazteywi.jpeg"></p><br><p>  Pertimbangkan cara untuk menangani kunci untuk tugas tertentu. </p><br><h2 id="zadacha">  "Tugas" </h2><br><p>  Bayangkan bahwa dalam proyek yang sudah ada Anda perlu menerapkan pemrosesan input keyboard.  Pada saat yang sama, antarmuka proyek dan pengontrolnya, tentu saja karena alasan historis, seperti adanya.  Dan ada yang berikut ini: </p><br><p> <code>ParentController</code> di mana ada dua komponen dengan status dan statusnya.  <code>Controller1</code> dan elemen yang menggunakan <code>CTRL+SHIFT+F</code> untuk mencari situs, dan <code>Controller2</code> dengan elemen DOM-nya, yang merupakan area lokal, di mana ada pencarian di dalamnya.  Namun, mereka dapat secara bersamaan berada di layar.  Berikut adalah beberapa cara untuk mengatasi masalah ini. </p><a name="habracut"></a><br><h4 id="1-keyboardeventhttpsdevelopermozillaorgrudocswebapikeyboardevent-i-ego-ruchnaya-obrabotka">  1. " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KeyboardEvent</a> dan pemrosesan manualnya" </h4><br><p>  Objek KeyboardEvent menjelaskan bagaimana pengguna berinteraksi dengan keyboard.  Setiap peristiwa dijelaskan oleh kunci;  jenis acara (keydown, penekanan tombol atau keyup) menentukan jenis tindakan yang dihasilkan. </p><br><p>  Kedengarannya bagus bukan?  Mari kita lihat lebih dekat. <br>  Pertimbangkan <code>CTRL+SHIFT+F</code> penekanan tombol ditekan, biasanya sesuai dengan panggilan pencarian global. </p><br><pre> <code class="javascript hljs">element.addEventListener(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, (event) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyName = event.key; <span class="hljs-comment"><span class="hljs-comment">//        // ..     SHIFT      if (event.ctrlKey &amp;&amp; event.shiftKey &amp;&amp; event.key.toLowerCase() === 't') { alert('CTRL+SHIFT+T pressed'); } });</span></span></code> </pre> <br><p>  Sekarang, berlaku untuk tugas kami, Anda dapat melakukan dua cara (misalnya) </p><br><p>  <strong>Lakukan intersepsi kunci di pengontrol 1 dan 2 secara terpisah</strong> </p><br><p>  Ini akan mengarah pada fakta bahwa tergantung pada urutan di DOM, Anda mungkin perlu <code>useCapture</code> untuk menjamin bahwa pemrosesan Controller2 dan kemudian Controller1 akan <code>useCapture</code> .  Jadi Anda mendapatkan logika yang terisolasi, tetapi jika aplikasi tersebut kompleks dan ada banyak pengontrol seperti itu, solusi ini tidak baik karena  beberapa dapat secara bersamaan di layar dan mereka dapat memiliki urutan pemrosesan sendiri yang ketat, yang tidak tergantung pada posisi mereka di pohon DOM.  (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggelegak dan menangkap</a> ) </p><br><p>  <strong>Pengambilan kunci di <code>CommonController</code></strong> </p><br><p>  Solusi alternatif adalah menangani klik pada pengontrol induk biasa, yang tahu persis kapan harus menunjukkan anak-anaknya, dikontrol oleh pengontrol pertama dan kedua.  Ini sambil meningkatkan pengendali anak tidak akan menyebabkan kesulitan dengan menangkap kejadian dan memutuskan pengendali untuk memproses kunci.  Namun, akan ada masalah lain - tebal <code>if</code> muncul di controller induk, yang menangani semua kasus yang mungkin.  Untuk aplikasi besar, solusi ini tidak cocok, karena  di beberapa titik, <code>Controller</code> lain mungkin muncul yang bukan anak dari <code>ParentController</code> maka Anda harus <code>ParentController</code> pawang satu tingkat ke atas ke orang tua mereka dan seterusnya ... Sampai cepat atau lambat salah satu pengendali mulai mengetahui terlalu banyak tentang elemen di dalamnya. </p><br><p><img src="https://habrastorage.org/webt/ca/di/uz/cadiuzohwqgknd297ncomfzyb9i.png"><br>  Faktanya, hanya 80% browser yang dapat bekerja dengan <code>KeboardEvent.key</code> , di lain pihak Anda harus mengoperasikan <code>KeboardEvent.keyCode</code> : <code>Number</code> dengan kode kunci.  Yang sangat menyulitkan kehidupan.  Di sini ada baiknya pergi ke deskripsi kelemahan dari pendekatan ini. </p><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Pengaturan kode sangat tidak nyaman, memerlukan kartu kode karakter dan teks yang setara, dan utilitas lain yang mengurangi jumlah kode dalam penangan. </li><li>  80% Dukungan oleh browser untuk bekerja dengan simbol tanpa menggunakan kode mereka masih tidak cukup. </li><li>  Tumpang tindih menggunakan <code>useCapture</code> satu penangan ke penangan lainnya. </li><li>  Jika ada kait dengan <code>useCapture</code> dan elemen bersarang dengan penangan yang sama <br>  debugging sulit. </li><li>  Skalabilitas buruk. </li></ul><br><p>  Namun secara alami, tidak ada dependensi dan pustaka yang tidak perlu </p><br><p>  Selanjutnya, kita akan berbicara tentang dua perpustakaan, yang salah satunya dirancang untuk memecahkan masalah mereka sendiri yang serupa. </p><br><h4 id="2-ispolzovanie-biblioteki-hotkeyshttpsgithubcomjaywcjlovehotkeys">  2. “Menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HotKeys</a> ” </h4><br><p>  Tiga ribu bintang di github, ukuran sederhana dan kurangnya ketergantungan.  Pabrikan Cina, menjanjikan solusi yang cocok untuk semua orang.  Tapi jangan terburu-buru.  Mari kita coba selesaikan masalah kita dengan bantuannya. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   hotkeys('ctrl+shift+f', function(event, handler){ alert('CTRL+SHIFT+T pressed'); });</span></span></code> </pre> <br><p>  Sintaksnya terlihat sudah jauh lebih pendek, dan chip utama untuk menyelesaikan masalah akan langsung menunjukkan komponen-komponen dari pengontrol 1 dan 2 di layar.  Setelah mencari-cari sedikit dalam kode perpustakaan, mudah untuk melihat bahwa penangan membentuk tumpukan yang diisi atau dihapus ketika mereka terdaftar alias muncul di layar (Katakanlah elemen dengan penangan yang muncul kemudian daripada yang ada akan memiliki prioritas dalam antrian untuk memproses kunci panas). </p><br><p>  Sering terjadi bahwa elemen yang seharusnya mencegat pemrosesan muncul kemudian.  Dalam hal ini, kita dapat dengan aman menyebarkan logika penanganan klik ke masing-masing pengontrol.  Dan chip lain seperti ruang lingkup akan membantu kami memisahkan satu aliran klik dari yang lain.  Tetapi dalam kasus ketika <code>    ≠   </code> - masalah yang sama muncul seperti pada eventListener asli.  Kita harus meletakkan semuanya ke dalam pengendali induk yang umum. </p><br><p>  Selain itu, sering terjadi bahwa Anda perlu memblokir perilaku default, tetapi acara tersebut tidak dianggap diproses (dengan kata lain, tidak ada pemahaman tegas apakah acara diproses atau tidak jika kami menerimanya) atau harus diproses oleh dua pengontrol secara bersamaan.  Salah satunya akan menimbulkan reaksi terhadap perilaku, dan yang lain hanya akan mempertimbangkan bahwa peristiwa itu. </p><br><p>  <strong>Total plus:</strong> </p><br><ul><li>  Lingkup memungkinkan Anda untuk memisahkan aliran. </li><li>  Sintaksnya jelas dan pendek. </li><li>  Urutan menentukan penampilan elemen, bukan posisi di DOM. </li><li>  Ukuran dan kurangnya ketergantungan. </li></ul><br><p>  <strong>Cons:</strong> </p><br><ul><li>  Hanya satu ruang lingkup yang dapat diproses sekaligus </li><li>  Debugging masih sulit karena pemanggilan fungsi dalam loop, mungkin tidak <strong>diketahui pada handler mana</strong> <del>  <strong>hilang</strong> </del>  <strong>acara ditangani</strong> </li><li>  Pernyataan bahwa acara diproses jika memiliki flag defaultPrevented dan distribusinya terganggu tidak benar. </li><li>  Fungsi global pendaftaran panggilan dan berhenti berlangganan dari acara </li></ul><br><p>  Ini cocok untuk menyelesaikan tugas-tugas biasa, tetapi akan ada masalah dengan penulisan terminal perdagangan atau panel admin besar, untuk debugging pasti. </p><br><h4 id="3-ispolzovanie-biblioteki-stack-shortcutshttpsgithubcombusinessduckstack-shortcuts">  3. “Menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan-pintasan</a> ” </h4><br><p>  Sebagai akibat dari banyak garu dan upaya untuk menggunakan solusi orang lain, saya harus membuatnya <del>  sepeda </del>  perpustakaan yang akan membantu, pertama-tama, untuk debut secara normal, melestarikan semua properti terbaik yang populer dan membawa sesuatu yang baru. </p><br><p>  <strong>Tugas apa yang diselesaikan pada saat penciptaan?</strong> </p><br><ul><li>  Prinsip operasi reaktif </li><li>  Penangan debugging sederhana </li><li>  Status pemrosesan acara yang tidak ambigu </li><li>  Lintas-platform </li><li>  Kenyamanan impor dan kurangnya fungsi global </li><li>  Tidak ada akses jendela langsung saat menghubungkan </li><li>  Tidak perlu memanggil <code>preventDefault</code> atau <code>stopPropagation</code> </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  this.shortcuts = shortcuts({ 'CMD+SHIFT+F': function (event, next) { alert('CMD+SHIFT+F pressed'); } }); //  this.shortcuts.destroy();</span></span></code> </pre> <br><p>  Berlaku untuk tugas kami, solusinya sepenuhnya bertepatan dengan perpustakaan sebelumnya.  Pemisahan yang lengkap dari logika pemrosesan tanpa terlalu banyak pengetahuan tentang satu sama lain masih belum terjadi, tetapi banyak yang menjadi lebih sederhana dan lebih mudah dimengerti.  Berkat yang berikut ini: </p><br><ul><li>  Masih tidak ada ikatan dengan DOM (dengan pengecualian satu pendengar) dan tumpukan penangan diisi tergantung pada urutan mereka terdaftar. </li><li>  <code>scope</code> segera menolak untuk menggunakan <code>scope</code> untuk isolasi.  tidak jelas tugas apa yang dipecahkannya dan tampaknya hanya mempersulit arsitektur. </li><li>  Debugging dan fungsi selanjutnya tentang hal itu mungkin lebih berharga ... </li><li>  Mutasi dalam peristiwa data yang ia bawa dalam <code>event.detail</code> </li></ul><br><p>  Penangan <strong>Debugging</strong> diatur sedemikian rupa sehingga <code>callstack</code> terbentuk dari mereka sebelum panggilan.  Ini memungkinkan Anda untuk melihat di konsol seluruh rantai acara dari penangan pertama ke yang berikutnya. </p><br><p>  <strong>next ()</strong> - Panggilan fungsi berarti bahwa acara belum diproses dan akan diteruskan ke penangan berikutnya.  Kontrak yang cukup akrab yang berlaku untuk penangan menengah atau middleware secara <code>express</code> .  Jadi, Anda akan selalu tahu jika acara diproses atau hanya bermutasi atau "diperhitungkan". </p><br><p><img src="https://habrastorage.org/webt/qi/px/ia/qipxiaoomxpysaam4fdkwfi6edu.png"></p><br><p>  Beginilah tampilan tumpukan panggilan jika Anda menetapkan breakpoint di salah satunya. </p><br><p>  <strong>Nah, tentang kontra:</strong> </p><br><ul><li>  Belum ada skrip naskah naskah. </li><li>  Tanpa cakupan - situs layar splits tidak dapat dibuat) </li><li>  Satu kombinasi selama pendaftaran (ini bukan <code>CMD+F,CMD+V,T</code> tidak akan mengerti koma) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438770/">https://habr.com/ru/post/id438770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438758/index.html">Mengapa Google mengubah antarmuka URL standar di browser</a></li>
<li><a href="../id438762/index.html">DBX: upaya untuk menyingkirkan kompilasi permintaan MySQL</a></li>
<li><a href="../id438764/index.html">Tes Chromium Keenam, Kata Penutup</a></li>
<li><a href="../id438766/index.html">DNA ekstraseluler sebagai biomarker penuaan dan berbagai patologi</a></li>
<li><a href="../id438768/index.html">Betapa saya membantu Alice untuk tidak menanggapi nama-nama lain. Magang Yandex</a></li>
<li><a href="../id438772/index.html">HX711 ADC dari 3.3V - jangan percaya dokumentasi China dan tidak hanya</a></li>
<li><a href="../id438774/index.html">Semua yang terbaik sekaligus. Artikel yang paling jelas dari blog LANIT di Habré - 2018</a></li>
<li><a href="../id438776/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, Januari 2019</a></li>
<li><a href="../id438778/index.html">@Pythonetc Januari 2019</a></li>
<li><a href="../id438782/index.html">FSB telah mengusulkan untuk merilis kartu SIM Rusia dan menggunakan kriptografi domestik untuk 5G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>