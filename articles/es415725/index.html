<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≥ üõ°Ô∏è üòû Arquitectura r√°pida y limpia como alternativa a VIPER ‚ÄºÔ∏è üí¶ üôéüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 En este momento, hay muchos art√≠culos sobre VIPER: arquitectura limpia, varias variaciones de las cuales se hicieron populares en alg√∫n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquitectura r√°pida y limpia como alternativa a VIPER</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415725/"><h3>  Introduccion </h3><br>  En este momento, hay muchos art√≠culos sobre VIPER: arquitectura limpia, varias variaciones de las cuales se hicieron populares en alg√∫n momento para proyectos de iOS.  Si no est√° familiarizado con Viper, puede leerlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Me gustar√≠a hablar sobre la alternativa VIPER: Clean Swift.  Clean Swift a primera vista parece VIPER, sin embargo, las diferencias se hacen visibles despu√©s de estudiar el principio de interacci√≥n entre m√≥dulos.  En VIPER, la interacci√≥n se basa en Presenter, transfiere las solicitudes de los usuarios al Interactor para su procesamiento y formatea los datos recibidos para mostrarlos en el Controlador de vista: <br><br><img src="https://habrastorage.org/webt/au/kr/v_/aukrv_2zvl2ikjare8odlwup--k.png" alt="imagen"><br><a name="habracut"></a><br>  En Clean Swift, los m√≥dulos principales, como en VIPER, son View Controller, Interactor, Presenter. <br><br><img src="https://habrastorage.org/webt/ll/ud/y0/lludy0ydjgy6domer_ayleohrp4.png" alt="imagen"><br><br>  La interacci√≥n entre ellos ocurre en ciclos.  La transferencia de datos se basa en protocolos (de nuevo, de manera similar a VIPER), lo que permite futuros cambios en uno de los componentes del sistema para simplemente reemplazarlo por otro.  El proceso de interacci√≥n en general tiene este aspecto: el usuario hace clic en el bot√≥n, View Controller crea un objeto con una descripci√≥n y lo env√≠a a Interactor.  Interactor, a su vez, implementa un escenario espec√≠fico de acuerdo con la l√≥gica empresarial, crea un objeto de resultado y lo pasa a Presenter.  El presentador forma un objeto con datos formateados para mostrar al usuario y lo env√≠a al controlador de vista.  Echemos un vistazo m√°s de cerca a cada m√≥dulo Clean Swift con m√°s detalle. <br><br><h3>  Ver (Controlador de vista) </h3><br>  View Controller, como en VIPER, realiza todas las configuraciones de VIew, ya sea de color, UILabel o configuraciones de fuente de dise√±o.  Por lo tanto, cada UIViewController en esta arquitectura implementa un protocolo de entrada para mostrar datos o responder a las acciones del usuario. <br><br><h3>  Interactractor </h3><br>  Interactor contiene toda la l√≥gica de negocios.  Acepta acciones del usuario desde el controlador, con par√°metros (por ejemplo, texto modificado del campo de entrada, presionando un bot√≥n) definidos en el protocolo de entrada.  Despu√©s de resolver la l√≥gica, Interactor, si es necesario, debe transferir los datos para su preparaci√≥n al Presentador antes de mostrarlos en el ViewController.  Sin embargo, Interactor solo acepta solicitudes de View como entrada, a diferencia de VIPER, donde estas solicitudes pasan por Presenter. <br><br><h3>  Presentador </h3><br>  El presentador procesa los datos para mostrarlos al usuario.  El resultado en este caso es el protocolo de entrada de ViewController, aqu√≠ puede, por ejemplo, cambiar el formato de texto, traducir el valor de color de enum a rgb, etc. <br><br><h3>  Trabajador </h3><br>  Para no complicar innecesariamente a Interactor y no duplicar los detalles de la l√≥gica empresarial, puede usar un elemento Worker adicional.  En m√≥dulos simples, no siempre es necesario, pero en m√≥dulos suficientemente cargados le permite eliminar algunas tareas de Interactor.  Por ejemplo, la l√≥gica de interacci√≥n con la base de datos se puede hacer en el trabajador, especialmente si las mismas consultas de la base de datos se pueden usar en diferentes m√≥dulos. <br><br><h3>  Enrutador </h3><br>  El enrutador es responsable de transferir datos a otros m√≥dulos y transiciones entre ellos.  Tiene un enlace al controlador, porque en iOS, desafortunadamente, los controladores, entre otras cosas, son hist√≥ricamente responsables de las transiciones.  El uso de segue puede simplificar la inicializaci√≥n de las transiciones al llamar a los m√©todos de enrutador desde Prepararse para segue, porque el enrutador sabe c√≥mo transferir datos, y lo har√° sin ning√∫n c√≥digo de bucle adicional de Interactor / Presenter.  Los datos se transfieren utilizando los protocolos de almacenamiento de datos de cada m√≥dulo implementado en Interactor.  Estos protocolos tambi√©n limitan la capacidad de acceder a los datos del m√≥dulo interno desde el enrutador. <br><br><h3>  Modelos </h3><br>  Modelos es una descripci√≥n de las estructuras de datos para transferir datos entre m√≥dulos.  Cada implementaci√≥n de la funci√≥n de l√≥gica de negocios tiene su propia descripci√≥n de los modelos. <br><br><ul><li>  Solicitud: para enviar una solicitud desde el controlador al interactor. </li><li>  Respuesta: la respuesta del interactor para transmitir al presentador con los datos. </li><li>  ViewModel: para la transferencia de datos en un formulario listo para mostrar en el controlador. </li></ul><br><h3>  Ejemplo de implementaci√≥n </h3><br>  Echemos un vistazo m√°s de cerca a esta arquitectura usando un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> simple.  Ser√°n atendidos por la aplicaci√≥n ContactsBook de forma simplificada, pero suficiente para comprender la esencia de la forma de la arquitectura.  La aplicaci√≥n incluye una lista de contactos, as√≠ como agregar y editar contactos. <br><br>  Un ejemplo de un protocolo de entrada: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListDisplayLogic</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: ContactList.ShowContacts.ViewModel)</span></span></span></span> }</code> </pre> <br>  Cada controlador contiene una referencia a un objeto que implementa el protocolo Interactor de entrada <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListBusinessLogic?</span></span></code> </pre> <br>  as√≠ como al objeto Router, que debe implementar la l√≥gica de transferencia de datos y conmutaci√≥n de m√≥dulos: <br><br><pre> <code class="hljs objectivec">var router: (<span class="hljs-built_in"><span class="hljs-built_in">NSObjectProtocol</span></span> &amp; ContactListRoutingLogic &amp; ContactListDataPassing)?</code> </pre> <br>  Puede implementar la configuraci√≥n del m√≥dulo en un m√©todo privado separado: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">ContactListInteractor</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">ContactListPresenter</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">ContactListRouter</span></span>() viewController.interactor = interactor viewController.router = router interactor.presenter = presenter presenter.viewController = viewController router.viewController = viewController router.dataStore = interactor }</code> </pre> <br>  o cree un Singleton Configurator para eliminar este c√≥digo del controlador (para aquellos que creen que el controlador no debe estar involucrado en la configuraci√≥n) y no se tienten con el acceso a partes del m√≥dulo en el controlador.  No hay clase de configurador en la vista del t√≠o Bob y en VIPER cl√°sico.  El uso del configurador para el m√≥dulo de agregar contacto se ve as√≠: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromNib() <span class="hljs-type"><span class="hljs-type">AddContactConfigurator</span></span>.sharedInstance.configure(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  El c√≥digo del configurador contiene el √∫nico m√©todo de configuraci√≥n que es absolutamente id√©ntico al m√©todo de configuraci√≥n en el controlador: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddContactConfigurator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedInstance = <span class="hljs-type"><span class="hljs-type">AddContactConfigurator</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control: AddContactViewController)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = control <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">AddContactInteractor</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">AddContactPresenter</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">AddContactRouter</span></span>() viewController.interactor = interactor viewController.router = router interactor.presenter = presenter presenter.viewController = viewController router.viewController = viewController router.dataStore = interactor } }</code> </pre> <br>  Otro punto muy importante en la implementaci√≥n del controlador es el c√≥digo en el m√©todo de preparaci√≥n est√°ndar para segue: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scene = segue.identifier { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> selector = <span class="hljs-type"><span class="hljs-type">NSSelectorFromString</span></span>(<span class="hljs-string"><span class="hljs-string">"routeTo\(scene)WithSegue:"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = router, router.responds(to: selector) { router.perform(selector, with: segue) } } }</code> </pre> <br>  Un lector atento probablemente not√≥ que Router tambi√©n es necesario para implementar NSObjectProtocol.  Esto se hace para que podamos usar los m√©todos est√°ndar de este protocolo para el enrutamiento cuando se usan segues.  Para admitir esta simple redirecci√≥n, la denominaci√≥n del identificador de segue debe coincidir con las terminaciones de los nombres de los m√©todos de enrutador.  Por ejemplo, para ir a ver un contacto, hay un segue, que est√° vinculado a la elecci√≥n de una celda con un contacto.  Su identificador es "ViewContact", aqu√≠ est√° el m√©todo correspondiente en el enrutador: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeToViewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(segue: UIStoryboardSegue?)</span></span></span></span></code> </pre> <br>  La solicitud para mostrar datos a Interactor tambi√©n parece muy simple: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> func fetchContacts() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>() interactor?.showContacts(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) }</code> </pre> <br>  Pasemos a Interactor.  Interactor implementa el protocolo ContactListDataStore, que se encarga de almacenar / acceder a los datos.  En nuestro caso, esto es solo una serie de contactos, limitados solo por el m√©todo getter, para mostrar al enrutador la inadmisibilidad de cambiarlo desde otros m√≥dulos.  Un protocolo que implementa la l√≥gica de negocios para nuestra lista es el siguiente: <br><br><pre> <code class="hljs vbscript">func showContacts(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = worker.getContacts() self.contacts = contacts <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">response</span></span> = ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Response</span></span>(contacts: contacts) presenter?.presentContacts(<span class="hljs-built_in"><span class="hljs-built_in">response</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">response</span></span>) }</code> </pre> <br>  Recibe datos de contacto de ContactListWorker.  En este caso, el trabajador es responsable de c√≥mo se descargan los datos.  Puede recurrir a servicios de terceros que deciden, por ejemplo, tomar datos del cach√© o descargarlos de la red.  Despu√©s de recibir los datos, Interactor env√≠a una Respuesta al Presentador para prepararse para la visualizaci√≥n, para este Interactor contiene un enlace al Presentador: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListPresentationLogic?</span></span></code> </pre> <br>  El presentador implementa solo un protocolo: ContactListPresentationLogic, en nuestro caso, simplemente cambia a la fuerza el caso del nombre y apellido del contacto, forma el modelo de presentaci√≥n DisplayedContact del modelo de datos y lo pasa al controlador para su visualizaci√≥n: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: ContactList.ShowContacts.Response)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapped = response.contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">ContactList</span></span> .<span class="hljs-type"><span class="hljs-type">ShowContacts</span></span> .<span class="hljs-type"><span class="hljs-type">ViewModel</span></span> .<span class="hljs-type"><span class="hljs-type">DisplayedContact</span></span>(firstName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.firstName.uppercaseFirst, lastName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.lastName.uppercaseFirst) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel = <span class="hljs-type"><span class="hljs-type">ContactList</span></span>.<span class="hljs-type"><span class="hljs-type">ShowContacts</span></span>.<span class="hljs-type"><span class="hljs-type">ViewModel</span></span>(displayedContacts: mapped) viewController?.displayContacts(viewModel: viewModel) }</code> </pre> <br>  Despu√©s de eso, el ciclo finaliza y el controlador muestra los datos, implementando el m√©todo de protocolo ContactListDisplayLogic: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: ContactList.ShowContacts.ViewModel)</span></span></span></span> { displayedContacts = viewModel.displayedContacts tableView.reloadData() }</code> </pre> <br>  As√≠ es como se ven los modelos para mostrar contactos: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShowContacts</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contacts: [<span class="hljs-type"><span class="hljs-type">Contact</span></span>] } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisplayedContact</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> displayedContacts: [<span class="hljs-type"><span class="hljs-type">DisplayedContact</span></span>] } }</code> </pre> <br>  En este caso, la solicitud no contiene datos, ya que esta es solo una lista general de contactos, sin embargo, si, por ejemplo, la pantalla de la lista contiene un filtro, el tipo de filtro podr√≠a incluirse en esta solicitud.  El modelo de respuesta Intrecator contiene la lista de contactos deseada, ViewModel tambi√©n contiene una serie de datos listos para mostrar: DisplayedContact. <br><br><h3>  Por qu√© Clean Swift </h3><br>  Considere los pros y los contras de esta arquitectura.  Primero, Clean Swift tiene plantillas de c√≥digo que facilitan la creaci√≥n de un m√≥dulo.  Estas plantillas se pueden escribir para muchas arquitecturas, pero cuando est√°n listas para usar, al menos le ahorran varias horas de tiempo. <br><br>  En segundo lugar, esta arquitectura, como VIPER, est√° bien probada, hay ejemplos de pruebas disponibles en el proyecto.  Dado que el m√≥dulo con el que se produce la interacci√≥n es f√°cil de reemplazar con un c√≥digo auxiliar, determinar la funcionalidad de cada m√≥dulo utilizando protocolos le permite implementar esto sin dolor de cabeza.  Si simult√°neamente creamos l√≥gica de negocios y las pruebas correspondientes (pruebas de Interactor, Interactor), esto encaja bien con el principio de TDD.  Debido al hecho de que el protocolo define la salida y la entrada de cada caso de l√≥gica, es suficiente escribir primero una prueba que determine su comportamiento y luego implementar directamente la l√≥gica del m√©todo. <br><br>  En tercer lugar, Clean Swift (a diferencia de VIPER) implementa un flujo unidireccional de procesamiento de datos y toma de decisiones.  Siempre se ejecuta un ciclo: Ver - Interactor - Presentador - Ver, que tambi√©n simplifica la refactorizaci√≥n, ya que a menudo es necesario cambiar menos entidades.  Debido a esto, los proyectos con l√≥gica que a menudo cambia o se complementa son m√°s convenientes para refactorizar utilizando la metodolog√≠a Clean Swift.  Usando Clean Swift, separas las entidades de dos maneras: <br><br><ol><li>  A√≠sle los componentes declarando los protocolos de entrada y salida </li><li>  A√≠sle las caracter√≠sticas mediante el uso de estructuras y la encapsulaci√≥n de datos en solicitudes / respuestas / modelos de IU independientes.  Cada caracter√≠stica tiene su propia l√≥gica y se controla dentro del marco de un proceso, sin cruzarse en un m√≥dulo con otras caracter√≠sticas. </li></ol><br>  Clean Swift no debe usarse en proyectos peque√±os sin una perspectiva a largo plazo, en proyectos prototipo.  Por ejemplo, es demasiado costoso implementar una aplicaci√≥n para el horario de una conferencia de desarrolladores utilizando esta arquitectura.  Los proyectos a largo plazo, proyectos con mucha l√≥gica de negocios, por el contrario, encajan bien en el marco de esta arquitectura.  Es muy conveniente usar Clean Swift cuando el proyecto se implementa para dos plataformas: Mac OS e iOS, o se planea portarlo en el futuro. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415725/">https://habr.com/ru/post/es415725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415713/index.html">Programaci√≥n PHP Orientada a Aspectos</a></li>
<li><a href="../es415715/index.html">La historia del colapso y rescate milagroso del molde en KOMPAS-3D</a></li>
<li><a href="../es415717/index.html">¬øPuedo hacer una pistola de luz para la pantalla LCD? Kickstarter ya est√° recaudando dinero</a></li>
<li><a href="../es415721/index.html">¬øPor qu√© el procesador insignia necesita memoria superior? Prueba del kit HyperX Fury DDR4-3466</a></li>
<li><a href="../es415723/index.html">Desde dise√±adores hasta el departamento de control de calidad, o hay vida despu√©s de la f√°brica</a></li>
<li><a href="../es415727/index.html">Inmerso en la din√°mica de la base de clientes: an√°lisis de cohortes y an√°lisis de flujo.</a></li>
<li><a href="../es415729/index.html">Algunas estad√≠sticas: los desarrolladores de Ubuntu publicaron por primera vez la telemetr√≠a de escritorio</a></li>
<li><a href="../es415731/index.html">Revise Xiaomi Redmi Note 5 - phablet de presupuesto medio con un reclamo de originalidad</a></li>
<li><a href="../es415733/index.html">Informaci√≥n: Roskomsvoboda y su historia</a></li>
<li><a href="../es415735/index.html">Hardware que codifica una transmisi√≥n de video en una c√°mara Logitech C920 y la env√≠a a ROS a trav√©s de wifi con un retraso de menos de 0.2 segundos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>