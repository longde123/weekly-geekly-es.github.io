<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏾 💥 🕴🏼 Introducción a las clases de datos 🐄 💸 😼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una de las nuevas características introducidas en Python 3.7 son las clases de datos. Están diseñados para automatizar la generación de código para la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducción a las clases de datos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415829/"><p>  Una de las nuevas características introducidas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python 3.7</a> son las clases de datos.  Están diseñados para automatizar la generación de código para las clases que se utilizan para almacenar datos.  A pesar de que utilizan otros mecanismos de trabajo, se pueden comparar con "tuplas con nombre mutable con valores predeterminados". </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEP 557 - Clases de datos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentación oficial</a> </li></ul><br><h2 id="vvedenie">  Introduccion </h2><br><blockquote>  Todos los ejemplos anteriores requieren Python 3.7 o superior para su funcionamiento. </blockquote><p>  La mayoría de los desarrolladores de Python tienen que escribir estas clases regularmente: </p><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularBook</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, title, author)</span></span></span><span class="hljs-function">:</span></span> self.title = title self.author = author</code> </pre> <br><p>  Ya en este ejemplo, la redundancia es visible.  El título y los identificadores del autor se usan varias veces.  La clase real también contendrá los métodos anulados <code>__eq__</code> y <code>__repr__</code> . </p><br><p>  El módulo de <code>dataclasses</code> contiene el decorador <code>@dataclass</code> .  Al usarlo, un código similar se vería así: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class">:</span></span> title: str author: str</code> </pre> <a name="habracut"></a><br><p>  Es importante tener en cuenta que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> <strong>requieren</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anotaciones de tipo</a> .  Todos los campos que no tengan marcas de tipo serán ignorados.  Por supuesto, si no desea utilizar un tipo específico, puede especificar <code>Any</code> desde el módulo de <code>typing</code> . </p><br><p>  ¿Qué obtienes como resultado?  Obtiene automáticamente una clase, con los métodos implementados <code>__init__</code> , <code>__repr__</code> , <code>__str__</code> y <code>__eq__</code> .  Además, será una clase regular y puede heredarla o agregar métodos arbitrarios. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>book = Book(title=<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, author=<span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book Book(title=<span class="hljs-string"><span class="hljs-string">'Fahrenheit 451'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>) &gt;&gt;&gt; book.author <span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span> &gt;&gt;&gt; other = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book == other <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><h2 id="alternativy">  Alternativas </h2><br><h3 id="kortezh-ili-slovar">  Tupla o diccionario </h3><br><p>  Por supuesto, si la estructura es bastante simple, puede guardar los datos en un diccionario o tupla: </p><br><pre> <code class="python hljs">book = (<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) other = {<span class="hljs-string"><span class="hljs-string">'title'</span></span>: <span class="hljs-string"><span class="hljs-string">'Fahrenheit 451'</span></span>, <span class="hljs-string"><span class="hljs-string">'author'</span></span>: <span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>}</code> </pre> <br><p>  Sin embargo, este enfoque tiene desventajas: </p><br><ul><li>  Debe recordarse que la variable contiene datos relacionados con esta estructura. </li><li>  En el caso de un diccionario, debe realizar un seguimiento de los nombres de las teclas.  Tal inicialización del diccionario <code>{'name': 'Fahrenheit 451', 'author': 'Bradbury'}</code> también será formalmente correcta. </li><li>  En el caso de una tupla, debe realizar un seguimiento del orden de los valores, ya que no tienen nombres. </li></ul><br><p>  Hay una mejor opción: </p><br><h3 id="namedtuple">  Namedtuple </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple NamedTupleBook = namedtuple(<span class="hljs-string"><span class="hljs-string">"NamedTupleBook"</span></span>, [<span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>])</code> </pre> <br><p>  Si usamos la clase creada de esta manera, obtenemos prácticamente lo mismo que usar la clase de datos. </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; book = NamedTupleBook("Fahrenheit 451", "Bradbury") &gt;&gt;&gt; book.author 'Bradbury' &gt;&gt;&gt; book NamedTupleBook(title='Fahrenheit 451', author='Bradbury') &gt;&gt;&gt; book == NamedTupleBook("Fahrenheit 451", "Bradbury")) True</code> </pre> <br><p>  Pero a pesar de la similitud general, las tuplas con nombre tienen sus limitaciones.  Vienen del hecho de que las tuplas con nombre siguen siendo tuplas. </p><br><p>  Primero, aún puede comparar instancias de diferentes clases. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Car = namedtuple(<span class="hljs-string"><span class="hljs-string">"Car"</span></span>, [<span class="hljs-string"><span class="hljs-string">"model"</span></span>, <span class="hljs-string"><span class="hljs-string">"owner"</span></span>]) &gt;&gt;&gt; book = NamedTupleBook(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>)) &gt;&gt;&gt; book == Car(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>  En segundo lugar, las tuplas con nombre son inmutables.  En algunas situaciones, esto es útil, pero me gustaría tener más flexibilidad. <br>  Finalmente, puede operar tanto en una tupla con nombre como en una normal.  Por ejemplo, repita. </p><br><h3 id="drugie-proekty">  Otros proyectos </h3><br><p>  Si no se limita a la biblioteca estándar, puede encontrar otras soluciones a este problema.  En particular, el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">atrae</a> .  Puede hacer incluso más que la clase de datos y funciona en versiones anteriores de python como 2.7 y 3.4.  Sin embargo, el hecho de que no sea parte de la biblioteca estándar puede ser inconveniente </p><br><h2 id="sozdanie">  Creación </h2><br><p>  Puede usar el decorador <code>@dataclass</code> para crear una clase de datos.  En este caso, todos los campos de la clase definidos con anotaciones de tipo se utilizarán en los métodos correspondientes de la clase resultante. </p><br><p>  Como alternativa, existe la función <code>make_dataclass</code> , que funciona de manera similar a la creación de tuplas con nombre. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> make_dataclass Book = make_dataclass(<span class="hljs-string"><span class="hljs-string">"Book"</span></span>, [<span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>]) book = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>)</code> </pre> <br><h2 id="znacheniya-po-umolchaniyu">  Valores por defecto </h2><br><p>  Una característica útil es la facilidad de agregar valores predeterminados a los campos.  Todavía no hay necesidad de redefinir el método <code>__init__</code> , solo especifique los valores directamente en la clase. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str = "Unknown" author: str = "Unknown author"</span></span></code> </pre> <br><p>  Se tendrán en cuenta en el método generado <code>__init__</code> </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Book() Book(title=<span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Unknown author'</span></span>) &gt;&gt;&gt; Book(<span class="hljs-string"><span class="hljs-string">"Farenheit 451"</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Farenheit 451'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Unknown author'</span></span>)</code> </pre> <br><p>  Pero al igual que con las clases y métodos regulares, debe tener cuidado al usar valores predeterminados mutables.  Si, por ejemplo, necesita usar la lista como valor predeterminado, hay otra forma, pero más sobre eso a continuación. </p><br><p>  Además, es importante controlar el orden en que se determinan los campos con valores predeterminados, ya que coincide exactamente con su orden en el método <code>__init__</code> </p><br><h2 id="immutabelnye-klassy-dannyh">  Clases de datos inmutables </h2><br><p>  Las instancias de tuplas con nombre son inmutables.  En muchas situaciones, esta es una buena idea.  Para las clases de datos, también puede hacer esto.  Simplemente especifique el parámetro <code>frozen=True</code> al crear la clase, y si intenta cambiar sus campos, se <code>FrozenInstanceError</code> una excepción <code>FrozenInstanceError</code> </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass(frozen=True) class Book: title: str author: str</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>book = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book.title = <span class="hljs-string"><span class="hljs-string">"1984"</span></span> dataclasses.FrozenInstanceError: cannot assign to field <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br><h2 id="nastroyka-klassa-dannyh">  Configuración de clase de datos </h2><br><p>  Además del parámetro <code>frozen</code> , el decorador <code>@dataclass</code> tiene otros parámetros: </p><br><ul><li>  <code>init</code> : si es <code>True</code> (predeterminado), se genera el método <code>__init__</code> .  Si la clase ya tiene un método <code>__init__</code> definido, el parámetro se ignora. </li><li>  <code>repr</code> : habilita (por defecto) la creación del método <code>__repr__</code> .  La cadena generada contiene el nombre de la clase y el nombre y la representación de todos los campos definidos en la clase.  En este caso, se pueden excluir campos individuales (ver más abajo) </li><li>  <code>eq</code> : habilita (por defecto) la creación del método <code>__eq__</code> .  Los objetos se comparan de la misma manera que si fueran tuplas que contienen los valores de campo correspondientes.  Además, la coincidencia de tipos está marcada. </li><li>  <code>order</code> habilita (el valor predeterminado es desactivado) la creación de los <code>__lt__</code> , <code>__le__</code> , <code>__gt__</code> y <code>__ge__</code> .  Los objetos se comparan de la misma manera que las tuplas correspondientes de valores de campo.  Al mismo tiempo, también se verifica el tipo de objetos.  Si <code>order</code> especifica el <code>order</code> , pero <code>eq</code> no, se <code>ValueError</code> una excepción <code>ValueError</code> .  Además, la clase no debe contener métodos de comparación ya definidos. </li><li>  <code>unsafe_hash</code> afecta la generación del método <code>__hash__</code> .  El comportamiento también depende de los valores de los parámetros <code>eq</code> y <code>frozen</code> </li></ul><br><h2 id="nastroyka-otdelnyh-poley">  Personaliza campos individuales </h2><br><p>  En la mayoría de las situaciones estándar, esto no es obligatorio, pero es posible personalizar el comportamiento de la clase de datos hasta campos individuales utilizando la función de campo. </p><br><h3 id="izmenyaemye-znacheniya-po-umolchaniyu">  Valores predeterminados modificables </h3><br><p>  Una situación típica mencionada anteriormente es el uso de listas u otros valores predeterminados mutables.  Es posible que desee una clase de "estantería" que contenga una lista de libros.  Si ejecuta el siguiente código: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Bookshelf: books: List[Book] = []</span></span></code> </pre> <br><p>  el intérprete informará un error: </p><br><pre> <code class="plaintext hljs">ValueError: mutable default &lt;class 'list'&gt; for field books is not allowed: use default_factory</code> </pre> <br><p>  Sin embargo, para otros valores mutables, esta advertencia no funcionará y conducirá a un comportamiento incorrecto del programa. </p><br><p>  Para evitar problemas, se sugiere utilizar el parámetro <code>default_factory</code> de la función de <code>field</code> .  Su valor puede ser cualquier objeto llamado o función sin parámetros. <br>  La versión correcta de la clase se ve así: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Bookshelf: books: List[Book] = field(default_factory=list)</span></span></code> </pre> <br><h3 id="drugie-parametry">  Otras opciones </h3><br><p>  Además de la <code>default_factory</code> especificada, la función de campo tiene los siguientes parámetros: </p><br><ul><li>  <code>default</code> : el valor <code>default</code> .  Este parámetro es obligatorio porque la llamada al <code>field</code> reemplaza el valor predeterminado del campo. </li><li>  <code>init</code> : habilita (por defecto) el uso de un campo en el método <code>__init__</code> </li><li>  <code>repr</code> : habilita (por defecto) el uso de un campo en el método <code>__repr__</code> </li><li>  <code>compare</code> incluye (por defecto) el uso del campo en los métodos de comparación ( <code>__eq__</code> , <code>__le__</code> y otros) </li><li>  <code>hash</code> : puede ser un valor booleano o <code>None</code> .  Si es <code>True</code> , el campo se usa para calcular el hash.  Si <code>None</code> especifica <code>None</code> (por defecto), se utiliza el valor del parámetro de <code>compare</code> . <br>  Una de las razones para especificar <code>hash=False</code> para una <code>compare=True</code> determinada <code>compare=True</code> puede ser la dificultad de calcular el hash de campo mientras sea necesario para la comparación. </li><li>  <code>metadata</code> : diccionario personalizado o <code>None</code> .  El valor está envuelto en <code>MappingProxyType</code> para que se vuelva inmutable.  Este parámetro no es utilizado por las clases de datos en sí y está destinado a extensiones de terceros. </li></ul><br><h2 id="obrabotka-posle-inicializacii">  Procesamiento después de la inicialización </h2><br><p>  El método <code>__init__</code> generado <code>__init__</code> llama al método <code>__post_init__</code> , si está definido en la clase.  Como regla, se llama en la forma <code>self.__post_init__()</code> , sin embargo, si las variables de tipo <code>InitVar</code> definen en la clase, se pasarán como parámetros del método. </p><br><p>  Si no se ha generado el método <code>__post_init__</code> , no se llamará a <code>__post_init__</code> . </p><br><p>  Por ejemplo, agregue una descripción de libro generada </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str author: str desc: str = None def __post_init__(self): self.desc = self.desc or "`%s` by %s" % (self.title, self.author)</span></span></code> </pre> <br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Book("Fareneheit 481", "Bradbury") Book(title='Fareneheit 481', author='Bradbury', desc='`Fareneheit 481` by Bradbury')</code> </pre> <br><h3 id="parametry-tolko-dlya-inicializacii">  Parámetros solo para inicialización </h3><br><p>  Una de las posibilidades asociadas con el método <code>__post_init__</code> son los parámetros utilizados solo para la inicialización.  Si, al declarar un campo, especifica <code>InitVar</code> como su tipo, su valor se pasará como un parámetro del método <code>__post_init__</code> .  De ninguna otra manera se usan tales campos en la clase de datos. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str author: str gen_desc: InitVar[bool] = True desc: str = None def __post_init__(self, gen_desc: str): if gen_desc and self.desc is None: self.desc = "`%s` by %s" % (self.title, self.author)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Book(<span class="hljs-string"><span class="hljs-string">"Fareneheit 481"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Fareneheit 481'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>, desc=<span class="hljs-string"><span class="hljs-string">'`Fareneheit 481` by Bradbury'</span></span>) &gt;&gt;&gt; Book(<span class="hljs-string"><span class="hljs-string">"Fareneheit 481"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>, gen_desc=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Fareneheit 481'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>, desc=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><h2 id="nasledovanie">  Herencia </h2><br><p>  Cuando usa el decorador <code>@dataclass</code> , <code>@dataclass</code> todas las clases principales comenzando con el objeto y para cada clase de datos encontrada guarda los campos en un diccionario ordenado, luego agrega las propiedades de la clase que se está procesando.  Todos los métodos generados utilizan campos del diccionario ordenado resultante. </p><br><p>  Como resultado, si la clase principal define valores predeterminados, deberá definir los campos con valores predeterminados. </p><br><p>  Como el diccionario ordenado almacena los valores en orden de inserción, para las siguientes clases </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class BaseBook: title: Any = None author: str = None @dataclass class Book(BaseBook): desc: str = None title: str = "Unknown"</span></span></code> </pre> <br><p>  Se <code>__init__</code> un método <code>__init__</code> con esta firma: </p><br><pre> <code class="plaintext hljs">def __init__(self, title: str="Unknown", author: str=None, desc: str=None)</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415829/">https://habr.com/ru/post/es415829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415815/index.html">A la vanguardia de la ciencia: un análisis de los artículos de arxiv.org</a></li>
<li><a href="../es415817/index.html">Overclockeamos la copia de seguridad. Conferencia de Yandex</a></li>
<li><a href="../es415819/index.html">Informe del Club de Roma 2018, Capítulo 3.16: Gobierno global</a></li>
<li><a href="../es415821/index.html">La forma de organizar una casa "inteligente" con el control eléctrico más amplio posible</a></li>
<li><a href="../es415823/index.html">FindFace cierra por simples mortales</a></li>
<li><a href="../es415831/index.html">Los nuevos diez mandamientos de Roskosmos</a></li>
<li><a href="../es415833/index.html">Ventajas y desventajas de Xamarin</a></li>
<li><a href="../es415835/index.html">Escribimos GUI a 1C RAC, o nuevamente sobre Tcl / Tk</a></li>
<li><a href="../es415837/index.html">Una pequeña descripción de linternas solares</a></li>
<li><a href="../es415839/index.html">El resumen de materiales interesantes para el desarrollador móvil # 259 (25 de junio - 1 de julio)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>