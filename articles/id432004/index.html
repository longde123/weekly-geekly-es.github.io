<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ”§ â™‚ï¸ âŒ›ï¸ Pengantar pemrograman reaktif ğŸ’…ğŸ¼ ğŸ§šğŸ¼ ğŸ¤±ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Dalam artikel ini saya akan berpacu di seluruh Eropa, yaitu, saya akan memberi tahu Anda apa yang mereka maksud dengan pemrograman reaktif, mempe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar pemrograman reaktif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/432004/">  Halo  Dalam artikel ini saya akan berpacu di seluruh Eropa, yaitu, saya akan memberi tahu Anda apa yang mereka maksud dengan pemrograman reaktif, memperkenalkan Anda kepada aktor, aliran reaktif, dan akhirnya, menggunakan aliran reaktif, kami akan mengenali gerakan mouse, seperti di Opera lama dan penerus spiritualnya - Vivaldi . <br><br>  Tujuannya adalah untuk memperkenalkan konsep dasar pemrograman reaktif dan menunjukkan bahwa tidak semuanya serumit dan seram seperti yang terlihat pada pandangan pertama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/858/157/0c68581574002383d90367c3e6b996c9.jpg" alt="gambar"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a></i> <br><a name="habracut"></a><br><h2>  Apa itu pemrograman reaktif? </h2><br>  Untuk menjawab pertanyaan ini, kita beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> .  Ini memiliki gambar yang indah yang menunjukkan 4 kriteria utama yang harus dipenuhi oleh aplikasi reaktif. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e5/092/390/6e5092390fa27e7843b59d57da94b8b3.svg" alt="gambar"><br><br>  Aplikasi harus cepat, toleran terhadap kesalahan dan skala dengan baik. <br>  Sepertinya "kita untuk semua baik versus semua buruk", kan? <br><br>  Apa yang dimaksud dengan kata-kata ini: <br><br><ol><li> <b>Responsif</b> <br><br>  Aplikasi harus memberi pengguna hasil dalam setengah detik.  Ini juga termasuk prinsip gagal cepat - yaitu, ketika terjadi kesalahan, lebih baik mengembalikan pesan kesalahan seperti â€œMaaf, ada masalah.  Coba lagi nanti daripada membuat cuaca menunggu di laut.  Jika operasinya panjang, kami menampilkan bilah kemajuan kepada pengguna.  Jika sangat panjang - â€œpermintaan Anda akan dipenuhi sementara pada tanggal 18 Maret 2042.  Kami akan mengirimkan pemberitahuan kepada Anda melalui pos. " </li><li>  <b>Skalabilitas</b> adalah cara untuk memberikan responsif di bawah beban.  Bayangkan siklus hidup dari layanan yang relatif sukses: <br><ol><li>  Peluncuran - aliran permintaan kecil, layanan berjalan pada mesin virtual dengan satu inti. </li><li>  Aliran permintaan meningkat - kernel ditambahkan ke mesin virtual dan permintaan diproses dalam beberapa utas. </li><li>  Bahkan lebih banyak memuat - kami menghubungkan batching - permintaan ke database dan hard drive dikelompokkan. </li><li>  Semakin banyak memuat - Anda perlu meningkatkan lebih banyak server dan menyediakan pekerjaan di kluster. <br>  Idealnya, sistem itu sendiri harus naik atau turun tergantung pada beban. </li></ol></li><li>  <b>Toleransi kesalahan</b> <br><br>  Kami menerima bahwa kami hidup di dunia yang tidak sempurna dan semuanya terjadi.  Jika terjadi kesalahan pada sistem kami, kami harus menyediakan metode penanganan kesalahan dan pemulihan </li><li>  Dan akhirnya, kami diundang untuk mencapai semua ini menggunakan sistem yang arsitekturnya didasarkan pada <b>pesan berbasis</b> pesan </li></ol><br>  Sebelum melanjutkan, saya ingin membahas bagaimana sistem yang digerakkan oleh peristiwa berbeda dari sistem yang digerakkan oleh pesan. <br><br>  <b>Didorong oleh acara:</b> <br><br><ul><li>  Peristiwa - sistem melaporkan bahwa ia telah mencapai kondisi tertentu. </li><li>  Mungkin ada banyak pelanggan untuk acara tersebut. </li><li>  Rantai peristiwa biasanya singkat, dan penangan acara dekat (baik secara fisik dan dalam kode) ke sumbernya. </li><li>  Sumber acara dan penangannya biasanya memiliki keadaan umum (secara fisik - mereka menggunakan potongan RAM yang sama untuk pertukaran informasi). </li></ul><br>  <b>Berbeda dengan event-driven, dalam sistem yang digerakkan oleh pesan:</b> <br><br><ul><li>  Setiap pesan hanya memiliki satu penerima. </li><li>  Pesan tidak berubah: Anda tidak dapat mengubah apa pun dalam pesan yang diterima sehingga pengirim tahu tentangnya dan dapat membaca informasi. </li><li>  Elemen-elemen sistem merespons (atau tidak merespons) untuk menerima pesan dan dapat mengirim pesan ke elemen-elemen lain dari sistem. </li></ul><br>  Semua ini menawarkan kita <br><br><h1>  Model aktor </h1><br>  Tonggak perkembangan: <br><br><ul><li>  Penyebutan aktor pertama adalah dalam makalah ilmiah tahun 1973 - Carl Hewitt, Peter Bishop, dan Richard Steiger, "Sebuah formalisme universal ACTOR modular untuk kecerdasan buatan," </li><li>  1986 - Erlang muncul.  Ericson membutuhkan bahasa untuk peralatan telekomunikasi yang akan memberikan toleransi kesalahan dan propagasi bebas kesalahan.  Dalam konteks artikel ini, fitur utamanya adalah: <br><br><ul><li>  Semuanya adalah proses </li><li>  Pesan adalah satu-satunya cara komunikasi (Erlang adalah bahasa fungsional, dan pesan di dalamnya tidak dapat diubah). </li></ul></li><li>  .. </li><li>  2004 - versi pertama bahasa Scala.  Fitur-fiturnya: <ul><li>  Didukung oleh JVM, </li><li>  Fungsional </li><li>  Untuk multi-threading, model aktor telah dipilih. </li></ul><br></li><li>  2009 - implementasi aktor dialokasikan di perpustakaan terpisah - Akka </li><li>  2014 - Akka.net - porting ke .Net. </li></ul><br><h1>  Apa yang bisa dilakukan aktor? </h1><br>  Aktor adalah objek yang sama, tetapi: <br><br><ul><li>  Tidak seperti objek biasa, aktor tidak dapat memanggil metode satu sama lain. </li><li>  Aktor dapat mengirimkan informasi <b>hanya melalui pesan yang tidak dapat diubah</b> . </li><li>  Setelah menerima pesan, aktor dapat <br><ul><li>  Buat aktor baru (mereka akan lebih rendah dalam hierarki), </li><li>  Kirim pesan ke aktor lain, </li><li>  Hentikan aktor di bawah ini dalam hierarki dan diri Anda sendiri. </li></ul></li></ul><br>  Mari kita lihat sebuah contoh. <br><br><img src="https://habrastorage.org/webt/ql/wj/cj/qlwjcjyygaw5s7iub_mshc1rbry.jpeg" alt="gambar"><br><br>  Aktor A ingin mengirim pesan ke Aktor B. Yang dia miliki hanyalah ActorRef (beberapa alamat).  Aktor B bisa dimana saja. <br>  Aktor A mengirimkan huruf B melalui sistem (ActorSystem).  Sistem meletakkan surat itu di kotak surat aktor B dan aktor "bangun" B. Aktor B mengambil surat itu dari kotak surat dan melakukan sesuatu. <br><br>  Dibandingkan dengan memanggil metode pada objek lain, itu terlihat tidak perlu rumit, tetapi model aktor sangat cocok di dunia nyata, jika Anda membayangkan bahwa aktor adalah orang yang dilatih untuk melakukan sesuatu dalam menanggapi rangsangan tertentu. <br><br>  Bayangkan seorang ayah dan seorang putra: <br><br><img src="https://habrastorage.org/webt/gk/o9/s5/gko9s5syabkkpdkg0_v_aimwwis.jpeg"><br><br>  Sang ayah mengirim putranya SMSku "Bersihkan di kamar" dan terus melakukan hal sendiri.  Anak itu membaca SMSku dan mulai membersihkan.  Ayah, sementara itu, sedang bermain poker.  Sang putra selesai membersihkan dan mengirim SMS "Selesai".  Itu terlihat sederhana, bukan? <br><br>  Sekarang bayangkan ayah dan anak itu bukan aktor, tetapi benda biasa yang bisa saling tarik metode.  Sang ayah menarik putranya untuk metode "membersihkan kamar" dan mengikuti dengan sendirinya, menunggu sampai putranya selesai membersihkan dan mentransfer kendali kembali ke ayahnya.  Ayah tidak bisa bermain poker saat ini.  Dalam konteks ini, model aktor menjadi lebih menarik. <br><br>  Sekarang mari kita beralih ke <br><br><h1>  Akka.NET </h1><br>  Segala sesuatu yang ditulis di bawah ini benar untuk Akka asli untuk JVM, tetapi bagi saya, C # lebih dekat daripada Java, jadi saya akan menggunakan Akka.NET sebagai contoh. <br><br><h3>  Jadi apa manfaat Akka? </h3><br><ul><li>  Multithreading melalui olahpesan.  Anda tidak lagi harus menderita dengan segala macam kunci, semaphore, mutex, dan kesenangan lain yang merupakan karakteristik multithreading klasik dengan memori bersama. </li><li>  Komunikasi transparan antara sistem dan komponennya.  Tidak perlu khawatir tentang kode jaringan yang kompleks - sistem itu sendiri akan menemukan tujuan pesan dan menjamin pengiriman pesan (di sini Anda dapat memasukkan lelucon tentang UDP vs TCP). </li><li>  Arsitektur fleksibel yang dapat secara otomatis menaikkan atau menurunkan.  Misalnya, di bawah beban, sistem dapat meningkatkan node cluster tambahan dan mendistribusikan beban secara merata. </li></ul><br>  Tetapi topik penskalaan sangat luas dan layak untuk publikasi terpisah.  Oleh karena itu, saya akan memberi tahu lebih detail hanya tentang fitur, yang akan berguna dalam semua proyek: <br><br><h2>  Menangani kesalahan </h2><br>  Aktor memiliki hierarki - dapat direpresentasikan sebagai pohon.  Setiap aktor memiliki orang tua dan dapat memiliki "anak-anak". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/57e/919/99e57e919cbea8e6761b75537c3f507a.png" alt="gambar"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Akka.NET</a> Hak Cipta 2013-2018 proyek Akka.NET</i> <br><br>  Untuk setiap aktor, Anda dapat menetapkan strategi Pengawasan - apa yang harus dilakukan jika ada yang tidak beres untuk "anak-anak".  Misalnya, "mengalahkan" aktor yang memiliki masalah, dan kemudian membuat aktor baru dengan tipe yang sama dan mempercayakan kepadanya dengan pekerjaan yang sama. <br><br>  Sebagai contoh, saya membuat aplikasi pada Akka.net CRUD, di mana lapisan "logika bisnis" diimplementasikan pada aktor.  Tujuan dari proyek ini adalah untuk mengetahui apakah para aktor harus digunakan dalam sistem yang tidak dapat diskalakan - apakah mereka akan membuat hidup lebih baik atau menambah rasa sakit. <br><br>  Bagaimana penanganan kesalahan bawaan Akka dapat membantu: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1f/oz/ou/1fozoulh0ufwzuyufofz4n8pvbi.gif"><br></div></div><br><ol><li>  semuanya baik-baik saja, aplikasi berfungsi, </li><li>  sesuatu terjadi pada repositori, dan sekarang hanya memberikan hasilnya 1 kali dari 5, </li><li>  Saya mengatur strategi Pengawasan untuk "coba 10 kali per detik", </li><li>  aplikasi bekerja lagi (walaupun lebih lambat), dan saya punya waktu untuk mencari tahu ada apa. </li></ol><br>  Ada godaan untuk mengatakan: "Ayo, saya akan menulis kesalahan seperti itu sendiri, mengapa beberapa aktor harus melakukan kesalahan?"  Ucapan wajar, tetapi hanya jika poin kegagalannya sedikit. <br><br>  Dan beberapa kode.  Beginilah inisialisasi sistem aktor dalam wadah IoC: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Container</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MySystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> echo = system.ActorOf&lt;EchoActor&gt;(<span class="hljs-string"><span class="hljs-string">"Echo"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//stop initialization if something is wrong with actor system var alive = echo.Ask&lt;bool&gt;(true, TimeSpan.FromMilliseconds(100)).Result; container = new WindsorContainer(); //search for dependencies //register controllers //register ActorSystem propsResolver = new WindsorDependencyResolver(container, (ActorSystem)system); system.AddDependencyResolver(propsResolver); actorSystemWrapper = new ActorSystemWrapper(system, propsResolver); container.Register(Component.For&lt;IActorRefFactory&gt;().Instance(actorSystemWrapper)); container.Register(Component.For&lt;IDependencyResolver&gt;().Instance(propsResolver)); }</span></span></code> </pre> <br>  EchoActor adalah aktor paling sederhana yang mengembalikan nilai ke pengirim: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EchoActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EchoActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(flag =&gt; { Sender.Tell(flag); }); } }</code> </pre><br>  Untuk menghubungkan aktor dengan kode "biasa", perintah Ask digunakan: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;ActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ViewBag.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Model); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CrudActorRef.Ask&lt;IEnumerable&lt;Model&gt;&gt;(DataMessage.GetAll&lt;Model&gt;(), maxDelay); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(res); }</code> </pre> <br><h3>  Total </h3><br>  Mencibir dengan para aktor, saya dapat mengatakan: <br><br><ul><li>  Lihatlah mereka jika Anda membutuhkan skalabilitas. </li><li>  Untuk logika bisnis yang kompleks, lebih baik tidak menggunakannya karena <ul><li>  Injeksi Ketergantungan aneh.  Untuk menginisialisasi aktor dengan dependensi yang diperlukan, Anda harus terlebih dahulu membuat objek Props, lalu memberikannya ke ActorSystem untuk membuat aktor dengan tipe yang diinginkan.  Untuk membuat Alat Peraga menggunakan wadah IoC (misalnya, Castle Windsor atau Autofac) ada pembungkus siap pakai - DependencyResolvers.  Tetapi saya dihadapkan dengan kenyataan bahwa wadah IoC berusaha untuk mengontrol masa pakai ketergantungan, dan setelah beberapa saat sistem diam-diam jatuh. <br><br>  * Mungkin, alih-alih menyuntikkan dependensi ke objek, Anda harus menempatkan dependensi ini sebagai aktor cilik. </li><li>  masalah mengetik.  ActorRef tidak tahu apa-apa tentang tipe aktor yang dimaksud.  Artinya, pada waktu kompilasi tidak diketahui apakah aktor dapat memproses pesan jenis ini atau tidak. </li></ul></li></ul><br><h1>  Bagian 2: Jet stream </h1><br>  Sekarang mari kita beralih ke topik yang lebih populer dan berguna - aliran jet.  Jika Anda tidak pernah bisa bertemu dengan aktor dalam proses kerja, maka aliran Rx tentu akan berguna baik di frontend dan di backend.  Implementasinya hampir di semua bahasa pemrograman modern.  Saya akan memberikan contoh pada RxJs, karena saat ini bahkan programmer backend terkadang harus melakukan sesuatu dalam JavaScript. <br><br><img src="https://habrastorage.org/webt/ru/yn/g9/ruyng9clvfa1gh8bd5ai3lpnc5m.jpeg"><br>  <i>Streaming Rx tersedia untuk semua bahasa pemrograman populer.</i> <br><br>  <i>â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Pemrograman Reaktif yang Anda lewatkan</a> â€ oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andre Staltz</a> , dilisensikan di bawah CC BY-NC 4.0</i> <br><br>  Untuk menjelaskan apa itu jet stream, saya akan mulai dengan tarikan dan dorong koleksi. <br><table><tbody><tr><th></th><th>  Nilai pengembalian tunggal </th><th>  Nilai pengembalian berganda </th></tr><tr><td>  Tarik <br>  Sinkron <br>  Interaktif </td><td>  T </td><td>  IEnumerable &lt;T&gt; </td></tr><tr><td>  Dorong <br>  Tidak sinkron <br>  Reaktif </td><td>  Tugas &lt;T&gt; </td><td>  IObservable &lt;T&gt; </td></tr></tbody></table><br>  Tarik koleksi adalah apa yang kita semua terbiasa dalam pemrograman.  Contoh yang paling mencolok adalah array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Sudah memiliki data, dia sendiri tidak akan mengubah data ini, tetapi dia dapat memberikannya berdasarkan permintaan. <br><br><pre> <code class="javascript hljs">arr.forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Juga, sebelum Anda melakukan sesuatu dengan data, Anda dapat memprosesnya. <br><br><pre> <code class="javascript hljs">arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> â€œmy number is â€+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Sekarang mari kita bayangkan bahwa pada awalnya tidak ada data dalam koleksi, tetapi itu pasti akan memberitahu Anda bahwa mereka telah muncul (Push).  Dan pada saat yang sama, kami masih dapat menerapkan transformasi yang diperlukan untuk koleksi ini. <br><br>  Sebagai contoh: <br><br><pre> <code class="javascript hljs">source.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> â€œmy number is â€+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Ketika nilai seperti 1 muncul di sumber, console.log akan menampilkan "nomor saya adalah 1". <br><br>  Cara kerjanya: <br><br>  Entitas baru muncul - Subjek (atau Dapat Diamati): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) </span></span>{ observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">3</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">4</span></span>); observer.complete(); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre> <br>  Ini adalah koleksi push yang akan mengirimkan pemberitahuan tentang perubahan di negaranya. <br><br>  Dalam hal ini, angka 1, 2 dan 3 akan segera muncul di dalamnya, dalam 4 detik, dan kemudian koleksi akan "berakhir".  Ini adalah jenis acara khusus. <br><br>  Entitas kedua adalah Pengamat.  Dia dapat berlangganan acara Subjek dan melakukan sesuatu dengan data yang diterima.  Sebagai contoh: <br><br><pre> <code class="javascript hljs">observable.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x)); observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'got value '</span></span> + x), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'something wrong occurred: '</span></span> + err), <span class="hljs-attr"><span class="hljs-attr">complete</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>), }); observable .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'This is '</span></span> + x) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x));</code> </pre> <br>  Dapat dilihat bahwa satu Subjek dapat memiliki banyak pelanggan. <br><br>  Itu terlihat mudah, tetapi belum jelas mengapa ini perlu.  Saya akan memberikan 2 definisi lagi yang perlu Anda ketahui ketika bekerja dengan aliran reaktif, dan kemudian saya akan menunjukkan dalam praktiknya bagaimana mereka bekerja dan dalam situasi apa potensi penuh mereka terungkap. <br><br><h4>  Diamati dingin </h4><br><ul><li>  Beri tahu tentang peristiwa saat seseorang berlangganan. </li><li>  Seluruh aliran data dikirim lagi ke setiap pelanggan, terlepas dari waktu berlangganan. </li><li>  Data disalin untuk setiap pelanggan. </li></ul><br>  Apa artinya ini: katakanlah perusahaan (Subjek) memutuskan untuk mengatur distribusi hadiah.  Setiap karyawan (Pengamat) datang untuk bekerja dan menerima salinan hadiahnya.  Tidak ada yang dirampas. <br><br><h4>  Teramati panas </h4><br><ul><li>  Mereka mencoba memberi tahu acara tersebut terlepas dari keberadaan pelanggan.  Jika pada saat acara tidak ada pelanggan, data hilang. </li></ul><br>  Contoh: di pagi hari, kue panas untuk karyawan dibawa ke perusahaan.  Ketika mereka dibawa masuk, semua lark terbang ke bau dan membuat pai untuk sarapan.  Tetapi burung hantu yang datang kemudian tidak mendapatkan pai lagi. <br><br><h4>  Dalam situasi apa jet stream digunakan? </h4><br>  Ketika ada aliran data yang didistribusikan dari waktu ke waktu.  Misalnya, input pengguna.  Atau log dari layanan apa pun.  Di salah satu proyek, saya melihat logger buatan sendiri yang mengumpulkan peristiwa dalam N detik, dan kemudian secara bersamaan merekam seluruh paket.  Kode baterai memenuhi halaman.  Jika Rx stream digunakan, maka itu akan jauh lebih sederhana: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/b1a/396/b6eb1a3960bd8b422c01b6c0a5dd97f0.png" alt="gambar"><br>  <i>â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi / Observasi RxJ</a> , dokumentasi dilisensikan di bawah CC BY 4.0</i> . <br>  <i>(ada banyak contoh dan gambar yang menjelaskan apa yang dilakukan berbagai operasi dengan aliran reaktif)</i> <br><br><pre> <code class="javascript hljs">source.bufferTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>).subsribe(doThings);</code> </pre> <br>  Dan akhirnya, contoh penggunaan. <br><br><h2>  Mengenali gerakan mouse dengan aliran Rx </h2><br>  Di Opera lama atau penerus spiritualnya - Vivaldi - ada kontrol browser menggunakan gerakan mouse. <br><br><div class="spoiler">  <b class="spoiler_title">Gif - gerakan mouse di Vivaldi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xs/ok/eq/xsokeqelkjbtvgrcurbv-wffmog.gif"><br></div></div><br>  Artinya, Anda perlu mengenali gerakan mouse atas / bawah, kanan / kiri, dan kombinasinya.  Itu dapat ditulis tanpa stream Rx, tetapi kodenya akan kompleks dan sulit untuk dipelihara. <br><br><h4>  Dan inilah tampilannya dengan aliran Rx: </h4><br>  Saya akan mulai dari akhir - Saya akan mengatur data apa dan dalam format apa saya akan mencari dalam urutan asli: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//gestures to look for const gestures = Rx.Observable.from([ { name: "Left", sequence: Rx.Observable.from([{ x: -1, y: 0 }]) }, { name: "Right", sequence: Rx.Observable.from([{ x: 1, y: 0 }]) }, { name: "Up", sequence: Rx.Observable.from([{ x: 0, y: -1 }]) }, { name: "Down", sequence: Rx.Observable.from([{ x: 0, y: 1 }]) }, { name: "Down+Up", sequence: Rx.Observable.from([{ x: 0, y: 1 }, { x: 0, y: -1 }]) }, { name: "Up+Right", sequence: Rx.Observable.from([{ x: 0, y: -1 }, { x: 1, y: 0 }]) } ]);</span></span></code> </pre> <br>  Ini adalah vektor satuan dan kombinasinya. <br><br>  Selanjutnya, Anda perlu mengonversi acara mouse ke aliran Rx.  Semua pustaka Rx memiliki alat bawaan untuk mengubah acara standar menjadi Dapat Diobservasi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseMoves = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>), mouseDowns = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>), mouseUps = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mouseup'</span></span>);</code> </pre> <br>  Selanjutnya, saya mengelompokkan koordinat mouse dengan 2 dan menemukan perbedaannya, mendapatkan offset mouse. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseDiffs = mouseMoves .map(getOffset) .pairwise() .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pair</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].x-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].y-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].y } });</code> </pre> <br>  Dan kelompokkan gerakan-gerakan ini menggunakan acara 'mousedown' dan 'mouseup'. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseGestures = mouseDiffs .bufferToggle(mouseDowns, x =&gt; mouseUps) .map(concat);</code> </pre> <br>  Fungsi concat memotong gerakan yang terlalu pendek dan mengelompokkan gerakan yang kira-kira sejajar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-comment"><span class="hljs-comment">//summarize move in same direction return values.reduce((a, v) =&gt; { if (!a.length) { a.push(v); } else { const last = a[a.length - 1]; const lastAngle = Math.atan2(last.x, last.y); const angle = Math.atan2(vx, vy); const angleDiff = normalizeAngle(angle - lastAngle); const dist = Math.hypot(vx, vy); if (dist &lt; 1) return a;//move is too short â€“ ignore //moving in same direction =&gt; adding vectors if (Math.abs(angleDiff) &lt;= maxAngleDiff) { last.x += vx; last.y += vy; } else { a.push(v); } } return a; }, []); }</span></span></code> </pre> <br>  Jika gerakan pada sumbu X atau Y terlalu pendek, itu diatur ulang ke nol.  Dan kemudian hanya tanda yang tersisa dari koordinat perpindahan yang diperoleh.  Dengan demikian, vektor satuan yang kami cari diperoleh. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> normalizedMouseGestures = mouseGestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function"> =&gt;</span></span> arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dist = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.hypot(vx, vy);<span class="hljs-comment"><span class="hljs-comment">//length of vector vx = Math.abs(vx) &gt; minMove &amp;&amp; Math.abs(vx) * treshold &gt; dist ? vx : 0; vy = Math.abs(vy) &gt; minMove &amp;&amp; Math.abs(vy) * treshold &gt; dist ? vy : 0; return v; }) ).map(arr =&gt; arr .map(v =&gt; { return { x: Math.sign(vx), y: Math.sign(vy) }; }) .filter(v =&gt; Math.hypot(vx, vy) &gt; 0) );</span></span></code> </pre> <br>  Hasil: <br><br><pre> <code class="javascript hljs">gestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gesture</span></span></span><span class="hljs-function"> =&gt;</span></span> normalizedMouseGestures.mergeMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moves</span></span></span><span class="hljs-function"> =&gt;</span></span> Rx.Observable.from(moves) .sequenceEqual(gesture.sequence, comparer) ).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x).mapTo(gesture.name) ).mergeAll().subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gestureName</span></span></span><span class="hljs-function"> =&gt;</span></span> actions[gestureName]());</code> </pre> <br>  Menggunakan sequenceEqual, Anda dapat membandingkan gerakan yang diterima dengan yang asli dan, jika ada kecocokan, lakukan tindakan tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lp/bx/fe/lpbxfeq_bq-mdfybskn0v7wwen8.gif"><br></div></div><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat bermain dengan gerakan di sini</a> <br><br>  Harap dicatat bahwa, selain pengenalan gerakan, ada juga gambar gerakan mouse awal dan normal pada kanvas HTML.  Keterbacaan kode tidak mengalami hal ini. <br><br>  Dari mana satu lagi keuntungan berikut - fungsi yang ditulis dengan bantuan aliran Rx dapat dengan mudah ditambahkan dan diperluas. <br><br><h2>  Ringkasan </h2><br><ul><li>  Perpustakaan dengan aliran Rx tersedia untuk hampir semua bahasa pemrograman. </li><li>  Aliran Rx harus digunakan ketika ada aliran peristiwa yang membentang dari waktu ke waktu (misalnya, input pengguna). </li><li>  Fungsi yang ditulis menggunakan stream Rx dapat dengan mudah ditambahkan dan diperluas. </li><li>  Saya tidak menemukan kekurangan yang berarti. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Tautan yang bermanfaat</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.introtorx.com</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getakka.net/articles/intro/what-is-akka.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reactivex.io/rxjs/class/es6/Observable.js ~Observable.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reactivex.io/languages.html</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432004/">https://habr.com/ru/post/id432004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431992/index.html">Biometrik: bagaimana keadaan kita dan mereka</a></li>
<li><a href="../id431994/index.html">Diskusi lisensi PVS-Studio gratis untuk proyek-proyek yang dihosting di GitHub</a></li>
<li><a href="../id431996/index.html">Smart Engines Science Corporate (atau bagaimana kami melaju ke ICMV 2018)</a></li>
<li><a href="../id431998/index.html">Temui Yandex.Phone - sekarang resmi</a></li>
<li><a href="../id432002/index.html">Microsoft sedang mengembangkan browser berbasis Chromium, yang akan dikirimkan secara default, bukan Edge</a></li>
<li><a href="../id432006/index.html">Kisah bagaimana saya masuk ke topik kesehatan wanita</a></li>
<li><a href="../id432008/index.html">Mengejar Standar Web</a></li>
<li><a href="../id432012/index.html">Cara menguji kontrak yang cerdas</a></li>
<li><a href="../id432014/index.html">Kali Linux untuk pemula</a></li>
<li><a href="../id432016/index.html">Bagaimana musik dan menggambar mengajari saya cara memprogram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>