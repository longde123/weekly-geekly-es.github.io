<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñçÔ∏è üìú üê¥ JAR de lanzamiento m√∫ltiple: ¬ømalo o bueno? üôåüèΩ üßúüèæ üïé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De un traductor: estamos trabajando activamente para traducir la plataforma en rieles de Java 11 y estamos pensando en c√≥mo desarrollar de manera efic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JAR de lanzamiento m√∫ltiple: ¬ømalo o bueno?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/428868/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cn/ee/cmcnee4gyidm3xbo-0fl1fatdme.png"></div><br><p>  <em>De un traductor: estamos trabajando activamente para traducir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plataforma</a> en rieles de Java 11 y estamos pensando en c√≥mo desarrollar de manera eficiente las bibliotecas de Java (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YARG</a> ), teniendo en cuenta las caracter√≠sticas de Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8/11</a> para que no tenga que crear ramas y lanzamientos por separado.</em>  <em>Una posible soluci√≥n es un JAR de lanzamiento m√∫ltiple, pero no todo es sencillo.</em> </p><br><p>  Java 9 incluye una nueva opci√≥n de tiempo de ejecuci√≥n de Java llamada JAR de lanzamiento m√∫ltiple.  Esta es quiz√°s una de las innovaciones m√°s controvertidas en la plataforma.  <em>TL; DR: consideramos que esta es una soluci√≥n torcida para un problema grave</em> .  En esta publicaci√≥n explicaremos por qu√© creemos que s√≠, y tambi√©n le diremos c√≥mo construir tal JAR si realmente lo desea. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los JAR de lanzamiento m√∫ltiple</a> , o JAR MR, son una nueva caracter√≠stica de la plataforma Java, introducida en JDK 9. Aqu√≠ describiremos en detalle los riesgos significativos asociados con el uso de esta tecnolog√≠a y c√≥mo crear JAR de lanzamiento m√∫ltiple usando Gradle, si a√∫n quieres </p><br><p>  De hecho, un JAR de lanzamiento m√∫ltiple es un archivo Java que incluye varias variantes de la misma clase para trabajar con diferentes versiones del tiempo de ejecuci√≥n.  Por ejemplo, si est√° trabajando en JDK 8, el entorno Java usar√° la versi√≥n de clase para JDK 8 y si en Java 9 se usa la versi√≥n para Java 9. De manera similar, si la versi√≥n se cre√≥ para una versi√≥n futura de Java 10, el tiempo de ejecuci√≥n usa esta versi√≥n en lugar de la versi√≥n para Java 9 o la versi√≥n predeterminada (Java 8). </p><br><p>  Debajo del gato, entendemos el dispositivo del nuevo formato JAR y descubrimos si esto es todo. </p><a name="habracut"></a><br><h2 id="kogda-ispolzovat-multi-release-jars">  Cu√°ndo usar JAR de lanzamiento m√∫ltiple </h2><br><ul><li>  Tiempo de ejecuci√≥n optimizado.  Esta es una soluci√≥n al problema que enfrentan muchos desarrolladores: al desarrollar una aplicaci√≥n, no se sabe en qu√© entorno se ejecutar√°.  Sin embargo, para algunas versiones del tiempo de ejecuci√≥n, puede incrustar versiones gen√©ricas de la misma clase.  Suponga que desea mostrar el n√∫mero de versi√≥n de Java en el que se ejecuta la aplicaci√≥n.  Para Java 9, puede usar el m√©todo Runtime.getVersion.  Sin embargo, este es un nuevo m√©todo disponible solo en Java 9+.  Si necesita otros tiempos de ejecuci√≥n, digamos Java 8, debe analizar la propiedad java.version.  Como resultado, tendr√° 2 implementaciones diferentes de una funci√≥n. </li><li><p>  API en conflicto: la resoluci√≥n de conflictos entre API tambi√©n es un problema com√∫n.  Por ejemplo, debe admitir dos tiempos de ejecuci√≥n, pero en uno de ellos la API est√° en desuso.  Hay 2 soluciones comunes a este problema: </p><br><ol><li>  El primero es la reflexi√≥n.  Por ejemplo, puede especificar la interfaz VersionProvider, luego 2 clases espec√≠ficas Java8VersionProvider y Java9VersionProvider, y cargar la clase correspondiente en tiempo de ejecuci√≥n (¬°es curioso que para elegir entre dos clases tenga que analizar el n√∫mero de versi√≥n!).  Una de las opciones para esta soluci√≥n es crear una sola clase con varios m√©todos que se llaman usar la reflexi√≥n. </li><li>  Una soluci√≥n m√°s avanzada es utilizar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√©todos de control</a> cuando sea posible.  Lo m√°s probable es que la reflexi√≥n te parezca inhibitoria e inc√≥moda y, en general, tal como es. </li></ol><br></li></ul><br><h2 id="izvestnye-alternativy-podhodu-multi-release-jars">  Alternativas conocidas a los JAR de lanzamiento m√∫ltiple </h2><br><p>  La segunda forma, m√°s simple y m√°s comprensible, es crear 2 archivos diferentes para diferentes tiempos de ejecuci√≥n.  En teor√≠a, crea dos implementaciones de la misma clase en el IDE, y la tarea del sistema de compilaci√≥n es compilarlas, probarlas y empacarlas correctamente en 2 artefactos diferentes.  Este es un enfoque que se ha utilizado en Guava o Spock durante muchos a√±os.  Pero tambi√©n es necesario para idiomas como Scala.  Y todo porque hay tantas opciones para el compilador y el tiempo de ejecuci√≥n que la compatibilidad binaria se vuelve casi inalcanzable. </p><br><p>  Pero hay muchas otras razones para usar archivos JAR separados: </p><br><ul><li>  JAR es solo una forma de empacar. </li></ul><br><p>  es un artefacto de ensamblaje que incluye clases, pero eso no es todo: los recursos, como regla, tambi√©n se incluyen en el archivo.  El empaque, como el manejo de recursos, tiene un precio.  El equipo de Gradle tiene como objetivo mejorar la calidad de construcci√≥n y reducir el tiempo de espera para que el desarrollador compile resultados, pruebas y el proceso de construcci√≥n en general.  Si el archivo aparece en el proceso demasiado pronto, se crea un punto de sincronizaci√≥n innecesario.  Por ejemplo, para compilar clases dependientes de API, lo √∫nico que se necesita son archivos .class.  No se necesitan archivos jar ni recursos en jar.  Del mismo modo, solo se necesitan archivos y recursos de calificaciones para ejecutar las pruebas de Gradle.  Para las pruebas, no es necesario crear un jar.  Solo ser√° necesario para un usuario externo (es decir, al publicar).  Pero si la creaci√≥n de un artefacto se vuelve obligatoria, algunas tareas no se pueden ejecutar en paralelo y se inhibe todo el proceso de ensamblaje.  Si para proyectos peque√±os esto no es cr√≠tico, para proyectos corporativos a gran escala este es el principal factor de desaceleraci√≥n. </p><br><ul><li>  Es mucho m√°s importante que, al ser un artefacto, un archivo jar no pueda transportar informaci√≥n sobre dependencias. </li></ul><br><p>  Es poco probable que las dependencias de cada clase en el tiempo de ejecuci√≥n de Java 9 y Java 8 sean las mismas.  S√≠, en nuestro ejemplo simple ser√°, pero para proyectos m√°s grandes esto no es cierto: generalmente el usuario importa el backport de la biblioteca para la funcionalidad Java 9 y lo usa para implementar la versi√≥n de la clase Java 8. Sin embargo, si empaqueta ambas versiones en un archivo, en un artefacto habr√° elementos con diferentes √°rboles de dependencia.  Esto significa que si est√° trabajando con Java 9, tiene dependencias que nunca ser√°n necesarias.  Adem√°s, contamina el classpath, creando conflictos probables para los usuarios de la biblioteca. </p><br><p>  Y finalmente, en un proyecto puede crear JAR para diferentes prop√≥sitos: </p><br><ul><li>  para API </li><li>  para java 8 </li><li>  para java 9 </li><li>  con enlace nativo </li><li>  etc. </li></ul><br><p>  El uso incorrecto del <em>clasificador de</em> dependencias genera conflictos relacionados con el uso compartido del mismo mecanismo.  Por <em>lo</em> general, las <em>fuentes</em> o <em>javadocs</em> se instalan como clasificadores, pero en realidad no tienen dependencias. </p><br><ul><li>  No queremos generar inconsistencias; el proceso de construcci√≥n no debe depender de c√≥mo se obtienen las clases.  En otras palabras, el uso de jarras de lanzamiento m√∫ltiple tiene un efecto secundario: llamar desde el archivo JAR y llamar desde el directorio de la clase ahora son cosas completamente diferentes.  ¬°Tienen una gran diferencia en sem√°ntica! </li><li>  Dependiendo de la herramienta que use para crear el JAR, ¬°puede terminar con archivos JAR incompatibles!  La √∫nica herramienta que garantiza que cuando empaquete dos opciones de clase en un archivo, tendr√°n una √∫nica API abierta: la propia utilidad <em>jar</em> .  Lo cual, no sin raz√≥n, no necesariamente involucra herramientas de ensamblaje o incluso usuarios.  JAR es esencialmente un "sobre" que se asemeja a un archivo ZIP.  Entonces, dependiendo de c√≥mo lo recolecte, obtendr√° diferentes comportamientos, o tal vez recolectar√° un artefacto incorrecto (y no lo notar√°). </li></ul><br><h2 id="bolee-effektivnye-sposoby-upravleniya-otdelnymi-jar-arhivami">  Formas m√°s eficientes de administrar archivos JAR individuales </h2><br><p>  La raz√≥n principal por la que los desarrolladores no usan archivos separados es que son inconvenientes para recopilar y usar.  Las herramientas de compilaci√≥n tienen la culpa, que, antes de Gradle, no se las arregl√≥ para nada.  En particular, aquellos que usaron este m√©todo en Maven solo pod√≠an confiar en la funci√≥n de <em>clasificador</em> d√©bil para publicar artefactos adicionales.  Sin embargo, el <em>clasificador</em> no ayuda en esta dif√≠cil situaci√≥n.  Se utilizan para diversos fines, desde la publicaci√≥n de fuentes, documentaci√≥n, javadocs, hasta la implementaci√≥n de opciones de biblioteca (guava-jdk5, guava-jdk7, ...) o varios casos de uso (api, fat jar, ...).  En la pr√°ctica, no hay forma de mostrar que el √°rbol de dependencia del <em>clasificador</em> es diferente del √°rbol de dependencia del proyecto principal.  En otras palabras, el formato POM est√° fundamentalmente roto porque  Representa c√≥mo se ensambla el componente y los artefactos que suministra.  Supongamos que necesita implementar 2 archivos jar diferentes: jar cl√°sico y gordo, que incluye todas las dependencias.  ¬°Maven decide que 2 artefactos tienen √°rboles de dependencia id√©nticos, incluso si esto obviamente es incorrecto!  En este caso, esto es m√°s que obvio, ¬°pero la situaci√≥n es la misma que con los JAR de lanzamiento m√∫ltiple! </p><br><p>  La soluci√≥n es manejar las opciones correctamente.  Gradle puede hacer esto administrando dependencias basadas en opciones.  Esta caracter√≠stica est√° actualmente disponible para desarrollo en Android, ¬°pero tambi√©n estamos trabajando en su versi√≥n para Java y aplicaciones nativas! </p><br><p>  La gesti√≥n de dependencias basada en variantes se basa en el hecho de que los m√≥dulos y los artefactos son cosas completamente diferentes.  El mismo c√≥digo puede funcionar perfectamente en diferentes tiempos de ejecuci√≥n, teniendo en cuenta diferentes requisitos.  Para aquellos que trabajan con compilaci√≥n nativa, esto ha sido obvio durante mucho tiempo: compilamos para <em>i386</em> y <em>amd64</em> y de ninguna manera podemos interferir con las dependencias de la biblioteca <em>i386</em> con <em>arm64</em> .  En el contexto de Java, esto significa que para Java 8 necesita crear una versi√≥n del archivo JAR "java 8", donde el formato de clase corresponder√° a Java 8. Este artefacto contendr√° metadatos con informaci√≥n sobre qu√© dependencias usar.  Para Java 8 o 9, se seleccionar√°n las dependencias correspondientes a la versi√≥n.  Es as√≠ de simple (de hecho, la raz√≥n no es que el tiempo de ejecuci√≥n sea solo un campo de opciones, puede combinar varias). </p><br><p>  Por supuesto, nadie hab√≠a hecho esto antes debido a una complejidad excesiva: Maven, aparentemente, nunca permitir√≠a que se realizara una operaci√≥n tan complicada.  Pero con Gradle es posible.  El equipo de Gradle est√° trabajando actualmente en un nuevo formato de metadatos que les dice a los usuarios qu√© opci√≥n usar.  En pocas palabras, una herramienta de compilaci√≥n debe manejar la compilaci√≥n, prueba, empaque y procesamiento de dichos m√≥dulos.  Por ejemplo, el proyecto deber√≠a funcionar en los tiempos de ejecuci√≥n de Java 8 y Java 9. Idealmente, debe implementar 2 versiones de la biblioteca.  Esto significa que hay 2 compiladores diferentes (para evitar el uso de la API de Java 9 cuando se trabaja en Java 8), 2 directorios de clase y, en √∫ltima instancia, 2 archivos JAR diferentes.  Y tambi√©n, muy probablemente, ser√° necesario probar 2 tiempos de ejecuci√≥n.  O implementa 2 archivos, pero decide probar el comportamiento de la versi√≥n de Java 8 en el tiempo de ejecuci√≥n de Java 9 (¬°porque esto puede suceder al inicio!). </p><br><p>  Este esquema a√∫n no se ha implementado, pero el equipo de Gradle <a href="">ha hecho un progreso significativo</a> en esta direcci√≥n. </p><br><h2 id="kak-sozdat-multi-release-jar-s-pomoschyu-gradle">  C√≥mo crear JAR de lanzamiento m√∫ltiple usando Gradle </h2><br><p>  Pero si esta funci√≥n a√∫n no est√° lista, ¬øqu√© debo hacer?  Rel√°jese, los artefactos correctos se crean de la misma manera.  Antes de que aparezca la funci√≥n anterior en el ecosistema de Java, hay dos opciones: </p><br><ul><li>  buena manera antigua usando la reflexi√≥n o diferentes archivos JAR; </li><li>  use JAR de lanzamiento m√∫ltiple (tenga en cuenta que esta puede ser una mala soluci√≥n, incluso si hay buenos casos de uso). </li></ul><br><p>  Lo que elija, diferentes archivos o archivos JAR de lanzamiento m√∫ltiple, el esquema ser√° el mismo.  Los JAR de lanzamiento m√∫ltiple son esencialmente un paquete incorrecto: deber√≠an ser una opci√≥n, pero no el objetivo.  T√©cnicamente, el dise√±o de origen es el mismo para JAR individuales y externos.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> describe c√≥mo crear un JAR de lanzamiento m√∫ltiple usando Gradle.  La esencia del proceso se describe brevemente a continuaci√≥n. </p><br><p>  En primer lugar, siempre debe recordar un mal h√°bito de los desarrolladores: ejecutan Gradle (o Maven) utilizando la misma versi√≥n de Java en la que se planea lanzar los artefactos.  Adem√°s, a veces se usa una versi√≥n posterior para iniciar Gradle, y la compilaci√≥n se produce con un nivel de API anterior.  Pero no hay una raz√≥n particular para hacerlo.  En Gradle, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la compilaci√≥n de Ross</a> es posible.  Le permite describir la posici√≥n del JDK, as√≠ como ejecutar la compilaci√≥n como un proceso separado, para compilar el componente utilizando este JDK.  La mejor manera de configurar varios JDK es configurar la ruta al JDK a trav√©s de variables de entorno, como se hace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este archivo</a> .  Entonces solo necesita configurar Gradle para usar el JDK correcto, basado en la compatibilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con la plataforma fuente / destino</a> .  Vale la pena se√±alar que, comenzando con JDK 9, las versiones anteriores de JDK no son necesarias para la compilaci√≥n cruzada.  Esto hace una nueva caracter√≠stica, -release.  Gradle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa esta funci√≥n y configurar√° el compilador</a> seg√∫n sea necesario. </p><br><p>  Otro punto clave es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de fuentes de</a> designaci√≥n.  El conjunto de origen es un conjunto de archivos de origen que deben compilarse juntos.  Un JAR se obtiene compilando uno o m√°s conjuntos de origen.  Para cada conjunto, Gradle crea autom√°ticamente una tarea de compilaci√≥n personalizada adecuada.  Esto significa que si hay fuentes para Java 8 y Java 9, estas fuentes estar√°n en conjuntos diferentes.  As√≠ es exactamente como funciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el conjunto de fuentes para Java 9</a> , en el que habr√° una versi√≥n de nuestra clase.  Esto realmente funciona y no necesita crear un proyecto separado, como en Maven.  Pero lo m√°s importante, este m√©todo le permite ajustar la compilaci√≥n del conjunto. </p><br><p>  Una de las dificultades de tener diferentes versiones de una clase es que el c√≥digo de clase rara vez es independiente del resto del c√≥digo (tiene dependencias con clases que no est√°n en el conjunto principal).  Por ejemplo, su API puede usar clases que no necesitan fuentes especiales para admitir Java 9. Al mismo tiempo, no me gustar√≠a volver a compilar todas estas clases comunes y empacar sus versiones para Java 9. Son clases comunes, por lo tanto, deben existir por separado de clases para un JDK espec√≠fico.  Lo configuramos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> : agregue una dependencia entre el conjunto de origen para Java 9 y el conjunto principal, de modo que al compilar la versi√≥n para Java 9, todas las clases comunes permanezcan en el classpath de compilaci√≥n. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El siguiente paso es simple</a> : debe explicarle a Gradle que el conjunto principal de fuentes se compilar√° con el nivel API de Java 8, y el conjunto para Java 9 con el nivel Java 9. </p><br><p>  Todo lo anterior lo ayudar√° a usar los dos enfoques mencionados anteriormente: implementar archivos JAR separados o JAR de lanzamiento m√∫ltiple.  Como la publicaci√≥n trata sobre este tema, veamos un ejemplo de c√≥mo hacer que Gradle construya un JAR de lanzamiento m√∫ltiple: </p><br><pre><code class="java hljs">jar { into(<span class="hljs-string"><span class="hljs-string">'META-INF/versions/9'</span></span>) { from sourceSets.java9.output } manifest.attributes( <span class="hljs-string"><span class="hljs-string">'Multi-Release'</span></span>: <span class="hljs-string"><span class="hljs-string">'true'</span></span> ) }</code> </pre> <br><p>  Este bloque describe: empacar clases para Java 9 en el directorio <em>META-INF / versiones / 9</em> , que se usa para MR JAR, y establecer la etiqueta de liberaci√≥n m√∫ltiple en el manifiesto. </p><br><p>  Y eso es todo, ¬°tu primer MR JAR est√° listo! </p><br><p>  Pero, desafortunadamente, el trabajo en esto no ha terminado.  Si trabaj√≥ con Gradle, sabe que cuando usa el complemento de la aplicaci√≥n, puede ejecutar la aplicaci√≥n directamente a trav√©s de la tarea de <em>ejecuci√≥n</em> .  Sin embargo, debido al hecho de que Gradle generalmente intenta minimizar la cantidad de trabajo, la tarea de <em>ejecuci√≥n</em> debe usar tanto los directorios de clase como los directorios de los recursos procesados.  Para los JAR de versiones m√∫ltiples, esto es un problema porque los JAR son necesarios de inmediato.  Por lo tanto, en lugar de usar el complemento, tendr√° que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crear su propia tarea</a> , y este es un argumento en contra del uso de JAR de lanzamiento m√∫ltiple. </p><br><p>  Y por √∫ltimo, pero no menos importante, mencionamos que necesitar√≠amos probar 2 versiones de la clase.  Para esto, puede usar solo VM en un proceso separado, porque no hay un equivalente del marcador de <em>liberaci√≥n</em> para el tiempo de ejecuci√≥n de Java.  La idea es que solo se necesita escribir una prueba, pero se ejecutar√° dos veces: en Java 8 y Java 9. Esta es la √∫nica forma de asegurarse de que las clases espec√≠ficas del tiempo de ejecuci√≥n funcionen correctamente.  De forma predeterminada, Gradle crea una tarea de prueba y utiliza los directorios de clase de la misma manera en lugar del JAR.  Por lo tanto, haremos dos cosas: crear una tarea de prueba para Java 9 y configurar ambas tareas para que utilicen el JAR y los tiempos de ejecuci√≥n de Java especificados.  La implementaci√≥n se ver√° as√≠: </p><br><pre> <code class="java hljs">test { dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_8"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 8"</span></span> } } <span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testJava9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Test)</span></span></span><span class="hljs-function"> </span></span>{ dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_9"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println classpath.asPath println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 9"</span></span> } } check.dependsOn(testJava9)</code> </pre> <br><p>  Ahora, cuando comience la tarea, <em>verifique que</em> Gradle compilar√° cada conjunto de fuentes usando el JDK deseado, crear√° un JAR de lanzamiento m√∫ltiple y luego ejecutar√° las pruebas usando este JAR en ambos JDK.  Las versiones futuras de Gradle lo ayudar√°n a hacer esto de manera m√°s declarativa. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Para resumir.  Aprendiste que los JAR de lanzamiento m√∫ltiple son un intento de resolver el problema real que enfrentan muchos desarrolladores de bibliotecas.  Sin embargo, esta soluci√≥n al problema parece ser incorrecta.  Gesti√≥n correcta de la dependencia, vinculaci√≥n de artefactos y opciones, cuidado del rendimiento (la capacidad de ejecutar tantas tareas como sea posible en paralelo): todo esto hace de MR JAR una soluci√≥n para los pobres.  Este problema se puede resolver correctamente utilizando las opciones.  Y, sin embargo, si bien la gesti√≥n de dependencias que utiliza las opciones de Gradle est√° en desarrollo, los JAR de lanzamiento m√∫ltiple son bastante convenientes en casos simples.  En este caso, esta publicaci√≥n lo ayudar√° a comprender c√≥mo hacer esto y c√≥mo la filosof√≠a de Gradle difiere de Maven (conjunto de fuentes vs proyecto). </p><br><p>  Finalmente, no negamos que haya casos en los que los JAR de lanzamiento m√∫ltiple tengan sentido: por ejemplo, cuando no se sabe en qu√© entorno se ejecutar√° la aplicaci√≥n (no una biblioteca), pero esto es m√°s bien una excepci√≥n.  En esta publicaci√≥n, describimos los principales problemas que enfrentan los desarrolladores de bibliotecas y c√≥mo los JAR de versiones m√∫ltiples intentan resolverlos.  El modelado correcto de las dependencias como opciones mejora el rendimiento (a trav√©s del paralelismo preciso) y reduce los costos de mantenimiento (evitando la complejidad imprevista) en comparaci√≥n con los JAR de lanzamiento m√∫ltiple.  En su situaci√≥n, los MR JAR tambi√©n pueden ser necesarios, por lo que Gradle ya se ha encargado de esto.  Eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este proyecto de muestra</a> y pru√©belo usted mismo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428868/">https://habr.com/ru/post/es428868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428856/index.html">Un truco maravilloso para hacer que el responsable del proyecto de c√≥digo abierto al d√≠a</a></li>
<li><a href="../es428858/index.html">Conferencia DEFCON 17. ¬°R√≠ete de tus virus! Parte 1</a></li>
<li><a href="../es428860/index.html">Conferencia DEFCON 17. ¬°R√≠ete de tus virus! Parte 2</a></li>
<li><a href="../es428864/index.html">Hagamos que la web sea grandiosa nuevamente</a></li>
<li><a href="../es428866/index.html">7 principios de dise√±o, actitud hacia las tendencias de dise√±o, cartera de dise√±adores UX, ...</a></li>
<li><a href="../es428870/index.html">Mrr: FRP total para reaccionar</a></li>
<li><a href="../es428872/index.html">La historia de un ojo y 20 operaciones (no se puede leer) o quer√≠a ser piloto, pero no se le permiti√≥ volar al cielo</a></li>
<li><a href="../es428876/index.html">No hay vuelta atr√°s: la experiencia personal del probador</a></li>
<li><a href="../es428878/index.html">Pig Flight u optimizaci√≥n de int√©rpretes de bytecode</a></li>
<li><a href="../es428880/index.html">Nuevos m√©todos de autenticaci√≥n: ¬øuna amenaza para la privacidad?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>