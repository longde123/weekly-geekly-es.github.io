<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèº üôÜüèª üîº Mobile OAuth 2.0-Sicherheit üë©üèø‚Äç‚úàÔ∏è üíü üßò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Ich bin Nikita Stupin, Informationssicherheitsspezialist, Mail.Ru Mail. Vor nicht allzu langer Zeit habe ich eine Schwachstellenfors...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mobile OAuth 2.0-Sicherheit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Hallo allerseits!  Ich bin Nikita Stupin, Informationssicherheitsspezialist, Mail.Ru Mail.  Vor nicht allzu langer Zeit habe ich eine Schwachstellenforschung f√ºr mobiles OAuth 2.0 durchgef√ºhrt.  Um ein sicheres mobiles OAuth 2.0-Schema zu erstellen, reicht es nicht aus, den Standard in seiner reinen Form zu implementieren und redirect_uri zu √ºberpr√ºfen.  Es ist notwendig, die Besonderheiten mobiler Anwendungen zu ber√ºcksichtigen und zus√§tzliche Schutzmechanismen anzuwenden. <br><br>  In diesem Artikel m√∂chte ich Ihnen Wissen √ºber Angriffe auf mobile OAuth 2.0, √ºber Schutzmethoden und die sichere Implementierung dieses Protokolls mitteilen.  Alle erforderlichen Schutzkomponenten, auf die ich weiter unten eingehen werde, sind im neuesten SDK f√ºr die mobilen Mail.Ru Mail-Clients implementiert. <br><a name="habracut"></a><br><h1>  Die Art und Funktion von OAuth 2.0 </h1><br>  OAuth 2.0 ist ein Autorisierungsprotokoll, das beschreibt, wie sicher ein Clientdienst auf Benutzerressourcen eines Dienstanbieters zugreifen kann.  Gleichzeitig erspart OAuth 2.0 dem Benutzer die Eingabe eines Kennworts au√üerhalb des Dienstanbieters: Der gesamte Vorgang wird auf das Klicken auf die Schaltfl√§che "Ich stimme zu, Zugriff zu gew√§hren ..." reduziert. <br><br>  Ein Anbieter im Sinne von OAuth 2.0 ist ein Dienst, der Benutzerdaten besitzt und mit Erlaubnis des Benutzers Diensten (Clients) von Drittanbietern einen sicheren Zugriff auf diese Daten bietet.  Ein Client ist eine Anwendung, die Benutzerdaten von einem Anbieter empfangen m√∂chte. <br><br>  Einige Zeit nach der Ver√∂ffentlichung des OAuth 2.0-Protokolls haben gew√∂hnliche Entwickler es f√ºr die Authentifizierung angepasst, obwohl es urspr√ºnglich nicht daf√ºr vorgesehen war.  Durch die Authentifizierung wird der Angriffsvektor von Benutzerdaten, die beim Dienstanbieter gespeichert sind, auf Benutzerkonten f√ºr Benutzerdienste verschoben. <br><br>  Es war nicht nur auf die Authentifizierung beschr√§nkt.  Im Zeitalter der mobilen Apps und der zunehmenden Konvertierung ist das Aufrufen der App mit einer einzigen Schaltfl√§che sehr verlockend geworden.  Die Entwickler setzen OAuth 2.0 auf mobile Schienen.  Nat√ºrlich haben nur wenige Menschen √ºber die Sicherheit und Besonderheiten mobiler Anwendungen nachgedacht: immer wieder und in der Produktion.  OAuth 2.0 funktioniert jedoch im Allgemeinen nicht gut au√üerhalb von Webanwendungen: Die gleichen Probleme treten sowohl bei mobilen als auch bei Desktopanwendungen auf. <br><br>  Lassen Sie uns herausfinden, wie Sie ein sicheres mobiles OAuth 2.0 erstellen. <br><br><h1>  Wie funktioniert es </h1><br>  Denken Sie daran, dass der Client auf Mobilger√§ten m√∂glicherweise kein Browser ist, sondern eine mobile Anwendung ohne Backend.  Daher stehen wir vor zwei gro√üen Sicherheitsproblemen f√ºr mobile OAuth 2.0: <br><br><ol><li>  Dem Client wird nicht vertraut. </li><li>  Das Verhalten einer Umleitung von einem Browser zu einer mobilen Anwendung h√§ngt von den Einstellungen und Anwendungen ab, die der Benutzer installiert hat. </li></ol><br><h4>  Mobile Anwendung ist ein √∂ffentlicher Client </h4><br>  Um die Wurzel des ersten Problems zu verstehen, sehen wir uns an, wie OAuth 2.0 bei Server-zu-Server-Interaktion funktioniert, und vergleichen es dann mit OAuth 2.0 bei Client-zu-Server-Interaktion. <br><br>  In beiden F√§llen beginnt alles damit, dass sich der Service-Client beim Service-Provider registriert und <code>client_id</code> und in einigen F√§llen <code>client_secret</code> .  Der Wert <code>client_id</code> ist √∂ffentlich und wird im Gegensatz zu <code>client_secret</code> , dessen Wert privat ist, zur Identifizierung des <code>client_secret</code> .  Der Registrierungsprozess wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 7591</a> ausf√ºhrlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben</a> . <br><br>  Das folgende Diagramm zeigt den Betrieb von OAuth 2.0 bei der Server-zu-Server-Kommunikation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Es gibt 3 Hauptstufen des OAuth 2.0-Protokolls: <br><br><ol><li>  [AC-Schritte] Holen Sie sich den Autorisierungscode (im Folgenden einfach <code>code</code> ). </li><li>  [DE-Schritte] Austauschcode f√ºr <code>access_token</code> . </li><li>  <code>access_token</code> mit <code>access_token</code> die Ressource zu. </li></ol><br>  Wir werden den Erhalt des Codes genauer analysieren: <br><br><ol><li>  [Schritt A] Der Service-Client leitet den Benutzer zum Service-Provider weiter. </li><li>  [Schritt B] Der Dienstanbieter fordert vom Benutzer die Erlaubnis an, Daten f√ºr den Clientdienst bereitzustellen (Pfeil B nach oben).  Der Benutzer bietet Zugriff auf die Daten (Pfeil B rechts). </li><li>  [Schritt C] Der Dienstanbieter gibt den <code>code</code> an den Browser des Benutzers zur√ºck, der den <code>code</code> den Clientdienst umleitet. </li></ol><br>  <code>access_token</code> wir <code>access_token</code> genauer an: <br><br><ol><li>  [Schritt D] Der Client-Server sendet eine Anforderung f√ºr <code>access_token</code> .  Die Anfrage enth√§lt: <code>code</code> , <code>client_secret</code> und <code>redirect_uri</code> . </li><li>  [Schritt E] Bei g√ºltigem <code>code</code> , <code>client_secret</code> und <code>redirect_uri</code> , wird <code>client_secret</code> bereitgestellt. </li></ol><br>  Die Anforderung f√ºr <code>access_token</code> wird gem√§√ü dem Server-zu-Server-Schema ausgef√ºhrt. Um <code>client_secret</code> zu stehlen <code>client_secret</code> muss <code>client_secret</code> Angreifer im Allgemeinen den Server-Client-Server oder den Server des Dienstanbieters hacken. <br><br>  Lassen Sie uns nun sehen, wie das OAuth 2.0-Schema auf einem mobilen Ger√§t ohne Backend aussieht (Client-Server-Interaktion). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Das allgemeine Schema ist in die gleichen drei Hauptschritte unterteilt: <br><br><ol><li>  [Schritte 1-4 im Bild] Holen Sie sich den <code>code</code> . </li><li>  [Schritte 5-6 im Bild] Austauschcode f√ºr <code>access_token</code> . </li><li>  <code>access_token</code> mit <code>access_token</code> die Ressource zu. </li></ol><br>  In diesem Fall fungiert die mobile Anwendung jedoch auch als Server, was bedeutet, dass <code>client_secret</code> innerhalb der Anwendung <code>client_secret</code> wird.  Dies f√ºhrt dazu, dass es auf mobilen Ger√§ten unm√∂glich ist, <code>lient_secret</code> vor einem Angreifer geheim zu halten.  <code>client_secret</code> gibt zwei M√∂glichkeiten, <code>client_secret</code> mit der Anwendung zu verbinden: Filtern des Datenverkehrs von der Anwendung zum Server oder Reverse Engineering der Anwendung.  Beide Methoden sind einfach zu implementieren, sodass <code>client_secret</code> auf Mobilger√§ten unbrauchbar <code>client_secret</code> . <br><br>  In Bezug auf das Client-zu-Server-Schema haben Sie m√∂glicherweise die Frage: "Warum nicht sofort <code>access_token</code> ?".  Es scheint, warum brauchen wir einen zus√§tzlichen Schritt?  Dar√ºber hinaus gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implizites Grant-</a> Schema, bei dem der Client sofort ein <code>access_token</code> erh√§lt.  Obwohl es in einigen F√§llen verwendet werden kann, werden wir unten sehen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implicit Grant</a> nicht f√ºr sicheres mobiles OAuth 2.0 geeignet ist. <br><br><h4>  Weiterleitung auf Mobilger√§ten </h4><br>  Im Allgemeinen werden f√ºr eine Umleitung von einem Browser zu einer Anwendung auf Mobilger√§ten das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte URI-Schema</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppLink-</a> Mechanismen verwendet.  Keiner dieser Mechanismen in seiner reinen Form ist so zuverl√§ssig wie eine Browserumleitung. <br><br>  Das benutzerdefinierte URI-Schema (oder Deep Link) wird wie folgt verwendet: Der Entwickler definiert das Anwendungsschema vor dem Zusammenbau.  Das Schema kann beliebig sein, w√§hrend auf demselben Ger√§t mehrere Anwendungen mit demselben Schema installiert werden k√∂nnen.  Alles ist ganz einfach, wenn jede Anwendung auf dem Ger√§t einer Anwendung entspricht.  Was aber, wenn zwei Anwendungen dieselbe Schaltung auf demselben Ger√§t registriert haben?  Wie kann das Betriebssystem bestimmen, welche der beiden Anwendungen beim Zugriff auf das benutzerdefinierte URI-Schema ge√∂ffnet werden soll?  Android zeigt ein Fenster mit der Auswahl der Anwendung an, in der Sie einen Link √∂ffnen m√∂chten.  In iOS ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verhalten nicht definiert</a> , was bedeutet, dass eine der beiden Anwendungen ge√∂ffnet werden kann.  In beiden F√§llen kann ein Angreifer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code oder access_token abfangen</a> . <br><br>  Im Gegensatz zum benutzerdefinierten URI-Schema wird AppLink garantiert die richtige Anwendung √∂ffnen. Dieser Mechanismus weist jedoch mehrere Nachteile auf: <br><br><ol><li>  Jeder Service-Client muss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das √úberpr√ºfungsverfahren</a> unabh√§ngig bestehen. </li><li>  Android-Benutzer k√∂nnen AppLink f√ºr eine bestimmte Anwendung in den Einstellungen deaktivieren. </li><li>  Android unter 6.0 und iOS unter 9.0 unterst√ºtzen AppLink nicht. </li></ol><br>  Die oben genannten Nachteile von AppLink erh√∂hen zum einen die Eintrittsschwelle f√ºr potenzielle Client-Dienste und zum anderen k√∂nnen sie dazu f√ºhren, dass der Benutzer unter bestimmten Umst√§nden nicht mit OAuth 2.0 arbeitet.  Dies macht AppLink ungeeignet zum Ersetzen von Browserumleitungen im OAuth 2.0-Protokoll. <br><br><h1>  Okay, was soll ich angreifen? </h1><br>  Die Probleme des mobilen OAuth 2.0 f√ºhrten auch zu spezifischen Angriffen.  Mal sehen, was sie sind und wie sie funktionieren. <br><br><a name="1"></a><h4>  Abfangangriff auf Autorisierungscode </h4><br>  Anfangsdaten: Auf dem Ger√§t des Benutzers sind eine legitime Anwendung (OAuth 2.0-Client) und eine sch√§dliche Anwendung installiert, die dasselbe Schema wie die legitime registriert haben.  Die folgende Abbildung zeigt das Angriffsschema. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Hier ist das Problem: In Schritt 4 gibt der Browser √ºber das benutzerdefinierte URI-Schema <code>code</code> an die Anwendung zur√ºck, sodass der <code>code</code> von der Malware abgefangen werden kann (da er dasselbe Schema wie die legitime Anwendung registriert hat).  Danach √§ndert die Malware den <code>code</code> in <code>access_token</code> und erh√§lt Zugriff auf Benutzerdaten. <br><br>  Wie k√∂nnen Sie sich sch√ºtzen?  In einigen F√§llen k√∂nnen Interprozess-Kommunikationsmechanismen verwendet werden, auf die wir weiter unten eingehen werden.  Im allgemeinen Fall m√ºssen Sie ein Schema namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Proof Key f√ºr Code Exchange</a> anwenden.  Sein Wesen spiegelt sich in der folgenden Abbildung wider. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  In Anforderungen vom Client gibt es mehrere zus√§tzliche Parameter: <code>code_verifier</code> , <code>code_challenge</code> (im <code>t(code_verifier)</code> ) und <code>code_challenge_method</code> (im <code>code_challenge_method</code> Diagramm). <br><br>  <code>Code_verifier</code> ist eine Zufallszahl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von mindestens 256 Bit L√§nge</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die nur einmal verwendet wird</a> .  Das hei√üt, f√ºr <b>jede</b> <code>code_verifier</code> muss <code>code</code> Client einen neuen <code>code_verifier</code> generieren. <br><br>  <code>Code_challenge_method</code> ist der Name einer Konvertierungsfunktion, meistens SHA-256. <br><br>  <code>Code_challenge</code> ist ein <code>code_verifier</code> auf den die Konvertierung von <code>code_challenge_method</code> und in der Safe Base64-URL codiert wurde. <br><br>  Die Konvertierung von <code>code_verifier</code> in <code>code_challenge</code> erforderlich, um sich vor Angriffsvektoren zu sch√ºtzen, die auf dem Abfangen von <code>code_verifier</code> (z. B. aus den Systemprotokollen des Ger√§ts) beim Anfordern von <code>code</code> basieren. <br><br>  Wenn das Ger√§t des Benutzers SHA-256 <b>nicht unterst√ºtzt</b> , ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Downgrade zul√§ssig, bis die Konvertierung von code_verifier fehlt</a> .  In allen anderen F√§llen m√ºssen Sie SHA-256 verwenden. <br><br>  Das Schema funktioniert wie folgt: <br><br><ol><li>  Der Client generiert einen <code>code_verifier</code> und merkt sich diesen. </li><li>  Der Client w√§hlt <code>code_challenge_method</code> und erh√§lt <code>code_challenge</code> von <code>code_verifier</code> . </li><li>  [Schritt A] Der Client fordert <code>code</code> , wobei der Anforderung <code>code_challenge</code> und <code>code_challenge_method</code> hinzugef√ºgt werden. </li><li>  [Schritt B] Der Anbieter merkt sich die <code>code_challenge</code> und <code>code_challenge_method</code> auf dem Server und gibt den <code>code</code> Client zur√ºck. </li><li>  [Schritt C] Der Client fordert <code>access_token</code> , wobei <code>access_token</code> zur <code>code_verifier</code> hinzugef√ºgt wird. </li><li>  Der Anbieter empf√§ngt die <code>code_challenge</code> vom eingehenden <code>code_verifier</code> und vergleicht sie dann mit der <code>code_challenge</code> , an die er sich erinnert hat. </li><li>  [Schritt D] Wenn die Werte √ºbereinstimmen, gibt der Anbieter ein <code>access_token</code> Client aus. </li></ol><br>  Mal <code>code_challenge</code> warum <code>code_challenge</code> mit <code>code_challenge</code> vor einem Code-Interception-Angriff sch√ºtzen k√∂nnen.  Zu diesem <code>access_token</code> wir die Phasen des Erhaltens von <code>access_token</code> . <br><br><ol><li>  Zun√§chst wird ein legitimer Anwendungsanforderungscode ( <code>code_challenge</code> und <code>code_challenge_method</code> zusammen mit der <b>Anforderung</b> gesendet). </li><li>  Die Malware f√§ngt <code>code</code> (aber nicht <code>code_challenge</code> , da <b>die Antwort</b> keine <code>code_challenge</code> ). </li><li>  Die Malware fordert <code>access_token</code> (mit g√ºltigem <code>code</code> , jedoch <b>ohne</b> g√ºltigen <code>code_verifier</code> ). </li><li>  Der Server bemerkt die <code>code_challenge</code> und gibt einen Fehler aus. </li></ol><br>  Beachten Sie, dass der Angreifer nicht in der Lage ist, den <code>code_verifier</code> zu erraten (zuf√§llige 256 Bit!) Oder ihn irgendwo in den Protokollen zu finden ( <code>code_verifier</code> wird einmal √ºbertragen). <br><br>  Wenn dies alles auf eine Phrase reduziert ist, kann der Dienstanbieter mit <code>code_challenge</code> die Frage beantworten: " <code>access_token</code> von derselben Clientanwendung angefordert, die <code>code</code> angefordert <code>code</code> , oder von einer anderen?". <br><br><h4>  OAuth 2.0 CSRF </h4><br>  Auf Mobilger√§ten wird OAuth 2.0 h√§ufig als Authentifizierungsmechanismus verwendet.  Wie wir uns erinnern, unterscheidet sich die Authentifizierung √ºber OAuth 2.0 von der Autorisierung darin, dass OAuth 2.0-Schwachstellen Benutzerdaten auf der Seite des Service-Clients und nicht des Service-Providers betreffen.  Infolgedessen k√∂nnen Sie mit dem CSRF-Angriff auf OAuth 2.0 das Konto eines anderen stehlen. <br><br>  Betrachten Sie einen CSRF-Angriff gegen OAuth 2.0 am Beispiel der Taxi-Client-Anwendung und des Provider.com-Providers.  Zun√§chst meldet sich ein Angreifer auf seinem Ger√§t bei attacker@provider.com an und erh√§lt einen <code>code</code> f√ºr das Taxi.  Danach unterbricht der Angreifer den OAuth 2.0-Prozess und generiert eine Verkn√ºpfung: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Dann sendet der Angreifer einen Link zum Opfer, beispielsweise unter dem Deckmantel eines Briefes oder einer SMS der Taxiverwaltung.  Das Opfer <code>access_token</code> Link, eine Taxi-Anwendung wird auf seinem Telefon ge√∂ffnet, die <code>access_token</code> empf√§ngt, und das Opfer landet auf dem <code>access_token</code> des <b>Angreifers</b> .  Das Opfer ist sich des Fangs nicht bewusst und verwendet dieses Konto: macht Reisen, gibt seine Daten ein usw. <br><br>  Jetzt kann sich ein Angreifer jederzeit in das Taxikonto des Opfers einloggen, da er an <code>attacker@provider.com</code> gebunden ist.  CSRF-Angriff auf die Anmeldung erlaubt, ein Konto zu stehlen. <br><br>  CSRF-Angriffe werden normalerweise mit einem CSRF-Token (auch als <code>state</code> ) gesch√ºtzt, und OAuth 2.0 ist keine Ausnahme.  So verwenden Sie das CSRF-Token: <br><br><ol><li>  Die Clientanwendung generiert und speichert das CSRF-Token auf dem mobilen Ger√§t des Benutzers. </li><li>  Die Clientanwendung enth√§lt das CSRF-Token in der Codeanforderung. </li><li>  Der Server gibt das gleiche CSRF-Token in der Antwort zusammen mit dem Code zur√ºck. </li><li>  Die Clientanwendung vergleicht das eingehende und das gespeicherte CSRF-Token.  Wenn die Werte √ºbereinstimmen, wird der Prozess fortgesetzt. </li></ol><br>  CSRF-Token-Anforderungen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nonce</a> mindestens 256 Bit lang, erhalten aus einer guten Quelle von Pseudozufallssequenzen. <br><br>  Kurz gesagt, mit dem CSRF-Token kann die Clientanwendung die Frage beantworten: " <code>access_token</code> ich angefangen, <code>access_token</code> zu erhalten, oder versucht mich jemand <code>access_token</code> ?" <br><br><h4>  Malware, die vorgibt, ein legitimer Client zu sein </h4><br>  Einige Malware kann legitime Anwendungen imitieren und in ihrem Namen einen Zustimmungsbildschirm ausl√∂sen (der Zustimmungsbildschirm ist ein Bildschirm, auf dem der Benutzer Folgendes sieht: "Ich bin damit einverstanden, Zugriff auf ... zu gew√§hren").  Unaufmerksame Benutzer k√∂nnen auf "Zulassen" klicken. Dadurch erh√§lt die Malware Zugriff auf Benutzerdaten. <br><br>  Android und iOS bieten Mechanismen zur gegenseitigen √úberpr√ºfung von Anwendungen.  Die Anbieteranwendung kann die Legitimit√§t der Clientanwendung √ºberpr√ºfen und umgekehrt. <br><br>  Wenn der OAuth 2.0-Mechanismus einen Stream √ºber einen Browser verwendet, k√∂nnen Sie sich leider nicht gegen diesen Angriff verteidigen. <br><br><h4>  Andere Angriffe </h4><br>  Wir haben die Angriffe untersucht, die nur f√ºr mobile OAuth 2.0 gelten.  Vergessen Sie jedoch nicht die Angriffe auf regul√§res OAuth 2.0: <code>redirect_uri</code> Spoofing, Abfangen des Datenverkehrs √ºber eine unsichere Verbindung usw.  Mehr dar√ºber k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. <br><br><h1>  Was tun? </h1><br>  Wir haben gelernt, wie das OAuth 2.0-Protokoll funktioniert, und herausgefunden, welche Schwachstellen in den Implementierungen dieses Protokolls auf Mobilger√§ten vorhanden sind.  Lassen Sie uns nun ein sicheres mobiles OAuth 2.0-Schema aus einzelnen Teilen zusammenstellen. <br><br><h4>  Gute, schlechte OAuth 2.0 </h4><br>  Beginnen wir mit dem richtigen Aufrufen des Zustimmungsbildschirms.  Auf Mobilger√§ten gibt es zwei M√∂glichkeiten, eine Webseite aus einer nativen Anwendung heraus zu √∂ffnen (Beispiele f√ºr native Anwendungen: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  Die erste Methode hei√üt Browser Custom Tab (im Bild links).  <b>Hinweis</b> : Die benutzerdefinierte Registerkarte "Browser" unter Android hei√üt "Chrome Custom Tab" und unter iOS SafariViewController.  Tats√§chlich ist dies eine normale Browser-Registerkarte, die direkt in der Anwendung angezeigt wird, d. H.  Es gibt kein visuelles Umschalten zwischen Anwendungen. <br><br>  Die zweite Methode hei√üt "Raise WebView" (im Bild rechts). In Bezug auf mobile OAuth 2.0 halte ich sie f√ºr schlecht. <br><br>  WebView ist ein eigenst√§ndiger Browser f√ºr eine native Anwendung. <br><br>  <i>Ein</i> "eigenst√§ndiger <i>Browser</i> " bedeutet, dass WebView keinen Zugriff auf Cookies, Speicher, Cache, Verlauf und andere Daten von Safari- und Chrome-Browsern zul√§sst.  Das Gegenteil ist auch der Fall: Safari und Chrome k√∂nnen nicht auf WebView-Daten zugreifen. <br><br>  " <i>Browser f√ºr eine native Anwendung</i> " bedeutet, dass die native Anwendung, die WebView ausgel√∂st hat, <b>vollen</b> Zugriff auf Cookies, Speicher, Cache, Verlauf und andere WebView-Daten hat. <br><br>  Stellen Sie sich nun vor: Der Benutzer dr√ºckt auf die Schaltfl√§che "Anmelden mit ..." und das WebView der b√∂sartigen Anwendung fragt den Dienstanbieter nach seinem Benutzernamen und Passwort. <br><br>  Fehler an allen Fronten sofort: <br><br><ol><li>  Der Benutzer gibt den Benutzernamen und das Kennwort √ºber das Konto des Dienstanbieters in der Anwendung ein, wodurch diese Daten leicht gestohlen werden k√∂nnen. </li><li>  OAuth 2.0 wurde urspr√ºnglich entwickelt <i>, um keinen Benutzernamen und kein Passwort</i> von einem Dienstanbieter <i>einzugeben</i> . </li><li>  Der Benutzer gew√∂hnt sich daran, das Login und das Passwort √ºberall einzugeben, die Wahrscheinlichkeit von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phishing</a> steigt. <br></li></ol><br>  Angesichts der Tatsache, dass alle Argumente gegen WebView sprechen, bietet sich die Schlussfolgerung an: √ñffnen Sie die Registerkarte Benutzerdefiniert f√ºr die Einwilligung des Browsers. <br><br>  Wenn einer von Ihnen Argumente f√ºr WebView anstelle von Browser Custom Tab hat, schreiben Sie dar√ºber in den Kommentaren, ich werde sehr dankbar sein. <br><br><h4>  Sicheres mobiles OAuth 2.0-Schema </h4><br>  Wir werden das Authorization Code Grant-Schema verwenden, da es uns erm√∂glicht, eine <code>code_challenge</code> hinzuzuf√ºgen und <code>code_challenge</code> vor einem Code-Interception-Angriff zu sch√ºtzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Die Codeanforderung (Schritte 1-2) sieht folgenderma√üen aus: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  In Schritt 3 erh√§lt der Browser eine umgeleitete Antwort: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  In Schritt 4 √∂ffnet der Browser das benutzerdefinierte URI-Schema und √ºbergibt den <code>code</code> und das CSRF-Token an die Clientanwendung. <br><br>  Anfrage f√ºr <code>access_token</code> (Schritt 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  Der letzte Schritt gibt eine Antwort mit <code>access_token</code> . <br><br>  Im Allgemeinen ist das obige Schema sicher, aber es gibt auch Sonderf√§lle, in denen OAuth 2.0 einfacher und ein wenig sicherer gemacht werden kann. <br><br><h4>  Android IPC </h4><br>  Android verf√ºgt √ºber einen Mechanismus f√ºr den bidirektionalen Datenaustausch zwischen Prozessen: IPC (Inter-Process Communication).  IPC wird aus zwei Gr√ºnden dem benutzerdefinierten URI-Schema vorgezogen: <br><br><ol><li>  Eine Anwendung, die einen IPC-Kanal √∂ffnet, kann die Authentizit√§t einer ge√∂ffneten Anwendung anhand ihres Zertifikats √ºberpr√ºfen.  Das Gegenteil ist auch der Fall: Eine ge√∂ffnete Anwendung kann die Authentizit√§t der Anwendung √ºberpr√ºfen, die sie ge√∂ffnet hat. </li><li>  Durch Senden einer Anfrage √ºber einen IPC-Kanal kann der Absender eine Antwort √ºber denselben Kanal empfangen.  Zusammen mit der gegenseitigen √úberpr√ºfung (Punkt 1) bedeutet dies, dass kein Prozess eines <code>access_token</code> abfangen <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Somit k√∂nnen wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">impliziten Zuschuss verwenden</a> und das mobile OAuth 2.0-Schema erheblich vereinfachen.  Keine <code>code_challenge</code> und CSRF-Token.  Dar√ºber hinaus k√∂nnen wir uns vor Malware sch√ºtzen, die legitime Kunden nachahmt, um Benutzerkonten zu stehlen. <br><br><h4>  Kunden-SDK </h4><br>  Zus√§tzlich zur Implementierung des oben beschriebenen sicheren mobilen OAuth 2.0-Schemas sollte der Anbieter ein SDK f√ºr seine Kunden entwickeln.  Dies erleichtert die Implementierung von OAuth 2.0 auf der Clientseite und reduziert gleichzeitig die Anzahl der Fehler und Schwachstellen. <br><br><h1>  Schlussfolgerungen ziehen </h1><br>  F√ºr OAuth 2.0-Anbieter habe ich die ‚ÄûSecure Mobile OAuth 2.0-Checkliste‚Äú zusammengestellt: <br><br><ol><li>  Ein solides Fundament ist entscheidend.  Im Fall von mobilem OAuth 2.0 ist die Grundlage das Schema oder Protokoll, das wir implementieren m√∂chten.  Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihr eigenes OAuth 2.0-Schema implementieren, k√∂nnen</a> Sie leicht einen Fehler machen.  Andere haben die Unebenheiten bereits aufgef√ºllt und Schlussfolgerungen gezogen. Es ist nichts Falsches daran, aus ihren Fehlern zu lernen und sofort eine sichere Implementierung vorzunehmen.  Im Allgemeinen ist das sicherste mobile OAuth 2.0-Schema das im Abschnitt "Was ist zu tun?". </li><li>  <code>Access_token</code> und andere vertrauliche Daten: unter iOS - im Schl√ºsselbund, unter Android - im internen Speicher.  Diese Repositorys wurden speziell f√ºr solche Zwecke entwickelt.  Bei Bedarf k√∂nnen Sie den Inhaltsanbieter in Android verwenden, er muss jedoch sicher konfiguriert sein. </li><li>  <code>Code</code> sollte einmalig sein und eine kurze Lebensdauer haben. </li><li>  Verwenden <code>code_challenge</code> zum Schutz vor dem Abfangen von Code <code>code_challenge</code> . </li><li>  Verwenden Sie CSRF-Token, um sich vor einem CSRF-Angriff auf die Anmeldung zu sch√ºtzen. </li><li>  Verwenden Sie WebView nicht f√ºr den Einwilligungsbildschirm, sondern verwenden Sie die benutzerdefinierte Registerkarte "Browser". </li><li>  <code>Client_secret</code> <b>nutzlos,</b> wenn es nicht im Backend gespeichert ist.  Geben Sie es nicht an √∂ffentliche Kunden weiter. </li><li>  Verwenden Sie HTTPS <b>√ºberall</b> , mit dem Verbot eines Downgrades auf HTTP. </li><li>  Befolgen Sie die Kryptografieempfehlungen (Verschl√ºsselungsauswahl, Tokenl√§nge usw.) <b>aus den Standards</b> .  Sie k√∂nnen die Daten kopieren und herausfinden, warum dies so gemacht wurde, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie k√∂nnen Ihre Kryptografie nicht durchf√ºhren</a> . </li><li>  √úberpr√ºfen Sie in der Clientanwendung, wen Sie f√ºr OAuth 2.0 √∂ffnen, und in der Anbieteranwendung, wer Sie f√ºr OAuth 2.0 √∂ffnet. </li><li>  Beachten Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºblichen OAuth 2.0-Schwachstellen</a> .  Mobile OAuth 2.0 erweitert und erg√§nzt das regul√§re OAuth 2.0, sodass niemand die √úberpr√ºfung von <code>redirect_uri</code> auf genaue √úbereinstimmungen und andere Empfehlungen f√ºr regul√§res OAuth 2.0 abgebrochen hat. </li><li>  Stellen Sie sicher, dass Sie den Kunden SDKs zur Verf√ºgung stellen.  Der Client hat weniger Fehler und Schwachstellen im Code, und es ist f√ºr ihn einfacher, OAuth 2.0 zu implementieren. </li></ol><br><h1>  Was zu lesen </h1><br><ol><li>  [RFC] OAuth 2.0 f√ºr native Apps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 f√ºr mobile und Desktop-Apps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Proof-Schl√ºssel f√ºr den Code-Austausch durch √∂ffentliche OAuth-Clients <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  OAuth 2.0 Race Condition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] √úberlegungen zum OAuth 2.0-Bedrohungsmodell und zur Sicherheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Angriffe auf regul√§res OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] OAuth 2.0 Dynamic Client Registration Protocol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Danksagung </h1><br>  Vielen Dank an alle, die diesen Artikel mitgeschrieben haben, insbesondere an Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@isciurus</a> ) und Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417031/">https://habr.com/ru/post/de417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417015/index.html">Wir verstehen, welche Aufzeichnungen die Burger King-Anwendung aufzeichnen und welche nicht</a></li>
<li><a href="../de417017/index.html">Wie ein fehlgeschlagenes Kernexperiment versehentlich die Neutrinoastronomie erzeugte</a></li>
<li><a href="../de417023/index.html">Erfahrung der Rambler Group: Wie wir damit begannen, die Bildung und das Verhalten von Front-End-React-Komponenten vollst√§ndig zu kontrollieren</a></li>
<li><a href="../de417027/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so be√§ngstigend? Einf√ºhrung</a></li>
<li><a href="../de417029/index.html">Code Profiling mit LLVM</a></li>
<li><a href="../de417033/index.html">QIWI Kitchen am 7. Juni - Video der Reden unserer Redner</a></li>
<li><a href="../de417035/index.html">UnnyWorld: Obduktion</a></li>
<li><a href="../de417037/index.html">BIERBRAZZER. Lichtsteuerung. Vixen Lights 3. Schnellstart (1/4)</a></li>
<li><a href="../de417039/index.html">Lerne WordPress (und mehr), um Youtube-Player schnell zu rendern</a></li>
<li><a href="../de417041/index.html">eslint-scope v3.7.2 stiehlt NPM-Token</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>