<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 🙆🏻 🔼 Mobile OAuth 2.0-Sicherheit 👩🏿‍✈️ 💟 🧘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Ich bin Nikita Stupin, Informationssicherheitsspezialist, Mail.Ru Mail. Vor nicht allzu langer Zeit habe ich eine Schwachstellenfors...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mobile OAuth 2.0-Sicherheit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Hallo allerseits!  Ich bin Nikita Stupin, Informationssicherheitsspezialist, Mail.Ru Mail.  Vor nicht allzu langer Zeit habe ich eine Schwachstellenforschung für mobiles OAuth 2.0 durchgeführt.  Um ein sicheres mobiles OAuth 2.0-Schema zu erstellen, reicht es nicht aus, den Standard in seiner reinen Form zu implementieren und redirect_uri zu überprüfen.  Es ist notwendig, die Besonderheiten mobiler Anwendungen zu berücksichtigen und zusätzliche Schutzmechanismen anzuwenden. <br><br>  In diesem Artikel möchte ich Ihnen Wissen über Angriffe auf mobile OAuth 2.0, über Schutzmethoden und die sichere Implementierung dieses Protokolls mitteilen.  Alle erforderlichen Schutzkomponenten, auf die ich weiter unten eingehen werde, sind im neuesten SDK für die mobilen Mail.Ru Mail-Clients implementiert. <br><a name="habracut"></a><br><h1>  Die Art und Funktion von OAuth 2.0 </h1><br>  OAuth 2.0 ist ein Autorisierungsprotokoll, das beschreibt, wie sicher ein Clientdienst auf Benutzerressourcen eines Dienstanbieters zugreifen kann.  Gleichzeitig erspart OAuth 2.0 dem Benutzer die Eingabe eines Kennworts außerhalb des Dienstanbieters: Der gesamte Vorgang wird auf das Klicken auf die Schaltfläche "Ich stimme zu, Zugriff zu gewähren ..." reduziert. <br><br>  Ein Anbieter im Sinne von OAuth 2.0 ist ein Dienst, der Benutzerdaten besitzt und mit Erlaubnis des Benutzers Diensten (Clients) von Drittanbietern einen sicheren Zugriff auf diese Daten bietet.  Ein Client ist eine Anwendung, die Benutzerdaten von einem Anbieter empfangen möchte. <br><br>  Einige Zeit nach der Veröffentlichung des OAuth 2.0-Protokolls haben gewöhnliche Entwickler es für die Authentifizierung angepasst, obwohl es ursprünglich nicht dafür vorgesehen war.  Durch die Authentifizierung wird der Angriffsvektor von Benutzerdaten, die beim Dienstanbieter gespeichert sind, auf Benutzerkonten für Benutzerdienste verschoben. <br><br>  Es war nicht nur auf die Authentifizierung beschränkt.  Im Zeitalter der mobilen Apps und der zunehmenden Konvertierung ist das Aufrufen der App mit einer einzigen Schaltfläche sehr verlockend geworden.  Die Entwickler setzen OAuth 2.0 auf mobile Schienen.  Natürlich haben nur wenige Menschen über die Sicherheit und Besonderheiten mobiler Anwendungen nachgedacht: immer wieder und in der Produktion.  OAuth 2.0 funktioniert jedoch im Allgemeinen nicht gut außerhalb von Webanwendungen: Die gleichen Probleme treten sowohl bei mobilen als auch bei Desktopanwendungen auf. <br><br>  Lassen Sie uns herausfinden, wie Sie ein sicheres mobiles OAuth 2.0 erstellen. <br><br><h1>  Wie funktioniert es </h1><br>  Denken Sie daran, dass der Client auf Mobilgeräten möglicherweise kein Browser ist, sondern eine mobile Anwendung ohne Backend.  Daher stehen wir vor zwei großen Sicherheitsproblemen für mobile OAuth 2.0: <br><br><ol><li>  Dem Client wird nicht vertraut. </li><li>  Das Verhalten einer Umleitung von einem Browser zu einer mobilen Anwendung hängt von den Einstellungen und Anwendungen ab, die der Benutzer installiert hat. </li></ol><br><h4>  Mobile Anwendung ist ein öffentlicher Client </h4><br>  Um die Wurzel des ersten Problems zu verstehen, sehen wir uns an, wie OAuth 2.0 bei Server-zu-Server-Interaktion funktioniert, und vergleichen es dann mit OAuth 2.0 bei Client-zu-Server-Interaktion. <br><br>  In beiden Fällen beginnt alles damit, dass sich der Service-Client beim Service-Provider registriert und <code>client_id</code> und in einigen Fällen <code>client_secret</code> .  Der Wert <code>client_id</code> ist öffentlich und wird im Gegensatz zu <code>client_secret</code> , dessen Wert privat ist, zur Identifizierung des <code>client_secret</code> .  Der Registrierungsprozess wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 7591</a> ausführlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben</a> . <br><br>  Das folgende Diagramm zeigt den Betrieb von OAuth 2.0 bei der Server-zu-Server-Kommunikation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Es gibt 3 Hauptstufen des OAuth 2.0-Protokolls: <br><br><ol><li>  [AC-Schritte] Holen Sie sich den Autorisierungscode (im Folgenden einfach <code>code</code> ). </li><li>  [DE-Schritte] Austauschcode für <code>access_token</code> . </li><li>  <code>access_token</code> mit <code>access_token</code> die Ressource zu. </li></ol><br>  Wir werden den Erhalt des Codes genauer analysieren: <br><br><ol><li>  [Schritt A] Der Service-Client leitet den Benutzer zum Service-Provider weiter. </li><li>  [Schritt B] Der Dienstanbieter fordert vom Benutzer die Erlaubnis an, Daten für den Clientdienst bereitzustellen (Pfeil B nach oben).  Der Benutzer bietet Zugriff auf die Daten (Pfeil B rechts). </li><li>  [Schritt C] Der Dienstanbieter gibt den <code>code</code> an den Browser des Benutzers zurück, der den <code>code</code> den Clientdienst umleitet. </li></ol><br>  <code>access_token</code> wir <code>access_token</code> genauer an: <br><br><ol><li>  [Schritt D] Der Client-Server sendet eine Anforderung für <code>access_token</code> .  Die Anfrage enthält: <code>code</code> , <code>client_secret</code> und <code>redirect_uri</code> . </li><li>  [Schritt E] Bei gültigem <code>code</code> , <code>client_secret</code> und <code>redirect_uri</code> , wird <code>client_secret</code> bereitgestellt. </li></ol><br>  Die Anforderung für <code>access_token</code> wird gemäß dem Server-zu-Server-Schema ausgeführt. Um <code>client_secret</code> zu stehlen <code>client_secret</code> muss <code>client_secret</code> Angreifer im Allgemeinen den Server-Client-Server oder den Server des Dienstanbieters hacken. <br><br>  Lassen Sie uns nun sehen, wie das OAuth 2.0-Schema auf einem mobilen Gerät ohne Backend aussieht (Client-Server-Interaktion). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Das allgemeine Schema ist in die gleichen drei Hauptschritte unterteilt: <br><br><ol><li>  [Schritte 1-4 im Bild] Holen Sie sich den <code>code</code> . </li><li>  [Schritte 5-6 im Bild] Austauschcode für <code>access_token</code> . </li><li>  <code>access_token</code> mit <code>access_token</code> die Ressource zu. </li></ol><br>  In diesem Fall fungiert die mobile Anwendung jedoch auch als Server, was bedeutet, dass <code>client_secret</code> innerhalb der Anwendung <code>client_secret</code> wird.  Dies führt dazu, dass es auf mobilen Geräten unmöglich ist, <code>lient_secret</code> vor einem Angreifer geheim zu halten.  <code>client_secret</code> gibt zwei Möglichkeiten, <code>client_secret</code> mit der Anwendung zu verbinden: Filtern des Datenverkehrs von der Anwendung zum Server oder Reverse Engineering der Anwendung.  Beide Methoden sind einfach zu implementieren, sodass <code>client_secret</code> auf Mobilgeräten unbrauchbar <code>client_secret</code> . <br><br>  In Bezug auf das Client-zu-Server-Schema haben Sie möglicherweise die Frage: "Warum nicht sofort <code>access_token</code> ?".  Es scheint, warum brauchen wir einen zusätzlichen Schritt?  Darüber hinaus gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implizites Grant-</a> Schema, bei dem der Client sofort ein <code>access_token</code> erhält.  Obwohl es in einigen Fällen verwendet werden kann, werden wir unten sehen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implicit Grant</a> nicht für sicheres mobiles OAuth 2.0 geeignet ist. <br><br><h4>  Weiterleitung auf Mobilgeräten </h4><br>  Im Allgemeinen werden für eine Umleitung von einem Browser zu einer Anwendung auf Mobilgeräten das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte URI-Schema</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppLink-</a> Mechanismen verwendet.  Keiner dieser Mechanismen in seiner reinen Form ist so zuverlässig wie eine Browserumleitung. <br><br>  Das benutzerdefinierte URI-Schema (oder Deep Link) wird wie folgt verwendet: Der Entwickler definiert das Anwendungsschema vor dem Zusammenbau.  Das Schema kann beliebig sein, während auf demselben Gerät mehrere Anwendungen mit demselben Schema installiert werden können.  Alles ist ganz einfach, wenn jede Anwendung auf dem Gerät einer Anwendung entspricht.  Was aber, wenn zwei Anwendungen dieselbe Schaltung auf demselben Gerät registriert haben?  Wie kann das Betriebssystem bestimmen, welche der beiden Anwendungen beim Zugriff auf das benutzerdefinierte URI-Schema geöffnet werden soll?  Android zeigt ein Fenster mit der Auswahl der Anwendung an, in der Sie einen Link öffnen möchten.  In iOS ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verhalten nicht definiert</a> , was bedeutet, dass eine der beiden Anwendungen geöffnet werden kann.  In beiden Fällen kann ein Angreifer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code oder access_token abfangen</a> . <br><br>  Im Gegensatz zum benutzerdefinierten URI-Schema wird AppLink garantiert die richtige Anwendung öffnen. Dieser Mechanismus weist jedoch mehrere Nachteile auf: <br><br><ol><li>  Jeder Service-Client muss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Überprüfungsverfahren</a> unabhängig bestehen. </li><li>  Android-Benutzer können AppLink für eine bestimmte Anwendung in den Einstellungen deaktivieren. </li><li>  Android unter 6.0 und iOS unter 9.0 unterstützen AppLink nicht. </li></ol><br>  Die oben genannten Nachteile von AppLink erhöhen zum einen die Eintrittsschwelle für potenzielle Client-Dienste und zum anderen können sie dazu führen, dass der Benutzer unter bestimmten Umständen nicht mit OAuth 2.0 arbeitet.  Dies macht AppLink ungeeignet zum Ersetzen von Browserumleitungen im OAuth 2.0-Protokoll. <br><br><h1>  Okay, was soll ich angreifen? </h1><br>  Die Probleme des mobilen OAuth 2.0 führten auch zu spezifischen Angriffen.  Mal sehen, was sie sind und wie sie funktionieren. <br><br><a name="1"></a><h4>  Abfangangriff auf Autorisierungscode </h4><br>  Anfangsdaten: Auf dem Gerät des Benutzers sind eine legitime Anwendung (OAuth 2.0-Client) und eine schädliche Anwendung installiert, die dasselbe Schema wie die legitime registriert haben.  Die folgende Abbildung zeigt das Angriffsschema. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Hier ist das Problem: In Schritt 4 gibt der Browser über das benutzerdefinierte URI-Schema <code>code</code> an die Anwendung zurück, sodass der <code>code</code> von der Malware abgefangen werden kann (da er dasselbe Schema wie die legitime Anwendung registriert hat).  Danach ändert die Malware den <code>code</code> in <code>access_token</code> und erhält Zugriff auf Benutzerdaten. <br><br>  Wie können Sie sich schützen?  In einigen Fällen können Interprozess-Kommunikationsmechanismen verwendet werden, auf die wir weiter unten eingehen werden.  Im allgemeinen Fall müssen Sie ein Schema namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Proof Key für Code Exchange</a> anwenden.  Sein Wesen spiegelt sich in der folgenden Abbildung wider. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  In Anforderungen vom Client gibt es mehrere zusätzliche Parameter: <code>code_verifier</code> , <code>code_challenge</code> (im <code>t(code_verifier)</code> ) und <code>code_challenge_method</code> (im <code>code_challenge_method</code> Diagramm). <br><br>  <code>Code_verifier</code> ist eine Zufallszahl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von mindestens 256 Bit Länge</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die nur einmal verwendet wird</a> .  Das heißt, für <b>jede</b> <code>code_verifier</code> muss <code>code</code> Client einen neuen <code>code_verifier</code> generieren. <br><br>  <code>Code_challenge_method</code> ist der Name einer Konvertierungsfunktion, meistens SHA-256. <br><br>  <code>Code_challenge</code> ist ein <code>code_verifier</code> auf den die Konvertierung von <code>code_challenge_method</code> und in der Safe Base64-URL codiert wurde. <br><br>  Die Konvertierung von <code>code_verifier</code> in <code>code_challenge</code> erforderlich, um sich vor Angriffsvektoren zu schützen, die auf dem Abfangen von <code>code_verifier</code> (z. B. aus den Systemprotokollen des Geräts) beim Anfordern von <code>code</code> basieren. <br><br>  Wenn das Gerät des Benutzers SHA-256 <b>nicht unterstützt</b> , ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Downgrade zulässig, bis die Konvertierung von code_verifier fehlt</a> .  In allen anderen Fällen müssen Sie SHA-256 verwenden. <br><br>  Das Schema funktioniert wie folgt: <br><br><ol><li>  Der Client generiert einen <code>code_verifier</code> und merkt sich diesen. </li><li>  Der Client wählt <code>code_challenge_method</code> und erhält <code>code_challenge</code> von <code>code_verifier</code> . </li><li>  [Schritt A] Der Client fordert <code>code</code> , wobei der Anforderung <code>code_challenge</code> und <code>code_challenge_method</code> hinzugefügt werden. </li><li>  [Schritt B] Der Anbieter merkt sich die <code>code_challenge</code> und <code>code_challenge_method</code> auf dem Server und gibt den <code>code</code> Client zurück. </li><li>  [Schritt C] Der Client fordert <code>access_token</code> , wobei <code>access_token</code> zur <code>code_verifier</code> hinzugefügt wird. </li><li>  Der Anbieter empfängt die <code>code_challenge</code> vom eingehenden <code>code_verifier</code> und vergleicht sie dann mit der <code>code_challenge</code> , an die er sich erinnert hat. </li><li>  [Schritt D] Wenn die Werte übereinstimmen, gibt der Anbieter ein <code>access_token</code> Client aus. </li></ol><br>  Mal <code>code_challenge</code> warum <code>code_challenge</code> mit <code>code_challenge</code> vor einem Code-Interception-Angriff schützen können.  Zu diesem <code>access_token</code> wir die Phasen des Erhaltens von <code>access_token</code> . <br><br><ol><li>  Zunächst wird ein legitimer Anwendungsanforderungscode ( <code>code_challenge</code> und <code>code_challenge_method</code> zusammen mit der <b>Anforderung</b> gesendet). </li><li>  Die Malware fängt <code>code</code> (aber nicht <code>code_challenge</code> , da <b>die Antwort</b> keine <code>code_challenge</code> ). </li><li>  Die Malware fordert <code>access_token</code> (mit gültigem <code>code</code> , jedoch <b>ohne</b> gültigen <code>code_verifier</code> ). </li><li>  Der Server bemerkt die <code>code_challenge</code> und gibt einen Fehler aus. </li></ol><br>  Beachten Sie, dass der Angreifer nicht in der Lage ist, den <code>code_verifier</code> zu erraten (zufällige 256 Bit!) Oder ihn irgendwo in den Protokollen zu finden ( <code>code_verifier</code> wird einmal übertragen). <br><br>  Wenn dies alles auf eine Phrase reduziert ist, kann der Dienstanbieter mit <code>code_challenge</code> die Frage beantworten: " <code>access_token</code> von derselben Clientanwendung angefordert, die <code>code</code> angefordert <code>code</code> , oder von einer anderen?". <br><br><h4>  OAuth 2.0 CSRF </h4><br>  Auf Mobilgeräten wird OAuth 2.0 häufig als Authentifizierungsmechanismus verwendet.  Wie wir uns erinnern, unterscheidet sich die Authentifizierung über OAuth 2.0 von der Autorisierung darin, dass OAuth 2.0-Schwachstellen Benutzerdaten auf der Seite des Service-Clients und nicht des Service-Providers betreffen.  Infolgedessen können Sie mit dem CSRF-Angriff auf OAuth 2.0 das Konto eines anderen stehlen. <br><br>  Betrachten Sie einen CSRF-Angriff gegen OAuth 2.0 am Beispiel der Taxi-Client-Anwendung und des Provider.com-Providers.  Zunächst meldet sich ein Angreifer auf seinem Gerät bei attacker@provider.com an und erhält einen <code>code</code> für das Taxi.  Danach unterbricht der Angreifer den OAuth 2.0-Prozess und generiert eine Verknüpfung: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Dann sendet der Angreifer einen Link zum Opfer, beispielsweise unter dem Deckmantel eines Briefes oder einer SMS der Taxiverwaltung.  Das Opfer <code>access_token</code> Link, eine Taxi-Anwendung wird auf seinem Telefon geöffnet, die <code>access_token</code> empfängt, und das Opfer landet auf dem <code>access_token</code> des <b>Angreifers</b> .  Das Opfer ist sich des Fangs nicht bewusst und verwendet dieses Konto: macht Reisen, gibt seine Daten ein usw. <br><br>  Jetzt kann sich ein Angreifer jederzeit in das Taxikonto des Opfers einloggen, da er an <code>attacker@provider.com</code> gebunden ist.  CSRF-Angriff auf die Anmeldung erlaubt, ein Konto zu stehlen. <br><br>  CSRF-Angriffe werden normalerweise mit einem CSRF-Token (auch als <code>state</code> ) geschützt, und OAuth 2.0 ist keine Ausnahme.  So verwenden Sie das CSRF-Token: <br><br><ol><li>  Die Clientanwendung generiert und speichert das CSRF-Token auf dem mobilen Gerät des Benutzers. </li><li>  Die Clientanwendung enthält das CSRF-Token in der Codeanforderung. </li><li>  Der Server gibt das gleiche CSRF-Token in der Antwort zusammen mit dem Code zurück. </li><li>  Die Clientanwendung vergleicht das eingehende und das gespeicherte CSRF-Token.  Wenn die Werte übereinstimmen, wird der Prozess fortgesetzt. </li></ol><br>  CSRF-Token-Anforderungen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nonce</a> mindestens 256 Bit lang, erhalten aus einer guten Quelle von Pseudozufallssequenzen. <br><br>  Kurz gesagt, mit dem CSRF-Token kann die Clientanwendung die Frage beantworten: " <code>access_token</code> ich angefangen, <code>access_token</code> zu erhalten, oder versucht mich jemand <code>access_token</code> ?" <br><br><h4>  Malware, die vorgibt, ein legitimer Client zu sein </h4><br>  Einige Malware kann legitime Anwendungen imitieren und in ihrem Namen einen Zustimmungsbildschirm auslösen (der Zustimmungsbildschirm ist ein Bildschirm, auf dem der Benutzer Folgendes sieht: "Ich bin damit einverstanden, Zugriff auf ... zu gewähren").  Unaufmerksame Benutzer können auf "Zulassen" klicken. Dadurch erhält die Malware Zugriff auf Benutzerdaten. <br><br>  Android und iOS bieten Mechanismen zur gegenseitigen Überprüfung von Anwendungen.  Die Anbieteranwendung kann die Legitimität der Clientanwendung überprüfen und umgekehrt. <br><br>  Wenn der OAuth 2.0-Mechanismus einen Stream über einen Browser verwendet, können Sie sich leider nicht gegen diesen Angriff verteidigen. <br><br><h4>  Andere Angriffe </h4><br>  Wir haben die Angriffe untersucht, die nur für mobile OAuth 2.0 gelten.  Vergessen Sie jedoch nicht die Angriffe auf reguläres OAuth 2.0: <code>redirect_uri</code> Spoofing, Abfangen des Datenverkehrs über eine unsichere Verbindung usw.  Mehr darüber können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. <br><br><h1>  Was tun? </h1><br>  Wir haben gelernt, wie das OAuth 2.0-Protokoll funktioniert, und herausgefunden, welche Schwachstellen in den Implementierungen dieses Protokolls auf Mobilgeräten vorhanden sind.  Lassen Sie uns nun ein sicheres mobiles OAuth 2.0-Schema aus einzelnen Teilen zusammenstellen. <br><br><h4>  Gute, schlechte OAuth 2.0 </h4><br>  Beginnen wir mit dem richtigen Aufrufen des Zustimmungsbildschirms.  Auf Mobilgeräten gibt es zwei Möglichkeiten, eine Webseite aus einer nativen Anwendung heraus zu öffnen (Beispiele für native Anwendungen: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  Die erste Methode heißt Browser Custom Tab (im Bild links).  <b>Hinweis</b> : Die benutzerdefinierte Registerkarte "Browser" unter Android heißt "Chrome Custom Tab" und unter iOS SafariViewController.  Tatsächlich ist dies eine normale Browser-Registerkarte, die direkt in der Anwendung angezeigt wird, d. H.  Es gibt kein visuelles Umschalten zwischen Anwendungen. <br><br>  Die zweite Methode heißt "Raise WebView" (im Bild rechts). In Bezug auf mobile OAuth 2.0 halte ich sie für schlecht. <br><br>  WebView ist ein eigenständiger Browser für eine native Anwendung. <br><br>  <i>Ein</i> "eigenständiger <i>Browser</i> " bedeutet, dass WebView keinen Zugriff auf Cookies, Speicher, Cache, Verlauf und andere Daten von Safari- und Chrome-Browsern zulässt.  Das Gegenteil ist auch der Fall: Safari und Chrome können nicht auf WebView-Daten zugreifen. <br><br>  " <i>Browser für eine native Anwendung</i> " bedeutet, dass die native Anwendung, die WebView ausgelöst hat, <b>vollen</b> Zugriff auf Cookies, Speicher, Cache, Verlauf und andere WebView-Daten hat. <br><br>  Stellen Sie sich nun vor: Der Benutzer drückt auf die Schaltfläche "Anmelden mit ..." und das WebView der bösartigen Anwendung fragt den Dienstanbieter nach seinem Benutzernamen und Passwort. <br><br>  Fehler an allen Fronten sofort: <br><br><ol><li>  Der Benutzer gibt den Benutzernamen und das Kennwort über das Konto des Dienstanbieters in der Anwendung ein, wodurch diese Daten leicht gestohlen werden können. </li><li>  OAuth 2.0 wurde ursprünglich entwickelt <i>, um keinen Benutzernamen und kein Passwort</i> von einem Dienstanbieter <i>einzugeben</i> . </li><li>  Der Benutzer gewöhnt sich daran, das Login und das Passwort überall einzugeben, die Wahrscheinlichkeit von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phishing</a> steigt. <br></li></ol><br>  Angesichts der Tatsache, dass alle Argumente gegen WebView sprechen, bietet sich die Schlussfolgerung an: Öffnen Sie die Registerkarte Benutzerdefiniert für die Einwilligung des Browsers. <br><br>  Wenn einer von Ihnen Argumente für WebView anstelle von Browser Custom Tab hat, schreiben Sie darüber in den Kommentaren, ich werde sehr dankbar sein. <br><br><h4>  Sicheres mobiles OAuth 2.0-Schema </h4><br>  Wir werden das Authorization Code Grant-Schema verwenden, da es uns ermöglicht, eine <code>code_challenge</code> hinzuzufügen und <code>code_challenge</code> vor einem Code-Interception-Angriff zu schützen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Die Codeanforderung (Schritte 1-2) sieht folgendermaßen aus: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  In Schritt 3 erhält der Browser eine umgeleitete Antwort: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  In Schritt 4 öffnet der Browser das benutzerdefinierte URI-Schema und übergibt den <code>code</code> und das CSRF-Token an die Clientanwendung. <br><br>  Anfrage für <code>access_token</code> (Schritt 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  Der letzte Schritt gibt eine Antwort mit <code>access_token</code> . <br><br>  Im Allgemeinen ist das obige Schema sicher, aber es gibt auch Sonderfälle, in denen OAuth 2.0 einfacher und ein wenig sicherer gemacht werden kann. <br><br><h4>  Android IPC </h4><br>  Android verfügt über einen Mechanismus für den bidirektionalen Datenaustausch zwischen Prozessen: IPC (Inter-Process Communication).  IPC wird aus zwei Gründen dem benutzerdefinierten URI-Schema vorgezogen: <br><br><ol><li>  Eine Anwendung, die einen IPC-Kanal öffnet, kann die Authentizität einer geöffneten Anwendung anhand ihres Zertifikats überprüfen.  Das Gegenteil ist auch der Fall: Eine geöffnete Anwendung kann die Authentizität der Anwendung überprüfen, die sie geöffnet hat. </li><li>  Durch Senden einer Anfrage über einen IPC-Kanal kann der Absender eine Antwort über denselben Kanal empfangen.  Zusammen mit der gegenseitigen Überprüfung (Punkt 1) bedeutet dies, dass kein Prozess eines <code>access_token</code> abfangen <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Somit können wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">impliziten Zuschuss verwenden</a> und das mobile OAuth 2.0-Schema erheblich vereinfachen.  Keine <code>code_challenge</code> und CSRF-Token.  Darüber hinaus können wir uns vor Malware schützen, die legitime Kunden nachahmt, um Benutzerkonten zu stehlen. <br><br><h4>  Kunden-SDK </h4><br>  Zusätzlich zur Implementierung des oben beschriebenen sicheren mobilen OAuth 2.0-Schemas sollte der Anbieter ein SDK für seine Kunden entwickeln.  Dies erleichtert die Implementierung von OAuth 2.0 auf der Clientseite und reduziert gleichzeitig die Anzahl der Fehler und Schwachstellen. <br><br><h1>  Schlussfolgerungen ziehen </h1><br>  Für OAuth 2.0-Anbieter habe ich die „Secure Mobile OAuth 2.0-Checkliste“ zusammengestellt: <br><br><ol><li>  Ein solides Fundament ist entscheidend.  Im Fall von mobilem OAuth 2.0 ist die Grundlage das Schema oder Protokoll, das wir implementieren möchten.  Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihr eigenes OAuth 2.0-Schema implementieren, können</a> Sie leicht einen Fehler machen.  Andere haben die Unebenheiten bereits aufgefüllt und Schlussfolgerungen gezogen. Es ist nichts Falsches daran, aus ihren Fehlern zu lernen und sofort eine sichere Implementierung vorzunehmen.  Im Allgemeinen ist das sicherste mobile OAuth 2.0-Schema das im Abschnitt "Was ist zu tun?". </li><li>  <code>Access_token</code> und andere vertrauliche Daten: unter iOS - im Schlüsselbund, unter Android - im internen Speicher.  Diese Repositorys wurden speziell für solche Zwecke entwickelt.  Bei Bedarf können Sie den Inhaltsanbieter in Android verwenden, er muss jedoch sicher konfiguriert sein. </li><li>  <code>Code</code> sollte einmalig sein und eine kurze Lebensdauer haben. </li><li>  Verwenden <code>code_challenge</code> zum Schutz vor dem Abfangen von Code <code>code_challenge</code> . </li><li>  Verwenden Sie CSRF-Token, um sich vor einem CSRF-Angriff auf die Anmeldung zu schützen. </li><li>  Verwenden Sie WebView nicht für den Einwilligungsbildschirm, sondern verwenden Sie die benutzerdefinierte Registerkarte "Browser". </li><li>  <code>Client_secret</code> <b>nutzlos,</b> wenn es nicht im Backend gespeichert ist.  Geben Sie es nicht an öffentliche Kunden weiter. </li><li>  Verwenden Sie HTTPS <b>überall</b> , mit dem Verbot eines Downgrades auf HTTP. </li><li>  Befolgen Sie die Kryptografieempfehlungen (Verschlüsselungsauswahl, Tokenlänge usw.) <b>aus den Standards</b> .  Sie können die Daten kopieren und herausfinden, warum dies so gemacht wurde, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie können Ihre Kryptografie nicht durchführen</a> . </li><li>  Überprüfen Sie in der Clientanwendung, wen Sie für OAuth 2.0 öffnen, und in der Anbieteranwendung, wer Sie für OAuth 2.0 öffnet. </li><li>  Beachten Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">üblichen OAuth 2.0-Schwachstellen</a> .  Mobile OAuth 2.0 erweitert und ergänzt das reguläre OAuth 2.0, sodass niemand die Überprüfung von <code>redirect_uri</code> auf genaue Übereinstimmungen und andere Empfehlungen für reguläres OAuth 2.0 abgebrochen hat. </li><li>  Stellen Sie sicher, dass Sie den Kunden SDKs zur Verfügung stellen.  Der Client hat weniger Fehler und Schwachstellen im Code, und es ist für ihn einfacher, OAuth 2.0 zu implementieren. </li></ol><br><h1>  Was zu lesen </h1><br><ol><li>  [RFC] OAuth 2.0 für native Apps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 für mobile und Desktop-Apps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Proof-Schlüssel für den Code-Austausch durch öffentliche OAuth-Clients <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  OAuth 2.0 Race Condition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] Überlegungen zum OAuth 2.0-Bedrohungsmodell und zur Sicherheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Angriffe auf reguläres OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] OAuth 2.0 Dynamic Client Registration Protocol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Danksagung </h1><br>  Vielen Dank an alle, die diesen Artikel mitgeschrieben haben, insbesondere an Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@isciurus</a> ) und Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417031/">https://habr.com/ru/post/de417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417015/index.html">Wir verstehen, welche Aufzeichnungen die Burger King-Anwendung aufzeichnen und welche nicht</a></li>
<li><a href="../de417017/index.html">Wie ein fehlgeschlagenes Kernexperiment versehentlich die Neutrinoastronomie erzeugte</a></li>
<li><a href="../de417023/index.html">Erfahrung der Rambler Group: Wie wir damit begannen, die Bildung und das Verhalten von Front-End-React-Komponenten vollständig zu kontrollieren</a></li>
<li><a href="../de417027/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Einführung</a></li>
<li><a href="../de417029/index.html">Code Profiling mit LLVM</a></li>
<li><a href="../de417033/index.html">QIWI Kitchen am 7. Juni - Video der Reden unserer Redner</a></li>
<li><a href="../de417035/index.html">UnnyWorld: Obduktion</a></li>
<li><a href="../de417037/index.html">BIERBRAZZER. Lichtsteuerung. Vixen Lights 3. Schnellstart (1/4)</a></li>
<li><a href="../de417039/index.html">Lerne WordPress (und mehr), um Youtube-Player schnell zu rendern</a></li>
<li><a href="../de417041/index.html">eslint-scope v3.7.2 stiehlt NPM-Token</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>