<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìï üîñ üêü Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen üß¢ üßñüèæ üç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist das Ergebnis der √úberpr√ºfung des Avalonia-UI-Projekts mit dem statischen Analyseger√§t PVS-Studio. Die Avalonia-Benutzeroberfl√§che i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481598/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/9b1/06a/e349b106a7c1d3ea775353520b20cd91.png" alt="Abbildung 2"></div><br>  Dieser Artikel ist das Ergebnis der √úberpr√ºfung des Avalonia-UI-Projekts mit dem statischen Analyseger√§t PVS-Studio.  Die Avalonia-Benutzeroberfl√§che ist eine plattform√ºbergreifende XAML-basierte Open-Source-Benutzeroberfl√§chenplattform.  Dies ist eines der technologisch bedeutenden Projekte in der Geschichte von .NET, da Sie plattform√ºbergreifende Schnittstellen auf der Basis des WPF-Systems erstellen k√∂nnen.  Ich hoffe, dass dieser Artikel den Autoren hilft, einige Fehler zu korrigieren und sie davon zu √ºberzeugen, in Zukunft statische Analyseger√§te zu verwenden. <br><a name="habracut"></a><br><h2>  √úber Avalonia UI </h2><br>  Das Avalonia-UI-Projekt (fr√ºher Perspex genannt) bietet die M√∂glichkeit, Benutzeroberfl√§chen f√ºr Windows, Linux und MacOS zu erstellen.  Momentan gibt es auch experimentelle Unterst√ºtzung f√ºr Android und iOS.  Die Avalonia-Benutzeroberfl√§che ist kein Wrapper √ºber Wrappern, sondern bezieht sich auf die native API.  Im Gegensatz zu Xamarin Forms, das Xamarin-Wrapper umh√ºllt.  In einem der Demo-Videos war ich beeindruckt von der M√∂glichkeit, die Steuerung der Debian-Konsole zu √ºbernehmen.  Dar√ºber hinaus bietet das Projekt dank der Verwendung von XAML-Markup mehr Funktionen f√ºr Layout und Design als herk√∂mmliche Schnittstellendesigner. <br><br>  Zu den Projekten, die Avalonia UI bereits verwenden, geh√∂ren <a href="https://github.com/VitalElement/AvalonStudio">AvalonStudio</a> (eine plattform√ºbergreifende IDE f√ºr die Entwicklung in C # und C / C ++) und <a href="https://github.com/wieslawsoltes/Core2D">Core2D</a> (Editor f√ºr 2D-Diagramme und Diagramme).  Als kommerzielles Projekt k√∂nnen Sie <a href="https://wasabiwallet.io/">Wasabi Wallet</a> (Bitcoin Wallet) mitbringen. <br><br>  Der Kampf gegen die Notwendigkeit, mehrere verschiedene Bibliotheken f√ºr die Erstellung einer plattform√ºbergreifenden Anwendung zu haben, ist von gro√üer Bedeutung.  Wir wollten dem Projekt helfen, und ich lud das Projekt herunter und √ºberpr√ºfte es mit unserem Analyseger√§t.  Ich hoffe, dass die Autoren diesem Artikel Aufmerksamkeit schenken und die notwendigen √Ñnderungen am Code vornehmen oder m√∂glicherweise regelm√§√üige statische Analysen in den Entwicklungsprozess einf√ºhren.  Dazu k√∂nnen sie die kostenlose Lizenzierungsoption von PVS-Studio f√ºr Open Source-Projekte nutzen.  Die regelm√§√üige Verwendung eines statischen Analyseger√§ts hilft, viele Probleme zu vermeiden und die Kosten f√ºr die Erkennung und Behebung vieler Fehler zu senken. <br><br><h2>  Validierungsergebnisse </h2><br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3001/">V3001</a> Links und rechts vom Operator '^' befinden sich identische Unterausdr√ºcke 'controlledFlags'.  WindowImpl.cs 975TwitterClientMessageHandler.cs 52 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> style = (WindowStyles)GetWindowLong(....); .... style = style | controlledFlags ^ controlledFlags; .... }</code> </pre> <br>  Ich werde symbolisch mit unserer ersten C # -Diagnose beginnen.  Der Analysator hat eine merkw√ºrdige Verwendung des bitweisen ODER-Operators festgestellt.  Lassen Sie mich anhand der Zahlen erkl√§ren, was hier passiert: <br><br>  Ausdruck <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> ^ <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  √§hnlich wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  Ein exklusives ODER ("^") hat eine h√∂here Priorit√§t als ein bitweises ODER ("|").  H√∂chstwahrscheinlich wurde hier eine andere Reihenfolge der Operationen impliziert.  In diesem Fall sollten Sie den ersten Ausdruck in Klammern setzen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... style = (style | controlledFlags) ^ controlledFlags; .... }</code> </pre> <br>  Vor den n√§chsten beiden Warnungen muss ich zugeben: die Fehlalarme.  Dies liegt an der Verwendung der √∂ffentlichen API, der <i>TransformToVisual-</i> Methode.  In unserem Fall ist <i>VisualRoot</i> immer das √ºbergeordnete <i>Element</i> von <i>Visual</i> .  Ich habe dies bei der Analyse der Antwort nicht verstanden, teilte mir der Autor des Projekts nach dem Schreiben des Artikels mit.  Die im Artikel vorgeschlagenen √Ñnderungen dienen also nicht dem Schutz vor einem tats√§chlichen Sturz, sondern vor einer m√∂glichen √úberarbeitung, die diese Logik verletzt. <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: TranslatePoint (...).  VisualExtensions.cs 23 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; }</code> </pre> <br>  Eine kleine Methode.  Der Analyzer ist der Ansicht, dass die Dereferenzierung des Ergebnisses eines Aufrufs von TranslatePoint unsicher ist.  Schauen Sie sich diese Methode an: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Point? TranslatePoint(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual visual, Point point, IVisual relativeTo) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = visual.TransformToVisual(relativeTo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.HasValue) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> point.Transform(transform.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  In der Tat gibt es eine R√ºckkehr <i>null</i> . <br><br>  Diese Methode hat 6 Aufrufe.  In drei F√§llen wird der Wert √ºberpr√ºft und im √úbrigen erkennt PVS-Studio m√∂gliche Dereferenzierungen und gibt Warnungen aus.  Ich habe das erste oben zitiert und die anderen beiden Warnungen sind hier: <br><br><ul><li>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Sehen Sie sich 'p' an.  VisualExtensions.cs 35 </li><li>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die Inspektion von 'controlPoint'.  Scene.cs 176 </li></ul><br>  Ich schlage vor, es analog zu <i>beheben</i> , indem ich die <i>Nullable &lt;Struct&gt; .HasValue-</i> Pr√ºfung in der <i>PointToClient-</i> Methode <i>hinzuf√ºge</i> <i>:</i> <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rootPoint.HasValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: TransformToVisual (...).  ViewportManager.cs 381 <br><br>  Ein Fall, der dem vorherigen Beispiel sehr √§hnlich ist: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEffectiveViewportChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransformedBounds? bounds</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = _owner.GetVisualRoot().TransformToVisual(_owner).Value; .... }</code> </pre> <br>  Die <i>TransformToVisual-</i> Methode sieht folgenderma√üen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Matrix? TransformToVisual(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, IVisual to) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> common = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.FindCommonVisualAncestor(to); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (common != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  √úbrigens kann die <i>FindCommonVisualAncestor-</i> Methode tats√§chlich <i>null</i> als Standardwert f√ºr Referenztypen zur√ºckgeben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IVisual </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCommonVisualAncestor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, IVisual target</span></span></span><span class="hljs-function">)</span></span> { Contract.Requires&lt;ArgumentNullException&gt;(visual != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ....FirstOrDefault(); }</code> </pre> <br>  Die <i>TransformToVisual-</i> Methode wird an neun Stellen verwendet, an sieben Stellen werden Pr√ºfungen durchgef√ºhrt.  Die erste Warnung, die ohne √úberpr√ºfung verwendet werden muss, ist h√∂her und die letzte ist hier: <br><br>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung von "Transformation".  MouseDevice.cs 80 <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3022/">V3022</a> Ausdruck ist immer wahr.  Wahrscheinlich sollte hier der Operator '&amp;&amp;' verwendet werden.  NavigationDirection.cs 89 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDirectional</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NavigationDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt; NavigationDirection.Previous || direction &lt;= NavigationDirection.PageDown; }</code> </pre> <br>  Seltsame Pr√ºfung.  In der <i>NavigationDirection-</i> Enumeration gibt es 9 Typen, und <i>PageDown</i> ist der letzte von ihnen.  Vielleicht war dies nicht immer der Fall, oder es handelt sich um eine Versicherung gegen das pl√∂tzliche Auftreten neuer √úberweisungsoptionen.  Es scheint mir, dass der erste Scheck hier ausreicht.  Die Entscheidung √ºberlasse ich den Autoren des Projekts. <br><br>  <b>Warnung PVS-Studio:</b> <a href="https://www.viva64.com/ru/w/v3066/">V3066</a> M√∂gliche falsche Reihenfolge der an den Konstruktor 'SelectionChangedEventArgs' √ºbergebenen Argumente: 'removedSelectedItems' und 'addedSelectedItems'.  DataGridSelectedItemsCollection.cs 338 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> SelectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs (DataGrid.SelectionChangedEvent, removedSelectedItems, addedSelectedItems) { Source = OwningGrid }; }</code> </pre> <br>  In diesem Fall schlug der Analysator vor, das zweite und dritte Argument des Konstruktors zu verwechseln.  Schauen wir uns den aufgerufenen Konstruktor an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RoutedEvent routedEvent, IList addedItems, IList removedItems</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">routedEvent</span></span></span><span class="hljs-function">)</span></span> { AddedItems = addedItems; RemovedItems = removedItems; }</code> </pre> <br>  Es werden zwei Beh√§lter vom Typ <i>IList</i> akzeptiert, die leicht zu mischen sind.  Nach dem Kommentar zu Beginn der Klasse zu urteilen, handelt es sich um einen Fehler im Kontrollcode, der von Microsoft kopiert und unter Avalonia ge√§ndert wurde.  Aber es scheint mir, dass es sich lohnt, die Reihenfolge der Argumente der Methode zu korrigieren, zumindest nicht nach einem m√∂glichen Fehler in sich selbst zu suchen, wenn ein Fehlerbericht kommt. <br><br>  Der Analysator hat drei weitere √§hnliche Fehler gefunden: <br><br>  <b>Warnung PVS-Studio:</b> <a href="https://www.viva64.com/ru/w/v3066/">V3066</a> M√∂gliche falsche Reihenfolge der Argumente, die an den Konstruktor 'SelectionChangedEventArgs' √ºbergeben wurden: 'removed' und 'added'.  AutoCompleteBox.cs 707 <br><br><pre> <code class="cs hljs">OnSelectionChanged(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs(SelectionChangedEvent, removed, added));</code> </pre> <br>  Selber Konstruktor <i>SelectionChangedEventArgs.</i> <br><br>  <b>PVS-Studio</b> <a href="https://www.viva64.com/ru/w/v3066/">V3066 Warnungen</a> : <br><br><ul><li>  M√∂gliche falsche Reihenfolge der an den Konstruktor 'ItemsRepeaterElementIndexChangedEventArgs' √ºbergebenen Argumente: 'oldIndex' und 'newIndex'.  ItemsRepeater.cs 532 </li><li>  M√∂gliche falsche Reihenfolge der an die 'Update'-Methode √ºbergebenen Argumente:' oldIndex 'und' newIndex '.  ItemsRepeater.cs 536 </li></ul><br>  Zwei Operationen in einer Methode eines Ereignisaufrufs. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnElementIndexChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ElementIndexChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elementIndexChangedArgs == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _elementIndexChangedArgs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ItemsRepeaterElementIndexChangedEventArgs(element, oldIndex, newIndex); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elementIndexChangedArgs.Update(element, oldIndex, newIndex); } ..... } }</code> </pre> <br>  Der Analysator hat <i>festgestellt,</i> dass <i>sowohl in ItemsRepeaterElementIndexChangedEventArgs</i> als auch in der <i>Update-</i> Methode die Argumente <i>oldIndex</i> und <i>newIndex</i> eine unterschiedliche Reihenfolge haben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItemsRepeaterElementIndexChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; }</code> </pre> <br>  Vielleicht wurde der Code von verschiedenen Programmierern geschrieben, und f√ºr einen ist es wichtiger, was passiert ist, und f√ºr den anderen - was wird passieren :) <br><br>  Wie im vorherigen Fall sollten Sie es nicht sofort bearbeiten, sondern pr√ºfen, ob wirklich ein Fehler vorliegt. <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3004/">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  DataGridSortDescription.cs 235 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  Eine √§u√üerst interessante Implementierung der <i>ThenBy-</i> Methode.  Die <i>IEnumerable-</i> Schnittstelle, von der das <i>seq-</i> Argument geerbt wird <i>,</i> verf√ºgt √ºber eine <i>ThenBy-</i> Methode.  Ich nehme an, dass seine Verwendung impliziert wurde.  So: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenBy(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  <b>Warnung PVS-Studio:</b> <a href="https://www.viva64.com/ru/w/v3106/">V3106</a> M√∂glicher negativer Indexwert.  Der Wert von 'index' index k√∂nnte -1 erreichen.  Animator.cs 68 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolationHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animationTime, T neutralValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kvCount &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = FindClosestBeforeKeyFrame(animationTime); firstKeyframe = _convertedKeyframes[index]; } .... } .... }</code> </pre> <br>  Der Analysator geht davon aus, dass der <i>Index</i> einen Wert von -1 haben kann.  Die Variable wird von der <i>FindClosestBeforeKeyFrame-</i> Methode abgerufen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  Wie wir sehen k√∂nnen, wird die Bedingung in der Schleife √ºberpr√ºft und der vorherige Wert des Iterators wird zur√ºckgegeben.  Der Zustand ist ziemlich schwer zu √ºberpr√ºfen und ich kann nicht genau sagen, was <i>CueValue ist</i> , aber der Beschreibung nach nimmt er einen Wert von 0,0 bis 1,0 an.  Wir k√∂nnen etwas √ºber die <i>Zeit</i> sagen, das ist <i>animationTime</i> von der aufrufenden Methode, es ist definitiv mehr als null und weniger als eins.  Andernfalls w√ºrde die Programmausf√ºhrung in einem anderen Zweig ablaufen.  Wenn dies die Methoden sind, die zum Rendern der Animation aufgerufen werden, sieht die Situation wie ein guter schwebender Fehler aus.  Ich w√ºrde eine √úberpr√ºfung f√ºr das Ergebnis von <i>FindClosestBeforeKeyFrame hinzuf√ºgen,</i> wenn in diesem Fall eine spezielle Behandlung erforderlich ist.  Oder - wenn das erste Element einige andere Bedingungen nicht erf√ºllt - entfernen Sie es aus der Schleife.  Da ich nicht wei√ü, wie das alles funktionieren soll, werde ich die zweite Option als Beispiel f√ºr die Korrektur w√§hlen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  <b>PVS-Studio Warnung: Der</b> <a href="https://www.viva64.com/ru/w/v3117/">V3117-</a> Konstruktorparameter 'phones' wird nicht verwendet.  Land.cs 25 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Country</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> region, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> population, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> area, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> density, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coast, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? migration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? infantMorality, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gdp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? literacy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? phones, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? birth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? death</span></span></span><span class="hljs-function">)</span></span> { Name = name; Region = region; Population = population; Area = area; PopulationDensity = density; CoastLine = coast; NetMigration = migration; InfantMortality = infantMorality; GDP = gdp; LiteracyPercent = literacy; BirthRate = birth; DeathRate = death; }</code> </pre> <br>  Ein gutes Beispiel f√ºr den Unterschied zwischen dem Betrieb des Analyseger√§ts und der manuellen Code√ºberpr√ºfung.  Dreizehn Konstruktorargumente, eines davon nicht verwendet.  Tats√§chlich stellt Visual Studio auch ein nicht verwendetes Argument fest, jedoch auf der dritten Warnstufe (sie sind h√§ufig deaktiviert).  In diesem Fall ist dies ein klarer Fehler, da die Klasse auch dreizehn Eigenschaften f√ºr jedes Argument hat und in <i>Phones</i> nirgendwo ein Wert zugewiesen ist.  Bearbeitung ist selbstverst√§ndlich, ich werde es nicht bringen. <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Sehen Sie sich 'tabItem' an.  TabItemContainerGenerator.cs 22 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  Der Analyzer hielt es f√ºr gef√§hrlich, das Ergebnis des Aufrufs von <i>CreateContainer</i> zu dereferenzieren. <br><br>  Schauen Sie sich diese Methode an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br>  Der Analysator kann die Zuweisung von <i>Null</i> zu einer Variablen sehen, selbst wenn ein Wert durch eine Kette von f√ºnfzig Methoden geleitet wird.  Er kann jedoch nicht sagen, ob dieser Thread mindestens einmal ausgef√ºhrt wird.  Ja, und ich konnte es auch im Allgemeinen nicht ... Methodenaufrufe gehen zwischen √ºberschriebenen und virtuellen Methoden verloren.  Ich schlage daher vor, mit einer zus√§tzlichen √úberpr√ºfung nur auf Nummer sicher zu gehen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tabItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3142/">V3142</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  DevTools.xaml.cs 91 <br><br>  Ich werde hier nicht viel Code schreiben, um Intrigen zu erzeugen, ich werde sofort sagen: Die Warnung ist falsch.  Der Analysator hat einen Aufruf einer Methode gesehen, die eine bedingungslose Ausnahme ausl√∂st.  Da ist er: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XamlLoadException(<span class="hljs-string"><span class="hljs-string">$"No precompiled XAML found for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{obj.GetType()}</span></span></span><span class="hljs-string">, make sure to specify x:Class and include your XAML file as AvaloniaResource"</span></span>); }</code> </pre> <br>  Es war unm√∂glich, f√ºnfunddrei√üig Warnungen (!) √úber den nicht erreichbaren Code, der sich nach Aufrufen dieser Methode befindet, nicht zu beachten.  Ich habe einen der Entwickler des Projekts gefragt: Wie funktioniert es?  Und sie erz√§hlten mir von einer M√∂glichkeit, Aufrufe einer Methode durch Aufrufe anderer zu ersetzen, die die <a href="https://www.mono-project.com/docs/">Mono.Cecil-</a> Bibliothek verwenden.  Sie k√∂nnen Anrufe direkt im IL-Code ersetzen. <br><br>  Der Analyzer unterst√ºtzt diese Bibliothek nicht, daher gibt es viele Fehlalarme. Es ist daher besser, diese Diagnose f√ºr dieses Projekt zu deaktivieren.  Es ist etwas peinlich zuzugeben, dass ich diese Diagnose gestellt habe ... aber wie jedes Tool muss auch die statische Analyse konfiguriert werden. <br><br>  Beispielsweise entwickeln wir derzeit Diagnosen zur Konvertierung unsicherer Typen.  Und es gibt etwas weniger als tausend Operationen auf dem Spielprojekt, bei denen die Tippsteuerung auf der Motorseite ausgef√ºhrt wird. <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://www.viva64.com/ru/w/v3009/">V3009</a> Es ist merkw√ºrdig, dass diese Methode immer den gleichen Wert von 'true' zur√ºckgibt.  DataGridRows.cs 412 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScrollSlotIntoView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> slot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrolledHorizontally</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot &lt; slot &amp;&amp; DisplayData.LastScrollingSlot &gt; slot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot == slot &amp;&amp; slot != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode gibt immer <i>true zur√ºck</i> .  Vielleicht hat sich der Zweck der Methode ge√§ndert, seit die Signatur geschrieben wurde, aber h√∂chstwahrscheinlich handelt es sich um einen Fehler.  Dies ist auch die von Microsoft kopierte Kontrollklasse, gemessen am Kommentar am Beginn der Klasse.  Meiner Meinung nach ist <i>DataGrid</i> in der Regel eines der instabilsten Steuerelemente. Ich halte es f√ºr erw√§genswert. Ist es erforderlich, den Bildlauf zu best√§tigen, wenn die Bedingungen nicht erf√ºllt werden? <br><br><h2>  Fazit </h2><br>  Einige dieser Fehler wurden nicht von den Avalonia-UI-Entwicklern selbst in das Projekt eingef√ºgt, sondern von Code, der aus den WPF-Steuerelementen kopiert wurde.  F√ºr den Benutzer der Schnittstelle spielt die Fehlerquelle jedoch in der Regel keine Rolle.  Ein abgest√ºrztes oder fehlerhaftes Interface verdirbt die Meinung des gesamten Programms. <br><br>  In dem Artikel, den ich erw√§hnte, dass der Analysator konfiguriert werden muss, gibt es Fehlalgorithmen, die aufgrund der Funktionsweise statischer Analysealgorithmen unvermeidbar sind.  Jeder, der mit dem <a href="https://en.wikipedia.org/wiki/Halting_problem">Problem des Anhaltens</a> vertraut <a href="https://en.wikipedia.org/wiki/Halting_problem">ist,</a> kennt die mathematischen Einschr√§nkungen beim Arbeiten mit anderem Code.  In diesem Fall geht es jedoch darum, eine Diagnose von fast einhunderteinhalb zu deaktivieren.  Wir sprechen also nicht √ºber den Bedeutungsverlust in der statischen Analyse (oder die Frage ist es nicht wert).  Au√üerdem h√§tte diese Diagnose gut ansprechen k√∂nnen. Es ist nur schwieriger, sie unter der Masse der falsch-positiven Ergebnisse zu finden. <br><br>  Achten Sie auf die hohe Qualit√§t des Projektcodes!  Ich hoffe, die Entwickler werden das Tempo und die Qualit√§t des Codes beibehalten.  Je gr√∂√üer das Projekt, desto mehr Fehler sind leider enthalten.  Eine der M√∂glichkeiten zur Reduzierung von Fehlern besteht in der korrekten Konfiguration von CI \ CD durch die Verkn√ºpfung statischer und dynamischer Analysen.  Und wenn Sie die Arbeit mit gro√üen Projekten vereinfachen und den Zeitaufwand f√ºr das Debuggen verringern m√∂chten, <a href="https://www.viva64.com/ru/pvs-studio-download/">laden Sie</a> PVS-Studio <a href="https://www.viva64.com/ru/pvs-studio-download/">herunter und probieren Sie es aus</a> ! <br><br><p> <a href="https://www.viva64.com/en/b/0701/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Alexander Senichkin.  <a href="https://www.viva64.com/en/b/0701/">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481598/">https://habr.com/ru/post/de481598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481586/index.html">E-Commerce-Tech-Trends 2020: Zeitalter der immersiven Technologien</a></li>
<li><a href="../de481588/index.html">Die √úbungen zur Isolierung von Runet begannen. √úberwachen wir?</a></li>
<li><a href="../de481592/index.html">Sechs Neujahrs-Geschenkoptionen f√ºr einen Autofahrer mit einem guten Rabatt</a></li>
<li><a href="../de481594/index.html">Entwicklung eines ‚Äûeinfachen Spannungsgenerators‚Äú nach GOST R IEC 61508 (IEC 61508)</a></li>
<li><a href="../de481596/index.html">Analysieren der ELK 7.5-Einstellungen f√ºr die Mikrotik-Protokollanalyse</a></li>
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele f√ºr Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481606/index.html">Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer gro√üen Tabelle unter Last</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>