<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏞️ 😔 🦗 使用pytest进行Python测试。 配置，第6章 👩‍⚕️ 👐 🔴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="返回 下一个 


 在本章中，我们将研究影响pytest的配置文件，讨论pytest如何基于它们更改其行为，以及对Tasks项目的配置任务进行一些更改。 





 本书中的示例是使用Python 3.6和pytest 3.2编写的。 pytest 3.2支持Python 2.6、2.7和Pyt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用pytest进行Python测试。 配置，第6章</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448796/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一个</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  <em>在本章中，我们将研究影响pytest的配置文件，讨论pytest如何基于它们更改其行为，以及对Tasks项目的配置任务进行一些更改。</em> </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p> 本书中的示例是使用Python 3.6和pytest 3.2编写的。  pytest 3.2支持Python 2.6、2.7和Python 3.3+。 </p><br><blockquote>本书网页上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">链接</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com</a>上提供了Tasks项目以及本书中显示的所有测试的源代码。 您无需下载源代码即可了解测试代码。 示例中以方便的形式提供了测试代码。 但是，为了跟上项目的任务，或者改编测试示例来测试自己的项目（不费力气！），您必须转到本书的网页并下载工作。 在该书的网页上，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/errata">勘误</a>信息链接和一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://forums.pragprog.com/forums/438">论坛</a> 。 </blockquote><p> 在剧透下方是该系列文章的列表。 </p><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>引言</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第1章：pytest入门</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第2章：编写测试函数</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第3章：Pytest固定装置</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第4章：内置灯具</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第5章：插件</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第6章：配置</strong></a> （本文） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第7章：与其他工具一起使用pytest</strong></a> </li></ul></div></div><br><h2 id="konfiguraciya"> 构型 </h2><br><p> 到目前为止，在本书中，我已经讨论了各种主要影响pytest的非测试文件，除了conftest.py例外，我在第95页的第5章插件中对此进行了详细介绍。在本章中，我们将介绍配置文件，影响pytest的内容，讨论pytest如何基于它们更改其行为，并对Tasks项目配置文件进行一些更改。 </p><br><h2 id="ponimanie-faylov-konfiguracii-pytest"> 了解pytest配置文件 </h2><br><p> 在我告诉您如何更改pytest中的默认行为之前，让我们先看一下pytest中的所有非测试文件，尤其是谁应该照顾它们。 </p><br><p> 您应该了解以下内容： </p><br><ul><li> <em>pytest.ini</em> ：这是主要的Pytest配置文件，允许您更改默认行为。 由于您可以进行很多配置更改，因此本章的大部分内容专门介绍您可以在<code>pytest.ini</code>进行的设置。 </li><li>  <em>conftest.py</em> ：这是一个本地插件，允许将钩子函数和装置连接到<code>conftest.py</code>文件及其所有子目录所在的目录。  <code>conftest.py</code>文件在第95页第5章“插件”中进行了描述。 </li><li>  <em><code>__init__.py</code></em> ：放置在每个测试子目录中时，此文件使您可以在多个测试目录中使用相同的测试文件名。 我们将在第120页上的文章“避免文件名冲突”中查看一个示例，该示例在测试目录中没有<code>__init__.py</code>文件的情况下会出现问题。 </li></ul><br><p> 如果您使用毒素，您将对以下内容感兴趣： </p><br><ul><li>  <em>tox.ini</em> ：此文件类似于<code>pytest.ini</code> ，但用于<code>tox</code> 。 但是，您可以将<code>pytest</code>配置<code>pytest</code>而不是同时拥有<code>tox.ini</code>文件和<code>pytest.ini</code>文件，从而为您节省一个配置文件。 第125页第7章“与其他工具一起使用pytest”中讨论了Tox。 </li></ul><br><p> 如果您要分发Python软件包（例如Tasks），则需要关注此文件： </p><br><ul><li>  <em>setup.cfg</em> ：这也是一个会影响<code>setup.py</code>行为的INI文件。 您可以在<code>setup.py</code>添加几行以运行<code>python setup.py test</code>并运行所有pytest测试。 如果您正在分发软件包，则可能已经有了<code>setup.cfg</code>文件，可以使用此文件存储Pytest配置。 您将在第175页的附录4“打包和分发Python项目”中看到如何完成此操作。 </li></ul><br><p> 无论您将pytest配置放入哪个文件，格式都基本相同。 </p><br><p> 对于<code>pytest.ini</code> ： </p><br><blockquote>  <strong>ch6 /格式/ pytest.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p> 对于<code>tox.ini</code> ： </p><br><blockquote>  <strong>ch6 /格式/ tox.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">... tox specific stuff ... [pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p> 对于<code>setup.cfg</code> ： </p><br><blockquote>  <strong>ch6 /格式/ setup.cfg</strong> </blockquote><br><pre> <code class="plaintext hljs">... packaging specific stuff ... [tool:pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p> 唯一的区别是setup.cfg的节头是<code>[tool:pytest]</code>而不是<code>[pytest]</code> 。 </p><br><h3 id="list-the-valid-ini-file-options-with-pytest-help"> 使用pytest –help列出有效的ini文件选项 </h3><br><p> 您可以从<code>pytest --help</code>获取<code>pytest.ini</code>的所有有效参数的列表： </p><br><pre> <code class="plaintext hljs">$ pytest --help ... [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found: markers (linelist) markers for test functions empty_parameter_set_mark (string) default marker for empty parametersets norecursedirs (args) directory patterns to avoid for recursion testpaths (args) directories to search for tests when no files or directories are given in the command line. console_output_style (string) console output: classic or with additional progress information (classic|progress). usefixtures (args) list of default fixtures to be used with this project python_files (args) glob-style file patterns for Python test module discovery python_classes (args) prefixes or glob names for Python test class discovery python_functions (args) prefixes or glob names for Python test function and method discovery xfail_strict (bool) default for the strict parameter of xfail markers when not given explicitly (default: False) junit_suite_name (string) Test suite name for JUnit report junit_logging (string) Write captured log messages to JUnit report: one of no|system-out|system-err doctest_optionflags (args) option flags for doctests doctest_encoding (string) encoding used for doctest files cache_dir (string) cache directory path. filterwarnings (linelist) Each line specifies a pattern for warnings.filterwarnings. Processed after -W and --pythonwarnings. log_print (bool) default value for --no-print-logs log_level (string) default value for --log-level log_format (string) default value for --log-format log_date_format (string) default value for --log-date-format log_cli (bool) enable log display during test run (also known as "live logging"). log_cli_level (string) default value for --log-cli-level log_cli_format (string) default value for --log-cli-format log_cli_date_format (string) default value for --log-cli-date-format log_file (string) default value for --log-file log_file_level (string) default value for --log-file-level log_file_format (string) default value for --log-file-format log_file_date_format (string) default value for --log-file-date-format addopts (args) extra command line options minversion (string) minimally required pytest version xvfb_width (string) Width of the Xvfb display xvfb_height (string) Height of the Xvfb display xvfb_colordepth (string) Color depth of the Xvfb display xvfb_args (args) Additional arguments for Xvfb xvfb_xauth (bool) Generate an Xauthority token for Xvfb. Needs xauth. ...</code> </pre> <br><p> 除了<code>doctest_optionflags</code> （在第125页的第7章“将pytest与其他工具一起使用”中讨论）外，您将在本章中看到所有这些设置。 </p><br><h3 id="plaginy-mogut-dobavlyat-opcii-ini-faylov"> 插件可以添加ini文件选项 </h3><br><p> 先前的设置列表不是常数。 对于插件（和conftest.py文件），可以添加ini文件选项。 添加的选项也将添加到pytest --help命令的输出中。 <br> 现在，让我们看一下使用核心pytest中可用的.ini文件的内置设置可以进行的一些配置更改。 </p><br><h3 id="izmenenie-parametrov-komandnoy-stroki-po-umolchaniyu"> 更改默认命令行选项 </h3><br><p> 您已经为<em>pytest</em>使用了一些命令行选项，例如<code>-v/--verbose</code>用于详细输出<code>-l/--showlocals</code>来查看带有堆栈跟踪的局部变量以进行失败的测试。 您可能会发现， <code>them—for a project</code> ，您始终会使用其中一些<code>options—or</code>更喜欢使用<code>them—for a project</code> 。 如果在<code>pytest.ini</code>安装了<code>pytest.ini</code>作为所需的参数，则无需再输入它们。 这是我喜欢的一套： </p><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict</code> </pre> <br><p>  <code>-rsxX</code>允许pytest报告所有<code>skipped</code> ， <code>xfailed</code>或<code>xpassed</code>测试的原因。  <code>-l</code>开关允许pytest在每次失败的情况下显示局部变量的堆栈跟踪。  <code>--tb=short</code>将删除大部分堆栈跟踪。 但是，它将保留文件和行号。 如果未在配置文件中注册令牌，则<code>--strict</code>禁止使用令牌。 您将在下一节中看到如何执行此操作。 </p><br><h3 id="registraciya-markerov-chtoby-izbezhat-opechatok-markera"> 标记注册，避免标记输入错误 </h3><br><p> 自定义标记（如第31页的“标记测试功能”中所述）非常适合让您标记要使用特定标记运行的测试子集。 但是，在标记中犯错误太容易了，最终有些测试被标记为<code>@pytest.mark.smoke</code> ，有些被标记为<code>@pytest.mark.somke</code> 。 默认情况下，这不是错误。  pytest只是认为您创建了两个标记。 但是，可以通过在pytest.ini中注册令牌来解决此问题，例如： </p><br><pre> <code class="plaintext hljs">[pytest] ... markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get() ...</code> </pre> <br><p> 通过注册这些标记，您现在还可以使用<code>pytest --markers</code>以及它们的描述来查看它们： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --markers @pytest.mark.smoke: Run the smoke test test functions @pytest.mark.get: Run the test functions that test tasks.get() @pytest.mark.skip(reason=None): skip the ... ...</code> </pre> <br><p> 如果未注册标记，则它们不会出现在<code>--markers</code>列表中。 注册它们时，将列出它们，如果使用<code>--strict</code> ，则任何带有错误或未注册的令牌都将显示为错误。  <code>ch6/a/tasks_proj</code>和<code>ch6/b/tasks_proj</code>之间的唯一区别是pytest.ini文件的内容。 在<code>ch6/a</code>空。 让我们尝试在不注册任何标记的情况下运行测试： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/a/tasks_proj/tests $ pytest --strict --tb=line ============================= test session starts ============================= collected 45 items / 2 errors =================================== ERRORS ==================================== ______________________ ERROR collecting func/test_add.py ______________________ 'smoke' not a registered marker ________________ ERROR collecting func/test_api_exceptions.py _________________ 'smoke' not a registered marker !!!!!!!!!!!!!!!!!!! Interrupted: 2 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 2 error in 1.10 seconds ===========================</code> </pre> <br><p> 如果您在<code>pytest.ini</code>使用标记来注册标记，则<code>pytest.ini</code>在使用时在<code>pytest.ini</code>中添加<code>--strict</code> 。 待会儿我会谢谢你的。 让我们继续并将pytest.ini文件添加到任务项目： </p><br><p> 如果您在<code>pytest.ini</code>使用标记来注册标记，则还可以在<code>addopts</code>添加<code>--strict</code> 。 您稍后会感谢我。 让我们继续并将pytest.ini文件添加到任务项目中： </p><br><p> 如果您在<code>pytest.ini</code>使用令牌注册令牌，则还可以使用<code>addopts</code>将<code>--strict</code>添加到现有<code>addopts</code> 。 酷吗？  <code>pytest.ini</code>感谢，并将<code>pytest.ini</code>文件添加到<code>tasks</code>项目： </p><br><blockquote>  ch6 / b / task_proj /测试/ pytest.ini </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get()</code> </pre> <br><p> 这是默认情况下首选的标志组合： </p><br><ul><li>  <code>-rsxX</code>跳过，xfailed或xpass的测试， </li><li>  <code>--tb = short</code>用于更短地跟踪故障， </li><li>  <code>--strict</code>只允许声明的令牌。 <br> 以及该项目的标记列表。 </li></ul><br><p> 这应该使我们能够进行测试，包括烟雾测试： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --strict -m smoke ===================== test session starts ====================== collected 57 items func/test_add.py . func/test_api_exceptions.py .. ===================== 54 tests deselected ====================== =========== 3 passed, 54 deselected in 0.06 seconds ============</code> </pre> <br><h3 id="trebovanie-minimalnoy-versii-pytest"> 最低Pytest要求 </h3><br><p> 使用<code>minversion</code>参数可以指定测试所需的最低pytest版本。 例如，我打算在测试浮点数时使用<code>approx()</code>来确定测试中的“相当接近”的相等性。 但是直到版本3.0才在pytest中引入此功能。 为避免混淆，我向使用<code>approx()</code>项目添加了以下内容： </p><br><pre> <code class="plaintext hljs">[pytest] minversion = 3.0</code> </pre> <br><p> 因此，如果有人尝试使用较旧版本的pytest运行测试，则会出现错误消息。 </p><br><h3 id="ostanovka-pytest-ot-poiska-v-nepravilnyh-mestah"> 停止pytest在错误的地方搜索 </h3><br><p> 您是否知道“递归”的定义之一是在自己的代码中宣誓两次？ 好吧，不。 实际上，这意味着要考虑子目录。  pytest将通过递归检查一堆目录来启用测试检测。 但是有些目录要从pytest中排除。 </p><br><p>  <code>norecurse</code>的默认值为<code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code>  <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code>是命名虚拟环境“ .venv”的一个很好的理由，因为所有以点开头的目录都将不可见。 </p><br><p> 对于Tasks项目， <code>src</code>可以轻松指定，因为使用pytest搜索测试文件将浪费时间。 </p><br><pre> <code class="plaintext hljs">[pytest] norecursedirs = .* venv src *.egg dist build</code> </pre> <br><p> 当覆盖已经具有有用值的参数（例如该参数）时，了解默认值并返回所需的值非常有用，就像我在上一个代码中使用<code>*.egg dist build</code>所做的那样。 <br>  <code>norecursedirs</code>是测试路径的一种结果，因此让我们稍后看一下。 </p><br><h3 id="specifikaciya-dereva-testovogo-kataloga"> 测试目录树规范 </h3><br><p> 虽然<code>norecursedirs</code>告诉pytest看哪里，而<code>testpaths</code>告诉pytest看哪里。  <code>testspaths</code>是相对于用于查找测试的根目录的目录列表。 仅当未将目录，文件或<code>nodeid</code>指定为参数时才使用它。 </p><br><p> 假设对于<code>Tasks</code>项目，我们将<code>pytest.ini</code>在<code>tasks_proj</code>目录中而不是测试中： </p><br><pre> <code class="plaintext hljs">\code\tasks_proj&gt;tree/f . │ pytest.ini │ ├───src │ └───tasks │ api.py │ ... │ └───tests │ conftest.py │ pytest.ini │ ├───func │ test_add.py │ ... │ ├───unit │ test_task.py │ __init__.py │ ...</code> </pre> <br><p> 然后将测试放在测试<code>testpaths</code>可能是有意义的： </p><br><pre> <code class="plaintext hljs">[pytest] testpaths = tests</code> </pre> <br><p> 现在，如果您从<code>tasks_proj</code>目录运行pytest，pytest将仅在<code>tasks_proj/tests</code>搜索。 这里的问题是，在测试的开发和调试过程中，我经常遍历测试目录，因此无需指定完整路径即可轻松测试子目录或文件。 因此，此选项对交互式测试有一定帮助。 </p><br><p> 但是，这对于从连续集成服务器或Tox运行的测试非常有用。 在这些情况下，您知道根目录将是固定的，并且可以列出相对于该固定根目录的目录。 在您确实希望减少测试时间的情况下，也是如此，因此摆脱对测试的搜索是一件很不错的事情。 </p><br><p> 乍一看，同时使用测试路径和<code>norecursedirs</code>似乎很愚蠢。 但是，正如您已经看到的，测试路径在文件系统不同部分的交互式测试中几乎没有帮助。 在这些情况下，无<code>norecursedirs</code>可能会有所帮助。 另外，如果您的测试目录不包含测试，则可以使用<code>norecursedirs</code>来避免使用它们。 但是实际上，将多余的目录放在没有测试的测试中有什么意义呢？ </p><br><h2 id="izmenenie-pravil-obnaruzheniya-testov"> 更改测试检测规则 </h2><br><p>  pytest根据特定的测试发现规则查找要运行的测试。 标准测试检测规则： </p><br><p>  •从一个或多个目录开始。 您可以在命令行上指定文件或目录的名称。 如果您未指定任何内容，则使用当前目录。 <br>  •在目录及其所有子目录中搜索测试模块。 <br>  •测试模块是一个名称类似于<code>test_*.py</code> <code>*_test.py</code>或<code>*_test.py</code> 。 <br>  •在测试模块中查找以test开头的功能<em>。</em> <em><br></em>  <em>•查找以Test开头的类。</em>  <em>在以`test开始</em> <code>,    </code> <strong>init`</strong> <code>,    </code> <em>类中寻找</em> <code>,    </code> 。 </p><br><p> 这些是标准的检测规则； 但是，您可以更改它们。 </p><br><h3 id="python_classes">  python_classes </h3><br><p> 查找pytest和类测试的通常规则是，如果该类以<code>Test*</code>开头，则将其视为潜在的测试类。 该类也不能具有<code>__init__()</code>方法。 但是，如果我们要将测试类命名为<code>&lt;something&gt;Test</code>或<code>&lt;something&gt;Suite</code>怎么办？ 这是<code>python_classes</code>出现<code>python_classes</code> ： </p><br><pre> <code class="plaintext hljs">[pytest] python_classes = *Test Test* *Suite</code> </pre> <br><p> 这使我们可以像这样命名类： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeleteSuite</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... ....</code> </pre> <br><h3 id="python_files">  python_files </h3><br><p> 像<code>pytest_classes</code>一样， <code>python_files</code>修改默认的测试检测规则，该规则包括查找以<code>test_*</code>开头或以<code>*_test</code> <code>test_*</code>结尾的文件。 <br> 假设您有一个自定义的测试框架，在其中将所有测试文件命名为<code>check_&lt;something&gt;.py</code> 。 似乎合理。 无需重命名所有文件，只需在<code>pytest.ini</code>添加一行，如下所示： </p><br><pre> <code class="plaintext hljs">[pytest] python_files = test_* *_test check_*</code> </pre> <br><p> 很简单 现在，您可以根据需要逐步转移命名约定，或者将其保留为<code>check_*</code> 。 </p><br><h3 id="python_functions">  python_functions </h3><br><p>  <code>python_functions</code>行为类似于之前的两个设置，但用于测试函数和方法名称。 默认值为<code>test_*</code> 。 并添加<code>check_*</code>猜对了），请执行以下操作： </p><br><pre> <code class="plaintext hljs">[pytest] python_functions = test_* check_*</code> </pre> <br><p>  <code>pytest</code>命名<code>pytest</code>似乎没有那么严格，对吗？ 因此，如果您不喜欢默认的命名约定，只需对其进行更改。 不过，我敦促您为此类决定提供更有说服力的理由。 迁移数百个测试文件绝对是一个很好的理由。 </p><br><h2 id="zapret-xpass">  XPASS禁令 </h2><br><p> 设置<code>xfail_strict = true</code>表示标记为<code>@pytest.mark.xfail</code>的测试未被识别为导致该错误。 我认为此设置应始终如此。 有关<code>xfail</code>令牌的更多信息<code>xfail</code>请参阅第37页“标记等待失败的测试”。 </p><br><h2 id="predotvraschenie-konfliktov-imen-faylov"> 防止文件名冲突 </h2><br><p> 在项目的每个测试子目录中都有<code>__init__.py</code>文件的作用使我困惑了很长时间。 但是，拥有或不拥有它们的区别很简单。 如果所有测试子目录中都有<code>__init__.py</code>文件，则可以在多个目录中使用相同的测试文件名。 如果没有，那么这将行不通。 </p><br><p> 这是一个例子。 目录<code>a</code>和<code>b</code>都有文件<code>test_foo.py</code> 。 这些文件包含什么都没有关系，但是在本示例中，它们看起来像这样： </p><br><blockquote>  <strong>ch6 / dups / a / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><br>  <strong>ch6 / dups / b / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br></blockquote><p> 使用此目录结构： </p><br><pre> <code class="plaintext hljs">dups ├── a │ └── test_foo.py └── b └── test_foo.py</code> </pre> <br><p> 这些文件甚至没有相同的内容，但是测试已损坏。 您将能够分别运行它们，但是无法从<code>dups</code>目录运行<code>pytest</code> ： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/dups $ pytest a ============================= test session starts ============================= collected 1 item a\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest b ============================= test session starts ============================= collected 1 item b\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest ============================= test session starts ============================= collected 1 item / 1 errors =================================== ERRORS ==================================== _______________________ ERROR collecting b/test_foo.py ________________________ import file mismatch: imported module 'test_foo' has this __file__ attribute: /path/to/code/ch6/dups/a/test_foo.py which is not the same as the test file we want to collect: /path/to/code/ch6/dups/b/test_foo.py HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules !!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 1 error in 0.34 seconds ===========================</code> </pre> <br><p> 不清楚！ <br> 此错误消息并不表示出了什么问题。 </p><br><p> 要修复此测试，只需将空的<code>__init__.py</code>文件添加到子目录中。 这是<code>dups_fixed</code>目录的示例，该目录具有相同的重复文件名，但添加了<code>__init__.py</code>文件： </p><br><pre> <code class="plaintext hljs">dups_fixed/ ├── a │ ├── __init__.py │ └── test_foo.py └── b ├── __init__.py └── test_foo.py</code> </pre> <br><p> 现在，让我们从<code>dups_fixed</code>的顶层重<code>dups_fixed</code> ： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/ch6/dups_fixed/ $ pytest ============================= test session starts ============================= collected 2 items a\test_foo.py . b\test_foo.py . ========================== 2 passed in 0.15 seconds ===========================</code> </pre> <br><p> 这样会更好。 </p><br><p> 当然，您可以说服自己永远不会有重复的文件名，所以没关系。 一切都正常。 但是项目在增长，测试目录也在增长，您肯定要等它发生之后再处理它吗？ 我说，就是把这些文件放在那里。 养成习惯，不必担心。 </p><br><h2 id="uprazhneniya"> 练习题 </h2><br><p> 在第95页的第5章，插件中，您创建了一个名为pytest-nice的插件，其中包括--nice命令行选项。 让我们对其进行扩展，使其包含一个名为nice的pytest.ini选项。 </p><br><p> 在第95页第5章“插件”中，您创建了一个名为<code>pytest-nice</code>的插件，其中包括<code>--nice</code>命令行<code>--nice</code> 。 让我们将其扩展为包含名为<code>nice</code>的<code>pytest.ini</code>选项。 </p><br><ol><li>  <code>pytest_addoption</code> <code>pytest_nice.py</code>添加到<code>pytest_addoption</code> <code>pytest_nice.py</code>挂钩函数中： <code>parser.addini('nice', type='bool', help='Turn failures into opportunities.')</code> </li><li> 插件中使用<code>getoption()</code>也必须调用<code>getini('nice')</code> 。 进行这些更改。 </li><li> 通过向<code>pytest.ini</code>文件添加<code>nice</code>来手动验证。 </li><li> 不要忘记插件测试。 添加一个测试以验证<code>pytest.ini</code>中的<code>nice</code>参数<code>pytest.ini</code>正常运行。 </li><li> 将测试添加到插件目录。 您需要找到一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他的Pytester功能</a> 。 </li></ol><br><h2 id="chto-dalshe"> 接下来是什么 </h2><br><p> 尽管pytest本身非常强大（尤其是插件），但它也可以与其他软件开发和软件测试工具很好地集成。 在下一章中，我们将结合其他强大的测试工具来研究pytest的用法。 </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一个</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448796/">https://habr.com/ru/post/zh-CN448796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448780/index.html">什么使软件可以赚钱</a></li>
<li><a href="../zh-CN448782/index.html">使用pytest进行Python测试。 pytest入门，第1章</a></li>
<li><a href="../zh-CN448786/index.html">使用pytest进行Python测试。 第3章pytest固定装置</a></li>
<li><a href="../zh-CN448788/index.html">使用pytest进行Python测试。 第2章，编写测试函数</a></li>
<li><a href="../zh-CN448790/index.html">SpaceVIL-用于在.Net Core，.Net Standard和JVM上开发的跨平台GUI框架</a></li>
<li><a href="../zh-CN448798/index.html">使用pytest进行Python测试。 将pytest与其他工具结合使用，第7章</a></li>
<li><a href="../zh-CN448800/index.html">使用.vsconfig在整个组织中配置Visual Studio</a></li>
<li><a href="../zh-CN448802/index.html">关于门户网站的思考：在虚幻引擎4中创建门户网站</a></li>
<li><a href="../zh-CN448804/index.html">为macOS的强化运行时和公证做好准备</a></li>
<li><a href="../zh-CN448806/index.html">在Qt库上创建扩展系统</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>