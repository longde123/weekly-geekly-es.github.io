<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèôÔ∏è üë©üèø üê® Escribimos un sistema operativo en Rust. Organizaci√≥n de la p√°gina de memoria üò∏ üì© ü§öüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, presentamos p√°ginas , un esquema de administraci√≥n de memoria muy com√∫n que tambi√©n aplicamos en nuestro sistema operativo. El art√≠c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos un sistema operativo en Rust. Organizaci√≥n de la p√°gina de memoria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436606/">  En este art√≠culo, presentamos <i>p√°ginas</i> , un esquema de administraci√≥n de memoria muy com√∫n que tambi√©n aplicamos en nuestro sistema operativo.  El art√≠culo explica por qu√© se necesita el aislamiento de la memoria, c√≥mo funciona la <i>segmentaci√≥n</i> , qu√© <i>es la memoria virtual</i> y c√≥mo las p√°ginas resuelven el problema de fragmentaci√≥n.  Tambi√©n exploramos el esquema de tablas de p√°ginas multinivel en la arquitectura x86_64. <br><br>  Este blog est√° publicado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  Si tiene alguna pregunta o problema, abra la solicitud correspondiente all√≠. <br><a name="habracut"></a><br><h1>  Protecci√≥n de la memoria </h1><br>  Una de las tareas principales del sistema operativo es aislar los programas entre s√≠.  Por ejemplo, un navegador no debe interferir con un editor de texto.  Existen varios enfoques seg√∫n el hardware y la implementaci√≥n del sistema operativo. <br><br>  Por ejemplo, algunos procesadores ARM Cortex-M (en sistemas integrados) tienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>una unidad de protecci√≥n de memoria</i></a> (MPU) que define un peque√±o n√∫mero (por ejemplo, 8) de √°reas de memoria con diferentes permisos de acceso (por ejemplo, sin acceso, solo lectura, lectura y registros).  Cada vez que se accede a la memoria, la MPU se asegura de que la direcci√≥n est√© en el √°rea con los permisos correctos, de lo contrario arroja una excepci√≥n.  Al cambiar el alcance y los permisos de acceso, el sistema operativo garantiza que cada proceso tenga acceso solo a su memoria para aislar los procesos entre s√≠. <br><br>  En x86, se admiten dos enfoques diferentes para proteger la memoria: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segmentaci√≥n</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paginaci√≥n</a> . <br><br><h1>  Segmentaci√≥n </h1><br>  La segmentaci√≥n se implement√≥ en 1978, inicialmente para aumentar la cantidad de memoria direccionable.  En ese momento, la CPU solo admit√≠a direcciones de 16 bits, lo que limitaba la cantidad de memoria direccionable a 64 KB.  Para aumentar este volumen, se introdujeron registros de segmento adicionales, cada uno de los cuales contiene una direcci√≥n de desplazamiento.  La CPU agrega autom√°ticamente este desplazamiento en cada acceso a la memoria, dirigiendo as√≠ hasta 1 MB de memoria. <br><br>  La CPU selecciona autom√°ticamente un registro de segmento seg√∫n el tipo de acceso a la memoria: el registro de segmento de c√≥digo <code>CS</code> se usa para recibir instrucciones, y el registro de segmento de pila <code>SS</code> se usa para operaciones de pila (push / pop).  Otras instrucciones utilizan el registro de segmento de datos <code>DS</code> o el registro de segmento <code>ES</code> opcional.  M√°s tarde, se agregaron dos registros de segmento adicionales <code>FS</code> y <code>GS</code> para uso gratuito. <br><br>  En la primera versi√≥n de la segmentaci√≥n, los registros conten√≠an directamente el desplazamiento y no se realiz√≥ el control de acceso.  Con la llegada del <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo protegido, el</a></i> mecanismo ha cambiado.  Cuando la CPU funciona en este modo, los descriptores de segmento almacenan el √≠ndice en una tabla de descriptores locales o globales, que adem√°s de la direcci√≥n de desplazamiento contiene el tama√±o del segmento y los permisos de acceso.  Al cargar tablas de descriptores globales / locales separadas para cada proceso, el sistema operativo puede aislar los procesos entre s√≠. <br><br>  Al cambiar las direcciones de memoria antes del acceso real, la segmentaci√≥n implement√≥ un m√©todo que ahora se usa en casi todas partes: es <i>la memoria virtual</i> . <br><br><h3>  Memoria virtual </h3><br>  La idea de la memoria virtual es abstraer las direcciones de memoria de un dispositivo f√≠sico.  En lugar de acceder directamente al dispositivo de almacenamiento, primero se realiza un paso de conversi√≥n.  En el caso de la segmentaci√≥n, la direcci√≥n de desplazamiento del segmento activo se agrega en la etapa de traducci√≥n.  Imagine un programa que accede a la direcci√≥n de memoria <code>0x1234000</code> en un segmento con un desplazamiento de <code>0x1111000</code> : en realidad, la direcci√≥n va a <code>0x2345000</code> . <br><br>  Para distinguir entre dos tipos de direcciones, las direcciones antes de la conversi√≥n se llaman <i>virtuales</i> y las direcciones despu√©s de la conversi√≥n se llaman <i>f√≠sicas</i> .  Hay una diferencia importante entre ellos: las direcciones f√≠sicas son √∫nicas y siempre se refieren a la misma ubicaci√≥n √∫nica en la memoria.  Las direcciones virtuales, por otro lado, dependen de la funci√≥n de traducci√≥n.  Dos direcciones virtuales diferentes pueden referirse a la misma direcci√≥n f√≠sica.  Adem√°s, las direcciones virtuales id√©nticas pueden referirse a diferentes direcciones f√≠sicas despu√©s de la conversi√≥n. <br><br>  Un ejemplo del uso √∫til de esta propiedad es el lanzamiento paralelo del mismo programa dos veces: <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br>  Aqu√≠, el mismo programa se ejecuta dos veces, pero con diferentes funciones de conversi√≥n.  La primera instancia tiene un desplazamiento de segmento de 100, por lo que sus direcciones virtuales 0-150 se convierten en direcciones f√≠sicas 100-250.  La segunda instancia tiene un desplazamiento de 300, que traduce las direcciones virtuales 0-150 en direcciones f√≠sicas 300-450.  Esto permite que ambos programas ejecuten el mismo c√≥digo y usen las mismas direcciones virtuales sin interferir entre s√≠. <br><br>  Otra ventaja es que ahora los programas se pueden colocar en lugares arbitrarios en la memoria f√≠sica.  Por lo tanto, el sistema operativo utiliza la cantidad total de memoria disponible sin la necesidad de volver a compilar programas. <br><br><h3>  Fragmentaci√≥n </h3><br>  La diferencia entre las direcciones virtuales y f√≠sicas es un logro real de la segmentaci√≥n.  Pero hay un problema.  Imagine que queremos ejecutar la tercera copia del programa que vimos arriba: <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br>  Aunque hay m√°s que suficiente espacio en la memoria f√≠sica, la tercera copia no cabe en ning√∫n lado.  El problema es que necesita un fragmento <i>continuo</i> de memoria y no podemos usar secciones libres separadas. <br><br>  Una forma de combatir la fragmentaci√≥n es pausar la ejecuci√≥n del programa, acercar las partes usadas de la memoria, actualizar la conversi√≥n y luego reanudar la ejecuci√≥n: <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br>  Ahora hay suficiente espacio para lanzar la tercera instancia. <br><br>  La desventaja de esta desfragmentaci√≥n es la necesidad de copiar grandes cantidades de memoria, lo que reduce el rendimiento.  Este procedimiento debe realizarse regularmente hasta que la memoria se haya fragmentado demasiado.  El rendimiento se vuelve impredecible, los programas se detienen en cualquier momento y pueden dejar de responder. <br><br>  La fragmentaci√≥n es una de las razones por las cuales la segmentaci√≥n no se usa en la mayor√≠a de los sistemas.  De hecho, ya no es compatible incluso en modo de 64 bits en x86.  En lugar de segmentaci√≥n, se utilizan p√°ginas que eliminan completamente el problema de la fragmentaci√≥n. <br><br><h1>  Organizaci√≥n de la p√°gina de memoria </h1><br>  La idea es dividir el espacio de la memoria virtual y f√≠sica en peque√±os bloques de un tama√±o fijo.  Los bloques de memoria virtual se denominan p√°ginas, y los bloques de espacio de direcciones f√≠sicas se denominan cuadros.  Cada p√°gina se asigna individualmente a un marco, lo que le permite dividir grandes √°reas de memoria entre marcos f√≠sicos no adyacentes. <br><br>  La ventaja se vuelve obvia si repite el ejemplo con un espacio de memoria fragmentado, pero esta vez usando p√°ginas en lugar de segmentaci√≥n: <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br>  En este ejemplo, el tama√±o de la p√°gina es de 50 bytes, es decir, cada una de las √°reas de memoria se divide en tres p√°ginas.  Cada p√°gina se asigna a un marco separado, por lo que una regi√≥n contigua de memoria virtual se puede asignar a marcos f√≠sicos aislados.  Esto le permite ejecutar la tercera instancia del programa sin desfragmentaci√≥n. <br><br><h3>  Fragmentaci√≥n oculta </h3><br>  En comparaci√≥n con la segmentaci√≥n, una organizaci√≥n de paginaci√≥n utiliza muchas √°reas peque√±as de memoria de tama√±o fijo en lugar de varias √°reas grandes de tama√±o variable.  Cada cuadro tiene el mismo tama√±o, por lo que no es posible la fragmentaci√≥n debido a cuadros demasiado peque√±os. <br><br>  Pero esto es solo una <i>apariencia</i> .  De hecho, existe una forma oculta de fragmentaci√≥n, la llamada <i>fragmentaci√≥n interna</i> debido al hecho de que no todas las √°reas de memoria son exactamente un m√∫ltiplo del tama√±o de la p√°gina.  Imagine en el ejemplo anterior, un programa de tama√±o 101: a√∫n necesitar√° tres p√°ginas de tama√±o 50, por lo que tomar√° 49 bytes m√°s de lo que necesita.  Para mayor claridad, la fragmentaci√≥n debida a la segmentaci√≥n se denomina <i>fragmentaci√≥n externa</i> . <br><br>  No hay nada bueno en la fragmentaci√≥n interna, pero a menudo es un mal menor que la fragmentaci√≥n externa.  Todav√≠a se consume memoria adicional, pero ahora no es necesario desfragmentarla, y el volumen de fragmentaci√≥n es predecible (en promedio, media p√°gina por √°rea de memoria). <br><br><h3>  Tablas de p√°gina </h3><br>  Vimos que cada uno de los millones de p√°ginas posibles se asigna individualmente a un marco.  Esta informaci√≥n de traducci√≥n de direcciones debe almacenarse en alg√∫n lugar.  Al segmentar, se utilizan registros de segmento separados para cada √°rea de memoria activa, lo cual es imposible en el caso de las p√°ginas, porque hay muchos m√°s que registros.  En cambio, utiliza una estructura llamada <i>tabla de p√°ginas</i> . <br><br>  Para el ejemplo anterior, las tablas se ver√°n as√≠: <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br>  Como puede ver, cada instancia del programa tiene su propia tabla de p√°ginas.  Un puntero a la tabla activa actual se almacena en un registro especial de la CPU.  En <code>x86</code> se llama <code>CR3</code> .  Antes de comenzar cada instancia del programa, el sistema operativo debe cargar un puntero a la tabla de p√°ginas correcta all√≠. <br><br>  Cada vez que se accede a la memoria, la CPU lee el puntero de la tabla del registro y busca el marco correspondiente en la tabla.  Esta es una funci√≥n totalmente de hardware que se ejecuta de forma completamente transparente para un programa en ejecuci√≥n.  Para acelerar el proceso, muchas arquitecturas de procesador tienen un cach√© especial que recuerda los resultados de las √∫ltimas conversiones. <br><br>  Seg√∫n la arquitectura, los atributos como los permisos tambi√©n se pueden almacenar en el campo de marca de la tabla de p√°ginas.  En el ejemplo anterior, el indicador <code>r/w</code> hace que la p√°gina sea legible y escribible. <br><br><h3>  Tablas de p√°gina en capas </h3><br>  Las tablas de p√°ginas simples tienen un problema con grandes espacios de direcciones: se desperdicia memoria.  Por ejemplo, el programa usa cuatro p√°ginas virtuales <code>0</code> , <code>1_000_000</code> , <code>1_000_050</code> y <code>1_000_100</code> (usamos <code>_</code> como separador de d√≠gitos): <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br>  Solo se requieren cuatro marcos f√≠sicos, pero hay m√°s de un mill√≥n de registros en la tabla de p√°ginas.  No podemos omitir entradas vac√≠as, porque la CPU durante el proceso de conversi√≥n no podr√° ir directamente a la entrada correcta (por ejemplo, ya no se garantiza que la cuarta p√°gina use la cuarta entrada). <br><br>  Para reducir la p√©rdida de memoria, puede usar una <b>organizaci√≥n de dos niveles</b> .  La idea es que usemos diferentes tablas para diferentes √°reas.  Una tabla adicional, llamada tabla de p√°ginas de <i>segundo nivel</i> , convierte entre las √°reas de direcciones y las tablas de p√°ginas de primer nivel. <br><br>  Esto se explica mejor con un ejemplo.  Definimos que cada tabla de p√°gina de nivel 1 es responsable de un √°rea de tama√±o <code>10_000</code> .  Luego, en el ejemplo anterior, existir√°n las siguientes tablas: <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br>  La p√°gina 0 se encuentra en la primera √°rea de <code>10_000</code> bytes, por lo que utiliza el primer registro en la tabla de p√°ginas del segundo nivel.  Esta entrada apunta a la tabla de p√°gina T1 de primer nivel, que determina que la p√°gina 0 se refiere al cuadro 0. <br><br>  Las p√°ginas <code>1_000_000</code> , <code>1_000_050</code> y <code>1_000_100</code> caen en la regi√≥n de 100 bytes de <code>10_000</code> , por lo que utilizan el registro n√∫mero 100 de la tabla de p√°ginas de nivel 2. Este registro apunta a otra tabla de primer nivel T2, que traduce tres p√°ginas en marcos 100, 150 y 200. Nota que la direcci√≥n de la p√°gina en las tablas del primer nivel no contiene un desplazamiento de regi√≥n, por lo tanto, por ejemplo, el registro de la p√°gina <code>1_000_050</code> es solo <code>50</code> . <br><br>  Todav√≠a tenemos 100 entradas vac√≠as en la tabla de segundo nivel, pero esto es mucho menos que el mill√≥n anterior.  La raz√≥n de los ahorros es que no necesita crear tablas de p√°ginas de primer nivel para √°reas de memoria <code>10_000</code> entre <code>10_000</code> y <code>1_000_000</code> . <br><br>  El principio de las tablas de dos niveles se puede extender a tres, cuatro o m√°s niveles.  En general, dicho sistema se denomina tabla de p√°ginas <i>multinivel</i> o <i>jer√°rquica</i> . <br><br>  Al conocer la organizaci√≥n de la p√°gina y las tablas de varios niveles, puede ver c√≥mo se implementa la organizaci√≥n de la p√°gina en la arquitectura x86_64 (suponemos que el procesador se ejecuta en modo de 64 bits). <br><br><h1>  Organizaci√≥n de la p√°gina en x86_64 </h1><br>  La arquitectura x86_64 utiliza una tabla de cuatro niveles con un tama√±o de p√°gina de 4 KB.  Independientemente del nivel, cada tabla de p√°gina tiene 512 elementos.  Cada registro tiene un tama√±o de 8 bytes, por lo que el tama√±o de las tablas es de 512 √ó 8 bytes = 4 KB. <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br>  Como puede ver, cada √≠ndice de tabla contiene 9 bits, lo que tiene sentido, porque las tablas tienen 2 ^ 9 = 512 entradas.  Los 12 bits inferiores son el desplazamiento de p√°gina de 4 kilobytes (2 ^ 12 bytes = 4 KB).  Los bits 48 a 64 se descartan, por lo que x86_64 en realidad no es un sistema de 64 bits, sino que solo admite direcciones de 48 bits.  Hay planes para expandir el tama√±o de la direcci√≥n a 57 bits a trav√©s de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabla de p√°ginas de 5 niveles</a> , pero dicho procesador a√∫n no se ha creado. <br><br>  Aunque los bits 48 a 64 se descartan, no se pueden establecer en valores arbitrarios.  Todos los bits en este rango deben ser copias del bit 47 para preservar direcciones √∫nicas y permitir una expansi√≥n futura, por ejemplo, a una tabla de p√°ginas de 5 niveles.  Esto se llama extensi√≥n de signo, porque es muy similar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una extensi√≥n de signo en c√≥digo adicional</a> .  Si la direcci√≥n se expande incorrectamente, la CPU emite una excepci√≥n. <br><br><h3>  Ejemplo de conversi√≥n </h3><br>  Veamos un ejemplo de c√≥mo funciona la traducci√≥n de direcciones: <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br>  La direcci√≥n f√≠sica de la tabla de p√°gina activa actual de las p√°ginas de nivel 4, que es la tabla ra√≠z de las p√°ginas de p√°gina de este nivel, se almacena en el <code>CR3</code> .  Cada entrada de la tabla de p√°ginas se√±ala el marco f√≠sico de la tabla de nivel siguiente.  Una entrada de tabla de nivel 1 indica el marco visualizado.  Tenga en cuenta que todas las direcciones en las tablas de p√°gina son f√≠sicas y no virtuales, porque de lo contrario la CPU necesitar√° convertir estas direcciones (lo que puede conducir a una recursi√≥n infinita). <br><br>  La jerarqu√≠a anterior convierte dos p√°ginas (en azul).  A partir de los √≠ndices, podemos concluir que las direcciones virtuales de estas p√°ginas son <code>0x803fe7f000</code> y <code>0x803FE00000</code> .  Veamos qu√© sucede cuando un programa intenta leer la memoria en la direcci√≥n <code>0x803FE7F5CE</code> .  Primero, convierta la direcci√≥n a binario y determine los √≠ndices de la tabla de p√°ginas y el desplazamiento de la direcci√≥n: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br>  Con estos √≠ndices, ahora podemos pasar por la jerarqu√≠a de las tablas de p√°ginas y encontrar el marco correspondiente: <br><br><ul><li>  Lea la direcci√≥n de la tabla del cuarto nivel del <code>CR3</code> . </li><li>  El √≠ndice del cuarto nivel es 1, por lo que miramos el registro con el √≠ndice 1 en esta tabla.  Ella dice que una tabla de nivel 3 se almacena a 16 KB. </li><li>  Cargamos la tabla de tercer nivel desde esta direcci√≥n y miramos el registro con √≠ndice 0, que apunta a la tabla de segundo nivel con 24 KB. </li><li>  El √≠ndice del segundo nivel es 511, por lo que estamos buscando el √∫ltimo registro en esta p√°gina para encontrar la direcci√≥n de la tabla del primer nivel. </li><li>  De la entrada con el √≠ndice 127 en la tabla de primer nivel, finalmente descubrimos que la p√°gina corresponde a un marco de 12 KB o 0xc000 en formato hexadecimal. </li><li>  El paso final es agregar un desplazamiento a la direcci√≥n del marco para obtener la direcci√≥n f√≠sica: 0xc000 + 0x5ce = 0xc5ce. </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br>  Para la p√°gina en la tabla del primer nivel, se especifica el indicador <code>r</code> , es decir, solo se permite la lectura.  Se lanzar√° una excepci√≥n a nivel de hardware si intentamos grabar all√≠.  Los permisos de las tablas de nivel superior se extienden a los niveles inferiores, por lo que si establecemos el indicador de solo lectura en el tercer nivel, ni una sola p√°gina posterior del nivel inferior se podr√° escribir, incluso si hay indicadores que permiten la escritura. <br><br>  Aunque este ejemplo usa solo una instancia de cada tabla, generalmente en cada espacio de direcciones hay varias instancias de cada nivel.  M√°ximo: <br><br><ul><li>  una mesa del cuarto nivel, </li><li>  512 tablas del tercer nivel (ya que hay 512 registros en la tabla del cuarto nivel), </li><li>  512 * 512 tablas de segundo nivel (ya que cada una de las tablas de tercer nivel tiene 512 entradas), y </li><li>  512 * 512 * 512 tablas del primer nivel (512 registros para cada tabla del segundo nivel). </li></ul><br><h3>  Formato de tabla de p√°gina </h3><br>  En la arquitectura x86_64, las tablas de p√°ginas son esencialmente matrices de 512 entradas.  En sintaxis de Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br>  Como se indica en el atributo <code>repr</code> , las tablas deben estar alineadas en la p√°gina, es decir, en el borde de 4 KB.  Este requisito asegura que la tabla siempre llene de manera √≥ptima toda la p√°gina, haciendo que las entradas sean muy compactas. <br><br>  El tama√±o de cada registro es de 8 bytes (64 bits) y el siguiente formato: <br><br><table><thead><tr><th>  Bit (s) </th><th>  Titulo </th><th>  Valor </th></tr></thead><tbody><tr><td>  0 0 </td><td>  presente </td><td>  p√°gina en memoria </td></tr><tr><td>  1 </td><td>  grabable </td><td>  registro permitido </td></tr><tr><td>  2 </td><td>  accesible para el usuario </td><td>  si el bit no est√° configurado, solo el n√∫cleo tiene acceso a la p√°gina </td></tr><tr><td>  3 </td><td>  escribir a trav√©s del almacenamiento en cach√© </td><td>  escribir directamente en la memoria </td></tr><tr><td>  4 4 </td><td>  deshabilitar cach√© </td><td>  deshabilitar cach√© para esta p√°gina </td></tr><tr><td>  5 5 </td><td>  accedido </td><td>  La CPU establece este bit cuando la p√°gina est√° en uso. </td></tr><tr><td>  6 6 </td><td>  sucio </td><td>  La CPU establece este bit cuando escribe en la p√°gina </td></tr><tr><td>  7 7 </td><td>  p√°gina enorme / nula </td><td>  el bit cero en P1 y P4 crea p√°ginas de 1 KB en P3, p√°gina de 2 MB en P2 </td></tr><tr><td>  8 </td><td>  global </td><td>  la p√°gina no se llena desde el cach√© al cambiar el espacio de direcciones (se debe establecer el bit PGE del registro CR4) </td></tr><tr><td>  9-11 </td><td>  disponible </td><td>  El sistema operativo puede usarlos libremente </td></tr><tr><td>  12-51 </td><td>  direcci√≥n f√≠sica </td><td>  direcci√≥n f√≠sica de 52 bits alineada con la p√°gina de la trama o la siguiente tabla de p√°ginas </td></tr><tr><td>  52-62 </td><td>  disponible </td><td>  El sistema operativo puede usarlos libremente </td></tr><tr><td>  63 </td><td>  no ejecutar </td><td>  proh√≠be la ejecuci√≥n de c√≥digo en esta p√°gina (el bit NXE debe establecerse en el registro EFER) </td></tr></tbody></table><br>  Vemos que solo los bits 12-51 se utilizan para almacenar la direcci√≥n f√≠sica de la trama, y ‚Äã‚Äãel resto funciona como indicadores o puede ser utilizado libremente por el sistema operativo.  Esto es posible porque siempre apuntamos a una direcci√≥n alineada con 4096 bytes, a una p√°gina alineada de tablas, o al comienzo del marco correspondiente.  Esto significa que los bits 0-11 siempre son cero, por lo que no se pueden almacenar, simplemente se restablecen al nivel de hardware antes de usar la direcci√≥n.  Lo mismo se aplica a los bits 52-63, ya que la arquitectura x86_64 solo admite direcciones f√≠sicas de 52 bits (y solo direcciones virtuales de 48 bits). <br><br>  Echemos un vistazo m√°s de cerca a las banderas disponibles: <br><br><ul><li>  La bandera <code>present</code> distingue las p√°ginas mostradas de las que no se muestran.  Se puede usar para guardar temporalmente p√°ginas en el disco cuando la memoria principal est√° llena.  La pr√≥xima vez que se accede a la p√°gina, se produce una excepci√≥n especial PageFault, a la que el sistema operativo responde intercambiando la p√°gina desde el disco; el programa contin√∫a funcionando. </li><li>  Las <code>writable</code> y <code>no execute</code> determinan si el contenido de la p√°gina es grabable o contiene instrucciones ejecutables, respectivamente. </li><li>  El procesador establece autom√°ticamente <code>dirty</code> marcas <code>dirty</code> y a las que <code>accessed</code> cuando lee o escribe en la p√°gina.  El sistema operativo puede usar esta informaci√≥n, por ejemplo, si intercambia p√°ginas o cuando verifica si el contenido de la p√°gina ha cambiado desde la √∫ltima extracci√≥n al disco. </li><li>  Las <code>write through caching</code> y <code>disable cache</code> permiten administrar el cach√© para cada p√°gina individualmente. </li><li>  El indicador <code>user accessible</code> hace que la p√°gina sea accesible para el c√≥digo desde el espacio del usuario; de lo contrario, solo est√° disponible para el n√∫cleo.  Esta funci√≥n se puede usar para acelerar las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamadas al sistema</a> mientras se mantiene la asignaci√≥n de direcciones para el n√∫cleo mientras se ejecuta el programa de usuario.  Sin embargo, la vulnerabilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spectre</a> permite a los programas leer estas p√°ginas desde el espacio del usuario. </li><li>  <code>global</code>  ,                (.   TLB )     (address space switch).     user <code>accessible</code>        . </li><li>  <code>huge page</code>     ,      2  3     .      512 :     2  = 512 √ó 4 ,      1  = 512 √ó 2 .             . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura x86_64 define el formato </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de las tablas de p√°gina</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y sus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que no tenemos que crear estas estructuras nosotros mismos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memoria intermedia de traducci√≥n asociativa (TLB) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a los cuatro niveles, cada traducci√≥n de direcci√≥n requiere cuatro accesos a la memoria. Por motivos de rendimiento, x86_64 almacena en cach√© las √∫ltimas traducciones en el denominado b√∫fer de traducci√≥n asociativa (TLB). Esto le permite omitir la conversi√≥n si todav√≠a est√° en la memoria cach√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferencia de otros cach√©s de procesador, TLB no es completamente transparente, no actualiza ni elimina conversiones al cambiar el contenido de las tablas de p√°ginas. Esto significa que el n√∫cleo debe actualizar el TLB en s√≠ mismo siempre que modifique la tabla de p√°ginas. Para hacer esto, hay una instrucci√≥n especial de CPU llamada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>invlpg</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(invalidar p√°gina), que elimina la traducci√≥n de la p√°gina especificada del TLB, de modo que la pr√≥xima vez que se vuelva a cargar de la tabla de p√°ginas. TLB se borra completamente mediante la recarga del registro</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que imita un interruptor de espacio de direcciones. </font><font style="vertical-align: inherit;">Ambas opciones est√°n disponibles a </font><font style="vertical-align: inherit;">trav√©s del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo tlb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es importante recordar limpiar el TLB despu√©s de cada cambio de tabla de p√°ginas, de lo contrario, la CPU continuar√° utilizando la traducci√≥n anterior, lo que conducir√° a errores impredecibles que son muy dif√≠ciles de depurar.</font></font><br><br><h1>  Implementaci√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No mencionamos una cosa: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuestro n√∫cleo ya es compatible con la organizaci√≥n de la p√°gina</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El gestor de arranque del art√≠culo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Minimal Kernel on Rust"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya ha establecido una jerarqu√≠a de cuatro niveles que asigna cada p√°gina de nuestro kernel a un marco f√≠sico, porque la organizaci√≥n de la p√°gina se requiere en modo de 64 bits en x86_64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto significa que en nuestro n√∫cleo todas las direcciones de memoria son virtuales. El acceso al b√∫fer VGA en la direcci√≥n </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funcion√≥ solo porque el identificador del gestor de arranque </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tradujo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esta p√°gina a la memoria, es decir, asign√≥ la p√°gina virtual </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al marco f√≠sico </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a la organizaci√≥n de la p√°gina, el n√∫cleo ya es relativamente seguro: cada acceso m√°s all√° de la memoria permitida provoca un error de p√°gina y no permite escribir en la memoria f√≠sica. </font><font style="vertical-align: inherit;">El cargador incluso estableci√≥ los permisos de acceso correctos para cada p√°gina: solo las p√°ginas con c√≥digo ser√°n ejecutables, y solo las p√°ginas con datos est√°n disponibles para escribir</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Errores de p√°gina (PageFault) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intentemos llamar a PageFault accediendo a la memoria fuera del n√∫cleo. </font><font style="vertical-align: inherit;">Primero, cree un controlador de errores y reg√≠strelo en nuestro IDT para ver una excepci√≥n espec√≠fica en lugar de un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doble error de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo general:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); [‚Ä¶] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la p√°gina falla, la CPU establece autom√°ticamente el caso </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>CR2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Contiene la direcci√≥n virtual de la p√°gina que caus√≥ la falla. Para leer y mostrar esta direcci√≥n, use la funci√≥n </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cr2::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo general, el tipo </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PageFaultErrorCode</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proporciona m√°s informaci√≥n sobre el tipo de acceso a la memoria que caus√≥ el error, pero </font><font style="vertical-align: inherit;">se transmite </font><font style="vertical-align: inherit;">un </font><font style="vertical-align: inherit;">c√≥digo de error no v√°lido </font><font style="vertical-align: inherit;">debido al </font><font style="vertical-align: inherit;">error </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que ignoraremos esta informaci√≥n por ahora. La ejecuci√≥n del programa no puede continuar hasta que resolvamos el error de la p√°gina, as√≠ que inserte al final </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hlt_loop</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos acceso a la memoria fuera del n√∫cleo:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de comenzar, vemos que se llama al controlador de errores de p√°gina: el </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registro </font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente contiene la direcci√≥n a la </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que quer√≠amos acceder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El puntero de instrucci√≥n actual es </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que sabemos que esta direcci√≥n apunta a una p√°gina de c√≥digos. </font><font style="vertical-align: inherit;">El cargador de solo lectura muestra las p√°ginas de c√≥digos, por lo que la lectura de esta direcci√≥n funciona y la escritura provocar√° un error. </font><font style="vertical-align: inherit;">Intente cambiar el puntero </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si comentamos la √∫ltima l√≠nea, podemos asegurarnos de que la lectura funcione y que la escritura provoque un error de PageFault. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acceso a tablas de p√°ginas. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora eche un vistazo a las tablas de p√°ginas para el n√∫cleo: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cr3::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve del registro la </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabla activa actual de p√°ginas del cuarto nivel. Vuelve una pareja </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PhysFrame</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cr3Flags</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Solo nos interesa lo primero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de comenzar, vemos este resultado: por lo </font></font><br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanto, en la actualidad, la tabla activa de p√°ginas del cuarto nivel se almacena en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memoria </font><i><font style="vertical-align: inherit;">f√≠sica</font></i><font style="vertical-align: inherit;"> en la direcci√≥n </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicada por el tipo </font></font><code>PhysAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ahora la pregunta es: ¬øc√≥mo acceder a esta tabla desde el n√∫cleo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la organizaci√≥n de la p√°gina, el acceso directo a la memoria f√≠sica no es posible; de ‚Äã‚Äãlo contrario, los programas podr√°n eludir f√°cilmente la protecci√≥n y obtener acceso a la memoria de otros programas. Por lo tanto, la √∫nica forma de obtener acceso es a trav√©s de alguna p√°gina virtual, que se traduce en un marco f√≠sico en</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es un problema t√≠pico porque el n√∫cleo deber√≠a acceder regularmente a las tablas de p√°ginas, por ejemplo, al asignar una pila para un nuevo hilo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las soluciones a este problema se describir√°n en detalle en el pr√≥ximo art√≠culo. Por ahora, digamos que el cargador utiliza un m√©todo llamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tablas de p√°ginas recursivas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La √∫ltima p√°gina del espacio de direcciones virtuales es </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la usamos para leer algunas entradas en esta tabla:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hemos reducido la direcci√≥n de la √∫ltima p√°gina virtual a un puntero a </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como se indic√≥ en la secci√≥n anterior, cada entrada de la tabla de p√°ginas tiene un tama√±o de 8 bytes (64 bits) y, por lo tanto, </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">representa exactamente una entrada. Usando el bucle, </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostramos los primeros 10 registros de la tabla. Dentro del bucle, usamos un bloque inseguro para leer directamente desde el puntero y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> offset</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcular el puntero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de iniciar vemos los siguientes resultados: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De acuerdo con el formato descrito anteriormente, el valor </font></font><code>0x2023</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medio de grabaci√≥n que tiene banderas 0 </font></font><code>present</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>writable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>accessed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la traducci√≥n en un marco </font></font><code>0x2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El registro 1 se transmite en el marco </font></font><code>0x6e2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y tiene las mismas banderas, adem√°s</font></font><code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Faltan las entradas 2‚Äì9, por lo que estos rangos de direcciones virtuales no se asignan a ninguna direcci√≥n f√≠sica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de trabajar con punteros inseguros directamente, puede usar un tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } [‚Ä¶] }</span></span></code> </pre> <br>     <code>0xffff_ffff_ffff_f000</code>  ,       Rust.  - ,      ,      .        <code>&amp;PageTable</code> ,        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . <br><br> <code>x86_64</code>       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br>   ‚Äî      0   1     3.       ,  <code>0x2000</code>  <code>0x6e5000</code>    ,         .       . <br><br><h1>  Resumen </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El art√≠culo presenta dos m√©todos para proteger la memoria: segmentaci√≥n y organizaci√≥n de la p√°gina. El primer m√©todo usa √°reas de memoria de tama√±o variable y sufre fragmentaci√≥n externa, el segundo usa p√°ginas de tama√±o fijo y permite un control mucho m√°s granular sobre los derechos de acceso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una organizaci√≥n de p√°ginas almacena informaci√≥n de traducci√≥n de p√°ginas en tablas de uno o m√°s niveles. La arquitectura x86_64 usa tablas de cuatro niveles con un tama√±o de p√°gina de 4 KB. El equipo omite autom√°ticamente las tablas de p√°ginas y almacena en cach√© los resultados de conversi√≥n en el b√∫fer de traducci√≥n asociativa (TLB). Al cambiar las tablas de p√°ginas, debe forzarse a limpiar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprendimos que nuestro n√∫cleo ya es compatible con la organizaci√≥n de la p√°gina, y que el acceso no autorizado a la memoria deja caer PageFault. </font><font style="vertical-align: inherit;">Intentamos acceder a las tablas de p√°gina actualmente activas, pero logramos acceder solo a la tabla de cuarto nivel, ya que las direcciones de p√°gina almacenan direcciones f√≠sicas, y no podemos acceder a ellas directamente desde el n√∫cleo.</font></font><br><br><h1>  Que sigue </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente art√≠culo se basa en los fundamentos fundamentales que ahora hemos aprendido. </font><font style="vertical-align: inherit;">Para acceder a las tablas de p√°ginas desde el kernel, </font><font style="vertical-align: inherit;">se utiliza </font><font style="vertical-align: inherit;">una t√©cnica avanzada llamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tablas de p√°ginas recursivas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para recorrer la jerarqu√≠a de tablas e implementar la traducci√≥n program√°tica de direcciones. </font><font style="vertical-align: inherit;">El art√≠culo tambi√©n explica c√≥mo crear nuevas traducciones en tablas de p√°ginas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436606/">https://habr.com/ru/post/es436606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436594/index.html">Adi√≥s Chevy Volt: Historias y leyendas del h√≠brido recargable</a></li>
<li><a href="../es436596/index.html">Los desarrolladores de pila completa est√°n de hecho atrapados en el nivel medio. Ah√≥rrate el sufrimiento, no sigas ese camino</a></li>
<li><a href="../es436598/index.html">Un paso gigante para una m√°quina de ajedrez</a></li>
<li><a href="../es436600/index.html">Derechos de autor superados y coreografiados: creadores de Fortnite demandados por personajes de baile</a></li>
<li><a href="../es436602/index.html">M√≥dulo de carga Dawn: 20 a√±os en √≥rbita</a></li>
<li><a href="../es436608/index.html">[SAP] SAPUI5 para dummies: un ejercicio completo paso a paso</a></li>
<li><a href="../es436610/index.html">C√≥mo funciona la especificidad CSS en un navegador</a></li>
<li><a href="../es436612/index.html">Brian Krebs: base de datos de cuentas de megafugas que contiene cientos de millones de registros, 2-3 a√±os</a></li>
<li><a href="../es436614/index.html">Tesla reducir√° el n√∫mero de empleados permanentes en todo el mundo en un 7%</a></li>
<li><a href="../es436616/index.html">C√≥mo funciona Singapur con la innovaci√≥n: de la regulaci√≥n gubernamental a los clubes nocturnos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>