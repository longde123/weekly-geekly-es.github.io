<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèæ üëåüèª ü§æüèø Ataques de hardware a microcontroladores usando ChipWhisperer y m√©todos de protecci√≥n contra ellos üë¶üèΩ ü•Å üë©‚Äç‚ù§Ô∏è‚Äçüë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los ataques de hardware representan una gran amenaza para todos los dispositivos con microcontroladores (en adelante, MK), ya que pueden eludir varios...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ataques de hardware a microcontroladores usando ChipWhisperer y m√©todos de protecci√≥n contra ellos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/480500/"><img src="https://habrastorage.org/webt/fm/dm/6l/fmdm6lpgrxzzbswipqkegkikcda.png" align="left"><br><p>  Los ataques de hardware representan una gran amenaza para todos los dispositivos con microcontroladores (en adelante, MK), ya que pueden eludir varios mecanismos de seguridad.  Es dif√≠cil defenderse de tales ataques usando software o hardware.  Por ejemplo, puede leer <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/group1/9f/0b/e4/b6/75/15/4f/e2/DM00493651/files/DM00493651.pdf/jcr:content/translations/en.DM00493651.pdf">un art√≠culo</a> de STMicroelectronics sobre varios tipos de ataques de hardware y m√©todos para proteger MK. <br>  Nosotros, el equipo de Raccoon Security, estamos interesados ‚Äã‚Äãen este tema, ya que una de las √°reas de actividad de nuestra empresa es el desarrollo de dispositivos integrados, incluidos los que contienen mecanismos de protecci√≥n de la informaci√≥n.  En su mayor parte, estamos interesados ‚Äã‚Äãen los ataques de falla, ya que le permiten pasar las instrucciones MK ejecutables.  Esta es una seria amenaza para la informaci√≥n confidencial contenida en MK, y la consecuencia m√°s peligrosa de tales ataques es leer el firmware cerrado, sin pasar por los mecanismos de seguridad proporcionados por los desarrolladores de MK. </p><br><p>  En Hardwear.io 2018 en La Haya y EmbeddedWorld 2019 en Nuremberg, NewAE demostr√≥ el dispositivo ChipWhisperer, que permite la implementaci√≥n de esa parte de los ataques de hardware no invasivos que no requieren un conocimiento profundo de la nanoelectr√≥nica y la disponibilidad de equipos espec√≠ficos.  Usando este dispositivo, estudiamos la seguridad de los dispositivos integrados y descubrimos c√≥mo minimizar el resultado de tales ataques.  Debajo del corte, lo que hicimos. </p><a name="habracut"></a><br><p>  <strong>Chipwhisperer</strong> </p><br><p> El kit ChipWhisperer es un kit de herramientas de c√≥digo abierto para analizar la seguridad de los MK m√°s populares (STM, Xmega, Intel D2000, SAM, LPC, MSP, 78K y otros) y FPGA.  El proyecto comenz√≥ el 27 de febrero de 2015 en <a href="https://www.kickstarter.com/projects/coflynn/chipwhisperer-lite-a-new-era-of-hardware-security">Kickstarter</a> .  Por el momento, hay diferentes versiones de ChipWhisperer (todas las opciones se pueden encontrar en el <a href="http://newae.com/catalogue/">cat√°logo</a> ).  Tienen un conjunto diferente de herramientas, pero generalmente est√°n orientados a los siguientes tipos de ataques de hardware: </p><br><p>  ‚Ä¢ ataques de canal lateral (SCA); </p><br><p>  ‚Ä¢ ataques de falla. </p><br><p>  Para un an√°lisis m√°s detallado, elegimos ChipWhisperer-Pro (CW1200), que es el modelo ChipWhisperer m√°s antiguo en este momento y tiene una amplia funcionalidad y un gran paquete: </p><br><img src="https://habrastorage.org/webt/w9/-h/fp/w9-hfpu2mqywy9imc05cxdss4z4.jpeg"><br><p>  <em>Kit ChipWhisperer (CW1200)</em> </p><br><p>  A bordo, el CW1200 tiene un osciloscopio, que consiste en un amplificador ajustable y un ADC con una muestra de 105 MSPS.  Este conjunto de herramientas le permite registrar el nivel de se√±al en cent√©simas de milivoltios y obtener una buena base de tiempo.  Tambi√©n en el CW1200 hay puertos para organizar CLK-glitch y Vcc-glitch, puertos GPIO que pueden asignarse como disparadores de entrada para rastrear el origen de un evento (solicitud de ingreso de contrase√±a, estado de descarga, etc.).  El CW1200 se conecta a una PC a trav√©s de USB y tiene dos protocolos de comunicaci√≥n con MK: UART y SPI. </p><br><p>  Para trabajar con ChipWhisperer, debe instalar controladores, descargar bibliotecas de Python y ejemplos de trabajo de <a href="https://github.com/newaetech/chipwhisperer/releases">GitHub,</a> o descargar la imagen preparada de una m√°quina virtual en Linux, en la que todas las bibliotecas y ejemplos de trabajo est√°n preinstalados.  Estas bibliotecas abiertas contienen: </p><br><p>  ‚Ä¢ protocolo de comunicaci√≥n con ChipWhisperer; </p><br><p>  ‚Ä¢ algoritmos matem√°ticos para procesar ataques en m√©todos de encriptaci√≥n populares; </p><br><p>  ‚Ä¢ protocolos para comunicarse con los gestores de arranque de MK populares; </p><br><p>  ‚Ä¢ firmware preparado para el entrenamiento en las placas con MK, incluido en el kit. </p><br><p>  Decidimos revisar todos los tutoriales <a href="https://wiki.newae.com/">en el antiguo</a> sitio <a href="https://wiki.newae.com/">web de</a> NewAE.  Ahora se est√° desarrollando otro <a href="https://chipwhisperer.readthedocs.io/en/latest/index.html">recurso</a> , donde se presenta informaci√≥n m√°s relevante y hay un <a href="https://forum.newae.com/">foro</a> . </p><br><p>  En este art√≠culo, presentaremos solo algunos ejemplos de gu√≠as de los desarrolladores de ChipWhisperer y las implementaremos no en las placas con MK que se incluyen en el paquete, sino en el STM32F103RBT6: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Junta STM32F103RBT6</em> </p><br><p>  Tambi√©n escribimos c√≥digo id√©ntico a sus ejemplos preparados, pero con bibliotecas HAL generadas a partir de CubeMX.  Todas estas acciones son necesarias para confirmar que los ataques con ChipWhisperer se pueden implementar en cualquier dispositivo aleatorio, y no solo en las placas presentes en el kit. </p><br><p>  A continuaci√≥n, ofrecemos una breve descripci√≥n general y ejemplos de ataques SCA y ataques de falla. </p><br><p>  <strong>An√°lisis SCA</strong> </p><br><p>  La base de los ataques SCA es rastrear los cambios en los factores externos del estado de la MC (consumo actual de la MC, temperatura, campo electromagn√©tico) durante el desarrollo de varias instrucciones.  ChipWhisperer implementa canales para monitorear la energ√≠a usando un ADC y un campo electromagn√©tico usando una antena. </p><br><p>  El an√°lisis SCA es efectivo para detectar contrase√±as, claves de cifrado, etc.  El sitio web de NewAE presenta muchas caracter√≠sticas <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_dpa_1-openadc-cwlitearm.html%2522/l%2522tutorial-pa-dpa-1-openadc-cwlitearm">diferentes</a> <br>  <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_multi_1-openadc-cwlitearm.html">Pautas</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_cpa_1-openadc-cwlitearm.html">√∫tiles</a> para encontrar <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_multi_1-openadc-cwlitearm.html">claves de cifrado</a> y para <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_tvla_1-openadc-cwlitearm.html">ataques</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_profiling_1-openadc-cwlitearm.html">SCA</a> , pero daremos solo un ejemplo de an√°lisis SCA, ya que los ataques de falla son de gran inter√©s para nosotros. </p><br><p>  <strong>Ejemplo de ataques SCA: an√°lisis de firma de potencia</strong> </p><br><p> Esta <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_spa_1-openadc-cwlitearm.html">gu√≠a</a> muestra un tipo de ataque SCA: el seguimiento de la entrada de contrase√±a car√°cter por car√°cter mediante el monitoreo de las firmas en el canal de alimentaci√≥n.  Al repetir las firmas de energ√≠a, es posible identificar el desarrollo de varias instrucciones de programa dentro del MK.  El ejemplo anterior demuestra el desarrollo de la entrada de contrase√±a MK mediante el seguimiento de la firma de la operaci√≥n de <code>break</code> . </p><br><p>  Comencemos la preparaci√≥n.  En primer lugar, debe hacer las conexiones de acuerdo con la figura: </p><br><img src="https://habrastorage.org/webt/vk/cv/gu/vkcvguq0vvlgyivzanufkixv-8e.jpeg"><br><p>  <em>Conexi√≥n MC para an√°lisis SCA</em> </p><br><p>  El diagrama tacha componentes que no necesitan estar conectados (a diferencia de la conexi√≥n MK est√°ndar).  Las flechas indican los puntos de conexi√≥n de ChipWhisperer, y las firmas indican sus pines. </p><br><p>  Prepare el firmware MK.  La siguiente funci√≥n est√° en el ciclo principal while <code>while(1)</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">028</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">password_check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">029</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwd[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-number"><span class="hljs-number">030</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> correct_passwd[] = <span class="hljs-string"><span class="hljs-string">"Vulkan"</span></span>; <span class="hljs-number"><span class="hljs-number">031</span></span> HAL_Delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-number"><span class="hljs-number">032</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"WARNING: UNAUTHORIZED ACCESS WILL BE PUNISHED\n"</span></span>); <span class="hljs-number"><span class="hljs-number">033</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">034</span></span> <span class="hljs-number"><span class="hljs-number">035</span></span> <span class="hljs-comment"><span class="hljs-comment">//Get password 036 uart_send("Please enter password to continue: "); 037 uart_receive(passwd, 32); 038 039 uint8_t passbad = 0; 040 041 led_on(); 042 043 for(uint8_t i = 0; i &lt; sizeof(correct_passwd); i++) 044 { 045 if (correct_passwd[i] != passwd[i]) 046 { 047 passbad = 1; 048 break; 049 } 050 } 051 052 if (passbad) 053 { 054 //Stop them fancy timing attacks 055 int wait = rand() % 100000; 056 for(volatile int i = 0; i &lt; wait; i++) 057 { 058 ; 059 } 060 HAL_Delay(4); 061 uart_send("PASSWORD FAIL\n"); 062 } 063 else 064 { 065 uart_send("Access granted, Welcome!\n"); 066 } 067 while(1) 068 { 069 ; 070 } 071 }</span></span></code> </pre> <br><p>  La l√≠nea 030 establece la contrase√±a para la entrada: Vulkan.  Luego, el LED se enciende <br>  <code>led_on()</code> y se env√≠a un mensaje UART sobre la solicitud de contrase√±a.  La funci√≥n <code>led_on()</code> activa el pin GPIO de PA12 MK y notifica un evento con respecto al cual ChipWhisperer comenzar√° a acumular formas de onda.  Es a este pin que CW_TRIG debe estar conectado.  Todo esto se "sintetiza" por conveniencia, pero en casos reales la diferencia ser√° insignificante, ya que puede ingresar un retraso de tiempo en la cantidad de ciclos de reloj RELOJ en relaci√≥n con cualquier evento al que est√© conectado CW_TRIG.  Por ejemplo, puede ser el inicio de la descarga de MK, la recepci√≥n / transmisi√≥n de mensajes, la inclusi√≥n de un LED, etc. </p><br><p>  Adem√°s, MK espera a que se ingrese una contrase√±a, que verificar√° car√°cter por car√°cter.  Si alg√∫n car√°cter de la cola no coincide, por ejemplo, tres caracteres son correctos y el cuarto no, entonces debe salir del bucle for con la instrucci√≥n <code>break</code> e informar la contrase√±a incorrecta.  En las l√≠neas 055‚Äì059, se implementa un generador de retardo aleatorio.  Este dise√±o se usa con mayor frecuencia para complicar la realizaci√≥n de ataques temporales (es decir, rastrear cambios en el tiempo de respuesta de todo el sistema).  Este dise√±o se incluye para comprender que no seleccionamos una contrase√±a utilizando el m√©todo de ataque temporal. </p><br><p>  El c√≥digo tutorial de Jupyter Python est√° alojado en el <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_spa_1-openadc-cwlitearm.html%2522/l%2522tutorial-pa-spa-1-openadc-cwlitearm">recurso</a> correspondiente.  La siguiente figura muestra un ejemplo de introducci√≥n de una contrase√±a con la salida de la forma de onda de la fuente de alimentaci√≥n del MK con cada nuevo s√≠mbolo correcto.  Tenga en cuenta que con el ingreso de caracteres de la contrase√±a correcta (la contrase√±a a ingresar se muestra en la parte superior de la figura), la firma de la operaci√≥n de <code>break</code> se desplaza a la l√≠nea 046 (resaltada en naranja en la figura a continuaci√≥n).  Esta es la "debilidad" de la interrupci√≥n por la operaci√≥n de <code>break</code> cuando se verifica la contrase√±a por contrase√±a. </p><br><img src="https://habrastorage.org/webt/eu/6p/xf/eu6pxfivltkrmfs5pa-ryxugvam.png"><br><p>  <em>Oscilogramas de contrase√±a</em> </p><br><p>  Como resultado de la familiarizaci√≥n con esta gu√≠a, descubrimos lo f√°cil que es eludir la protecci√≥n con contrase√±a con este enfoque para verificarlo mediante el an√°lisis SCA.  Es suficiente comentar la operaci√≥n de <code>break</code> en la l√≠nea 048 en este firmware y, en general, la verificaci√≥n de contrase√±a ser√° tan exitosa, pero el procesamiento del seguimiento de firmas se volver√° m√°s complicado.  Por lo tanto, para reducir la efectividad de tales ataques, debe evitar la operaci√≥n de interrupci√≥n inmediata de los ciclos de exploraci√≥n. </p><br><p>  La complejidad de este an√°lisis radica en encontrar las firmas necesarias.  Por lo tanto, realizar tales ataques puede complicar significativamente la introducci√≥n de construcciones temporales de <code>rand()</code> en el momento de la verificaci√≥n de la contrase√±a, agregar c√°lculos adicionales o agregar ruido a otros componentes. </p><br><p>  <strong>Ataques de falla</strong> </p><br><p>  Los ataques de falla se llevan a cabo mediante una serie de impulsos a corto plazo en un momento exacto seg√∫n un determinado m√©todo de influencia.  Los m√©todos m√°s populares son: reloj (falla CLK), potencia (falla Vcc) y campo electromagn√©tico.  El campo electromagn√©tico es generado por una chispa de alto voltaje cerca del MC.  Para esto, NewAE utiliza equipos <a href="http://store.newae.com/chipshouter-kit/">ChipSHOUTER</a> .  No lo compramos, por lo que solo realizamos los ataques CLK-glitch y Vcc-glitch. </p><br><p>  Los ataques de falla se llevan a cabo agregando un pulso de voltaje: para falla de CLK - a la se√±al de RELOJ externa del MK (de un cuarzo o generador externo), para falla de Vcc - en potencia. </p><br><p>  En general, los ataques de falla le permiten omitir cualquier instrucci√≥n MK, por ejemplo, ingresar una contrase√±a, solicitud de acceso, acuerdo de licencia, etc.  Los ataques de falla son m√°s complejos, laboriosos y lentos.  Adem√°s, es necesario repetir repetidamente el ataque de falla, ya que su √©xito es de naturaleza probabil√≠stica y depende de los par√°metros del pulso.  Las siguientes son opciones de falla: </p><br><p>  ‚Ä¢ scope.glitch.width - ancho de pulso en porcentaje relativo a CLOCK; </p><br><p>  ‚Ä¢ scope.glitch.offset: desplazamiento de impulso en porcentaje relativo a CLOCK; </p><br><p>  ‚Ä¢ scope.glitch.repeat: el n√∫mero de repeticiones de pulsos de ataque; </p><br><p>  ‚Ä¢ scope.glitch.ext_offset: el n√∫mero de medidas omitidas despu√©s del desencadenante del evento. </p><br><p>  Las asignaciones de glitch para CLK-glitch y Vcc-glitch se muestran en los diagramas de tiempos: </p><br><img src="https://habrastorage.org/webt/ll/cs/vb/llcsvbaocipt0fz1rwtrgpswzka.jpeg"><br><p>  <em>Diagrama de tiempos para CLK-glitch</em> </p><br><img src="https://habrastorage.org/webt/yc/fr/k5/ycfrk5slksrrxh5sjpcgvv4uons.jpeg"><br><p>  <em>Diagrama de tiempos para Vcc-glitch</em> </p><br><p>  Todos los par√°metros del pulso de falla se seleccionan para que el n√∫cleo MK funcione en un modo inestable (debido a que se omiten las instrucciones). </p><br><p>  Seg√∫n los resultados de los ataques fallidos, se revel√≥ que si el valor del par√°metro scope.glitch.repeat es demasiado peque√±o, no se produce el "deslizamiento" de las instrucciones.  Si establece un valor grande, puede omitir no solo las instrucciones necesarias, sino tambi√©n todas las posteriores.  En la mayor√≠a de los casos, buscar scope.glitch.repeat en la regi√≥n de 5‚Äì25 es suficiente.  Con respecto a otros par√°metros, todo depende del tipo de ataque y las condiciones de conexi√≥n. </p><br><p>  <strong>Falla de CLK</strong> </p><br><p>  Los ataques de falla CLK se llevan a cabo agregando pulsos de menor duraci√≥n a la se√±al CLOCK MK.  Por lo tanto, CLOCK debe estar desconectado del MK y alimentarlo desde ChipWhisperer ya con un ataque de falla CLK. </p><br><p>  Primero necesitas conectar ChipWhisperer a MK: </p><br><img src="https://habrastorage.org/webt/dr/2l/w_/dr2lw_3vrw7t5rcmz5bfuotngno.jpeg"><br><p>  <em>Diagrama de conexi√≥n para CLK-glitch</em> </p><br><p>  Todo el c√≥digo Python y una descripci√≥n detallada del manual se presentan en el <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html%2522/l%2522tutorial-fault-1-openadc-cwlitearm">recurso</a> .  Luego, en STM32F103RBT6, "llene" el firmware, donde se agrega la siguiente funci√≥n al <code>while(1)</code> principal <code>while(1)</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">075</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glitch_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 076 </span></span>{ <span class="hljs-number"><span class="hljs-number">077</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> inp[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-number"><span class="hljs-number">078</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; <span class="hljs-number"><span class="hljs-number">079</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">080</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"Password:"</span></span>); <span class="hljs-number"><span class="hljs-number">081</span></span> <span class="hljs-number"><span class="hljs-number">082</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((c != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &amp; (cnt &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)) <span class="hljs-number"><span class="hljs-number">083</span></span> { <span class="hljs-number"><span class="hljs-number">084</span></span> c = getch(); <span class="hljs-number"><span class="hljs-number">085</span></span> inp[cnt] = c; <span class="hljs-number"><span class="hljs-number">086</span></span> cnt++; <span class="hljs-number"><span class="hljs-number">087</span></span> } <span class="hljs-number"><span class="hljs-number">088</span></span> <span class="hljs-number"><span class="hljs-number">089</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwd[] = <span class="hljs-string"><span class="hljs-string">"Vulkan"</span></span>; <span class="hljs-number"><span class="hljs-number">090</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passok = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">091</span></span> <span class="hljs-number"><span class="hljs-number">092</span></span> led_on(); <span class="hljs-number"><span class="hljs-number">093</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">094</span></span> <span class="hljs-number"><span class="hljs-number">095</span></span> <span class="hljs-comment"><span class="hljs-comment">//Simple test - doesn't check for too-long password! 096 for(cnt = 0; cnt &lt; 5; cnt++) 097 { 098 if (inp[cnt] != passwd[cnt]) 099 { 100 passok = 0; 101 } 102 } 103 if (!passok){ 104 uart_send("Denied\n"); 105 } 106 else 107 { 108 uart_send("Wow! Vulkan win!\n"); 109 } 110 }</span></span></code> </pre> <br><p>  Nuestro objetivo es omitir la <code>if</code> en la l√≠nea 103 al ingresar la contrase√±a incorrecta y entrar en el caso <code>else</code> en la l√≠nea 106. Lo m√°s importante en este ataque es verificar la variable <code>passok</code> en la l√≠nea 103. Para hacer esto, seleccione el par√°metro scope.glitch.ext_offset.  Esto es m√°s f√°cil de hacer conectando el osciloscopio al UART y configurando la falla en la ubicaci√≥n de la interferencia, ya que la falla se filtra a trav√©s de todo el MK: </p><br><img src="https://habrastorage.org/webt/de/3q/hv/de3qhvyf89kklulihenck7loqfk.jpeg"><br><p>  <em>Ubicaci√≥n de falla</em> </p><br><p>  El c√≥digo de ataque y la metodolog√≠a est√°n tomados de este <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html">manual</a> (secci√≥n de bucle de ataque, bloques 9-10).  Lo √∫nico que cambiamos en el c√≥digo fue habilitar la salida de todos los mensajes de <code>print(response)</code> sin filtrar, ya que los eventos importantes a menudo se omiten debido a filtros configurados como: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_response <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"!"</span></span>)</code> </pre> <br><p>  Las siguientes figuras muestran ejemplos de un registro de salida de mensaje que aparece cuando un ataque de falla de CLK est√° cerca del √©xito o est√° lejos de tener √©xito.  Al acercarse a los par√°metros de falla correctos, comienzan a aparecer inestabilidades en la operaci√≥n del MK (los mensajes se rompen, el MK se reinicia).  Esto puede ser una pista al buscar. </p><br><img src="https://habrastorage.org/webt/hf/n2/b1/hfn2b1ds3gqlkhuwmg0knrjlp98.png"><br><p>  <em>Salida de mensaje durante un ataque de falla con par√°metros que est√°n lejos de ser exitosos (a) y cercanos al √©xito (b)</em> </p><br><img src="https://habrastorage.org/webt/e_/hy/t7/e_hyt75mrika_metrq8tzrvu518.png"><br><p>  <em>El resultado de un exitoso ataque CLK-glitch</em> </p><br><p>  Como resultado de los ataques, se revel√≥ que los par√°metros del pulso de falla CLK pueden "flotar" dependiendo de la calidad de la conexi√≥n ChipWhisperer al CLOCK MK.  Por ejemplo, al configurar la sonda del osciloscopio en el pin CLOCK, el par√°metro scope.glitch.offset se volvi√≥ diferente para un ataque exitoso, ya que la sonda tiene sus propios par√°metros capacitivos inductivos que corrigen la falla de alta frecuencia.  Por lo tanto, la conexi√≥n a trav√©s de un cable largo sin blindaje puede traer sus sorpresas.  De lo contrario, los ataques CLK-glitch pueden llamarse estables, como  sus par√°metros cambiaron ligeramente para varias instrucciones (si, para, mientras se verificaron). </p><br><p>  El m√©todo de protecci√≥n contra tales ataques es usar la se√±al interna CLOCK MK, pero tiene la peor estabilidad de temperatura y tiempo.  Adem√°s, un m√©todo eficaz puede ser la introducci√≥n de un retraso de tiempo aleatorio antes y despu√©s de instrucciones importantes (verificaci√≥n de contrase√±as, datos personales, etc.), lo que puede complicar el golpe exacto del pulso de falla CLK en el momento adecuado. </p><br><p>  <strong>Vcc-glitch</strong> </p><br><p>  Vcc-glitch, como CLK-glitch, introduce interferencia de alta frecuencia en la operaci√≥n del MK, solo haciendo un cortocircuito en la fuente de alimentaci√≥n del MK a tierra.  Al realizar ataques de falla Vcc, se debe tener en cuenta que los par√°metros de un pulso exitoso dependen de muchos factores, tales como: </p><br><p>  ‚Ä¢ caracter√≠sticas de dise√±o de la placa de circuito impreso para MK y la presencia de un flejado diverso; </p><br><p>  ‚Ä¢ longitud del cable coaxial para la conexi√≥n MK y el puerto de falla de ChipWhisperer (cuanto m√°s largo sea el cable, menos posibilidades de un ataque exitoso, la longitud √≥ptima es de 10-15 cm); </p><br><p>  ‚Ä¢ serie MK; </p><br><p>  ‚Ä¢ instrucciones que se deben omitir; </p><br><p>  ‚Ä¢ Optimizaci√≥n del compilador MK; </p><br><p>  ‚Ä¢ tipo de transistor MOSFET (debido a la diferencia en los componentes de alta frecuencia de los par√°metros S). </p><br><p>  Por lo tanto, al realizar ataques, es necesario asegurarse de que estos par√°metros no cambien. </p><br><p>  Primero debes conectar ChipWhisperer a MK: </p><br><img src="https://habrastorage.org/webt/tv/mu/rx/tvmurxgqouyuiswpaqrkdemm_yg.jpeg"><br><p>  <em>Esquema de conexi√≥n para ataques de falla Vcc</em> </p><br><p>  A continuaci√≥n, "flasheamos" el firmware en MK, donde en el <code>while(1)</code> principal <code>while(1)</code> existe la siguiente funci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">115</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glitch_while</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> 116 </span></span>{ <span class="hljs-number"><span class="hljs-number">117</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> infinity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">118</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">" Hello habr!"</span></span>); <span class="hljs-number"><span class="hljs-number">119</span></span> led_on(); <span class="hljs-number"><span class="hljs-number">120</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">121</span></span> <span class="hljs-number"><span class="hljs-number">122</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(infinity != <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">123</span></span> { <span class="hljs-number"><span class="hljs-number">124</span></span> ; <span class="hljs-number"><span class="hljs-number">125</span></span> } <span class="hljs-number"><span class="hljs-number">126</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"WOW!!! Vcc Glitch work!"</span></span>); <span class="hljs-number"><span class="hljs-number">127</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">128</span></span> { <span class="hljs-number"><span class="hljs-number">129</span></span> ; <span class="hljs-number"><span class="hljs-number">130</span></span> } <span class="hljs-number"><span class="hljs-number">131</span></span> }</code> </pre> <br><p>  MK despu√©s de enviar el mensaje "¬°Hola, habr!" Entra en un bucle sin fin en la l√≠nea 122. Nuestra tarea es eliminar MK de este bucle utilizando Vcc-glitch.  En este bucle, la variable de <code>volatile uint8_t infinity</code> se usa como condici√≥n, que nunca ser√° igual a dos cuando el programa se <code>volatile uint8_t infinity</code> normalmente.  Si ponemos <code>while(1)</code> lugar de <code>while(infinity != 2)</code> , el compilador ignorar√≠a el c√≥digo a continuaci√≥n, incluido nuestro mensaje que anuncia la salida del bucle infinito.  Debido a una variable de tipo <code>volatile</code> compilador no podr√° hacer esto.  El <code>while(1)</code> l√≠nea 127 se agrega para que despu√©s del <em>WOW !!!</em>  <em>Vcc Glitch funciona!</em>  no hemos vuelto a mostrar <em>Hola habr!</em> </p><br><p>  Utilizamos el c√≥digo Python para controlar ChipWhisperer desde esta <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html">gu√≠a</a> .  Aqu√≠ est√°n los mensajes de MK: </p><br><img src="https://habrastorage.org/webt/ar/ef/s9/arefs9fdqislmsdldtxdzj41zwe.png"><br><p>  <em>El resultado de un exitoso ataque Vcc-glitch</em> </p><br><p>  Como se puede ver en la figura, el ataque Vcc-glitch fue exitoso. </p><br><p>  La dificultad para realizar un ataque de falla Vcc radica en la selecci√≥n de los par√°metros de pulso correctos.  La implementaci√≥n de este ataque tom√≥ el tiempo m√°s largo en comparaci√≥n con los dem√°s, ya que la implementaci√≥n exitosa de los ataques de falla Vcc depende de los factores descritos anteriormente. </p><br><p>  Un m√©todo de protecci√≥n contra tales ataques tambi√©n puede ser la introducci√≥n de un retraso de tiempo aleatorio antes de las instrucciones importantes y despu√©s de ellas (verificaci√≥n de contrase√±as, datos personales, etc.).  Esto puede complicar el golpe exacto del pulso de falla Vcc en el momento adecuado.  Un aumento en el acoplamiento capacitivo entre la alimentaci√≥n y la tierra durante el cableado de la PCB tambi√©n puede ayudar un poco. </p><br><p>  <strong>Conclusiones</strong> </p><br><p>  Los ataques realizados te permiten eludir las instrucciones en MK.  Un ejemplo de un an√°lisis SCA mostr√≥ que incluso el tipo m√°s simple de tal ataque puede amenazar la seguridad de sus datos (contrase√±as, claves de cifrado).  Nos aseguramos de que los ataques de fallas eluden varias instrucciones y m√©todos de protecci√≥n de software provistos en los dispositivos.  El m√©todo universal de protecci√≥n contra ataques en los manuales considerados puede ser la introducci√≥n de retrasos aleatorios al ejecutar instrucciones importantes en el MC. </p><br><p>  Nuestro estudio de los ataques de hardware no termina ah√≠.  En el futuro, planeamos explorar la posibilidad de omitir la verificaci√≥n del byte de firmware del firmware MK utilizando ataques Vcc-glitch.  El acceso al firmware de MK puede abrir grandes oportunidades para un atacante: desde la clonaci√≥n de un dispositivo para reventa hasta el acceso completo a toda la informaci√≥n de propiedad y el control sobre MK. </p><br><p>  En nuestros experimentos con Vcc-glitch, intentamos evitar la protecci√≥n del firmware, y lo logramos.  Nos aseguramos de que esto sea posible.  En el pr√≥ximo art√≠culo presentaremos experimentos que demuestran la lectura del firmware oculto de MK. </p><br><p> <a href="http://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  Raccoon Security es un equipo especial de expertos en el Centro Cient√≠fico y T√©cnico Volcano en el campo de la seguridad pr√°ctica de la informaci√≥n, la criptograf√≠a, los circuitos, la ingenier√≠a inversa y la creaci√≥n de software de bajo nivel. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480500/">https://habr.com/ru/post/480500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480488/index.html">Una publicaci√≥n sobre buenas mochilas (guardar)</a></li>
<li><a href="../480490/index.html">Conocimiento de los controladores de Appium (o c√≥mo elegir el necesario)</a></li>
<li><a href="../480492/index.html">C√≥mo dej√© de tener miedo y me enamor√© del apoyo</a></li>
<li><a href="../480494/index.html">tecnolog√≠a QATOK aprox .: materiales para eventos</a></li>
<li><a href="../480498/index.html">An√°lisis: ¬øpor qu√© necesitamos un servicio de correo electr√≥nico cuando hay un CRM con la funci√≥n de enviar cartas?</a></li>
<li><a href="../480502/index.html">El post-futurismo que merecemos</a></li>
<li><a href="../480506/index.html">4. An√°lisis de malware mediante el an√°lisis forense de Check Point. CloudGuard SaaS</a></li>
<li><a href="../480508/index.html">AI Journey: informes y resultados de la competencia</a></li>
<li><a href="../480510/index.html">Cr√≥nica del enfrentamiento entre Rambler y Nginx (actualizado el 23 de diciembre a las 12:00)</a></li>
<li><a href="../480512/index.html">Cr√≥nica del grupo Rambler y la confrontaci√≥n de Nginx (actualizado el 23 de diciembre, 12 pm)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>