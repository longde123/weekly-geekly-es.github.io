<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ ğŸ‘‰ğŸ½ ğŸ§– 10 manfaat nyata dari penggunaan Rust ğŸ’¸ ğŸ–•ğŸ» ğŸ‘©ğŸ¿â€ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust adalah bahasa pemrograman sistem yang muda dan ambisius. Ini menerapkan manajemen memori otomatis tanpa pengumpul sampah dan overhead lain dari w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 manfaat nyata dari penggunaan Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust adalah bahasa pemrograman sistem yang muda dan ambisius.  Ini menerapkan manajemen memori otomatis tanpa pengumpul sampah dan overhead lain dari waktu eksekusi.  Selain itu, bahasa default digunakan dalam bahasa Rust, ada aturan yang belum pernah terjadi sebelumnya untuk mengakses data yang bisa berubah, dan masa pakai tautan juga diperhitungkan.  Ini memungkinkan dia untuk menjamin keamanan memori dan memfasilitasi pemrograman multi-threaded, karena kurangnya data balap. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Semua ini sudah diketahui semua orang yang mengikuti perkembangan teknologi pemrograman modern setidaknya sedikit.  Tetapi bagaimana jika Anda bukan pemrogram sistem, dan tidak ada banyak kode multithread di proyek Anda, tetapi Anda masih tertarik dengan kinerja Rust.  Apakah Anda akan mendapat manfaat tambahan dari penggunaannya dalam aplikasi?  Atau semua yang dia akan berikan kepada Anda adalah perkelahian yang sulit dengan kompiler, yang akan memaksa Anda untuk menulis program sehingga terus mengikuti aturan bahasa tentang pinjaman dan kepemilikan? </p><br><p>  Artikel ini telah mengumpulkan puluhan keuntungan tidak jelas dan tidak diiklankan secara khusus menggunakan Rust, yang, saya harap, akan membantu Anda memutuskan pilihan bahasa ini untuk proyek Anda. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. Keuniversalan bahasa </h2><br><p>  Terlepas dari kenyataan bahwa Rust diposisikan sebagai bahasa untuk pemrograman sistem, itu juga cocok untuk memecahkan masalah yang diterapkan tingkat tinggi.  Anda tidak harus bekerja dengan pointer mentah kecuali Anda membutuhkannya untuk tugas Anda.  Pustaka bahasa standar telah menerapkan sebagian besar jenis dan fungsi yang mungkin diperlukan dalam pengembangan aplikasi.  Anda juga dapat dengan mudah menghubungkan perpustakaan eksternal dan menggunakannya.  Sistem tipe dan pemrograman umum dalam Rust memungkinkan penggunaan abstraksi dari tingkat yang cukup tinggi, meskipun tidak ada dukungan langsung untuk OOP dalam bahasa tersebut. </p><br><p>  Mari kita lihat beberapa contoh sederhana menggunakan Rust. </p><br><p>  Contoh menggabungkan dua iterator menjadi satu iterator pada pasangan elemen: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><blockquote>  Catatan: panggilan ke <code>name!(...)</code> format <code>name!(...)</code> adalah panggilan ke makro fungsional.  Nama-nama makro seperti itu di Rust selalu diakhiri dengan simbol <code>!</code>  sehingga mereka dapat dibedakan dari nama fungsi dan pengidentifikasi lainnya.  Manfaat menggunakan makro akan dibahas di bawah ini. </blockquote><p>  Contoh menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>regex</code></a> eksternal untuk bekerja dengan ekspresi reguler: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Contoh penerapan <code>Add</code> untuk struktur <code>Point</code> sendiri untuk membebani operator tambahan: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Contoh menggunakan tipe generik dalam struktur: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Pada Rust Anda dapat menulis utilitas sistem yang efisien, aplikasi desktop besar, layanan mikro, aplikasi web (termasuk bagian klien, karena Rust dapat dikompilasi dalam Wasm), aplikasi mobile (meskipun ekosistem bahasa masih kurang berkembang dalam arah ini).  Fleksibilitas semacam itu dapat menjadi keuntungan bagi tim multi-proyek, karena memungkinkan Anda untuk menggunakan pendekatan yang sama dan modul yang sama di banyak proyek yang berbeda.  Jika Anda terbiasa dengan fakta bahwa setiap alat dirancang untuk bidang aplikasi yang sempit, maka cobalah untuk melihat Rust sebagai kotak alat dengan keandalan dan kenyamanan yang sama.  Mungkin inilah tepatnya yang Anda lewatkan. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Alat manajemen yang mudah dibangun dan ketergantungan </h2><br><p>  Ini jelas tidak diiklankan, tetapi banyak yang memperhatikan bahwa Rust memiliki salah satu sistem manajemen pembangunan dan ketergantungan terbaik yang tersedia saat ini.  Jika Anda memprogram dalam C atau C ++, dan pertanyaan tentang penggunaan pustaka eksternal yang tidak menyakitkan bagi Anda, maka menggunakan Rust dengan alat bangunnya dan manajer ketergantungan Cargo akan menjadi pilihan yang baik untuk proyek baru Anda. </p><br><p>  Selain fakta bahwa Cargo akan mengunduh dependensi untuk Anda dan mengelola versinya, membangun dan menjalankan aplikasi Anda, menjalankan tes, dan menghasilkan dokumentasi, Cargo juga dapat diperluas dengan plugin untuk fungsi berguna lainnya.  Misalnya, ada ekstensi yang memungkinkan Cargo untuk menentukan dependensi usang proyek Anda, melakukan analisis statis terhadap kode sumber, membangun dan menggunakan kembali bagian-bagian klien dari aplikasi web, dan banyak lagi. </p><br><p>  File konfigurasi Cargo menggunakan bahasa marka toml ramah dan minimal untuk menggambarkan pengaturan proyek.  Berikut adalah contoh <code>Cargo.toml</code> konfigurasi <code>Cargo.toml</code> khas: </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Dan di bawah ini adalah tiga perintah khas untuk menggunakan Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Dengan bantuan mereka, kode sumber akan diperiksa untuk kesalahan kompilasi, perakitan proyek dan peluncuran tes, perakitan dan peluncuran program untuk dieksekusi, masing-masing. </p><br><h2 id="3-vstroennye-testy">  3. Tes bawaan </h2><br><p>  Tes unit menulis di Rust sangat mudah dan sederhana sehingga Anda ingin melakukannya berulang kali.  :) Seringkali akan lebih mudah untuk menulis unit test daripada mencoba menguji fungsionalitas dengan cara lain.  Berikut adalah contoh fungsi dan tes untuk mereka: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Fungsi-fungsi dalam modul <code>test</code> , ditandai dengan atribut <code>#[test]</code> , adalah tes unit.  Mereka akan dieksekusi secara paralel ketika perintah <code>cargo test</code> dipanggil.  Atribut kompilasi bersyarat <code>#[cfg(test)]</code> , yang menandai seluruh modul dengan tes, akan mengarah pada fakta bahwa modul hanya akan dikompilasi ketika tes dijalankan, tetapi tidak akan masuk ke perakitan normal. </p><br><p>  Sangat mudah untuk menempatkan tes dalam modul yang sama dengan fungsional yang diuji, cukup dengan menambahkan submodule <code>test</code> ke dalamnya.  Dan jika Anda memerlukan tes integrasi, cukup tempatkan tes Anda di direktori <code>tests</code> di root proyek, dan gunakan aplikasi Anda di dalamnya sebagai paket eksternal.  Modul <code>test</code> terpisah dan arahan kompilasi bersyarat dalam kasus ini tidak perlu ditambahkan. </p><br><p>  Contoh-contoh khusus dari dokumentasi yang dilaksanakan sebagai ujian patut mendapat perhatian khusus, tetapi ini akan dibahas di bawah ini. </p><br><p>  Tes kinerja built-in (tolok ukur) juga tersedia, tetapi belum stabil, oleh karena itu tes ini hanya tersedia di majelis malam kompiler.  Di Rust yang stabil, Anda harus menggunakan pustaka eksternal untuk jenis pengujian ini. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Dokumentasi yang baik dengan contoh saat ini </h2><br><p>  Perpustakaan Rust standar didokumentasikan dengan sangat baik.  Dokumentasi HTML secara otomatis dihasilkan dari kode sumber dengan deskripsi penurunan harga di dermaga komentar.  Selain itu, komentar dokumen dalam kode Rust berisi kode sampel yang dijalankan saat tes dijalankan.  Ini memastikan relevansi contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Dokumentasi</em></a> </p><br><p>  Berikut adalah contoh penggunaan metode <code>as_bytes</code> dari tipe <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  akan dieksekusi sebagai tes selama peluncuran tes. </p><br><p>  Selain itu, praktik membuat contoh penggunaannya dalam bentuk program independen kecil yang terletak di direktori <code>examples</code> di root proyek adalah umum untuk perpustakaan Rust.  Contoh-contoh ini juga merupakan bagian penting dari dokumentasi dan mereka juga dikompilasi dan dieksekusi selama uji coba, tetapi mereka dapat dijalankan secara independen dari tes. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Pengurangan otomatis tipe cerdas </h2><br><p>  Dalam program Karat, Anda tidak dapat menentukan jenis ekspresi secara eksplisit jika kompilator dapat mengeluarkannya secara otomatis berdasarkan konteks penggunaan.  Dan ini tidak hanya berlaku untuk tempat-tempat di mana variabel dinyatakan.  Mari kita lihat sebuah contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Jika kami mengatur jenis anotasi, maka contoh ini akan terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Yaitu, kita memiliki vektor irisan string dan variabel irisan string tipe.  Tetapi dalam kasus ini, menentukan jenis sepenuhnya berlebihan, karena kompiler dapat mengeluarkannya sendiri (menggunakan versi diperpanjang dari algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hindley-Milner</a> ).  Fakta bahwa <code>vec</code> adalah vektor sudah jelas dengan jenis nilai pengembalian dari <code>Vec::new()</code> , tetapi belum jelas jenis elemennya.  Fakta bahwa jenis <code>text</code> adalah irisan string dapat dimengerti oleh fakta bahwa itu diberikan literal jenis ini.  Dengan demikian, setelah <code>vec.push(text)</code> , jenis elemen vektor menjadi jelas.  Perhatikan bahwa jenis variabel <code>vec</code> sepenuhnya ditentukan oleh penggunaannya dalam utas eksekusi, dan bukan pada tahap inisialisasi. </p><br><p>  Sistem inferensi tipe seperti itu menghilangkan noise dari kode dan membuatnya sesingkat kode dalam beberapa bahasa pemrograman yang diketik secara dinamis.  Dan ini sambil mempertahankan pengetikan statis yang ketat! </p><br><p>  Tentu saja, kita tidak bisa sepenuhnya menghapus pengetikan dalam bahasa yang diketik secara statis.  Program harus memiliki titik di mana jenis objek dijamin diketahui, sehingga di tempat lain jenis ini dapat ditampilkan.  Poin seperti itu di Rust adalah deklarasi tipe data yang ditentukan pengguna dan fungsi tanda tangan, di mana orang tidak bisa tidak menentukan jenis yang digunakan.  Tapi Anda bisa memasukkan "meta-variabel jenis" di dalamnya, menggunakan pemrograman umum. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Pencocokan pola pada titik-titik deklarasi variabel </h2><br><p>  <code>let</code> operasi </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  tidak benar-benar terbatas hanya dengan mendeklarasikan variabel baru.  Apa yang sebenarnya dia lakukan adalah mencocokkan ekspresi di sebelah kanan tanda sama dengan pola di sebelah kiri.  Dan variabel baru dapat diperkenalkan sebagai bagian dari sampel (dan hanya demikian).  Lihatlah contoh berikut, dan itu akan menjadi lebih jelas bagi Anda: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Destrukturisasi dilakukan di sini: perbandingan seperti itu akan memperkenalkan variabel <code>x</code> dan <code>y</code> , yang akan diinisialisasi dengan nilai bidang <code>x</code> dan <code>y</code> dari objek struktur <code>Point</code> , yang dikembalikan dengan memanggil <code>Point::new()</code> .  Pada saat yang sama, perbandingannya benar, karena jenis ekspresi di sebelah kanan sesuai dengan pola <code>Point</code> dari tipe <code>Point</code> di sebelah kiri.  Dengan cara yang sama, Anda bisa mengambil, misalnya, dua elemen pertama dari sebuah array: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Dan masih banyak lagi yang harus dilakukan.  Hal yang paling luar biasa adalah bahwa perbandingan semacam itu dilakukan di semua tempat di mana nama variabel baru dapat dimasukkan dalam Rust, yaitu: dalam <code>match</code> , <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , di header <code>for</code> loop, dalam argumen fungsi dan penutupan.  Berikut adalah contoh penggunaan pola yang cocok secara elegan dalam <code>for</code> loop: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Metode <code>enumerate</code> , dipanggil pada iterator, membangun iterator baru, yang akan beralih bukan nilai awal, tetapi tupel, pasang "indeks ordinal, nilai awal".  Masing-masing tupel selama iterasi siklus akan dipetakan ke pola yang ditentukan <code>(i, ch)</code> , sebagai akibatnya variabel <code>i</code> akan menerima nilai pertama dari tuple - indeks, dan variabel <code>ch</code> - yang kedua, yaitu karakter string.  Lebih lanjut dalam tubuh loop kita dapat menggunakan variabel-variabel ini. </p><br><p>  Contoh populer lain dari menggunakan pola dalam <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Di sini kita mengabaikan nilai iterator menggunakan pola <code>_</code> .  Karena kita tidak menggunakan nomor iterasi di badan loop.  Hal yang sama dapat dilakukan, misalnya, dengan argumen fungsi: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Atau saat mencocokkan dalam pernyataan <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Pencocokan pola membuat kode sangat kompak dan ekspresif, dan dalam pernyataan <code>match</code> umumnya tidak tergantikan.  Operator <code>match</code> adalah operator analisis variatif lengkap, sehingga Anda tidak akan dapat secara tidak sengaja lupa untuk memeriksa beberapa kecocokan yang mungkin untuk ekspresi yang dianalisis di dalamnya. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Ekstensi sintaks dan DSL khusus </h2><br><p>  Sintaksis Rust terbatas, sebagian besar disebabkan oleh kompleksitas jenis sistem yang digunakan dalam bahasa.  Misalnya, Rust tidak memiliki nama argumen fungsi atau fungsi dengan sejumlah variabel argumen.  Tetapi Anda dapat menyiasati ini dan keterbatasan lainnya dengan makro.  Karat memiliki dua jenis makro: deklaratif dan prosedural.  Dengan makro deklaratif, Anda tidak akan pernah memiliki masalah yang sama dengan makro di C, karena mereka higienis dan tidak bekerja di tingkat penggantian teks, tetapi pada tingkat penggantian di pohon sintaksis abstrak.  Macro memungkinkan Anda untuk membuat abstraksi pada tingkat sintaksis bahasa.  Sebagai contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Selain fakta bahwa makro ini memperluas kemampuan sintaksis memanggil "fungsi" dari mencetak string yang diformat, itu juga akan dalam implementasinya memverifikasi bahwa argumen input cocok dengan string format yang ditentukan pada waktu kompilasi, dan tidak pada saat run time.  Dengan menggunakan makro, Anda dapat memasukkan sintaksis ringkas untuk kebutuhan desain Anda sendiri, membuat dan menggunakan DSL.  Berikut adalah contoh penggunaan kode JavaScript di dalam program Rust yang dikompilasi dalam Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Makro <code>js!</code>  didefinisikan dalam paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>stdweb</code></a> dan memungkinkan Anda untuk menyematkan kode JavaScript lengkap dalam program Anda (dengan pengecualian string dan operator yang dikutip tunggal tidak dilengkapi dengan tanda titik koma) dan menggunakan objek dari kode Rust menggunakan sintaks <code>@{expr}</code> . </p><br><p>  Makro menawarkan peluang luar biasa untuk mengadaptasi sintaks program Rust dengan tugas-tugas spesifik dari bidang subjek tertentu.  Mereka akan menghemat waktu dan perhatian Anda saat mengembangkan aplikasi yang kompleks.  Bukan dengan meningkatkan overhead runtime, tetapi dengan meningkatkan waktu kompilasi.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Pembuatan kode dependen secara otomatis </h2><br><p>  Makro turunan prosedural Rust secara luas digunakan untuk secara otomatis mengimplementasikan sifat-sifat dan pembuatan kode lainnya.  Berikut ini sebuah contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Karena semua jenis ini ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> dan <code>Eq</code> ) dari pustaka standar diimplementasikan untuk jenis bidang struktur <code>i32</code> , implementasinya dapat secara otomatis ditampilkan untuk seluruh struktur secara keseluruhan.  Contoh lain: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Di sini, menggunakan <code>Deserialize</code> dan <code>Deserialize</code> dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>serde</code></a> untuk struktur <code>Point</code> , metode untuk serialisasi dan deserialisasi secara otomatis dihasilkan.  Kemudian Anda dapat mengirimkan instance dari struktur ini ke berbagai fungsi serialisasi, misalnya, mengubahnya menjadi string JSON. </p><br><p>  Anda dapat membuat macro prosedural Anda sendiri yang akan menghasilkan kode yang Anda butuhkan.  Atau gunakan banyak makro yang sudah dibuat oleh pengembang lain.  Selain menyelamatkan pemrogram dari menulis kode boilerplate, makro juga memiliki keuntungan bahwa Anda tidak perlu mempertahankan bagian kode yang berbeda dalam keadaan konsisten.  Misalnya, jika bidang ketiga <code>z</code> ditambahkan ke struktur <code>Point</code> , maka untuk melakukan serialisasi dengan benar, jika Anda menggunakan turunan, Anda tidak perlu melakukan hal lain.  Jika kita sendiri akan menerapkan sifat-sifat yang diperlukan untuk serialisasi <code>Point</code> , maka kita harus memastikan bahwa implementasi ini selalu konsisten dengan perubahan terbaru dalam struktur <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Tipe data aljabar </h2><br><p>  Sederhananya, tipe data aljabar adalah tipe data komposit yang merupakan gabungan dari struktur.  Lebih formal, ini adalah tipe-jumlah dari jenis produk.  Di Rust, tipe ini didefinisikan menggunakan kata kunci <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  Jenis nilai tertentu dari variabel tipe <code>Message</code> hanya dapat menjadi salah satu dari tipe struktur yang tercantum dalam <code>Message</code> .  Ini adalah struktur <code>Quit</code> tanpa bidang yang mirip unit, salah satu struktur tuple <code>ChangeColor</code> atau <code>Write</code> dengan bidang tanpa nama, atau struktur <code>Move</code> biasa.  Tipe enumerasi tradisional dapat direpresentasikan sebagai kasus khusus tipe data aljabar: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Dimungkinkan untuk mengetahui jenis apa yang sebenarnya mengambil nilai dalam kasus tertentu menggunakan pencocokan pola: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Dalam bentuk tipe data aljabar, Rust mengimplementasikan tipe penting seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Option</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Result</code></a> , yang digunakan untuk mewakili nilai yang hilang dan hasil yang benar / salah.  Begini cara <code>Option</code> didefinisikan di perpustakaan standar: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust tidak memiliki nilai nol, sama seperti kesalahan menjengkelkan dari panggilan tak terduga ke sana.  Sebaliknya, jika benar-benar diperlukan untuk menunjukkan kemungkinan nilai yang hilang, <code>Option</code> digunakan: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Lari</em></a> </p><br><p>  Tipe data aljabar adalah alat yang kuat dan ekspresif yang membuka pintu bagi Pengembangan Tipe-Didorong.  Program yang ditulis secara kompeten dalam paradigma ini memberikan sebagian besar pemeriksaan kebenaran pekerjaannya ke sistem tipe.  Karena itu, jika Anda kekurangan Haskell dalam pemrograman industri sehari-hari, Rust bisa menjadi outlet Anda.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Refactoring mudah </h2><br><p>  Sistem tipe statis ketat yang dikembangkan di Rust dan upaya untuk melakukan sebanyak mungkin pemeriksaan selama kompilasi, mengarah pada fakta bahwa memodifikasi dan refactoring kode menjadi sangat sederhana dan aman.  Jika, setelah perubahan, program dikompilasi, ini berarti hanya meninggalkan kesalahan logis yang tidak terkait dengan fungsi yang verifikasi ditugaskan ke kompiler.  Dikombinasikan dengan kemudahan menambahkan tes unit untuk menguji logika, ini mengarah pada jaminan serius keandalan program dan peningkatan kepercayaan diri programmer dalam operasi kode yang benar setelah melakukan perubahan. </p><br><hr><br><p>  Mungkin ini yang ingin saya bicarakan di artikel ini.  Tentu saja, Rust memiliki banyak keunggulan lain, serta sejumlah kelemahan (beberapa kelemahan bahasa, kurangnya idiom pemrograman yang akrab, dan sintaksis "non-sastra"), yang tidak disebutkan di sini.  Jika Anda memiliki sesuatu untuk diceritakan tentang mereka, tulis di komentar.  Secara umum, coba Rust dalam praktik.  Dan mungkin kelebihannya bagi Anda akan melebihi semua kekurangannya, seperti yang terjadi dalam kasus saya.  Dan akhirnya, Anda akan mendapatkan set alat yang Anda butuhkan untuk waktu yang lama. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430294/">https://habr.com/ru/post/id430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430282/index.html">9 dari 10 orang setuju untuk menghasilkan lebih sedikit dari pekerjaan yang lebih bermakna</a></li>
<li><a href="../id430284/index.html">Intisari materi menarik untuk pengembang seluler # 275 (12 - 18 November)</a></li>
<li><a href="../id430286/index.html">Detail sisi berantakan dan gelap dari game bajak laut untuk Nintendo Switch</a></li>
<li><a href="../id430290/index.html">Upaya untuk memprediksi iterasi keempat dari proyek SpaceX BFR</a></li>
<li><a href="../id430292/index.html">Electronic Frontier Foundation: Kinerja jaringan plat polisi AS 0,5%</a></li>
<li><a href="../id430296/index.html">Jadikan ide Anda datang dengan aplikasi. Aplikasi tanpa server - petunjuk langkah demi langkah</a></li>
<li><a href="../id430300/index.html">Layanan microser on Go dengan kit Go: Pendahuluan</a></li>
<li><a href="../id430302/index.html">Pengantar ptrace atau injeksi kode dalam sshd untuk bersenang-senang</a></li>
<li><a href="../id430304/index.html">Pos luar biasa di orbit</a></li>
<li><a href="../id430306/index.html">Terowongan pertama Perusahaan Boring dibor oleh Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>