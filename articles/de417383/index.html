<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 🕧 👩🏽‍🤝‍👨🏻 JavaScript ES6: Schwächen 🏂🏿 👩🏿‍🎤 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Juni 2018 feierte der Standard ECMAScript 2015 ( ES6 ) sein dreijähriges Bestehen. In ES6 sind zum einen viele neue JavaScript-Funktionen erschiene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript ES6: Schwächen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417383/">  Im Juni 2018 feierte der Standard ECMAScript 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ES6</a> ) sein dreijähriges Bestehen.  In ES6 sind zum einen viele neue JavaScript-Funktionen erschienen, und zum anderen beginnt mit diesem Standard eine neue Ära der Sprachentwicklung.  Darüber hinaus war dies die letzte groß angelegte Version von JS, da TC39 jetzt das Schema für die Ausgabe kleiner jährlicher Ausgaben des Standards anwendet und es nicht alle paar Jahre erneut herausbringt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  In den letzten 4 Jahren hat ES6 zu Recht allgemeine Aufmerksamkeit erregt.  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, sagt, dass er dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel</a> die ganze Zeit den gesamten Code mit der modernen Version der JS-Spezifikationen geschrieben hat.  Er glaubt, dass genug Zeit vergangen ist, um die neuen Funktionen von ES6 kritisch zu analysieren.  Insbesondere interessiert er sich für das, was er für einige Zeit verwendet hat, und hat es dann nicht mehr verwendet, weil es seinen Code verschlechtert hat. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Über JS-Schwächen</font> </h2><br>  Douglas Crockford schrieb in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> JavaScript: Strengths auch darüber, was als Schwächen der Sprache angesehen werden kann.  Dies ist etwas, das seiner Meinung nach nicht wert ist, verwendet zu werden.  Glücklicherweise gibt es unter den Innovationen von ES6 nichts so unansehnliches wie einige der alten problematischen Funktionen von JS, wie den laxen Gleichheitsoperator, der die implizite Typkonvertierung durchführt, die <code>eval()</code> -Funktion und die <code>with</code> Anweisung.  Die neuen Funktionen von ES6 sind viel besser gestaltet.  Es gibt jedoch einige Dinge in ihm, die ich vermeide.  Die Funktionen, die auf meiner Liste der JS-Schwachstellen stehen, sind aus folgenden Gründen in dieser Liste aufgeführt: <br><br><ul><li>  Sie sind im Wesentlichen „Fallen“.  Das heißt, sie scheinen darauf ausgelegt zu sein, bestimmte Aktionen auszuführen, und in den meisten Fällen funktionieren sie wie erwartet.  Manchmal verhalten sie sich jedoch unerwartet, was leicht zu Fehlern führen kann. </li><li>  Sie erhöhen das Sprachvolumen im Austausch für kleine Vorteile.  Solche Möglichkeiten bieten dem Entwickler einige kleine Vorteile, erfordern jedoch jemanden, der versucht, seinen Code herauszufinden, um Kenntnisse über bestimmte Mechanismen zu haben, die normalerweise irgendwo versteckt sind.  Dies gilt in zweifacher Hinsicht für API-Funktionen. Wenn Sie diese Funktion verwenden, bedeutet dies, dass anderer Code, der mit Code interagiert, der von einem bestimmten Entwickler geschrieben wurde, die Anwendung dieser API-Funktion kennen muss. </li></ul><br>  Lassen Sie uns nun anhand dieser Überlegungen über die Schwächen von ES6 sprechen. <br><br><h2>  <font color="#3AC1EF">Schlüsselwort const</font> </h2><br>  Vor ES6 konnten Variablen in JavaScript mit dem Schlüsselwort <code>var</code> deklariert werden.  Außerdem konnten Variablen überhaupt nicht deklariert werden, dann fallen sie, selbst wenn sie in Funktionen verwendet werden, in den globalen Bereich.  Eigenschaften von Objekten können die Rolle von Variablen spielen, und Funktionen werden mit dem <code>function</code> deklariert.  Das Schlüsselwort <code>var</code> hat bestimmte Funktionen. <br><br>  Auf diese Weise können Sie Variablen erstellen, die dem globalen Objekt hinzugefügt werden oder deren Umfang durch Funktionen begrenzt ist.  Das Schlüsselwort <code>var</code> berücksichtigt jedoch keine Codeblöcke.  Darüber hinaus können Sie auf eine Variable verweisen, die mit dem Schlüsselwort <code>var</code> im Code vor dem Befehl für ihre Deklaration deklariert wurde.  Dieses Phänomen wird als Erhöhen von Variablen bezeichnet.  Wenn diese Funktionen nicht berücksichtigt werden, können sie zu Fehlern führen.  Um die Situation zu korrigieren, führte ES6 zwei neue Schlüsselwörter für die Deklaration von Variablen ein: <code>let</code> und <code>const</code> .  Sie lösten die Hauptprobleme <code>var</code> .  Wir sprechen nämlich über die Tatsache, dass Variablen, die mit diesen Schlüsselwörtern deklariert wurden, einen Blockbereich haben, sodass beispielsweise eine in einer Schleife deklarierte Variable außerhalb dieser Schleife nicht sichtbar ist.  Darüber hinaus ermöglicht die Verwendung von <code>let</code> und <code>const</code> keinen Zugriff auf Variablen, bevor diese deklariert werden.  Dies führt zu einem <code>ReferenceError</code> Fehler.  Dies war ein großer Schritt nach vorne.  Das Auftauchen von zwei neuen Schlüsselwörtern sowie deren Funktionen führte jedoch zu zusätzlicher Verwirrung. <br><br>  Der Wert einer Variablen (Konstante), die mit dem Schlüsselwort <code>const</code> deklariert wurde, kann nach der Deklaration nicht überschrieben werden.  Dies ist der einzige Unterschied zwischen <code>const</code> und <code>let</code> .  Diese neue Gelegenheit sieht nützlich aus und kann wirklich einige Vorteile bringen.  Das Problem ist das <code>const</code> Schlüsselwort selbst.  Die Art und Weise, wie sich die deklarierten Konstanten verhalten, entspricht nicht dem, was die meisten Entwickler mit dem Konzept der „Konstante“ assoziieren. <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  Die Verwendung des Schlüsselworts <code>const</code> verhindert, dass ein neuer Wert in eine Konstante geschrieben wird, macht jedoch Objekte, auf die von solchen Konstanten verwiesen wird, nicht unveränderlich.  Diese Funktion bietet einen schlechten Schutz gegen Wertänderungen bei der Arbeit mit den meisten Datentypen.  Aufgrund der Tatsache, dass die Verwendung von <code>const</code> zu Verwirrung führen kann, und aufgrund der Tatsache, dass das Vorhandensein von <code>const</code> redundant aussieht, wenn das Schlüsselwort <code>let</code> vorhanden ist, habe ich mich entschieden, immer <code>let</code> . <br><br><h2>  <font color="#3AC1EF">Tagged Template Strings</font> </h2><br>  Das Schlüsselwort <code>const</code> ist ein Beispiel dafür, wie eine Spezifikation zu viele Möglichkeiten zur Lösung zu weniger Probleme schafft.  Bei getaggten Vorlagenzeichenfolgen ist die Situation umgekehrt.  Die Syntax solcher Zeichenfolgen wurde vom TC39-Komitee als eine Möglichkeit zur Lösung von Zeichenfolgeninterpolation und mehrzeiligen Zeichenfolgen angesehen.  Dann beschlossen sie, diese Möglichkeit durch den Einsatz von Makros zu erweitern. <br><br>  Wenn Sie noch nie markierte Musterzeichenfolgen gesehen haben, denken Sie daran, dass sie ein bisschen wie Zeichenfolgendekoratoren sind.  Hier ist ein Beispiel für die Arbeit mit ihnen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> : <br><br><pre> <code class="hljs powershell">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var output = myTag`that <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ person } is a <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ age }`; console.log(output); // that Mike is a youngster</code> </pre> <br>  Mit Tags versehene Vorlagenzeichenfolgen können nicht als völlig nutzlos bezeichnet werden.  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersicht über</a> einige ihrer Anwendungen.  Sie sind beispielsweise beim Löschen von HTML-Code hilfreich.  Derzeit zeigt ihre Anwendung den genauesten Ansatz in Situationen, in denen Sie dieselbe Operation für alle Eingabedaten einer beliebigen Zeichenfolgenvorlage ausführen müssen.  Dies ist jedoch relativ selten. Sie können dies auch mit der entsprechenden API tun (obwohl eine solche Lösung länger ist).  Um die meisten Probleme zu lösen, ist die Verwendung der API nicht schlechter als die Verwendung von mit Tags versehenen Vorlagenzeichenfolgen.  Diese Funktion fügt der Sprache keine neuen Funktionen hinzu.  Sie fügt neue Ansätze für die Arbeit mit Daten hinzu, die denen vertraut sein sollten, die Code lesen müssen, der mit markierten Vorlagenzeichenfolgen geschrieben wurde.  Und ich bemühe mich sicherzustellen, dass mein Code so sauber und verständlich wie möglich bleibt. <br><br><h2>  <font color="#3AC1EF">Überarbeitete destruktive Zuweisungsausdrücke</font> </h2><br>  Einige Funktionen der Sprache sehen gut aus, wenn sie zur Lösung einfacher Aufgaben verwendet werden. Wenn Aufgaben jedoch komplexer werden, können diese Funktionen außer Kontrolle geraten.  Zum Beispiel mag ich den ternären bedingten Operator: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  Mit dem mit seiner Hilfe geschriebenen Code wird es jedoch schwierig zu verstehen, ob Sie mit diesem Operator verschachtelte Konstruktionen verwenden: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  Gleiches gilt für die destruktive Zuordnung.  Mit diesem Mechanismus können Sie die Werte von Variablen aus Objekten oder Arrays abrufen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  Darüber hinaus können Sie bei Verwendung Variablen umbenennen, verschachtelte Werte abrufen und Standardwerte festlegen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  All dies ist wunderbar - bis es darum geht, komplexe Ausdrücke mit all diesen Funktionen zu erstellen.  Im folgenden Ausdruck werden beispielsweise 4 Variablen deklariert: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> und <code>eventId</code> .  Ihre Werte werden von verschiedenen Stellen in der Struktur des <code>eventRecord</code> Objekts übernommen. <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  Einen solchen Code zu verstehen ist fast unmöglich.  Dieses Problem kann mit viel besser lesbarem Code gelöst werden, wenn Sie mehrere Destrukturierungsvorgänge verwenden oder diese vollständig aufgeben. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  Ich habe keine klare Richtlinie, die darauf hinweist, dass der Ausdruck der destruktiven Aufgabe überarbeitet werden muss.  Jedes Mal, wenn ich einen ähnlichen Ausdruck betrachte und nicht sofort verstehen kann, welches Problem er löst und welche Variablen darin verwendet werden, ist es an der Zeit, den Code zu vereinfachen, um seine Lesbarkeit zu verbessern. <br><br><h2>  <font color="#3AC1EF">Standardexport</font> </h2><br>  ES6 hat eine nette Funktion.  Es besteht darin, wie seine Entwickler die Standardisierung dessen, was zuvor getan wurde, mit Hilfe verschiedener Bibliotheken angegangen sind, die häufig miteinander konkurrieren.  So erschienen in der Spezifikation Klassen, Versprechen, Module.  Dies ist alles, was die JS-Entwicklergemeinde vor ES6 verwendet hat und in Bibliotheken von Drittanbietern gefunden hat.  Zum Beispiel sind ES6-Module ein hervorragender Ersatz für das, was in den AMD / CommonJS-Formatkrieg übergegangen ist, und bieten eine bequeme Syntax für die Organisation von Importen. <br><br>  ES6-Module unterstützen zwei Hauptmethoden zum Exportieren von Werten: benannter Export und Standardexport oder Standardexport: <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  Ein Modul kann mehrere benannte Exportbefehle verwenden, jedoch nur einen Standardexportbefehl.  Wenn Sie importieren, was mit dem Standardexportbefehl exportiert wurde, können Sie in der Importdatei jedem Namen, der standardmäßig exportiert wird, einen beliebigen Namen geben, da während dieses Vorgangs keine Namen gesucht werden.  Wenn Sie den benannten Export verwenden, müssen Sie die Variablennamen aus den exportierenden Dateien verwenden, obwohl auch das Umbenennen möglich ist. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  Der Standardexport fand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei den Entwicklern des</a> ES6-Standards <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besondere Beachtung</a> und erstellte absichtlich eine einfachere Syntax dafür.  In der Praxis konnte ich jedoch feststellen, dass die Verwendung der benannten Exporttechnologie aus den folgenden Gründen vorzuziehen ist. <br><br><ol><li>  Bei Verwendung des benannten Exports entsprechen die Namen der exportierten Variablen standardmäßig den Namen der importierten Variablen, was die Suche nach Personen vereinfacht, die keine intelligenten Entwicklungstools verwenden. </li><li>  Bei der Verwendung benannter Exporte erhalten Programmierer, die intelligente Entwicklungstools verwenden, so praktische Funktionen wie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatischen Import</a> . </li><li>  Mit benannten Exporten können Sie alles, was Sie wollen, in den richtigen Mengen einheitlich aus den Modulen exportieren.  Der Standardexport beschränkt den Entwickler darauf, nur einen einzelnen Wert zu exportieren.  Um dieses Problem zu umgehen, können Sie den Export eines Objekts mit mehreren Eigenschaften anwenden.  Dieser Ansatz verliert jedoch den Wert des Tree-Shaking-Algorithmus, der zum Reduzieren der Größe von JS-Anwendungen verwendet wird, die von so etwas wie Webpack erstellt wurden.  Die Verwendung ausschließlich benannter Module vereinfacht die Arbeit. </li></ol><br>  Im Allgemeinen kann festgestellt werden, dass das Benennen von Entitäten eine gute Vorgehensweise ist, da Sie sie sowohl im Code als auch in Gesprächen über diesen Code eindeutig identifizieren können.  Deshalb verwende ich den benannten Export. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Sie haben gerade die Funktionen von ES6 kennengelernt, die laut dem Autor dieses Materials nicht erfolgreich sind.  Vielleicht schließen Sie sich dieser Meinung an, vielleicht auch nicht.  Jede Programmiersprache ist ein komplexes System, dessen Funktionen aus verschiedenen Blickwinkeln betrachtet werden können.  Wir hoffen jedoch, dass dieser Artikel allen nützlich sein wird, die klaren und qualitativ hochwertigen Code schreiben möchten. <br><br>  <b>Liebe Leser!</b>  Gibt es etwas in modernem JavaScript, das Sie vermeiden möchten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417383/">https://habr.com/ru/post/de417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417369/index.html">15 Tools für das Arbeitsarsenal des Produktmanagers</a></li>
<li><a href="../de417373/index.html">ZFS-Speicher-, Standby- und Testumgebungen</a></li>
<li><a href="../de417375/index.html">15 HTML-Elementmethoden, von denen Sie wahrscheinlich noch nie gehört haben</a></li>
<li><a href="../de417377/index.html">Warum sollten Sie Google Cloud nicht verwenden?</a></li>
<li><a href="../de417379/index.html">Neuer Feststoffraketenmotor für Vega-C und Ariane 6</a></li>
<li><a href="../de417385/index.html">Wie ich umgezogen bin ... nach Hause oder meine Antwort an den Autor des Artikels über "gnadenloses Mehl"</a></li>
<li><a href="../de417389/index.html">Tilt Shift Lens-Effekt</a></li>
<li><a href="../de417391/index.html">Browserübergreifende Web-Erweiterung für benutzerdefinierte Skripte Teil 4</a></li>
<li><a href="../de417393/index.html">Wie wir ein System geschaffen haben, das Kunden Rabatte basierend auf individuellen Merkmalen zuweist</a></li>
<li><a href="../de417395/index.html">End-to-End-Tests: Was, warum, warum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>