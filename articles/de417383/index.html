<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üïß üë©üèΩ‚Äçü§ù‚Äçüë®üèª JavaScript ES6: Schw√§chen üèÇüèø üë©üèø‚Äçüé§ üßê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Juni 2018 feierte der Standard ECMAScript 2015 ( ES6 ) sein dreij√§hriges Bestehen. In ES6 sind zum einen viele neue JavaScript-Funktionen erschiene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript ES6: Schw√§chen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417383/">  Im Juni 2018 feierte der Standard ECMAScript 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ES6</a> ) sein dreij√§hriges Bestehen.  In ES6 sind zum einen viele neue JavaScript-Funktionen erschienen, und zum anderen beginnt mit diesem Standard eine neue √Ñra der Sprachentwicklung.  Dar√ºber hinaus war dies die letzte gro√ü angelegte Version von JS, da TC39 jetzt das Schema f√ºr die Ausgabe kleiner j√§hrlicher Ausgaben des Standards anwendet und es nicht alle paar Jahre erneut herausbringt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  In den letzten 4 Jahren hat ES6 zu Recht allgemeine Aufmerksamkeit erregt.  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass er dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel</a> die ganze Zeit den gesamten Code mit der modernen Version der JS-Spezifikationen geschrieben hat.  Er glaubt, dass genug Zeit vergangen ist, um die neuen Funktionen von ES6 kritisch zu analysieren.  Insbesondere interessiert er sich f√ºr das, was er f√ºr einige Zeit verwendet hat, und hat es dann nicht mehr verwendet, weil es seinen Code verschlechtert hat. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">√úber JS-Schw√§chen</font> </h2><br>  Douglas Crockford schrieb in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> JavaScript: Strengths auch dar√ºber, was als Schw√§chen der Sprache angesehen werden kann.  Dies ist etwas, das seiner Meinung nach nicht wert ist, verwendet zu werden.  Gl√ºcklicherweise gibt es unter den Innovationen von ES6 nichts so unansehnliches wie einige der alten problematischen Funktionen von JS, wie den laxen Gleichheitsoperator, der die implizite Typkonvertierung durchf√ºhrt, die <code>eval()</code> -Funktion und die <code>with</code> Anweisung.  Die neuen Funktionen von ES6 sind viel besser gestaltet.  Es gibt jedoch einige Dinge in ihm, die ich vermeide.  Die Funktionen, die auf meiner Liste der JS-Schwachstellen stehen, sind aus folgenden Gr√ºnden in dieser Liste aufgef√ºhrt: <br><br><ul><li>  Sie sind im Wesentlichen ‚ÄûFallen‚Äú.  Das hei√üt, sie scheinen darauf ausgelegt zu sein, bestimmte Aktionen auszuf√ºhren, und in den meisten F√§llen funktionieren sie wie erwartet.  Manchmal verhalten sie sich jedoch unerwartet, was leicht zu Fehlern f√ºhren kann. </li><li>  Sie erh√∂hen das Sprachvolumen im Austausch f√ºr kleine Vorteile.  Solche M√∂glichkeiten bieten dem Entwickler einige kleine Vorteile, erfordern jedoch jemanden, der versucht, seinen Code herauszufinden, um Kenntnisse √ºber bestimmte Mechanismen zu haben, die normalerweise irgendwo versteckt sind.  Dies gilt in zweifacher Hinsicht f√ºr API-Funktionen. Wenn Sie diese Funktion verwenden, bedeutet dies, dass anderer Code, der mit Code interagiert, der von einem bestimmten Entwickler geschrieben wurde, die Anwendung dieser API-Funktion kennen muss. </li></ul><br>  Lassen Sie uns nun anhand dieser √úberlegungen √ºber die Schw√§chen von ES6 sprechen. <br><br><h2>  <font color="#3AC1EF">Schl√ºsselwort const</font> </h2><br>  Vor ES6 konnten Variablen in JavaScript mit dem Schl√ºsselwort <code>var</code> deklariert werden.  Au√üerdem konnten Variablen √ºberhaupt nicht deklariert werden, dann fallen sie, selbst wenn sie in Funktionen verwendet werden, in den globalen Bereich.  Eigenschaften von Objekten k√∂nnen die Rolle von Variablen spielen, und Funktionen werden mit dem <code>function</code> deklariert.  Das Schl√ºsselwort <code>var</code> hat bestimmte Funktionen. <br><br>  Auf diese Weise k√∂nnen Sie Variablen erstellen, die dem globalen Objekt hinzugef√ºgt werden oder deren Umfang durch Funktionen begrenzt ist.  Das Schl√ºsselwort <code>var</code> ber√ºcksichtigt jedoch keine Codebl√∂cke.  Dar√ºber hinaus k√∂nnen Sie auf eine Variable verweisen, die mit dem Schl√ºsselwort <code>var</code> im Code vor dem Befehl f√ºr ihre Deklaration deklariert wurde.  Dieses Ph√§nomen wird als Erh√∂hen von Variablen bezeichnet.  Wenn diese Funktionen nicht ber√ºcksichtigt werden, k√∂nnen sie zu Fehlern f√ºhren.  Um die Situation zu korrigieren, f√ºhrte ES6 zwei neue Schl√ºsselw√∂rter f√ºr die Deklaration von Variablen ein: <code>let</code> und <code>const</code> .  Sie l√∂sten die Hauptprobleme <code>var</code> .  Wir sprechen n√§mlich √ºber die Tatsache, dass Variablen, die mit diesen Schl√ºsselw√∂rtern deklariert wurden, einen Blockbereich haben, sodass beispielsweise eine in einer Schleife deklarierte Variable au√üerhalb dieser Schleife nicht sichtbar ist.  Dar√ºber hinaus erm√∂glicht die Verwendung von <code>let</code> und <code>const</code> keinen Zugriff auf Variablen, bevor diese deklariert werden.  Dies f√ºhrt zu einem <code>ReferenceError</code> Fehler.  Dies war ein gro√üer Schritt nach vorne.  Das Auftauchen von zwei neuen Schl√ºsselw√∂rtern sowie deren Funktionen f√ºhrte jedoch zu zus√§tzlicher Verwirrung. <br><br>  Der Wert einer Variablen (Konstante), die mit dem Schl√ºsselwort <code>const</code> deklariert wurde, kann nach der Deklaration nicht √ºberschrieben werden.  Dies ist der einzige Unterschied zwischen <code>const</code> und <code>let</code> .  Diese neue Gelegenheit sieht n√ºtzlich aus und kann wirklich einige Vorteile bringen.  Das Problem ist das <code>const</code> Schl√ºsselwort selbst.  Die Art und Weise, wie sich die deklarierten Konstanten verhalten, entspricht nicht dem, was die meisten Entwickler mit dem Konzept der ‚ÄûKonstante‚Äú assoziieren. <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  Die Verwendung des Schl√ºsselworts <code>const</code> verhindert, dass ein neuer Wert in eine Konstante geschrieben wird, macht jedoch Objekte, auf die von solchen Konstanten verwiesen wird, nicht unver√§nderlich.  Diese Funktion bietet einen schlechten Schutz gegen Wert√§nderungen bei der Arbeit mit den meisten Datentypen.  Aufgrund der Tatsache, dass die Verwendung von <code>const</code> zu Verwirrung f√ºhren kann, und aufgrund der Tatsache, dass das Vorhandensein von <code>const</code> redundant aussieht, wenn das Schl√ºsselwort <code>let</code> vorhanden ist, habe ich mich entschieden, immer <code>let</code> . <br><br><h2>  <font color="#3AC1EF">Tagged Template Strings</font> </h2><br>  Das Schl√ºsselwort <code>const</code> ist ein Beispiel daf√ºr, wie eine Spezifikation zu viele M√∂glichkeiten zur L√∂sung zu weniger Probleme schafft.  Bei getaggten Vorlagenzeichenfolgen ist die Situation umgekehrt.  Die Syntax solcher Zeichenfolgen wurde vom TC39-Komitee als eine M√∂glichkeit zur L√∂sung von Zeichenfolgeninterpolation und mehrzeiligen Zeichenfolgen angesehen.  Dann beschlossen sie, diese M√∂glichkeit durch den Einsatz von Makros zu erweitern. <br><br>  Wenn Sie noch nie markierte Musterzeichenfolgen gesehen haben, denken Sie daran, dass sie ein bisschen wie Zeichenfolgendekoratoren sind.  Hier ist ein Beispiel f√ºr die Arbeit mit ihnen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> : <br><br><pre> <code class="hljs powershell">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var output = myTag`that <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ person } is a <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ age }`; console.log(output); // that Mike is a youngster</code> </pre> <br>  Mit Tags versehene Vorlagenzeichenfolgen k√∂nnen nicht als v√∂llig nutzlos bezeichnet werden.  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersicht √ºber</a> einige ihrer Anwendungen.  Sie sind beispielsweise beim L√∂schen von HTML-Code hilfreich.  Derzeit zeigt ihre Anwendung den genauesten Ansatz in Situationen, in denen Sie dieselbe Operation f√ºr alle Eingabedaten einer beliebigen Zeichenfolgenvorlage ausf√ºhren m√ºssen.  Dies ist jedoch relativ selten. Sie k√∂nnen dies auch mit der entsprechenden API tun (obwohl eine solche L√∂sung l√§nger ist).  Um die meisten Probleme zu l√∂sen, ist die Verwendung der API nicht schlechter als die Verwendung von mit Tags versehenen Vorlagenzeichenfolgen.  Diese Funktion f√ºgt der Sprache keine neuen Funktionen hinzu.  Sie f√ºgt neue Ans√§tze f√ºr die Arbeit mit Daten hinzu, die denen vertraut sein sollten, die Code lesen m√ºssen, der mit markierten Vorlagenzeichenfolgen geschrieben wurde.  Und ich bem√ºhe mich sicherzustellen, dass mein Code so sauber und verst√§ndlich wie m√∂glich bleibt. <br><br><h2>  <font color="#3AC1EF">√úberarbeitete destruktive Zuweisungsausdr√ºcke</font> </h2><br>  Einige Funktionen der Sprache sehen gut aus, wenn sie zur L√∂sung einfacher Aufgaben verwendet werden. Wenn Aufgaben jedoch komplexer werden, k√∂nnen diese Funktionen au√üer Kontrolle geraten.  Zum Beispiel mag ich den tern√§ren bedingten Operator: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  Mit dem mit seiner Hilfe geschriebenen Code wird es jedoch schwierig zu verstehen, ob Sie mit diesem Operator verschachtelte Konstruktionen verwenden: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  Gleiches gilt f√ºr die destruktive Zuordnung.  Mit diesem Mechanismus k√∂nnen Sie die Werte von Variablen aus Objekten oder Arrays abrufen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  Dar√ºber hinaus k√∂nnen Sie bei Verwendung Variablen umbenennen, verschachtelte Werte abrufen und Standardwerte festlegen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  All dies ist wunderbar - bis es darum geht, komplexe Ausdr√ºcke mit all diesen Funktionen zu erstellen.  Im folgenden Ausdruck werden beispielsweise 4 Variablen deklariert: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> und <code>eventId</code> .  Ihre Werte werden von verschiedenen Stellen in der Struktur des <code>eventRecord</code> Objekts √ºbernommen. <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  Einen solchen Code zu verstehen ist fast unm√∂glich.  Dieses Problem kann mit viel besser lesbarem Code gel√∂st werden, wenn Sie mehrere Destrukturierungsvorg√§nge verwenden oder diese vollst√§ndig aufgeben. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  Ich habe keine klare Richtlinie, die darauf hinweist, dass der Ausdruck der destruktiven Aufgabe √ºberarbeitet werden muss.  Jedes Mal, wenn ich einen √§hnlichen Ausdruck betrachte und nicht sofort verstehen kann, welches Problem er l√∂st und welche Variablen darin verwendet werden, ist es an der Zeit, den Code zu vereinfachen, um seine Lesbarkeit zu verbessern. <br><br><h2>  <font color="#3AC1EF">Standardexport</font> </h2><br>  ES6 hat eine nette Funktion.  Es besteht darin, wie seine Entwickler die Standardisierung dessen, was zuvor getan wurde, mit Hilfe verschiedener Bibliotheken angegangen sind, die h√§ufig miteinander konkurrieren.  So erschienen in der Spezifikation Klassen, Versprechen, Module.  Dies ist alles, was die JS-Entwicklergemeinde vor ES6 verwendet hat und in Bibliotheken von Drittanbietern gefunden hat.  Zum Beispiel sind ES6-Module ein hervorragender Ersatz f√ºr das, was in den AMD / CommonJS-Formatkrieg √ºbergegangen ist, und bieten eine bequeme Syntax f√ºr die Organisation von Importen. <br><br>  ES6-Module unterst√ºtzen zwei Hauptmethoden zum Exportieren von Werten: benannter Export und Standardexport oder Standardexport: <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  Ein Modul kann mehrere benannte Exportbefehle verwenden, jedoch nur einen Standardexportbefehl.  Wenn Sie importieren, was mit dem Standardexportbefehl exportiert wurde, k√∂nnen Sie in der Importdatei jedem Namen, der standardm√§√üig exportiert wird, einen beliebigen Namen geben, da w√§hrend dieses Vorgangs keine Namen gesucht werden.  Wenn Sie den benannten Export verwenden, m√ºssen Sie die Variablennamen aus den exportierenden Dateien verwenden, obwohl auch das Umbenennen m√∂glich ist. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  Der Standardexport fand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei den Entwicklern des</a> ES6-Standards <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besondere Beachtung</a> und erstellte absichtlich eine einfachere Syntax daf√ºr.  In der Praxis konnte ich jedoch feststellen, dass die Verwendung der benannten Exporttechnologie aus den folgenden Gr√ºnden vorzuziehen ist. <br><br><ol><li>  Bei Verwendung des benannten Exports entsprechen die Namen der exportierten Variablen standardm√§√üig den Namen der importierten Variablen, was die Suche nach Personen vereinfacht, die keine intelligenten Entwicklungstools verwenden. </li><li>  Bei der Verwendung benannter Exporte erhalten Programmierer, die intelligente Entwicklungstools verwenden, so praktische Funktionen wie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatischen Import</a> . </li><li>  Mit benannten Exporten k√∂nnen Sie alles, was Sie wollen, in den richtigen Mengen einheitlich aus den Modulen exportieren.  Der Standardexport beschr√§nkt den Entwickler darauf, nur einen einzelnen Wert zu exportieren.  Um dieses Problem zu umgehen, k√∂nnen Sie den Export eines Objekts mit mehreren Eigenschaften anwenden.  Dieser Ansatz verliert jedoch den Wert des Tree-Shaking-Algorithmus, der zum Reduzieren der Gr√∂√üe von JS-Anwendungen verwendet wird, die von so etwas wie Webpack erstellt wurden.  Die Verwendung ausschlie√ülich benannter Module vereinfacht die Arbeit. </li></ol><br>  Im Allgemeinen kann festgestellt werden, dass das Benennen von Entit√§ten eine gute Vorgehensweise ist, da Sie sie sowohl im Code als auch in Gespr√§chen √ºber diesen Code eindeutig identifizieren k√∂nnen.  Deshalb verwende ich den benannten Export. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Sie haben gerade die Funktionen von ES6 kennengelernt, die laut dem Autor dieses Materials nicht erfolgreich sind.  Vielleicht schlie√üen Sie sich dieser Meinung an, vielleicht auch nicht.  Jede Programmiersprache ist ein komplexes System, dessen Funktionen aus verschiedenen Blickwinkeln betrachtet werden k√∂nnen.  Wir hoffen jedoch, dass dieser Artikel allen n√ºtzlich sein wird, die klaren und qualitativ hochwertigen Code schreiben m√∂chten. <br><br>  <b>Liebe Leser!</b>  Gibt es etwas in modernem JavaScript, das Sie vermeiden m√∂chten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417383/">https://habr.com/ru/post/de417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417369/index.html">15 Tools f√ºr das Arbeitsarsenal des Produktmanagers</a></li>
<li><a href="../de417373/index.html">ZFS-Speicher-, Standby- und Testumgebungen</a></li>
<li><a href="../de417375/index.html">15 HTML-Elementmethoden, von denen Sie wahrscheinlich noch nie geh√∂rt haben</a></li>
<li><a href="../de417377/index.html">Warum sollten Sie Google Cloud nicht verwenden?</a></li>
<li><a href="../de417379/index.html">Neuer Feststoffraketenmotor f√ºr Vega-C und Ariane 6</a></li>
<li><a href="../de417385/index.html">Wie ich umgezogen bin ... nach Hause oder meine Antwort an den Autor des Artikels √ºber "gnadenloses Mehl"</a></li>
<li><a href="../de417389/index.html">Tilt Shift Lens-Effekt</a></li>
<li><a href="../de417391/index.html">Browser√ºbergreifende Web-Erweiterung f√ºr benutzerdefinierte Skripte Teil 4</a></li>
<li><a href="../de417393/index.html">Wie wir ein System geschaffen haben, das Kunden Rabatte basierend auf individuellen Merkmalen zuweist</a></li>
<li><a href="../de417395/index.html">End-to-End-Tests: Was, warum, warum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>