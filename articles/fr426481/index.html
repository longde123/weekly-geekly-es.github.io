<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µ üìß üçú Cartes hexagonales dans Unity: Path Finder, Player Squads, Animations üôéüèº üëò ü§™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivi√®res et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: Path Finder, Player Squads, Animations</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426481/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivi√®res et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, √©quipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, √©rosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 16: trouver le chemin </h1><br><ul><li>  Mettre en surbrillance les cellules </li><li>  S√©lectionnez une cible de recherche </li><li>  Trouvez le chemin le plus court </li><li>  Cr√©er une file d'attente prioritaire </li></ul><br>  Apr√®s avoir calcul√© les distances entre les cellules, nous avons proc√©d√© √† la recherche des chemins entre elles. <br><br>  √Ä partir de cette partie, des didacticiels de carte hexagonale seront cr√©√©s dans Unity 5.6.0.  Il convient de noter qu'en 5.6, il existe un bogue qui d√©truit les tableaux de textures dans les assemblys pour plusieurs plates-formes.  Vous pouvez le contourner en incluant <em>Is Readable</em> dans l'inspecteur de tableau de textures. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>Planifier un voyage</i> <br><a name="habracut"></a><br><h2>  Cellules en surbrillance </h2><br>  Pour rechercher le chemin entre deux cellules, nous devons d'abord s√©lectionner ces cellules.  C‚Äôest plus que de choisir une cellule et de surveiller la recherche sur la carte.  Par exemple, nous allons d'abord s√©lectionner la cellule initiale, puis la derni√®re.  Dans ce cas, il serait pratique qu'ils soient mis en √©vidence.  Par cons√©quent, ajoutons une telle fonctionnalit√©.  Jusqu'√† ce que nous cr√©ons un moyen complexe ou efficace de mettre en √©vidence, nous cr√©ons juste quelque chose pour nous aider dans le d√©veloppement. <br><br><h3>  Texture de contour </h3><br>  Une fa√ßon simple de s√©lectionner des cellules consiste √† leur ajouter un chemin.  Pour ce faire, la m√©thode la plus simple consiste √† utiliser une texture contenant un contour hexagonal.  <a href="">Ici,</a> vous pouvez t√©l√©charger une telle texture.  Il est transparent √† l'exception du contour blanc de l'hexagone.  Apr√®s l'avoir rendu blanc, nous pourrons √† l'avenir le coloriser selon nos besoins. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>Contour de cellule sur fond noir</i> <br><br>  Importez la texture et d√©finissez son <em>type de texture</em> sur <em>Sprite</em> .  Son <em>mode Sprite</em> sera d√©fini sur <em>Single</em> avec les param√®tres par d√©faut.  Comme il s'agit d'une texture exceptionnellement blanche, nous n'avons pas besoin de convertir en <em>sRGB</em> .  Le canal alpha indique la transparence, donc activer <em>Alpha est Transparence</em> .  J'ai √©galement d√©fini la texture du <em>mode de filtre</em> sur <em>Trilin√©aire</em> , car sinon les transitions de mip pour les chemins peuvent devenir trop visibles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>Options d'importation de texture</i> <br><br><h3>  Un sprite par cellule </h3><br>  Le moyen le plus rapide consiste √† ajouter un contour possible aux cellules, en ajoutant chaque sprite.  Cr√©ez un nouvel objet de jeu, ajoutez-y le composant Image ( <em>Component / UI / Image</em> ) et affectez-lui notre sprite de contour.  Ins√©rez ensuite l'instance de pr√©fabriqu√© <em>Hex Cell Label</em> dans la sc√®ne, faites-en un objet sprite, appliquez les modifications au pr√©fabriqu√©, puis supprimez-le. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>√âl√©ment de s√©lection enfant pr√©fabriqu√©</i> <br><br>  Maintenant, chaque cellule a un sprite, mais il sera trop grand.  Pour que les contours correspondent aux centres des cellules, modifiez la <em>largeur</em> et la <em>hauteur</em> du composant de transformation de l'image-objet √† 17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>Sprites de s√©lection partiellement cach√©s par un relief</i> <br><br><h3>  Dessiner par dessus tout </h3><br>  Le contour √©tant superpos√© √† la surface des bords des alv√©oles, il appara√Æt souvent sous la g√©om√©trie du relief.  Pour cette raison, une partie du circuit dispara√Æt.  Cela peut √™tre √©vit√© en √©levant l√©g√®rement les sprites verticalement, mais pas en cas de pauses.  Au lieu de cela, nous pouvons faire ce qui suit: toujours dessiner des sprites au-dessus de tout le reste.  Pour ce faire, cr√©ez votre propre shader de sprite.  Il nous suffira de copier le shader de sprite Unity standard et d'y apporter quelques modifications. <br><br><pre><code class="hljs powershell">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Highlight"</span></span> { Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">MaterialToggle</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelSnap</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Pixel snap"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RendererColor</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"RendererColor"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Flip"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableExternalAlpha</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Enable External Alpha"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"PreviewType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Plane"</span></span> <span class="hljs-string"><span class="hljs-string">"CanUseSpriteAtlas"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> } Cull Off ZWrite Off Blend One OneMinusSrcAlpha Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">#pragma vertex SpriteVert #pragma fragment SpriteFrag #pragma target 2.0 #pragma multi_compile_instancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #include "UnitySprites.cginc" ENDCG } } }</span></span></code> </pre> <br>  Le premier changement est que nous ignorons le tampon de profondeur, ce qui fait que le test Z r√©ussit toujours. <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br>  Le deuxi√®me changement est que nous effectuons le rendu apr√®s le reste de la g√©om√©trie transparente.  De quoi ajouter 10 √† la file d'attente de transparence. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br>  Cr√©ez un nouveau mat√©riau que ce shader utilisera.  Nous pouvons ignorer toutes ses propri√©t√©s, en respectant les valeurs par d√©faut.  Faites ensuite le pr√©fabriqu√© sprite utiliser ce mat√©riau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>Nous utilisons notre propre mat√©riau sprite</i> <br><br>  D√©sormais, les contours de la s√©lection sont toujours visibles.  M√™me si la cellule est cach√©e sous un relief plus √©lev√©, son contour sera toujours dessin√© au-dessus de tout le reste.  Cela peut ne pas √™tre beau, mais les cellules s√©lectionn√©es seront toujours visibles, ce qui est utile pour nous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>Ignorer le tampon de profondeur</i> <br><br><h3>  Contr√¥le de s√©lection </h3><br>  Nous ne voulons pas que toutes les cellules soient mises en √©vidence en m√™me temps.  En fait, au d√©part, ils devraient tous √™tre d√©s√©lectionn√©s.  Nous pouvons impl√©menter cela en d√©sactivant le composant Image de l'objet pr√©fabriqu√© <em>Highlight</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>Composant d'image d√©sactiv√©</i> <br><br>  Pour activer la s√©lection de cellules, ajoutez la m√©thode <code>EnableHighlight</code> √† <code>EnableHighlight</code> .  Il doit prendre le seul enfant de son <code>uiRect</code> et inclure son composant Image.  Nous allons √©galement cr√©er la m√©thode <code>DisableHighlight</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Enfin, nous pouvons sp√©cifier la couleur de sorte que lorsqu'il est allum√©, donner au r√©tro-√©clairage une teinte. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Trouver le chemin </h2><br>  Maintenant que nous pouvons s√©lectionner les cellules, nous devons avancer et s√©lectionner deux cellules, puis trouver le chemin entre elles.  Nous devons d'abord s√©lectionner les cellules, puis restreindre la recherche √† un chemin entre elles, et enfin montrer ce chemin. <br><br><h3>  D√©but de la recherche </h3><br>  Nous devons s√©lectionner deux cellules diff√©rentes, les points de d√©but et de fin de la recherche.  Supposons que pour s√©lectionner la cellule de recherche initiale, maintenez la touche Maj enfonc√©e tout en cliquant avec la souris.  Dans ce cas, la cellule est surlign√©e en bleu.  Nous devons enregistrer le lien vers cette cellule pour une recherche plus approfondie.  De plus, lors du choix d'une nouvelle cellule de d√©part, la s√©lection de l'ancienne doit √™tre d√©sactiv√©e.  Par cons√©quent, nous ajoutons le champ <code>searchFromCell</code> √† <code>searchFromCell</code> . <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br>  √Ä l'int√©rieur de <code>HandleInput</code> nous pouvons utiliser <code>Input.GetKey(KeyCode.LeftShift)</code> pour tester la touche Maj enfonc√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>O√π chercher</i> <br><br><h3>  Point de terminaison de recherche </h3><br>  Au lieu de rechercher toutes les distances d'une cellule, nous recherchons maintenant un chemin entre deux cellules sp√©cifiques.  Par cons√©quent, renommez <code>HexGrid.FindDistancesTo</code> en <code>HexGrid.FindPath</code> et attribuez-lui le deuxi√®me param√®tre <code>HexCell</code> . Modifiez √©galement la m√©thode <code>Search</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); ‚Ä¶ }</code> </pre> <br>  D√©sormais, <code>HexMapEditor.HandleInput</code> doit appeler la m√©thode modifi√©e, en utilisant <code>searchFromCell</code> et <code>currentCell</code> comme arguments.  De plus, nous ne pouvons rechercher que lorsque nous savons √† partir de quelle cellule effectuer la recherche.  Et nous n'avons pas √† nous soucier de rechercher si les points de d√©but et de fin co√Øncident. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br>  En ce qui concerne la recherche, nous devons d'abord nous d√©barrasser de toutes les s√©lections pr√©c√©dentes.  Par cons√©quent, faites <code>HexGrid.Search</code> d√©sactiver la s√©lection lors de la r√©initialisation des distances.  Comme cela d√©sactive √©galement l'√©clairage de la cellule initiale, puis rallumez-le.  √Ä ce stade, nous pouvons √©galement mettre en √©vidence le point final.  Faisons-la rouge. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>Points finaux d'un chemin potentiel</i> <br><br><h3>  Limiter la recherche </h3><br>  √Ä ce stade, notre algorithme de recherche calcule toujours les distances de toutes les cellules accessibles depuis la cellule de d√©part.  Mais nous n'en avons plus besoin.  Nous pouvons nous arr√™ter d√®s que nous trouvons la distance finale √† la cellule finale.  Autrement dit, lorsque la cellule actuelle est finie, nous pouvons quitter la boucle d'algorithme. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>Arr√™tez-vous au point final</i> <br><br><div class="spoiler">  <b class="spoiler_title">Que se passe-t-il si le point final ne peut pas √™tre atteint?</b> <div class="spoiler_text">  Ensuite, l'algorithme continuera de fonctionner jusqu'√† ce qu'il trouve toutes les cellules accessibles.  Sans la possibilit√© d'une sortie pr√©matur√©e, cela fonctionnera comme l'ancienne m√©thode <code>FindDistancesTo</code> . </div></div><br><h3>  Affichage du chemin </h3><br>  Nous pouvons trouver la distance entre le d√©but et la fin du chemin, mais nous ne savons pas encore quel sera le vrai chemin.  Pour le trouver, vous devez suivre la fa√ßon dont chaque cellule est atteinte.  Mais comment faire? <br><br>  Lors de l'ajout d'une cellule √† la bordure, nous le faisons car c'est un voisin de la cellule actuelle.  La seule exception est la cellule de d√©part.  Toutes les autres cellules ont √©t√© atteintes via la cellule actuelle.  Si nous gardons une trace de la cellule √† partir de laquelle chaque cellule a √©t√© atteinte, nous obtenons un r√©seau de cellules en cons√©quence.  Plus pr√©cis√©ment, un r√©seau arborescent dont la racine est le point de d√©part.  Nous pouvons l'utiliser pour construire le chemin apr√®s avoir atteint le point final. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>R√©seau d'arbres d√©crivant les chemins vers le centre</i> <br><br>  Nous pouvons enregistrer ces informations en ajoutant un lien vers une autre cellule dans <code>HexCell</code> .  Nous n'avons pas besoin de s√©rialiser ces donn√©es, nous utilisons donc la propri√©t√© standard pour cela. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dans <code>HexGrid.Search</code> d√©finissez la valeur <code>PathFrom</code> du voisin sur la cellule actuelle lors de son ajout √† la bordure.  De plus, nous devons changer ce lien lorsque nous trouvons un chemin plus court vers le voisin. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br>  Apr√®s avoir atteint le point final, nous pouvons visualiser le chemin en suivant ces liens vers la cellule de d√©part et en les s√©lectionnant. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>Chemin trouv√©</i> <br><br>  Il convient de noter qu'il existe souvent plusieurs chemins les plus courts.  Celui trouv√© d√©pend de l'ordre de traitement des cellules.  Certains chemins peuvent sembler bons, d'autres peuvent √™tre mauvais, mais il n'y a jamais de chemin plus court.  Nous y reviendrons plus tard. <br><br><h3>  Modifier le d√©but de la recherche </h3><br>  Apr√®s avoir s√©lectionn√© le point de d√©part, la modification du point de fin d√©clenchera une nouvelle recherche.  La m√™me chose devrait se produire lors du choix d'une nouvelle cellule de d√©part.  Pour rendre cela possible, <code>HexMapEditor</code> doit √©galement se souvenir du point de terminaison. <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br>  En utilisant ce champ, nous pouvons √©galement lancer une nouvelle recherche lors du choix d'un nouveau d√©part. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br>  De plus, nous devons √©viter des points de d√©part et d'arriv√©e √©gaux. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { ‚Ä¶ }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Recherche plus intelligente </h2><br>  Bien que notre algorithme trouve le chemin le plus court, il passe beaucoup de temps √† explorer des points qui ne feront √©videmment pas partie de ce chemin.  Au moins, c'est √©vident pour nous.  L'algorithme ne peut pas regarder vers le bas sur la carte; il ne peut pas voir qu'une recherche dans certaines directions n'aura aucun sens.  Il pr√©f√®re se d√©placer sur les routes, malgr√© le fait qu'elles se dirigent dans la direction oppos√©e au point final.  Est-il possible de rendre la recherche plus intelligente? <br><br>  Pour le moment, lors du choix de la cellule √† traiter ensuite, nous consid√©rons uniquement la distance entre la cellule et le d√©but.  Si nous voulons faire plus intelligemment, nous devons √©galement tenir compte de la distance jusqu'au point final.  Malheureusement, nous ne le connaissons pas encore.  Mais nous pouvons cr√©er une estimation de la distance restante.  L'ajout de cette estimation √† la distance de la cellule nous donne une compr√©hension de la longueur totale du chemin passant par cette cellule.  Ensuite, nous pouvons l'utiliser pour prioriser les recherches de cellules. <br><br><h3>  Recherche heuristique </h3><br>  Lorsque nous utilisons une estimation ou une conjecture au lieu de donn√©es exactement connues, cela s'appelle utiliser une heuristique de recherche.  Cette heuristique repr√©sente la meilleure estimation de la distance restante.  Nous devons d√©terminer cette valeur pour chaque cellule que nous recherchons, nous allons donc lui ajouter une propri√©t√© enti√®re <code>HexCell</code> .  Nous n'avons pas besoin de le s√©rialiser, donc une autre propri√©t√© standard suffira. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Comment faire une hypoth√®se sur la distance restante?  Dans le cas le plus id√©al, nous aurons une route menant directement au point d'arriv√©e.  Si c'est le cas, alors la distance est √©gale √† la distance inchang√©e entre les coordonn√©es de cette cellule et la cellule finale.  Profitons de cela dans notre heuristique. <br><br>  √âtant donn√© que l'heuristique ne d√©pend pas d'un chemin d√©j√† parcouru, elle est constante dans le processus de recherche.  Par cons√©quent, nous devons le calculer une seule fois lorsque <code>HexGrid.Search</code> ajoute une cellule √† la bordure. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3>  Priorit√© de recherche </h3><br>  D√©sormais, nous d√©terminerons la priorit√© de la recherche en fonction de la distance √† la cellule plus son heuristique.  Ajoutons une propri√©t√© pour cette valeur dans <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br>  Pour que cela fonctionne, <code>HexGrid.Search</code> afin qu'il utilise cette propri√©t√© pour trier la bordure. <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>Recherche sans heuristique et avec heuristique</i> <br><br><h3>  Heuristique valide </h3><br>  Gr√¢ce aux nouvelles priorit√©s de recherche, nous allons en fait visiter moins de cellules.  Cependant, sur une carte uniforme, l'algorithme traite toujours les cellules qui sont dans la mauvaise direction.  En effet, par d√©faut, les co√ªts pour chaque √©tape de d√©placement sont de 5, et l'heuristique n'ajoute que 1 par √©tape, c'est-√†-dire que l'influence de l'heuristique n'est pas tr√®s forte. <br><br>  Si les co√ªts de d√©placement sur toutes les cartes sont les m√™mes, alors nous pouvons utiliser les m√™mes co√ªts lors de la d√©termination de l'heuristique.  Dans notre cas, ce sera l'heuristique actuelle multipli√©e par 5. Cela r√©duira consid√©rablement le nombre de cellules trait√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>Utiliser l'heuristique √ó 5</i> <br><br>  Cependant, s'il y a des routes sur la carte, nous pouvons surestimer la distance restante.  Par cons√©quent, l'algorithme peut faire des erreurs et cr√©er un chemin qui n'est en fait pas le plus court. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>Heuristique sur√©valu√©e et valide</i> <br><br>  Pour s'assurer que le chemin le plus court est trouv√©, nous devons nous assurer de ne jamais surestimer la distance restante.  Cette approche est appel√©e heuristique valide.  Le co√ªt minimum de d√©placement √©tant de 1, nous n'avons d'autre choix que d'utiliser les m√™mes co√ªts pour d√©terminer l'heuristique. <br><br>  √Ä strictement parler, il est tout √† fait normal d'utiliser des co√ªts encore plus bas, mais cela ne fera que rendre l'heuristique plus faible.  L'heuristique minimale possible est z√©ro, ce qui nous donne juste l'algorithme de Dijkstra.  Avec une heuristique non nulle, l'algorithme est appel√© A <sup>*</sup> (prononc√© "A star"). <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi est-il appel√© A *?</b> <div class="spoiler_text">  L'id√©e d'ajouter une heuristique √† l'algorithme de Dijkstra a √©t√© propos√©e pour la premi√®re fois par Niels Nilsson.  Il a nomm√© sa version A1.  Bertram Rafael a propos√© plus tard la meilleure version qu'il a appel√©e A2.  Ensuite, Peter Hart a prouv√© qu'avec une bonne heuristique, A2 est optimal, c'est-√†-dire qu'il ne peut y avoir de meilleure version.  Cela l'a forc√© √† appeler l'algorithme A <sup>*</sup> pour montrer qu'il ne pouvait pas √™tre am√©lior√©, c'est-√†-dire que A3 ou A4 n'appara√Ætraient pas.  Alors oui, l'algorithme A <sup>*</sup> est le meilleur que nous puissions obtenir, mais il est aussi bon que son heuristique. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  File d'attente prioritaire </h2><br>  Bien que A <sup>* soit un</sup> bon algorithme, notre impl√©mentation n'est pas aussi efficace, car pour stocker la bordure, nous utilisons une liste qui doit √™tre tri√©e √† chaque it√©ration.  Comme mentionn√© dans la partie pr√©c√©dente, nous avons besoin d'une file d'attente prioritaire, mais son impl√©mentation standard n'existe pas.  Par cons√©quent, cr√©ons-le vous-m√™me. <br><br>  Notre tour doit prendre en charge l'op√©ration de d√©finition et d'exclusion de la file d'attente en fonction de la priorit√©.  Il doit √©galement prendre en charge la modification de la priorit√© d'une cellule d√©j√† dans la file d'attente.  Id√©alement, nous l'impl√©mentons en minimisant la recherche de tri et la m√©moire allou√©e.  De plus, cela doit rester simple. <br><br><h3>  Cr√©ez votre propre file d'attente </h3><br>  Cr√©ez une nouvelle classe <code>HexCellPriorityQueue</code> avec les m√©thodes courantes requises.  Nous utilisons une simple liste pour suivre le contenu d'une file d'attente.  De plus, nous y ajouterons la m√©thode <code>Clear</code> pour effacer la file d'attente afin qu'elle puisse √™tre utilis√©e √† plusieurs reprises. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br>  Nous stockons les priorit√©s des cellules dans les cellules elles-m√™mes.  Autrement dit, avant d'ajouter une cellule √† la file d'attente, sa priorit√© doit √™tre d√©finie.  Mais en cas de changement de priorit√©, il sera probablement utile de savoir quelle √©tait l'ancienne priorit√©.  Ajoutons donc ceci √† <code>Change</code> comme param√®tre. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Il est √©galement utile de conna√Ætre le nombre de cellules dans la file d'attente, ajoutons donc la propri√©t√© <code>Count</code> pour cela.  Utilisez simplement le champ pour lequel nous allons effectuer l'incr√©mentation et la d√©cr√©mentation correspondantes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3>  Ajouter √† la file d'attente </h3><br>  Lorsqu'une cellule est ajout√©e √† la file d'attente, utilisons d'abord sa priorit√© comme index, en traitant la liste comme un simple tableau. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br>  Cependant, cela ne fonctionne que si la liste est suffisamment longue, sinon nous d√©passerons les fronti√®res.  Vous pouvez √©viter cela en ajoutant des √©l√©ments vides √† la liste jusqu'√† ce qu'elle atteigne la longueur requise.  Ces √©l√©ments vides ne r√©f√©rencent pas la cellule, vous pouvez donc les cr√©er en ajoutant <code>null</code> √† la liste. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>Liste avec trous</i> <br><br>  Mais c'est ainsi que nous stockons une seule cellule par priorit√©, et il y en aura probablement plusieurs.  Pour suivre toutes les cellules avec la m√™me priorit√©, nous devons utiliser une autre liste.  Bien que nous puissions utiliser une vraie liste pour chaque priorit√©, nous pouvons √©galement ajouter une propri√©t√© √† <code>HexCell</code> pour les lier ensemble.  Cela nous permet de cr√©er une cha√Æne de cellules appel√©e liste cha√Æn√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Pour cr√©er une cha√Æne, laissez <code>HexCellPriorityQueue.Enqueue</code> forcer la cellule nouvellement ajout√©e √† se r√©f√©rer √† la valeur actuelle avec la m√™me priorit√©, avant de la supprimer. <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>Liste des listes li√©es</i> <br><br><h3>  Supprimer de la file d'attente </h3><br>  Pour obtenir une cellule d'une file d'attente prioritaire, nous devons acc√©der √† la liste li√©e √† l'index non vide le plus bas.  Par cons√©quent, nous allons parcourir la liste en boucle jusqu'√† ce que nous la trouvions.  Si nous ne trouvons pas, alors la file d'attente est vide et nous retournons <code>null</code> . <br><br>  De la cha√Æne trouv√©e, nous pouvons renvoyer n'importe quelle cellule, car elles ont toutes la m√™me priorit√©.  Le moyen le plus simple consiste √† renvoyer la cellule depuis le d√©but de la cha√Æne. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Pour conserver le lien vers la cha√Æne restante, utilisez la cellule suivante avec la m√™me priorit√© que le nouveau d√©part.  S'il n'y avait qu'une seule cellule √† ce niveau de priorit√©, alors l'√©l√©ment devient <code>null</code> et sera ignor√© √† l'avenir. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3>  Suivi minimum </h3><br>  Cette approche fonctionne, mais parcourt la liste chaque fois qu'une cellule est re√ßue.  Nous ne pouvons pas √©viter de trouver le plus petit indice non vide, mais nous ne sommes pas tenus de recommencer √† z√©ro √† chaque fois.  Au lieu de cela, nous pouvons suivre la priorit√© minimale et commencer la recherche avec elle.  Initialement, le minimum est essentiellement √©gal √† l'infini. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br>  Lors de l'ajout d'une cellule √† la file d'attente, nous modifions le minimum si n√©cessaire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } ‚Ä¶ }</code> </pre> <br>  Et lors du retrait de la file d'attente, nous utilisons au moins la liste pour les it√©rations, et ne partons pas de z√©ro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Cela r√©duit consid√©rablement le temps n√©cessaire pour parcourir la boucle de liste de priorit√©s. <br><br><h3>  Changer les priorit√©s </h3><br>  Lors de la modification de la priorit√© d'une cellule, elle doit √™tre supprim√©e de la liste cha√Æn√©e dont elle fait partie.  Pour ce faire, nous devons suivre la cha√Æne jusqu'√† ce que nous la trouvions. <br><br>  Commen√ßons par d√©clarer que la t√™te de l'ancienne liste de priorit√© sera la cellule actuelle, et nous suivrons √©galement la cellule suivante.  Nous pouvons imm√©diatement prendre la cellule suivante, car nous savons qu'il y a au moins une cellule par cet indice. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br>  Si la cellule actuelle est une cellule modifi√©e, il s'agit de la cellule principale et nous pouvons la couper comme si nous l'avions retir√©e de la file d'attente. <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br>  Si ce n'est pas le cas, alors nous devons suivre la cha√Æne jusqu'√† ce que nous soyons dans la cellule en face de la cellule modifi√©e.  Il contient un lien vers la cellule qui a √©t√© modifi√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br>  √Ä ce stade, nous pouvons supprimer la cellule modifi√©e de la liste li√©e, en la sautant. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br>  Apr√®s avoir supprim√© une cellule, vous devez l'ajouter √† nouveau pour qu'elle apparaisse dans la liste de sa nouvelle priorit√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Enqueue(cell); }</code> </pre> <br>  La m√©thode <code>Enqueue</code> incr√©mente le compteur, mais en r√©alit√© nous <code>Enqueue</code> pas de nouvelle cellule.  Par cons√©quent, afin de compenser cela, nous devrons d√©cr√©menter le compteur. <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3>  Utilisation de la file d'attente </h3><br>  Nous pouvons maintenant profiter de notre file d'attente prioritaire chez <code>HexGrid</code> .  Cela peut √™tre fait avec une seule instance, r√©utilisable pour toutes les op√©rations de recherche. <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de d√©marrer la boucle, la m√©thode </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit d'abord √™tre ajout√©e √† la file d'attente </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et chaque it√©ration commence par la sortie de la cellule de la file d'attente. </font><font style="vertical-align: inherit;">Cela remplacera l'ancien code frontalier.</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le code afin qu'il ajoute et modifie le voisin. </font><font style="vertical-align: inherit;">Avant le changement, nous nous souviendrons de l'ancienne priorit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, nous n'avons plus besoin de trier la fronti√®re. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche √† l'aide d'une file d'attente prioritaire</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme mentionn√© pr√©c√©demment, le chemin le plus court trouv√© d√©pend de l'ordre de traitement des cellules. </font><font style="vertical-align: inherit;">Notre tour cr√©e un ordre diff√©rent de l'ordre de la liste tri√©e, nous pouvons donc obtenir d'autres moyens. </font><font style="vertical-align: inherit;">Puisque nous ajoutons et supprimons de la t√™te de la liste li√©e pour chaque priorit√©, ils ressemblent plus √† des piles qu'√† des files d'attente. </font><font style="vertical-align: inherit;">Les cellules ajout√©es en dernier sont trait√©es en premier. </font><font style="vertical-align: inherit;">Un effet secondaire de cette approche est que l'algorithme est sujet au zigzag. </font><font style="vertical-align: inherit;">Par cons√©quent, la probabilit√© de chemins en zigzag augmente √©galement. </font><font style="vertical-align: inherit;">Heureusement, ces chemins semblent g√©n√©ralement meilleurs, donc cet effet secondaire est en notre faveur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">tri√©e </font></a><i><font style="vertical-align: inherit;">et file d'attente avec priorit√© au </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet unitaire</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 17: mouvement limit√© </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous trouvons des moyens pour un mouvement pas √† pas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichez imm√©diatement le chemin. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cr√©ons une recherche plus efficace. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous visualisons uniquement le chemin. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette partie, nous allons diviser le mouvement en mouvements et acc√©l√©rer autant que possible la recherche. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyagez √† partir de plusieurs mouvements</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement pas √† pas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les jeux de strat√©gie qui utilisent des filets hexagonaux sont presque toujours au tour par tour. </font><font style="vertical-align: inherit;">Les unit√©s se d√©pla√ßant sur la carte ont une vitesse limit√©e, ce qui limite la distance parcourue en un tour.</font></font><br><br><h3>  La vitesse </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour fournir un support pour un mouvement limit√©, nous ajoutons dans </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et dans le </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre entier </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il d√©termine l'amplitude de mouvement pour un mouvement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rents types d'unit√©s dans le jeu utilisent des vitesses diff√©rentes. </font><font style="vertical-align: inherit;">La cavalerie est rapide, l'infanterie est lente, etc. </font><font style="vertical-align: inherit;">Nous n'avons pas encore d'unit√©s, donc pour l'instant nous allons utiliser une vitesse constante. </font><font style="vertical-align: inherit;">Prenons une valeur de 24. Il s'agit d'une valeur assez grande, non divisible par 5 (le co√ªt par d√©faut du d√©m√©nagement). </font><font style="vertical-align: inherit;">Ajouter un argument pour </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une vitesse constante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se d√©place </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de suivre le co√ªt total du d√©placement le long du chemin, nous devons maintenant √©galement savoir combien de mouvements il faudra pour se d√©placer le long de celui-ci. Mais nous n'avons pas besoin de stocker ces informations dans chaque cellule. Il peut √™tre obtenu en divisant la distance parcourue par la vitesse. Puisque ce sont des entiers, nous utiliserons la division enti√®re. C'est-√†-dire que les distances totales ne d√©passant pas 24 correspondent au parcours 0. Cela signifie que l'ensemble du chemin peut √™tre compl√©t√© dans le parcours actuel. Si le point final est √† une distance de 30, alors ce doit √™tre le tour 1. Pour arriver au point final, l'unit√© devra d√©penser tout son mouvement dans le tour en cours et en partie dans le tour suivant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©terminons le cours de la cellule actuelle et de tous ses voisins √† l'int√©rieur</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le parcours de la cellule courante ne peut √™tre calcul√© qu'une seule fois, juste avant de faire le tour du cycle voisin. </font><font style="vertical-align: inherit;">Le mouvement du voisin peut √™tre d√©termin√© d√®s que nous trouvons la distance qui le s√©pare.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement perdu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le mouvement du voisin est sup√©rieur au mouvement actuel, alors nous avons travers√© la limite du mouvement. </font><font style="vertical-align: inherit;">Si le mouvement n√©cessaire pour atteindre un voisin √©tait de 1, alors tout va bien. </font><font style="vertical-align: inherit;">Mais si passer √† la cellule suivante co√ªte plus cher, alors tout devient plus compliqu√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que nous nous d√©placions le long d'une carte homog√®ne, c'est-√†-dire que pour entrer dans chaque cellule, vous avez besoin de 5 unit√©s de mouvement. </font><font style="vertical-align: inherit;">Notre vitesse est de 24. Apr√®s quatre √©tapes, nous avons d√©pens√© 20 unit√©s de notre stock de mouvement, et il en reste 4. Dans l'√©tape suivante, 5 unit√©s sont √† nouveau n√©cessaires, c'est-√†-dire une de plus que celles disponibles. </font><font style="vertical-align: inherit;">Que devons-nous faire √† ce stade?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux approches √† cette situation. La premi√®re consiste √† permettre √† l'unit√© d'entrer dans la cinqui√®me cellule du tour en cours, m√™me si nous n'avons pas assez de mouvement. La seconde consiste √† interdire le mouvement pendant le mouvement en cours, c'est-√†-dire que les points de mouvement restants ne peuvent pas √™tre utilis√©s et ils seront perdus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le choix de l'option d√©pend du jeu. En g√©n√©ral, la premi√®re approche est plus appropri√©e pour les jeux dans lesquels les unit√©s ne peuvent se d√©placer que de quelques pas par tour, par exemple, pour les jeux de la s√©rie Civilization. Cela garantit que les unit√©s peuvent toujours se d√©placer d'au moins une cellule par tour. Si les unit√©s peuvent d√©placer plusieurs cellules par tour, comme dans Age of Wonders ou Battle for Wesnoth, alors la deuxi√®me option est meilleure.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous utilisons la vitesse 24, choisissons la deuxi√®me approche. </font><font style="vertical-align: inherit;">Pour qu'il commence √† fonctionner, nous devons isoler les co√ªts de l'acc√®s √† la cellule suivante avant de l'ajouter √† la distance actuelle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si, par cons√©quent, nous traversons la fronti√®re du mouvement, nous utilisons d'abord tous les points de mouvement du mouvement en cours. </font><font style="vertical-align: inherit;">Nous pouvons le faire en multipliant simplement le mouvement par la vitesse. </font><font style="vertical-align: inherit;">Apr√®s cela, nous ajoutons le co√ªt du d√©m√©nagement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä la suite de cela, nous terminerons le premier mouvement dans la quatri√®me cellule avec 4 points de mouvement inutilis√©s. </font><font style="vertical-align: inherit;">Ces points perdus sont ajout√©s aux co√ªts de la cinqui√®me cellule, donc sa distance devient 29, et non 25. En cons√©quence, les distances sont plus grandes qu'auparavant. </font><font style="vertical-align: inherit;">Par exemple, la dixi√®me cellule avait une distance de 50. Mais maintenant, pour y entrer, nous devons traverser les fronti√®res de deux mouvements, perdant 8 points de mouvement, c'est-√†-dire que la distance √† celle-ci devient maintenant 58.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus long que pr√©vu</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtant donn√© que les points de mouvement inutilis√©s sont ajout√©s aux distances aux cellules, ils sont pris en compte lors de la d√©termination du chemin le plus court. </font><font style="vertical-align: inherit;">Le moyen le plus efficace est de perdre le moins de points possible. </font><font style="vertical-align: inherit;">Par cons√©quent, √† diff√©rentes vitesses, nous pouvons obtenir diff√©rents chemins.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichage des mouvements au lieu des distances </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous jouons au jeu, nous ne sommes pas tr√®s int√©ress√©s par les valeurs de distance utilis√©es pour trouver le chemin le plus court. </font><font style="vertical-align: inherit;">Nous sommes int√©ress√©s par le nombre de mouvements n√©cessaires pour atteindre le point final. </font><font style="vertical-align: inherit;">Par cons√©quent, au lieu des distances, affichons les mouvements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, d√©barrassez-vous de </font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son appel </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } ‚Ä¶ // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de cela, nous ajouterons √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode g√©n√©rale </font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui re√ßoit une cha√Æne arbitraire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette nouvelle m√©thode pour </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nettoyer les cellules. </font><font style="vertical-align: inherit;">Pour masquer les cellules, affectez-les simplement </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous attribuons √† la marque du voisin la valeur de son mouvement. </font><font style="vertical-align: inherit;">Apr√®s cela, nous pourrons voir combien de mouvements suppl√©mentaires il faudra pour aller jusqu'au bout.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre de mouvements requis pour se d√©placer le long du chemin du </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chemins instantan√©s </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, lorsque nous jouons au jeu, peu nous importe comment l'algorithme de recherche de chemin trouve le chemin. </font><font style="vertical-align: inherit;">Nous voulons voir le chemin demand√© imm√©diatement. </font><font style="vertical-align: inherit;">Pour le moment, nous pouvons √™tre s√ªrs que l'algorithme fonctionne, alors d√©barrassons-nous de la visualisation de la recherche.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sans corutine </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour un passage lent dans l'algorithme, nous avons utilis√© la corutine. </font><font style="vertical-align: inherit;">Nous n'avons plus besoin de le faire, nous allons donc nous d√©barrasser des appels </font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous l'invoquons simplement </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme m√©thode r√©guli√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); ‚Ä¶ } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous ne l'utilisons plus </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme coroutine, il n'a pas besoin de rendement, nous allons donc nous d√©barrasser de cet op√©rateur. </font><font style="vertical-align: inherit;">Cela signifie que nous supprimerons √©galement la d√©claration </font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et changerons le type de retour de la m√©thode en </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); ‚Ä¶ } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultats instantan√©s</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finition du temps de recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons obtenir les chemins instantan√©ment, mais √† quelle vitesse sont-ils calcul√©s? Les chemins courts apparaissent presque imm√©diatement, mais les chemins longs sur les grandes cartes peuvent sembler un peu lents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesurons le temps qu'il faut pour rechercher et afficher le chemin. Nous pouvons utiliser un profileur pour d√©terminer le temps de recherche, mais c'est un peu trop et cr√©e des co√ªts suppl√©mentaires. Utilisons √† la place </font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui se trouve dans l'espace de noms </font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme nous ne l'utilisons que temporairement, je n'ajouterai pas la construction </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au d√©but du script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juste avant la recherche, cr√©ez un nouveau chronom√®tre et d√©marrez-le. Une fois la recherche termin√©e, arr√™tez le chronom√®tre et affichez le temps √©coul√© dans la console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choisissons le pire cas pour notre algorithme - une recherche du coin inf√©rieur gauche au coin sup√©rieur droit d'une grande carte. Le pire est une carte uniforme, car l'algorithme devra traiter les 4 800 cellules de la carte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechercher dans le pire des cas Le temps</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass√© √† le rechercher peut √™tre diff√©rent, car l'√©diteur Unity n'est pas le seul processus en cours d'ex√©cution sur votre machine. Alors testez-le plusieurs fois pour comprendre la dur√©e moyenne. Dans mon cas, la recherche prend environ 45 millisecondes. Ce n'est pas beaucoup et correspond √† 22,22 trajets par seconde; d√©notons cela comme 22 pps (chemins par seconde). Cela signifie que la fr√©quence d'images du jeu diminuera √©galement d'un maximum de 22 ips dans cette image lorsque ce chemin sera calcul√©. Et cela sans tenir compte de tous les autres travaux, par exemple, le rendu du cadre lui-m√™me. Autrement dit, nous obtenons une diminution assez importante de la fr√©quence d'images, elle tombera √† 20 ips.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous effectuez un tel test de performances, vous devez tenir compte du fait que les performances de l'√©diteur Unity ne seront pas aussi √©lev√©es que les performances de l'application termin√©e. </font><font style="vertical-align: inherit;">Si je fais le m√™me test avec l'assemblage, cela ne prendra en moyenne que 15 ms. </font><font style="vertical-align: inherit;">C'est 66 pps, ce qui est beaucoup mieux. </font><font style="vertical-align: inherit;">N√©anmoins, cela repr√©sente toujours une grande partie des ressources allou√©es par trame, de sorte que la fr√©quence d'images deviendra inf√©rieure √† 60 ips.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O√π puis-je voir le journal de d√©bogage de l'assembly?</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherchez uniquement si n√©cessaire. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons faire une optimisation simple - effectuer une recherche uniquement lorsque cela est n√©cessaire. </font><font style="vertical-align: inherit;">Pendant que nous lan√ßons une nouvelle recherche dans chaque image dans laquelle le bouton de la souris est maintenu enfonc√©. </font><font style="vertical-align: inherit;">Par cons√©quent, la fr√©quence d'images sera constamment sous-estim√©e lors du glisser-d√©poser. </font><font style="vertical-align: inherit;">Nous pouvons √©viter cela en n'initiant une nouvelle recherche </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que lorsque nous avons vraiment affaire √† un nouveau point de terminaison. </font><font style="vertical-align: inherit;">Sinon, le chemin visible actuel est toujours valide.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afficher les √©tiquettes uniquement pour le chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'affichage des marques de d√©placement est une op√©ration assez co√ªteuse, notamment parce que nous utilisons une approche non optimis√©e. </font><font style="vertical-align: inherit;">L'ex√©cution de cette op√©ration pour toutes les cellules ralentira certainement l'ex√©cution. </font><font style="vertical-align: inherit;">Alors sautons l'√©tiquetage </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons voir ces informations uniquement pour le chemin trouv√©. </font><font style="vertical-align: inherit;">Par cons√©quent, apr√®s avoir atteint le point final, nous calculerons le parcours et d√©finirons les √©tiquettes des seules cellules en cours de route.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affichage des √©tiquettes pour les cellules de chemin uniquement</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous n'incluons maintenant que les √©tiquettes de cellule entre le d√©but et la fin. </font><font style="vertical-align: inherit;">Mais le point final est la chose la plus importante, nous devons √©galement lui attribuer une √©tiquette. </font><font style="vertical-align: inherit;">Vous pouvez le faire en d√©marrant le cycle de chemin √† partir de la cellule de destination, et non √† partir de la cellule en face d'elle. </font><font style="vertical-align: inherit;">Dans ce cas, l'√©clairage du point final du rouge passera au blanc, nous supprimerons donc son r√©tro-√©clairage sous le cycle.</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les informations de progression sont les plus importantes pour le noeud final.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s ces modifications, le pire des cas est r√©duit √† 23 millisecondes dans l'√©diteur et √† 6 millisecondes dans l'assemblage termin√©. </font><font style="vertical-align: inherit;">Ce sont 43 pps et 166 pps - beaucoup mieux. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La recherche la plus intelligente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie pr√©c√©dente, nous avons rendu la proc√©dure de recherche plus intelligente en impl√©mentant l'algorithme A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cependant, en r√©alit√©, nous n'effectuons toujours pas la recherche de la mani√®re la plus optimale. </font><font style="vertical-align: inherit;">√Ä chaque it√©ration, nous calculons les distances de la cellule actuelle √† tous ses voisins. </font><font style="vertical-align: inherit;">Cela est vrai pour les cellules qui ne sont pas encore ou font actuellement partie de la bordure de recherche. </font><font style="vertical-align: inherit;">Mais les cellules qui ont d√©j√† √©t√© retir√©es de la fronti√®re, n'ont plus besoin d'√™tre prises en compte, car nous avons d√©j√† trouv√© le chemin le plus court vers ces cellules. </font><font style="vertical-align: inherit;">L'impl√©mentation correcte de A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ignore ces cellules, nous pouvons donc faire de m√™me.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Phase de recherche de cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment savoir si une cellule a d√©j√† quitt√© la fronti√®re? </font><font style="vertical-align: inherit;">Bien que nous ne pouvons pas d√©terminer cela. </font><font style="vertical-align: inherit;">Par cons√©quent, vous devez suivre dans quelle phase de la recherche se trouve la cellule. </font><font style="vertical-align: inherit;">Elle n'est pas encore √† la fronti√®re, elle y est maintenant ou est √† l'√©tranger. </font><font style="vertical-align: inherit;">Nous pouvons suivre cela en ajoutant √† une </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple propri√©t√© enti√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, 0 signifie que les cellules n'ont pas encore atteint, 1 - que la cellule est maintenant dans la bordure et 2 - qu'elle a d√©j√† √©t√© supprim√©e de la bordure. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frapper la fronti√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons r√©initialiser toutes les cellules √† 0 et toujours utiliser 1 pour la bordure. </font><font style="vertical-align: inherit;">Ou nous pouvons augmenter le nombre de fronti√®res √† chaque nouvelle recherche. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, nous n'aurons pas √† faire face au d√©versement de cellules si nous augmentons √† chaque fois le nombre de fronti√®res de deux.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant d√©finir la phase de la recherche de cellules lors de leur ajout √† la bordure. </font><font style="vertical-align: inherit;">Le processus commence par une cellule initiale, qui est ajout√©e √† la bordure.</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et aussi chaque fois que nous ajoutons un voisin √† la fronti√®re. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contr√¥le des fronti√®res </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, pour v√©rifier que la cellule n'a pas encore √©t√© ajout√©e √† la bordure, nous avons utilis√© une distance √©gale √† </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons comparer la phase de la recherche de cellules avec la bordure actuelle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela signifie que nous n'avons plus besoin de r√©initialiser les distances des cellules avant de chercher, c'est-√†-dire que nous devrons faire moins de travail, ce qui est bien. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quitter la fronti√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une cellule est retir√©e de la fronti√®re, nous d√©signons cela par une augmentation de sa phase de recherche. </font><font style="vertical-align: inherit;">Cela la place au-del√† de la fronti√®re actuelle et avant la suivante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant ignorer les cellules retir√©es de la fronti√®re, en √©vitant le calcul inutile et la comparaison des distances. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, notre algorithme produit toujours les m√™mes r√©sultats, mais plus efficacement. </font><font style="vertical-align: inherit;">Sur ma machine, la recherche du pire des cas prend 20 ms dans l'√©diteur et 5 ms dans l'assemblage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons √©galement calculer combien de fois la cellule a √©t√© trait√©e par l'algorithme, augmentant le compteur lors du calcul de la distance √† la cellule. </font><font style="vertical-align: inherit;">Auparavant, notre algorithme dans le pire des cas calculait 28 239 distances. </font><font style="vertical-align: inherit;">Dans l'algorithme A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pr√™t √† l'emploi, </font><font style="vertical-align: inherit;">nous calculons ses 14 120 distances. </font><font style="vertical-align: inherit;">Le montant a diminu√© de 50%. </font><font style="vertical-align: inherit;">Le degr√© d'impact de ces indicateurs sur la productivit√© d√©pend des co√ªts de calcul du co√ªt du d√©m√©nagement. </font><font style="vertical-align: inherit;">Dans notre cas, il n'y a pas beaucoup de travail ici, donc l'am√©lioration de l'assemblage n'est pas tr√®s importante, mais elle est tr√®s perceptible dans l'√©diteur. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ouvrir la voie </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous lancez une nouvelle recherche, nous devons d'abord effacer la visualisation du chemin pr√©c√©dent. </font><font style="vertical-align: inherit;">Pendant ce temps, d√©sactivez la s√©lection et supprimez les √©tiquettes de chaque cellule de la grille. </font><font style="vertical-align: inherit;">Il s'agit d'une approche tr√®s difficile. </font><font style="vertical-align: inherit;">Id√©alement, nous devons √©liminer uniquement les cellules qui faisaient partie du chemin pr√©c√©dent.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rechercher uniquement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par supprimer compl√®tement le code de visualisation de </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'a qu'√† effectuer une recherche de chemin et n'a pas √† savoir ce que nous ferons de ces informations.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } ‚Ä¶ } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour signaler que </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons trouv√© un moyen, nous reviendrons bool√©en.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rappelez-vous le chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque le chemin est trouv√©, nous devons nous en souvenir. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, nous pourrons le nettoyer √† l'avenir. </font><font style="vertical-align: inherit;">Par cons√©quent, nous allons suivre les points d'extr√©mit√© et voir s'il existe un chemin entre eux.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afficher √† nouveau le chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser les donn√©es de recherche que nous avons enregistr√©es pour visualiser √† nouveau le chemin. </font><font style="vertical-align: inherit;">Cr√©ons une nouvelle m√©thode pour cela </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il parcourra le cycle de la fin au d√©but du chemin, mettant en √©vidence les cellules et attribuant une valeur de trait √† leurs √©tiquettes. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons conna√Ætre la vitesse, alors faites-en un param√®tre. </font><font style="vertical-align: inherit;">Si nous n'avons pas de chemin, la m√©thode s√©lectionne simplement les points de terminaison.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez cette m√©thode </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apr√®s la recherche.</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balayer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous revoyons le chemin, mais maintenant il ne s'√©loigne pas. </font><font style="vertical-align: inherit;">Pour l'effacer, cr√©ez une m√©thode </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fait, c'est une copie </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sauf qu'elle d√©sactive la s√©lection et les √©tiquettes, mais ne les inclut pas. </font><font style="vertical-align: inherit;">Cela fait, il doit effacer les donn√©es de chemin enregistr√©es qui ne sont plus valides.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant cette m√©thode, nous pouvons effacer la visualisation de l'ancien chemin en visitant uniquement les cellules n√©cessaires, la taille de la carte n'est plus importante. </font><font style="vertical-align: inherit;">Nous l'appellerons </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de lancer une nouvelle recherche.</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, nous effacerons le chemin lors de la cr√©ation d'une nouvelle carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et aussi avant de charger une autre carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visualisation du chemin est √† nouveau effac√©e, comme avant ce changement. </font><font style="vertical-align: inherit;">Mais maintenant, nous utilisons une approche plus efficace, et dans le pire des cas, le temps est pass√© √† 14 millisecondes. </font><font style="vertical-align: inherit;">Assez d'am√©liorations s√©rieuses uniquement gr√¢ce √† un nettoyage plus intelligent. </font><font style="vertical-align: inherit;">Le temps d'assemblage a √©t√© r√©duit √† 3 ms, ce qui repr√©sente 333 points par seconde. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, la recherche de chemins est exactement applicable en temps r√©el. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons effectu√© une recherche rapide des chemins, nous pouvons supprimer le code de d√©bogage temporaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 18: unit√©s </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pla√ßons les escouades sur la carte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrez et chargez les escouades. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous trouvons des moyens pour les troupes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous d√©pla√ßons les unit√©s. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant que nous avons compris comment rechercher un chemin, pla√ßons les escouades sur la carte. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des renforts sont arriv√©s</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©er des escouades </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous n'avons trait√© que des cellules et de leurs objets fixes. </font><font style="vertical-align: inherit;">Les unit√©s diff√®rent d'eux en ce qu'elles sont mobiles. </font><font style="vertical-align: inherit;">Une escouade peut signifier n'importe quelle √©chelle, d'une personne ou d'un v√©hicule √† une arm√©e enti√®re. </font><font style="vertical-align: inherit;">Dans ce tutoriel, nous nous limitons √† un type d'unit√© g√©n√©ralis√© simple. </font><font style="vertical-align: inherit;">Apr√®s cela, nous passerons √† la prise en charge de combinaisons de plusieurs types d'unit√©s.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escouade pr√©fabriqu√©e </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour travailler avec des escouades, cr√©ez un nouveau type de composant </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour l'instant, commen√ßons par un vide </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutons plus tard des fonctionnalit√©s.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un objet de jeu vide avec ce composant, qui devrait devenir un pr√©fabriqu√©. </font><font style="vertical-align: inherit;">Ce sera l'objet racine de l'√©quipe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escouade pr√©fabriqu√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un mod√®le 3D symbolisant le d√©tachement en tant qu'objet enfant. </font><font style="vertical-align: inherit;">J'ai utilis√© un simple cube √† l'√©chelle pour lequel j'ai cr√©√© un mat√©riau bleu. </font><font style="vertical-align: inherit;">L'objet racine d√©termine le niveau du sol du d√©tachement, par cons√©quent, nous d√©pla√ßons en cons√©quence l'√©l√©ment enfant.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âl√©ment de cube enfant</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez un collisionneur √† l'√©quipe afin qu'il soit plus facile de le s√©lectionner √† l'avenir. </font><font style="vertical-align: inherit;">Le collisionneur du cube standard nous convient tout √† fait, il suffit de le placer dans une seule cellule.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation d'instances d'escouade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous n'avons pas encore de gameplay, la cr√©ation d'unit√©s se fait en mode √©dition. </font><font style="vertical-align: inherit;">Par cons√©quent, cela devrait √™tre r√©solu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ce faire, il a besoin d'un pr√©fabriqu√©, alors ajoutez un champ </font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et connectez-le.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion du pr√©fabriqu√©</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de la cr√©ation d'unit√©s, nous les placerons sur la cellule sous le curseur. </font><font style="vertical-align: inherit;">Il </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe un code pour trouver cette cellule lors de la modification d'un terrain. </font><font style="vertical-align: inherit;">Maintenant, nous en avons √©galement besoin pour les escouades, nous allons donc d√©placer le code correspondant vers une m√©thode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant utiliser cette m√©thode pour la </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplifier.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { ‚Ä¶ } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, ajoutez une nouvelle m√©thode </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui utilise √©galement </font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">S'il y a une cellule, nous cr√©erons une nouvelle √©quipe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour garder la hi√©rarchie propre, utilisons la grille comme parent pour tous les objets de jeu dans les escouades. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fa√ßon la plus simple d'ajouter la </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prise en charge de la cr√©ation d'unit√©s consiste √† appuyer sur une touche. </font><font style="vertical-align: inherit;">Modifiez la m√©thode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'elle appelle </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque vous appuyez sur la touche U. Comme avec c </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela doit se produire si le curseur n'est pas au-dessus de l'√©l√©ment GUI. </font><font style="vertical-align: inherit;">Tout d'abord, nous v√©rifierons si nous devons modifier la carte, et sinon, nous v√©rifierons si nous devons ajouter une √©quipe. </font><font style="vertical-align: inherit;">Si oui, appelez </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instance cr√©√©e de l'escouade</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Placement des troupes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant cr√©er des unit√©s, mais elles apparaissent √† l'origine de la carte. </font><font style="vertical-align: inherit;">Nous devons les mettre au bon endroit. </font><font style="vertical-align: inherit;">Pour cela, il faut que les troupes soient conscientes de leur position. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajoutons √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquant la cellule qu'ils occupent. </font><font style="vertical-align: inherit;">Lors de la d√©finition de la propri√©t√©, nous modifierons la position de l'escouade afin qu'elle corresponde √† la position de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois attribuer la position de la cellule de l'escouade sous le curseur. </font><font style="vertical-align: inherit;">Ensuite, les unit√©s seront l√† o√π elles devraient.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escouades sur la carte</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Orientation de l'unit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, toutes les unit√©s ont la m√™me orientation, ce qui semble peu naturel. </font><font style="vertical-align: inherit;">Pour les faire revivre, ajoutez √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit d'une valeur flottante qui indique la rotation de l'escouade le long de l'axe Y en degr√©s. </font><font style="vertical-align: inherit;">Lors de sa configuration, nous modifierons en cons√©quence la rotation de l'objet de jeu lui-m√™me.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assigner une rotation al√©atoire de 0 √† 360 degr√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rentes orientations d'unit√©</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une escouade par cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les unit√©s semblent bonnes si elles ne sont pas cr√©√©es dans une cellule. </font><font style="vertical-align: inherit;">Dans ce cas, nous obtenons un groupe de cubes √©tranges.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit√©s superpos√©es</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Certains jeux permettent de placer plusieurs unit√©s au m√™me endroit, d'autres non. </font><font style="vertical-align: inherit;">Puisqu'il est plus facile de travailler avec une escouade par cellule, je choisirai cette option. </font><font style="vertical-align: inherit;">Cela signifie que nous ne devons cr√©er une nouvelle escouade que lorsque la cellule actuelle n'est pas occup√©e. </font><font style="vertical-align: inherit;">Pour que vous puissiez le d√©couvrir, ajoutez-le √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© standard </font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette propri√©t√© </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour faire savoir √† la cellule si l'unit√© s'y trouve.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut </font><font style="vertical-align: inherit;">maintenant </font><font style="vertical-align: inherit;">v√©rifier si la cellule actuelle est libre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modification des cellules occup√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialement, les unit√©s sont plac√©es correctement, mais tout peut changer si leurs cellules sont modifi√©es ult√©rieurement. </font><font style="vertical-align: inherit;">Si la hauteur de la cellule change, alors l'unit√© qui l'occupe sera suspendue au-dessus d'elle ou y plongera.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escouades suspendues et noy√©es</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La solution consiste √† v√©rifier la position de l'escouade apr√®s avoir effectu√© des modifications. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez la m√©thode √† </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous ne sommes int√©ress√©s que par la position de l'√©quipe, alors posez-la √† nouveau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons coordonner la position du d√©tachement lors de la mise √† jour de la cellule, ce qui se passe lorsque les m√©thodes </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou l' </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet sont </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appel√©s. </font><font style="vertical-align: inherit;">Bien s√ªr, cela n'est n√©cessaire que lorsqu'il y a vraiment un d√©tachement dans la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supprimer des escouades </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de cr√©er des unit√©s, il serait utile de les d√©truire. </font><font style="vertical-align: inherit;">Par cons√©quent, ajoutez √† la </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il doit v√©rifier s'il y a un d√©tachement dans la cellule sous le curseur, et si c'est le cas, d√©truire l'objet de jeu du d√©tachement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter que pour arriver dans l'√©quipe, nous traversons la cellule. </font><font style="vertical-align: inherit;">Pour interagir avec l'√©quipe, d√©placez simplement la souris sur sa cellule. </font><font style="vertical-align: inherit;">Par cons√©quent, pour que cela fonctionne, l'√©quipe n'a pas besoin d'avoir un collisionneur. </font><font style="vertical-align: inherit;">Cependant, l'ajout d'un collisionneur facilite la s√©lection car il bloque les rayons qui autrement entreraient en collision avec la cellule derri√®re l'escouade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisons </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une combinaison de Shift gauche + U </font><font style="vertical-align: inherit;">pour d√©truire l'√©quipe </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas o√π nous cr√©ons et d√©truisons plusieurs unit√©s, soyons prudents et effa√ßons la propri√©t√© lors du retrait de l'unit√©. </font><font style="vertical-align: inherit;">Autrement dit, nous effa√ßons explicitement le lien cellulaire vers l'√©quipe. </font><font style="vertical-align: inherit;">Ajoutez √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui traite de cela, ainsi que la destruction de votre propre objet de jeu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appellerons cette m√©thode </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ne d√©truirons pas directement l'√©quipe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sauvegarde et chargement des escouades </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons avoir des unit√©s sur la carte, nous devons les inclure dans le processus d'enregistrement et de chargement. </font><font style="vertical-align: inherit;">Nous pouvons aborder cette t√¢che de deux mani√®res. </font><font style="vertical-align: inherit;">La premi√®re consiste √† enregistrer les donn√©es de l'escouade lors de l'enregistrement d'une cellule afin que les donn√©es de la cellule et de l'escouade soient m√©lang√©es. </font><font style="vertical-align: inherit;">La deuxi√®me fa√ßon consiste √† enregistrer les donn√©es de cellule et d'escouade s√©par√©ment. </font><font style="vertical-align: inherit;">Bien qu'il puisse sembler que la premi√®re approche soit plus facile √† mettre en ≈ìuvre, la seconde nous donne des donn√©es plus structur√©es. </font><font style="vertical-align: inherit;">Si nous partageons les donn√©es, il sera plus facile de travailler avec elles √† l'avenir.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi des unit√©s </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garder toutes les unit√©s ensemble, nous devons les suivre. </font><font style="vertical-align: inherit;">Nous le ferons en ajoutant √† la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liste des unit√©s. </font><font style="vertical-align: inherit;">Cette liste doit contenir toutes les unit√©s sur la carte.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la cr√©ation ou du chargement d'une nouvelle carte, nous devons nous d√©barrasser de toutes les unit√©s sur la carte. </font><font style="vertical-align: inherit;">Pour simplifier ce processus, cr√©ez une m√©thode </font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui tue tout le monde sur la liste et l'efface.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appelons cette m√©thode in </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et in </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Faisons-le apr√®s avoir nettoy√© le chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); ClearUnits(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout d'escouades √† la grille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lors de la cr√©ation de nouvelles unit√©s, nous devons les ajouter √† la liste. </font><font style="vertical-align: inherit;">D√©finissons une m√©thode pour cela </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui traitera √©galement de l'emplacement de l'escouade et des param√®tres de son objet parent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suffira d'appeler </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec une nouvelle instance du d√©tachement, son emplacement et son orientation al√©atoire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supprimer des escouades de la grille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode pour supprimer l'escouade et c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il suffit de retirer l'√©quipe de la liste et de lui ordonner de mourir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appelons cette m√©thode au </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lieu de d√©truire directement l'√©quipe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrement des unit√©s </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous allons garder toutes les unit√©s ensemble, nous devons nous rappeler quelles cellules elles occupent. </font><font style="vertical-align: inherit;">Le moyen le plus fiable consiste √† enregistrer les coordonn√©es de leur emplacement. </font><font style="vertical-align: inherit;">Pour rendre cela possible, nous ajoutons les </font><font style="vertical-align: inherit;">champs X et Z </font><font style="vertical-align: inherit;">√† la </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui l'√©crit.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut maintenant enregistrer les coordonn√©es et l'orientation de l'√©quipe. </font><font style="vertical-align: inherit;">Ce sont toutes les donn√©es des unit√©s que nous avons en ce moment.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suit les unit√©s, sa m√©thode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrera les donn√©es des unit√©s. </font><font style="vertical-align: inherit;">Tout d'abord, notez le nombre total d'unit√©s, puis contournez-les toutes en boucle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons modifi√© les donn√©es stock√©es, nous allons donc augmenter le num√©ro de version </font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† 2. L'ancien code de d√©marrage fonctionnera toujours, car il ne lira tout simplement pas les donn√©es de l'√©quipe. </font><font style="vertical-align: inherit;">Cependant, vous devez augmenter le num√©ro de version pour indiquer que le fichier contient des informations sur l'unit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escouades de chargement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'agit d'une structure, cela n'a pas beaucoup de sens d'y ajouter la m√©thode habituelle </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Faisons-en une m√©thode statique qui lit et renvoie les coordonn√©es stock√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme le nombre d'unit√©s est variable, nous n'avons pas d'unit√©s pr√©existantes dans lesquelles les donn√©es peuvent √™tre charg√©es. </font><font style="vertical-align: inherit;">Nous pouvons cr√©er de nouvelles instances d'unit√©s avant de charger leurs donn√©es, mais cela n√©cessitera que nous </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©ons des instances de nouvelles unit√©s au d√©marrage. </font><font style="vertical-align: inherit;">Il vaut donc mieux le laisser </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous utilisons √©galement la m√©thode statique </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Commen√ßons par lire simplement ces escouades. </font><font style="vertical-align: inherit;">Pour lire la valeur du flotteur d'orientation, nous utilisons la m√©thode </font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi c√©libataire?</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©tape suivante consiste √† cr√©er une instance d'une nouvelle √©quipe. </font><font style="vertical-align: inherit;">Cependant, pour cela, nous avons besoin d'un lien vers le pr√©fabriqu√© de l'unit√©. </font><font style="vertical-align: inherit;">Afin de ne pas le compliquer encore, ajoutons une </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode statique </font><font style="vertical-align: inherit;">pour cela </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©finir ce lien, utilisons-le √† nouveau </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme nous l'avons fait avec la texture du bruit. </font><font style="vertical-align: inherit;">Lorsque nous devons prendre en charge de nombreux types d'unit√©s, nous allons passer √† une meilleure solution.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous passons le pr√©fabriqu√© de l'unit√©.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir connect√© le terrain, nous n'avons plus besoin d'un lien direct vers </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, il peut utiliser </font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; ‚Ä¶ void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant cr√©er une instance de la nouvelle √©quipe dans </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de le renvoyer, nous pouvons utiliser les coordonn√©es et l'orientation charg√©es pour l'ajouter √† la grille. </font><font style="vertical-align: inherit;">Pour rendre cela possible, ajoutez un param√®tre </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fin de compte, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous comptons le nombre d'unit√©s et l'utilisons pour charger toutes les unit√©s stock√©es, en nous passant comme argument suppl√©mentaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien s√ªr, cela ne fonctionnera que pour les fichiers de sauvegarde dont la version n'est pas inf√©rieure √† 2, dans les versions plus r√©centes, il n'y a pas d'unit√©s √† charger. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant t√©l√©charger correctement les fichiers de la version 2, </font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmentez donc le nombre de versions prises en charge √† 2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement des troupes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les escouades sont mobiles, nous devons donc pouvoir les d√©placer sur la carte. </font><font style="vertical-align: inherit;">Nous avons d√©j√† un code de recherche de chemin, mais jusqu'√† pr√©sent, nous l'avons test√© uniquement pour des endroits arbitraires. </font><font style="vertical-align: inherit;">Nous devons maintenant supprimer l'ancienne interface utilisateur de test et cr√©er une nouvelle interface utilisateur pour la gestion des effectifs.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nettoyage de l'√©diteur de carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©placer des unit√©s le long des chemins fait partie du gameplay, cela ne s'applique pas √† l'√©diteur de carte. </font><font style="vertical-align: inherit;">Par cons√©quent, nous nous d√©barrasserons </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de tout le code associ√© √† la recherche du chemin.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir supprim√© ce code, il n'est plus logique de laisser l'√©diteur actif lorsque nous ne sommes pas en mode √©dition. </font><font style="vertical-align: inherit;">Par cons√©quent, au lieu d'un champ de suivi de mode, nous pouvons simplement activer ou d√©sactiver le composant </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De plus, l'√©diteur n'a plus √† g√©rer les √©tiquettes d'interface utilisateur.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; ‚Ä¶ public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque par d√©faut, nous ne sommes pas en mode d'√©dition de carte, dans Awake, nous d√©sactiverons l'√©diteur. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utiliser raycast pour rechercher la cellule actuelle sous le curseur est n√©cessaire lors de la modification de la carte et pour g√©rer les unit√©s. </font><font style="vertical-align: inherit;">Peut-√™tre qu'√† l'avenir, il nous sera utile pour autre chose. </font><font style="vertical-align: inherit;">Passons de la logique de diffusion de </font><font style="vertical-align: inherit;">rayons </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† une nouvelle m√©thode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un param√®tre de faisceau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut simplement appeler cette m√©thode avec le faisceau du curseur. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interface utilisateur du jeu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour contr√¥ler l'interface utilisateur du mode de jeu, nous utiliserons un nouveau composant. </font><font style="vertical-align: inherit;">Bien qu'il ne s'occupe que de la s√©lection et du mouvement des unit√©s. </font><font style="vertical-align: inherit;">Cr√©ez-lui un nouveau type de composant </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un lien vers la grille lui suffit pour faire son travail.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez ce composant au nouvel objet de jeu dans la hi√©rarchie de l'interface utilisateur. </font><font style="vertical-align: inherit;">Il n'a pas besoin d'avoir son propre objet, mais il sera √©vident pour nous qu'il existe une interface utilisateur distincte pour le jeu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objet d'interface utilisateur de jeu</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez une </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme dans </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'interface utilisateur du jeu doit √™tre activ√©e lorsque nous ne sommes pas en mode √©dition. </font><font style="vertical-align: inherit;">De plus, les √©tiquettes doivent √™tre incluses ici car l'interface utilisateur du jeu fonctionne avec des chemins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez la m√©thode d'interface utilisateur du jeu avec la liste des √©v√©nements du commutateur de mode d'√©dition. </font><font style="vertical-align: inherit;">Cela signifie que lorsque le joueur change de mode, les deux m√©thodes sont appel√©es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plusieurs m√©thodes d'√©v√©nement. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivre la cellule actuelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selon la situation, </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous devez savoir quelle cellule se trouve actuellement sous le curseur. </font><font style="vertical-align: inherit;">Par cons√©quent, nous y ajoutons un champ </font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez une m√©thode </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui utilise le </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faisceau </font><font style="vertical-align: inherit;">du </font><font style="vertical-align: inherit;">curseur pour mettre √† jour ce champ.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la mise √† jour de la cellule actuelle, nous devrons peut-√™tre savoir si elle a chang√©. </font><font style="vertical-align: inherit;">Forcer √† </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoyer ces informations.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√©lection d'unit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de d√©placer une √©quipe, elle doit √™tre s√©lectionn√©e et suivie. </font><font style="vertical-align: inherit;">Par cons√©quent, ajoutez un champ </font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous essayons de faire une s√©lection, nous devons commencer par mettre √† jour la cellule actuelle. </font><font style="vertical-align: inherit;">Si la cellule actuelle est alors l'unit√© occupant cette cellule devient l'unit√© s√©lectionn√©e. </font><font style="vertical-align: inherit;">S'il n'y a pas d'unit√© dans la cellule, aucune unit√© n'est s√©lectionn√©e. </font><font style="vertical-align: inherit;">Cr√©ons une m√©thode pour cela </font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous r√©alisons le choix des unit√©s d'un simple clic de souris. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajoutons une m√©thode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui effectue une s√©lection lorsque le bouton de la souris est activ√©. Bien s√ªr, nous devons l'ex√©cuter uniquement lorsque le curseur n'est pas au-dessus de l'√©l√©ment GUI.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, nous avons appris √† s√©lectionner une unit√© √† la fois d'un simple clic de souris. </font><font style="vertical-align: inherit;">Lorsque vous cliquez sur une cellule vide, la s√©lection d'une unit√© est supprim√©e. </font><font style="vertical-align: inherit;">Mais nous n'en recevons aucune confirmation visuelle.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche d'escouade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une unit√© est s√©lectionn√©e, nous pouvons utiliser son emplacement comme point de d√©part pour trouver un chemin. </font><font style="vertical-align: inherit;">Pour l'activer, nous n'aurons pas besoin d'un autre clic du bouton de la souris. </font><font style="vertical-align: inherit;">Au lieu de cela, nous trouverons et afficherons automatiquement le chemin entre la position de l'escouade et la cellule actuelle. </font><font style="vertical-align: inherit;">Nous le ferons toujours en </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sauf lorsque le choix est fait. </font><font style="vertical-align: inherit;">Pour ce faire, lorsque nous avons un d√©tachement, nous appelons la m√©thode </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">met simplement √† jour la cellule actuelle et appelle </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'il y a un point de terminaison. </font><font style="vertical-align: inherit;">Nous utilisons √† nouveau une vitesse constante de 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veuillez noter que nous ne devons pas trouver de nouveau chemin √† chaque mise √† jour, mais uniquement lorsque la cellule actuelle change. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trouver un chemin pour une escouade</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous voyons maintenant les chemins qui apparaissent lorsque vous d√©placez le curseur apr√®s avoir s√©lectionn√© une escouade. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, il est √©vident quelle unit√© est s√©lectionn√©e. </font><font style="vertical-align: inherit;">Cependant, les chemins ne sont pas toujours effac√©s correctement. </font><font style="vertical-align: inherit;">Tout d'abord, effa√ßons l'ancien chemin si le curseur est en dehors de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, cela n√©cessite que ce </font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soit commun, donc nous faisons un tel changement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deuxi√®mement, nous effacerons l'ancienne voie lors du choix d'un d√©tachement. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfin, nous effacerons le chemin lors du changement de mode d'√©dition. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rechercher uniquement les points de terminaison valides </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous ne pouvons pas toujours trouver le chemin, car il est parfois impossible d'atteindre la cellule finale. </font></font> C'est normal.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais parfois, la cellule finale elle-m√™me est inacceptable. </font><font style="vertical-align: inherit;">Par exemple, nous avons d√©cid√© que les chemins ne pouvaient pas inclure de cellules sous-marines. </font><font style="vertical-align: inherit;">Mais cela peut d√©pendre de l'unit√©. </font><font style="vertical-align: inherit;">Ajoutons √† une </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode qui nous indique si une cellule est un point de terminaison valide. </font><font style="vertical-align: inherit;">Les cellules sous-marines ne le sont pas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous n'avons autoris√© qu'une seule unit√© √† rester dans la cellule. </font><font style="vertical-align: inherit;">Par cons√©quent, la cellule finale ne sera pas valide si elle est occup√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette m√©thode </font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ignorer les points de terminaison non valides.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©placer vers le point final </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons un chemin valide, nous pouvons d√©placer l'√©quipe au point final. </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sait quand cela peut √™tre fait. </font><font style="vertical-align: inherit;">Nous lui faisons passer ces informations dans une nouvelle propri√©t√© en lecture seule </font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©placer une escouade, ajoutez √† la </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette m√©thode sera appel√©e lorsqu'une commande est √©mise et si une unit√© est s√©lectionn√©e. </font><font style="vertical-align: inherit;">Par cons√©quent, il doit v√©rifier s'il existe un moyen et, dans l'affirmative, changer l'emplacement du d√©tachement. </font><font style="vertical-align: inherit;">Pendant que nous t√©l√©portons imm√©diatement l'√©quipe au point final. </font><font style="vertical-align: inherit;">Dans l'un des didacticiels suivants, nous allons faire en sorte que l'√©quipe continue jusqu'au bout.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisons le bouton 1 de la souris (clic droit) pour soumettre la commande. </font><font style="vertical-align: inherit;">Nous v√©rifierons cela si un d√©tachement est s√©lectionn√©. </font><font style="vertical-align: inherit;">Si le bouton n'est pas enfonc√©, alors nous recherchons le chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons d√©placer des unit√©s! </font><font style="vertical-align: inherit;">Mais parfois, ils refusent de trouver un moyen d'acc√©der √† certaines cellules. </font><font style="vertical-align: inherit;">En particulier, aux cellules dans lesquelles se trouvait le d√©tachement. </font><font style="vertical-align: inherit;">Cela se produit car il </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne met pas √† jour l'ancien emplacement lors de la d√©finition d'un nouveau. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, nous effacerons le lien vers l'√©quipe √† son ancien emplacement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âvitez les escouades </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trouver le chemin fonctionne d√©sormais correctement et les unit√©s peuvent se t√©l√©porter sur la carte. </font><font style="vertical-align: inherit;">Bien qu'ils ne puissent pas se d√©placer vers des cellules qui ont d√©j√† une escouade, les d√©tachements qui se dressent sur le chemin sont ignor√©s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les unit√©s en cours de route sont ignor√©es. Les</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unit√©s d'une m√™me faction peuvent g√©n√©ralement se d√©placer entre elles, mais jusqu'√† pr√©sent, nous n'avons pas de factions. </font><font style="vertical-align: inherit;">Par cons√©quent, consid√©rons toutes les unit√©s comme d√©connect√©es les unes des autres et bloquant les chemins. </font><font style="vertical-align: inherit;">Cela peut √™tre impl√©ment√© en ignorant les cellules occup√©es </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âvitez les </font><font style="vertical-align: inherit;">d√©tachements </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 19: Animation de mouvement </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous d√©pla√ßons les unit√©s entre les cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisez le chemin parcouru. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous d√©pla√ßons les troupes le long des courbes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous for√ßons les troupes √† regarder dans le sens du mouvement. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette partie, nous forcerons les unit√©s au lieu de la t√©l√©portation √† se d√©placer le long des pistes. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des escouades en route</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement le long du chemin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie pr√©c√©dente, nous avons ajout√© des unit√©s et la possibilit√© de les d√©placer. </font><font style="vertical-align: inherit;">Bien que nous ayons utilis√© la recherche du chemin pour d√©terminer les points de terminaison valides, apr√®s avoir donn√© l'ordre, les troupes se sont simplement t√©l√©port√©es vers la cellule finale. </font><font style="vertical-align: inherit;">Pour suivre r√©ellement le chemin trouv√©, nous devons suivre ce chemin et cr√©er un processus d'animation qui force l'√©quipe √† se d√©placer de cellule en cellule. </font><font style="vertical-align: inherit;">√âtant donn√© qu'en regardant les animations, il est difficile de remarquer comment l'√©quipe s'est d√©plac√©e, nous visualisons √©galement le chemin parcouru √† l'aide de gadgets. </font><font style="vertical-align: inherit;">Mais avant de continuer, nous devons corriger l'erreur.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erreur avec virages </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison d'un oubli, nous calculons incorrectement le cap auquel la cellule sera atteinte. </font><font style="vertical-align: inherit;">Maintenant, nous d√©terminons le parcours en divisant la distance totale par la vitesse de l'√©quipe</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-5"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et en √©liminant le reste. </font><font style="vertical-align: inherit;">L'erreur se produit lorsque pour entrer dans la cellule, vous devez d√©penser exactement tous les points de mouvement restants par mouvement. </font><font style="vertical-align: inherit;">Par exemple, lorsque chaque √©tape co√ªte 1 et que la vitesse est de 3, nous pouvons d√©placer trois cellules par tour. </font><font style="vertical-align: inherit;">Cependant, avec les calculs existants, nous ne pouvons prendre que deux √©tapes au premier coup, car pour la troisi√®me √©tape</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.407ex" height="2.66ex" viewBox="0 -832 3189.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-73" x="2719" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">t = d / s</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s </font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-21"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.254ex" height="2.66ex" viewBox="0 -832 7859.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-73" x="2719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="3466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-33" x="4523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2F" x="5023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-33" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="6302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-31" x="7358" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">t = d / s = 3 / 3 = 1</script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les co√ªts totaux du d√©placement avec des mouvements mal d√©finis, vitesse 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour le calcul correct des mouvements, nous devons d√©placer la bordure d'un pas depuis la cellule initiale. </font><font style="vertical-align: inherit;">Nous pouvons le faire en r√©duisant la distance de 1 avant de calculer le mouvement. Ensuite, le mouvement pour la troisi√®me √©tape sera</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux </font></font></span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trois </font></font></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.686ex" height="2.66ex" viewBox="0 -832 5031.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-32" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2F" x="2196" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-33" x="2696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="3474" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-30" x="4531" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvements corrects</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons le faire en changeant la formule de calcul en</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.219ex" height="2.66ex" viewBox="0 -832 5691.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-28" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-64" x="2085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2212" x="2830" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-31" x="3831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-29" x="4332" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2F" x="4721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-73" x="5222" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">t = (d - 1) / s</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons apporter cette modification √† </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous changeons √©galement les marques des mouvements. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; ‚Ä¶ } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez qu'avec cette approche, le chemin de cellule initial est -1. </font><font style="vertical-align: inherit;">Ceci est normal, car nous ne l'afficheons pas, et l'algorithme de recherche reste op√©rationnel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment arriver </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se d√©placer le long du chemin est la t√¢che de l'√©quipe. </font><font style="vertical-align: inherit;">Pour ce faire, il doit conna√Ætre le chemin. </font><font style="vertical-align: inherit;">Nous avons ces informations </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors ajoutons-y une m√©thode pour obtenir le chemin actuel sous la forme d'une liste de cellules. </font><font style="vertical-align: inherit;">Il peut le prendre dans le pool de listes et revenir s'il y a vraiment un chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La liste est remplie en suivant le chemin du lien de la cellule finale √† la cellule initiale, comme pour la visualisation du chemin. </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans ce cas, nous avons besoin du chemin complet, qui inclut la cellule initiale. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons le chemin dans l'ordre inverse. </font><font style="vertical-align: inherit;">On peut travailler avec lui, mais ce ne sera pas tr√®s intuitif. </font><font style="vertical-align: inherit;">Faisons basculer la liste pour qu'elle passe du d√©but √† la fin.</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demande de motion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons ajouter √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode, lui ordonnant de suivre le chemin. </font><font style="vertical-align: inherit;">Au d√©part, nous l'avons simplement laiss√© se t√©l√©porter vers la cellule finale. </font><font style="vertical-align: inherit;">Nous ne retournerons pas imm√©diatement la liste √† la piscine, car elle nous sera utile pendant un certain temps.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour demander un mouvement, nous le modifions </font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il appelle une nouvelle m√©thode avec le chemin courant, et pas seulement pour d√©finir l'emplacement de l'unit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisation du chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de commencer √† animer l'√©quipe, v√©rifions que les chemins sont corrects. </font><font style="vertical-align: inherit;">Nous le ferons en ordonnant de se </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">souvenir du chemin le long duquel il doit se d√©placer, afin qu'il puisse √™tre visualis√© √† l'aide de gadgets.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour afficher le dernier chemin √† parcourir (s'il existe). </font><font style="vertical-align: inherit;">Si l'unit√© n'a pas encore boug√©, le chemin doit √™tre √©gal </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais en raison de la s√©rialisation d'Unity lors de l'√©dition apr√®s recompilation en mode Lecture, il peut √©galement s'agir d'une liste vide.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple de montrer le chemin consiste √† dessiner une sph√®re de gizmo pour chaque cellule du chemin. </font><font style="vertical-align: inherit;">Une sph√®re d'un rayon de 2 unit√©s nous convient.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque nous montrerons les chemins du d√©tachement, nous pourrons voir simultan√©ment tous ses derniers chemins. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les gizmos affichent les derniers chemins parcourus.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afin de mieux montrer les connexions des cellules, nous dessinons plusieurs sph√®res en boucle sur une ligne entre les cellules pr√©c√©dentes et actuelles. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons d√©marrer le processus √† partir de la deuxi√®me cellule. </font><font style="vertical-align: inherit;">Les sph√®res peuvent √™tre arrang√©es en utilisant une interpolation lin√©aire avec un incr√©ment de 0,1 unit√©, de sorte que nous obtenons dix sph√®res par segment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des moyens plus √©vidents</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Glissez le long du chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez utiliser la m√™me m√©thode pour d√©placer des unit√©s. </font><font style="vertical-align: inherit;">Cr√©ons une coroutine pour cela. </font><font style="vertical-align: inherit;">Au lieu de dessiner un gizmo, nous allons d√©finir la position de l'√©quipe. </font><font style="vertical-align: inherit;">Au lieu d'incr√©menter, nous utiliserons un delta temporel de 0,1 et nous effectuerons le rendement pour chaque it√©ration. </font><font style="vertical-align: inherit;">Dans ce cas, l'escouade passera d'une cellule √† l'autre en une seconde.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons coroutine √† la fin de la m√©thode </font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais d'abord, nous arr√™terons toutes les coroutines existantes. </font><font style="vertical-align: inherit;">Nous garantissons donc que deux coroutines ne d√©marreront pas en m√™me temps, sinon cela conduirait √† des r√©sultats tr√®s √©tranges.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©placer une cellule par seconde est assez lent. </font><font style="vertical-align: inherit;">Le joueur pendant le jeu ne voudra pas attendre aussi longtemps. </font><font style="vertical-align: inherit;">Vous pouvez faire de la vitesse de d√©placement de l'escouade une option de configuration, mais pour l'instant, utilisons une constante. </font><font style="vertical-align: inherit;">Je lui ai attribu√© une valeur de 4 cellules par seconde; </font><font style="vertical-align: inherit;">c'est assez rapide, mais permet de remarquer ce qui se passe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout comme nous pouvons visualiser plusieurs chemins simultan√©ment, nous pouvons faire voyager plusieurs unit√©s en m√™me temps. </font><font style="vertical-align: inherit;">Du point de vue de l'√©tat du jeu, le mouvement est toujours de la t√©l√©portation, les animations sont exclusivement visuelles. </font><font style="vertical-align: inherit;">Les unit√©s occupent instantan√©ment la cellule finale. </font><font style="vertical-align: inherit;">Vous pouvez m√™me trouver des moyens et commencer un nouveau mouvement avant leur arriv√©e. </font><font style="vertical-align: inherit;">Dans ce cas, ils sont t√©l√©port√©s visuellement au d√©but d'un nouveau chemin. </font><font style="vertical-align: inherit;">Cela peut √™tre √©vit√© en bloquant des unit√©s ou m√™me toute l'interface utilisateur pendant leur d√©placement, mais une telle r√©action rapide est tr√®s pratique lors du d√©veloppement et du test de mouvements.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit√©s mobiles. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et la diff√©rence de hauteur?</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position apr√®s compilation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des inconv√©nients de la corutine est qu'elle ne ¬´survit¬ª pas lorsqu'elle est recompil√©e en mode Play. </font><font style="vertical-align: inherit;">Bien que l'√©tat du jeu soit toujours vrai, cela peut entra√Æner le blocage des escouades quelque part sur leur dernier chemin si la recompilation est lanc√©e alors qu'elles sont toujours en mouvement. </font><font style="vertical-align: inherit;">Pour att√©nuer les cons√©quences, assurons-nous qu'apr√®s la recompilation, les unit√©s sont toujours dans la bonne position. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en mettant √† jour leur position dans </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement fluide </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mouvement du centre vers le centre de la cellule semble trop m√©caniste et cr√©e de brusques changements de direction. </font><font style="vertical-align: inherit;">Pour de nombreux jeux, ce sera normal, mais inacceptable si vous avez besoin d'au moins un mouvement l√©g√®rement r√©aliste. </font><font style="vertical-align: inherit;">Modifions donc le mouvement pour lui donner un aspect un peu plus organique.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passer d'une c√¥te √† l'autre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'escouade commence son voyage depuis le centre de la cellule. </font><font style="vertical-align: inherit;">Il passe au milieu du bord de la cellule, puis entre dans la cellule suivante. </font><font style="vertical-align: inherit;">Au lieu de se d√©placer vers le centre, il peut se diriger tout droit vers le bord suivant qu'il doit traverser. </font><font style="vertical-align: inherit;">En fait, l'unit√© coupera le chemin lorsqu'elle devra changer de direction. </font><font style="vertical-align: inherit;">Cela est possible pour toutes les cellules, √† l'exception des extr√©mit√©s du chemin.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois fa√ßons de se d√©placer d'un bord √† l'autre Adaptons-</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l'affichage des chemins g√©n√©r√©s de cette fa√ßon. </font><font style="vertical-align: inherit;">Il doit interpoler entre les bords des cellules, ce qui peut √™tre trouv√© en faisant la moyenne des positions des cellules voisines. </font><font style="vertical-align: inherit;">Il nous suffit de calculer une ar√™te par it√©ration, en r√©utilisant la valeur de l'it√©ration pr√©c√©dente. </font><font style="vertical-align: inherit;">Ainsi, nous pouvons faire fonctionner la m√©thode pour la cellule initiale, mais au lieu du bord, nous prenons sa position.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour atteindre le centre de la cellule d'extr√©mit√©, nous devons utiliser la position de la cellule comme dernier point, pas le bord. </font><font style="vertical-align: inherit;">Vous pouvez ajouter la v√©rification de ce cas √† la boucle, mais c'est un code si simple qu'il sera plus √©vident de simplement dupliquer le code et de le modifier l√©g√®rement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trajectoires bas√©es sur les</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nervures Les trajectoires r√©sultantes ressemblent moins √† des zigzags et l'angle de braquage maximal est r√©duit de 120 ¬∞ √† 90 ¬∞. </font><font style="vertical-align: inherit;">Cela peut √™tre consid√©r√© comme une am√©lioration, nous appliquons donc les m√™mes modifications dans la coroutine </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour voir √† quoi cela ressemble dans l'animation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©placement avec une vitesse variable</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir coup√© les angles, la longueur des segments de trajectoire est devenue d√©pendante du changement de direction. </font><font style="vertical-align: inherit;">Mais nous d√©finissons la vitesse en cellules par seconde. </font><font style="vertical-align: inherit;">Par cons√©quent, la vitesse de d√©tachement change de fa√ßon al√©atoire.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Courbes suivantes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les changements instantan√©s de direction et de vitesse lors du franchissement des limites des cellules semblent laids. </font><font style="vertical-align: inherit;">Mieux vaut utiliser un changement progressif de direction. </font><font style="vertical-align: inherit;">Nous pouvons ajouter un soutien √† cela en for√ßant les troupes √† suivre des courbes plut√¥t que des lignes droites. </font><font style="vertical-align: inherit;">Vous pouvez utiliser des courbes de B√©zier pour cela. </font><font style="vertical-align: inherit;">En particulier, nous pouvons prendre des courbes de B√©zier quadratiques o√π le centre des cellules sera le point de contr√¥le central. </font><font style="vertical-align: inherit;">Dans ce cas, les tangentes des courbes adjacentes seront des images miroir les unes des autres, c'est-√†-dire que le chemin entier se transformera en une courbe lisse continue.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courbes d'un bord √† l'autre</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ez une classe auxiliaire </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec une m√©thode pour obtenir des points sur une courbe de B√©zier quadratique. </font><font style="vertical-align: inherit;">Comme expliqu√© dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">didacticiel Courbes et splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la formule est utilis√©e pour</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-49" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A </font></font></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.208ex" height="2.901ex" viewBox="0 -935.7 12575.6 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2212" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="2112" y="0"></use><g transform="translate(2474,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-32" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-41" x="3317" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2B" x="4290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-32" x="5291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-28" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-31" x="6181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2212" x="6904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="7904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-29" x="8266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="8655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-42" x="9017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-2B" x="9998" y="0"></use><g transform="translate(10999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMAIN-32" x="511" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-43" x="11815" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script>  o√π <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.057ex" viewBox="0 -780.1 750.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-41" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> A </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhgDFanBG4nWq-Vyj8nvw5TK8IazcA#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> B </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont les points de contr√¥le et t est l'interpolateur.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8">C</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetPoint ne devrait-il pas √™tre limit√© √† 0-1?</font></font></b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher le chemin de la courbe </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous devons suivre non pas deux, mais trois points. </font><font style="vertical-align: inherit;">Un point suppl√©mentaire est le centre de la cellule avec laquelle nous travaillons √† l'it√©ration actuelle, qui a un index </font></font><code>i - 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car le cycle commence par 1. Apr√®s avoir re√ßu tous les points, nous pouvons le remplacer </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>Bezier.GetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les cellules de d√©but et de fin, au lieu des points de fin et de milieu, nous pouvons simplement utiliser le centre de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chemins cr√©√©s √† l'aide de courbes de B√©zier Un</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chemin </font><i><font style="vertical-align: inherit;">courbe</font></i><font style="vertical-align: inherit;"> est beaucoup plus esth√©tique. </font><font style="vertical-align: inherit;">Nous appliquons les m√™mes changements </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et voyons comment les unit√©s sont anim√©es avec cette approche.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous nous d√©pla√ßons le long des courbes. L'</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> animation est √©galement devenue fluide, m√™me lorsque la vitesse du d√©tachement est instable. </font><font style="vertical-align: inherit;">Comme les tangentes de la courbe des segments adjacents co√Øncident, la vitesse est continue. </font><font style="vertical-align: inherit;">Le changement de vitesse se produit progressivement et se produit lorsqu'un d√©tachement traverse la cellule, ralentissant lors d'un changement de direction. </font><font style="vertical-align: inherit;">S'il va tout droit, alors la vitesse reste constante. </font><font style="vertical-align: inherit;">De plus, l'√©quipe commence et termine son voyage √† vitesse nulle. </font><font style="vertical-align: inherit;">Cela imite le mouvement naturel, alors laissez-le comme √ßa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi du temps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† ce point, nous avons commenc√© √† it√©rer sur chacun des segments √† partir de 0, en continuant jusqu'√† ce que nous atteignions 1. Cela fonctionne bien lorsque nous augmentons d'une valeur constante, mais notre it√©ration d√©pend du delta temporel. Lorsque l'it√©ration sur un segment est termin√©e, nous sommes susceptibles de d√©passer 1 d'un certain montant, selon le delta de temps. Ceci est invisible √† des fr√©quences d'images √©lev√©es, mais peut entra√Æner des √†-coups √† des fr√©quences d'images faibles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©viter la perte de temps, nous devons transf√©rer le temps restant d'un segment au suivant. Cela peut √™tre fait en suivant </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout le chemin, et pas seulement dans chaque segment. Ensuite, √† la fin de chaque segment, nous en soustrayons 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous le faisons d√©j√†, assurons-nous que le delta temporel est pris en compte au d√©but du chemin. </font><font style="vertical-align: inherit;">Cela signifie que nous commencerons √† bouger imm√©diatement et ne resterons pas inactifs pendant une image.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous ne terminons pas exactement au moment o√π le chemin doit se terminer, mais quelques instants avant. </font><font style="vertical-align: inherit;">Ici, la diff√©rence peut √©galement d√©pendre de la fr√©quence d'images. </font><font style="vertical-align: inherit;">Par cons√©quent, faisons en sorte que l'√©quipe termine le chemin exactement au point final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animation d'orientation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les unit√©s ont commenc√© √† se d√©placer le long d'une courbe lisse, mais elles n'ont pas chang√© d'orientation en fonction de la direction du mouvement. </font><font style="vertical-align: inherit;">En cons√©quence, ils semblent glisser. </font><font style="vertical-align: inherit;">Pour que le mouvement ressemble √† un vrai mouvement, nous devons les faire pivoter.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour l'avenir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">didacticiel Courbes et splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous pouvons utiliser la d√©riv√©e de la courbe pour d√©terminer l'orientation de l'unit√©. </font><font style="vertical-align: inherit;">La formule pour la d√©riv√©e d'une courbe de B√©zier quadratique:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mn" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-75"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font></span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-91" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">2 ((1 - t) (B - A) + t (C - B))</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √† la </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode pour le calculer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le vecteur d√©riv√© est situ√© sur une ligne droite avec la direction du mouvement. </font><font style="vertical-align: inherit;">Nous pouvons utiliser la m√©thode </font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour la convertir en tour d'√©quipe. </font><font style="vertical-align: inherit;">Nous le r√©aliserons √† chaque √©tape </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'y a-t-il pas d'erreur au d√©but du chemin?</font></font></b> <div class="spoiler_text">    ,        .    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">A</span></span></span><script type="math/tex" id="MathJax-Element-10"> A </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">B</span></span></span><script type="math/tex" id="MathJax-Element-11"> B </script>  ,    .   ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">t</span><span class="MJXp-mo" id="MJXp-Span-98" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-99">0</span></span></span><script type="math/tex" id="MathJax-Element-12">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">t</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-103">0</span></span></span><script type="math/tex" id="MathJax-Element-13">t = 0</script>   .     .       ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">t</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-107">0</span></span></span><script type="math/tex" id="MathJax-Element-14">t > 0</script>    . <br>         ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-111">1</span></span></span><script type="math/tex" id="MathJax-Element-15">t < 1</script>  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contrairement √† la position du d√©tachement, la non-id√©alit√© de son orientation en fin de parcours n'est pas importante. </font><font style="vertical-align: inherit;">cependant, nous devons nous assurer que son orientation correspond √† la rotation finale. </font><font style="vertical-align: inherit;">Pour ce faire, apr√®s ach√®vement, nous assimilons son orientation √† sa rotation en Y.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les unit√©s regardent exactement dans la direction du mouvement, √† la fois horizontalement et verticalement. </font><font style="vertical-align: inherit;">Cela signifie qu'ils se pencheront en avant et en arri√®re, descendant des pentes et les escaladant. </font><font style="vertical-align: inherit;">Pour s'assurer qu'ils sont toujours droits, nous for√ßons la composante Y du vecteur de direction √† z√©ro avant de l'utiliser pour d√©terminer la rotation de l'unit√©.</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); ‚Ä¶ Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarder vers l'avant tout en se d√©pla√ßant</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous regardons le point </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout au long du chemin, les unit√©s regardent vers l'avant, mais avant de commencer √† se d√©placer, elles peuvent regarder dans l'autre direction. Dans ce cas, ils changent instantan√©ment leur orientation. Ce sera mieux s'ils tournent en direction du chemin avant le d√©but du mouvement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarder dans la bonne direction peut √™tre utile dans d'autres situations, alors cr√©ons une m√©thode </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui force l'√©quipe √† changer d'orientation afin de regarder un certain point. La rotation requise peut √™tre d√©finie √† l'aide de la m√©thode </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tout d'abord en pla√ßant le point dans la m√™me position verticale que le d√©tachement. Apr√®s cela, nous pouvons r√©cup√©rer l'orientation de l'√©quipe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que le d√©tachement tourne r√©ellement, nous transformerons la m√©thode en une autre corutine qui la fera tourner √† vitesse constante. La vitesse de rotation peut √©galement √™tre ajust√©e, mais nous utiliserons √† nouveau la constante. La rotation doit √™tre rapide, environ 180 ¬∞ par seconde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'est pas n√©cessaire de bricoler avec une acc√©l√©ration de virage car elle est imperceptible. Il nous suffira d'interpoler simplement entre les deux orientations. Malheureusement, ce n'est pas aussi simple que dans le cas de deux nombres, car les angles sont circulaires. Par exemple, une transition de 350 ¬∞ √† 10 ¬∞ devrait entra√Æner une rotation de 20 ¬∞ dans le sens horaire, mais une simple interpolation forcera une rotation de 340 ¬∞ dans le sens antihoraire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fa√ßon la plus simple de cr√©er une rotation correcte consiste √† interpoler entre deux quaternions √† l'aide d'une interpolation sph√©rique. Cela conduira au virage le plus court. Pour ce faire, nous obtenons les quaternions du d√©but et de la fin, puis effectuons une transition entre eux en utilisant </font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela fonctionnera, mais l'interpolation passe toujours de 0 √† 1, quel que soit l'angle de rotation. </font><font style="vertical-align: inherit;">Pour assurer une vitesse angulaire uniforme, nous devons ralentir l'interpolation √† mesure que l'angle de rotation augmente.</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connaissant l'angle, nous pouvons sauter compl√®tement le virage s'il s'av√®re √™tre nul. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ‚Ä¶ ) { ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant ajouter la rotation de l'unit√© en </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectuant simplement le rendement avant de d√©placer la </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position de la deuxi√®me cellule. </font><font style="vertical-align: inherit;">Unity lancera automatiquement coroutine </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendra sa fin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous v√©rifiez le code, l'escouade se t√©l√©porte dans la derni√®re cellule, y retourne, puis se t√©l√©porte au d√©but du chemin et commence √† se d√©placer √† partir de l√†. </font><font style="vertical-align: inherit;">Cela se produit car nous attribuons une valeur √† une propri√©t√© </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant le d√©but de la coroutine </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour se d√©barrasser de la t√©l√©portation, on peut au d√©part </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ramener la position du d√©tachement √† la cellule initiale.</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tournez avant de bouger</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balayer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ayant re√ßu le mouvement dont nous avons besoin, nous pouvons nous d√©barrasser de la m√©thode </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Supprimez-le ou commentez-le au cas o√π nous aurions besoin de voir des chemins √† l'avenir.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // ‚Ä¶ // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous n'avons plus besoin de nous rappeler dans quelle direction nous nous d√©placions, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez </font><font style="vertical-align: inherit;">finalement </font><font style="vertical-align: inherit;">lib√©rer la liste des cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il des vraies animations d'√©quipe?</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426481/">https://habr.com/ru/post/fr426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426471/index.html">Comment les donn√©es des logiciels espions fuient</a></li>
<li><a href="../fr426473/index.html">Architecture Redux. Oui ou non?</a></li>
<li><a href="../fr426475/index.html">Miya - assistant depuis le smartphone</a></li>
<li><a href="../fr426477/index.html">Toute la v√©rit√© sur RTOS. Article # 15. Partitions de m√©moire: services et structures de donn√©es</a></li>
<li><a href="../fr426479/index.html">Banc de test maison pour cartes m√®res</a></li>
<li><a href="../fr426483/index.html">Celui qui d√©passe Tesla. Pour plus rentable</a></li>
<li><a href="../fr426485/index.html">Troisi√®me test Qt 5 avec PVS-Studio</a></li>
<li><a href="../fr426487/index.html">Testez l'automatisation √† partir de z√©ro. Partie 1</a></li>
<li><a href="../fr426489/index.html">Sur la relation des nombres premiers et irrationnels</a></li>
<li><a href="../fr426491/index.html">Semaine de la s√©curit√© 39: √† la mort de Google+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>