<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍💼 🎰 🗽 Bagaimana penyimpanan S3 DataLine bekerja 💇🏻 🍹 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Bukan rahasia lagi bahwa sejumlah besar data terlibat dalam pekerjaan aplikasi modern, dan alirannya terus bertambah. Data ini perlu di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana penyimpanan S3 DataLine bekerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataline/blog/423853/"><img src="https://habrastorage.org/webt/r2/ri/yr/r2riyrsimmtddysut6vvaatcqtw.png"><br><br>  Halo, Habr! <br><br>  Bukan rahasia lagi bahwa sejumlah besar data terlibat dalam pekerjaan aplikasi modern, dan alirannya terus bertambah.  Data ini perlu disimpan dan diproses, seringkali dari sejumlah besar mesin, dan ini bukan tugas yang mudah.  Untuk mengatasinya, ada toko objek cloud.  Biasanya mereka adalah implementasi dari teknologi Storage Ditentukan Perangkat Lunak. <br><br>  Pada awal 2018, kami meluncurkan (dan meluncurkan!) Penyimpanan kami yang kompatibel dengan S3 100% berdasarkan Cloudian HyperStore.  Ternyata, jaringan memiliki sangat sedikit publikasi berbahasa Rusia tentang Cloudian itu sendiri, dan lebih sedikit lagi tentang aplikasi aktual dari solusi ini. <br><br>  Hari ini, berdasarkan pengalaman DataLine, saya akan memberi tahu Anda tentang arsitektur dan struktur internal perangkat lunak Cloud, termasuk implementasi Cloudian SDS berdasarkan sejumlah solusi arsitektur Apache Cassandra.  Secara terpisah, kami menganggap yang paling menarik dalam penyimpanan SDS - logika memastikan toleransi kesalahan dan distribusi objek. <br><br>  Jika Anda sedang membangun penyimpanan S3 Anda atau sibuk mempertahankannya, artikel ini akan berguna bagi Anda. <br><a name="habracut"></a><br>  Pertama-tama, saya akan menjelaskan mengapa pilihan kita jatuh pada Cloudian.  Ini sederhana: ada beberapa opsi yang layak di ceruk ini.  Sebagai contoh, beberapa tahun yang lalu, ketika kami hanya berpikir untuk membangun, hanya ada tiga pilihan: <br><br><ul><li>  CEHP + RADOS Gateway; <br></li><li>  Minio <br></li><li>  Cloudian HyperStore. <br></li></ul><br>  Bagi kami, sebagai penyedia layanan, faktor yang menentukan adalah: tingkat korespondensi yang tinggi antara API penyimpanan dan Amazon S3 asli, ketersediaan penagihan bawaan, skalabilitas dengan dukungan multiregionalitas, dan keberadaan lini ketiga dukungan vendor.  Cloudian memiliki semua ini. <br><br>  Dan ya, yang paling (pasti!) Yang paling penting adalah bahwa DataLine dan Cloudian memiliki warna korporat yang sama.  Anda harus mengakui bahwa kami tidak dapat menahan keindahan itu. <br><br><img src="https://habrastorage.org/webt/cj/mh/_u/cjmh_uot3g8v4spn8vgm4fvvngo.png"><br><br>  Sayangnya, Cloudian bukan perangkat lunak yang paling umum, dan praktis tidak ada informasi tentang itu di RuNet.  Hari ini kami akan memperbaiki ketidakadilan ini dan berbicara dengan Anda tentang fitur-fitur arsitektur HyperStore, memeriksa komponen-komponennya yang paling penting dan berurusan dengan nuansa arsitektur utama.  Mari kita mulai dengan yang paling mendasar, yaitu - apa itu Cloudian di bawah tenda? <br><br><h1>  Bagaimana Cloudian HyperStore Storage Bekerja </h1><br>  Mari kita lihat diagram dan melihat bagaimana solusi Cloudian bekerja. <br><br><img src="https://habrastorage.org/webt/8m/_n/0x/8m_n0xtx0vtlx50himh-wxrkjfm.jpeg"><br>  <i>Skema penyimpanan komponen utama.</i> <br><br>  Seperti yang dapat kita lihat, sistem terdiri dari beberapa komponen utama: <br><br><ul><li>  <b>Kontrol Manajemen Cloudian</b> - <i>konsol manajemen</i> ; </li><li>  <b>Layanan Admin</b> - <i>modul administrasi internal</i> ; </li><li>  <b>Layanan S3</b> - <i>modul yang bertanggung jawab untuk mendukung protokol S3</i> ; </li><li>  <b>Layanan HyperStore</b> - <i>layanan penyimpanan aktual</i> ; </li><li>  <b>Apache Cassandra</b> - <i>repositori terpusat dari data layanan</i> ; </li><li>  <b>Redis</b> - <i>untuk data yang paling sering dibaca</i> . </li></ul><br>  Yang paling menarik bagi kami adalah karya layanan utama, Layanan S3 dan Layanan HyperStore, maka kami akan mempertimbangkan pekerjaan mereka dengan cermat.  Tetapi pertama-tama, masuk akal untuk mengetahui bagaimana distribusi layanan dalam cluster diatur dan apa toleransi kesalahan dan keandalan penyimpanan data dari solusi ini secara keseluruhan. <br><br><img src="https://habrastorage.org/webt/hr/vq/su/hrvqsuhmqgexmgetlc72lsfwhqu.jpeg"><br><br><br>  Yang dimaksud dengan <i>layanan umum</i> pada diagram di atas adalah <b>layanan S3, HyperStore, CMC dan Apache Cassandra</b> .  Sepintas, semuanya indah dan rapi.  Tetapi setelah pemeriksaan lebih dekat, ternyata hanya satu kegagalan simpul yang secara efektif berhasil.  Dan kehilangan simultan dua node sekaligus bisa berakibat fatal bagi ketersediaan cluster - Redis QoS (pada node 2) hanya memiliki 1 slave (pada node 3).  Gambar yang sama dengan risiko kehilangan manajemen cluster - Server Wayang hanya pada dua node (1 dan 2).  Namun, probabilitas kegagalan dua node sekaligus sangat rendah, dan Anda dapat hidup dengannya. <br><br>  Namun demikian, untuk meningkatkan keandalan penyimpanan, kami menggunakan 4 node di DataLine alih-alih minimal tiga.  Distribusi sumber daya berikut diperoleh: <br><br><img src="https://habrastorage.org/webt/x0/ue/f2/x0uef2dubkivpngycrxidcjvx1u.png"><br><br>  Satu lagi nuansa segera menarik perhatian Anda - <b>Redis Kredensial</b> tidak ditempatkan pada setiap node (seperti yang dapat diasumsikan dari skema resmi di atas), tetapi hanya pada 3 dari mereka.  Dalam hal ini, <b>Redis Credentials</b> digunakan untuk setiap permintaan yang masuk.  Ternyata karena kebutuhan untuk pergi ke Redis orang lain, ada beberapa ketidakseimbangan dalam kinerja simpul keempat. <br><br>  Bagi kami, ini belum signifikan.  Selama pengujian stres, penyimpangan yang signifikan dalam kecepatan respon dari node tidak diperhatikan, tetapi pada kelompok besar dari puluhan node yang bekerja, masuk akal untuk memperbaiki nuansa ini. <br><br>  Beginilah skema migrasi pada 6 node terlihat seperti: <br><br><img src="https://habrastorage.org/webt/yc/df/1l/ycdf1lkqic3oh2rb6iu-yhyoiyo.jpeg"><br><br>  <i>Diagram menunjukkan bagaimana migrasi layanan diimplementasikan jika terjadi kegagalan simpul.</i>  <i>Hanya kegagalan satu server dari setiap peran yang diperhitungkan.</i>  <i>Jika kedua server jatuh, intervensi manual akan diperlukan.</i> <br><br>  Di sini juga, bisnis itu bukannya tanpa kehalusan.  Migrasi peran menggunakan Wayang.  Oleh karena itu, jika Anda kehilangan atau memecahkannya secara tidak sengaja, kegagalan otomatis mungkin tidak berfungsi.  Untuk alasan yang sama, Anda tidak boleh mengedit manifes wayang bawaan secara manual.  Ini tidak sepenuhnya aman, perubahan dapat tiba-tiba usang, karena manifes diedit menggunakan panel admin cluster. <br><br>  Dari sudut pandang keamanan data, semuanya jauh lebih menarik.  Metadata objek disimpan di Apache Cassandra, dan setiap catatan direplikasi menjadi 3 dari 4 node.  Faktor replikasi 3 juga digunakan untuk menyimpan data, tetapi Anda dapat mengkonfigurasi yang lebih besar.  Ini memastikan keamanan data bahkan dalam kasus kegagalan simultan 2 dari 4 node.  Dan jika Anda punya waktu untuk menyeimbangkan kembali cluster, Anda tidak akan kehilangan apa pun dengan satu simpul yang tersisa.  Hal utama adalah memiliki ruang yang cukup. <br><br><img src="https://habrastorage.org/webt/do/oo/ip/doooipch3gctjx0ruteyepc3n2w.jpeg"><br><br>  <i>Inilah yang terjadi ketika dua node gagal.</i>  <i>Diagram dengan jelas menunjukkan bahwa bahkan dalam situasi ini, data tetap aman</i> <br><br>  Pada saat yang sama, ketersediaan data dan penyimpanan akan tergantung pada strategi untuk memastikan konsistensi.  Untuk data, metadata, baca dan tulis, ini dikonfigurasi secara terpisah. <br><br>  Opsi yang valid setidaknya satu node, kuorum, atau semua node. <br>  Pengaturan ini menentukan berapa banyak node yang harus mengkonfirmasi penulisan / baca agar permintaan dianggap berhasil.  Kami menggunakan kuorum sebagai kompromi yang masuk akal antara waktu yang dibutuhkan untuk memproses permintaan dan keandalan penulisan / inkonsistensi membaca.  Yaitu, dari tiga node yang terlibat dalam operasi, untuk operasi bebas kesalahan, cukup untuk mendapatkan jawaban yang konsisten dari 2.  Dengan demikian, untuk tetap bertahan jika terjadi kegagalan lebih dari satu node, Anda harus beralih ke strategi tulis / baca tunggal. <br><br><h2>  Pemrosesan permintaan dalam Cloudian </h2><br>  Di bawah ini kami akan mempertimbangkan dua skema untuk memproses permintaan masuk di Cloudian HyperStore, PUT dan GET.  Ini adalah tugas utama untuk Layanan S3 dan HyperStore. <br><br>  Mari kita mulai dengan bagaimana permintaan penulisan diproses: <br><br><img src="https://habrastorage.org/webt/ig/ae/g7/igaeg7v86nw9e1rgxt6xbdlhxb8.jpeg"><br><br>  Tentunya Anda mencatat bahwa setiap permintaan menghasilkan banyak pemeriksaan dan pengambilan data, setidaknya 6 hit dari komponen ke komponen.  Dari sinilah penundaan perekaman dan konsumsi waktu CPU tinggi muncul ketika bekerja dengan file kecil. <br><br>  File besar ditransmisikan oleh potongan.  Potongan terpisah tidak dianggap sebagai permintaan terpisah dan beberapa pemeriksaan tidak dilakukan. <br><br>  Node yang menerima permintaan awal lebih jauh menentukan secara mandiri di mana dan apa yang harus ditulis, bahkan jika tidak ditulis langsung ke sana.  Ini memungkinkan Anda untuk menyembunyikan organisasi internal cluster dari klien akhir dan menggunakan penyeimbang beban eksternal.  Semua ini berpengaruh positif terhadap kemudahan perawatan dan toleransi kesalahan penyimpanan. <br><br><img src="https://habrastorage.org/webt/ss/tr/zj/sstrzjuve-nm6oyz2mj0yitmnts.jpeg"><br><br>  Seperti yang Anda lihat, logika membaca tidak terlalu berbeda dari menulis.  Di dalamnya, sensitivitas kinerja tinggi yang sama terhadap ukuran objek yang diproses diamati.  Oleh karena itu, karena penghematan yang signifikan dalam bekerja dengan metadata, jauh lebih mudah untuk mengekstrak satu objek yang dicincang halus daripada banyak objek terpisah dari volume total yang sama. <br><br><h2>  Penyimpanan dan duplikasi data </h2><br>  Seperti yang dapat Anda lihat dari diagram di atas, Cloudian mendukung berbagai skema penyimpanan dan duplikasi data: <br><br>  <b>Replikasi</b> - menggunakan replikasi, dimungkinkan untuk mempertahankan jumlah salinan kustom dari setiap objek data dalam sistem dan menyimpan setiap salinan pada node yang berbeda.  Misalnya, menggunakan replikasi 3X, 3 salinan dari setiap objek dibuat, dan setiap salinan "terletak" pada node sendiri. <br><br>  <b>Erasure Coding</b> - Dengan pengkodean erasure, setiap objek dikodekan ke dalam jumlah khusus (dikenal sebagai nomor K) dari fragmen data ditambah jumlah kustom kode redundansi (nomor M).  Setiap fragmen K + M dari suatu objek adalah unik, dan setiap fragmen disimpan pada simpulnya sendiri.  Objek dapat didekodekan menggunakan fragmen K apa pun.  Dengan kata lain, objek tetap dapat dibaca, bahkan jika node M tidak dapat diakses. <br><br>  Misalnya, dalam pengkodean penghapusan, sesuai dengan rumus 4 + 2 (4 fragmen data ditambah 2 fragmen kode redundansi), setiap objek dibagi menjadi 6 fragmen unik yang disimpan pada enam node berbeda, dan objek ini dapat dipulihkan dan dibaca jika ada 4 dari 6 fragmen yang tersedia . <br><br>  Keuntungan dari Erasure Coding dibandingkan dengan replikasi adalah untuk menghemat ruang, meskipun dengan biaya peningkatan beban prosesor yang signifikan, memburuknya kecepatan respons dan perlunya prosedur latar belakang untuk mengontrol konsistensi objek.  Bagaimanapun, metadata disimpan secara terpisah dari data (dalam Apache Cassandra), yang meningkatkan fleksibilitas dan keandalan solusi. <br><br><h2>  Secara singkat tentang fungsi lain dari HyperStore </h2><br>  Seperti yang saya tulis di awal artikel ini, beberapa alat yang berguna dibangun ke HyperStore.  Diantaranya adalah: <br><br><ul><li>  Tagihan fleksibel dengan dukungan untuk mengubah harga sumber daya tergantung pada volume dan rencana tarif; <br></li><li>  Pemantauan internal <br></li><li>  Kemampuan untuk membatasi penggunaan sumber daya untuk pengguna dan grup pengguna; <br></li><li>  Pengaturan QoS dan prosedur bawaan untuk menyeimbangkan penggunaan sumber daya antara node, serta prosedur reguler untuk menyeimbangkan kembali antara node dan disk pada node atau ketika memasukkan node baru dalam sebuah cluster. <br></li></ul><br>  Namun, Cloudian HyperStore masih belum sempurna.  Misalnya, karena alasan tertentu, Anda tidak dapat mentransfer akun yang ada ke grup lain atau menetapkan beberapa grup ke satu catatan.  Laporan tagihan sementara tidak mungkin - Anda akan menerima semua laporan hanya setelah menutup periode pelaporan.  Oleh karena itu, baik klien maupun kami tidak dapat mengetahui berapa banyak akun telah tumbuh secara real time. <br><br><h1>  Cloudian HyperStore Logic </h1><br>  Sekarang kita akan menyelam lebih dalam dan melihat yang paling menarik dalam penyimpanan SDS - logika distribusi objek dengan node.  Dalam kasus penyimpanan Cloudian, metadata disimpan secara terpisah dari data itu sendiri.  Untuk metadata, Cassandra digunakan, untuk data, solusi HyperStore. <br><br>  Sayangnya, sejauh ini tidak ada terjemahan resmi dari dokumentasi Cloudian ke dalam bahasa Rusia di Internet, jadi di bawah ini saya akan memposting terjemahan saya dari bagian yang paling menarik dari dokumentasi ini. <br><br><h2>  Peran Apache Cassandra dalam HyperStore </h2><br>  Dalam HyperStore, Cassandra digunakan untuk menyimpan metadata objek, informasi akun pengguna, dan data penggunaan layanan.  Dalam penyebaran khas pada setiap HyperStore, data Cassandra disimpan pada drive yang sama dengan OS.  Sistem ini juga mendukung data Cassandra pada drive khusus pada setiap node.  Data Cassandra tidak disimpan di disk data HyperStore.  Ketika vNodes ditugaskan ke host, mereka didistribusikan hanya ke node penyimpanan HyperStore.  vNodes tidak dialokasikan ke drive tempat data Cassandra disimpan. <br>  Di dalam cluster, metadata di Cassandra direplikasi sesuai dengan kebijakan (strategi) repositori Anda.  Replikasi Data Cassandra menggunakan vNodes dengan cara ini: <br><br><ul><li>  Saat membuat objek Cassandra baru (kunci utama dan nilai-nilai yang terkait), itu hash, dan hash digunakan untuk mengaitkan objek dengan vNode tertentu.  Sistem memeriksa host yang vNode ini ditugaskan, dan kemudian replika pertama objek Cassandra disimpan pada drive Cassandra pada host itu. <br></li><li>  Sebagai contoh, misalkan sebuah host ditugaskan 96 vNodes didistribusikan di beberapa disk data HyperStore.  Objek-objek Cassandra yang nilai hash-nya berada dalam rentang token dari 96 vNodes ini akan ditulis ke drive Cassandra pada host ini. <br></li><li>  Replika tambahan dari objek Cassandra (jumlah replika tergantung pada konfigurasi Anda) dikaitkan dengan vNodes dengan nomor urut berikut dan disimpan pada node tempat vNodes ini ditetapkan, asalkan vNodes dilewati jika perlu, sehingga setiap replika objek Cassandra disimpan pada yang lain mesin host. <br></li></ul><br><h2>  Cara Penyimpanan HyperStore Bekerja </h2><br>  Penempatan dan replikasi objek S3 dalam cluster HyperStore didasarkan pada skema caching yang konsisten yang menggunakan ruang token integer dalam rentang dari 0 hingga 2 <sup>127</sup> -1.  Token integer ditetapkan ke node HyperStore.  Untuk setiap objek S3, hash dihitung saat dimuat ke penyimpanan.  Objek disimpan dalam node yang diberi nilai token terendah, lebih besar dari atau sama dengan nilai hash objek.  Replikasi juga diimplementasikan dengan menyimpan objek pada node yang telah diberi token, yang memiliki nilai minimum. <br><br>  Dalam penyimpanan berbasis hash konsisten "klasik", satu token ditugaskan ke satu simpul fisik.  Sistem Cloudian HyperStore menggunakan dan memperluas fungsionalitas "simpul virtual" (vNode) yang diperkenalkan di Cassandra dalam versi 1.2 - sejumlah besar token ditugaskan untuk masing-masing host fisik (maksimum 256).  Bahkan, cluster penyimpanan terdiri dari sejumlah besar "virtual node" dengan sejumlah besar virtual node (token) pada setiap host fisik. <br><br>  Sistem HyperStore menetapkan satu set token yang terpisah (virtual node) untuk setiap disk pada setiap host fisik.  Setiap disk pada host bertanggung jawab atas set replika objeknya sendiri.  Kegagalan disk hanya memengaruhi replika objek yang ada di dalamnya.  Drive lain pada host akan terus beroperasi dan melaksanakan tanggung jawab penyimpanan data mereka. <br><br>  Kami memberikan contoh dan mempertimbangkan sekelompok 6 host HyperStore, yang masing-masing memiliki 4 disk penyimpanan S3.  Asumsikan 32 token ditugaskan untuk setiap host fisik dan ada ruang token yang disederhanakan dari 0 hingga 960, dan nilai 192 token dalam sistem ini (6 host dari 32 token) adalah 0, 5, 10, 15, 20, dan seterusnya hingga 955. <br><br>  Diagram di bawah ini menunjukkan satu kemungkinan distribusi token di seluruh cluster.  32 token dari setiap host didistribusikan secara merata di 4 disk (8 token per disk), dan token itu sendiri didistribusikan secara acak di seluruh cluster. <br><br><img src="https://habrastorage.org/webt/wa/w2/9c/waw29ckv34avc3fdmqvfq4-a40a.jpeg"><br><br>  Sekarang anggaplah Anda mengkonfigurasi HyperStore ke 3X mereplikasi objek S3.  Mari kita sepakat bahwa objek S3 dimuat ke dalam sistem, dan algoritma hash yang diterapkan pada namanya memberi kita nilai hash 322 (dalam ruang hash yang disederhanakan ini).  Diagram di bawah ini menunjukkan bagaimana tiga instance atau replika objek akan disimpan dalam sebuah cluster: <br><br><ul><li>  Dengan nilai hash nama 322, replika pertama objek disimpan di 325 token, karena  ini adalah nilai token terkecil yang lebih besar dari atau sama dengan nilai hash objek.  325 token (disorot dengan warna merah pada diagram) ditugaskan untuk hyperstore2: Disk2.  Dengan demikian, replika pertama objek disimpan di sana. <br></li></ul><br><ul><li>  Replika kedua disimpan di disk yang ditugaskan token berikutnya (330, disorot dalam oranye), yaitu, di hyperstore4: Disk2. <br></li><li>  Replika ketiga disimpan ke disk, yang diberikan token berikutnya setelah 330 - 335 (kuning), di hyperstore3: Disk3. <br></li></ul><br><img src="https://habrastorage.org/webt/xy/0w/k-/xy0wk-hrqt3lgppbyeohdpllsnq.jpeg"><br><blockquote>  <b>Saya akan menambahkan komentar:</b> dari sudut pandang praktis, optimisasi ini (distribusi token tidak hanya di antara node fisik, tetapi juga antar disk individu) diperlukan tidak hanya untuk memastikan aksesibilitas, tetapi juga untuk memastikan distribusi data yang seragam antara disk.  Dalam hal ini, array RAID tidak digunakan, seluruh logika alokasi data pada disk dikendalikan oleh HyperStore itu sendiri.  Di satu sisi, itu nyaman dan terkendali, jika disk hilang, semuanya akan diseimbangkan sendiri.  Di sisi lain, saya pribadi mempercayai pengontrol RAID yang lebih baik - lagipula, logikanya telah dioptimalkan selama bertahun-tahun.  Tapi ini semua preferensi pribadi saya, pada tiang dan masalah nyata, kami tidak pernah menangkap HyperStore, jika kami mengikuti rekomendasi vendor ketika menginstal perangkat lunak pada server fisik.  Tetapi upaya untuk menggunakan virtualisasi dan disk virtual di atas bulan yang sama pada sistem penyimpanan gagal, ketika membebani sistem penyimpanan selama pengujian beban, HyperStore menjadi gila dan menyebarkan data sepenuhnya tidak merata, menyumbat beberapa disk dan tidak menyentuh yang lain. </blockquote><h2>  Drive perangkat di dalam sebuah cluster </h2><br>  Ingatlah bahwa setiap host memiliki 32 token, dan token dari masing-masing host didistribusikan secara merata di antara disk-nya.  Mari kita lihat lebih dekat pada hyperstore2: Disk2 (pada diagram di bawah).  Kita melihat bahwa token 325, 425, 370 dan seterusnya ditugaskan ke disk ini. <br><br>  Karena cluster dikonfigurasi untuk replikasi 3X, berikut ini akan disimpan di hyperstore2: Disk2: <br><br>  Sesuai dengan 325 token disk: <br><ul><li>  Replika objek pertama dengan nilai hash dari 320 (eksklusif) hingga 325 (inklusif); </li><li>  Replika objek kedua dengan nilai hash dari 315 (eksklusif) hingga 320 (inklusif); </li><li>  Replika objek ketiga dengan nilai hash dari 310 (eksklusif) hingga 315 (inklusif). </li></ul><br>  Menurut 425 token disk: <br><ul><li>  Replika objek pertama dengan nilai hash dari 420 (eksklusif) hingga 425 (inklusif); </li><li>  Replika objek kedua dengan nilai hash dari 415 (eksklusif) ke 420 (inklusif); </li><li>  Replika objek ketiga dengan nilai hash dari 410 (eksklusif) hingga 415 (inklusif). </li></ul><br>  Dan sebagainya. <br><br>  Seperti disebutkan sebelumnya, ketika menempatkan replika kedua dan ketiga, HyperStore dalam beberapa kasus dapat melewatkan token agar tidak menyimpan lebih dari satu salinan objek pada satu simpul fisik.  Ini menghilangkan penggunaan hyperstore2: disk2 sebagai penyimpanan untuk replika kedua atau ketiga dari objek yang sama. <br><br><img src="https://habrastorage.org/webt/hl/rf/dq/hlrfdqwtqhiuwvdrrplv0mxt8dk.jpeg"><br><br>  Jika Disk 2 crash pada Disk 1, 3, dan 4, data akan terus disimpan, dan objek pada Disk 2 akan disimpan di cluster, karena  telah direplikasi ke host lain. <br><blockquote>  <b>Komentar:</b> sebagai hasilnya, distribusi replika dan / atau fragmen objek di cluster HyperStore didasarkan pada desain Cassandra, yang dikembangkan untuk kebutuhan penyimpanan file.  ,    ,       ,     ,   «»  .          .                     .  ,      :        ,    ,     . </blockquote><h2>      </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita lihat bagaimana HyperStore bekerja di beberapa pusat data dan wilayah. Dalam kasus kami, mode multi-DPC berbeda dari mode multi-regional dengan menggunakan satu atau beberapa ruang token. Dalam kasus pertama, ruang token seragam. Pada tahap kedua, setiap wilayah akan memiliki ruang token independen dengan (berpotensi) pengaturannya sendiri untuk tingkat konsistensi, kapasitas, dan konfigurasi penyimpanan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memahami bagaimana ini bekerja, mari kita kembali ke terjemahan dokumentasi, bagian </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Penyebaran Pusat Data Banyak".</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan untuk menggunakan HyperStore di dua pusat data. Sebut mereka DC1 dan DC2. Setiap pusat data memiliki 3 node fisik. Seperti dalam contoh kami sebelumnya, setiap node fisik memiliki empat disk, 32 token (vNodes) ditugaskan untuk setiap host, dan kami menganggap ruang token yang disederhanakan dari 0 hingga 960. Menurut skenario ini dengan beberapa pusat data, ruang token dibagi menjadi 192 token - 32 token untuk masing-masing dari 6 host fisik. Token didistribusikan oleh host secara acak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anggap juga bahwa replikasi objek S3 dalam hal ini dikonfigurasi pada dua replika di setiap pusat data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat bagaimana objek S3 hipotetis dengan nilai hash 942 akan mereplikasi di 2 pusat data:</font></font><br><br><ul><li>     vNode 945 (     ),    DC2,  hyperstore5:Disk3. <br></li><li>     vNode 950 (  ) DC2,  hyperstore6:Disk4. <br></li><li>  vNode 955   DC2,      ,   vNode . <br></li><li>     vNode 0 () —  DC1, hyperstore2:Disk3.  ,       (955)       (0). <br></li><li>  vNode (5)   DC2,      ,   vNode . <br></li><li>       vNode 10 () —  DC1, hyperstore3:Disk3. <br></li></ul><br><img src="https://habrastorage.org/webt/uu/vl/ak/uuvlakjhabsho_u_swahrrf8cz4.png"><br><blockquote> <b>:</b>        ,      ,   ,  ,           .     ,      . </blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menyimpulkan tinjauan umum kami tentang arsitektur Cloudian dan fitur-fitur utama. </font><font style="vertical-align: inherit;">Bagaimanapun, topik ini terlalu serius dan besar untuk bisa memuat manual lengkap menjadi sebuah artikel tentang Habré. </font><font style="vertical-align: inherit;">Karena itu, jika Anda tertarik pada detail yang saya hilangkan, Anda memiliki pertanyaan atau saran untuk presentasi materi di artikel mendatang, saya akan dengan senang hati berkomunikasi dengan Anda di komentar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel selanjutnya, kami akan mempertimbangkan implementasi penyimpanan S3 di DataLine, kami akan berbicara secara rinci tentang infrastruktur dan teknologi toleransi kesalahan jaringan yang digunakan, dan sebagai bonus, saya akan menceritakan kisah pembangunannya!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423853/">https://habr.com/ru/post/id423853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423839/index.html">sha256 test per toothOK untuk jaringan saraf</a></li>
<li><a href="../id423843/index.html">Jika Anda berada di Kazan atau Novosibirsk dan ingin merancang microchip, seperti di Cupertino</a></li>
<li><a href="../id423845/index.html">Kondom perusahaan</a></li>
<li><a href="../id423847/index.html">Pengenalan warna dan cahaya dengan APDS-9960</a></li>
<li><a href="../id423851/index.html">Memperkenalkan plugin baru Grafana - panel Statusmap</a></li>
<li><a href="../id423855/index.html">Zyxel Nebula - kemudahan manajemen sebagai dasar untuk penghematan</a></li>
<li><a href="../id423857/index.html">6 tantangan yang akan Anda hadapi ketika belajar pemrograman sendiri</a></li>
<li><a href="../id423861/index.html">Lentera surya - kita perlu lebih terang</a></li>
<li><a href="../id423863/index.html">Konfrontasi pada PHDays 8 - SOC View</a></li>
<li><a href="../id423865/index.html">Roskomnadzor dilaporkan secara publik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>