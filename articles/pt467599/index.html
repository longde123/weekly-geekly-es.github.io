<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¢ üë≤üèø üõÄüèø Renderiza√ß√£o de gr√°ficos 3D com OpenGL üë´ ü¶ï üßÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Renderizar gr√°ficos 3D n√£o √© uma tarefa f√°cil, mas extremamente interessante e emocionante. Este artigo √© para aqueles que est√£o come√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Renderiza√ß√£o de gr√°ficos 3D com OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467599/"><h2>  1. Introdu√ß√£o </h2><br>  Renderizar gr√°ficos 3D n√£o √© uma tarefa f√°cil, mas extremamente interessante e emocionante.  Este artigo √© para aqueles que est√£o come√ßando a se familiarizar com o OpenGL ou para aqueles que est√£o interessados ‚Äã‚Äãem como os pipelines gr√°ficos funcionam e o que s√£o.  Este artigo n√£o fornecer√° instru√ß√µes exatas sobre como criar um contexto e uma janela OpenGL ou como escrever seu primeiro aplicativo de janela OpenGL.  Isso se deve aos recursos de cada linguagem de programa√ß√£o e √† escolha de uma biblioteca ou estrutura para trabalhar com o OpenGL (usarei C ++ e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLFW</a> ), especialmente porque √© f√°cil encontrar um tutorial na rede para a linguagem em que voc√™ est√° interessado.  Todos os exemplos dados neste artigo funcionar√£o em outros idiomas com sem√¢nticas de comandos ligeiramente alteradas, por que √© assim, falarei um pouco mais adiante. <br><a name="habracut"></a><br><h2>  O que √© o OpenGL? </h2><br><p>  OpenGL √© uma especifica√ß√£o que define uma interface de software independente de plataforma para escrever aplicativos usando gr√°ficos de computador bidimensionais e tridimensionais.  O OpenGL n√£o √© uma implementa√ß√£o, mas descreve apenas os conjuntos de instru√ß√µes que devem ser implementadas, ou seja,  √© uma API. </p><br><p>  Cada vers√£o do OpenGL tem sua pr√≥pria especifica√ß√£o, trabalharemos da vers√£o 3.3 para a vers√£o 4.6, porque  todas as inova√ß√µes da vers√£o 3.3 afetam aspectos que s√£o pouco significativos para n√≥s.  Antes de come√ßar a escrever seu primeiro aplicativo OpenGL, eu recomendo que voc√™ descubra quais vers√µes o seu driver suporta (voc√™ pode fazer isso no site do fornecedor da sua placa de v√≠deo) e atualize o driver para a vers√£o mais recente. </p><br><h3>  Dispositivo OpenGL </h3><br><p>  O OpenGL pode ser comparado a uma grande m√°quina de estado, que possui muitos estados e fun√ß√µes para alter√°-los.  O estado OpenGL refere-se basicamente ao contexto OpenGL.  Enquanto trabalhamos com o OpenGL, passaremos por v√°rias fun√ß√µes de mudan√ßa de estado que mudar√£o o contexto e executaremos a√ß√µes dependendo do estado atual do OpenGL. </p><br><p>  Por exemplo, se dermos ao OpenGL o comando para usar linhas em vez de tri√¢ngulos antes da renderiza√ß√£o, o OpenGL usar√° linhas para todos os desenhos subseq√ºentes at√© alterarmos essa op√ß√£o ou alterar o contexto. </p><br><h3>  Objetos no OpenGL </h3><br><p>  As bibliotecas OpenGL s√£o escritas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C</a> e possuem in√∫meras APIs para diferentes idiomas, mas, no entanto, s√£o bibliotecas em C.  Muitas constru√ß√µes de C n√£o s√£o traduzidas para linguagens de alto n√≠vel; portanto, o OpenGL foi desenvolvido usando um grande n√∫mero de abstra√ß√µes, uma dessas abstra√ß√µes s√£o objetos. </p><br><p>  Um objeto no OpenGL √© um conjunto de op√ß√µes que determina seu estado.  Qualquer objeto no OpenGL pode ser descrito por seu ID e pelo conjunto de op√ß√µes pelas quais √© respons√°vel.  Obviamente, cada tipo de objeto tem suas pr√≥prias op√ß√µes e uma tentativa de configurar op√ß√µes inexistentes para o objeto levar√° a um erro.  A√≠ reside a inconveni√™ncia de usar o OpenGL: um conjunto de op√ß√µes √© descrito por uma estrutura semelhante em C cujo identificador geralmente √© um n√∫mero, o que n√£o permite que o programador encontre um erro no est√°gio de compila√ß√£o, porque  c√≥digo incorreto e correto s√£o semanticamente indistingu√≠veis. </p><br><pre><code class="cpp hljs">glGenObject(&amp;objectId); glBindObject(GL_TAGRGET, objectId); glSetObjectOption(GL_TARGET, GL_CORRECT_OPTION, correct_option); <span class="hljs-comment"><span class="hljs-comment">//Ok glSetObjectOption(GL_TARGET, GL_WRONG_OPTION, wrong_option); //  , ..   </span></span></code> </pre> <br><p>  Voc√™ encontrar√° esse c√≥digo com muita frequ√™ncia; portanto, quando voc√™ se acostumar com a configura√ß√£o de uma m√°quina de estado, isso se tornar√° muito mais f√°cil.  Este c√≥digo mostra apenas um exemplo de como o OpenGL funciona.  Posteriormente, exemplos reais ser√£o apresentados. </p><br><p>  Mas h√° vantagens.  A principal caracter√≠stica desses objetos √© que podemos declarar muitos objetos em nosso aplicativo, definir suas op√ß√µes e sempre que iniciarmos opera√ß√µes usando o estado OpenGL, podemos simplesmente vincular o objeto √†s nossas configura√ß√µes preferidas.  Por exemplo, podem ser objetos com dados do modelo 3D ou algo que queremos desenhar nesse modelo.  A posse de v√°rios objetos facilita a altern√¢ncia entre eles durante o processo de renderiza√ß√£o.  Com essa abordagem, podemos configurar muitos objetos necess√°rios para renderizar e usar seus estados sem perder um tempo valioso entre os quadros. </p><br><p>  Para come√ßar a trabalhar com o OpenGL, voc√™ precisa se familiarizar com v√°rios objetos b√°sicos sem os quais n√£o podemos exibir nada.  Usando esses objetos como exemplo, entenderemos como vincular dados e instru√ß√µes execut√°veis ‚Äã‚Äãno OpenGL. </p><br><h2>  Objetos base: Shaders e programas de shader. = </h2><br>  Shader √© um pequeno programa executado em um acelerador de gr√°ficos (GPU) em um determinado ponto do pipeline de gr√°ficos.  Se considerarmos os shaders abstratamente, podemos dizer que esses s√£o os est√°gios do pipeline de gr√°ficos, que: <br><br><ol><li>  Saiba onde obter dados para processamento. </li><li>  Saiba como processar dados de entrada. </li><li>  Eles sabem onde gravar dados para processamento adicional. </li></ol><br><p>  Mas como √© o pipeline de gr√°ficos?  Muito simples, assim: </p><br><img src="https://habrastorage.org/webt/vv/qi/au/vvqiaulrpglg1rnwq0woxh5xg_8.png"><br>  At√© agora, neste esquema, estamos interessados ‚Äã‚Äãapenas na vertical principal, que come√ßa com a especifica√ß√£o de v√©rtice e termina com o buffer de quadro.  Como mencionado anteriormente, cada shader possui seus pr√≥prios par√¢metros de entrada e sa√≠da, que diferem no tipo e no n√∫mero de par√¢metros. <br>  Descrevemos brevemente cada est√°gio do pipeline para entender o que ele faz: <br><br><ol><li>  Vertex Shader - necess√°rio para processar dados de coordenadas 3D e todos os outros par√¢metros de entrada.  Na maioria das vezes, o sombreador de v√©rtice calcula a posi√ß√£o do v√©rtice em rela√ß√£o √† tela, calcula as normais (se necess√°rio) e gera dados de entrada para outros sombreadores. </li><li>  Shader de mosaico e shader de controle de mosaico - esses dois shaders s√£o respons√°veis ‚Äã‚Äãpor detalhar as primitivas provenientes do shader de v√©rtice e preparar os dados para processamento no shader geom√©trico.  √â dif√≠cil descrever do que esses dois shaders s√£o capazes em duas frases, mas para os leitores terem uma pequena ideia, darei algumas imagens com baixos e altos n√≠veis de sobreposi√ß√£o: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/pm/hu/gy/pmhugylrqwhvqkwnia4eby4k0us.png"></td><td><img src="https://habrastorage.org/webt/_p/rs/dl/_prsdlb_pbwgitigom09fj5fju0.png"></td></tr></tbody></table></div><br>  Aconselho voc√™ a ler este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> se quiser saber mais sobre mosaico.  Nesta s√©rie de artigos, abordaremos o mosaico, mas n√£o ser√° em breve. </li><li>  Shader geom√©trico - √© respons√°vel pela forma√ß√£o de primitivas geom√©tricas a partir da sa√≠da do shader de mosaico.  Usando o sombreador geom√©trico, voc√™ pode criar novas primitivas a partir das primitivas b√°sicas do OpenGL (GL_LINES, GL_POINT, GL_TRIANGLES, etc), por exemplo, usando o sombreador geom√©trico, √© poss√≠vel criar um efeito de part√≠cula descrevendo a part√≠cula apenas por cor, centro de cluster, raio e densidade. </li><li>  O shader de rasteriza√ß√£o √© um dos shaders n√£o program√°veis.  Falando em um idioma compreens√≠vel, ele traduz todas as primitivas gr√°ficas de sa√≠da em fragmentos (pixels), ou seja,  determina sua posi√ß√£o na tela. </li><li>  O sombreador de fragmento √© o √∫ltimo est√°gio do pipeline de gr√°ficos.  O sombreador de fragmento calcula a cor do fragmento (pixel) que ser√° definido no buffer de quadro atual.  Na maioria das vezes, no sombreador do fragmento, o sombreamento e a ilumina√ß√£o do fragmento, o mapeamento de texturas e os mapas normais s√£o calculados - todas essas t√©cnicas permitem obter resultados incrivelmente bonitos. </li></ol><br><p>  Os shaders do OpenGL s√£o escritos em uma linguagem GLSL especial do tipo C, a partir da qual s√£o compilados e vinculados a um programa de shader.  J√° nesta fase, parece que escrever um programa de sombreador √© uma tarefa extremamente demorada, porque  voc√™ precisa determinar as 5 etapas do pipeline gr√°fico e vincul√°-las.  Felizmente, n√£o √© assim: os shaders de mosaico e geometria s√£o definidos no pipeline de gr√°ficos por padr√£o, o que nos permite definir apenas dois shaders - o v√©rtice e o fragmento (√†s vezes chamado de pixel shader).  √â melhor considerar esses dois shaders com um exemplo cl√°ssico: </p><br><div class="spoiler">  <b class="spoiler_title">Sombreador de v√©rtice</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 layout (location = 0) in vec3 vertexCords; layout (location = 1) in vec3 color; out vec3 Color; void main(){ gl_Position = vec4(vertexCords,1.0f) ; Color = color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Tonalizador de fragmentos</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 in vec3 Color; out vec4 out_fragColor; void main(){ out_fragColor = Color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exemplo de montagem de sombreador</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vShader = glCreateShader(GL_SHADER_VERTEX); <span class="hljs-comment"><span class="hljs-comment">//    glShaderSource(vShader,&amp;vShaderSource); //  glCompileShader(vShader); //  //        unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vShader); //    glAttachShader(shaderProgram, fShader); //    glLinkProgram(shaderProgram); // </span></span></code> </pre><br></div></div><br><p>  Esses dois sombreadores simples n√£o calculam nada, apenas passam os dados para o pipeline.  Vamos prestar aten√ß√£o em como os sombreadores de v√©rtice e fragmento est√£o conectados: no sombreador de v√©rtice, a vari√°vel Color √© declarada na qual a cor ser√° gravada ap√≥s a execu√ß√£o da fun√ß√£o principal, enquanto no sombreador a mesma vari√°vel exata com o qualificador in √© declarada.  como descrito anteriormente, o sombreador de fragmento recebe dados do v√©rtice por meio de um simples empurr√£o dos dados pelo pipeline (mas, na verdade, n√£o √© t√£o simples). <br></p><blockquote>  Nota: Se voc√™ n√£o declarar e inicializar uma vari√°vel do tipo vec4 no shader de fragmento, nada ser√° exibido na tela. </blockquote><br>  Leitores atentos j√° notaram a declara√ß√£o de vari√°veis ‚Äã‚Äãde entrada do tipo vec3 com qualificadores de layout estranhos no in√≠cio do sombreador de v√©rtices, √© l√≥gico supor que isso seja de entrada, mas de onde n√≥s o obtemos? <br><br><h2>  Objetos base: buffers e matrizes de v√©rtices </h2><br>  Acho que n√£o vale a pena explicar o que s√£o objetos de buffer, √© melhor considerarmos como criar e preencher um buffer no OpenGL. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertices[] = { <span class="hljs-comment"><span class="hljs-comment">// // -0.8f, -0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, 0.0f, 0.0f, 0.0f, 1.0f }; unsigned int VBO; //vertex buffer object glGenBuffers(1,&amp;VBO); glBindBuffer(GL_SOME_BUFFER_TARGET,VBO); glBufferData(GL_SOME_BUFFER_TARGET, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span></code> </pre><br><p>  N√£o h√° nada de dif√≠cil nisso: anexamos o buffer gerado ao destino desejado (mais tarde descobriremos qual) e carregamos os dados indicando seu tamanho e tipo de uso. </p><br><blockquote>  GL_STATIC_DRAW - os dados no buffer n√£o ser√£o alterados. <br>  GL_DYNAMIC_DRAW - os dados no buffer ser√£o alterados, mas n√£o com frequ√™ncia. <br>  GL_STREAM_DRAW - os dados no buffer ser√£o alterados a cada chamada de empate. <br></blockquote><br><p>  √â √≥timo, agora nossos dados est√£o localizados na mem√≥ria da GPU, o programa de sombreador √© compilado e vinculado, mas h√° uma ressalva: como o programa sabe onde obter os dados de entrada para o sombreador de v√©rtice?  Fizemos o download dos dados, mas n√£o indicamos de onde o programa shader o obteria.  Esse problema √© resolvido por um tipo separado de objetos OpenGL - matrizes de v√©rtices. </p><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png" alt="imagem"><br><blockquote>  A imagem √© retirada deste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial</a> . </blockquote><br><p>  Assim como os buffers, as matrizes de v√©rtices s√£o melhor visualizadas usando seu exemplo de configura√ß√£o. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VBO, VAO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glBindVertexArray(VAO); <span class="hljs-comment"><span class="hljs-comment">//    glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //     () glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr); //     () glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), reinterpret_cast&lt;void*&gt; (sizeof(float) * 3)); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);</span></span></code> </pre><br><p>  Criar matrizes de v√©rtices n√£o √© diferente de criar outros objetos OpenGL; o mais interessante come√ßa ap√≥s a linha: </p><pre> <code class="plaintext hljs">glBindVertexArray(VAO);</code> </pre>  Uma matriz de v√©rtices (VAO) lembra todas as liga√ß√µes e configura√ß√µes executadas com ela, incluindo a liga√ß√£o de objetos de buffer para descarregamento de dados.  Neste exemplo, existe apenas um objeto, mas na pr√°tica pode haver v√°rios.  Depois disso, o atributo de v√©rtice com um n√∫mero espec√≠fico √© configurado: <p></p><br><pre> <code class="plaintext hljs"> glBindBuffer(GL_ARRAY_BUFFER, VBO); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr);</code> </pre><br>  Onde conseguimos esse n√∫mero?  Lembre-se de qualificadores de layout para vari√°veis ‚Äã‚Äãde entrada do vertex shader?  S√£o eles que determinam a qual atributo de v√©rtice a vari√°vel de entrada ser√° vinculada.  Agora repare brevemente os argumentos da fun√ß√£o para que n√£o haja perguntas desnecess√°rias: <br><ol><li>  O n√∫mero do atributo que queremos configurar. </li><li>  O n√∫mero de itens que queremos levar.  (Como a vari√°vel de entrada do vertex shader com layout = 0 √© do tipo vec3, usamos 3 elementos do tipo float) </li><li>  Tipo de itens. </li><li>  √â necess√°rio normalizar os elementos, se for um vetor. </li><li>  O deslocamento para o pr√≥ximo v√©rtice (como temos as coordenadas e as cores localizadas seq√ºencialmente e cada uma tem o tipo vec3, passamos por 6 * sizeof (float) = 24 bytes). </li><li>  O √∫ltimo argumento mostra qual deslocamento usar para o primeiro v√©rtice.  (para coordenadas, este argumento √© 0 bytes, para cores 12 bytes) </li></ol><br><p>  Agora estamos prontos para renderizar nossa primeira imagem </p><br><blockquote>  Lembre-se de vincular o VAO e o programa shader antes de chamar a renderiza√ß√£o. <br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">// your render loop glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES,0,3); //        }</span></span></code> </pre><br></blockquote><br><p>  Se voc√™ fez tudo certo, deve obter este resultado: </p><br><img src="https://habrastorage.org/webt/nn/zt/w2/nnztw2prezwfkhm9dsx9viufl4m.png"><br><p>  O resultado √© impressionante, mas de onde veio o preenchimento de gradiente no tri√¢ngulo, porque indicamos apenas tr√™s cores: vermelho, azul e verde para cada v√©rtice individual?  Essa √© a m√°gica do shader de rasteriza√ß√£o: o fato √© que o valor de Cor que definimos no v√©rtice n√£o est√° entrando no shader de fragmento.  N√≥s transmitimos apenas tr√™s v√©rtices, mas muito mais fragmentos s√£o gerados (existem exatamente tantos fragmentos quanto pixels preenchidos).  Portanto, para cada fragmento, a m√©dia dos tr√™s valores de cores √© obtida, dependendo da proximidade com cada um dos v√©rtices.  Isso √© muito bem visto nos cantos do tri√¢ngulo, onde os fragmentos assumem o valor da cor que indicamos nos dados do v√©rtice. <br></p><blockquote>  Olhando para o futuro, direi que as coordenadas da textura s√£o transmitidas da mesma maneira, o que facilita a sobreposi√ß√£o de texturas em nossas primitivas. </blockquote><br><p>  Acho que vale a pena terminar este artigo, o mais dif√≠cil est√° para tr√°s, mas o mais interessante est√° apenas come√ßando.  Se voc√™ tiver alguma d√∫vida ou viu um erro no artigo, escreva sobre isso nos coment√°rios, ficarei muito agradecido. </p><br><p>  No pr√≥ximo artigo, examinaremos as transforma√ß√µes, aprenderemos sobre vari√°veis ‚Äã‚Äãunifrom e aprenderemos a impor texturas a primitivas. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467599/">https://habr.com/ru/post/pt467599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467589/index.html">O que voc√™ precisa saber sobre o GDPR em 2019</a></li>
<li><a href="../pt467591/index.html">A nova prova resolve a aproxima√ß√£o de n√∫meros como pi</a></li>
<li><a href="../pt467593/index.html">(N√£o relevante, reparado) Nota. Como a Tele2 compartilha o acesso √† conta pessoal de novos assinantes</a></li>
<li><a href="../pt467595/index.html">Viajando pelo data center Selectel. Dinossauro em chamas, VMware, C2F5H e o lobisomem invis√≠vel</a></li>
<li><a href="../pt467597/index.html">Personalizando as diretrizes de produtos de big data com o Vowpal Wabbit</a></li>
<li><a href="../pt467605/index.html">Tudo que voc√™ precisa √© de URL</a></li>
<li><a href="../pt467607/index.html">Confiss√£o do √≥dio dos estivadores</a></li>
<li><a href="../pt467609/index.html">Criando um aplicativo m√≥vel no React Native</a></li>
<li><a href="../pt467611/index.html">Algoritmos de detec√ß√£o de contorno de imagem</a></li>
<li><a href="../pt467615/index.html">Como criar wrapper Python e n√£o enlouquecer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>