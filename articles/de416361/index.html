<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥ üë©üèΩ‚ÄçüöÄ üéä So organisieren Sie den allgemeinen Status in Reaktionsanwendungen ohne Verwendung von Bibliotheken (und warum wird Mobx ben√∂tigt) üïã üå≠ üõåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sofort ein kleiner Spoiler - das Organisieren eines Staates in Mobx unterscheidet sich nicht vom Organisieren eines allgemeinen Staates ohne Mobx in e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So organisieren Sie den allgemeinen Status in Reaktionsanwendungen ohne Verwendung von Bibliotheken (und warum wird Mobx ben√∂tigt)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Sofort ein kleiner Spoiler - das Organisieren eines Staates in Mobx unterscheidet sich nicht vom Organisieren eines allgemeinen Staates ohne Mobx in einer reinen Reaktion.  Die Antwort auf die nat√ºrliche Frage lautet: Warum wird dieser Mobx dann tats√§chlich ben√∂tigt? Sie finden ihn am Ende des Artikels. In der Zwischenzeit konzentriert sich der Artikel auf die Organisation des Zustands in einer sauberen Reaktionsanwendung ohne externe Bibliotheken. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  Die Reaktion bietet eine M√∂glichkeit zum Speichern und Aktualisieren des Status von Komponenten mithilfe der state-Eigenschaft f√ºr eine Instanz einer Klassenkomponente und der setState-Methode.  In der Reaktionsgemeinschaft werden jedoch eine Reihe zus√§tzlicher Bibliotheken und Ans√§tze f√ºr die Arbeit mit dem Staat verwendet (Flussmittel, Redux, Reduxionen, Effektor, Mobx, Gehirn, eine Reihe von Bibliotheken).  Aber ist es m√∂glich, eine ausreichend gro√üe Anwendung mit einer Reihe von Gesch√§ftslogiken mit einer gro√üen Anzahl von Entit√§ten und komplexen Datenbeziehungen zwischen Komponenten nur mit setState zu erstellen?  Sind zus√§tzliche Bibliotheken erforderlich, um mit dem Status zu arbeiten?  Lass es uns herausfinden. <a name="habracut"></a><br><p>  Wir haben also setState, das den Status aktualisiert und den Renderer der Komponente aufruft.  Was aber, wenn viele Komponenten, die nicht miteinander verbunden sind, dieselben Daten ben√∂tigen?  Im offiziellen Dock der Reaktion gibt es einen Abschnitt "Aufheben des Zustands" mit einer detaillierten Beschreibung - wir erheben den Zustand einfach auf den Vorfahren, der diesen Komponenten gemeinsam ist, und √ºbergeben Daten und Funktionen, um ihn durch Requisiten (und gegebenenfalls durch Zwischenkomponenten) zu √§ndern.  F√ºr kleine Beispiele sieht dies vern√ºnftig aus, aber die Realit√§t ist, dass in komplexen Anwendungen viele Abh√§ngigkeiten zwischen Komponenten bestehen k√∂nnen und die Tendenz, Zust√§nde auf eine gemeinsame Komponente des Vorfahren zu √ºbertragen, dazu f√ºhrt, dass der gesamte Zustand immer h√∂her wird und zusammen mit ihm in der Stammkomponente der App landet die Logik zum Aktualisieren dieses Status f√ºr alle Komponenten.  Infolgedessen wird setState nur ausgef√ºhrt, um die Datenkomponente lokal oder in der Stammkomponente der App zu aktualisieren, in der die gesamte Logik konzentriert wird. </p><br><p>  Aber ist es m√∂glich, den Prozess- und Renderstatus in einer Reaktionsanwendung zu speichern, ohne setState oder zus√§tzliche Bibliotheken zu verwenden und von beliebigen Komponenten aus allgemeinen Zugriff auf diese Daten zu gew√§hren? </p><br><p>  Die gebr√§uchlichsten Javascript-Objekte und bestimmte Regeln f√ºr deren Organisation helfen uns dabei. </p><br><p>  Zun√§chst m√ºssen Sie jedoch lernen, wie Sie Anwendungen in Entit√§tstypen und deren Beziehungen zerlegen. </p><br><p>  Zun√§chst f√ºhren wir ein Objekt ein, das globale Daten, die f√ºr die gesamte Anwendung gelten, (dies k√∂nnen die Einstellungen f√ºr Stile, Lokalisierung, Fenstergr√∂√üen usw. sein) in einem einzelnen AppState-Objekt speichert und dieses Objekt einfach in eine separate Datei einf√ºgt. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Jetzt k√∂nnen Sie in jeder Komponente die Daten unseres Gesch√§fts importieren und verwenden. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Wir gehen noch weiter - fast jede Anwendung hat die Essenz des aktuellen Benutzers (es spielt keine Rolle, wie sie erstellt wird oder vom Server stammt usw.), sodass sich das Singleton-Objekt unseres Benutzers auch im Status der Anwendung befindet.  Es kann auch in eine separate Datei verschoben und auch importiert werden, oder es kann sofort im AppState-Objekt gespeichert werden.  Und jetzt die Hauptsache - Sie m√ºssen das Diagramm der Entit√§ten bestimmen, aus denen die Anwendung besteht.  In Bezug auf eine Datenbank sind dies Tabellen mit Eins-zu-Viele- oder Viele-zu-Viele-Beziehungen, und diese gesamte Beziehungskette beginnt mit der Hauptessenz des Benutzers.  In unserem Fall speichert das Objekt des Benutzers einfach ein Array anderer Objekt-Entit√§ts-Speicher, wobei jeder Objekt-Speicher wiederum Arrays anderer Entit√§ts-Speicher speichert. </p><br><p>  Hier ist ein Beispiel: Es gibt eine Gesch√§ftslogik, die ausgedr√ºckt wird als "Der Benutzer kann Ordner, Projekte in jedem Ordner, in jedem Aufgabenprojekt und in jeder Unteraufgabenaufgabe erstellen / bearbeiten / l√∂schen" (es stellt sich wie ein Task-Manager heraus) und wird im Statusdiagramm angezeigt ungef√§hr so: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Jetzt kann die Stammkomponente der App dieses Objekt einfach importieren und einige Informationen √ºber den Benutzer rendern. Anschlie√üend kann das Benutzerobjekt auf die Dashboard-Komponente √ºbertragen werden </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  und er kann die Liste der Ordner rendern </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  und jede Komponente des Ordners zeigt eine Liste von Projekten an </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  und jede Komponente des Projekts kann Aufgaben auflisten </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  und schlie√ülich kann jede Aufgabenkomponente eine Liste von Unteraufgaben rendern, indem das gew√ºnschte Objekt an die Unteraufgabenkomponente √ºbergeben wird </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Nat√ºrlich zeigt auf einer Seite niemand alle Aufgaben aller Projekte aller Ordner an, sie werden durch Seitenbereiche (z. B. eine Liste von Ordnern), durch Seiten usw. unterteilt, aber die allgemeine Struktur ist ungef√§hr dieselbe - die √ºbergeordnete Komponente rendert die eingebettete Komponente, die ein Objekt mit Requisiten √ºbergibt Daten.  Ein wichtiger Punkt sollte beachtet werden: Jedes Objekt (z. B. ein Objekt eines Ordners, eines Projekts oder einer Aufgabe) wird nicht im Status einer Komponente gespeichert. Die Komponente empf√§ngt es einfach √ºber Requisiten als Teil eines allgemeineren Objekts.  Wenn die Projektkomponente beispielsweise das Aufgabenobjekt ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) an die untergeordnete Komponente von Task √ºbergibt, da die Objekte in einem einzelnen Objekt gespeichert sind Sie k√∂nnen dieses Aufgabenobjekt jederzeit von au√üen √§ndern, z. B. AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "bearbeitete Aufgabe", und dann die Stammkomponente aktualisieren (ReactDOM.render (&lt;App /&gt;) ) und auf diese Weise erhalten wir den aktuellen Status der Anwendung. </p><br><p>  Angenommen, wir m√∂chten eine neue Unteraufgabe erstellen, wenn wir in der Task-Komponente auf die Schaltfl√§che "+" klicken.  Alles ist einfach </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  Da die Task-Komponente das Task-Objekt als Requisiten empf√§ngt und dieses Objekt nicht in seinem Status gespeichert wird, sondern Teil des globalen AppState-Speichers ist (dh das Task-Objekt wird im Task-Array des allgemeineren Projektobjekts gespeichert und ist wiederum Teil des Benutzerobjekts und der Benutzer ist bereits im AppState gespeichert ) und dank dieser Konnektivit√§t k√∂nnen Sie nach dem Hinzuf√ºgen eines neuen Task-Objekts zum Subtasks-Array das Root-Komponenten-Update aufrufen und dadurch das Haus f√ºr alle Daten√§nderungen (unabh√§ngig davon, wo sie stattgefunden haben) aktualisieren und aktualisieren, indem Sie einfach die Upd-Funktion aufrufen  ateDOM, das wiederum einfach die Stammkomponente aktualisiert. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  Dabei spielt es keine Rolle, welche Daten von welchen Teilen von AppState und von welchen Stellen wir √§ndern (Sie k√∂nnen beispielsweise ein Ordnerobjekt √ºber Requisiten √ºber zwischengeschaltete Projekt- und Aufgabenkomponenten an die Subtask-Komponente weiterleiten und einfach den Ordnernamen aktualisieren (this.props.folder.name = "neuer Name) ") - Aufgrund der Tatsache, dass Komponenten Daten √ºber Requisiten empfangen, werden durch die Aktualisierung der Stammkomponente alle verschachtelten Komponenten und die gesamte Anwendung aktualisiert. </p><br><p>  Lassen Sie uns nun versuchen, die Arbeit mit der Seite etwas komfortabler zu gestalten.  Im obigen Beispiel k√∂nnen Sie feststellen, dass jedes Mal ein neues Entit√§tsobjekt erstellt wird (z. B. <code>project.tasks.push({text: "", subtasks: [], ...})</code> wenn das Objekt viele Eigenschaften mit Standardparametern aufweist Um sie aufzulisten, k√∂nnen Sie einen Fehler machen und etwas vergessen usw. Das erste, was Ihnen in den Sinn kommt, ist, die Erstellung eines Objekts in eine Funktion zu integrieren, in der Standardfelder zugewiesen werden, und sie gleichzeitig mit neuen Daten neu zu definieren </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  Wenn Sie jedoch von der anderen Seite schauen, ist diese Funktion der Konstruktor einer bestimmten Entit√§t, und Javascript-Klassen eignen sich hervorragend f√ºr diese Rolle </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  Wenn Sie dann das Objekt erstellen, wird einfach eine Instanz der Klasse erstellt, mit der einige Standardfelder √ºberschrieben werden k√∂nnen </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  Au√üerdem k√∂nnen Sie feststellen, dass beim Erstellen von Klassen f√ºr Projektobjekte, Benutzer und Unteraufgaben auf dieselbe Weise Code-Duplikate im Konstruktor erstellt werden </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  Wir k√∂nnen jedoch die Vererbung nutzen und diesen Code in den Konstruktor der Basisklasse ziehen. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  Au√üerdem werden Sie feststellen, dass wir jedes Mal, wenn wir einen Status aktualisieren, die Felder des Objekts manuell √§ndern </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  und es wird schwierig zu verfolgen, zu verhandeln und zu verstehen, was in der Komponente geschieht, und daher muss ein gemeinsamer Kanal festgelegt werden, √ºber den Aktualisierungen von Daten durchlaufen werden, und dann k√∂nnen wir Protokollierung und alle m√∂glichen anderen Annehmlichkeiten hinzuf√ºgen.  Zu diesem Zweck besteht die L√∂sung darin, eine Aktualisierungsmethode in der Klasse zu erstellen, die ein tempor√§res Objekt mit neuen Daten verwendet und sich selbst aktualisiert und die Regel festlegt, dass Objekte nur √ºber die Aktualisierungsmethode und nicht durch direkte Zuweisung aktualisiert werden k√∂nnen </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Um den Code nicht in jeder Klasse zu duplizieren, verschieben wir diese Aktualisierungsmethode auch in die Basisklasse. </p><br><p>  Jetzt k√∂nnen Sie sehen, dass wir beim Aktualisieren einiger Daten die updateDOM () -Methode manuell aufrufen m√ºssen.  Es ist jedoch praktisch, dieses Update jedes Mal automatisch durchzuf√ºhren, wenn die Update-Methode ({...}) der Basisklasse aufgerufen wird. <br>  Es stellt sich heraus, dass die Basisklasse ungef√§hr so ‚Äã‚Äãaussehen wird </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Damit beim sukzessiven Aufruf der update () -Methode keine unn√∂tigen Aktualisierungen auftreten, k√∂nnen Sie die Aktualisierung der Komponente auf den n√§chsten Ereigniszyklus verz√∂gern </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  Dar√ºber hinaus k√∂nnen Sie die Funktionalit√§t der Basisklasse schrittweise erh√∂hen. Um beispielsweise nicht jedes Mal manuell eine Anforderung an den Server senden zu m√ºssen, k√∂nnen Sie zus√§tzlich zur Aktualisierung des Status im Hintergrund eine Anforderung an die Aktualisierungsmethode ({..}) senden.  Sie k√∂nnen einen Live-Aktualisierungskanal f√ºr Web-Sockets organisieren, indem Sie ein Konto f√ºr jedes erstellte Objekt in der globalen Hash-Map hinzuf√ºgen, ohne die Komponenten zu √§ndern und in irgendeiner Weise mit Daten zu arbeiten. </p><br><p>  Es gibt noch viel zu tun, aber ich m√∂chte ein interessantes Thema erw√§hnen - sehr oft ein Objekt mit Daten an die erforderliche Komponente √ºbergeben (z. B. wenn eine Projektkomponente eine Aufgabenkomponente rendert). </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  Die eigentliche Komponente der Aufgabe ben√∂tigt m√∂glicherweise einige Informationen, die nicht direkt in der Aufgabe gespeichert sind, sondern sich im √ºbergeordneten Objekt befinden. </p><br><p>  Angenommen, Sie m√∂chten alle Aufgaben in einer Farbe f√§rben, die im Projekt gespeichert ist und allen Aufgaben gemeinsam ist.  Dazu muss die Projektkomponente zus√§tzlich zu den Task-Requisiten auch ihre Projekt-Requisiten <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  Wenn Sie die Aufgabe pl√∂tzlich in einer Farbe f√§rben m√ºssen, die allen Aufgaben in einem Ordner gemeinsam ist, m√ºssen Sie das aktuelle Ordnerobjekt von der Ordnerkomponente zur Aufgabenkomponente √ºbertragen, indem Sie es √ºber die Zwischenkomponente Projekt weiterleiten. <br>  Eine fragile Abh√§ngigkeit scheint zu bestehen, dass die Komponente wissen sollte, was ihre verschachtelten Komponenten erfordern.  Dar√ºber hinaus erfordert die M√∂glichkeit eines Reaktionskontexts, obwohl dies die √úbertragung durch Zwischenkomponenten vereinfacht, immer noch eine Beschreibung des Anbieters und das Wissen dar√ºber, welche Daten f√ºr die untergeordneten Komponenten ben√∂tigt werden. </p><br><p>  Das Hauptproblem besteht jedoch darin, dass Sie jedes Mal, wenn Sie ein Design bearbeiten oder die Wunschliste eines Kunden √§ndern, wenn eine Komponente neue Informationen ben√∂tigt, die h√∂heren Komponenten √§ndern m√ºssen, indem Sie entweder Requisiten weiterleiten oder Kontextanbieter erstellen.  Ich m√∂chte, dass die Komponente, die √ºber Requisiten ein Objekt mit Daten empf√§ngt, irgendwie auf einen Teil unseres Anwendungsstatus zugreift.  Und hier passt Javascript gut (im Gegensatz zu funktionalen Sprachen wie Ulme oder unver√§nderlichen Ans√§tzen wie Redux), sodass Objekte kreisf√∂rmige Links zueinander speichern k√∂nnen.  In diesem Fall sollte das Task-Objekt ein task.project-Feld mit einem Link zum Objekt des √ºbergeordneten Projekts haben, in dem es gespeichert ist, und das Projektobjekt sollte wiederum einen Link zum Ordnerobjekt usw. zum Root-AppState-Objekt haben.  Somit kann die Komponente, egal wie tief sie ist, immer die √ºbergeordneten Objekte √ºber den Link durchlaufen und alle erforderlichen Informationen abrufen, ohne sie durch eine Reihe von Zwischenkomponenten werfen zu m√ºssen.  Daher f√ºhren wir eine Regel ein: Jedes Mal, wenn Sie ein Objekt erstellen, m√ºssen Sie dem √ºbergeordneten Objekt einen Link hinzuf√ºgen.  Das Erstellen einer neuen Aufgabe sieht beispielsweise so aus </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  Mit zunehmender Gesch√§ftslogik k√∂nnen Sie au√üerdem feststellen, dass die Bolterplate mit der Backlink-Unterst√ºtzung verbunden ist (z. B. beim Zuweisen eines Links zum √ºbergeordneten Objekt beim Erstellen eines neuen Objekts oder beim √úbertragen eines Projekts von einem Ordner in einen anderen m√ºssen Sie nicht nur die Eigenschaft project.folder = newFolder aktualisieren und l√∂schen Sie selbst aus dem Projektarray des vorherigen Ordners und das Hinzuf√ºgen eines neuen Ordners zum Projektarray beginnt sich zu wiederholen. Es kann auch in die Basisklasse verschoben werden, sodass beim Erstellen des Objekts die √ºbergeordnete <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> und die Basisklasse w√ºrden automatisch ein neues Objekt zum Array <code>project.tasks</code> hinzuf√ºgen. Auch beim √úbertragen der Aufgabe in ein anderes Projekt w√ºrde es ausreichen, nur das <code>task.update({project: newProject})</code> zu aktualisieren, und die Basisklasse w√ºrde die Aufgabe automatisch l√∂schen Eine Reihe von Aufgaben aus dem vorherigen Projekt, die einem neuen hinzugef√ºgt wurden.  Dies erfordert jedoch bereits die Deklaration von Beziehungen (z. B. in statischen Eigenschaften oder Methoden), damit die Basisklasse wei√ü, welche Felder aktualisiert werden m√ºssen. </p><br><p>  <strong>Fazit</strong> </p><br><p>  Auf solch einfache Weise, bei der nur js-Objekte verwendet wurden, kamen wir zu dem Schluss, dass Sie alle Vorteile des Arbeitens mit dem allgemeinen Status der Anwendung erhalten k√∂nnen, ohne die Abh√§ngigkeit von einer externen Bibliothek f√ºr die Arbeit mit dem Status in die Anwendung einzuf√ºhren. </p><br><p>  Die Frage ist, warum wir dann Bibliotheken f√ºr die Verwaltung des Staates und insbesondere von Mobx ben√∂tigen. </p><br><p>  Tatsache ist, dass bei dem beschriebenen Ansatz zur Organisation des allgemeinen Zustands bei Verwendung gew√∂hnlicher nativer "Vanilla" -J-Objekte (oder Klassenobjekte) ein gro√üer Nachteil besteht: Wenn sich ein kleiner Teil des Zustands oder sogar ein Feld √§ndert, werden die Komponenten aktualisiert oder "gerendert", die in keiner Weise verbunden sind und h√§ngen nicht von diesem Teil des Staates ab. <br>  Bei gro√üen Anwendungen mit fettgedruckter Benutzeroberfl√§che f√ºhrt dies zu Bremsen, da die Reaktion einfach keine Zeit hat, das virtuelle Haus der gesamten Anwendung rekursiv zu vergleichen, da zus√§tzlich zum Vergleich jedes Renderers jedes Mal ein neuer Objektbaum generiert wird, der das Layout absolut aller Komponenten beschreibt. </p><br><p>  Trotz der Bedeutung ist dieses Problem rein technischer Natur - es gibt Bibliotheken, die der Vitual Dom-Reaktion √§hneln und den Renderer besser optimieren und das Komponentenlimit erh√∂hen k√∂nnen. </p><br><p>  Es gibt effektivere Hausrenovierungstechniken als das Erstellen eines neuen virtuellen Hausbaums und den anschlie√üenden rekursiven Vergleichsdurchlauf mit dem vorherigen Baum. </p><br><p>  Und schlie√ülich gibt es Bibliotheken, die versuchen, das Problem langsamer Aktualisierungen durch einen anderen Ansatz zu l√∂sen - n√§mlich zu verfolgen, welche Teile des Status mit welchen Komponenten verbunden sind, und beim √Ñndern einiger Daten nur die Komponenten zu berechnen und zu aktualisieren, die von diesen Daten abh√§ngen, und die verbleibenden Komponenten nicht zu ber√ºhren.  Redux ist ebenfalls eine solche Bibliothek, erfordert jedoch einen v√∂llig anderen Ansatz f√ºr die staatliche Organisation.  Im Gegensatz dazu bringt die Mobx-Bibliothek nichts Neues und wir k√∂nnen den Renderer praktisch beschleunigen, ohne etwas in der Anwendung zu √§ndern. <code>@observable</code> einfach den <code>@observable</code> Dekorator zu den Feldern der Klasse und den <code>@observable</code> Dekorator zu den Komponenten hinzu, die diese Felder rendern, und es bleibt Wenn Sie nur den unn√∂tigen Aktualisierungscode f√ºr die Stammkomponente in der update () -Methode unserer Basisklasse ausschneiden, erhalten Sie eine voll funktionsf√§hige Anwendung. Wenn Sie jedoch jetzt einen Teil des Status oder sogar ein Feld √§ndern, werden nur diese Komponenten aktualisiert  die gereift AK (einlenkenden Methode () √ºbertr√§gt) f√ºr ein bestimmtes Feld eines bestimmten Zustands des Objekts. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416361/">https://habr.com/ru/post/de416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416349/index.html">Sehen Sie die Welligkeit</a></li>
<li><a href="../de416351/index.html">Top-Down-Ansatz. Produkt√∂konomie. Bruttogewinn</a></li>
<li><a href="../de416353/index.html">Audio Digest: 20 Materialien zur Geschichte der akustischen Systeme und Musik in der sowjetischen Kultur</a></li>
<li><a href="../de416355/index.html">Interview mit Gary Hudson, CEO von Oisin Biotechnologies</a></li>
<li><a href="../de416359/index.html">Schnelle Arbeitsumgebung f√ºr Webentwickler (Vagrant und PHPStorm)</a></li>
<li><a href="../de416363/index.html">Taobao wurde offiziell in Russland er√∂ffnet</a></li>
<li><a href="../de416365/index.html">Sammlung von W√ºnschen und Abstimmung f√ºr neue Funktionen des Vivaldi-Browsers</a></li>
<li><a href="../de416367/index.html">Wir starten ReactOS mit BTRFS des Abschnitts</a></li>
<li><a href="../de416369/index.html">Fast kompliziert. Teil 2, Schaffung eines drahtlosen ‚ÄûSmart Home‚Äú. Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416371/index.html">Analoges Campinglicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>