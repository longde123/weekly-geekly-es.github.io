<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴 👩🏽‍🚀 🎊 So organisieren Sie den allgemeinen Status in Reaktionsanwendungen ohne Verwendung von Bibliotheken (und warum wird Mobx benötigt) 🕋 🌭 🛌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sofort ein kleiner Spoiler - das Organisieren eines Staates in Mobx unterscheidet sich nicht vom Organisieren eines allgemeinen Staates ohne Mobx in e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So organisieren Sie den allgemeinen Status in Reaktionsanwendungen ohne Verwendung von Bibliotheken (und warum wird Mobx benötigt)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Sofort ein kleiner Spoiler - das Organisieren eines Staates in Mobx unterscheidet sich nicht vom Organisieren eines allgemeinen Staates ohne Mobx in einer reinen Reaktion.  Die Antwort auf die natürliche Frage lautet: Warum wird dieser Mobx dann tatsächlich benötigt? Sie finden ihn am Ende des Artikels. In der Zwischenzeit konzentriert sich der Artikel auf die Organisation des Zustands in einer sauberen Reaktionsanwendung ohne externe Bibliotheken. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  Die Reaktion bietet eine Möglichkeit zum Speichern und Aktualisieren des Status von Komponenten mithilfe der state-Eigenschaft für eine Instanz einer Klassenkomponente und der setState-Methode.  In der Reaktionsgemeinschaft werden jedoch eine Reihe zusätzlicher Bibliotheken und Ansätze für die Arbeit mit dem Staat verwendet (Flussmittel, Redux, Reduxionen, Effektor, Mobx, Gehirn, eine Reihe von Bibliotheken).  Aber ist es möglich, eine ausreichend große Anwendung mit einer Reihe von Geschäftslogiken mit einer großen Anzahl von Entitäten und komplexen Datenbeziehungen zwischen Komponenten nur mit setState zu erstellen?  Sind zusätzliche Bibliotheken erforderlich, um mit dem Status zu arbeiten?  Lass es uns herausfinden. <a name="habracut"></a><br><p>  Wir haben also setState, das den Status aktualisiert und den Renderer der Komponente aufruft.  Was aber, wenn viele Komponenten, die nicht miteinander verbunden sind, dieselben Daten benötigen?  Im offiziellen Dock der Reaktion gibt es einen Abschnitt "Aufheben des Zustands" mit einer detaillierten Beschreibung - wir erheben den Zustand einfach auf den Vorfahren, der diesen Komponenten gemeinsam ist, und übergeben Daten und Funktionen, um ihn durch Requisiten (und gegebenenfalls durch Zwischenkomponenten) zu ändern.  Für kleine Beispiele sieht dies vernünftig aus, aber die Realität ist, dass in komplexen Anwendungen viele Abhängigkeiten zwischen Komponenten bestehen können und die Tendenz, Zustände auf eine gemeinsame Komponente des Vorfahren zu übertragen, dazu führt, dass der gesamte Zustand immer höher wird und zusammen mit ihm in der Stammkomponente der App landet die Logik zum Aktualisieren dieses Status für alle Komponenten.  Infolgedessen wird setState nur ausgeführt, um die Datenkomponente lokal oder in der Stammkomponente der App zu aktualisieren, in der die gesamte Logik konzentriert wird. </p><br><p>  Aber ist es möglich, den Prozess- und Renderstatus in einer Reaktionsanwendung zu speichern, ohne setState oder zusätzliche Bibliotheken zu verwenden und von beliebigen Komponenten aus allgemeinen Zugriff auf diese Daten zu gewähren? </p><br><p>  Die gebräuchlichsten Javascript-Objekte und bestimmte Regeln für deren Organisation helfen uns dabei. </p><br><p>  Zunächst müssen Sie jedoch lernen, wie Sie Anwendungen in Entitätstypen und deren Beziehungen zerlegen. </p><br><p>  Zunächst führen wir ein Objekt ein, das globale Daten, die für die gesamte Anwendung gelten, (dies können die Einstellungen für Stile, Lokalisierung, Fenstergrößen usw. sein) in einem einzelnen AppState-Objekt speichert und dieses Objekt einfach in eine separate Datei einfügt. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Jetzt können Sie in jeder Komponente die Daten unseres Geschäfts importieren und verwenden. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Wir gehen noch weiter - fast jede Anwendung hat die Essenz des aktuellen Benutzers (es spielt keine Rolle, wie sie erstellt wird oder vom Server stammt usw.), sodass sich das Singleton-Objekt unseres Benutzers auch im Status der Anwendung befindet.  Es kann auch in eine separate Datei verschoben und auch importiert werden, oder es kann sofort im AppState-Objekt gespeichert werden.  Und jetzt die Hauptsache - Sie müssen das Diagramm der Entitäten bestimmen, aus denen die Anwendung besteht.  In Bezug auf eine Datenbank sind dies Tabellen mit Eins-zu-Viele- oder Viele-zu-Viele-Beziehungen, und diese gesamte Beziehungskette beginnt mit der Hauptessenz des Benutzers.  In unserem Fall speichert das Objekt des Benutzers einfach ein Array anderer Objekt-Entitäts-Speicher, wobei jeder Objekt-Speicher wiederum Arrays anderer Entitäts-Speicher speichert. </p><br><p>  Hier ist ein Beispiel: Es gibt eine Geschäftslogik, die ausgedrückt wird als "Der Benutzer kann Ordner, Projekte in jedem Ordner, in jedem Aufgabenprojekt und in jeder Unteraufgabenaufgabe erstellen / bearbeiten / löschen" (es stellt sich wie ein Task-Manager heraus) und wird im Statusdiagramm angezeigt ungefähr so: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Jetzt kann die Stammkomponente der App dieses Objekt einfach importieren und einige Informationen über den Benutzer rendern. Anschließend kann das Benutzerobjekt auf die Dashboard-Komponente übertragen werden </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  und er kann die Liste der Ordner rendern </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  und jede Komponente des Ordners zeigt eine Liste von Projekten an </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  und jede Komponente des Projekts kann Aufgaben auflisten </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  und schließlich kann jede Aufgabenkomponente eine Liste von Unteraufgaben rendern, indem das gewünschte Objekt an die Unteraufgabenkomponente übergeben wird </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Natürlich zeigt auf einer Seite niemand alle Aufgaben aller Projekte aller Ordner an, sie werden durch Seitenbereiche (z. B. eine Liste von Ordnern), durch Seiten usw. unterteilt, aber die allgemeine Struktur ist ungefähr dieselbe - die übergeordnete Komponente rendert die eingebettete Komponente, die ein Objekt mit Requisiten übergibt Daten.  Ein wichtiger Punkt sollte beachtet werden: Jedes Objekt (z. B. ein Objekt eines Ordners, eines Projekts oder einer Aufgabe) wird nicht im Status einer Komponente gespeichert. Die Komponente empfängt es einfach über Requisiten als Teil eines allgemeineren Objekts.  Wenn die Projektkomponente beispielsweise das Aufgabenobjekt ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) an die untergeordnete Komponente von Task übergibt, da die Objekte in einem einzelnen Objekt gespeichert sind Sie können dieses Aufgabenobjekt jederzeit von außen ändern, z. B. AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "bearbeitete Aufgabe", und dann die Stammkomponente aktualisieren (ReactDOM.render (&lt;App /&gt;) ) und auf diese Weise erhalten wir den aktuellen Status der Anwendung. </p><br><p>  Angenommen, wir möchten eine neue Unteraufgabe erstellen, wenn wir in der Task-Komponente auf die Schaltfläche "+" klicken.  Alles ist einfach </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  Da die Task-Komponente das Task-Objekt als Requisiten empfängt und dieses Objekt nicht in seinem Status gespeichert wird, sondern Teil des globalen AppState-Speichers ist (dh das Task-Objekt wird im Task-Array des allgemeineren Projektobjekts gespeichert und ist wiederum Teil des Benutzerobjekts und der Benutzer ist bereits im AppState gespeichert ) und dank dieser Konnektivität können Sie nach dem Hinzufügen eines neuen Task-Objekts zum Subtasks-Array das Root-Komponenten-Update aufrufen und dadurch das Haus für alle Datenänderungen (unabhängig davon, wo sie stattgefunden haben) aktualisieren und aktualisieren, indem Sie einfach die Upd-Funktion aufrufen  ateDOM, das wiederum einfach die Stammkomponente aktualisiert. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  Dabei spielt es keine Rolle, welche Daten von welchen Teilen von AppState und von welchen Stellen wir ändern (Sie können beispielsweise ein Ordnerobjekt über Requisiten über zwischengeschaltete Projekt- und Aufgabenkomponenten an die Subtask-Komponente weiterleiten und einfach den Ordnernamen aktualisieren (this.props.folder.name = "neuer Name) ") - Aufgrund der Tatsache, dass Komponenten Daten über Requisiten empfangen, werden durch die Aktualisierung der Stammkomponente alle verschachtelten Komponenten und die gesamte Anwendung aktualisiert. </p><br><p>  Lassen Sie uns nun versuchen, die Arbeit mit der Seite etwas komfortabler zu gestalten.  Im obigen Beispiel können Sie feststellen, dass jedes Mal ein neues Entitätsobjekt erstellt wird (z. B. <code>project.tasks.push({text: "", subtasks: [], ...})</code> wenn das Objekt viele Eigenschaften mit Standardparametern aufweist Um sie aufzulisten, können Sie einen Fehler machen und etwas vergessen usw. Das erste, was Ihnen in den Sinn kommt, ist, die Erstellung eines Objekts in eine Funktion zu integrieren, in der Standardfelder zugewiesen werden, und sie gleichzeitig mit neuen Daten neu zu definieren </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  Wenn Sie jedoch von der anderen Seite schauen, ist diese Funktion der Konstruktor einer bestimmten Entität, und Javascript-Klassen eignen sich hervorragend für diese Rolle </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  Wenn Sie dann das Objekt erstellen, wird einfach eine Instanz der Klasse erstellt, mit der einige Standardfelder überschrieben werden können </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  Außerdem können Sie feststellen, dass beim Erstellen von Klassen für Projektobjekte, Benutzer und Unteraufgaben auf dieselbe Weise Code-Duplikate im Konstruktor erstellt werden </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  Wir können jedoch die Vererbung nutzen und diesen Code in den Konstruktor der Basisklasse ziehen. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  Außerdem werden Sie feststellen, dass wir jedes Mal, wenn wir einen Status aktualisieren, die Felder des Objekts manuell ändern </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  und es wird schwierig zu verfolgen, zu verhandeln und zu verstehen, was in der Komponente geschieht, und daher muss ein gemeinsamer Kanal festgelegt werden, über den Aktualisierungen von Daten durchlaufen werden, und dann können wir Protokollierung und alle möglichen anderen Annehmlichkeiten hinzufügen.  Zu diesem Zweck besteht die Lösung darin, eine Aktualisierungsmethode in der Klasse zu erstellen, die ein temporäres Objekt mit neuen Daten verwendet und sich selbst aktualisiert und die Regel festlegt, dass Objekte nur über die Aktualisierungsmethode und nicht durch direkte Zuweisung aktualisiert werden können </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Um den Code nicht in jeder Klasse zu duplizieren, verschieben wir diese Aktualisierungsmethode auch in die Basisklasse. </p><br><p>  Jetzt können Sie sehen, dass wir beim Aktualisieren einiger Daten die updateDOM () -Methode manuell aufrufen müssen.  Es ist jedoch praktisch, dieses Update jedes Mal automatisch durchzuführen, wenn die Update-Methode ({...}) der Basisklasse aufgerufen wird. <br>  Es stellt sich heraus, dass die Basisklasse ungefähr so ​​aussehen wird </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Damit beim sukzessiven Aufruf der update () -Methode keine unnötigen Aktualisierungen auftreten, können Sie die Aktualisierung der Komponente auf den nächsten Ereigniszyklus verzögern </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  Darüber hinaus können Sie die Funktionalität der Basisklasse schrittweise erhöhen. Um beispielsweise nicht jedes Mal manuell eine Anforderung an den Server senden zu müssen, können Sie zusätzlich zur Aktualisierung des Status im Hintergrund eine Anforderung an die Aktualisierungsmethode ({..}) senden.  Sie können einen Live-Aktualisierungskanal für Web-Sockets organisieren, indem Sie ein Konto für jedes erstellte Objekt in der globalen Hash-Map hinzufügen, ohne die Komponenten zu ändern und in irgendeiner Weise mit Daten zu arbeiten. </p><br><p>  Es gibt noch viel zu tun, aber ich möchte ein interessantes Thema erwähnen - sehr oft ein Objekt mit Daten an die erforderliche Komponente übergeben (z. B. wenn eine Projektkomponente eine Aufgabenkomponente rendert). </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  Die eigentliche Komponente der Aufgabe benötigt möglicherweise einige Informationen, die nicht direkt in der Aufgabe gespeichert sind, sondern sich im übergeordneten Objekt befinden. </p><br><p>  Angenommen, Sie möchten alle Aufgaben in einer Farbe färben, die im Projekt gespeichert ist und allen Aufgaben gemeinsam ist.  Dazu muss die Projektkomponente zusätzlich zu den Task-Requisiten auch ihre Projekt-Requisiten <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  Wenn Sie die Aufgabe plötzlich in einer Farbe färben müssen, die allen Aufgaben in einem Ordner gemeinsam ist, müssen Sie das aktuelle Ordnerobjekt von der Ordnerkomponente zur Aufgabenkomponente übertragen, indem Sie es über die Zwischenkomponente Projekt weiterleiten. <br>  Eine fragile Abhängigkeit scheint zu bestehen, dass die Komponente wissen sollte, was ihre verschachtelten Komponenten erfordern.  Darüber hinaus erfordert die Möglichkeit eines Reaktionskontexts, obwohl dies die Übertragung durch Zwischenkomponenten vereinfacht, immer noch eine Beschreibung des Anbieters und das Wissen darüber, welche Daten für die untergeordneten Komponenten benötigt werden. </p><br><p>  Das Hauptproblem besteht jedoch darin, dass Sie jedes Mal, wenn Sie ein Design bearbeiten oder die Wunschliste eines Kunden ändern, wenn eine Komponente neue Informationen benötigt, die höheren Komponenten ändern müssen, indem Sie entweder Requisiten weiterleiten oder Kontextanbieter erstellen.  Ich möchte, dass die Komponente, die über Requisiten ein Objekt mit Daten empfängt, irgendwie auf einen Teil unseres Anwendungsstatus zugreift.  Und hier passt Javascript gut (im Gegensatz zu funktionalen Sprachen wie Ulme oder unveränderlichen Ansätzen wie Redux), sodass Objekte kreisförmige Links zueinander speichern können.  In diesem Fall sollte das Task-Objekt ein task.project-Feld mit einem Link zum Objekt des übergeordneten Projekts haben, in dem es gespeichert ist, und das Projektobjekt sollte wiederum einen Link zum Ordnerobjekt usw. zum Root-AppState-Objekt haben.  Somit kann die Komponente, egal wie tief sie ist, immer die übergeordneten Objekte über den Link durchlaufen und alle erforderlichen Informationen abrufen, ohne sie durch eine Reihe von Zwischenkomponenten werfen zu müssen.  Daher führen wir eine Regel ein: Jedes Mal, wenn Sie ein Objekt erstellen, müssen Sie dem übergeordneten Objekt einen Link hinzufügen.  Das Erstellen einer neuen Aufgabe sieht beispielsweise so aus </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  Mit zunehmender Geschäftslogik können Sie außerdem feststellen, dass die Bolterplate mit der Backlink-Unterstützung verbunden ist (z. B. beim Zuweisen eines Links zum übergeordneten Objekt beim Erstellen eines neuen Objekts oder beim Übertragen eines Projekts von einem Ordner in einen anderen müssen Sie nicht nur die Eigenschaft project.folder = newFolder aktualisieren und löschen Sie selbst aus dem Projektarray des vorherigen Ordners und das Hinzufügen eines neuen Ordners zum Projektarray beginnt sich zu wiederholen. Es kann auch in die Basisklasse verschoben werden, sodass beim Erstellen des Objekts die übergeordnete <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> und die Basisklasse würden automatisch ein neues Objekt zum Array <code>project.tasks</code> hinzufügen. Auch beim Übertragen der Aufgabe in ein anderes Projekt würde es ausreichen, nur das <code>task.update({project: newProject})</code> zu aktualisieren, und die Basisklasse würde die Aufgabe automatisch löschen Eine Reihe von Aufgaben aus dem vorherigen Projekt, die einem neuen hinzugefügt wurden.  Dies erfordert jedoch bereits die Deklaration von Beziehungen (z. B. in statischen Eigenschaften oder Methoden), damit die Basisklasse weiß, welche Felder aktualisiert werden müssen. </p><br><p>  <strong>Fazit</strong> </p><br><p>  Auf solch einfache Weise, bei der nur js-Objekte verwendet wurden, kamen wir zu dem Schluss, dass Sie alle Vorteile des Arbeitens mit dem allgemeinen Status der Anwendung erhalten können, ohne die Abhängigkeit von einer externen Bibliothek für die Arbeit mit dem Status in die Anwendung einzuführen. </p><br><p>  Die Frage ist, warum wir dann Bibliotheken für die Verwaltung des Staates und insbesondere von Mobx benötigen. </p><br><p>  Tatsache ist, dass bei dem beschriebenen Ansatz zur Organisation des allgemeinen Zustands bei Verwendung gewöhnlicher nativer "Vanilla" -J-Objekte (oder Klassenobjekte) ein großer Nachteil besteht: Wenn sich ein kleiner Teil des Zustands oder sogar ein Feld ändert, werden die Komponenten aktualisiert oder "gerendert", die in keiner Weise verbunden sind und hängen nicht von diesem Teil des Staates ab. <br>  Bei großen Anwendungen mit fettgedruckter Benutzeroberfläche führt dies zu Bremsen, da die Reaktion einfach keine Zeit hat, das virtuelle Haus der gesamten Anwendung rekursiv zu vergleichen, da zusätzlich zum Vergleich jedes Renderers jedes Mal ein neuer Objektbaum generiert wird, der das Layout absolut aller Komponenten beschreibt. </p><br><p>  Trotz der Bedeutung ist dieses Problem rein technischer Natur - es gibt Bibliotheken, die der Vitual Dom-Reaktion ähneln und den Renderer besser optimieren und das Komponentenlimit erhöhen können. </p><br><p>  Es gibt effektivere Hausrenovierungstechniken als das Erstellen eines neuen virtuellen Hausbaums und den anschließenden rekursiven Vergleichsdurchlauf mit dem vorherigen Baum. </p><br><p>  Und schließlich gibt es Bibliotheken, die versuchen, das Problem langsamer Aktualisierungen durch einen anderen Ansatz zu lösen - nämlich zu verfolgen, welche Teile des Status mit welchen Komponenten verbunden sind, und beim Ändern einiger Daten nur die Komponenten zu berechnen und zu aktualisieren, die von diesen Daten abhängen, und die verbleibenden Komponenten nicht zu berühren.  Redux ist ebenfalls eine solche Bibliothek, erfordert jedoch einen völlig anderen Ansatz für die staatliche Organisation.  Im Gegensatz dazu bringt die Mobx-Bibliothek nichts Neues und wir können den Renderer praktisch beschleunigen, ohne etwas in der Anwendung zu ändern. <code>@observable</code> einfach den <code>@observable</code> Dekorator zu den Feldern der Klasse und den <code>@observable</code> Dekorator zu den Komponenten hinzu, die diese Felder rendern, und es bleibt Wenn Sie nur den unnötigen Aktualisierungscode für die Stammkomponente in der update () -Methode unserer Basisklasse ausschneiden, erhalten Sie eine voll funktionsfähige Anwendung. Wenn Sie jedoch jetzt einen Teil des Status oder sogar ein Feld ändern, werden nur diese Komponenten aktualisiert  die gereift AK (einlenkenden Methode () überträgt) für ein bestimmtes Feld eines bestimmten Zustands des Objekts. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416361/">https://habr.com/ru/post/de416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416349/index.html">Sehen Sie die Welligkeit</a></li>
<li><a href="../de416351/index.html">Top-Down-Ansatz. Produktökonomie. Bruttogewinn</a></li>
<li><a href="../de416353/index.html">Audio Digest: 20 Materialien zur Geschichte der akustischen Systeme und Musik in der sowjetischen Kultur</a></li>
<li><a href="../de416355/index.html">Interview mit Gary Hudson, CEO von Oisin Biotechnologies</a></li>
<li><a href="../de416359/index.html">Schnelle Arbeitsumgebung für Webentwickler (Vagrant und PHPStorm)</a></li>
<li><a href="../de416363/index.html">Taobao wurde offiziell in Russland eröffnet</a></li>
<li><a href="../de416365/index.html">Sammlung von Wünschen und Abstimmung für neue Funktionen des Vivaldi-Browsers</a></li>
<li><a href="../de416367/index.html">Wir starten ReactOS mit BTRFS des Abschnitts</a></li>
<li><a href="../de416369/index.html">Fast kompliziert. Teil 2, Schaffung eines drahtlosen „Smart Home“. Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416371/index.html">Analoges Campinglicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>