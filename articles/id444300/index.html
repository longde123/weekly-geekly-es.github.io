<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏾 👨🏾‍🎤 👨 Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 1 ⏏️ 🔭 👸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Sergey Kostanbaev, di Bursa saya sedang mengembangkan inti dari sistem perdagangan. 

 Ketika Bursa Efek New York ditampilkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moex/blog/444300/"><img src="https://habrastorage.org/webt/1l/tg/fk/1ltgfktpjwjmzxxty7fnwez8zh0.jpeg"><br><br>  Halo semuanya!  Nama saya Sergey Kostanbaev, di Bursa saya sedang mengembangkan inti dari sistem perdagangan. <br><br>  Ketika Bursa Efek New York ditampilkan dalam film-film Hollywood, selalu terlihat seperti ini: kerumunan orang meneriakkan sesuatu, melambaikan kertas, ada kekacauan total.  Kami tidak pernah memiliki ini di Bursa Moskow, karena hampir sejak awal, perdagangan dilakukan secara elektronik dan didasarkan pada dua platform utama - Spectra (pasar derivatif) dan ASTS (mata uang, pasar saham dan pasar uang).  Dan hari ini saya ingin berbicara tentang evolusi arsitektur perdagangan ASTS dan sistem kliring, tentang berbagai solusi dan temuan.  Ceritanya akan panjang, jadi saya harus memecahnya menjadi dua bagian. <br><a name="habracut"></a><br>  Kami adalah salah satu dari sedikit pertukaran di dunia yang memperdagangkan aset dari semua kelas dan menyediakan berbagai layanan pertukaran.  Sebagai contoh, tahun lalu kami berada di peringkat kedua di dunia dalam hal perdagangan obligasi, ke-25 di antara semua bursa saham, ke-13 dengan kapitalisasi di antara bursa-bursa publik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cb/cfc/903/4cbcfc90328c075abc687564ad382bd5.png"><br><br>  Untuk penawar profesional, parameter seperti waktu respons, stabilitas distribusi waktu (jitter) dan keandalan seluruh kompleks sangat penting.  Saat ini, kami memproses puluhan juta transaksi per hari.  Pemrosesan setiap transaksi oleh inti sistem membutuhkan puluhan mikrodetik.  Tentu saja, dengan operator seluler di Tahun Baru atau dengan mesin pencari, bebannya sendiri lebih tinggi daripada kita, tetapi dalam hal beban, ditambah dengan karakteristik di atas, hanya sedikit yang bisa dibandingkan dengan kita, seperti yang menurut saya.  Pada saat yang sama, penting bagi kami bahwa sistem tidak melambat sesaat, berfungsi sangat stabil, dan semua pengguna memiliki kedudukan yang sama. <br><br><h2>  Sedikit sejarah </h2><br>  Pada tahun 1994, sistem ASTS Australia diluncurkan di Moscow Interbank Currency Exchange (MICEX), dan mulai saat ini Anda dapat menghitung sejarah perdagangan elektronik Rusia.  Pada tahun 1998, arsitektur pertukaran dimodernisasi untuk pengenalan perdagangan Internet.  Sejak itu, kecepatan memperkenalkan solusi baru dan perubahan arsitektur di semua sistem dan subsistem hanya mendapatkan momentum. <br><br>  Pada tahun-tahun itu, sistem pertukaran bekerja pada perangkat keras hi-end - server HP Superdome 9000 yang sangat andal (dibangun di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur PA-RISC</a> ), yang menggandakan semuanya: subsistem I / O, jaringan, RAM (sebenarnya, ada array RAID dari RAM ), prosesor (hot swapping didukung).  Dimungkinkan untuk mengubah komponen server apa pun tanpa menghentikan mesin.  Kami mengandalkan perangkat ini, menganggapnya hampir bebas masalah.  Sistem operasi adalah HP UX seperti Unix. <br><br>  Tetapi sejak sekitar 2010, sebuah fenomena seperti perdagangan frekuensi tinggi (HFT), atau perdagangan frekuensi tinggi, cukup cantumkan, tukar robot, telah muncul.  Hanya dalam 2,5 tahun, beban di server kami telah meningkat 140 kali. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/251/646/529/25164652921c8d56c1fa5fd9219b7131.png"><br><br>  Untuk menahan beban seperti itu dengan arsitektur dan peralatan lama tidak mungkin.  Itu perlu untuk beradaptasi entah bagaimana. <br><br><h2>  Mulai </h2><br>  Permintaan ke sistem pertukaran dapat dibagi menjadi dua jenis: <br><br><ul><li>  Transaksi  Jika Anda ingin membeli dolar, saham atau sesuatu yang lain, maka kirim transaksi ke sistem perdagangan dan dapatkan respons tentang keberhasilannya. </li><li>  Permintaan informasi.  Jika Anda ingin mengetahui harga saat ini, lihat buku pesanan atau indeks, kemudian kirim permintaan informasi. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/afa/3cb/080/afa3cb0800fc3fd2c4bc83348e00bca2.png"><br><br>  Secara skematis, inti dari sistem dapat dibagi menjadi tiga tingkatan: <br><br><ul><li>  Tingkat klien di mana broker dan klien bekerja.  Semuanya berinteraksi dengan server akses. </li><li>  Server akses (Gateway) adalah server caching yang secara lokal memproses semua permintaan informasi.  Ingin tahu berapa harga saham Sberbank sekarang diperdagangkan?  Permintaan masuk ke server akses. </li><li>  Tetapi jika Anda ingin membeli saham, maka permintaan sudah ada di server pusat (Trade Engine).  Ada satu server seperti itu untuk setiap jenis pasar, mereka memainkan peran penting, dan demi kepentingan itulah kami menciptakan sistem ini. </li></ul><br>  Inti dari sistem perdagangan adalah database dalam-memori yang rumit di mana semua transaksi merupakan transaksi pertukaran.  Basis ditulis dalam C, dari dependensi eksternal hanya ada perpustakaan libc dan sama sekali tidak ada alokasi memori dinamis.  Untuk mengurangi waktu pemrosesan, sistem dimulai dengan serangkaian array statis dan dengan relokasi data statis: pertama, semua data untuk hari ini dimuat ke dalam memori, dan kemudian tidak ada disk mengakses, semua pekerjaan hanya dilakukan dalam memori.  Ketika sistem dimulai, semua data referensi sudah diurutkan, sehingga pencarian bekerja dengan sangat efisien dan membutuhkan sedikit waktu dalam runtime.  Semua tabel dibuat dengan daftar dan pohon intrusif untuk struktur data dinamis sehingga tidak memerlukan alokasi memori saat runtime. <br><br>  Mari kita secara singkat membahas sejarah pengembangan sistem perdagangan dan kliring kami. <br>  Versi pertama arsitektur sistem perdagangan dan kliring dibangun di atas apa yang disebut interaksi Unix: memori bersama, semafor dan antrian digunakan, dan setiap proses terdiri dari satu utas.  Pendekatan ini tersebar luas pada awal 1990-an. <br><br>  Versi pertama dari sistem berisi dua tingkat Gateway dan server pusat dari sistem perdagangan.  Skema kerjanya adalah sebagai berikut: <br><br><ul><li>  Klien mengirim permintaan yang mengenai Gateway.  Dia memeriksa validitas format (tetapi bukan data itu sendiri) dan menolak transaksi yang salah. </li><li>  Jika permintaan informasi telah dikirim, maka itu dieksekusi secara lokal;  jika itu adalah transaksi, maka itu dialihkan ke server pusat. </li><li>  Kemudian mesin perdagangan memproses transaksi, mengubah memori lokal dan mengirimkan respons terhadap transaksi, dan itu sendiri - untuk replikasi menggunakan mekanisme replikasi yang terpisah. </li><li>  Gateway menerima respons dari simpul pusat dan mengalihkannya ke klien. </li><li>  Setelah beberapa saat, Gateway menerima transaksi menggunakan mekanisme replikasi, dan kali ini mengeksekusi secara lokal, mengubah struktur datanya sehingga permintaan informasi berikut menampilkan data aktual. </li></ul><br>  Bahkan, model replikasi dijelaskan di sini, di mana Gateway sepenuhnya mengulangi tindakan yang dilakukan dalam sistem perdagangan.  Saluran replikasi terpisah memberikan urutan eksekusi transaksi yang sama pada beberapa node akses. <br><br>  Karena kode tersebut adalah single-threaded, skema klasik dengan proses bercabang digunakan untuk melayani banyak klien.  Namun, membuat garpu untuk seluruh database sangat mahal, sehingga proses layanan ringan digunakan yang mengumpulkan paket dari sesi TCP dan mentransfernya ke satu antrian (SystemV Message Queue).  Gateway dan Trade Engine hanya bekerja dengan antrian ini, mengambil transaksi untuk dieksekusi dari sana.  Sudah tidak mungkin mengirim jawaban untuk itu, karena tidak jelas proses layanan mana yang harus membacanya.  Jadi kami menggunakan trik: setiap proses bercabang menciptakan antrian respons untuk dirinya sendiri, dan ketika permintaan masuk dalam antrian masuk, tag untuk antrian respons segera ditambahkan ke dalamnya. <br><br>  Menyalin konstan dari antrian ke antrian sejumlah besar data menciptakan masalah, terutama karakteristik permintaan informasi.  Oleh karena itu, kami mengambil keuntungan dari trik lain: selain antrian respons, setiap proses juga membuat memori bersama (SystemV Shared Memory).  Paket-paket itu sendiri ditempatkan di dalamnya, dan hanya tag yang disimpan dalam antrian, memungkinkan Anda menemukan paket sumber.  Ini membantu menyimpan data dalam cache prosesor. <br><br>  SystemV IPC mencakup utilitas untuk melihat status antrian, memori, dan objek semafor.  Kami secara aktif menggunakan ini untuk memahami apa yang terjadi dalam sistem pada saat tertentu, di mana paket terakumulasi, yang diblokir, dll. <br><br><h2>  Modernisasi pertama </h2><br>  Pertama-tama, kami menyingkirkan Gateway proses tunggal.  Kekurangannya yang signifikan adalah dapat memproses satu transaksi replikasi atau satu permintaan informasi dari klien.  Dan dengan meningkatnya beban, Gateway akan memproses permintaan lebih lama dan tidak akan dapat memproses aliran replikasi.  Selain itu, jika klien mengirim transaksi, maka Anda hanya perlu memeriksa validitasnya dan meneruskannya lebih lanjut.  Oleh karena itu, kami mengganti satu proses Gateway dengan banyak komponen yang dapat bekerja secara paralel: informasi multithreaded dan proses transaksional yang bekerja secara independen satu sama lain dengan area memori umum menggunakan RW-lock.  Dan pada saat yang sama kami memperkenalkan proses penjadwalan dan replikasi. <br><br><h2>  Dampak dari perdagangan frekuensi tinggi </h2><br>  Versi arsitektur di atas berlangsung hingga 2010.  Sementara itu, kami tidak lagi puas dengan kinerja server HP Superdome.  Selain itu, arsitektur PA-RISC benar-benar mati, vendor tidak menawarkan pembaruan signifikan.  Sebagai hasilnya, kami mulai beralih dari HP UX / PA RISC ke Linux / x86.  Transisi dimulai dengan adaptasi akses server. <br><br>  Kenapa kita harus mengubah arsitektur lagi?  Faktanya adalah bahwa perdagangan frekuensi tinggi telah secara signifikan mengubah profil beban inti sistem. <br><br>  Misalkan kita memiliki transaksi kecil yang menyebabkan perubahan harga yang signifikan - seseorang membeli setengah miliar dolar.  Setelah beberapa milidetik, semua pelaku pasar memperhatikan hal ini dan mulai memberikan koreksi.  Secara alami, permintaan berbaris dalam antrian besar, yang akan dikerjakan sistem untuk waktu yang lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0b/00e/ac6/d0b00eac6f1d2833db744246d58ce66a.png"><br><br>  Pada interval 50 ms ini, kecepatan rata-rata sekitar 16 ribu transaksi per detik.  Jika Anda mengurangi jendela hingga 20 ms, kami mendapatkan kecepatan rata-rata 90 ribu transaksi per detik, dan pada puncaknya akan ada 200 ribu transaksi.  Dengan kata lain, bebannya tidak stabil, dengan semburan yang tajam.  Dan antrian permintaan harus selalu diproses dengan cepat. <br><br>  Tapi mengapa ada antrian sama sekali?  Jadi, dalam contoh kami, banyak pengguna memperhatikan perubahan harga dan mengirim transaksi yang sesuai.  Mereka datang ke Gateway, ia membuat serial mereka, menetapkan urutan tertentu dan mengirimkannya ke jaringan.  Router mencampur paket dan meneruskannya.  Paket siapa datang lebih awal, transaksi itu "menang".  Akibatnya, pelanggan pertukaran mulai memperhatikan bahwa jika transaksi yang sama dikirim dari beberapa Gateways, maka kemungkinan pemrosesan cepatnya meningkat.  Segera, robot pertukaran mulai membombardir Gateway dengan permintaan, dan longsoran transaksi muncul. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/1f9/429/65b1f9429f7806a1e5e8d5e2c67c3184.png"><br><br><h2>  Babak baru evolusi </h2><br>  Setelah pengujian dan penelitian yang ekstensif, kami beralih ke kernel real-time dari sistem operasi.  Untuk melakukan ini, mereka memilih RedHat Enterprise MRG Linux, di mana MRG adalah singkatan dari kotak pesan real-time.  Keuntungan dari tambalan waktu nyata adalah tambalan itu mengoptimalkan sistem untuk eksekusi tercepat yang mungkin: semua proses diatur dalam antrian FIFO, Anda dapat mengisolasi kernel, tanpa tetes, semua transaksi diproses dalam urutan yang ketat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c1/607/6e8/5c16076e8ed1a40c5e1aea471f5f0f70.png"><br>  <i>Merah - bekerja dengan antrian di kernel reguler, hijau - bekerja di kernel real-time.</i> <br><br>  Tetapi mencapai latensi rendah di server biasa tidak begitu sederhana: <br><br><ul><li>  Mode SMI, yang dalam arsitektur x86 terletak di jantung bekerja dengan periferal penting, sangat mengganggu.  Memproses berbagai peristiwa perangkat keras dan mengelola komponen dan perangkat dilakukan oleh firmware dalam apa yang disebut mode SMI transparan, di mana sistem operasi tidak melihat apa yang dilakukan firmware sama sekali.  Sebagai aturan, semua vendor utama menawarkan ekstensi khusus untuk server firmware, yang memungkinkan pengurangan jumlah pemrosesan SMI. </li><li>  Seharusnya tidak ada kontrol dinamis dari frekuensi prosesor, ini mengarah ke downtime tambahan. </li><li>  Ketika log sistem file diatur ulang, proses-proses tertentu terjadi pada kernel yang menyebabkan penundaan yang tidak terduga. </li><li>  Anda perlu memperhatikan hal-hal seperti Affinity CPU, Interrupt afinity, NUMA. </li></ul><br>  Saya harus mengatakan bahwa topik mengkonfigurasi perangkat keras dan kernel Linux untuk pemrosesan realtime layak mendapat artikel terpisah.  Kami menghabiskan banyak waktu untuk eksperimen dan penelitian sebelum kami mencapai hasil yang baik. <br><br>  Ketika beralih dari server PA-RISC ke x86, kami praktis tidak harus banyak mengubah kode sistem, kami hanya mengadaptasi dan mengkonfigurasi ulang.  Pada saat yang sama, beberapa bug diperbaiki.  Misalnya, konsekuensi dengan cepat muncul bahwa PA RISC adalah sistem Big endian dan x86 sistem Little endian: misalnya, data tidak dibaca dengan benar.  Bug yang lebih rumit adalah bahwa PA RISC menggunakan akses memori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konsisten Sequential</a> , sementara x86 dapat menyusun ulang operasi baca, sehingga kode yang benar-benar valid pada satu platform menjadi tidak beroperasi pada yang lain. <br><br>  Setelah beralih ke x86, produktivitas meningkat hampir tiga kali lipat, waktu pemrosesan transaksi rata-rata turun menjadi 60 μs. <br><br>  Sekarang mari kita melihat lebih dekat perubahan kunci apa yang telah dibuat pada arsitektur sistem. <br><br><h2>  Hot Standby Epic </h2><br>  Beralih ke server komoditas, kami menyadari bahwa mereka kurang dapat diandalkan.  Karena itu, ketika membuat arsitektur baru, kami apriori mengasumsikan kemungkinan kegagalan satu atau lebih node.  Oleh karena itu, kami membutuhkan sistem siaga panas yang dapat beralih dengan sangat cepat ke mesin cadangan. <br><br>  Selain itu, ada persyaratan lain: <br><br><ul><li>  Dalam hal apapun Anda tidak boleh kehilangan transaksi yang diproses. </li><li>  Sistem harus benar-benar transparan untuk infrastruktur kami. </li><li>  Klien seharusnya tidak melihat koneksi terputus. </li><li>  Reservasi tidak boleh menyebabkan penundaan yang signifikan, karena ini merupakan faktor penting untuk pertukaran. </li></ul><br>  Saat membuat sistem siaga panas, kami tidak menganggap skenario seperti itu sebagai kegagalan ganda (misalnya, jaringan pada satu server berhenti bekerja dan server utama macet);  tidak mempertimbangkan kemungkinan kesalahan dalam perangkat lunak, karena mereka terdeteksi selama pengujian;  dan tidak mempertimbangkan tidak berfungsinya besi. <br><br>  Akibatnya, kami sampai pada skema berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad3/4a6/52f/ad34a652fbe11f9023f484e9d64dd19c.png"><br><br><ul><li>  Server utama berinteraksi langsung dengan server Gateway. </li><li>  Semua transaksi yang diterima di server utama langsung direplikasi ke server cadangan melalui saluran terpisah.  Wasit (Gubernur) mengoordinasikan sakelar ketika terjadi masalah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/ca8/118/050ca81185b227e767e3de134d8b2f8e.png"></li><li>  Server utama memproses setiap transaksi dan menunggu konfirmasi dari server cadangan.  Untuk meminimalkan keterlambatan, kami menolak untuk menunggu transaksi diselesaikan di server cadangan.  Karena durasi transaksi melalui jaringan sebanding dengan durasi transaksi, tidak ada penundaan tambahan yang ditambahkan. </li><li>  Kami dapat memverifikasi status pemrosesan server utama dan cadangan hanya untuk transaksi sebelumnya, dan status pemrosesan transaksi saat ini tidak diketahui.  Karena proses single-threaded masih digunakan di sini, menunggu respons dari Cadangan akan memperlambat seluruh aliran pemrosesan, dan karenanya kami membuat kompromi yang masuk akal: kami memeriksa hasil transaksi sebelumnya. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/e3d/34c/9f0/e3d34c9f079015074fa63cf39016d1cf.png"><br><br>  Skema ini bekerja sebagai berikut. <br><br>  Misalkan server utama berhenti merespons, tetapi Gateway terus berkomunikasi.  Di server cadangan, batas waktu dipicu, beralih ke Gubernur, dan yang terakhir menugaskannya peran server utama, dan semua Gateway beralih ke server utama yang baru. <br><br>  Jika server utama kembali beroperasi, batas waktu internal juga dipicu, karena untuk beberapa waktu tidak ada panggilan ke server dari Gateway.  Kemudian dia juga berpaling ke Gubernur, dan dia mengeluarkannya dari skema.  Akibatnya, pertukaran bekerja dengan satu server hingga akhir periode perdagangan.  Karena kemungkinan server crash agak rendah, skema seperti itu dianggap cukup dapat diterima, itu tidak mengandung logika yang kompleks dan mudah diuji. <br><br>  <i><b>Untuk dilanjutkan.</b></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444300/">https://habr.com/ru/post/id444300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444288/index.html">Aplikasi mobile baru LampTest.ru</a></li>
<li><a href="../id444290/index.html">Dasar-dasar pemrograman reaktif menggunakan RxJS. Bagian 2. Operator dan pipa</a></li>
<li><a href="../id444294/index.html">Bagaimana penerbangan bisnis bekerja di Rusia (pusat FBO)</a></li>
<li><a href="../id444296/index.html">6 sumber daya dan layanan yang bermanfaat bagi calon emigran ke AS, Jerman, dan Kanada</a></li>
<li><a href="../id444298/index.html">Para ilmuwan mengatakan mereka dapat mengubah bentuk dinosaurus hidup selama 5 tahun</a></li>
<li><a href="../id444302/index.html">Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 2</a></li>
<li><a href="../id444304/index.html">Huawei dan Nutanix Mengumumkan Kemitraan HCI</a></li>
<li><a href="../id444306/index.html">Seks, cinta, dan hubungan melalui prisma arsitektur layanan mikro</a></li>
<li><a href="../id444308/index.html">Berita Industri Game (11-18 Maret, 2019)</a></li>
<li><a href="../id444312/index.html">Instal ReactOS dari stik USB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>