<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üôåüèª üà≤ Complementos de volumen de almacenamiento de Kubernetes: Flexvolume a CSI üå¨Ô∏è üßù üöô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los d√≠as en que Kubernetes todav√≠a era v1.0.0, exist√≠an complementos de volumen. Fueron necesarios para conectarse a los sistemas Kubernetes para a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Complementos de volumen de almacenamiento de Kubernetes: Flexvolume a CSI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/465417/"><img src="https://habrastorage.org/webt/sj/ie/we/sjieweu7inrj2_yn3mxvtxe8vrw.png"><br><br>  En los d√≠as en que Kubernetes todav√≠a era v1.0.0, exist√≠an complementos de volumen.  Fueron necesarios para conectarse a los sistemas Kubernetes para almacenar datos de contenedor persistentes (permanentes).  Su n√∫mero era peque√±o, y entre los primeros hab√≠a proveedores de almacenamiento como GCE PD, Ceph, AWS EBS y otros. <br><br>  Los complementos se entregaron junto con Kubernetes, por lo que obtuvieron su nombre: en el √°rbol.  Sin embargo, muchos de los conjuntos existentes de tales complementos no eran suficientes.  Los artesanos agregaron complementos simples al n√∫cleo de Kubernetes utilizando parches, despu√©s de lo cual construyeron sus propios Kubernetes y los pusieron en sus servidores.  Pero con el tiempo, los desarrolladores de Kubernetes se dieron cuenta de que el <i>pescado</i> no pod√≠a resolverse.  La gente necesita una <i>ca√±a de pescar</i> .  Y en el lanzamiento de Kubernetes v1.2.0, apareci√≥ ... <a name="habracut"></a><br><br><h2>  Complemento Flexvolume: ca√±a de pescar m√≠nima </h2><br>  Los desarrolladores de Kubernetes crearon el complemento FlexVolume, que era un enlace l√≥gico de variables y m√©todos para trabajar con controladores Flexvolume de terceros. <br><br>  Deteng√°monos y echemos un vistazo m√°s de cerca a lo que es el controlador FlexVolume.  Este es un cierto <b>archivo ejecutable</b> ( <b>archivo</b> binario, secuencia de comandos Python, secuencia de comandos Bash, etc.) que, cuando se ejecuta, toma argumentos de l√≠nea de comando y devuelve un mensaje con campos previamente conocidos en formato JSON.  Por convenci√≥n, el primer argumento de la l√≠nea de comando es siempre el m√©todo, y el resto de los argumentos son sus par√°metros. <br><br><img src="https://habrastorage.org/webt/ed/rp/2_/edrp2_n7i75s5meu4bgj5wmiydm.png"><br>  <i>Esquema de conexi√≥n de CIFS Shares en OpenShift.</i>  <i>Controlador Flexvolume - Justo en el centro</i> <br><br>  <b>El conjunto m√≠nimo de m√©todos se</b> ve as√≠: <br><br><pre><code class="cs hljs">flexvolume_driver mount <span class="hljs-meta"><span class="hljs-meta">#      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver unmount #      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver init #     #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", // ,     attach/deatach "capabilities":{"attach": True/False} }</span></span></code> </pre> <br>  El uso de los m√©todos de conexi√≥n y desconexi√≥n determinar√° el escenario seg√∫n el cual en el futuro actuar√° Kubelet cuando se llame al controlador.  Tambi√©n hay <code>expandfs</code> especiales <code>expandvolume</code> y <code>expandfs</code> que son responsables de cambiar el tama√±o din√°micamente de un volumen. <br><br>  Como ejemplo de los cambios que <code>expandvolume</code> m√©todo <code>expandvolume</code> , y con la capacidad de cambiar el tama√±o del volumen en tiempo real, puede consultar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestra solicitud de extracci√≥n</a> en el Rook Ceph Operator. <br><br>  Aqu√≠ hay un ejemplo de implementaci√≥n del controlador Flexvolume para trabajar con NFS: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span></span>() { err <span class="hljs-string"><span class="hljs-string">"Invalid usage. Usage: "</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> init"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> mount &lt;mount dir&gt; &lt;json params&gt;"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> unmount &lt;mount dir&gt;"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* 1&gt;&amp;2 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* &gt;&amp;1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ismounted</span></span></span></span>() { MOUNT=`findmnt -n <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> 2&gt;/dev/null | cut -d<span class="hljs-string"><span class="hljs-string">' '</span></span> -f1` <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MOUNT}</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">domount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> NFS_SERVER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.server'</span></span>) SHARE=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.share'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 1 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> mkdir -p <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null mount -t nfs <span class="hljs-variable"><span class="hljs-variable">${NFS_SERVER}</span></span>:/<span class="hljs-variable"><span class="hljs-variable">${SHARE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failure\", \"message\": \"Failed to mount </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${NFS_SERVER}</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${SHARE}</span></span></span><span class="hljs-string"> at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 0 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> umount <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } op=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"init"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success", "capabilities": {"attach": false}}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$#</span></span> -lt 2 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> usage <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mount) domount $* ;; unmount) unmount $* ;; *) <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Not supported"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1</code> </pre> <br>  Entonces, despu√©s de preparar el archivo ejecutable real, debe <b>dise√±ar el controlador en el cl√∫ster de Kubernetes</b> .  El controlador debe estar ubicado en cada nodo del cl√∫ster de acuerdo con una ruta predefinida.  Por defecto fue seleccionado: <br><br> <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/__~_/</code> <br> <br>  ... pero usando diferentes distribuciones de Kubernetes (OpenShift, Rancher ...) la ruta puede ser diferente. <br><br><h2>  Problemas de flexvolumen: ¬øc√≥mo lanzar una ca√±a de pescar? </h2><br>  Poner el controlador Flexvolume en los nodos del cl√∫ster result√≥ ser una tarea no trivial.  Una vez realizada la operaci√≥n manualmente, es f√°cil encontrar una situaci√≥n en la que aparecen nuevos nodos en el cl√∫ster: debido a la adici√≥n de un nuevo nodo, escala horizontal autom√°tica o, peor a√∫n, al reemplazo del nodo debido a un mal funcionamiento.  En este caso, es <b>imposible</b> trabajar con el almacenamiento en estos nodos hasta que agregue manualmente el controlador Flexvolume de la misma manera. <br><br>  La soluci√≥n a este problema fue una de las primitivas de Kubernetes: <code>DaemonSet</code> .  Cuando aparece un nuevo nodo en el cl√∫ster, obtiene autom√°ticamente un pod de nuestro DaemonSet, al que se adjunta un volumen local en el camino para encontrar controladores Flexvolume.  Tras la creaci√≥n exitosa, el pod copia los archivos necesarios para que el controlador funcione en el disco. <br><br>  Aqu√≠ hay un ejemplo de tal DaemonSet para dise√±ar el complemento Flexvolume: <br><br><pre> <code class="1c hljs">apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: flex-set spec: template: metadata: name: flex-deploy labels: app: flex-deploy spec: containers: - image: &lt;deployment_image&gt; name: flex-deploy securityContext: privileged: true volumeMounts: - mountPath: /flexmnt name: flexvolume-mount volumes: - name: flexvolume-mount hostPath: path: &lt;host_driver_directory&gt;</code> </pre> <br>  ... y un ejemplo de un script Bash para dise√±ar un controlador Flexvolume: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -o errexit set -o pipefail VENDOR=k8s.io DRIVER=nfs driver_dir=$VENDOR${VENDOR:+"~"}${DRIVER} if [ ! -d "/flexmnt/$driver_dir" ]; then mkdir "/flexmnt/$driver_dir" fi cp "/$DRIVER" "/flexmnt/$driver_dir/.$DRIVER" mv -f "/flexmnt/$driver_dir/.$DRIVER" "/flexmnt/$driver_dir/$DRIVER" while : ; do sleep 3600 done</span></span></code> </pre> <br>  Es importante no olvidar que la operaci√≥n de copia <b>no</b> es <b>at√≥mica</b> .  Es muy probable que Kubelet comience a usar el controlador antes de que se complete el proceso de preparaci√≥n, lo que provocar√° un error en el sistema.  El enfoque correcto ser√≠a copiar primero los archivos del controlador con un nombre diferente y luego usar la operaci√≥n de cambio de nombre at√≥mico. <br><br><img src="https://habrastorage.org/webt/3k/zv/vd/3kzvvdbejy8mi47vpezfpjnqlus.png"><br>  <i>Esquema de trabajo con Ceph en la declaraci√≥n Rook: el controlador Flexvolume en el diagrama est√° dentro del agente Rook</i> <br><br>  El siguiente problema cuando se utilizan controladores Flexvolume es que para la mayor√≠a de los almacenamientos <b>, el software necesario para esto debe instalarse</b> en el nodo del cl√∫ster (por ejemplo, el paquete ceph-common para Ceph).  Inicialmente, el complemento Flexvolume no fue dise√±ado para implementar sistemas tan complejos. <br><br>  Se puede ver una soluci√≥n original a este problema en la implementaci√≥n del controlador Flexvolume del operador Rook: <br><br>  El controlador en s√≠ est√° dise√±ado como un cliente RPC.  El socket IPC para la comunicaci√≥n se encuentra en el mismo directorio que el controlador mismo.  Recordamos que para copiar archivos de controlador ser√≠a bueno usar DaemonSet, que conecta un directorio con el controlador como un volumen.  Despu√©s de copiar los archivos necesarios del controlador de torre, este pod no muere, sino que se conecta al z√≥calo IPC a trav√©s del volumen adjunto como un servidor RPC completo.  El paquete ceph-common ya est√° instalado dentro del contenedor del m√≥dulo.  El socket IPC conf√≠a en que kubelet se comunicar√° con el pod particular ubicado en el mismo nodo.  ¬°Todo lo ingenioso es simple! .. <br><br><h2>  ¬°Adi√≥s, nuestros afectuosos ... complementos en el √°rbol! </h2><br>  Los desarrolladores de Kubernetes han descubierto que la cantidad de complementos de almacenamiento dentro del n√∫cleo es veinte.  Y el cambio en cada uno de ellos de alguna manera pasa por el ciclo completo de lanzamiento de Kubernetes. <br><br>  Resulta que para usar la nueva versi√≥n del complemento para el almacenamiento, <b>debe actualizar todo el cl√∫ster</b> .  Adem√°s de esto, puede sorprenderse de que la nueva versi√≥n de Kubernetes de repente se vuelva incompatible con el kernel de Linux utilizado ... Y, por lo tanto, limpie las l√°grimas y apriete los dientes y coordine con las autoridades y los usuarios el tiempo para actualizar el kernel de Linux y el cl√∫ster de Kubernetes.  Con posible tiempo de inactividad en la prestaci√≥n de servicios. <br><br>  La situaci√≥n es m√°s que c√≥mica, ¬øno?  Se hizo evidente para toda la comunidad que el enfoque no funcion√≥.  Con una decisi√≥n decidida, los desarrolladores de Kubernetes anuncian que ya no se aceptar√°n nuevos complementos de almacenamiento en el n√∫cleo.  Para todo lo dem√°s, como ya sabemos, en la implementaci√≥n del complemento Flexvolume se revelaron una serie de deficiencias ... <br><br>  De una vez por todas, se convoc√≥ al √∫ltimo complemento agregado para vol√∫menes en Kubernetes, CSI, para cerrar el problema con los almacenes de datos persistentes.  Su versi√≥n alfa, m√°s com√∫nmente conocida como Complementos de volumen CSI fuera del √°rbol, se anunci√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.9</a> . <br><br><h2>  Interfaz de almacenamiento de contenedores, o CSI 3000 girando! </h2><br>  En primer lugar, me gustar√≠a se√±alar que CSI no es solo un complemento de volumen, sino un <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°ndar</a></b> real <b>para crear componentes personalizados para trabajar con almacenes de datos</b> .  Se supuso que los sistemas de orquestaci√≥n de contenedores, como Kubernetes y Mesos, deber√≠an "aprender" c√≥mo trabajar con componentes implementados de acuerdo con este est√°ndar.  Y ahora Kubernetes ya ha aprendido. <br><br>  ¬øCu√°l es el dispositivo del complemento CSI en Kubernetes?  El complemento CSI funciona con controladores especiales ( <b>controladores CSI</b> ) escritos por desarrolladores externos.  El controlador CSI en Kubernetes debe constar al menos de dos componentes (pods): <br><br><ul><li>  <b>Controlador</b> : administra el almacenamiento externo persistente.  Se implementa como un servidor gRPC para el que se usa la primitiva <code>StatefulSet</code> . </li><li>  <b>Nodo</b> : es responsable de montar almacenes persistentes en los nodos del cl√∫ster.  Tambi√©n se implementa como un servidor gRPC, pero se <code>DaemonSet</code> primitiva <code>DaemonSet</code> para ello. </li></ul><br><img src="https://habrastorage.org/webt/4h/vs/af/4hvsafmhi2tmja8fvc_qtzkqtfc.png"><br>  <i>Kubernetes CSI Plugin Workflow</i> <br><br>  Puede obtener informaci√≥n sobre otros detalles de CSI, por ejemplo, del art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender el CSI</a> ", una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n que</a> publicamos hace un a√±o. <br><br><h3>  Las ventajas de tal implementaci√≥n </h3><br><ul><li>  Para cosas b√°sicas, por ejemplo, para registrar un controlador para un nodo, los desarrolladores de Kubernetes han implementado un conjunto de contenedores.  Ya no necesita crear una respuesta JSON con capacidades, como se hizo para el complemento Flexvolume. </li><li>  En lugar de "deslizar" los nodos de los archivos ejecutables, ahora colocamos pods en el cl√∫ster.  Esto es lo que originalmente esper√°bamos de Kubernetes: todos los procesos ocurren dentro de contenedores desplegados usando primitivas de Kubernetes. </li><li>  Para implementar controladores complejos, ya no necesita desarrollar un servidor RPC y un cliente RPC.  El cliente para nosotros fue implementado por los desarrolladores de Kubernetes. </li><li>  Pasar argumentos para trabajar con el protocolo gRPC es mucho m√°s conveniente, flexible y m√°s confiable que pasarlos a trav√©s de argumentos de l√≠nea de comandos.  Para comprender c√≥mo agregar soporte para las m√©tricas de uso de volumen a CSI agregando un m√©todo gRPC estandarizado, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestra solicitud de extracci√≥n</a> para el controlador vsphere-csi. </li><li>  La comunicaci√≥n se realiza a trav√©s de sockets IPC para no confundirse si el pod Kubelet envi√≥ o no una solicitud. </li></ul><br>  ¬øEsta lista te recuerda algo?  Las ventajas de CSI son la <b>soluci√≥n a los problemas</b> que no se tuvieron en cuenta al desarrollar el complemento Flexvolume. <br><br><h2>  Conclusiones </h2><br>  CSI como est√°ndar para implementar complementos personalizados para interactuar con los almacenes de datos ha sido muy aceptado por la comunidad.  Adem√°s, debido a sus ventajas y versatilidad, los controladores CSI se crean incluso para repositorios como Ceph o AWS EBS, complementos para trabajar que se agregaron en la primera versi√≥n de Kubernetes. <br><br>  A principios de 2019, los complementos en √°rbol <a href="">quedaron en desuso</a> .  Se planea continuar admitiendo el complemento Flexvolume, pero no habr√° desarrollo de nuevas funcionalidades para √©l. <br><br>  ¬°Nosotros mismos ya tenemos experiencia en el uso de ceph-csi, vsphere-csi y estamos listos para agregar a esta lista!  Hasta ahora, CSI hace frente a las tareas que se le asignaron con una explosi√≥n, y all√≠ esperamos y vemos. <br><br>  ¬°No olvides que todo lo nuevo es bien pensado! <br><br><h2>  PS </h2><br>  Lea tambi√©n en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entendemos la interfaz de almacenamiento de contenedores (en Kubernetes y no solo)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rook o no Rook, esa es la pregunta</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conociendo la versi√≥n alfa de las instant√°neas de volumen en Kubernetes</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465417/">https://habr.com/ru/post/465417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465401/index.html">5 actividades para acelerar la resoluci√≥n de problemas en cualquier equipo de TI</a></li>
<li><a href="../465403/index.html">Achtung! Nuevas c√°maras en el camino o informaci√≥n actualizada sobre radares y detectores de radar</a></li>
<li><a href="../465407/index.html">1. Descripci√≥n general de los conmutadores Extreme Enterprise Layer</a></li>
<li><a href="../465409/index.html">Vue.js Mejores pr√°cticas para desarrollo web</a></li>
<li><a href="../465415/index.html">Hablamos de DevOps en un lenguaje comprensible.</a></li>
<li><a href="../465419/index.html">Ma√±ana en la Universidad ITMO: el proceso educativo, las competiciones y la educaci√≥n en el extranjero: una selecci√≥n de los pr√≥ximos eventos</a></li>
<li><a href="../465423/index.html">Fabricaci√≥n inteligente e industria 4.0: tres tendencias tecnol√≥gicas principales</a></li>
<li><a href="../465425/index.html">Vepp: el nuevo servidor de ISPsystem y el panel de control del sitio web</a></li>
<li><a href="../465427/index.html">An√°lisis del marco Apache Dubbo RPC por el analizador de c√≥digo est√°tico PVS-Studio</a></li>
<li><a href="../465429/index.html">Sin embargo, C es un lenguaje de bajo nivel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>