<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏿 🙎🏿 🏇 snap & flatpack - tragedia de comunidades 🚬 ▶️ 🕺🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Advertencia de Longrid: Has sido advertido, muchas cartas. 


 Durante mucho tiempo ha estado desarrollando un formato de distribución para aplicacion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>snap & flatpack - tragedia de comunidades</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433052/"><p>  <em>Advertencia de Longrid: Has sido advertido, muchas cartas.</em> </p><br><p>  Durante mucho tiempo ha estado desarrollando un formato de distribución para aplicaciones que estaban "libres" de dependencias de todo el sistema.  Ubuntu es muy, muy activo en la promoción de su complemento, gnome - flatpack.  Ambos prometen paraíso y libertad de rpm / deb.  Pensemos en el problema que quieren resolver y el precio que solicitan para solucionarlo. </p><a name="habracut"></a><br><h1 id="biblioteki">  Bibliotecas </h1><br><p>  Nadie en el mundo moderno puede escribir una aplicación sin usar el código de otra persona.  Hay varias razones: </p><br><ul><li>  Muchas bibliotecas son tan serias que escribir su funcionalidad desde cero es una tarea desalentadora.  Ejemplos: soporte para unicode, renderizado de fuentes, matemática. </li><li>  Otras bibliotecas ofrecen un conjunto de funciones bastante modesto, pero están tan bien escritas que escribir al menos tan bien es casi imposible.  Bibliotecas estándar de lenguajes de programación, diversas implementaciones de libc, etc. </li><li> El costo de trabajar con el código de otra persona (al que se dedica esta sección) a menudo es más bajo que el costo de mantener su código.  Es probable que la densidad de "errores por línea de código" sea comparable, y usted debe detectar sus propios errores.  Es probable que las bibliotecas extranjeras (populares) sean depuradas y corregidas por las manos equivocadas. </li></ul><br><p>  La clave es que incluso si podemos escribir la funcionalidad de una sola biblioteca desde el principio, el número total de funciones necesarias (y dependencias) da un aumento casi exponencial en el número de tareas que deben resolverse, posponiendo el tiempo de inicio del trabajo en el código del programa en sí. en la distancia inalcanzable. </p><br><p>  Un ejemplo para darse cuenta de la escala del drama: digamos que su aplicación toma dos líneas de entrada como argumentos opcionales y las muestra juntas después de la normalización.  Si está escribiendo una aplicación industrial (una aplicación que se parece a una "real"), entonces: </p><br><ul><li>  Necesita un analizador de línea de comando </li><li>  Que debe aceptar unicode </li><li>  Y quizás le dé al usuario una pista de que ha sellado el nombre del argumento </li><li>  Lo que requiere comparación fonética </li><li>  Y tal vez expresiones regulares </li><li>  En general, tendrá que admitir no solo Unicode sino también otros entornos locales, lo que requiere una biblioteca de soporte de entorno local y <em>TODO lo</em> que la gente crea en el contexto de entornos locales. </li><li>  La concatenación de cadenas con la normalización es otro uso de una biblioteca Unicode separada; usted mismo no implementa esto. </li><li>  Es probable que la visualización en la pantalla (ayuda de la línea de comandos, su resultado) requiera soporte para ncurses, una biblioteca que admite diferentes terminales (puede hacerlo con el modo de texto, pero las aplicaciones a menudo usan capacidades de color). </li><li>  Las pruebas implican el uso de un marco de prueba, posiblemente una biblioteca para moks. </li></ul><br><p>  Está claro que tal complejidad para la tarea de "dos líneas" es una ingeniería excesiva, pero tan pronto como comienzas a hacer algo más, la idea de "todo por ti mismo" comienza a ir más allá de los límites de lo observable y lo realizado. </p><br><p>  ¿Cuántas bibliotecas cree que son necesarias para garantizar que curl http (s): // ... funcione?  Mucho  Utilizará uno, pero las dependencias de sus dependencias son sus dependencias. </p><br><h1 id="copypaste--vendoring-vs-dynamic-linking">  Copiar y vender VS enlace dinámico </h1><br><p>  Si bien el uso de bibliotecas es inevitable, el uso en sí mismo puede variar en la implementación.  Tenga en cuenta que tenemos dos palabras importantes: "uso" e "implementación de uso".  ¿Qué significa el uso?  En su forma más grosera: la capacidad de llamar al código de la biblioteca cuando sea necesario.  Y aquí están las implementaciones de esto: </p><br><ul><li>  Podemos copiar el código que realiza las operaciones que necesitamos.  En forma de código (copiar y pegar), como un módulo separado en un lenguaje de programación (archivo de objeto para lenguajes compilados), o como un módulo separado (para lenguajes interpretados).  En algún lugar justo al lado está "copie el archivo fuente de la biblioteca a su directorio con la aplicación".  ¿Qué problemas crea esto?  El principal problema principal es que perdemos (para siempre) la conexión con el original.  Incluso si el autor de la biblioteca original corrige el error, no lo sabremos.  Además, si solo copiamos el código, la siguiente persona que trabaje en el programa ni siquiera podrá descubrir que este código es "ajeno".  De hecho, cortamos el camino en la pregunta "escribir desde cero" y tomamos el de otra persona.  Sin embargo, cortamos solo una parte, porque si hay errores en este código (pero no <em>estarán allí</em> , están <em>allí</em> ), entonces su corrección requerirá que el corrector vaya y comprenda la esencia del problema hasta el fondo.  Incluso si la prueba requiere leer varios cientos de miles de líneas de código fuente y cientos de RFC (así como comentarios de que las implementaciones son diferentes a las RFC), no tenemos otra manera.  El error clave en este lugar es que hemos perdido información de que este código es extraño.  Tener comentarios en un archivo puede ayudar, pero requiere la participación activa y profunda de una persona, porque si escribimos en un comentario "tomado de libfoobar, src / lib / foo.c versión 364a51577f3782dbf8e5d2482ab941980357c492", entonces alguien tendrá que ver dónde se encuentra libfoobar, qué versión es y qué ha cambiado desde la versión anterior ". Para simplificar este proceso, necesitamos metainformación legible por máquina. </li><li>  Si acompañamos el "código de otra persona" con metainformación y usamos programas para administrar este código (en lugar de copiar y pegar), esto se llama <em>venta</em> , es decir  inclusión controlada del código de otra persona en su código.  Técnicamente, la venta puede ocurrir en la etapa del texto fuente, vinculando objetos a un archivo ejecutable, importando módulos (en intérpretes) desde la aplicación, o incluso vinculando dinámicamente con "su" versión de la biblioteca (más sobre esto más adelante). </li><li>  Finalmente, podemos realizar enlaces dinámicos en la etapa de inicio de la aplicación.  Para los idiomas compilados, estos son so'hks comunes; para los idiomas interpretados, hay un módulo en la importación de todo el sistema.  Si varias aplicaciones pueden importarlo, entonces esta es una biblioteca compartida.  Si la aplicación "trajo su módulo", entonces la biblioteca es "propia", incluso si su interfaz implica una "biblioteca compartida".  Por ejemplo, si una aplicación utiliza su "propia" versión de la misma, independientemente de si difiere de la general o no, entonces esto es vending.  Y si el sistema se importa, entonces esta es una biblioteca compartida. </li></ul><br><p>  ¿Cuál es la diferencia entre estos métodos?  Daré breves argumentos; se han discutido muchas veces en muchos artículos.  Cada uno de estos argumentos sigue siendo válido a pesar de la presencia de contraargumentos vecinos: </p><br><ul><li>  Ahorro de memoria (RAM y disco) para so'sh, reduciendo el tamaño del sistema instalado.  Cuantas más aplicaciones usen lo mismo, mayor será el ahorro de memoria.  En consecuencia, por el contrario, cuanto más "sus" bibliotecas trae una aplicación, más "gorda" es. </li><li>  El debate sobre quién monitorea las vulnerabilidades es el sistema (que proporciona actualizaciones de la biblioteca) o el autor de la aplicación (que la actualiza a tiempo). </li><li>  Resolución de conflictos de dependencias (la venta resuelve este problema ya que las bibliotecas compartidas requieren atención y precisión de todos los participantes en el proceso, a veces creando dificultades insuperables), el mismo infierno legendario. </li><li>  Nuevas versiones de las bibliotecas: aparecen a pedido de los autores de la aplicación o por decisión de los autores de la distribución.  En un caso, el autor puede aportar la nueva característica que necesita, en otro caso, la distribución puede aportar una mejora a la aplicación existente al admitir algo nuevo en la biblioteca (por ejemplo, las pantallas hidpi comenzaron a funcionar correctamente en todas las aplicaciones vinculadas dinámicamente a bibliotecas qt / gtk) . </li></ul><br><p>  Todos estos problemas se han tratado muchas veces antes.  En cambio, quiero centrarme en los aspectos sociales de la cuenca hidrográfica "todo mío" y "todo común". </p><br><h1 id="socialnyy-kontrakt-i-vlast-meynteynerov">  Contrato social y mantenedores de poder </h1><br><p>  Las bibliotecas compartidas son cooperación, poder y responsabilidad.  Las personas que determinan qué bibliotecas compartidas están disponibles en el sistema operativo dictan a los fabricantes de software qué bibliotecas compartidas pueden usar.  Una gran cantidad de software puede usar diferentes bibliotecas, y la indicación de qué versión exacta usar se deja a discreción del vinculador (para los idiomas compilados) o el controlador de archivos de dependencia (pip, bundler, etc.).  Si todas las aplicaciones en la distribución se crean con los mismos requisitos, entonces aparece la gracia: si hay un error en alguna biblioteca, el responsable de esta biblioteca actualiza la versión y la corrección se aplica automáticamente a todas las aplicaciones.  Incluso si la aplicación se lanza cada dos años, la corrección en el openssl condicional se aplicará dentro de una semana.  Si en un sistema operativo particular se toma la decisión de abandonar el protocolo anterior, algunas modificaciones (por ejemplo, la interfaz de usuario), estos cambios también se aplicarán a todos.  Look &amp; feel en un estilo general que (quizás) puede ser cambiado por el usuario de una vez por todas.  ¿No es esto gracia? </p><br><h2 id="vlast-i-borba-za-neyo">  El poder y la lucha por él. </h2><br><p>  ... Esta gracia requiere que todas las aplicaciones puedan funcionar con la versión seleccionada de la biblioteca.  Pero, ¿qué pasa si alguna aplicación quiere una función muy, muy nueva de la biblioteca, y todas las demás aplicaciones no quieren usarla, porque esto, por ejemplo, no es una versión LTS de la biblioteca, es decir?  ¿No es lo suficientemente estable?  Pero el kit de distribución puede negarse a cambiar a nuevas versiones "por principio", porque les prometimos a los usuarios solo correcciones de errores, y nuevas versiones solo en la próxima versión del sistema operativo, que (como) se lanzará en medio año.  Y esto provoca resistencia por parte de los autores de la aplicación.  ¿Quién eres para decirme con qué versiones debo trabajar?  Soy autor, lo veo así.  Necesito libfoobar 3.14-pre2 o anterior, no tu antiguo libfoobar aburrido 3.10. </p><br><p> ... En este punto, el autor simplemente escribe en los requisitos de la aplicación <code>libfoobar&gt;=3.14-pre2</code> .  El mantenedor toma y aplica parches a la solicitud, además de eliminar el código que dependía de esta biblioteca.  Tal vez  O simplemente se niega a aceptar una nueva versión con dicha dependencia hasta que esta dependencia (libfoobar 3.16) esté en la nueva versión de la distribución. </p><br><p>  Si el autor realmente necesita que los usuarios usen la nueva versión (por ejemplo, porque el autor no quiere admitir la versión anterior), entonces busca soluciones alternativas para enviar la aplicación al usuario. </p><br><p>  Lo mismo sucede cuando hay varias distribuciones, algunas más nuevas, otras más antiguas.  Mantener distribuciones antiguas, probar con diferentes bibliotecas es difícil.  Entonces, la opción "enviar con sus bibliotecas" aparece casi de inmediato. </p><br><h1 id="tragediya-obschin">  Tragedia comunitaria </h1><br><p>  Esto crea los requisitos previos para el surgimiento de una tragedia comunitaria: </p><br><ul><li>  Cada fabricante (autor del software) quiere enviar lo que necesita.  Adaptarse a las reglas (versiones) de otras personas es una pérdida de tiempo y esfuerzo, sobre todo porque hay muchas distribuciones diferentes en el mundo </li><li>  Los usuarios quieren nuevas versiones. </li></ul><br><p>  Al mismo tiempo, cuantas más aplicaciones vengan con sus bibliotecas, menor será el uso de las bibliotecas del sistema.  ¿Te acuerdas de Grace?  Cuanto menos es "universal", menos es gracia.  Si 5 bibliotecas diferentes usan una biblioteca compartida de otras 995, entonces el beneficio de esta biblioteca es 0.5%.  Es una pena, sí.  Además, perjudica a todos los usuarios, incluso a aquellos que, en principio, no tienen una gran necesidad de una nueva función, pero si la aplicación solo está disponible en forma expendedora, el usuario no tiene opciones. </p><br><p>  Resulta que tenemos un extremo global: todas las aplicaciones usan solo bibliotecas compartidas (máxima gracia común, inconvenientes para los autores de aplicaciones individuales) o "cada una por sí misma" (una distribución gruesa con un montón de aplicaciones que pueden tener vulnerabilidades no detectadas pero ampliamente utilizadas, comiendo un montón de memoria, pero el autor de cada aplicación es conveniente). </p><br><p>  Aquí es donde llegamos a la disputa rpm / deb VS snap / flatpack </p><br><h1 id="svoboda-ili-rabstvo">  ¿Libertad o esclavitud? </h1><br><p>  Ubuntu aboga muy, muy fuertemente por Snap'y.  GNOME confía en que el futuro está en los paquetes planos.  Cada uno de ellos es un marco para aplicaciones profundamente individualistas.  Todo tipo de electrones, que llevan consigo no solo el capó del compartimento del motor, sino también el sistema operativo del compartimento del motor.  Propia libc, propia libssl, propia regexp, propia ncurses, etc.  Solo el núcleo actúa como común, es decir  de hecho, esta es la misma aplicación en contenedor, pero para el escritorio.  Dé a cada uno su propio núcleo y obtendrá un dispositivo en forma de máquina virtual.  Agregue los metadatos y obtendrá un contenedor Docker. </p><br><p>  El individualismo de las aplicaciones (autores de la aplicación) es comprensible, pero ¿quién representa el bien común?  Una mejora local importante se compensa con una ligera degradación general de la distribución multiplicada por aplicaciones puramente.  Si todos hacen mejoras locales por sí mismos, la cantidad de discapacidad se vuelve mayor que el beneficio de la cantidad de mejora. </p><br><p>  Parecería que en este lugar los creadores de distribuciones deberían actuar como custodios de interés común.  Sin embargo ... </p><br><h1 id="politika">  Política </h1><br><p>  Ubuntu depende de Debian mucho más de lo que Canonical (la compañía Ubuntu) quisiera.  El valor de Ubuntu no está en los esfuerzos de los mantenedores de Ubuntu, sino en un enorme repositorio de software proveniente de Debian en una forma en que todas las aplicaciones funcionan bien juntas a través de los esfuerzos de miles de mantenedores de los paquetes individuales que poseen la distribución de Debian.  Además, Canonical agrega sus esfuerzos para pulir el resultado, y por eso algunos lo aman.  Agregue un poco de marketing y un ciclo de vida fijo, que es del agrado de la empresa, y obtenemos un excelente producto. </p><br><p>  ... Lo que depende de la voluntad de miles de voluntarios en algún lugar. </p><br><p>  Lo que no se adapta a casi ninguna empresa comercial.  ¿Cómo romper esta adicción?  Eso es correcto al hacer su propio paquete de aplicaciones.  Cuantas más aplicaciones haya, menos ventajas tendrá en la empresa.  Baste recordar la historia cuando un voto en Debian en systemd enterró al advenedizo, desarrollado por Canonical. </p><br><p>  Pero mantenga varias decenas de miles de aplicaciones, algunas de las cuales son su propio espacio (erlang, go, perl, python, R, julia, etc.), y algunas son monstruos en el área temática correspondiente (navegadores, emacs, tex, marcapasos, etc.). trabajo pesado  No es de extrañar que estos sean <em>miles de</em> mantenedores. </p><br><p>  ... Y hay una idea.  Y, dejemos, los autores de la aplicación mantienen las aplicaciones.  Démosles a todos una caja de arena, déjenlos cavar.  Los autores obtienen libertad, Canonical: aplicaciones que no dependen de Debian y que al menos alguien mantiene de forma gratuita.  Los usuarios obtienen ... </p><br><p>  ... aplicaciones que son gordas, pesadas, con actualizaciones irregulares y que pueden mantener fácilmente las vulnerabilidades sin corregir durante años ... Pero algunas de ellas son nuevas y brillantes. </p><br><h1 id="i-chto-dalshe">  Entonces, ¿qué sigue? </h1><br><p>  Imagina un mundo en el que todos llevan todo consigo ... ¿Sabes cómo se ve?  Echa un vistazo a chefsdk.  Se envía consigo mismo dentro de su postgresql (con sus dependencias), su rabbitmq (que depende de su erlang), además el chef-servidor también está en erlang, por lo que también tiene su propio erlang.  De repente, tenemos dos erlangs y docenas de copias de las mismas bibliotecas dentro de la misma aplicación, ligeramente diferentes en la versión.  Esta no es la opción final, ya que  adentro, todavía hay bibliotecas comunes entre los componentes.  Si los cortamos más, obtenemos varias docenas de copias de openssl y libc para una aplicación.  Ni siquiera en su forma final, parece 600MB por aplicación. </p><br><p>  ... Que, por supuesto, es mucho más grande que la aplicación electrónica promedio ... Y 12 veces más que todo el servidor mariadb (¡todo el DBMS!), O krita o gimp (grandes aplicaciones de gráficos). </p><br><p>  ¿Y si todos serán así?  Tengo 2000 paquetes instalados en mi computadora (sin contar -dev y lib) ... 2000 * 300 = 600GB (Para el tamaño promedio del resultado, tomé la mitad de chefsdk, porque no todos son tan terribles por dependencias).  Ahora ocupan alrededor de 7 GB (incluidos recursos, como documentación, editores de texturas, plantillas CAD, etc.). </p><br><p>  Si esto se convierte en 600 GB, ¿no es eso una pura tragedia de las comunidades?  En cada momento, observamos la optimización local (y la solución de los inconvenientes de otra persona), pero en conjunto, la suma de estas optimizaciones locales reduce la optimización general del sistema.  En mi opinión, más que la ganancia local de cada uno de los participantes. </p><br><p>  Entiendo por qué Canonical empuja a presión.  Entiendo esto y no lo apruebo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433052/">https://habr.com/ru/post/es433052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433042/index.html">Intel lanzará el procesador con arquitectura tridimensional Foveros en 2019</a></li>
<li><a href="../es433044/index.html">El código fuente de OpenJDK contiene demasiadas palabras malas</a></li>
<li><a href="../es433046/index.html">Toda la verdad sobre RTOS. Artículo # 25. Canales de datos: introducción y servicios básicos</a></li>
<li><a href="../es433048/index.html">Cómo 2019 cambiará las tiendas rusas</a></li>
<li><a href="../es433050/index.html">De un diseñador de aviones a un programador en un año, o cómo convertirse en un Jedi</a></li>
<li><a href="../es433054/index.html">Una aguja en una pila de sesiones, o un bytecode de expresión regular</a></li>
<li><a href="../es433056/index.html">El Ministerio de Comunicaciones endurece las reglas para el software con elementos de origen extranjero</a></li>
<li><a href="../es433058/index.html">Quinteto como entidad básica para describir un área temática</a></li>
<li><a href="../es433060/index.html">Por qué no creo microbenchmarks</a></li>
<li><a href="../es433062/index.html">AXIS P1367 versus IDIS DC-B3303X: Comparar cámaras CCTV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>