<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦌 🧑🏼‍🤝‍🧑🏻 🤦 Tarantool Kubernetes运算符 🚚 🥦 🤜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetes正在成为运行无状态应用程序的事实上的标准。 主要是因为它可以大大减少新功能交付的上市时间。 启动有状态的应用程序-数据库，有状态的微服务-仍然是一项艰巨的任务，但是承受竞争和保持高交付率的需求促使公司在这一领域进行试验，并产生了对此类解决方案的需求。 

 我们向您介绍用于启动有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool Kubernetes运算符</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/465823/"><img src="https://habrastorage.org/webt/pm/mm/lk/pmmmlkexzrcniami66ljv1ynirg.jpeg"><br><br>  Kubernetes正在成为运行无状态应用程序的事实上的标准。 主要是因为它可以大大减少新功能交付的上市时间。 启动有状态的应用程序-数据库，有状态的微服务-仍然是一项艰巨的任务，但是承受竞争和保持高交付率的需求促使公司在这一领域进行试验，并产生了对此类解决方案的需求。 <br><br> 我们向您介绍用于启动有状态集群的解决方案<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tarantool Cartridge</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tarantool Kubernetes Operator</a> ，有关详细信息，我请教。 <br><a name="habracut"></a><br> 目录： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">而不是一千个字</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作员完全做什么</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于细微差别</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作员如何工作</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运营商的扩展</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">总结</a> </li></ol><br><br>  Tarantool是一个软件包中的开源数据库和应用程序服务器。 作为数据库，它具有许多独特的特性：铁的高效利用，灵活的数据方案，对内存和磁盘存储的支持以及通过使用Lua语言进行扩展的可能性。 作为应用程序服务器，它使您可以将应用程序代码移到尽可能靠近数据的位置，同时实现最短的响应时间和最大的吞吐量。 此外，Tarantool拥有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">广泛的生态系统</a> ，提供用于解决应用程序问题的现成模块： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分片</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列</a> ，促进开发的模块（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">盒式磁带</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">luatest</a> ），操作解决方案（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">度量标准</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ansible</a> ）-这些仅是示例。 <br><br> 尽管具有所有优点，但单个Tarantool实例的功能并非无限：存储数TB的数据并处理数百万个请求，您需要引发数十个和数百个实例，这是一个分布式系统，存在所有固有的问题。 为了解决这些问题，我们有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tarantool Cartridge</a>框架，其主要任务是隐藏编写分布式应用程序时遇到的各种困难，并使开发人员可以专注于应用程序的业务价值。  Cartridge提供了一组功能强大的组件，用于自动集群流程，自动数据分发，用于操作的webui和开发人员工具。 <br><br>  Tarantool不仅是技术，还是一支工程师团队，致力于开发整套企业系统，盒式解决方案以及对开源组件的支持。 <br><br> 在全球范围内，我们的任务可以分为两个领域：新系统的开发和现有解决方案的扩充。 例如，有一个著名供应商的庞大基地。 为了扩展它以进行读取，他们在Tarantool上放置了一个最终一致的缓存。 反之亦然：为了扩展记录，他们将Tarantool置于热/冷配置中，在此过程中，当他们“冷却”数据时，会将其转储到冷存储中并与分析队列并行。 或者，为了备份现有系统，编写了该系统的精简版（功能储备），该储备保留了主“热”数据并从主系统复制数据。 更多信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">T + 2019</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告中</a>找到。 <br><br> 所有这些系统都有一个共同点：它们很难操作。 快速将包含100多个实例的集群冗余部署到3个数据中心，更新应用程序以存储数据，而不会造成停机和维护损失，在发生灾难或人为错误的情况下进行备份还原，确保组件进行谨慎的故障转移，组织配置管理...总体而言，很多有趣。 <br><br> 如果所有这些都仍像开发中一样简单地操作，那就太好了。  Kubernetes可以实现期望的结果，但是使用专业的操作员可以使生活更加轻松。 <br><br><a name="1"></a><h2> 而不是一千个字 </h2><br> 我们准备了一个基于Tarantool弹药筒的小例子，我们将使用它。 一个简单的应用程序，例如“具有HTTP接口的分布式键值存储”。 启动后，我们得到以下图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/235/2c7/c242352c708a0e0dfa8fc0896bbb986d.png"><br><br> 其中： <br><br><ul><li> 路由器-群集中负责接受和处理传入HTTP请求的部分； <br></li><li> 存储是集群中负责存储和处理数据的部分，每个主副本和副本中都有3个分片。 <br></li></ul><br> 为了平衡路由器上的传入HTTP流量，使用了Kubernetian入口。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vshard组件，</a>可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Tar​​antool</a>本身的级别将数据分发到存储中。 <br><br> 我们需要kubernetes 1.14 +，minikube可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工作</a> 。 同样， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubectl</a>的可用性也不会受到损害。 要启动操作员，您需要为其创建ServiceAccount，Role和RoleBinding： <br><br><pre><code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/service_account.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role_binding.yaml</code> </pre> <br>  Tarantool Operator通过其资源定义扩展了Kubernetes API，我们将创建它们： <br><br><pre> <code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_cluster_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_role_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_replicasettemplate_crd.yaml</code> </pre> <br> 一切准备就绪，可以启动操作员，让我们开始： <br><br><pre> <code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/operator.yaml</code> </pre> <br> 我们正在等待操作员启动，我们可以继续启动该应用程序： <br><br><pre> <code class="bash hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/examples/kv/deployment.yaml</code> </pre> <br> 在带有示例的yaml文件中，Ingress在Web UI上声明； 在<code>cluster_ip/admin/cluster</code>上可用。 当至少有一个来自Ingress的Pod启动时，您可以去那里，观察如何将新实例添加到集群中以及其拓扑结构如何变化。 <br><br> 我们正在等待集群的使用： <br><br><pre> <code class="bash hljs">$ kubectl describe clusters.tarantool.io examples-kv-cluster</code> </pre> <br> 我们希望在“群集状态”中包含以下内容： <br><br><pre> <code class="plaintext hljs">… Status: State: Ready …</code> </pre> <br> 一切就绪，该应用程序即可使用！ <br><br> 需要更多的存储空间？ 添加分片： <br><br><pre> <code class="bash hljs">$ kubectl scale roles.tarantool.io storage --replicas=3</code> </pre> <br> 分片不能应付负荷吗？ 通过编辑副本集模板，增加分片中的实例数： <br><br><pre> <code class="bash hljs">$ kubectl edit replicasettemplates.tarantool.io storage-template</code> </pre> <br> 设置<code>.spec.replicas</code> （例如2），以将每个副本集中的实例数增加到两个。 <br><br> 不再需要集群吗？ 我们将其与所有资源一起删除： <br><br><pre> <code class="bash hljs">$ kubectl delete clusters.tarantool.io examples-kv-cluster</code> </pre> <br> 出问题了吗？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拿到票后</a> ，我们会迅速拆卸。  :) <br><br><a name="2"></a><h2> 操作员完全做什么 </h2><br>  Tarantool Cartridge集群的启动和操作就是在特定时刻以特定顺序执行特定动作的故事。 <br><br> 群集本身主要通过admin API：基于HTTP的GraphQL进行管理。 当然，您可以降低级别并将命令直接驱动到控制台，但这很少发生。 例如，这是集群启动的方式： <br><br><ol><li> 例如，在systemd下，我们提高了所需的Tarantool实例数量。 <br></li><li> 将实例合并为成员： <br><br><pre> <code class="plaintext hljs">mutation { probe_instance: probe_server(uri: "storage:3301") }</code> </pre> <br></li><li> 将角色分配给实例，规定实例和副本集标识符。  GraphQL API也用于此目的： <br><br><pre> <code class="plaintext hljs">mutation { join_server( uri:"storage:3301", instance_uuid: "cccccccc-cccc-4000-b000-000000000001", replicaset_uuid: "cccccccc-0000-4000-b000-000000000000", roles: ["storage"], timeout: 5 ) }</code> </pre> <br></li><li> 我们执行负责分片的组件的引导。 同样通过API： <br><br><pre> <code class="plaintext hljs">mutation { bootstrap_vshard cluster { failover(enabled:true) } }</code> </pre> <br></li></ol><br> 容易吧？ <br><br> 扩展集群时，一切都会变得更加有趣。 该示例中路由器的角色可以简单地扩展：增加更多实例，将它们挂接到现有群集上-您完成了！ 存储的角色有些棘手。 存储是分片的，因此在添加/删除实例时，有必要重新平衡数据以移至新实例/从已删除实例移出。 如果不这样做，则在一种情况下，我们将获得实例不足的负载；在第二种情况下，我们将丢失数据。 如果不是只有一个，而是十二个具有不同拓扑结构的集群正在运行？ <br><br> 通常，Tarantool操作员会忙于所有这一切。 用户描述了Tarantool Cartridge集群的期望状态，并且操作员将其转换为对k8s资源的一组操作，并在特定时刻将其转换为以特定顺序对Tarantool集群admin API的某些调用，并且通常尝试向用户隐藏所有细微差别。 <br><br><a name="3"></a><h2> 关于细微差别 </h2><br> 使用Tarantool Cartridge管理集群API时，调用的顺序及其到来的位置都很重要。 为什么这样 <br><br>  Tarantool Cartridge带有其拓扑库，其服务发现组件和配置组件。 群集的每个实例在yaml文件中存储拓扑和配置的副本。 <br><br><pre> <code class="plaintext hljs">servers: d8a9ce19-a880-5757-9ae0-6a0959525842: uri: storage-2-0.examples-kv-cluster:3301 replicaset_uuid: 8cf044f2-cae0-519b-8d08-00a2f1173fcb 497762e2-02a1-583e-8f51-5610375ebae9: uri: storage-0-0.examples-kv-cluster:3301 replicaset_uuid: 05e42b64-fa81-59e6-beb2-95d84c22a435 … vshard: bucket_count: 30000 ...</code> </pre> <br> 更新使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两阶段提交</a>机制一致进行。 成功的升级需要100％的仲裁：每个实例必须响应，否则将回滚。 就操作而言，这意味着什么？ 向admin API修改集群状态的所有请求最可靠地发送给一个实例，再发送给领导者，否则我们冒着在不同实例上获得不同配置的风险。  Tarantool弹药筒不知道如何进行领导者选举（但还不知道如何进行），而Tarantool操作员可以-并且您只能将其视为有趣的事实，因为操作员会破坏一切。 <br><br> 而且，每个实例必须具有固定的标识，即一组<code>instance_uuid</code>和<code>replicaset_uuid</code>以及<code>advertise_uri</code> 。 如果存储突然重新启动，并且其中一个参数发生更改，则可能会导致仲裁中断-操作员也会这样做。 <br><br><a name="4"></a><h2> 操作员如何工作 </h2><br> 操作员的任务是使系统进入用户设置的状态，并将系统保持在此状态，直到收到新的指示为止。 为了使操作员能够执行其工作，他需要： <br><br><ol><li> 系统状态的描述。 <br></li><li> 使系统进入此状态的代码。 <br></li><li> 一种将此代码集成到k8中的机制（例如，接收状态变化的通知）。 <br></li></ol><br> 通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义资源定义（CRD）</a>以k8来描述Tarantool弹药群。 操作员需要3个这样的自定义资源，这些资源合并在tarantool.io/v1alpha组中： <br><br><ul><li> 群集是与一个Tarantool Cartridge群集相对应的顶级资源。 <br></li><li> 角色-就Tarantool弹药筒而言，这是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用户角色</a> 。 <br></li><li>  ReplicasetTemplate-用于创建StatefulSets的模板（为什么有状态-我稍后再告诉您；不要与k8s ReplicaSet混淆）。 <br></li></ul><br> 所有这些资源都直接反映了Tarantool Cartridge集群描述模型。 有了通用的字典，操作员可以更轻松地与开发人员进行交流并了解他们希望在产品中看到的内容。 <br><br> 使系统进入给定状态的代码-就k8而言，它是控制器。 对于Tarantool Operator，有几个控制器： <br><br><ul><li>  ClusterController-负责与Tarantool Cartridge集群进行交互，将实例连接到集群，并断开实例与集群的连接。 <br></li><li>  RoleController是一个用户角色控制器，它负责从模板部署StatefulSet并将其编号保持在给定的数量。 <br></li></ul><br> 控制器是什么样的？ 一组代码，可以逐步使您周围的世界井井有条。 可以这样示意性地描绘ClusterController： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/132/1d2/317/1321d23173a37f65743fcc0ee4d48ad2.png"><br><br> 入口点是检查事件发生的群集资源是否存在的检查。 不存在吗？ 我们要走了 有吗 我们继续进行下一个步骤：获取用户角色的所有权。 捕获了一个-左，在第二个圆上我们捕获了第二个。 依此类推，直到我们捕获所有内容。 是否捕获了所有角色？ 因此，转到下一个操作块。 这样，直到我们走到最后。 那么我们可以假设受控系统处于给定状态。 <br><br> 总的来说，一切都很简单。 确定通过每个阶段的成功标准很重要。 例如，我们认为成功加入集群的操作不是在返回条件成功= true时发生，而是在返回诸如“已加入”之类的错误时进行。 <br><br> 该机制的最后一部分是将控制器与k8s集成在一起。 在鸟瞰图中，整个k8包含一组控制器，这些控制器生成事件并对其进行响应。 事件经过我们可以订阅的队列。 可以用以下方式表示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/094/d57/3fb/094d573fbcf511ba2eea8e707a575423.jpg"><br><br> 用户调用<code>kubectl create -f tarantool_cluster.yaml</code> ，将<code>kubectl create -f tarantool_cluster.yaml</code>相应的群集资源。 通知ClusterController创建集群资源。 他要做的第一件事是找到所有应该属于此集群的角色资源。 如果找到，则将“群集”分配为“角色”的“所有者”并更新“角色”资源。  RoleController接收到一个Role更新通知，看到该资源具有Owner，并开始创建StatefulSets。 依此类推，依次为：第二个的第一个触发器，第三个的第二个触发器，依此类推，直到有人停下来。 您还可以按时触发，例如每5秒触发一次，这有时很有用。 <br><br> 这就是整个操作员：创建自定义资源并编写代码以响应资源上的事件。 <br><br><a name="5"></a><h2> 运营商的扩展 </h2><br> 操作员的行动最终导致k8创建Pod和容器。 在部署在k8上的Tarantool Cartridge集群中，所有Pod都合并到StatefulSets中。 <br><br> 为什么选择StatefulSet？ 如我之前所写，每个Tarantool集群实例都保留一个集群拓扑和配置的副本，并且在应用服务器上通常不行，不行，并且它们使用某种空间，例如依次或引用数据，这已经是完整状态。 而且StatefulSet还保证了身份Pod的保存，这在群集实例中群集时很重要：实例的身份必须固定，否则重新启动时有失去仲裁的风险。 <br><br> 创建所有群集资源并将其置于所需状态后，它们将形成以下层次结构： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e27/89f/f7e/e2789ff7e8bf174c20baf8cc077bdad2.png"><br><br> 箭头指示资源之间的所有者依赖关系。 例如，在删除群集的情况下，有必要在我们之后清理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">垃圾收集器</a> 。 <br><br> 除了StatefulSets，Tarantool运算符还创建了Headless选举所需的Headless服务，并通过该实例相互通信。 <br><br>  Tarantool Operator的背后是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Operator Framework</a> ，该操作员代码本身在golang中，在这里没什么特别的。 <br><br><a name="6"></a><h2> 总结 </h2><br> 一般而言，仅此而已！ 我们正在等待您的反馈和门票-如果没有它们，alpha版本将完全相同。 接下来是什么？ 然后有很多工作要牢记在心： <br><br><ul><li> 单元，端到端测试； <br></li><li> 混沌猴子测试 <br></li><li> 压力测试； <br></li><li> 备份/还原； <br></li><li> 外部拓扑提供程序。 <br></li></ul><br> 这些主题中的每个主题本身都是广泛的，应该使用单独的材料，请等待更新！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465823/">https://habr.com/ru/post/zh-CN465823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465811/index.html">编写简洁的React代码的14条技巧。 第一部分</a></li>
<li><a href="../zh-CN465813/index.html">编写简洁的React代码的14条技巧。 第二部分</a></li>
<li><a href="../zh-CN465815/index.html">科学家们培育了神经细胞簇，并将其送到国际空间站</a></li>
<li><a href="../zh-CN465817/index.html">不适如何帮助我们改善开发过程。</a></li>
<li><a href="../zh-CN465819/index.html">理想的局域网</a></li>
<li><a href="../zh-CN465825/index.html">SQL表中的Asterisk FreePBX电话目录（基于Web的目录，上载到Grandstream电话的xml文件中）</a></li>
<li><a href="../zh-CN465829/index.html">[教程]如何创建您的第一个增量IDLE JavaScript游戏</a></li>
<li><a href="../zh-CN465833/index.html">TOKEN2 Molto-1，世界上第一个多配置文件TOTP硬件令牌</a></li>
<li><a href="../zh-CN465835/index.html">手指上的抽象工厂</a></li>
<li><a href="../zh-CN465839/index.html">您需要了解的有关CSS保证金的所有信息</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>