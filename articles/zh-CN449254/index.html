<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📒 👆🏿 🙅 关于建筑和工作的常见问题解答VKontakte 🎶 📞 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="帕维尔本人告诉维基百科，维基百科的历史已经在维基百科上。 似乎每个人都已经认识她。 Pavel 在2010年就谈到了HighLoad ++网站的内部，架构和设计。 从那时起，许多服务器泄漏了，因此我们将更新信息：我们进行剖析，深入了解内部，权衡-我们从技术角度来看VK设备。 



 Alexey ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于建筑和工作的常见问题解答VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449254/"> 帕维尔本人告诉维基百科，维基百科的历史已经在维基百科上。 似乎每个人都已经认识她。  Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在2010年</a>就谈到了HighLoad ++网站的内部，架构和设计。 从那时起，许多服务器泄漏了，因此我们将更新信息：我们进行剖析，深入了解内部，权衡-我们从技术角度来看VK设备。 <br><br><img src="https://habrastorage.org/webt/_x/zc/wp/_xzcwpb5ze_4e-yx_jw_-8nvnei.jpeg"><br><br>  <strong>Alexey Akulovich</strong> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">AterCattus</a> ）是VKontakte团队的后端开发人员。 该报告的笔录是对平台，基础架构，服务器及其之间的交互的常见问题的集体回答，但与开发（即<strong>硬件）</strong>无关。 另外-有关数据库以及VK所处的位置，有关收集日志并监视整个项目。 细节剪下。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_GqcriadL-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br> 四年多来，我一直在执行与后端相关的各种任务。 <br><br><ul><li> 下载，存储，处理，分发媒体：视频，实时流，音频，照片，文档。 </li><li> 基础架构，平台，开发人员监视，日志，区域缓存，CDN，专有RPC协议。 </li><li> 与外部服务集成：推送邮件，解析外部链接，RSS feed。 </li><li> 帮助同事解决各种问题，以获取您不得不陷入未知代码中的答案。 </li></ul><br> 在这段时间里，我参与了该网站的许多工作。 我想分享这种经验。 <br><br><h2> 通用架构 </h2><br> 与往常一样，一切都从一个服务器或一组接受请求的服务器开始。 <br><br><h3> 前置服务器 </h3><br> 前端服务器通过HTTPS，RTMP和WSS接受请求。 <br><br>  <strong>HTTPS</strong>是对网站的主要和移动Web版本的请求：vk.com和m.vk.com，以及我们API的其他官方和非官方客户端：移动客户端，即时通讯程序。 我们具有<strong>RTMP</strong>流量，用于使用单独的前端服务器进行实时广播和用于Streaming API的<strong>WSS</strong>连接。 <br><br> 对于HTTPS和WSS， <strong>nginx</strong>安装在服务器上。 对于RTMP广播，我们最近切换到了自己的<strong>kive</strong>解决方案，但这超出了报告的范围。 为了容错，这些服务器声明公用IP地址并作为组，以便在其中一台服务器出现问题的情况下，不会丢失用户请求。 对于HTTPS和WSS，这些相同的服务器会对流量进行加密，以承担其自身的CPU负载。 <br><br> 此外，我们将不再谈论WSS和RTMP，而仅谈论通常与Web项目相关的标准HTTPS请求。 <br><br><h3> 后端 </h3><br> 前端后面通常是后端服务器。 它们处理前端服务器从客户端收到的请求。 <br><br> 这些是运行HTTP守护程序的<strong>kPHP服务器</strong> ，因为HTTPS已被解密。  kPHP是根据<strong>prefork模型</strong>工作的服务器：它启动主进程，一堆子进程，将监听套接字传递给它们，然后它们处理它们的请求。 同时，进程不会在用户的每个请求之间重新启动，而只是将它们的状态重置为初始零值状态（逐个请求），而不是重新启动。 <br><br><h4> 负载分担 </h4><br> 我们所有的后端都不是可以处理任何请求的庞大计算机池。 我们<strong>将</strong>它们<strong>分为不同的组</strong> ：常规，移动，api，视频，暂存...在另一组计算机上的问题不会影响其他所有人。 在视频出现问题的情况下，正在听音乐的用户甚至都不知道这些问题。 将请求发送到哪个后端由配置中位于前面的nginx解决。 <br><br><h4> 指标收集和重新平衡 </h4><br> 要了解每个组中需要多少辆汽车，我们<strong>不依赖QPS</strong> 。 后端不同，它们具有不同的请求，每个请求具有不同的QPS计算复杂度。 因此，我们使用<strong>服务器整体负载</strong>的<strong>概念-CPU和perf</strong> 。 <br><br> 我们有成千上万个这样的服务器。  kPHP组在每个物理服务器上运行以利用所有内核（因为kPHP是单线程的）。 <br><br><h3> 内容服务器 </h3><br>  <strong>CS或Content Server正在存储</strong> 。  CS是一台服务器，用于存储文件，并且还处理上传的文件，主要Web前端为此提供的各种同步后台任务。 <br><br> 我们有成千上万个存储文件的物理服务器。 用户喜欢上传文件，我们喜欢存储和共享文件。 其中一些服务器被特殊的pu / pp服务器关闭。 <br><br><h3>  //页 </h3><br> 如果您在VK中打开了网络标签，那么您会看到pu / pp。 <br><br><img src="https://habrastorage.org/webt/fd/am/xo/fdamxolkfxlplnc5h5flbihru3g.png"><br><br> 什么是pu / pp？ 如果我们先关闭一台服务器，则有两种选择可用于将文件上传和下载到已关闭的服务器： <strong>直接</strong>通过<code>http://cs100500.userapi.com/path</code>或<strong>通过中间服务器</strong> <code>http://pu.vk.com/c100500/path</code> <br><br>  <strong>Pu是照片上传的历史名称，pp是照片代理</strong> 。 也就是说，一台服务器上传照片，另一台服务器上传。 现在，不仅可以加载照片，而且可以保留名称。 <br><br> 这些服务器<strong>终止HTTPS会话，</strong>以从存储中删除处理器负载。 此外，由于在这些服务器上处理了用户文件，因此在这些计算机上存储的敏感信息越少越好。 例如，HTTPS加密密钥。 <br><br> 由于这些机器是由我们的其他机器关闭的，因此我们不能给它们提供“白色”的外部IP，而<strong>给它们“灰色”的</strong> IP。 因此，我们保存在IP池中，并保证保护计算机免受外部访问-根本没有IP可用。 <br><br>  <strong>通过共享IP的容错能力</strong> 。 在容错方面，该方案以相同的方式工作-几台物理服务器具有一个公共的物理IP，并且它们前面的一块铁决定了将请求发送到哪里。 稍后我将讨论其他选项。 <br><br> 有争议的一点是，在这种情况下， <strong>客户端拥有较少的连接</strong> 。 如果多台计算机上有相同的IP-主机相同：pu.vk.com或pp.vk.com，则客户端浏览器对同时请求一个主机的数量有限制。 但是在无处不在的HTTP / 2中，我相信情况不再如此。 <br><br> 该方案的明显缺点是您必须通过另一台服务器<strong>泵送所有</strong>流向存储<strong>的流量</strong> 。 由于我们通过汽车来吸引流量，因此我们还不能以相同的方式（例如视频）来吸引大量流量。 我们直接进行传输-独立的直接连接，专门用于视频的各个存储库。 我们通过代理传输较轻的内容。 <br><br> 不久前，我们有了代理的改进版本。 现在，我将告诉您它们与普通的区别以及为什么有必要。 <br><br><h3> 太阳 </h3><br>  2017年9月，先前收购了Sun的甲骨文<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解雇了大量Sun员工</a> 。 可以说，此刻该公司不复存在。 为新系统选择一个名称后，我们的管理员决定对该公司表示敬意和尊重，并命名了新的Sun系统。 在我们之间，我们称之为“阳光”。 <br><br><img src="https://habrastorage.org/webt/d3/6f/0j/d36f0jjqbwlst9mk2-lcncltkq4.png"><br><br>  Pp有一些问题。  <strong>每个组一个IP是低效的缓存</strong> 。 多个物理服务器具有一个公共IP地址，并且无法控制请求将到达哪个服务器。 因此，如果不同的用户使用同一个文件，则在这些服务器上存在高速缓存时，该文件将驻留在每个服务器的高速缓存中。 这是一个非常低效的方案，但是什么也做不了。 <br><br> 结果， <strong>我们无法分片内容</strong> ，因为我们无法为此组选择特定的服务器-它们具有公共IP。 此外，由于某些内部原因，我们<strong>没有机会将这些服务器放置在区域中</strong> 。 他们只站在圣彼得堡。 <br><br> 有了太阳，我们改变了选择系统。 现在我们有了<strong>Anycast路由</strong> ：动态路由，Anycast，自检守护程序。 每个服务器都有自己的IP，但同时有一个公用子网。 一切都以这样的方式配置：在丢失一台服务器的情况下，流量会自动分散到同一组的其他服务器。 现在可以选择一个特定的服务器， <strong>没有过多的缓存</strong> ，并且不影响可靠性。 <br><br>  <strong>重量支撑</strong> 。 现在，我们有能力根据需要放置不同容量的汽车，并且在出现临时性问题的情况下，改变工作中的“太阳”的重量以减轻其负担，使它们“休息”并重新工作。 <br><br>  <strong>通过内容ID进行分片</strong> 。 关于分片的一个有趣的事情是，我们通常将内容分片，以便不同的用户通过相同的“ sun”跟踪同一文件，从而使他们拥有共同的缓存。 <br><br> 我们最近启动了Clover应用程序。 这是一个在线实时广播测验，演示者提问，用户通过选择选项进行实时响应。 该应用程序具有聊天功能，用户可以在其中进行泛洪。  <strong>超过10万人</strong>可以同时连接到广播。 他们都写了发送给所有参与者的消息，消息又是另一个化身。 如果有十万人在一个“太阳”中来到一个化身，那么它有时会滚过云层。 <br><br> 为了承受来自同一文件的大量请求，我们为某种内容提供了一种愚蠢的方案，该方案可将文件分布在该地区所有可用的“太阳”中。 <br><br><h4> 太阳里面 </h4><br> 反向代理到nginx，缓存在RAM或Optane / NVMe快速磁盘中。 示例： <code>http://sun4-2.userapi.com/c100500/path</code> : <code>http://sun4-2.userapi.com/c100500/path</code>链接到“ sun”，它位于第四个区域，即第二个服务器组。 它关闭物理上位于服务器100500上的路径文件。 <br><br><h3> 快取 </h3><br> 我们在架构方案中增加了一个节点-缓存环境。 <br><br><img src="https://habrastorage.org/webt/jp/4p/xv/jp4pxvydhstms-z9bpbmpjy0htk.png"><br><br> 下面是<strong>区域缓存</strong>的布局，大约有20个。 这些正是缓存和“太阳”的确切位置，它们可以通过自身缓存流量。 <br><br><img src="https://habrastorage.org/webt/yh/9i/qk/yh9iqkv3dyqd3uox9wgd2cmgqba.png"><br><br> 这是多媒体内容的缓存，用户数据不存储在这里-只是音乐，视频，照片。 <br><br> 为了确定用户的区域，我们<strong>收集了在区域中宣布的BGP网络前缀</strong> 。 在后备情况下，如果我们无法通过前缀找到IP，我们仍然可以解析geoip。  <strong>通过用户IP，我们确定区域</strong> 。 在代码中，我们可以查看用户的一个或多个区域-他在地理上最接近的那些点。 <br><br><h4> 如何运作？ </h4><br>  <strong>我们按地区来考虑文件的普及程度</strong> 。 用户所在的区域有一个缓存编号，还有一个文件标识符-我们采用这一对，并为每次下载增加等级。 <br><br> 同时，恶魔-地区中的服务-不时来到API并说：“我拥有这样的缓存，请给我列出我所在地区最受欢迎的文件列表。”  API提供了一堆按等级排序的文件，守护程序将它们抽出，将它们带到区域并从那里提供文件。 这是pu / pp和Sun从缓存中获得的根本区别：即使文件不存在于缓存中，它们也会立即通过自身提供文件，并且缓存首先将文件下载到其自身，然后开始将其释放。 <br><br> 同时，我们使<strong>内容更贴近用户</strong>并抹去了网络负载。 例如，仅在莫斯科缓存中，我们在繁忙时间分配的速率超过1 Tbit / s。 <br><br> 但是存在问题- <strong>缓存服务器不是橡胶的</strong> 。 对于超级流行的内容，有时在单独的服务器上没有足够的网络。 我们有40-50 Gbit / s高速缓存服务器，但是有些内容完全阻塞了这样的通道。 我们正在努力实现在该地区存储一个以上的流行文件副本。 我希望我们能在今年年底之前实现这一目标。 <br><br> 我们研究了总体架构。 <br><br><ul><li> 接受请求的前端服务器。 </li><li> 处理请求的后端。 </li><li> 由两种类型的代理关闭的保管库。 </li><li> 区域缓存。 </li></ul><br> 该计划缺少什么？ 当然，我们存储数据的数据库。 <br><br><h2> 数据库或引擎 </h2><br> 我们称它们不是数据库，而是Engines引擎，因为在通常公认的意义上，我们实际上没有数据库。 <br><br><img src="https://habrastorage.org/webt/n6/zm/lj/n6zmlj5pwxsnqoqp0xgfhxza_ic.png"><br><br>  <strong>这是必要的措施</strong> 。 发生这种情况的原因是，在2008-2009年间，VK的爆炸性增长使该项目完全在MySQL和Memcache上运行，并且出现了问题。  MySQL喜欢掉落并破坏文件，此后它没有上升，并且Memcache的性能逐渐下降，必须重新启动。 <br><br> 事实证明，在越来越受欢迎的项目中，有一个永久存储破坏了数据，而一个缓存却变慢了。 在这种情况下，很难发展一个不断发展的项目。 决定尝试重写项目依靠自己的自行车的关键事项。 <br><br>  <strong>解决方案成功</strong> 。 迫切需要这样做的能力，因为那时还不存在其他缩放方法。 目前还没有基础库，NoSQL还不存在，只有MySQL，Memcache和PostrgreSQL，仅此而已。 <br><br>  <strong>通用操作</strong> 。 开发工作由我们的C开发人员团队领导，并且所有操作均以相同的方式完成。 无论使用哪种引擎，到处都有几乎相同格式的文件写入磁盘，相同的启动参数，在发生边缘情况和问题时对信号进行相同的处理和表现相同。 随着引擎的增长，管理员可以方便地操作该系统-无需维护动物园，也无需学习再次操作每个新的第三方基地，这使得快速便捷地增加其数量成为可能。 <br><br><h3> 引擎类型 </h3><br> 团队已经编写了很多引擎。 以下是其中的一些：朋友，提示，图像，ipdb，字母，列表，日志，memcached，meowdb，新闻，nostradamus，照片，播放列表，pmemcached，沙箱，搜索，存储，喜欢，任务，... <br><br> 对于需要特定数据结构或处理非典型请求的每个任务，C团队将编写一个新引擎。 为什么不呢 <br><br> 我们有一个单独的<strong>memcached</strong>引擎，它与通常的引擎相似，但是带有一堆面包，并且不会减慢速度。 不是ClickHouse，但也可以。 单独有<strong>pmemcached-</strong>这是一个<strong>持久性的memcached</strong> ，它也可以将数据存储在磁盘上，并且存储在RAM中的数据要多得多，以便在重启时不会丢失数据。 有多种引擎可用于单独的任务：队列，列表，集合-我们项目所需要的全部。 <br><br><h3> 集群 </h3><br> 从代码的角度来看，无需将引擎或数据库想象为某些进程，实体或实例。 该代码专门用于具有引擎组的<strong>集群</strong> - <strong>每个集群一种类型</strong> 。 假设有一个内存缓存集群-它只是一组计算机。 <br><br><blockquote> 该代码不需要知道服务器的物理位置，大小和数量。 他通过某个标识符进入集群。 </blockquote><br> 为此，您需要添加另一个实体，该实体位于代码和engines- <strong>proxy之间</strong> 。 <br><br><h3>  RPC代理 </h3><br> 代理- <strong>连接总线</strong> ，几乎可以运行整个站点。 同时，我们<strong>没有服务发现</strong> -代替它，而是此代理的配置，该代理知道所有群集以及该群集的所有碎片的位置。 这是由管理员完成的。 <br><br> 程序员通常并不关心它的成本，成本和成本，而只是去集群。 这让我们受益匪浅。 收到请求后，代理将重定向请求，并知道它在哪里-它确定了这一点。 <br><br><img src="https://habrastorage.org/webt/7k/pf/ia/7kpfiagxzy2a4mrosc_f4otqnw8.png"><br><br> 同时，代理是防止服务故障的保护点。 如果任何引擎速度变慢或崩溃，则代理可以理解这一点，并相应地响应客户端。 这使您可以删除超时-代码不等待引擎响应，但是知道它不起作用并且您需要采取不同的行为。 应该针对数据库并非始终有效的事实准备代码。 <br><br><h4> 具体实施 </h4><br> 有时，我们仍然非常想拥有某种定制解决方案作为引擎。 同时，决定不使用专门为我们的引擎创建的现成的rpc-proxy，而是为该任务创建单独的代理。 <br><br> 对于在某些地方仍然存在的MySQL，我们使用db-proxy，对于ClickHouse- <strong>Kittenhouse</strong> 。 <br><br> 这样总体上是这样的。 有一个服务器，kPHP，Go，Python正在其上运行-通常，任何可以遵循我们的RPC协议的代码。 代码在本地传递到RPC代理-在有代码的每台服务器上，都会启动其自己的本地代理。 根据要求，代理知道要去哪里。 <br><br><img src="https://habrastorage.org/webt/f-/dx/ro/f-dxrox3o97ckejzygz8mgf4tcs.png"><br><br> 如果一个引擎想要转到另一个引擎，即使它是邻居，它也会通过代理，因为邻居可以位于另一个数据中心。 引擎不应该只知道自身以外的任何位置，我们拥有这种标准解决方案。 但是当然有例外：） <br><br> 所有引擎均根据其工作的TL方案示例。 <br><br><pre> <code class="plaintext hljs">memcache.not_found = memcache.Value; memcache.strvalue value:string flags:int = memcache.Value; memcache.addOrIncr key:string flags:int delay:int value:long = memcache.Value; tasks.task fields_mask:# flags:int tag:%(Vector int) data:string id:fields_mask.0?long retries:fields_mask.1?int scheduled_time:fields_mask.2?int deadline:fields_mask.3?int = tasks.Task; tasks.addTask type_name:string queue_id:%(Vector int) task:%tasks.Task = Long;</code> </pre> <br> 这是一个二进制协议，最接近的类似物是<strong>protobuf。</strong> 该方案预先描述了可选字段，复杂类型-内置标量的扩展和查询。 一切都按照此协议进行。 <br><br><h4>  RPC over TL over TCP / UDP ... UDP？ </h4><br> 我们有一个用于查询引擎的RPC协议，该协议在TL方案之上运行。 所有这些都可以在TCP / UDP连接之上进行。  TCP-很明显，为什么我们经常被问到UDP。 <br><br>  UDP有助于<strong>避免服务器之间的大量连接问题</strong> 。 如果每个服务器上都有一个RPC代理，并且通常它可以连接到任何引擎，那么您将获得与该服务器成千上万的TCP连接。 有负载，但是没用。 如果是UDP，则不会出现此问题。 <br><br>  <strong>没有冗余的TCP握手</strong> 。 这是一个典型的问题：当出现新引擎或新服务器时，会立即建立许多TCP连接。 对于较小的轻量级请求，例如UDP负载，代码和引擎之间的所有通信都是<strong>两个UDP数据包：</strong>一个在一个方向上飞行，另一个在另一个方向上飞行。 一次往返-代码收到了引擎的响应，没有握手。 <br><br> 是的，这一切仅<strong>在很小的丢包率下</strong>起作用。 该协议支持重传和超时，但是如果丢失很多，我们实际上会获得TCP，这是无利可图的。 在大洋彼岸，请勿驱动UDP。 <br><br> 我们有成千上万个这样的服务器，并且有相同的方案：每台物理服务器上都放置了一组引擎。 基本上，它们是单线程的，可以在不阻塞的情况下尽快运行，并且被分解为单线程解决方案。 同时，我们没有比这些引擎更可靠的了，并且对持久性数据存储给予了很多关注。 <br><br><h3> 永久数据存储 </h3><br>  <strong>引擎编写binlog</strong> 。  Binlog是一个文件，在文件的末尾添加了一个事件以更改状态或数据。 在不同的解决方案中，其名称有所不同：二进制日志， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WAL</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AOF</a> ，但原理是一种。 <br><br> 为了使引擎在多年的重新启动过程中不会重新读取整个binlog，引擎会写入<strong>快照-当前状态</strong> 。 如有必要，他们首先从中读取，然后从binlog中读取。 根据TL方案，所有二进制日志均以相同的二进制格式编写，因此管理员可以使用其工具平等地对其进行管理。 无需快照。 有一个通用的标题，指示谁的快照是int，引擎的魔力，以及哪个主体对任何人都不重要。 这是记录快照的引擎的问题。 <br><br> 我将简要描述工作原理。 有一台正在运行引擎的服务器。 他打开一个新的空binlog进行记录，并向其中写入一个change事件。 <br><br><img src="https://habrastorage.org/webt/dd/w9/9p/ddw99p7g6upg9hci9ou6aln6d_c.png"><br><br> 在某个时候，他要么决定拍摄快照，要么他接收到信号。 服务器创建一个新文件，将其状态完全写入其中，将binlog的当前大小（偏移量）附加到文件末尾，然后继续进行进一步写入。 不会创建新的binlog。 <br><br><img src="https://habrastorage.org/webt/ec/fq/yt/ecfqytibh2tsm5ncd8mfli-b1ta.png"><br><br> 在某个时候，引擎重新启动时，磁盘上将有一个二进制日志和一个快照。 引擎将读取完整的快照，并在特定点提升其状态。 <br><br><img src="https://habrastorage.org/webt/bg/ph/-u/bgph-uu68nqedhby4a2kf3r9c5u.png"><br><br> 减去创建快照时的位置和二进制日志的大小。 <br><br><img src="https://habrastorage.org/webt/ar/gs/lq/argslqv8ewosmtic8-zaobq4g5o.png"><br><br> 读取binlog的末尾以获取当前状态，并继续编写其他事件。 这是一个简单的方案，我们所有的引擎都可以使用它。 <br><br><h4> 资料复制 </h4><br> 结果，数据复制是<strong>基于语句的</strong> -我们不会将任何页面更改写入二进制日志，而是<strong>请求更改</strong> 。 与网络上的内容非常相似，只有一点点变化。 <br><br> 相同的方案不仅用于复制，而且<strong>用于创建备份</strong> 。 我们有一个引擎-编写二进制日志的写作大师。 在管理员设置的其他任何地方，复制此二进制日志都会增加，仅此而已-我们有一个备份。 <br><br><img src="https://habrastorage.org/webt/og/al/sz/ogalszm0wfe3f_064sbjnpo4p9c.png"><br><br> 如果您需要一个<strong>读取副本</strong>以减轻CPU读取的负担，那么读取引擎就会启动，它会读取binlog的末尾并在本地执行这些命令。 <br><br> 这里的滞后很小，并且有机会找出副本副本在原版副本后面的数量。 <br><br><h3>  RPC代理中的数据分片 </h3><br> 分片如何工作？ 代理如何理解要发送到哪个群集分片？ 代码没有说：“发送到15个碎片！”  -不，它可以代理。 <br><br>  <strong>最简单的方案是firstint</strong> ，即请求中的第一个数字。 <br><br> <code>get(photo100_500) =&gt; 100 % N.</code> <br> <br> 这是一个简单的Memcached文本协议的示例，但是，当然，请求是复杂的，结构化的。 该示例获取查询中的第一个数字，然后除以群集大小的余数。 <br><br> 当我们想要一个实体的数据局部性时，这很有用。 假设100是一个用户或组ID，并且我们希望一个实体的所有数据在同一分片上以进行复杂的查询。 <br><br> 如果我们不在乎请求如何在整个集群中分布，则还有另一种选择- <strong>对整个分片进行哈希处理</strong> 。 <br><br> <code>hash(photo100_500) =&gt; 3539886280 % N</code> <br> <br> 我们还获得散列，除法的余数和分片的数量。 <br><br> 这两个选项只有在我们准备好增加群集大小时会多次分裂或增加群集这一事实时才起作用。 例如，我们有16个分片，我们丢失了，我们想要更多-您可以安全地获得32个而不会造成停机。 如果我们要进行多次构建，则会出现停机时间，因为无法小心地粉碎所有内容而不会造成损失。 这些选项很有用，但并非总是如此。 <br><br> 如果我们需要添加或删除任意数量的服务器， <strong>则在la Ketama环上使用一致的哈希</strong> 。 但是，与此同时，我们完全失去了数据的局部性，我们必须向集群发出合并请求，以使每个块都返回其较小的答案，并且已经将响应合并到代理中。 <br><br>  - .   : RPC-proxy  , ,       .     , ,     ,      .    proxy. <br><br><img src="https://habrastorage.org/webt/jx/6t/f9/jx6tf9jlkkmva1qfifzmwrx58wc.png"><br><br><h2>  </h2><br>     .     — <strong>   memcache</strong> . <br><br> <code>ring-buffer: prefix.idx = line</code> <br> <br>    —  , ,      —  .     0     1.   memcache —       .        . <br><br>    ,   <strong>Multi Get</strong>  ,   ,         .  ,   -      ,   ,         ,      . <br><br>         <strong>logs-engine</strong> .      ,       .       600   . <br><br>   ,  ,    6–7 .    ,    , ,    ClickHouse   . <br><br><h3>    ClickHouse </h3><br>   ,      . <br><br><img src="https://habrastorage.org/webt/jm/-j/s0/jm-js04tjh8lb8pii1_dzl_sfa4.png"><br><br>  ,   RPC    RPC-proxy,   ,    .       ClickHouse,        : <br><br><ul><li>  -   ClickHouse; </li><li>  RPC-proxy,      ClickHouse,  - ,  ,   RPC. </li></ul><br>    —          ClickHouse. <br><br>     ClickHouse,   <strong>KittenHouse</strong> .      KittenHouse  ClickHouse —   .   ,  HTTP-     .   ,    ClickHouse <strong>  reverse proxy</strong> ,   ,     .         . <br><br><img src="https://habrastorage.org/webt/zj/fy/5y/zjfy5yuay9-6wqe3nrgjkeznvny.png"><br><br>      RPC-   , ,  nginx.   KittenHouse      UDP. <br><br><img src="https://habrastorage.org/webt/hq/wl/v_/hqwlv_vnujb-maxakxksbmrf6xo.png"><br><br>         ,    UDP-      .       RPC     ,      UDP.      . <br><br><h2> 监控方式 </h2><br>     : ,        ,     .     : <strong>  </strong> . <br><br><h3>   </h3><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Netdata</a> ,        <strong>Graphite Carbon</strong> .      ClickHouse,   Whisper, .       ClickHouse,   <strong>Grafana</strong>  ,   .  ,   Netdata  Grafana  . <br><br><h3>   </h3><br>      . ,    ,    Counts, UniqueCounts   ,   - . <br><br><pre> <code class="plaintext hljs">statlogsCountEvent ( 'stat_name', $key1, $key2, …) statlogsUniqueCount ( 'stat_name', $uid, $key1, $key2, …) statlogsValuetEvent ( 'stat_name', $value, $key1, $key2, …) $stats = statlogsStatData($params)</code> </pre><br>      ,    ,     —  ,  Wathdogs. <br><br>    <strong> ,</strong>    600   1   .       <strong>   </strong> ,     .     —  ,     . ,      . <br><br>    ,     <strong>  memcache</strong> ,    .         <strong>stats-daemon</strong>   .         <strong>logs-collectors</strong> ,       ,      . <br><br><img src="https://habrastorage.org/webt/ih/ab/oy/ihaboy4luh5hriorej9seodbx6u.png"><br><br>        logs-collectors. <br><br><img src="https://habrastorage.org/webt/fq/ta/bj/fqtabjgq556wqfdz5_kfq3mj94c.png"><br><br>          stas-daemom —   ,      collector.  ,    -        memcache stats-daemon,   ,    . <br><br>  logs-collectors    <strong>meowDB</strong> —   ,      . <br><br><img src="https://habrastorage.org/webt/v_/gb/_y/v_gb_ya-9ywkra7xdh5h_qtqsc4.png"><br><br>      «-SQL»  . <br><br><img src="https://habrastorage.org/webt/1q/gw/wp/1qgwwpyj3ewcwuonshvty_zcfhc.png"><br><br><h3>  </h3><br>  2018     ,          -,      ClickHouse.      ClickHouse —    ? <br><br><img src="https://habrastorage.org/webt/wg/mz/kl/wgmzklw41x7ilj0-5hbr_kfdif8.png"><br><br>    ,     KittenHouse. <br><br><img src="https://habrastorage.org/webt/kq/s7/uj/kqs7ujzbhnqzt5f8djepldmwxia.png"><br><br>   <strong>     «*House»</strong> ,        ,       UDP.   *House    inserts,  ,   KittenHouse.        ClickHouse,     . <br><br><img src="https://habrastorage.org/webt/ff/k3/th/ffk3thypln9exuhyuhr-nuj9hr4.png"><br><br>   memcache, stats-daemon  logs-collectors    . <br><br><img src="https://habrastorage.org/webt/r4/g3/e9/r4g3e9yakpzbx5gscmgyl6keqsa.png"><br><br>   memcache, stats-daemon  logs-collectors    . <br><br><ul><li>     ,     StatsHouse. </li><li> StatsHouse   KittenHouse UDP-,    SQL-inserts, . </li><li> KittenHouse    ClickHouse. </li><li>     ,      StatsHouse —   ClickHouse  SQL. </li></ul><br>    <strong></strong> ,   ,  .    , , ,    .     . <br><br>  <strong>  </strong> .   ,    stats-daemons  logs-collectors,  ClickHouse   ,  ,     . <strong>  ,       </strong> . <br><br><h2>  </h2><br>     PHP.    <strong>git</strong> :  <strong>GitLab</strong>  <strong>TeamCity</strong>  .     -,       ,   —  . <br><br>        ,     diff  — : , , .     binlog   copyfast,          .     ,  <strong>gossip replication</strong> ,       ,  —  ,   .            .      ,       <strong>  </strong> .       . <br><br>     kPHP         <strong>git</strong>   .    <strong> HTTP-</strong> ,      diff —     .     —    <strong>binlog copyfast</strong> .     ,      .  <strong>  </strong> .  copyfast' ,   binlog   ,     gossip replication     ,    -,      .   <strong>graceful </strong>   . <br><br>   ,     ,   : <br><br><ul><li> git master branch; </li><li>   <strong>.deb</strong> ; </li><li>    binlog copyfast; </li><li>   ; </li><li>     .dep; </li><li> <strong>dpkg -i</strong> ; </li><li> graceful    . </li></ul><br>   ,        <strong>.deb</strong> ,     <strong>dpkg -i</strong>   .    kPHP  ,   — dpkg?  .  —  . <br><br> <b> :</b> <br><br><ul><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«  Vkontakte. ?»</a>    copyfast  gossip. </li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">« VK    CLickHouse    »</a> . </li><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«     »</a> ,     ,   . </li></ul><br><blockquote>     ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP Russia</a>  17          PHP-. ,     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> (     PHP!) — ,      PHP,   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449254/">https://habr.com/ru/post/zh-CN449254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449236/index.html">好的，谷歌：我如何通过验证码？</a></li>
<li><a href="../zh-CN449240/index.html">年轻的Daida服务的故事（订阅艺术）</a></li>
<li><a href="../zh-CN449246/index.html">AX200-英特尔Wi-Fi 6</a></li>
<li><a href="../zh-CN449248/index.html">现代IDE。 绝对是D，某种程度上是E，当然不是我</a></li>
<li><a href="../zh-CN449252/index.html">Zombie专案-即使使用者死亡也可以合并使用者资料</a></li>
<li><a href="../zh-CN449256/index.html">我看了80份简历，有疑问</a></li>
<li><a href="../zh-CN449260/index.html">什么是自动化机器学习（AutoML）</a></li>
<li><a href="../zh-CN449262/index.html">最新的IRM-Siebel升级到IP17 +</a></li>
<li><a href="../zh-CN449264/index.html">为1C创建报告系统：基于OLAP和Excel的ERP</a></li>
<li><a href="../zh-CN449266/index.html">RusCrypto的3个报告：具有经验的会议</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>