<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçØ üéâ üëºüèø Spark SQL. Um pouco sobre o otimizador de consultas ‚ôÇÔ∏è ü•ê üåπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal. Como introdu√ß√£o, quero lhe contar como cheguei a essa vida. 



 Antes de conhecer o Big Data e o Spark, em particular, eu tinha muitas e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spark SQL. Um pouco sobre o otimizador de consultas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/neoflex/blog/417103/"><p>  Ol√° pessoal.  Como introdu√ß√£o, quero lhe contar como cheguei a essa vida. <br></p><br><p>  Antes de conhecer o Big Data e o Spark, em particular, eu tinha muitas e muitas vezes otimiza√ß√£o de consultas SQL, primeiro para MSSQL, depois para Oracle, e agora me deparei com o SparkSQL. <br></p><br><p>  E se j√° existem muitos bons livros para o DBMS que descrevem a metodologia e as "canetas" que voc√™ pode girar para obter o plano de consulta ideal, ent√£o eu n√£o vi esses livros para o Spark.  Me deparei com mais artigos e conjuntos de pr√°ticas, mais relacionados ao trabalho atrav√©s da API RDD / Dataset, em vez de SQL puro.  Para mim, um dos livros de refer√™ncia sobre otimiza√ß√£o de SQL √© o livro de J. Lewis, Oracle.  No√ß√µes b√°sicas de otimiza√ß√£o de custos ".  Eu procurei algo semelhante em profundidade de estudo.  Por que o assunto da pesquisa foi especificamente o SparkSQL, e n√£o a API subjacente?  Ent√£o o interesse foi causado pelos recursos do projeto em que estou trabalhando. <br></p><br><img src="https://habrastorage.org/webt/po/1f/un/po1fun6vgbktou6lykepwmrncci.jpeg"><br><a name="habracut"></a><br><p>  Para um de nossos clientes, nossa empresa est√° desenvolvendo um data warehouse, cuja camada detalhada e parte dos casos de exibi√ß√£o est√£o no cluster Hadoop, e os casos de exibi√ß√£o finais est√£o no Oracle.  Este projeto envolve uma extensa camada de convers√£o de dados, que √© implementada no Spark.  Para acelerar o desenvolvimento e a conectividade dos desenvolvedores de ETL que n√£o est√£o familiarizados com as complexidades das tecnologias de Big Data, mas est√£o familiarizados com as ferramentas SQL e ETL, foi desenvolvida uma ferramenta que lembra ideologicamente outras ferramentas de ETL, por exemplo, a Informatica, e permite projetar visualmente os processos de ETL com a gera√ß√£o subsequente c√≥digo para Spark.  Devido √† complexidade dos algoritmos e ao grande n√∫mero de transforma√ß√µes, os desenvolvedores usam principalmente consultas SparkSQL. <br></p><br><p> E √© a√≠ que a hist√≥ria come√ßa, pois tive que responder a um grande n√∫mero de perguntas no formul√°rio ‚ÄúPor que a solicita√ß√£o n√£o funciona / funciona lentamente / funciona de forma diferente da Oracle?‚Äù.  Essa foi a parte mais interessante para mim: ‚ÄúPor que funciona devagar?‚Äù.  Al√©m disso, ao contr√°rio do DBMS com o qual trabalhei antes, voc√™ pode entrar no c√≥digo-fonte e obter a resposta para suas perguntas. <br></p><cut text="    "></cut><br><h2>  Limita√ß√µes e premissas </h2><br><p>  O Spark 2.3.0 √© usado para executar exemplos e analisar o c√≥digo-fonte. <br>  Sup√µe-se que o leitor esteja familiarizado com a arquitetura Spark e os princ√≠pios gerais do otimizador de consulta para um dos DBMSs.  No m√≠nimo, a frase "plano de consulta" certamente n√£o deve ser surpreendente. <br></p><br><p>  Al√©m disso, este artigo tenta n√£o se tornar uma tradu√ß√£o do c√≥digo do otimizador Spark para o russo; portanto, para coisas que s√£o muito interessantes do ponto de vista do otimizador, mas que podem ser lidas no c√≥digo-fonte, elas ser√£o simplesmente mencionadas aqui brevemente com links para as classes correspondentes. <br></p><br><h2>  V√° para o estudo </h2><br><p>  Vamos come√ßar com uma pequena consulta para explorar os est√°gios b√°sicos pelos quais ela passa da an√°lise para a execu√ß√£o. <br></p><br><pre><code class="scala hljs">scala&gt; spark.read.orc(<span class="hljs-string"><span class="hljs-string">"/user/test/balance"</span></span>).createOrReplaceTempView(<span class="hljs-string"><span class="hljs-string">"bal"</span></span>) scala&gt; spark.read.orc(<span class="hljs-string"><span class="hljs-string">"/user/test/customer"</span></span>).createOrReplaceTempView(<span class="hljs-string"><span class="hljs-string">"cust"</span></span>) scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> df = spark.sql(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">" | select bal.account_rk, cust.full_name | from bal | join cust | on bal.party_rk = cust.party_rk | and bal.actual_date = cust.actual_date | where bal.actual_date = cast('2017-12-31' as date) | "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) df: org.apache.spark.sql.<span class="hljs-type"><span class="hljs-type">DataFrame</span></span> = [account_rk: decimal(<span class="hljs-number"><span class="hljs-number">38</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>), full_name: string] scala&gt; df.explain(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  O principal m√≥dulo respons√°vel por analisar o SQL e otimizar o plano de execu√ß√£o da consulta √© o Spark Catalyst. <br></p><br><p>  A sa√≠da expandida na descri√ß√£o do plano de solicita√ß√£o (df.explain (true)) permite rastrear todos os est√°gios pelos quais a solicita√ß√£o passa: <br></p><br><ul><li>  Plano l√≥gico analisado - obtenha ap√≥s analisar o SQL.  Nesse est√°gio, apenas a corre√ß√£o sint√°tica da solicita√ß√£o √© verificada. </li></ul><br><pre> <code class="hljs rust">== Parsed Logical Plan == <span class="hljs-symbol"><span class="hljs-symbol">'Project</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">'bal</span></span>.account_rk, <span class="hljs-symbol"><span class="hljs-symbol">'cust</span></span>.full_name] +- <span class="hljs-symbol"><span class="hljs-symbol">'Filter</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">'bal</span></span>.actual_date = cast(<span class="hljs-number"><span class="hljs-number">2017</span></span>-<span class="hljs-number"><span class="hljs-number">12</span></span>-<span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> date)) +- <span class="hljs-symbol"><span class="hljs-symbol">'Join</span></span> Inner, ((<span class="hljs-symbol"><span class="hljs-symbol">'bal</span></span>.party_rk = <span class="hljs-symbol"><span class="hljs-symbol">'cust</span></span>.party_rk) &amp;&amp; (<span class="hljs-symbol"><span class="hljs-symbol">'bal</span></span>.actual_date = <span class="hljs-symbol"><span class="hljs-symbol">'cust</span></span>.actual_date)) :- <span class="hljs-symbol"><span class="hljs-symbol">'UnresolvedRelation</span></span> `bal` +- <span class="hljs-symbol"><span class="hljs-symbol">'UnresolvedRelation</span></span> `cust`</code> </pre><br><ul><li>  Plano L√≥gico Analisado - nesta etapa, s√£o adicionadas informa√ß√µes sobre a estrutura das entidades utilizadas, a correspond√™ncia da estrutura e os atributos solicitados. </li></ul><br><pre> <code class="hljs delphi">== Analyzed Logical Plan == account_rk: decimal(<span class="hljs-number"><span class="hljs-number">38</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>), full_name: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Project [account_rk<span class="hljs-string"><span class="hljs-string">#1</span></span>, full_name<span class="hljs-string"><span class="hljs-string">#59</span></span>] +- Filter (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = cast(<span class="hljs-number"><span class="hljs-number">2017</span></span>-<span class="hljs-number"><span class="hljs-number">12</span></span>-<span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> date)) +- Join Inner, ((party_rk<span class="hljs-string"><span class="hljs-string">#18</span></span> = party_rk<span class="hljs-string"><span class="hljs-string">#57</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span>)) :- SubqueryAlias bal : +- Relation[ACTUAL_END_DATE<span class="hljs-string"><span class="hljs-string">#0</span></span>,ACCOUNT_RK<span class="hljs-string"><span class="hljs-string">#1</span></span>,... <span class="hljs-number"><span class="hljs-number">4</span></span> more fields] orc +- SubqueryAlias cust +- Relation[ACTUAL_END_DATE<span class="hljs-string"><span class="hljs-string">#56</span></span>,PARTY_RK<span class="hljs-string"><span class="hljs-string">#57</span></span>... <span class="hljs-number"><span class="hljs-number">9</span></span> more fields] orc</code> </pre><br><ul><li>  O plano l√≥gico otimizado √© o mais interessante para n√≥s.  Nesse est√°gio, a √°rvore de consulta resultante √© convertida com base nas regras de otimiza√ß√£o dispon√≠veis. </li></ul><br><pre> <code class="hljs delphi">== Optimized Logical Plan == Project [account_rk<span class="hljs-string"><span class="hljs-string">#1</span></span>, full_name<span class="hljs-string"><span class="hljs-string">#59</span></span>] +- Join Inner, ((party_rk<span class="hljs-string"><span class="hljs-string">#18</span></span> = party_rk<span class="hljs-string"><span class="hljs-string">#57</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span>)) :- Project [ACCOUNT_RK<span class="hljs-string"><span class="hljs-string">#1</span></span>, PARTY_RK<span class="hljs-string"><span class="hljs-string">#18</span></span>, ACTUAL_DATE<span class="hljs-string"><span class="hljs-string">#27</span></span>] : +- Filter ((isnotnull(actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>)) &amp;&amp; isnotnull(party_rk<span class="hljs-string"><span class="hljs-string">#18</span></span>)) : +- Relation[ACTUAL_END_DATE<span class="hljs-string"><span class="hljs-string">#0</span></span>,ACCOUNT_RK<span class="hljs-string"><span class="hljs-string">#1</span></span>,... <span class="hljs-number"><span class="hljs-number">4</span></span> more fields] orc +- Project [PARTY_RK<span class="hljs-string"><span class="hljs-string">#57</span></span>, FULL_NAME<span class="hljs-string"><span class="hljs-string">#59</span></span>, ACTUAL_DATE<span class="hljs-string"><span class="hljs-string">#88</span></span>] +- Filter ((isnotnull(actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span>) &amp;&amp; isnotnull(party_rk<span class="hljs-string"><span class="hljs-string">#57</span></span>)) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>)) +- Relation[ACTUAL_END_DATE<span class="hljs-string"><span class="hljs-string">#56</span></span>,PARTY_RK<span class="hljs-string"><span class="hljs-string">#57</span></span>,... <span class="hljs-number"><span class="hljs-number">9</span></span> more fields] orc</code> </pre><br><ul><li>  Plano f√≠sico - os recursos de acesso aos dados de origem est√£o come√ßando a ser levados em considera√ß√£o, incluindo otimiza√ß√µes para filtrar parti√ß√µes e dados para minimizar o conjunto de dados resultante.  A estrat√©gia de execu√ß√£o da jun√ß√£o est√° selecionada (para obter mais detalhes sobre as op√ß√µes dispon√≠veis, veja abaixo). </li></ul><br><pre> <code class="hljs pgsql">== Physical Plan == *(<span class="hljs-number"><span class="hljs-number">2</span></span>) Project [account_rk#<span class="hljs-number"><span class="hljs-number">1</span></span>, full_name#<span class="hljs-number"><span class="hljs-number">59</span></span>] +- *(<span class="hljs-number"><span class="hljs-number">2</span></span>) BroadcastHashJoin [party_rk#<span class="hljs-number"><span class="hljs-number">18</span></span>, actual_date#<span class="hljs-number"><span class="hljs-number">27</span></span>], [party_rk#<span class="hljs-number"><span class="hljs-number">57</span></span>, actual_date#<span class="hljs-number"><span class="hljs-number">88</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span>, BuildRight :- *(<span class="hljs-number"><span class="hljs-number">2</span></span>) Project [ACCOUNT_RK#<span class="hljs-number"><span class="hljs-number">1</span></span>, PARTY_RK#<span class="hljs-number"><span class="hljs-number">18</span></span>, ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">27</span></span>] : +- *(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> isnotnull(party_rk#<span class="hljs-number"><span class="hljs-number">18</span></span>) : +- *(<span class="hljs-number"><span class="hljs-number">2</span></span>) FileScan orc [ACCOUNT_RK#<span class="hljs-number"><span class="hljs-number">1</span></span>,PARTY_RK#<span class="hljs-number"><span class="hljs-number">18</span></span>,ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">27</span></span>] Batched: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Format</span></span>: ORC, <span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: InMemoryFileIndex[hdfs://<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>:<span class="hljs-number"><span class="hljs-number">8020</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/test/balance], PartitionCount: <span class="hljs-number"><span class="hljs-number">1</span></span>, PartitionFilters: [isnotnull(ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">27</span></span>), (ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">27</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>)], PushedFilters: [IsNotNull(PARTY_RK)], ReadSchema: struct&lt;ACCOUNT_RK:<span class="hljs-type"><span class="hljs-type">decimal</span></span>(<span class="hljs-number"><span class="hljs-number">38</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>),PARTY_RK:<span class="hljs-type"><span class="hljs-type">decimal</span></span>(<span class="hljs-number"><span class="hljs-number">38</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>)&gt; +- BroadcastExchange HashedRelationBroadcastMode(List(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-type"><span class="hljs-type">decimal</span></span>(<span class="hljs-number"><span class="hljs-number">38</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>])) +- *(<span class="hljs-number"><span class="hljs-number">1</span></span>) Project [PARTY_RK#<span class="hljs-number"><span class="hljs-number">57</span></span>, FULL_NAME#<span class="hljs-number"><span class="hljs-number">59</span></span>, ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">88</span></span>] +- *(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> isnotnull(party_rk#<span class="hljs-number"><span class="hljs-number">57</span></span>) +- *(<span class="hljs-number"><span class="hljs-number">1</span></span>) FileScan orc [PARTY_RK#<span class="hljs-number"><span class="hljs-number">57</span></span>,FULL_NAME#<span class="hljs-number"><span class="hljs-number">59</span></span>,ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">88</span></span>] Batched: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Format</span></span>: ORC, <span class="hljs-keyword"><span class="hljs-keyword">Location</span></span>: InMemoryFileIndex[hdfs://<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>:<span class="hljs-number"><span class="hljs-number">8020</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/test/customer], PartitionCount: <span class="hljs-number"><span class="hljs-number">1</span></span>, PartitionFilters: [isnotnull(ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">88</span></span>), (ACTUAL_DATE#<span class="hljs-number"><span class="hljs-number">88</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>)], PushedFilters: [IsNotNull(PARTY_RK)], ReadSchema: struct&lt;PARTY_RK:<span class="hljs-type"><span class="hljs-type">decimal</span></span>(<span class="hljs-number"><span class="hljs-number">38</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>),FULL_NAME:string&gt;</code> </pre><br><p>  Os seguintes est√°gios de otimiza√ß√£o e execu√ß√£o (por exemplo, WholeStageCodegen) est√£o al√©m do escopo deste artigo, mas s√£o descritos em grande detalhe (assim como os est√°gios descritos acima) no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mastering Spark Sql</a> . <br></p><br><p>  A leitura do plano de execu√ß√£o da consulta geralmente acontece ‚Äúde dentro‚Äù e ‚Äúde baixo para cima‚Äù, ou seja, as partes mais aninhadas s√£o executadas primeiro e avan√ßam gradualmente para a proje√ß√£o final localizada na parte superior. <br></p><br><h2>  Tipos de otimizadores de consulta </h2><br><p>  Dois tipos de otimizadores de consulta podem ser distinguidos: </p><br><ul><li>  Otimizadores baseados em regras (RBOs). </li><li>  Otimizadores com base em uma estimativa do custo de execu√ß√£o da consulta (otimizador baseado em custo, CBO). </li></ul><br><p>  Os primeiros s√£o focados no uso de um conjunto de regras fixas, por exemplo, na aplica√ß√£o de condi√ß√µes de filtragem a partir de onde, em est√°gios anteriores, se poss√≠vel, no c√°lculo de constantes, etc. <br></p><br><p>  Para avaliar a qualidade do plano resultante, o otimizador CBO usa uma fun√ß√£o de custo, que geralmente depende da quantidade de dados processados, do n√∫mero de linhas que se enquadram nos filtros e do custo de executar determinadas opera√ß√µes. <br></p><br><p>  Para saber mais sobre a especifica√ß√£o de design do CBO para o Apache Spark, siga os links: a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">principal tarefa do JIRA para implementa√ß√£o</a> . <br></p><br><p>  O ponto de partida para explorar toda a gama de otimiza√ß√µes existentes √© o c√≥digo Optimizer.scala. <br></p><br><p>  Aqui est√° um pequeno trecho de uma longa lista de otimiza√ß√µes dispon√≠veis: <br></p><br><pre> <code class="hljs perl">def batches: Se<span class="hljs-string"><span class="hljs-string">q[Batch]</span></span> = { val operatorOptimizationRuleSet = Se<span class="hljs-string"><span class="hljs-string">q( // Operator push down PushProjectionThroughUnion, ReorderJoin, EliminateOuterJoin, PushPredicateThroughJoin, PushDownPredicate, LimitPushDown, ColumnPruning, InferFiltersFromConstraints, // Operator combine CollapseRepartition, CollapseProject, CollapseWindow, CombineFilters, CombineLimits, CombineUnions, // Constant folding and strength reduction NullPropagation, ConstantPropagation, ........</span></span></code> </pre><br><p>  Deve-se observar que a lista dessas otimiza√ß√µes inclui otimiza√ß√µes baseadas em regras e otimiza√ß√µes baseadas em estimativas de custo de consulta, que ser√£o discutidas abaixo. <br></p><br><p>  Um recurso do CBO √© que, para a opera√ß√£o correta, ele precisa conhecer e armazenar informa√ß√µes sobre as estat√≠sticas dos dados usados ‚Äã‚Äãna consulta - o n√∫mero de registros, tamanho do registro, histogramas de distribui√ß√£o de dados nas colunas da tabela. <br></p><br><p>  Para coletar estat√≠sticas, um conjunto de comandos SQL ANALYZE TABLE ... COMPUTE STATISTICS √© usado, al√©m disso, √© necess√°rio um conjunto de tabelas para armazenar informa√ß√µes, a API √© fornecida por ExternalCatalog, mais precisamente por HiveExternalCatalog. <br></p><br><p>  Como o CBO est√° atualmente desativado por padr√£o, a √™nfase principal ser√° colocada na pesquisa da otimiza√ß√£o e nuances dispon√≠veis do RBO. <br></p><br><h2>  Tipos e escolha da estrat√©gia de jun√ß√£o </h2><br><p>  No est√°gio de forma√ß√£o do plano f√≠sico para executar a solicita√ß√£o, a estrat√©gia de jun√ß√£o √© selecionada.  As seguintes op√ß√µes est√£o atualmente dispon√≠veis no Spark (voc√™ pode come√ßar a aprender c√≥digo a partir do c√≥digo no SparkStrategies.scala). <br></p><br><h3>  Associa√ß√£o de hash de transmiss√£o </h3><br><p>  A melhor op√ß√£o √© se uma das partes de jun√ß√£o for pequena o suficiente (o crit√©rio de sufici√™ncia √© definido pelo par√¢metro spark.sql.autoBroadcastJoinThreshold no SQLConf).  Nesse caso, esse lado √© completamente copiado para todos os executores, onde h√° uma jun√ß√£o de hash com a tabela principal.  Al√©m do tamanho, deve-se observar que, no caso de jun√ß√£o externa, apenas o lado externo pode ser copiado; portanto, se poss√≠vel, como a tabela principal no caso de jun√ß√£o externa, voc√™ deve usar a tabela com a maior quantidade de dados. <br></p><br><pre> <code class="hljs pgsql">  ,    ,     <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>      Oracle,   <span class="hljs-comment"><span class="hljs-comment">/*+ broadcast(t1, t2) */</span></span></code> </pre><br><h3>  Classificar jun√ß√£o de mesclagem </h3><br><p>  Com <em>spark.sql.join.preferSortMergeJoin</em> ativado por padr√£o, esse m√©todo √© aplicado por padr√£o se as chaves para jun√ß√£o puderem ser classificadas. <br>  Dos recursos, pode-se notar que, diferentemente do m√©todo anterior, a otimiza√ß√£o da gera√ß√£o de c√≥digo para executar a opera√ß√£o est√° dispon√≠vel apenas para jun√ß√£o interna. <br></p><br><h3>  Misturar aleatoriamente o hash </h3><br><p>  Se as chaves n√£o puderem ser classificadas ou a op√ß√£o de sele√ß√£o da jun√ß√£o de mesclagem de classifica√ß√£o padr√£o estiver desativada, o Catalyst tentar√° aplicar uma jun√ß√£o de hash aleat√≥ria.  Al√©m de verificar as configura√ß√µes, tamb√©m √© verificado se o Spark possui mem√≥ria suficiente para criar um mapa de hash local para uma parti√ß√£o (o n√∫mero total de parti√ß√µes √© definido pela configura√ß√£o de <em>spark.sql.shuffle.partitions</em> ) </p><br><h3>  BroadcastNestedLoopJoin e CartesianProduct </h3><br><p>  No caso em que n√£o h√° possibilidade de compara√ß√£o direta por chave (por exemplo, uma condi√ß√£o como) ou n√£o h√° chaves para unir tabelas, dependendo do tamanho das tabelas, esse tipo ou Produto Cartesiano est√° selecionado. <br></p><br><h3>  A ordem de especificar tabelas em join'ah </h3><br><p>  Em qualquer caso, a jun√ß√£o requer tabelas aleat√≥rias por chave.  Portanto, no momento, a ordem de especifica√ß√£o das tabelas, especialmente no caso de v√°rias jun√ß√µes seguidas, √© importante (se voc√™ √© um orif√≠cio, se o CBO n√£o estiver ativado e a configura√ß√£o JOIN_REORDER_ENABLED n√£o estiver ativada). <br></p><br><p>  Se poss√≠vel, a ordem das tabelas de jun√ß√£o deve minimizar o n√∫mero de opera√ß√µes aleat√≥rias para tabelas grandes, para as quais as jun√ß√µes na mesma chave devem ser seq√ºenciais.  Al√©m disso, n√£o se esque√ßa de minimizar os dados para ingresso, para ativar o ingresso de transmiss√£o de hash. <br></p><br><h2>  Aplica√ß√£o transitiva das condi√ß√µes do filtro </h2><br><p>  Considere a seguinte consulta: <br></p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> bal.account_rk, cust.full_name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> balance bal <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> customer cust <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bal.party_rk = cust.party_rk <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> bal.actual_date = cust.actual_date <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> bal.actual_date = <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(<span class="hljs-string"><span class="hljs-string">'2017-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>)</code> </pre><br><p>  Aqui, conectamos duas tabelas particionadas da mesma maneira, de acordo com o campo actual_date e aplicamos um filtro expl√≠cito apenas √† parti√ß√£o de acordo com a tabela de saldo. <br></p><br><p>  Como pode ser visto no plano de consulta otimizado, o filtro por data tamb√©m √© aplicado ao cliente e, no momento da leitura dos dados do disco, √© determinado que exatamente uma parti√ß√£o √© necess√°ria. <br></p><br><pre> <code class="hljs delphi">== Optimized Logical Plan == Project [account_rk<span class="hljs-string"><span class="hljs-string">#1</span></span>, full_name<span class="hljs-string"><span class="hljs-string">#59</span></span>] +- Join Inner, ((party_rk<span class="hljs-string"><span class="hljs-string">#18</span></span> = party_rk<span class="hljs-string"><span class="hljs-string">#57</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span>)) :- Project [ACCOUNT_RK<span class="hljs-string"><span class="hljs-string">#1</span></span>, PARTY_RK<span class="hljs-string"><span class="hljs-string">#18</span></span>, ACTUAL_DATE<span class="hljs-string"><span class="hljs-string">#27</span></span>] : +- Filter ((isnotnull(actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>)) &amp;&amp; isnotnull(party_rk<span class="hljs-string"><span class="hljs-string">#18</span></span>)) : +- Relation[,... <span class="hljs-number"><span class="hljs-number">4</span></span> more fields] orc +- Project [PARTY_RK<span class="hljs-string"><span class="hljs-string">#57</span></span>, FULL_NAME<span class="hljs-string"><span class="hljs-string">#59</span></span>, ACTUAL_DATE<span class="hljs-string"><span class="hljs-string">#88</span></span>] +- Filter (((actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>) &amp;&amp; isnotnull(actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span>)) &amp;&amp; isnotnull(party_rk<span class="hljs-string"><span class="hljs-string">#57</span></span>)) +- Relation[,... <span class="hljs-number"><span class="hljs-number">9</span></span> more fields] orc</code> </pre><br><p>  Mas voc√™ s√≥ precisa substituir a jun√ß√£o interna pela externa esquerda na consulta, pois o predicado push da tabela do cliente cai imediatamente e ocorre uma varredura completa, o que √© um efeito indesej√°vel. <br></p><br><pre> <code class="hljs delphi">== Optimized Logical Plan == Project [account_rk<span class="hljs-string"><span class="hljs-string">#1</span></span>, full_name<span class="hljs-string"><span class="hljs-string">#59</span></span>] +- Join LeftOuter, ((party_rk<span class="hljs-string"><span class="hljs-string">#18</span></span> = party_rk<span class="hljs-string"><span class="hljs-string">#57</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = actual_date<span class="hljs-string"><span class="hljs-string">#88</span></span>)) :- Project [ACCOUNT_RK<span class="hljs-string"><span class="hljs-string">#1</span></span>, PARTY_RK<span class="hljs-string"><span class="hljs-string">#18</span></span>, ACTUAL_DATE<span class="hljs-string"><span class="hljs-string">#27</span></span>] : +- Filter (isnotnull(actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span>) &amp;&amp; (actual_date<span class="hljs-string"><span class="hljs-string">#27</span></span> = <span class="hljs-number"><span class="hljs-number">17531</span></span>)) : +- Relation[,... <span class="hljs-number"><span class="hljs-number">4</span></span> more fields] orc +- Project [PARTY_RK<span class="hljs-string"><span class="hljs-string">#57</span></span>, FULL_NAME<span class="hljs-string"><span class="hljs-string">#59</span></span>, ACTUAL_DATE<span class="hljs-string"><span class="hljs-string">#88</span></span>] +- Relation[,... <span class="hljs-number"><span class="hljs-number">9</span></span> more fields] orc</code> </pre><br><h2>  Convers√£o de tipo </h2><br><p>  Considere um exemplo simples de sele√ß√£o de uma tabela com filtragem por tipo de cliente. No esquema, o tipo do campo party_type √© string. <br></p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> party_rk, full_name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cust <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> actual_date = cast(<span class="hljs-string"><span class="hljs-string">'2017-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> party_type = <span class="hljs-number"><span class="hljs-number">101</span></span> <span class="hljs-comment"><span class="hljs-comment">--   -- and party_type = '101' --    </span></span></code> </pre><br><p>  E compare os dois planos resultantes, o primeiro - quando nos referimos ao tipo incorreto (haver√° uma convers√£o impl√≠cita para int), o segundo - quando o tipo corresponde ao esquema. <br></p><br><pre> <code class="hljs powershell">PushedFilters: [<span class="hljs-type"><span class="hljs-type">IsNotNull</span></span>(<span class="hljs-type"><span class="hljs-type">PARTY_TYPE</span></span>)] //            . PushedFilters: [<span class="hljs-type"><span class="hljs-type">IsNotNull</span></span>(<span class="hljs-type"><span class="hljs-type">PARTY_TYPE</span></span>), <span class="hljs-type"><span class="hljs-type">EqualTo</span></span>(<span class="hljs-type"><span class="hljs-type">PARTY_TYPE</span></span>,<span class="hljs-number"><span class="hljs-number">101</span></span>)] //             .</code> </pre><br><p>  Um problema semelhante √© observado no caso de comparar datas com uma sequ√™ncia, haver√° um filtro para comparar as sequ√™ncias.  Um exemplo: <br></p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">where</span></span> OPER_DATE = <span class="hljs-string"><span class="hljs-string">'2017-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> (isnotnull(oper_date#<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (cast(oper_date#<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> string) = <span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-12</span></span><span class="hljs-number"><span class="hljs-number">-31</span></span>) PushedFilters: [IsNotNull(OPER_DATE)] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> OPER_DATE = cast(<span class="hljs-string"><span class="hljs-string">'2017-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>) PushedFilters: [IsNotNull(OPER_DATE), EqualTo(OPER_DATE,<span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-12</span></span><span class="hljs-number"><span class="hljs-number">-31</span></span>)]</code> </pre><br><p>  No caso em que uma convers√£o impl√≠cita de tipo √© poss√≠vel, por exemplo, int -&gt; decimal, o otimizador faz isso por conta pr√≥pria. <br></p><br><h2>  Pesquisa adicional </h2><br><p>  Muitas informa√ß√µes interessantes sobre os "bot√µes" que podem ser usados ‚Äã‚Äãpara ajustar o Catalyst, bem como sobre as possibilidades (presente e futura) do otimizador, podem ser obtidas no SQLConf.scala. <br></p><br><p>  Em particular, como voc√™ pode ver por padr√£o, o otimizador de custos ainda est√° desativado no momento. <br></p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">CBO_ENABLED</span></span> = buildConf(<span class="hljs-string"><span class="hljs-string">"spark.sql.cbo.enabled"</span></span>) .doc(<span class="hljs-string"><span class="hljs-string">"Enables CBO for estimation of plan statistics when set true."</span></span>) .booleanConf .createWithDefault(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><p>  Bem como suas otimiza√ß√µes dependentes associadas √† reordena√ß√£o de join'ov. <br></p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">JOIN_REORDER_ENABLED</span></span> = buildConf(<span class="hljs-string"><span class="hljs-string">"spark.sql.cbo.joinReorder.enabled"</span></span>) .doc(<span class="hljs-string"><span class="hljs-string">"Enables join reorder in CBO."</span></span>) .booleanConf .createWithDefault(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><p>  ou </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">STARSCHEMA_DETECTION</span></span> = buildConf(<span class="hljs-string"><span class="hljs-string">"spark.sql.cbo.starSchemaDetection"</span></span>) .doc(<span class="hljs-string"><span class="hljs-string">"When true, it enables join reordering based on star schema detection. "</span></span>) .booleanConf .createWithDefault(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><h2>  Breve resumo </h2><br><p>  Apenas uma pequena parte das otimiza√ß√µes existentes foi tocada; experimentos com otimiza√ß√£o de custos, que podem dar muito mais espa√ßo para a convers√£o de consultas, est√£o √† frente.  Al√©m disso, uma quest√£o interessante e separada √© a compara√ß√£o de um conjunto de otimiza√ß√µes ao ler arquivos do Parquet e Orc, a julgar pelo jira do projeto, trata-se de paridade, mas √© mesmo? <br></p><br><p>  Al√©m disso: </p><br><ul><li>  A an√°lise e otimiza√ß√£o de solicita√ß√µes √© interessante e empolgante, principalmente considerando a disponibilidade de c√≥digos-fonte. </li><li>  A inclus√£o do CBO fornecer√° espa√ßo para novas otimiza√ß√µes e pesquisas. </li><li>  √â necess√°rio monitorar a aplicabilidade das regras b√°sicas que permitem filtrar o m√°ximo de dados "extras" poss√≠vel nos est√°gios mais iniciais poss√≠veis. </li><li>  A associa√ß√£o √© um mal necess√°rio, mas, se poss√≠vel, vale a pena minimiz√°-los e acompanhar qual implementa√ß√£o √© usada sob o cap√¥. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417103/">https://habr.com/ru/post/pt417103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417091/index.html">Crie um sombreador de √°gua de desenho animado para a web. Parte 3</a></li>
<li><a href="../pt417093/index.html">Interruptores sens√≠veis ao toque com Modbus: por que eles s√£o necess√°rios e como aplic√°-los em um apartamento inteligente</a></li>
<li><a href="../pt417097/index.html">Metaprograma√ß√£o JavaScript</a></li>
<li><a href="../pt417099/index.html">Como eu escrevi a biblioteca C ++ 11 padr√£o ou por que o impulso √© t√£o assustador? Cap√≠tulo 2</a></li>
<li><a href="../pt417101/index.html">Defini√ß√£o de Ready - O que esquecemos de contar</a></li>
<li><a href="../pt417105/index.html">Imprimindo em uma impressora 3D. Experi√™ncias secretas do 3Dtool</a></li>
<li><a href="../pt417107/index.html">Criador do jogo enquanto True: aprenda () sobre programa√ß√£o de gamedev, problemas de VR e simula√ß√µes de ML</a></li>
<li><a href="../pt417109/index.html">Richard Hamming: Cap√≠tulo 10. Teoria da Codifica√ß√£o - I</a></li>
<li><a href="../pt417111/index.html">Confer√™ncias online: streaming vs webinar</a></li>
<li><a href="../pt417113/index.html">Impressora 3D italiana na R√∫ssia: Raise3D N1 Dual - modelagem e prototipagem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>