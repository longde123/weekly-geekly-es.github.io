<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîê üçä ‚úçüèø Encapsulamento para samurais reais ou as nuances associadas √† palavra-chave interna em C # üíó ‚òùüèø üöµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo: interno √© novo p√∫blico 


 Cada um de n√≥s sonhava com um projeto onde tudo seria feito corretamente. Parece bastante natural. Assim que voc√™ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encapsulamento para samurais reais ou as nuances associadas √† palavra-chave interna em C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Pr√≥logo: interno √© novo p√∫blico </h2><br><p>  Cada um de n√≥s sonhava com um projeto onde tudo seria feito corretamente.  Parece bastante natural.  Assim que voc√™ aprende sobre a possibilidade de escrever um bom c√≥digo, assim que ouve lendas sobre o mesmo c√≥digo que pode ser facilmente lido e modificado, voc√™ se ilumina imediatamente: "Bem, agora eu vou fazer isso direito, sou inteligente e leio McConnell". </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="imagem"><br><br><p>  Esse projeto aconteceu na minha vida.  Outro.  E estou fazendo isso sob supervis√£o volunt√°ria, onde cada linha que eu sigo.  Consequentemente, n√£o apenas eu queria, mas tamb√©m precisava fazer tudo certo.  Um dos "direitos" era "respeitar o encapsulamento e quase o m√°ximo, porque voc√™ sempre tem tempo para abrir e ser√° tarde demais para fechar".  E, portanto, onde quer que eu pudesse, comecei a usar o modificador de acesso interno em vez de p√∫blico para as aulas.  E, √© claro, quando voc√™ come√ßa a usar ativamente um novo recurso de idioma para voc√™, surgem algumas nuances.  Eu quero falar sobre eles em ordem. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Ajuda b√°sica ofensiva</b> <div class="spoiler_text"><p>  Apenas para lembrar e rotular. </p><br><ul><li>  Assembly √© a menor unidade de implanta√ß√£o no .NET e uma das unidades b√°sicas de compila√ß√£o.  Como √©, isso √© .dll ou .exe.  Eles dizem que pode ser dividido em v√°rios arquivos chamados m√≥dulos. </li><li>  modificador de acesso p√∫blico, o que significa que √© acess√≠vel a todos marcados com ele. </li><li>  modificador de acesso interno, o que significa que ele est√° marcado apenas dispon√≠vel dentro da montagem. </li><li>  protected - um modificador de acesso que indica que est√° marcado apenas dispon√≠vel para os herdeiros da classe em que o marcado est√° localizado. </li><li>  private - um modificador de acesso que indica que est√° marcado apenas dispon√≠vel para a classe em que est√° localizado.  E mais ningu√©m. </li></ul><br></div></div><br><h2>  Testes de unidade e constru√ß√µes amig√°veis </h2><br><p>  No C ++, havia um recurso t√£o estranho quanto as classes amig√°veis.  As turmas podiam ser designadas como amigas e, em seguida, a fronteira do encapsulamento entre elas era apagada.  Eu suspeito que esse n√£o seja o recurso mais estranho em C ++.  Talvez at√© os dez mais estranhos n√£o estejam inclu√≠dos.  Mas dar um tiro no p√© vinculando v√°rias classes com for√ßa √© algo f√°cil demais e √© muito dif√≠cil encontrar um caso adequado para esse recurso. </p><br><p>  O mais surpreendente foi saber que no .NET existem assembl√©ias amig√°veis, uma esp√©cie de repensar.  Ou seja, voc√™ pode fazer uma montagem ver o que est√° oculto atr√°s da trava interna em outra montagem.  Quando descobri isso, fiquei um pouco surpreso.  Bem, como seria, por qu√™?  Qual √© o objetivo?  Quem amarrar√° firmemente as duas assembl√©ias, envolvidas em sua separa√ß√£o?  Casos em que, em qualquer situa√ß√£o incompreens√≠vel, eles moldam o p√∫blico, n√£o consideramos neste artigo. </p><br><p>  E ent√£o, no mesmo projeto, comecei a aprender um dos ramos do caminho de um samurai real: teste de unidade.  E no Feng Shui, os testes de unidade devem ser realizados em uma montagem separada.  Para o mesmo Feng Shui, tudo o que pode ser escondido dentro da montagem, voc√™ precisa se esconder dentro da montagem.  Enfrentei uma escolha muito, muito desagrad√°vel.  Os testes ficar√£o lado a lado e v√£o para o cliente junto com o c√≥digo √∫til para ele, ou tudo ser√° coberto pela palavra-chave public, h√° quanto tempo o p√£o permanece na umidade. </p><br><p>  E aqui, de algum lugar nas caixas da minha mem√≥ria, algo foi obtido sobre assembl√©ias amig√°veis.  Aconteceu que, se voc√™ tiver a montagem "YourAssemblyName", poder√° escrever assim: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  E o assembly "YourAssemblyName.Tests" ver√° o que est√° marcado com a palavra-chave interna em "YourAssemblyName".  Essa linha pode ser inserida, apenas um pouco, em AssemblyInfo.cs, que o VS cria especificamente para armazenar esses atributos. </p><br><div class="spoiler">  <b class="spoiler_title">Retornar abusivo √† ajuda b√°sica</b> <div class="spoiler_text">  No .NET, al√©m de atributos ou palavras-chave j√° incorporados, como abstrato, p√∫blico, interno, est√°tico, voc√™ pode criar seus pr√≥prios.  E pendure-os no que quiser: campos, propriedades, classes, m√©todos, eventos e montagens inteiras.  Em C #, para isso, basta escrever o nome do atributo entre colchetes antes do que voc√™ espera.  A exce√ß√£o √© o pr√≥prio assembly, pois n√£o h√° indica√ß√£o direta em nenhum lugar do c√≥digo que "Assembly come√ßa aqui".  L√°, antes do nome do atributo, voc√™ precisa adicionar o assembly: <br></div></div><br><p>  Assim, os lobos permanecem cheios, as ovelhas est√£o seguras, tudo o que √© poss√≠vel ainda est√° escondido dentro da assembl√©ia, os testes de unidade vivem em uma assembl√©ia separada, como deveria ser, e um recurso que eu mal lembrava tem um motivo para us√°-lo.  Talvez a √∫nica raz√£o existente. </p><br><p>  Eu quase esqueci um ponto importante.  A a√ß√£o de atributo InternalsVisibleTo √© unidirecional. </p><br><h2>  protegido &lt;interno? </h2><br><p>  Ent√£o a situa√ß√£o: A e B estavam sentados em um cano. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A foi destru√≠do no processo de revis√£o de c√≥digo, uma vez que n√£o √© usado fora do assembly, mas por algum motivo se permite ter um modificador de acesso p√∫blico, B causou um erro de compila√ß√£o, o que poderia levar a um estupor nos primeiros minutos. </p><br><p>  Basicamente, a mensagem de erro √© l√≥gica.  O acessador de propriedade n√£o pode revelar mais do que a pr√≥pria propriedade.  Qualquer pessoa reagir√° com compreens√£o se o compilador fornecer um cabe√ßalho para isso: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Mas reivindica√ß√µes a essa linha quebram imediatamente o c√©rebro: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Observo que n√£o haver√° queixas sobre esta linha: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Se voc√™ n√£o pensa muito, a seguinte hierarquia √© criada em sua cabe√ßa: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  E essa hierarquia parece funcionar.  Exceto por um lugar.  Onde interno&gt; protegido.  Para entender a ess√™ncia das declara√ß√µes do compilador, lembre-se de quais restri√ß√µes s√£o impostas por interno e protegido.  interno - somente dentro da montagem.  protegido - apenas herdeiros.  Observe qualquer herdeiro.  E se a classe B estiver marcada como p√∫blica, em outra montagem voc√™ poder√° definir seus descendentes.  E ent√£o o acessador definido realmente obt√©m acesso a onde toda a propriedade n√£o a possui.  Como o compilador C # √© paran√≥ico, ele n√£o pode sequer permitir essa possibilidade. </p><br><p>  Obrigado a ele por isso, mas precisamos dar aos herdeiros acesso ao assessor.  E especificamente para esses casos, h√° um modificador de acesso interno protegido. </p><br><div class="spoiler">  <b class="spoiler_title">Essa ajuda n√£o √© t√£o ofensiva</b> <div class="spoiler_text"><ul><li>  interno protegido - um modificador de acesso que indica que o marcado est√° dispon√≠vel dentro da montagem <strong>ou para os</strong> herdeiros da classe em que o marcado est√° localizado. </li></ul><br></div></div><br><p>  Portanto, se queremos que o compilador nos permita usar essa propriedade e configur√°-la nos herdeiros, precisamos fazer o seguinte: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  E a hierarquia correta dos modificadores de acesso se parece com isso: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Interfaces </h2><br><p>  Ent√£o, a situa√ß√£o: A, eu, B est√°vamos sentados no cano. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Sentamos exatamente e n√£o nos metemos do lado de fora da assembl√©ia.  Mas eles foram rejeitados pelo compilador.  Aqui a ess√™ncia das reivindica√ß√µes √© clara na mensagem de erro.  A implementa√ß√£o da interface deve estar aberta.  Mesmo se a pr√≥pria interface estiver fechada.  Seria l√≥gico vincular o acesso √† implementa√ß√£o da interface √† sua disponibilidade, mas o que n√£o √©, n√£o √©.  A implementa√ß√£o da interface deve ser p√∫blica. </p><br><p>  E n√≥s temos duas maneiras de sair.  Primeiro: atrav√©s do rangido e ranger de dentes, pendure um modificador de acesso p√∫blico na implementa√ß√£o da interface.  Segundo: implementa√ß√£o expl√≠cita da interface.  √â assim: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Observe que, no segundo caso, n√£o h√° modificador de acesso.  Para quem, neste caso, est√° dispon√≠vel a implementa√ß√£o do m√©todo?  Vamos apenas dizer ningu√©m.  √â mais f√°cil mostrar com um exemplo: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  A implementa√ß√£o expl√≠cita da interface I significa que, at√© lan√ßarmos explicitamente a vari√°vel para o tipo I, n√£o h√° m√©todos que implementem essa interface.  Escrever (b como I) .SomeMethod () toda vez pode ser uma sobrecarga.  Como (I) b) .AlgumM√©todo ().  E eu encontrei duas maneiras de contornar isso.  Eu mesmo pensei em um e pesquisei honestamente no segundo. </p><br><p>  A primeira maneira √© a f√°brica: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Bem, ou qualquer outro padr√£o que permita ocultar essa nuance. </p><br><p>  M√©todo dois - m√©todos de extens√£o: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  Surpreendentemente, funciona.  Estas linhas param de gerar um erro: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Afinal, a chamada chega, como o IntelliSense nos diz no Visual Studio, n√£o para m√©todos para implementar explicitamente a interface, mas para m√©todos de extens√£o.  E ningu√©m pro√≠be recorrer a eles.  E os m√©todos de extens√£o de interface podem ser chamados em todas as suas implementa√ß√µes. </p><br><p>  Mas resta uma ressalva.  Dentro da pr√≥pria classe, voc√™ precisa acessar esse m√©todo atrav√©s da palavra-chave this; caso contr√°rio, o compilador n√£o entender√° que queremos nos referir ao m√©todo de extens√£o: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  E assim, e assim, temos ou p√∫blico, onde n√£o deveria estar, mas <em>parece</em> que n√£o faz mal, ou um pouco de c√≥digo extra para cada interface interna.  Escolha o mal menor ao seu gosto. </p><br><h2>  Reflex√£o </h2><br><p>  Eu bati isso dolorosamente quando tentei encontrar um construtor atrav√©s da reflex√£o, que, √© claro, foi marcada como interna na classe interna.  E aconteceu que a reflex√£o n√£o divulgaria nada que n√£o fosse p√∫blico.  E isso, em princ√≠pio, √© l√≥gico. </p><br><p>  Em primeiro lugar, reflex√£o, se me lembro corretamente do que as pessoas inteligentes escreveram nos livros inteligentes, trata-se de encontrar informa√ß√µes nos metadados da montagem.  O que, em teoria, n√£o deve dar muito (pelo menos eu pensava).  Em segundo lugar, o principal uso da reflex√£o √© tornar seu programa extens√≠vel.  Voc√™ fornece algum tipo de interface para pessoas de fora (talvez at√© na forma de interfaces, fiy-ha!).  E eles o implementam e fornecem plugins, mods, extens√µes na forma de uma montagem carregada em movimento, a partir da qual a reflex√£o os obt√©m.  E por si s√≥, sua API ser√° p√∫blica.  Ou seja, olhar para a reflex√£o interna n√£o √© tecnicamente e sem sentido de um ponto de vista pr√°tico. </p><br><p>  <strong>Update</strong>  Aqui, nos coment√°rios, descobriu-se que a reflex√£o permite, se voc√™ pedir explicitamente, refletir tudo.  Seja interno, privado.  Se voc√™ n√£o est√° escrevendo algum tipo de ferramenta de an√°lise de c√≥digo, tente n√£o fazer isso, por favor.  O texto abaixo ainda √© relevante para os casos em que estamos procurando tipos de membros abertos.  E, em geral, n√£o passe coment√°rios, h√° muitas coisas interessantes. </p><br><p>  Isso pode ser conclu√≠do com reflex√£o, mas vamos retornar ao exemplo anterior, onde A, I, B estavam sentados em um cano: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  O autor da classe A decidiu que nada de ruim aconteceria se o m√©todo da classe interna fosse marcado como p√∫blico, para que o compilador n√£o doesse e para que n√£o houvesse necessidade de colocar mais c√≥digo nele.  A interface √© marcada como interna, a classe que a implementa √© marcada como interna; de fora, parece que n√£o h√° como acessar o m√©todo marcado como p√∫blico. </p><br><p>  E ent√£o a porta se abre e o reflexo entra silenciosamente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Estude este c√≥digo, leve-o para o est√∫dio, se desejar.  Aqui, estamos tentando usar a reflex√£o para encontrar todos os m√©todos de todos os tipos de nosso pipe (namespace Pipe).  E aqui est√£o os resultados que ele nos fornece: </p><br><blockquote>  No tipo I, encontramos Void SomeMethod () <br>  NULL!  N√£o √© poss√≠vel encontrar o m√©todo SomeMethod no tipo IExtensions <br>  No tipo A, encontramos Void SomeMethod () <br>  NULL!  N√£o √© poss√≠vel encontrar o m√©todo OtherMethod no tipo A <br>  NULL!  N√£o √© poss√≠vel encontrar o m√©todo SomeMethod no tipo B <br>  NULL!  N√£o √© poss√≠vel encontrar o m√©todo OtherMethod no tipo B <br></blockquote><br><p>  Devo dizer imediatamente que, usando um objeto do tipo MethodInfo, o m√©todo encontrado pode ser chamado.  Ou seja, se a reflex√£o encontrou algo, o encapsulamento pode ser violado puramente teoricamente.  E n√≥s encontramos algo.  Em primeiro lugar, o mesmo p√∫blico anula SomeMethod () da classe A. Era esperado, o que mais dizer.  Essa indulg√™ncia ainda pode ter consequ√™ncias.  Em segundo lugar, anule SomeMethod () da interface I. Isso j√° √© mais interessante.  N√£o importa como nos trancemos, os m√©todos abstratos colocados na interface (ou o que o CLR realmente coloca l√°) est√£o realmente abertos.  Da√≠ a conclus√£o feita em um par√°grafo separado: </p><br><p>  <em>Observe com cuidado quem e que tipo de System.Type voc√™ est√° dando.</em> </p><br><p>  Mas h√° mais uma nuance com esses dois m√©todos encontrados, que eu gostaria de considerar.  M√©todos de interface interna e m√©todos p√∫blicos de classes internas podem ser encontrados usando reflex√£o.  Como uma pessoa razo√°vel, concluirei que eles se enquadram nos metadados.  Como pessoa experiente, vou verificar esta conclus√£o.  E neste ILDasm nos ajudar√°. </p><br><div class="spoiler">  <b class="spoiler_title">D√™ uma olhada na toca do coelho nos metadados do nosso cachimbo</b> <div class="spoiler_text"><p>  Montagem foi montada em Release </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Uma r√°pida olhada mostra que <strong>tudo</strong> entra nos metadados, n√£o importa como estejam marcados.  A reflex√£o ainda cuidadosamente esconde de n√≥s o que n√£o se deve ver de fora.  Portanto, pode ser que as cinco linhas de c√≥digo extras para cada m√©todo da interface interna n√£o sejam um grande mal.  No entanto, a principal conclus√£o permanece a mesma: </p><br><p>  <em>Observe com cuidado quem e que tipo de System.Type voc√™ est√° dando.</em> </p><br><p>  Mas este √©, obviamente, o pr√≥ximo n√≠vel, ap√≥s a ades√£o da palavra-chave interna em todos os lugares onde n√£o h√° necessidade de p√∫blico. </p><br><h2>  PS </h2><br><p>  Voc√™ sabe que a coisa mais legal sobre o uso da palavra-chave interna est√° em todo lugar na montagem?  Quando cresce, voc√™ precisa dividi-lo em dois ou mais.  E no processo, voc√™ precisa fazer uma pausa para abrir alguns tipos.  E voc√™ precisa pensar exatamente sobre quais tipos merecem ser abertos.  Pelo menos brevemente. </p><br><p>  Isso significa o seguinte: <em>essa pr√°tica de escrever c√≥digo far√° voc√™ pensar novamente sobre o formato da fronteira arquitet√¥nica entre as assembl√©ias rec√©m-nascidas.</em>  O que poderia ser mais bonito? </p><br><h2>  PPS </h2><br><p>  Come√ßando com a vers√£o C # 7.2, um novo modificador de acesso, protegido privado, apareceu.  E ainda n√£o tenho ideia do que √© e do que √© comido.  Desde que n√£o encontrado na pr√°tica.  Mas ficarei feliz em saber nos coment√°rios.  Mas n√£o copie e cole da documenta√ß√£o, mas casos reais em que esse modificador de acesso pode ser necess√°rio. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445804/">https://habr.com/ru/post/pt445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445794/index.html">Gigantes de TI revelam uma solu√ß√£o h√≠brida de implanta√ß√£o de nuvem h√≠brida</a></li>
<li><a href="../pt445796/index.html">Fintech Digest: Dorsey paga com bitcoins, estrat√©gia de blockchain da Austr√°lia, IPO da Levi, prefeito de Chicago e a inevitabilidade do bitcoin</a></li>
<li><a href="../pt445798/index.html">Rinoceronte dentro do gato - execute o firmware no emulador Kopycat</a></li>
<li><a href="../pt445800/index.html">M√¥nadas em 15 minutos</a></li>
<li><a href="../pt445802/index.html">5 coisas que tend√™ncias da Internet que todos deveriam conhecer</a></li>
<li><a href="../pt445806/index.html">Como a intelig√™ncia artificial est√° mudando a ci√™ncia</a></li>
<li><a href="../pt445808/index.html">N√≥s odiamos e ca√ßamos: a vida perigosa de um cracker de v√≠rus que est√° fazendo inimigos poderosos</a></li>
<li><a href="../pt445814/index.html">Como um rob√¥ de entrega mudou os h√°bitos culin√°rios dos estudantes americanos</a></li>
<li><a href="../pt445816/index.html">Como vimos a renderiza√ß√£o do servidor e o que aconteceu</a></li>
<li><a href="../pt445820/index.html">MVCC-3. Vers√µes de linha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>