<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 👩🏼‍🔧 💈 10 plugins PostCSS que economizarão seu tempo de layout 🖖🏽 ♈️ 👋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nós, o front-end, temos uma categoria de ferramentas que não resolvem os problemas que estamos enfrentando, mas afetam o processo de resolvê-los. Mude...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 plugins PostCSS que economizarão seu tempo de layout</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457340/"><p><img src="https://habrastorage.org/webt/1b/7_/el/1b7_elrk3cworvip4qutltld9to.jpeg"></p><br><p>  Nós, o front-end, temos uma categoria de ferramentas que não resolvem os problemas que estamos enfrentando, mas afetam o processo de resolvê-los.  Mude isso.  A atitude em relação a essas ferramentas é muito diferente - a partir da mania no espírito de "vamos empurrar essa coisa para todo lado, é muito legal" e termina com desculpas como "se não resolver o problema de negócios, não precisaremos disso".  Mas, enfim, hoje falaremos sobre o PostCSS - uma dessas ferramentas. </p><br><p>  A onda de hype passou muito tempo; nos últimos anos, muito pouco foi dito sobre o PostCSS.  Muitos iniciantes nem sabem o que é.  Acho que é hora de olhar para essa ferramenta do ponto de vista do uso prático nos projetos mais comuns, onde as pessoas resolvem problemas e não brincam com as tecnologias da moda. </p><a name="habracut"></a><br><h2 id="postcss-vs-sass">  PostCSS vs SASS </h2><br><p> Oh ... Aparentemente, algumas palavras sobre isso.  Acho que agora um tipógrafo raro não se encontra com pré-processadores.  O SASS ou o meu LESS favorito, com menos frequência, são usados ​​tanto em projetos grandes quanto em pequenos.  Alguém está tentando tirar o máximo proveito deles, alguém usa um conjunto minimalista - aninhamento, variáveis, importações.  Mas, de uma maneira ou de outra, essas ferramentas ajudam com problemas de sintaxe.  Eles facilitam a escrita de código. </p><br><p>  Cerca de dois ou três anos atrás, o PostCSS era constantemente comparado aos pré-processadores.  E isso é compreensível.  Formalmente, usando-o, você pode fazer a mesma coisa, criar algum tipo de sintaxe que será mais conveniente que o CSS puro.  Mas tudo isso causou uma massa fervente, principalmente porque todos com a ajuda do PostCSS fizeram algo diferente.  Inúmeros plugins desconhecidos, milhões de combinações e, além do autor desta ou daquela configuração, ninguém entendeu como funciona e o que faz.  É como o Vim ou o Emacs - você pode criar uma espaçonave com eles, mas será muito difícil ensinar outro desenvolvedor a usá-lo. </p><br><p>  Mas se descartarmos essas comparações, o PostCSS é uma ferramenta que nos permite pegar nosso CSS e fazer algo com ele.  Ninguém se preocupa em usar o SASS por causa da sintaxe e, após a montagem, cole o PostCSS e faça algo com o resultado.  Eles não se contradizem. </p><br><h2 id="staroe--ne-znachit-nerabotayuschee">  Velho não significa ocioso </h2><br><p>  Recentemente, foi moda para nós criar combinações que podem fazer tudo o que vem à mente e seu desenvolvimento nunca para.  E se não houver confirmações novas no repositório por alguns meses, tudo - podemos assumir que está desatualizado e agora usá-lo - não comemos il faut.  Exagerarei, é claro, mas acho que você percebeu o quão absurdo isso às vezes acontece. </p><br><p>  No mundo PostCSS, geralmente um plugin resolve um problema.  Você pode ver elementos da filosofia Unix aqui.  Uma conclusão lógica se segue - se o plug-in já está resolvendo sua tarefa, nada mais precisa ser feito com ele.  Você pode encontrar plug-ins que não são atualizados há anos, mas isso não significa que eles pararam subitamente de resolver as tarefas para as quais foram criados. </p><br><p>  Mas vamos começar ... Eu montei uma dúzia de plug-ins, que na prática mostraram sua capacidade de simplificar a vida dos designers de layout e economizar tempo durante o desenvolvimento.  Mas você sempre pode adicionar algo nos comentários. </p><br><h2 id="1-doiuse">  No. 1.  Doiuse </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/anandthakker/doiuse</a> </p><br><p>  Acho que todos enfrentamos esse problema: você escreve o código, verifica o chrome - está tudo bem.  Você faz o check-in FF - aprox.  E então, no Safari móvel, tudo desmorona.  Ou no Edge.  E você senta e não entende o que está errado.  Então você fica olhando o código por um longo tempo, tomando chá e, de repente, percebe-se que algumas propriedades não são suportadas em algum navegador.  Você segue em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">frente</a> e vê a confirmação do óbvio. </p><br><p><img src="https://habrastorage.org/webt/pm/dy/lw/pmdylwl6g5ahftjlsoikrqyckec.png"></p><br><p>  Obviamente, com a experiência, as próprias mãos lembram quais propriedades devem ser evitadas, mas tudo acontece.  Você não consegue dormir o suficiente, pode haver prazos e nervos apertados, a lista de navegadores que precisam ser alterados pode mudar.  E então a experiência começará a falhar.  Doiuse é uma ferramenta que ajuda muito nessas situações. </p><br><p>  O princípio de operação é simples - fornecemos a ele uma lista de navegadores e nosso CSS.  O plug-in vai para o banco de dados caniuse e em tempo real nos dá a resposta que usamos do que não é suportado. </p><br><p>  Podemos definir a lista de navegadores diretamente no package.json.  Simples e conveniente.  O PostCSS usa a lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">navegadores</a> e, se você ainda não viu, é algo parecido com isto: </p><br><pre><code class="plaintext hljs">"browserslist": [ "&gt; .5% and last 2 versions", "not dead", "not OperaMini all", "ie &gt;= 11", "Edge &gt;= 12" ]</code> </pre> <br><p>  Há também uma configuração do douse em que você pode forçá-lo a ignorar alguns grupos de propriedades se tiver certeza de que isso não afeta nada.  Por exemplo, se você usar polyfiles ou com a perda de suporte de alguma propriedade, nada será alterado: </p><br><pre> <code class="plaintext hljs">ignore: [ 'will-change', 'object-fit' ]</code> </pre> <br><p>  O log padrão fornecido pelo plug-in não é muito legível.  Ele contém muitas informações e não é muito conveniente percebê-las.  Mas isso é corrigível.  Na mesma configuração, podemos fazer nossa função para criar um log. </p><br><blockquote>  Use console.log para descobrir como o objeto que passa o PostCSS para essa função funciona.  Há muitas coisas interessantes. </blockquote><p>  Minha prática mostrou que a opção mais conveniente é exibir seletores e propriedades específicas que não são suportadas, sem especificar navegadores e linhas de código.  Se o projeto usa o BEM ou alguns análogos, e o código do componente é distribuído em arquivos separados, essa abordagem permite encontrar rapidamente um local problemático sem carregar o cérebro. </p><br><pre> <code class="javascript hljs">onFeatureUsage(info) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = info.usage.parent.selector; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.prop}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.value}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status = info.featureData.caniuseData.status.toUpperCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.missing) { status = <span class="hljs-string"><span class="hljs-string">'NOT SUPPORTED'</span></span>.red; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.partial) { status = <span class="hljs-string"><span class="hljs-string">'PARTIAL SUPPORT'</span></span>.yellow; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">:\n\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selector}</span></span></span><span class="hljs-string"> {\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property}</span></span></span><span class="hljs-string">;\n }\n`</span></span>); }</code> </pre> <br><p>  Para não escrever seqüências especiais de caracteres para cores no console, você pode conectar o pacote de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cores</a> , será mais conveniente. </p><br><p>  Ao criar, haverá algo parecido com isto no console: </p><br><pre> <code class="plaintext hljs">NOT SUPPORTED: html { -ms-text-size-adjust: 100%; } NOT SUPPORTED: html { -webkit-text-size-adjust: 100%; } PARTIAL SUPPORT: body { display: flex; }</code> </pre> <br><h2 id="2-autoprefixer">  No. 2.  Autoprefixer </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/postcss/autoprefixer</a> </p><br><p>  É até embaraçoso falar sobre ele, mas muitas vezes vejo pessoas que em 2019 escrevem prefixos com as mãos e ainda asseguram aos outros que sabem exatamente quais são necessários e quais não são.  Tais ações levam ao fato de que o código está cheio de vários prefixos desnecessários e se torna completamente ilegível.  Isso afeta a produtividade do trabalho.  Por outro lado, se você precisar do apoio de dinossauros, sempre poderá esquecer algo.  Portanto, vale a pena se livrar do trabalho manual ao resolver esse problema. </p><br><p>  O autoprefixer funciona com o mesmo banco de dados caniuse, usa a mesma lista de navegadores e pode adicionar ao CSS os prefixos realmente necessários nos navegadores especificados.  Ao mesmo tempo, o próprio código fica mais limpo e o trabalho é mais rápido. </p><br><h2 id="3-stylelint">  Número 3.  Stylelint </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/stylelint/stylelint</a> </p><br><p>  Quando você imprime muito e rapidamente, mais cedo ou mais tarde você começa a cometer muitos erros sem notá-los completamente.  O olho está embaçado.  No caso do CSS, isso pode dar um efeito engraçado (na verdade não) quando você olha no navegador - você vê um problema com o layout.  Você olha o código - ele não está lá.  Você olha no navegador - é.  Mas no código - não.  Como resultado, você pode procurar um problema difícil por um longo período de tempo, sem perceber que acabou de entender.  Para evitar isso, inventou a linter. </p><br><p>  Stylelint é uma opção popular.  Ele sabe trabalhar com a sintaxe dos principais pré-processadores, conhece as últimas tendências em CSS, pode personalizá-lo a seu gosto - as configurações são semelhantes às do eslint.  Formalmente, essa ferramenta pode ser usada por si só, sem PostCSS, mas sem mencionar aqui, seria errado. </p><br><h2 id="4-postcss-flexbugs-fixes">  Número 4.  Postcss-flexbugs-fixes </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/luisrudge/postcss-flexbugs-fixes</a> </p><br><p>  Ou em um sentido mais amplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postcss-fixes</a> , que inclui este plugin.  Lentas, mas seguramente, as flexões suplantam a antiga abordagem do layout em carros alegóricos.  Isso é bom, mas todos sabemos que muitos bugs estão associados a eles.  Eles são descritos no repositório <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">flexbugs</a> .  Alguns deles requerem atenção especial, mas há também alguns que são tão simples que constantemente saem da sua cabeça.  Por exemplo, o IE ignora a função calc na abreviação da propriedade flex.  Isso nem sempre é necessário, mas, se necessário, suas mãos podem escrever uma versão resumida e você precisa pensar por um longo tempo qual é o problema.  Felizmente, isso pode ser corrigido automaticamente.  O plug-in postcss-flexbugs-fixes vem ao resgate. </p><br><p>  No exemplo do calc, ele encontrará fragmentos como este no código: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw – 1px); }</code> </pre> <br><p>  E implante-os: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw - 1px); }</code> </pre> <br><p>  Simples e conveniente. </p><br><h2 id="5-postcss-preset-env">  No. 5.  Postcss-preset-env </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/csstools/postcss-preset-env</a> </p><br><p>  Como estamos falando de suporte ao navegador, não será impróprio dizer sobre postcss-preset-env.  Anteriormente, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cssnext</a> desempenhava o mesmo papel.  Este plugin será útil se você estiver interessado em novas tendências em CSS. </p><br><p><img src="https://habrastorage.org/webt/bu/kp/4h/bukp4htn6ewwkk4qznb8phjxzoa.jpeg"></p><br><p>  Muitas das inovações podem ser tecnicamente implementadas usando os métodos antigos; ela será simplesmente longa, detalhada e feia.  O preset-env ajuda você a escrever código de uma nova maneira, economizar tempo com isso e convertê-lo para uma versão confiável antiga.  Obviamente, algumas coisas, como propriedades personalizadas, não são implementadas em navegadores antigos, portanto, as fallbacks serão usadas lá. </p><br><p>  Como você pode imaginar pelo nome do instrumento, ele se parece com o mesmo nome predefinido em Babel.  Aqui, tudo é o mesmo - existem muitos conversores montados em um conjunto estável.  Algumas transformações requerem conexão subseqüente de scripts polyphile no cliente, mas a maioria é implementada apenas por CSS.  Tanto quanto eu entendo, para scripts Stage2 + não são necessários.  De qualquer forma, não encontrei a necessidade deles.  Corrija-me se eu perdi alguma coisa lá. </p><br><h2 id="6-postcss-animation">  No. 6.  Postcss-animation </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/zhouwenbin/postcss-animation</a> </p><br><p>  Frequentemente, ouço de pessoas diferentes (principalmente back-end que não são muito fortes em CSS) que desejam usar animações separadas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">animate.css</a> , mas considero uma má idéia conectar toda a biblioteca.  É bastante lógico.  Mas, como resultado, eles passam muito tempo tentando repetir essas animações por conta própria. </p><br><p><img src="https://habrastorage.org/webt/hy/tw/wp/hytwwpkrfzjzsktmomybo51bea0.jpeg"></p><br><p>  O plug-in postcss-animation acelera bastante esse processo.  Escrevemos apenas o nome da animação, por exemplo: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; }</code> </pre> <br><p>  E ele pega a implementação do animate.css e a insere no código. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> bounce { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span>, 20%, 53%, 80%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.215, 0.610, 0.355, 1.000); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,0,0); } 40%, 43% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -30px, 0); } 70% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -15px, 0); } 90% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,-4px,0); } }</code> </pre> <br><h2 id="7-list-selectors">  Número 7.  Seletores de lista </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/davidtheclark/list-selectors</a> </p><br><p>  Quando você tem vários tipógrafos e muitos estilos, surge a questão da revisão de código, que seria bom, às vezes, ver com seus olhos o quadro geral com todos os seletores que temos.  Saiba quais IDs são usados, se existem seletores de tags ou quão bem a metodologia aceita está sendo seguida.  Isso é especialmente importante quando você verifica o código do iniciante, que pode escrever coisas estranhas que funcionarão formalmente, mas na verdade contraria os acordos aceitos (longe de qualquer lugar, esses acordos são bem fixos e há uma oportunidade de automatizar essas coisas).  Percorra várias folhas de estilo para verificar a adequação dos seletores por um longo tempo.  Precisamos de uma maneira de isolá-los e mostrá-los separadamente.  Os seletores de lista apenas resolvem esse problema. </p><br><p>  Assim como doiuse, este plugin permite que você use sua função para preparar informações para exibição.  Você pode exibir apenas o que lhe interessa ou pintar tudo em cores diferentes.  Como exemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'list-selectors'</span></span>).plugin(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inspect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>).inspect; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'SELECTORS:'</span></span>.blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.selectors, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'IDS:'</span></span>.red); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.simpleSelectors.ids, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).red); })</code> </pre> <br><p>  Este exemplo produz uma lista longa e longa de seletores: </p><br><pre> <code class="plaintext hljs">SELECTORS: [ '.mui-progress-bar', '.mui-progress-bar &gt; .indicator', '.mui-progress-bar &gt; .value', '.mui-progress-bar.-radial', '.mui-progress-bar.-radial &gt; .indicator', '.mui-progress-bar.-radial &gt; .indicator &gt; .background', '.mui-progress-bar.-radial &gt; .indicator &gt; .progress', '.mui-progress-bar.-radial &gt; .value', . . .</code> </pre> <br><h2 id="8-immutable-css">  Número 8.  Immutable-CSS </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/johno/immutable-css</a> </p><br><p>  Outra coisa a observar é interromper estilos de bibliotecas de terceiros.  Se conectamos algum tipo de biblioteca e depois começamos a escrever nossos próprios estilos para seletores, então no final obtemos um código confuso no qual não conseguimos entender o que veio.  Isso pode levar a erros aleatórios, que levam muito tempo do nada.  Quanto mais vezes redefinimos algo, mais difícil é finalmente entender o que está acontecendo, embora o problema em si que precise ser resolvido possa ser muito simples.  Nessa situação, uma ferramenta chamada immutable-css pode ser útil. </p><br><p>  Em geral, o princípio de seu trabalho é simples: ele pega arquivos com estilos; se encontra correspondências nos seletores, começa a ficar indignado: </p><br><pre> <code class="plaintext hljs">! .button was mutated 2 times [line 93, col 1]: /css/basscss.css [line 3, col 1]: /css/custom.css [immutable-css] ! .left was mutated 2 times [line 291, col 1]: /css/basscss.css [line 4, col 1]: /css/custom.css [immutable-css]</code> </pre> <br><p>  O único problema com esta ferramenta é que ela não suporta sintaxe não CSS.  Portanto, se pré-processadores forem usados ​​no projeto, os arquivos já montados deverão ser comparados.  Mas, em geral, se a tarefa é simplesmente garantir que ninguém reescreva acidentalmente os estilos de uma biblioteca de terceiros, isso não é tão importante. </p><br><h2 id="9-bye-bye">  No. 9.  Tchau-tchau! </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/AoDev/css-byebye</a> </p><br><p>  Acho que todos estão familiarizados com a situação quando adicionamos gradualmente alguns componentes a um site de trabalho.  Alguns deles vão imediatamente para a produção e outros ficam por um longo tempo e aguardam a sua vez (por exemplo, criamos, ainda não terminamos o back-end).  Algo pode ser um experimento ou uma solução temporária para os feriados.  Pode haver muitas situações, mas elas são unidas pelo fato de termos vários componentes e apenas uma pequena parte deles é usada no local de combate.  Seria bom remover tudo o que não é usado da montagem atual.  Isso pode reduzir significativamente seu tamanho, bem como reduzir uma dor de cabeça no futuro, quando será necessário fazer um redesenho, por exemplo, e a pergunta será: o que realmente precisa ser reescrito agora e o que não é. </p><br><p><img src="https://habrastorage.org/webt/l5/rl/e5/l5rle5k5yldudgr5rvtz7hotjom.gif"></p><br><p>  Existem diferentes abordagens para esse problema.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uncss</a> vem imediatamente à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mente</a> .  Essa ferramenta detecta automaticamente quais estilos são usados ​​nas páginas e remove os desnecessários.  Mas, na prática, isso quase sempre leva ao fato de que ninguém sabe o que realmente está sendo usado e o que não é.  Também duvido o tempo todo se essa ferramenta excluiu algo supérfluo.  Mas esta é provavelmente a minha paranóia.  Embora ... </p><br><p>  Bye-bye é uma ferramenta mais simples que alimentamos uma lista de seletores para remover do CSS.  E você pode usar expressões regulares.  Se você usa o BEM ou algo assim, com um simples regular, você pode excluir um bloco com tudo o que estiver relacionado a ele.  Tchau-tchau! </p><br><p>  Essa abordagem acabou sendo bastante conveniente.  Fica imediatamente claro quais estilos ainda não foram usados ​​ou foram removidos como desnecessários, enquanto todas as fontes estão no lugar, todas as configurações em um arquivo, nada é perdido, não causa dificuldades para fazer várias montagens diferentes e, o mais importante, a solução é simples e previsível. </p><br><h2 id="10-postcss-trolling">  No. 10.  Postcss-trolling </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/juanfran/postcss-trolling</a> </p><br><p>  Todas as ferramentas anteriores podem aumentar levemente a produtividade de seus designers de layout, mas essa fornece resultados simplesmente fenomenais.  Eu recomendo. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  O PostCSS é uma boa ajuda para um designer de layout.  Se eles não são abusados, é claro.  Para muitos problemas demorados, existem soluções prontas na forma de plug-ins e, embora muitas vezes não se desenvolvam e pareçam abandonadas, isso não interfere no seu uso. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457340/">https://habr.com/ru/post/pt457340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457330/index.html">Como verificar rapidamente avisos interessantes fornecidos pelo analisador PVS-Studio para códigos C e C ++?</a></li>
<li><a href="../pt457332/index.html">Como ver rapidamente avisos interessantes gerados pelo analisador PVS-Studio para código C e C ++?</a></li>
<li><a href="../pt457334/index.html">TacacsGUI, Gerenciador de configuração</a></li>
<li><a href="../pt457336/index.html">As consequências da remoção prematura dos dentes do siso</a></li>
<li><a href="../pt457338/index.html">Blitz com Ilya Krasinsky: como tirar más hipóteses, por que descartar um produto e como crescer para um mínimo de ação?</a></li>
<li><a href="../pt457342/index.html">Sinais do alto: como salvamos os cartógrafos de trabalho desnecessário e olhos vermelhos</a></li>
<li><a href="../pt457348/index.html">Implantação no PythonAnywhere do GitHub</a></li>
<li><a href="../pt457350/index.html">Por que o osciloscópio precisa de suporte de criptografia?</a></li>
<li><a href="../pt457352/index.html">Conclusão de informações na tela do comprador</a></li>
<li><a href="../pt457354/index.html">Ofuscação de dados para testes de desempenho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>