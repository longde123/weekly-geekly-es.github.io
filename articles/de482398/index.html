<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° ü§≥üèæ ü§úüèª Logische Replikation von PostgreSQL nach Erlang üèéÔ∏è üëáüèº üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein ziemlich typisches Schema bei der Entwicklung des Systems, bei dem die Hauptverarbeitungslogik in der Anwendung (in unserem Fall Erlang) und die D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logische Replikation von PostgreSQL nach Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482398/"><p> Ein ziemlich typisches Schema bei der Entwicklung des Systems, bei dem die Hauptverarbeitungslogik in der Anwendung (in unserem Fall Erlang) und die Daten f√ºr diese Anwendung (Einstellungen, Benutzerprofile usw.) in der Datenbank (PostgreSQL) konzentriert sind.  Die Erlang-Anwendung speichert Einstellungen in der ETS zwischen, um die Verarbeitung zu beschleunigen und die Datenbankbelastung zu verringern, indem permanente Anforderungen abgelehnt werden.  Gleichzeitig erfolgt die √Ñnderung dieser Daten √ºber einen separaten (ggf. externen) Dienst. </p><br><p>  In solchen Situationen besteht die Herausforderung darin, die zwischengespeicherten Daten auf dem neuesten Stand zu halten.  Es gibt verschiedene Ans√§tze, um dieses Problem zu l√∂sen.  Eine davon ist die logische PostgreSQL-Replikation.  Dar√ºber und wird weiter unten diskutiert. </p><a name="habracut"></a><br><h1>  Logisches Replikationsprotokoll streamen </h1><br><p>  <a href="https://www.postgresql.org/docs/10/logical-replication.html">Die logische Replikation</a> verwendet das PostgreSQL-Streaming-Replikationsprotokoll, um Daten√§nderungen in PostgreSQL-Tabellen zu empfangen, indem WAL-Protokolle gelesen, die ben√∂tigten Tabellen gefiltert und diese √Ñnderungen an den Abonnenten gesendet werden.  Dieser Mechanismus √§hnelt dem f√ºr die physische Replikation zum Erstellen einer Standby-Datenbank verwendeten. </p><br><p>  Die logische Replikation bietet die folgenden Vorteile: </p><br><ul><li>  √Ñnderungen unverz√ºglich in Echtzeit empfangen; </li><li>  Filtern von √Ñnderungen nach Tabellen und Operationen (INSERT / DELETE / UPDATE); </li><li>  Vollst√§ndigkeit und Integrit√§t der vom Abonnenten empfangenen Daten.  Der Abonnent erh√§lt die √Ñnderungen in der Reihenfolge, in der sie in der Datenbank vorgenommen wurden. </li><li>  Kein Datenverlust bei vor√ºbergehender Unterbrechung des Teilnehmers.  PostgreSQL merkt sich, wo die Replikation gestoppt wurde. </li></ul><br><h1>  Datenbankvorbereitung </h1><br><p>  Um mit der logischen Replikation arbeiten zu k√∂nnen, ben√∂tigen Sie ein Plugin, das WAL-Eintr√§ge vom Server in einem bequemeren Format decodiert. <br>  Vor PostgreSQL 10 k√∂nnen Sie das <a href="https://2ndquadrant.com/en/resources/pglogical">Plugin</a> / extension <a href="https://2ndquadrant.com/en/resources/pglogical">pglogical_output verwenden</a> . <br>  Beginnend mit dem PostgreSQL 10- <a href="https://www.postgresql.org/docs/10/static/protocol-logicalrep-message-formats.html">Plugin</a> . <br>  Dieser Artikel behandelt das Plugin pgoutput. </p><br><p>  Auf der PostgreSQL-Seite m√ºssen Sie die folgenden Schritte ausf√ºhren: </p><br><ul><li><p>  Legen Sie die Parameter f√ºr die Unterst√ºtzung der logischen Replikation in fest <br>  <a href="https://www.postgresql.org/docs/10/static/logical-replication-config.html">postgresql.conf</a> </p><br><pre><code class="plaintext hljs">wal_level = 'logical' max_replication_slots = 5 max_wal_senders = 5</code> </pre> <br></li><li><p>  Erstellen Sie eine Rolle, die f√ºr die Replikation verwendet werden soll.  Die Rolle muss das <code>SUPERUSER</code> <code>REPLICATION</code> oder <code>SUPERUSER</code> . </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span> epgl_test <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLICATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PASSWORD</span></span> <span class="hljs-string"><span class="hljs-string">'epgl_test'</span></span>;</code> </pre> <br></li><li><p>  Erm√∂glichen Sie den Zugriff f√ºr diese Rolle in pg_hba.conf mit <code>database = replication</code> </p><br><pre> <code class="plaintext hljs">host replication epgl_test 127.0.0.1/32 trust</code> </pre> <br></li><li><p>  Erstellen Sie eine <a href="https://www.postgresql.org/docs/10/sql-createpublication.html">Publikation</a> .  Beim Erstellen einer Publikation geben wir die Tabellen an, die wir in der Erlang-Anwendung erhalten m√∂chten </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> PUBLICATION epgl_test <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> public.test_table1, public.test_table3; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> PUBLICATION epgl_test <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> public.test_table2; <span class="hljs-comment"><span class="hljs-comment">--      </span></span></code> </pre> <br></li></ul><br><h1>  Erlang Teil </h1><br><p>  Vor nicht allzu langer Zeit wurde die Unterst√ºtzung <a href="https://www.postgresql.org/docs/10/protocol-replication.html">f√ºr das Streaming-Replikationsprotokoll</a> zur beliebten Erlang-Bibliothek f√ºr die Arbeit mit PostgreSQL <a href="">EPGSQL hinzugef√ºgt</a> .  Basierend auf dieser Bibliothek erstellen wir die Logik f√ºr den Empfang von √Ñnderungen in Erlang. <br>  Da das Format der Daten direkt in der <code>XlogData</code> Nachricht des Protokolls davon abh√§ngt, welches Plug-In f√ºr den Replikationssteckplatz verwendet wird, dekodiert die <code>EPGSQL</code> Bibliothek die Daten nicht, sondern ruft die Callback-Methode auf oder sendet die Nachricht asynchron an den Prozess. </p><br><h2>  DB-Verbindung </h2><br><p>  Es muss eine spezielle Replikationsverbindung zur Datenbank hergestellt werden, dazu muss das <code>replication</code> . <br>  Innerhalb einer Replikationsdatenbankverbindung k√∂nnen nur Replikationsbefehle ausgef√ºhrt werden (z. B. DROP_REPLICATION_SLOT, CREATE_REPLICATION_SLOT). <br>  Sie k√∂nnen keine regul√§re Anforderung √ºber diese Verbindung ausf√ºhren. </p><br><h2>  Erstellen Sie einen Replikationssteckplatz </h2><br><p>  Der Replikations-Slot wird verwendet, um die aktuelle Position des √ºbertragenen WAL-Protokolls zu verfolgen. <br>  Beim Erstellen eines Replikationssteckplatzes wird ein Plug-In zum Dekodieren angegeben. </p><br><p>  PostgreSQL 10 bietet die M√∂glichkeit, tempor√§re Replikations-Slots zu erstellen, die automatisch gel√∂scht werden, wenn die Replikationsverbindung geschlossen wird. </p><br><p>  Wenn die Anwendung bei jedem Start den Anfangszustand der Tabellen liest, empfehle ich die Verwendung von tempor√§ren Replikationssteckpl√§tzen. In diesem Fall m√ºssen Sie sich nicht um das L√∂schen der erstellten Replikationssteckpl√§tze (DROP_REPLICATION_SLOT) k√ºmmern.  Das Entfernen alter / nicht verwendeter Replikationssteckpl√§tze ist √§u√üerst wichtig, da PostgreSQL WAL-Protokolle erst l√∂scht, wenn die Abonnenten aller Replikationssteckpl√§tze die √Ñnderung erhalten.  Wenn noch ein inaktiver Replikationsbereich vorhanden ist, sammeln sich WAL-Protokolle an und fr√ºher oder sp√§ter l√§uft das Dateisystem √ºber. </p><br><h2>  Den Anfangszustand von Tabellen abrufen </h2><br><p>  Beim Erstellen eines Replikationssteckplatzes (siehe vorherigen Schritt) wird automatisch ein Snapshot erstellt, der den Status der Datenbank zum Zeitpunkt der Erstellung des Steckplatzes anzeigt.  Dieser Snapshot kann zum Laden des Anfangszustands von Tabellen verwendet werden, der sich zu Beginn der Replikation befand. </p><br><p>  Snapshot ist nur verf√ºgbar, bis die Replikationsverbindung geschlossen wird, in der der Befehl <code>CREATE_REPLICATION_SLOT</code> ausgef√ºhrt wurde. </p><br><p>  Um die anf√§nglichen Daten zu laden, muss eine neue regul√§re / Nicht-Replikationsverbindung zur Datenbank erstellt werden, da SELECT nicht f√ºr die Replikationsverbindung ausgef√ºhrt werden kann.  Setzen Sie in diesem Zusammenhang den Snapshot <code>SET TRANSACTION SNAPSHOT SnapshotName</code> und extrahieren Sie die notwendigen Daten. </p><br><h2>  Starten Sie die Replikation </h2><br><p>  Wir starten die Replikation f√ºr den erstellten Replikations-Slot.  Beim Start der Replikation √ºbergeben wir zus√§tzliche Parameter f√ºr das Plugin, f√ºr pgoutput ist dies der Name der erstellten Publikation. </p><br><p>  Alle Schritte zusammen </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_replication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%%    {ok, ReplConn} = epgsql:connect(Host, User, Password, [{database, DBName}, {port, Port}, {replication, "database"}]), %%    {ok, _, [{_, _, SnapshotName}|_]} = epgsql:squery(ReplConn, "CREATE_REPLICATION_SLOT epgl_repl_slot TEMPORARY LOGICAL pgoutput"). %%     {ok, NormalConn} = epgsql:connect(Host, User, Password, [{database, DBName}, {port, Port}]), {ok, _, _} = epgsql:squery(NormalConn, "BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ"), {ok, _, _} = epgsql:squery(NormalConn, ["SET TRANSACTION SNAPSHOT '", SnapshotName, "'"]), %% select/load data epgsql:equery(NormalConn,... epgsql:close(NormalConn), %%   ReplSlot = "epgl_repl_slot", Callback = ?MODULE, CbInitState = #{}, WALPosition = "0/0", PluginOpts = "proto_version '1', publication_names '\"epgl_test\"'", ok = epgsql:start_replication(ReplConn, ReplSlot, Callback, CbInitState, WALPosition, PluginOpts). handle_x_log_data(StartLSN, EndLSN, Data, CbState) -&gt; io:format("~p~n", [{StartLSN, EndLSN, Data}]), {ok, EndLSN, EndLSN, CbState}.</span></span></code> </pre> <br><p>  Es gibt zwei M√∂glichkeiten, mit der <code>EPGSQL</code> Bibliothek zu interagieren: </p><br><ul><li><p>  Synchron.  Der Name des Moduls wird als Callback √ºbergeben.  Die Bibliothek f√ºr die empfangenen Daten ruft die <code>CallbackModule:handle_x_log_data</code> Funktion auf <code>CallbackModule:handle_x_log_data</code> .  Die Funktion sollte LastFlushedLSN, LastAppliedLSN, zur√ºckgeben, das in der PostgreSQL-Antwort gesendet wird, um die aktuelle Position des Replikationsslots zu verfolgen.  In unseren Projekten verwenden wir nur diese Option; </p><br></li><li><p>  Asynchron.  Der R√ºckruf ist die PID des Prozesses, der Nachrichten der Form <code>{epgsql, self(), {x_log_data, StartLSN, EndLSN, WALRecord}}</code> .  Nach der Verarbeitung sollte der Prozess die verarbeitete LSN √ºber einen <code>epgsql:standby_status_update(Conn, FlushedLSN, AppliedLSN)</code> Aufruf <code>epgsql:standby_status_update(Conn, FlushedLSN, AppliedLSN)</code> ; </p><br></li></ul><br><h1>  Anstelle einer Schlussfolgerung </h1><br><p>  Um den beschriebenen Ansatz zu verwenden, ist es au√üerdem erforderlich, das Dekodieren von Nachrichten aus <a href="https://www.postgresql.org/docs/10/static/protocol-logicalrep-message-formats.html">dem</a> Replikationssteckplatz- <a href="https://www.postgresql.org/docs/10/static/protocol-logicalrep-message-formats.html">Plug-In-Format</a> in Strukturen zu implementieren, die Erlang vertrauter sind.  Oder verwenden Sie die Bibliothek mit <a href="https://github.com/SifoxDevTeam/epgl">GitHub</a> , das die Dekodierung f√ºr zwei Plug-Ins implementiert und die Ausf√ºhrung von Replikationsbefehlen vereinfacht. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482398/">https://habr.com/ru/post/de482398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482382/index.html">Vier Prinzipien der √úbersetzung oder wie wird eine Person einem maschinellen √úbersetzer nicht nachgeben?</a></li>
<li><a href="../de482384/index.html">Mein nicht realisiertes Projekt. Netzwerk von 200 MikroTik Routern</a></li>
<li><a href="../de482386/index.html">Visual Studio f√ºr Mac: √úbernehmen Sie die Kontrolle √ºber Ihre IDE mit Tastenkombinationen</a></li>
<li><a href="../de482392/index.html">ELF-Tricks in Go</a></li>
<li><a href="../de482396/index.html">So w√§hlen Sie kaufm√§nnische Kurse f√ºr IT-Berufe aus</a></li>
<li><a href="../de482400/index.html">Eine Auswahl unterhaltsamer statistischer Fakten # 2</a></li>
<li><a href="../de482402/index.html">Fabrik muster. Anwendungsbeispiel in Unity</a></li>
<li><a href="../de482404/index.html">Mnemonik: Erforschung von Methoden zur Steigerung des Gehirns</a></li>
<li><a href="../de482406/index.html">Top-DLC-B√ºcher f√ºr moderne Science-Fiction-Serien</a></li>
<li><a href="../de482410/index.html">Betrachtung der gro√üen fraktalen √Ñhnlichkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>