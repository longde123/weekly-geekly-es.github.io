<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍤 👩‍👦 🤷🏼 Wörterbuchimplementierung in Python 🤱🏽 👨🏽‍🏫 💹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, am 30. April beginnt der Kurs Algorithmen für Entwickler bei OTUS, und die Veröffentlichung des heutigen Materials ist diesem Thema ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wörterbuchimplementierung in Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448350/">  Hallo allerseits, am 30. April beginnt der Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen für Entwickler</a> bei OTUS, und die Veröffentlichung des heutigen Materials ist diesem Thema gewidmet.  Fangen wir an. <br><br><img src="https://habrastorage.org/webt/hq/5t/r4/hq5tr4-0h1wb2kxrkaggtq_fatm.png"><br><br>  In diesem Artikel erfahren Sie, wie Wörterbücher in Python implementiert werden. <br>  Wörterbücher werden mithilfe von Schlüsseln indiziert und können als zugeordnete Arrays betrachtet werden.  Fügen wir dem Wörterbuch 3 Schlüssel / Wert-Paare hinzu: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>} &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <a name="habracut"></a><br>  Auf Werte kann wie folgt zugegriffen werden: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'a'</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'b'</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'d'</span></span>] Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; KeyError: <span class="hljs-string"><span class="hljs-string">'d'</span></span></code> </pre> <br>  Der Schlüssel <code>“d”</code> ist nicht vorhanden, daher tritt ein KeyError-Fehler auf. <br><br>  <b>Hash-Tabellen</b> <br><br>  Wörterbücher in Python werden mithilfe von Hash-Tabellen implementiert.  Dies sind Arrays, deren Indizes mithilfe von Hash-Funktionen berechnet werden.  Das Ziel der Hash-Funktion besteht darin, die Schlüssel im Array gleichmäßig zu verteilen.  Eine gute Hash-Funktion minimiert die Anzahl von Kollisionen, d.h.  die Wahrscheinlichkeit, dass verschiedene Schlüssel denselben Hash haben.  In Python gibt es keine solchen Hash-Funktionen.  Die wichtigsten Hash-Funktionen (für Zeichenfolgen und ganzzahlige Werte) erzeugen im Allgemeinen ähnliche Werte: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>map(hash, (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; map(hash, (<span class="hljs-string"><span class="hljs-string">"namea"</span></span>, <span class="hljs-string"><span class="hljs-string">"nameb"</span></span>, <span class="hljs-string"><span class="hljs-string">"namec"</span></span>, <span class="hljs-string"><span class="hljs-string">"named"</span></span>)) [<span class="hljs-number"><span class="hljs-number">-1658398457</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398460</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398459</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398462</span></span>]</code> </pre> <br>  Wir gehen davon aus, dass wir bis zum Ende dieses Artikels Zeichenfolgen als Schlüssel verwenden werden.  Die Hash-Funktion in Python für Zeichenfolgen ist wie folgt definiert: <br><br><pre> <code class="python hljs">arguments: string object returns: hash function string_hash: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash cached: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it set len to string<span class="hljs-string"><span class="hljs-string">'s length initialize var p pointing to 1st char of string object set x to value pointed by p left shifted by 7 bits while len &gt;= 0: set var x to (1000003 * x) xor value pointed by p increment pointer p set x to x xor length of string object cache x as the hash so we don'</span></span>t need to calculate it again <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the hash</code> </pre> <br>  Wenn Sie in Python <code>hash('a')</code> <code>12416037344</code> , wird <code>string_hash()</code> und <code>12416037344</code> .  Hier verwenden wir standardmäßig die 64-Bit-Maschine. <br><br>  Wenn ein Array der Größe <code></code> zum Speichern der Wert / Schlüssel-Paare verwendet wird, wird eine Maske verwendet, um den Index der Zelle der Zelle im Array zu berechnen, der als <code>-1</code> berechnet wird.  Dieser Ansatz erleichtert die Berechnung von Zellindizes.  Die Wahrscheinlichkeit, eine leere Zelle zu finden, ist aufgrund des unten beschriebenen Größenänderungsmechanismus ziemlich hoch.  Dies bedeutet, dass eine einfache Berechnung in den meisten Fällen sinnvoll ist.  Die Größe des Arrays beträgt 8, der Index für <code>'a'</code> lautet: <code>hash('a') &amp; 7 = 0</code> .  Der Index für <code>'b'</code> ist 2, der Index für <code>'c'</code> ist 3, der Index für <code>'z'</code> ist 3, genau wie für <code>'b'</code> , und hier erhalten wir eine Kollision. <br><br><img src="https://habrastorage.org/webt/m0/uu/ie/m0uuieays-qf4xbaurxripjwdi8.png"><br><br>  Wie wir sehen können, erledigt eine Hash-Funktion in Python ihre Arbeit auf qualitativ hochwertige Weise, wenn die Schlüssel sequentiell sind, was gut ist, da Sie häufig mit solchen Daten arbeiten müssen.  Sobald wir jedoch die Taste <code>'z'</code> hinzufügen, tritt eine Kollision auf, da diese nicht mit den vorherigen übereinstimmt. <br><br>  Wir könnten eine verknüpfte Liste verwenden, um Paare mit demselben Hash zu speichern, aber dies würde die Suchzeit verlängern und im Durchschnitt nicht gleich O (1) sein.  Der folgende Abschnitt beschreibt die Kollisionsauflösungsmethode, die für Wörterbücher in Python verwendet wird. <br><br>  <b>Offene Adressierung</b> <br><br>  Open Addressing ist eine Kollisionsauflösungstechnik, bei der die Prüfung verwendet wird.  Im Fall von <code>'z'</code> wird der Index von Zelle 3 bereits im Array verwendet, daher müssen wir nach einem anderen Index suchen, der noch nicht verwendet wurde.  Der Vorgang des Hinzufügens eines Schlüssel / Wert-Paares erfordert im Durchschnitt O (1) sowie den Suchvorgang. <br><br>  Um nach freien Zellen zu suchen, wird eine quadratische Abtastsequenz verwendet.  Es wird wie folgt implementiert: <br><br><pre> <code class="python hljs">j = (<span class="hljs-number"><span class="hljs-number">5</span></span>*j) + <span class="hljs-number"><span class="hljs-number">1</span></span> + perturb; perturb &gt;&gt;= PERTURB_SHIFT; use j % <span class="hljs-number"><span class="hljs-number">2</span></span>**i <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the next table index;</code> </pre> <br>  Die Rekursion bei (5 * j) +1 erhöht schnell große Unterschiede in Bits, die den ursprünglichen Index nicht beeinflusst haben.  Die Variable <code>"perturb"</code> in diesem Fall die anderen Bits des Hash-Codes auf. <br><br>  Lassen Sie uns aus Neugier schauen, was passiert, wenn wir eine Beispielsequenz mit der Tabellengröße 32 und j = 3 haben. <br><br>  3 -&gt; 11 -&gt; 19 -&gt; 29 -&gt; 5 -&gt; 6 -&gt; 16 -&gt; 31 -&gt; 28 -&gt; 13 -&gt; 2 ... <br><br>  Weitere <a href="">Informationen zu</a> dieser <a href="">Prüfsequenz finden Sie</a> im Quellcode <a href="">dictobject.c</a> .  Eine ausführliche Erläuterung des Prüfmechanismus finden Sie oben in der Datei. <br><br><img src="https://habrastorage.org/webt/jq/vo/l3/jqvol3q4ekq8yullsftv4ylm-p4.png"><br><br>  Schauen wir uns den Python-Quellcode mit diesem Beispiel an. <br><br>  <b>C Wörterbuchstrukturen</b> <br><br>  Die folgende C-Struktur wird verwendet, um den Eintrag im Wörterbuch zu speichern: Schlüssel / Wert-Paar.  Der Hash, der Schlüssel und der Wert werden gespeichert.  <code>PyObject</code> ist die Basisklasse für Objekte in Python. <br><br><pre> <code class="python hljs">typedef struct { Py_ssize_t me_hash; PyObject *me_key; PyObject *me_value; } PyDictEntry;</code> </pre> <br>  Die folgende Struktur ist ein Wörterbuch.  <code>ma_fill</code> ist die Gesamtzahl der verwendeten und inaktiven Zellen.  Eine Zelle gilt als inaktiv, wenn ein Schlüsselpaar gelöscht wird.  <code>ma_used</code> ist die Anzahl der verwendeten (aktiven) Zellen.  <code>ma_mask</code> entspricht der Größe des -1-Arrays und wird zur Berechnung des Zellenindex verwendet.  <code>ma_table</code> ist ein Array und <code>ma_smalltable</code> ist das ursprüngliche Array der Größe 8. <br><br><pre> <code class="python hljs">typedef struct _dictobject PyDictObject; struct _dictobject { PyObject_HEAD Py_ssize_t ma_fill; Py_ssize_t ma_used; Py_ssize_t ma_mask; PyDictEntry *ma_table; PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash); PyDictEntry ma_smalltable[PyDict_MINSIZE]; };</code> </pre> <br>  <b>Wortschatzinitialisierung</b> <br><br>  Wenn Sie nur ein Wörterbuch erstellen, wird die Funktion <code>PyDict_New()</code> .  Ich habe einige Zeilen gelöscht und den C-Code in Pseudocode konvertiert, um mich auf Schlüsselkonzepte zu konzentrieren. <br><br>  <code>PyDict_New()</code> -Funktion: <br><br><ul><li>  Gibt ein Wörterbuchobjekt zurück. </li><li>  Ordnet ein neues Wörterbuchobjekt zu. </li><li>  Löscht die Wörterbuchtabelle. </li><li>  Setzt die Anzahl der verwendeten Wörterbuchzellen und nicht verwendeten Zellen ( <code>ma_fill</code> ) auf 0; </li><li>  Setzt die Anzahl der aktiven Zellen ( <code>ma_used</code> ) auf 0; </li><li>  Setzt die Wörterbuchmaske ( <code>ma_value</code> ) auf einen Wert, der der Größe des Wörterbuchs entspricht - 1 = 7; </li><li>  Legt die Wörterbuchsuchfunktion <code>lookdict_string</code> . </li><li>  Gibt das zugewiesene Wörterbuchobjekt zurück. </li></ul><br>  <b>Element hinzufügen</b> <br><br>  Wenn ein neues Schlüssel / Wert-Paar hinzugefügt wird, wird <code>PyDict_SetItem()</code> aufgerufen.  Diese Funktion akzeptiert einen Zeiger auf ein Wörterbuchobjekt und ein Schlüssel / Wert-Paar als Eingabe.  Es prüft, ob der Schlüssel eine Zeichenfolge ist, wertet den Hash aus oder verwendet den zwischengespeicherten erneut, falls vorhanden.  <code>insertdict()</code> wird aufgerufen, um ein neues Schlüssel / Wert-Paar hinzuzufügen, und die Wörterbuchgröße ändert sich, wenn die Anzahl der verwendeten und nicht verwendeten Zellen mehr als 2/3 der Größe des Arrays beträgt. <br><br>  Warum genau 2/3?  Dies ist notwendig, um sicherzustellen, dass die Sondensequenz freie Zellen schnell genug finden kann.  Später werden wir die Funktion zum Ändern der Größe betrachten. <br><br><pre> <code class="python hljs">arguments: dictionary, key, value returns: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> function PyDict_SetItem: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key<span class="hljs-string"><span class="hljs-string">'s hash cached: use hash else: calculate hash call insertdict with dictionary object, key, hash and value if key/value pair added successfully and capacity over 2/3: call dictresize to resize dictionary'</span></span>s table</code> </pre> <br>  <code>inserdict()</code> verwendet die <code>lookdict_string()</code> , um eine freie Zelle zu finden.  Die gleiche Funktion wird verwendet, um nach einem Schlüssel zu suchen. <br><br>  <code>lookdict_string()</code> berechnet den Zellenindex mithilfe von Hash- und <code>lookdict_string()</code> .  Wenn sie den Schlüssel nicht anhand des Werts von Zellenindex = Hash &amp; Maske (Slot-Index = Hash &amp; Maske) finden kann, beginnt sie mit der Prüfung mit dem oben beschriebenen Zyklus, bis sie eine freie Zelle findet.  Wenn der Schlüssel beim ersten Versuch zu prüfen ist, wird eine nicht verwendete Zelle zurückgegeben, wenn sie bei der ersten Suche gefunden wurde.  Dies stellt die Priorität für die Wiederverwendung zuvor gelöschter Zellen sicher. <br>  Wir möchten die folgenden Schlüssel / Wert-Paare hinzufügen: <code>{'a': 1, 'b': 2′, 'z': 26, 'y': 25, 'c': 5, 'x': 24}</code> .  Folgendes wird passieren: <br><br>  Die Wörterbuchstruktur wird mit einer Tabellengröße von 8 zugewiesen. <br><br><ul><li>  PyDict_SetItem: key = 'a', value = 1 <br><ul><li>  Hash = Hash ('a') = 12416037344 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  Slot Index = Hash &amp; Maske = 12416037344 &amp; 7 = 0 </li><li>  Steckplatz 0 wird nicht verwendet. Geben Sie diese Zelle zurück </li></ul></li><li>  Initialisierung des Eintrags bei Index 0 mit Schlüssel, Wert und Hash </li><li>  ma_used = 1, ma_fill = 1 </li></ul></li></ul></li><li>  PyDict_SetItem: key = 'b', value = 2 <br><ul><li>  Hash = Hash ('b') = 12544037731 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  Slot Index = Hash &amp; Maske = 12544037731 &amp; 7 = 3 </li><li>  Steckplatz 3 wird nicht verwendet. Geben Sie diese Zelle zurück </li></ul></li><li>  Initialisierung des Eintrags bei Index 3 mit Schlüssel, Wert und Hash </li><li>  ma_used = 2, ma_fill = 2 <br></li></ul></li></ul></li><li>  PyDict_SetItem: key = 'z', value = 26 <br><ul><li>  Hash = Hash ('z') = 15616046971 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  Slot Index = Hash &amp; Maske = 15616046971 &amp; 7 = 3 </li><li>  Steckplatz 3 wird verwendet, versuchen Sie es mit einer anderen Zelle: 5 ist frei <br></li></ul><br>  Initialisierung des Eintrags bei Index 5 mit Schlüssel, Wert und Hash <br>  ma_used = 3, ma_fill = 3 <br></li></ul></li></ul></li><li>  PyDict_SetItem: key = 'y', value = 25 <br><ul><li>  Hash = Hash ('y') = 15488046584 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  Slot Index = Hash &amp; Maske = 15488046584 &amp; 7 = 0 </li><li>  Steckplatz 0 wird verwendet, versuchen Sie es mit einer anderen Zelle: 1 ist frei </li></ul></li><li>  Initialisierung des Eintrags bei Index 1 mit Schlüssel, Wert und Hash </li><li>  ma_used = 4, ma_fill = 4 </li></ul></li></ul></li></ul><br>  PyDict_SetItem: key = 'c', value = 3 <br><ul><li>  Hash = Hash ('c') = 12672038114 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  Slot Index = Hash &amp; Maske = 12672038114 &amp; 7 = 2 </li><li>  Steckplatz 2 wird nicht verwendet. Geben Sie diese Zelle zurück </li></ul></li><li>  Initialisierung des Eintrags bei Index 2 mit Schlüssel, Wert und Hash </li><li>  ma_used = 5, ma_fill = 5 </li></ul></li></ul><br>  PyDict_SetItem: key = 'x', value = 24 <br><ul><li>  Hash = Hash ('x') = 15360046201 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  Slot Index = Hash &amp; Maske = 15360046201 &amp; 7 = 1 </li><li>  Steckplatz 1 wird verwendet, versuchen Sie es mit einer anderen Zelle: 7 ist frei </li></ul></li><li>  Initialisierung des Eintrags bei Index 7 mit Schlüssel, Wert und Hash </li><li>  ma_used = 6, ma_fill = 6 </li></ul></li></ul><br>  Folgendes bekommen wir: <br><br><img src="https://habrastorage.org/webt/f9/wa/hf/f9wahfryuhllv1zykzjmwjcqllk.png"><br><br>  Jetzt werden 6 von 8 Zellen verwendet, mehr als 2/3 der Array-Kapazität sind belegt.  <code>dictresize()</code> wird aufgerufen, um ein größeres Array zuzuweisen.  Diese Funktion kopiert auch Datensätze aus der alten Tabelle in die neue. <br><br>  <code>dictresize ()</code> wird in unserem Fall mit <code>minused</code> = 24 aufgerufen, wobei 4 * <code>ma_used</code> .  2 * <code>ma_used</code> verwendet, wenn die Anzahl der verwendeten Zellen sehr groß ist (mehr als 50.000).  Warum sind 4 mal mehr Zellen?  Dies reduziert die Anzahl der Schritte zum Implementieren der Größenänderung und erhöht die Spärlichkeit. <br><br>  Die neue Größe der Tabelle sollte größer als 24 sein. Sie wird berechnet, indem die aktuelle Größe um 1 Bit nach links verschoben wird, bis die Größe der Tabelle größer als 24 wird. Infolgedessen sind es 32, z. B. 8 -&gt; 16 -&gt; 32. <br><br>  Folgendes passiert mit unserer Tabelle während der Größenänderung: Eine neue Tabelle der Größe 32 wird hervorgehoben. Alte Tabelleneinträge werden mit einem neuen Maskenwert von 31 in die neue Tabelle eingefügt. Das Ergebnis ist das Folgende: <br><br><img src="https://habrastorage.org/webt/qy/ue/ke/qyueke3baeooxaxzskg8dphcpli.png"><br><br>  <b>Elemente löschen</b> <br><br>  <code>PyDict_DelItem()</code> wird aufgerufen, um Datensätze zu löschen.  Der Hash wird für den Datensatzschlüssel berechnet, dann wird die Suchfunktion aufgerufen, um den Datensatz zurückzugeben.  Jetzt ist die Zelle leer. <br><br>  Wir möchten den Schlüssel c aus unserem Wörterbuch entfernen.  Als Ergebnis erhalten wir das folgende Array: <br><br><img src="https://habrastorage.org/webt/sw/x1/l1/swx1l1efqzzelggasprbesixdqw.png"><br><br>  Beachten Sie, dass durch das Löschen eines Elements die Größe des Arrays nicht geändert wird, wenn die Anzahl der verwendeten Zellen viel geringer ist als ihre Gesamtzahl.  Wenn jedoch ein Schlüssel / Wert-Paar hinzugefügt wird, hängt die Notwendigkeit einer Größenänderung von der Anzahl der verwendeten und inaktiven Zellen ab, sodass die Additionsoperation auch das Array reduzieren kann. <br><br>  Diese Veröffentlichung ist zu Ende gegangen, und wir warten traditionell auf Ihre Kommentare und laden alle zu einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen Lektion ein</a> , die am 18. April stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448350/">https://habr.com/ru/post/de448350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448336/index.html">Seminar „Hybrid Clouds - Vor- und Nachteile: Vorbereitung auf Business und IT“ - 25. April, Moskau</a></li>
<li><a href="../de448338/index.html">Aufschlüsselung der Grundlagen von C #: Zuweisen von Speicher für einen Referenztyp auf dem Stapel</a></li>
<li><a href="../de448340/index.html">Erstellung des 35MM-Spiels. Postapokalypse in Russland</a></li>
<li><a href="../de448342/index.html">MyDrops - kostengünstiges TWS mit gutem Sound und zuverlässigem Bluetooth</a></li>
<li><a href="../de448346/index.html">Von GNU zu Doom: TechTrain 2019 angekündigt</a></li>
<li><a href="../de448352/index.html">Die Boring Company wird in Las Vegas einen Tunnel graben</a></li>
<li><a href="../de448354/index.html">GraphQL Voyager als Tool zum Auffinden von Schwachstellen</a></li>
<li><a href="../de448358/index.html">Wir hören Musik und Vorträge von Youtube mit einem gesperrten Smartphone-Bildschirm und ohne Werbung mit Telegramm</a></li>
<li><a href="../de448360/index.html">Eine kleine Hintertür auf Flask oder wie man einen Computer in einem lokalen Netzwerk steuert</a></li>
<li><a href="../de448362/index.html">Ich dachte, ich muss Designer schicken an ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>