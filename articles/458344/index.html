<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Å üë©üèº‚Äçüî¨ üåâ Uso de mensajer√≠a asincr√≥nica para mejorar la disponibilidad üë®üèæ‚Äçüè≠ üë®üèª‚Äçüé® üíù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! Recientemente entregamos un libro de Chris Richardson a la imprenta, cuyo prop√≥sito es ense√±ar c√≥mo desarrollar aplicaciones con √©x...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso de mensajer√≠a asincr√≥nica para mejorar la disponibilidad</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458344/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/hz/bw/dj/hzbwdju5aq8nv9xbromr1vbgdsi.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  Recientemente entregamos un libro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chris Richardson</a> a la imprenta, cuyo prop√≥sito es ense√±ar c√≥mo desarrollar aplicaciones con √©xito utilizando la arquitectura de microservicios.  El libro discute no solo las ventajas, sino tambi√©n las desventajas de los microservicios.  Aprender√° en qu√© situaciones tiene sentido aplicarlas y cu√°ndo es mejor pensar en un enfoque monol√≠tico. <br><br>  El libro se centra en la arquitectura y el dise√±o.  Est√° dise√±ado para cualquier persona cuyas responsabilidades incluyan escribir y entregar software, incluidos desarrolladores, arquitectos, directores t√©cnicos y jefes de departamentos de desarrollo. <br><br>  Lo siguiente es un extracto del libro Uso de la mensajer√≠a asincr√≥nica. <br><a name="habracut"></a><br><h3>  Uso de mensajer√≠a asincr√≥nica para mejorar la disponibilidad </h3><br>  Como ha visto, los diversos mecanismos de IPC lo empujan a varios compromisos.  Uno de ellos est√° relacionado con la forma en que IPC afecta la accesibilidad.  En esta secci√≥n, aprender√° que la interacci√≥n sincr√≥nica con otros servicios como parte del procesamiento de solicitudes reduce la disponibilidad de la aplicaci√≥n.  En este sentido, cuando dise√±e sus servicios, debe usar mensajes as√≠ncronos siempre que sea posible. <br><br>  Primero, veamos qu√© problemas crea la interacci√≥n sincr√≥nica y c√≥mo afecta la accesibilidad. <br><br><h3>  3.4.1.  La interacci√≥n sincronizada reduce la disponibilidad </h3><br>  REST es un motor IPC extremadamente popular.  Puede tener la tentaci√≥n de usarlo para la comunicaci√≥n entre servicios.  Pero el problema con REST es que es un protocolo s√≠ncrono: el cliente HTTP tiene que esperar hasta que el servicio devuelva una respuesta.  Cada vez que los servicios se comunican entre s√≠ a trav√©s de un protocolo s√≠ncrono, esto reduce la disponibilidad de la aplicaci√≥n. <br><br>  Para comprender por qu√© sucede esto, considere el escenario que se muestra en la Fig.  3.15.  El servicio de pedidos tiene una API REST para crear pedidos.  Para verificar el pedido, recurre a los servicios para consumidores y restaurantes, que tambi√©n tienen una API REST. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pn/uq/22/pnuq22tmdzqdhbr_wxa9nuntoeq.png" alt="imagen"></div><br>  Crear una orden consiste en esta secuencia de pasos. <br><br><ol><li>  El cliente realiza una solicitud HTTP POST / pedidos al servicio de pedidos. </li><li>  El servicio de pedido recupera la informaci√≥n del cliente al hacer una solicitud HTTP GET / consumer / id al servicio al consumidor. </li><li>  El servicio de pedidos recupera la informaci√≥n del restaurante ejecutando una solicitud HTTP GET / restaurant / id al servicio del restaurante. </li><li>  Order Taking verifica la solicitud utilizando informaci√≥n sobre el cliente y el restaurante. </li><li>  La toma de pedidos crea un pedido. </li><li>  Order Taking env√≠a una respuesta HTTP al cliente. </li></ol><br>  Dado que estos servicios usan HTTP, todos deben estar accesibles para que FTGO procese la solicitud CreateOrder.  No podr√° crear un pedido si al menos uno de los servicios no est√° disponible.  Desde un punto de vista matem√°tico, la disponibilidad de una operaci√≥n del sistema es un producto de la disponibilidad de los servicios que participan en √©l.  Si el servicio de Pedido y los dos servicios a los que llama tienen una disponibilidad del 99.5%, entonces su disponibilidad general ser√° del 99.5% 3 = 98.5%, que es mucho menor.  Cada servicio posterior que participa en la solicitud hace que la operaci√≥n sea menos accesible. <br><br>  Este problema no es exclusivo de las interacciones basadas en REST.  La disponibilidad disminuye cuando un servicio necesita recibir respuestas de otros servicios para responder a un cliente.  Incluso la transici√≥n a un estilo de interacci√≥n de solicitud / respuesta adem√°s de mensajes asincr√≥nicos no ayudar√° aqu√≠.  Por ejemplo, si el servicio de pedidos env√≠a un mensaje al servicio al consumidor a trav√©s de un agente y comienza a esperar una respuesta, su disponibilidad se deteriorar√°. <br><br>  Si desea maximizar la accesibilidad, minimice la cantidad de interacci√≥n sincr√≥nica.  Veamos como hacerlo. <br><br><h3>  3.4.2.  Desh√°gase de la interacci√≥n sincr√≥nica </h3><br>  Hay varias formas de reducir la cantidad de interacci√≥n sincr√≥nica con otros servicios al procesar solicitudes sincr√≥nicas.  En primer lugar, para evitar completamente este problema, todos los servicios se pueden proporcionar con API exclusivamente asincr√≥nicas.  Pero esto no siempre es posible.  Por ejemplo, las API p√∫blicas generalmente se adhieren al est√°ndar REST.  Por lo tanto, algunos servicios deben tener API s√≠ncronas. <br><br>  Afortunadamente, para procesar solicitudes sincr√≥nicas, no es necesario ejecutarlas usted mismo.  Hablemos de tales opciones. <br><br>  <b>Uso de estilos de interacci√≥n asincr√≥nica</b> <br><br>  Idealmente, toda interacci√≥n deber√≠a ocurrir en el estilo asincr√≥nico descrito anteriormente en este cap√≠tulo.  Imagine, por ejemplo, que el cliente de la aplicaci√≥n FTGO utiliza un estilo de interacci√≥n de solicitud as√≠ncrona / respuesta as√≠ncrona para crear pedidos.  Para crear un pedido, env√≠a un mensaje de solicitud al servicio de pedidos.  Luego, este servicio intercambia mensajes de forma as√≠ncrona con otros servicios y finalmente devuelve una respuesta al cliente (Fig. 3.16). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/j3/px/7ej3pxinlckogxf4ga0fmjaxtmu.png" alt="imagen"></div><br>  El cliente y el servicio se comunican de forma as√≠ncrona, enviando mensajes a trav√©s de canales.  Ninguno de los participantes en esta interacci√≥n est√° bloqueado esperando una respuesta. <br><br>  Dicha arquitectura ser√≠a extremadamente robusta, porque el agente almacena los mensajes hasta que su consumo sea posible.  Pero el problema es que los servicios a menudo tienen una API externa que utiliza un protocolo s√≠ncrono como REST y, como resultado, deben responder de inmediato a las solicitudes. <br><br>  Si el servicio tiene una API s√≠ncrona, la accesibilidad se puede mejorar mediante la replicaci√≥n de datos.  Veamos como funciona. <br><br>  <b>Replicaci√≥n de datos</b> <br><br>  Una forma de minimizar la interacci√≥n sincr√≥nica durante el procesamiento de consultas es replicar datos.  El servicio almacena una copia (r√©plica) de los datos que necesita para procesar las solicitudes.  Para mantener actualizada la r√©plica, se suscribe a eventos publicados por los servicios a los que pertenecen estos datos.  Por ejemplo, un servicio de pedidos puede almacenar una copia de los datos pertenecientes a los servicios de consumo y restaurante.  Esto le permitir√° procesar solicitudes para crear pedidos sin recurrir a estos servicios.  Tal arquitectura se muestra en la fig.  3.17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p9/vz/zs/p9vzzssvlgjr7xx3efpsyjtesly.png" alt="imagen"></div><br>  Los servicios para consumidores y restaurantes publican eventos cada vez que cambian sus datos.  El servicio de pedidos se suscribe a estos eventos y actualiza su r√©plica. <br><br>  En algunos casos, la replicaci√≥n de datos es una buena soluci√≥n.  Por ejemplo, el Cap√≠tulo 5 describe c√≥mo el servicio de pedidos replica los datos del servicio de restaurante para poder verificar los elementos del men√∫.  Uno de los inconvenientes de este enfoque es que a veces requiere copiar grandes cantidades de datos, lo cual es ineficiente.  Por ejemplo, si tenemos muchos clientes, almacenar una r√©plica de los datos que pertenecen al servicio al consumidor puede no ser pr√°ctico.  Otra desventaja de la replicaci√≥n radica en el hecho de que no resuelve el problema de actualizar los datos que pertenecen a otros servicios. <br><br>  Para resolver este problema, un servicio puede retrasar la interacci√≥n con otros servicios hasta que responda a su cliente.  Esto se discutir√° m√°s a fondo. <br><br>  <b>Finalizar el procesamiento despu√©s de devolver una respuesta</b> <br><br>  Otra forma de eliminar la interacci√≥n sincr√≥nica durante el procesamiento de consultas es realizar este procesamiento en la forma de los siguientes pasos. <br><br><ol><li>  El servicio verifica la solicitud solo con la ayuda de los datos disponibles localmente. </li><li>  Actualiza su base de datos, incluida la adici√≥n de mensajes a la tabla OUTBOX. </li><li>  Devuelve la respuesta a su cliente. </li></ol><br>  Durante el procesamiento de la solicitud, el servicio no accede sincr√≥nicamente a ning√∫n otro servicio.  En cambio, les env√≠a mensajes asincr√≥nicos.  Este enfoque proporciona una conectividad deficiente de los servicios.  Como ver√° en el pr√≥ximo cap√≠tulo, este proceso a menudo se implementa como una narraci√≥n. <br><br>  Imagine que el servicio de pedidos act√∫a de esta manera.  Crea un pedido con el estado PENDIENTE y luego lo verifica intercambiando mensajes asincr√≥nicos con otros servicios.  En la fig.  La figura 3.18 muestra lo que sucede cuando se llama a la operaci√≥n createOrder ().  La cadena de eventos se ve as√≠. <br><br><ol><li>  El servicio de pedidos crea un pedido con el estado PENDIENTE. </li><li>  El servicio de pedidos devuelve una respuesta con ID de pedido a su cliente. </li><li>  El servicio de pedidos env√≠a un mensaje ValidateConsumerInfo al servicio al consumidor. </li><li>  El servicio de pedidos env√≠a un mensaje ValidateOrderDetails al servicio de restaurante. </li><li>  El servicio al consumidor recibe un mensaje ValidateConsumerInfo, verifica si el cliente puede hacer un pedido y env√≠a un mensaje al cliente validado al servicio Order. </li><li>  El servicio del restaurante recibe un mensaje ValidateOrderDetails, verifica la exactitud de los elementos del men√∫ y la capacidad del restaurante de entregar un pedido a una direcci√≥n determinada, y env√≠a un mensaje OrderDetailsValidated al servicio Order. </li><li>  El servicio de pedidos recibe mensajes ConsumerValidated y OrderDetailsValidated y cambia el estado del pedido a VALIDATED. </li></ol><br>  Y as√≠ sucesivamente ... <br><br>  El servicio de pedidos puede recibir mensajes ConsumerValidated y OrderDetailsValidated en cualquier orden.  Para saber cu√°l recibi√≥ primero, cambia el estado del pedido.  Si el primer mensaje es ConsumerValidated, el estado del pedido cambia a CONSUMER_VALIDATED, y si OrderDetailsValidated cambia a ORDER_DETAILS_VALIDATED.  Despu√©s de recibir el segundo mensaje, el servicio de pedido establece el estado del pedido en VALIDADO. <br><br>  Despu√©s de verificar el pedido, el servicio de pedidos realiza los pasos restantes para crearlo, que discutiremos en el pr√≥ximo cap√≠tulo.  Una gran parte de este enfoque es que el servicio de pedidos puede crear un pedido y responder al cliente, incluso si el servicio al consumidor no est√° disponible.  Tarde o temprano, el servicio al consumidor recuperar√° y procesar√° todos los mensajes pendientes, lo que completar√° la verificaci√≥n de los pedidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/d2/e_/hvd2e_kioxghqoo4jwcyqroerk8.png" alt="imagen"></div><br>  La desventaja de devolver una respuesta antes de que la solicitud se procese por completo es que hace que el cliente sea m√°s complejo.  Por ejemplo, cuando el servicio de pedidos devuelve una respuesta, ofrece garant√≠as m√≠nimas sobre el estado del pedido que se acaba de crear.  Responde de inmediato, incluso antes de verificar el pedido y autorizar la tarjeta bancaria del cliente.  Por lo tanto, para saber si el pedido se ha creado correctamente, el cliente debe solicitar informaci√≥n peri√≥dicamente o el servicio de pedidos debe enviarle un mensaje de notificaci√≥n.  A pesar de la complejidad de este enfoque, en muchos casos vale la pena preferirlo, especialmente porque tiene en cuenta los problemas con la administraci√≥n de transacciones distribuidas, que discutiremos en el Cap√≠tulo 4. En los cap√≠tulos 4 y 5, demostrar√© esta t√©cnica usando el ejemplo del servicio de pedidos. <br><br><h3>  Resumen </h3><br><ul><li>  La arquitectura de microservicios se distribuye, por lo que la comunicaci√≥n entre procesos desempe√±a un papel clave en ella. </li><li>  El desarrollo del servicio API debe abordarse cuidadosa y cuidadosamente.  Es m√°s f√°cil realizar cambios compatibles con versiones anteriores porque no afectan la forma en que trabajan los clientes.  Al realizar cambios importantes en la API del servicio, generalmente debe mantener tanto la versi√≥n anterior como la nueva hasta que se actualicen los clientes. </li><li>  Existen muchas tecnolog√≠as IPC, cada una con sus propias fortalezas y debilidades.  La decisi√≥n clave en la etapa de dise√±o es la elecci√≥n entre llamada a procedimiento remoto sincr√≥nico y mensajes asincr√≥nicos.  Los m√°s f√°ciles de usar son los protocolos s√≠ncronos como REST, basados ‚Äã‚Äãen la llamada de procedimientos remotos.  Pero, idealmente, para aumentar la accesibilidad, los servicios deben comunicarse mediante mensajes asincr√≥nicos. </li><li>  Para evitar una acumulaci√≥n de fallas similar a una avalancha en el sistema, un cliente que usa un protocolo s√≠ncrono debe ser capaz de lidiar con fallas parciales, el hecho de que el servicio llamado no est√° disponible o exhibe alta latencia.  En particular, cuando se ejecutan solicitudes, es necesario contar el tiempo de espera, limitar el n√∫mero de solicitudes vencidas y aplicar la plantilla "Fusible" para evitar llamadas al servicio defectuoso. </li><li>  Una arquitectura que usa protocolos s√≠ncronos debe incluir un mecanismo de descubrimiento para que los clientes puedan determinar la ubicaci√≥n de red de las instancias de servicio.  La forma m√°s f√°cil es centrarse en el mecanismo de descubrimiento proporcionado por la plataforma de implementaci√≥n: en las plantillas "Descubrimiento del lado del servidor" y "Registro de terceros".  Un enfoque alternativo es la implementaci√≥n del descubrimiento de servicios a nivel de aplicaci√≥n: las plantillas de descubrimiento de clientes y de autorregistro.  Este m√©todo requiere m√°s esfuerzo, pero es adecuado para situaciones donde los servicios se ejecutan en m√∫ltiples plataformas de implementaci√≥n. </li><li>  El modelo de mensaje y canal encapsula los detalles de la implementaci√≥n del sistema de mensajer√≠a y se convierte en una buena opci√≥n al dise√±ar este tipo de arquitectura.  M√°s tarde, puede vincular su arquitectura a una infraestructura de mensajer√≠a espec√≠fica, que generalmente utiliza un intermediario. </li><li>  Una dificultad clave en la mensajer√≠a es la publicaci√≥n y actualizaci√≥n de la base de datos.  Una buena soluci√≥n es utilizar la plantilla de publicaci√≥n de eventos: el mensaje se escribe en la base de datos al principio como parte de la transacci√≥n.  Luego, un proceso separado recupera el mensaje de la base de datos utilizando la plantilla de Interrogating Publisher o Transactional Log Tracking, y lo pasa al intermediario. </li></ul><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Para Khabrozhiteley 30% de descuento en libros de pre-pedido en un cup√≥n - <b>Microservicios</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458344/">https://habr.com/ru/post/458344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458332/index.html">Programaci√≥n as√≠ncrona: rendimiento as√≠ncrono: comprenda los costos de as√≠ncrono y aguarde</a></li>
<li><a href="../458334/index.html">Replicaci√≥n continua de PostgreSQL antiguo a nuevo con Slony</a></li>
<li><a href="../458336/index.html">El ciclo completo de desarrollo de productos de TI utilizando el ejemplo del proyecto: roles de equipo, tareas del cliente, etapas</a></li>
<li><a href="../458338/index.html">Gerente de Seguridad de Aplicaciones. Desarrollador o seguridad?</a></li>
<li><a href="../458342/index.html">Texturizado, o lo que necesitas saber para convertirte en un Artista de Surface. Parte 1. Pixel</a></li>
<li><a href="../458346/index.html">Resoluci√≥n de problemas con pwnable.kr 01 - fd. Descriptores de archivo y procesos</a></li>
<li><a href="../458350/index.html">Revisi√≥n sucia de Twitter del VS7.0-ER</a></li>
<li><a href="../458352/index.html">[Peter] Reuni√≥n JUG.ru con Cliff Click - ¬øUna JVM hace eso?</a></li>
<li><a href="../458354/index.html">Introducci√≥n a la inversi√≥n desde cero utilizando IDA PRO</a></li>
<li><a href="../458356/index.html">Estudiamos el calendario</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>