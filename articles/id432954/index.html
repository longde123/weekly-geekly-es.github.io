<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè´ üññüèº üôçüèª Dan lagi ke luar angkasa: bagaimana unicorn Stellarium dikunjungi üñêüèº ü§¥üèº üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama seluruh periode keberadaan mereka, orang-orang telah berupaya keras untuk mempelajari hampir seluruh area langit berbintang. Hingga saat ini, k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dan lagi ke luar angkasa: bagaimana unicorn Stellarium dikunjungi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/432954/">  Selama seluruh periode keberadaan mereka, orang-orang telah berupaya keras untuk mempelajari hampir seluruh area langit berbintang.  Hingga saat ini, kami telah memeriksa ratusan ribu asteroid, komet, nebula, dan bintang, galaksi, dan planet.  Untuk melihat semua keindahan ini sendiri, tidak perlu meninggalkan rumah dan membeli sendiri teleskop.  Anda dapat menginstal Stellarium - planetarium virtual di komputer Anda, dan melihat langit malam, berbaring dengan nyaman di sofa ... Tetapi apakah itu nyaman?  Untuk mengetahui jawaban atas pertanyaan ini, kami akan memeriksa Stellarium untuk kesalahan dalam kode komputer. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/c8b/129/4b8c8b12983537442bfea4700cadca97.png"></div><br><a name="habracut"></a><br><h2>  Sedikit tentang proyek ... </h2><br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi</a> di situs web Wikipedia, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stellarium</a> adalah planetarium virtual open-source yang tersedia untuk Linux, Mac OS X, Microsoft Windows, Symbian, Android dan iOS, serta MeeGo.  Program ini menggunakan teknologi OpenGL dan Qt untuk menciptakan langit yang realistis secara real time.  Dengan Stellarium Anda dapat melihat apa yang dapat Anda lihat dengan teleskop berukuran sedang dan bahkan besar.  Program ini juga menyediakan pengamatan gerhana matahari dan pergerakan komet. <br><br>  Stellarium dibuat oleh programmer Prancis Fabian Chereau, yang meluncurkan proyek pada musim panas 2001.  Pengembang terkemuka lainnya termasuk Robert Spearman, Johannes Gadzhozik, Matthew Gates, Timothy Reeves, Bogdan Marinov dan Johan Meeris, yang bertanggung jawab atas karya seni tersebut. <br><br><h2>  ... dan tentang penganalisa </h2><br>  Analisis proyek dilakukan menggunakan penganalisis kode statis PVS-Studio.  Ini adalah alat untuk mendeteksi kesalahan dan kerentanan potensial dalam kode sumber program yang ditulis dalam C, C ++ dan C # (segera di Jawa!).  Ini berjalan pada Windows, Linux, dan macOS.  Ini dirancang untuk mereka yang perlu meningkatkan kualitas kode mereka. <br><br>  Analisisnya cukup sederhana.  Pertama, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh</a> proyek Stellarium dari GitHub, dan kemudian menginstal semua paket yang diperlukan untuk perakitan.  Karena proyek dibangun menggunakan Qt Creator, saya menggunakan sistem pelacakan peluncuran kompiler, yang dibangun ke dalam versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mandiri</a> dari penganalisa.  Di sana Anda dapat melihat laporan analisis yang sudah selesai. <br><br>  Pembaca baru dan pengguna <b><i>Stellarium</i></b> mungkin bertanya-tanya: mengapa unicorn muncul dalam judul artikel dan bagaimana kaitannya dengan analisis kode?  Saya menjawab: Saya adalah salah satu pengembang PVS-Studio, dan unicorn adalah maskot nakal favorit kami.  Jadi naik! <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfc/8f2/aab/bfc8f2aaba0bf61f3b40d4d0765dd027.png"></div><br>  Saya berharap bahwa berkat artikel ini, pembaca akan belajar sesuatu yang baru untuk diri mereka sendiri, dan pengembang Stellarium akan dapat menghilangkan beberapa kesalahan dan meningkatkan kualitas kode. <br><br>  Bawalah kopi dengan croissant udara dan buat diri Anda nyaman, karena kita akan ke bagian yang paling menarik - ikhtisar hasil analisis dan analisis kesalahan! <br><br><h2>  Kondisi mencurigakan </h2><br>  Untuk kesenangan membaca yang lebih besar, saya sarankan untuk tidak langsung melihat peringatan penganalisa, tetapi coba di sini dan lebih jauh untuk menemukan kesalahan sendiri. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QZipReaderPrivate::scanFiles() { .... <span class="hljs-comment"><span class="hljs-comment">// find EndOfDirectory header int i = 0; int start_of_directory = -1; EndOfDirectory eod; while (start_of_directory == -1) { const int pos = device-&gt;size() - int(sizeof(EndOfDirectory)) - i; if (pos &lt; 0 || i &gt; 65535) { qWarning() &lt;&lt; "QZip: EndOfDirectory not found"; return; } device-&gt;seek(pos); device-&gt;read((char *)&amp;eod, sizeof(EndOfDirectory)); if (readUInt(eod.signature) == 0x06054b50) break; ++i; } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringatan</a> <b>PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V654</a> Kondisi 'start_of_directory == - 1' dari loop selalu benar.  qzip.cpp 617 <br><br>  Bisakah Anda menemukan kesalahan?  Jika demikian, maka pujilah. <br><br>  Kesalahannya terletak pada kondisi <i>loop sementara</i> .  Itu selalu benar, karena variabel <i>start_of_directory</i> tidak berubah dalam tubuh loop.  Kemungkinan besar, siklus tidak akan abadi, karena mengandung <i>kembali</i> dan <i>rusak</i> , tetapi kode tersebut terlihat aneh. <br><br>  Sepertinya saya bahwa dalam kode mereka lupa membuat tugas <i>start_of_directory = pos</i> di tempat di mana tanda tangan sedang diverifikasi.  Maka pernyataan <i>break</i> mungkin berlebihan.  Dalam hal ini, kode dapat ditulis ulang seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start_of_directory = <span class="hljs-number"><span class="hljs-number">-1</span></span>; EndOfDirectory eod; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start_of_directory == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = device-&gt;size() - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(EndOfDirectory)) - i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span>) { qWarning() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"QZip: EndOfDirectory not found"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } device-&gt;seek(pos); device-&gt;read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;eod, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(EndOfDirectory)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readUInt(eod.signature) == <span class="hljs-number"><span class="hljs-number">0x06054b50</span></span>) start_of_directory = pos; ++i; }</code> </pre> <br>  Namun, saya tidak yakin kode harus seperti apa.  Yang terbaik adalah pengembang proyek itu sendiri menganalisis bagian dari program ini dan membuat perubahan yang diperlukan. <br><br>  Kondisi aneh lainnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StelProjectorCylinder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StelProjector { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersectViewportDiscontinuityInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3d&amp; capN, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capD)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capN, capD)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cap.intersects(cap1) &amp;&amp; cap.intersects(cap2) &amp;&amp; cap.intersects(cap2); } };</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> Ada sub-ekspresi identik 'cap.intersects (cap2)' di kiri dan di kanan operator '&amp;&amp;'.  StelProjectorClasses.hpp 175 <br><br>  Seperti yang mungkin sudah Anda tebak, kesalahan terletak pada baris terakhir fungsi: programmer membuat kesalahan ketik, dan pada akhirnya ternyata fungsi mengembalikan hasil terlepas dari nilai <i>cap3</i> . <br><br>  Jenis kesalahan ini sangat umum: di hampir setiap proyek yang diuji, kami telah menemukan kesalahan ketik yang terkait dengan nama-nama bentuk <i>name1</i> dan <i>name2</i> dan sejenisnya.  Biasanya, kesalahan seperti itu terkait dengan salin-tempel. <br><br>  Contoh kode ini adalah contoh utama dari pola kesalahan umum lainnya, yang bahkan kami lakukan studi-mini terpisah.  Rekan saya Andrei Karpov menyebutnya " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">efek garis terakhir</a> ."  Jika Anda tidak terbiasa dengan materi ini, saya sarankan membuka tab di browser untuk dibaca nanti, tetapi untuk sekarang, mari kita lanjutkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BottomStelBar::updateText(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> updatePos) { .... updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location-&gt;text() != newLocation || updatePos) { updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fov-&gt;text() != str) { updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fps-&gt;text() != str) { updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatePos) { .... } }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V560</a> Bagian dari ekspresi kondisional selalu benar: updatePos.  StelGuiItems.cpp 732 </li><li>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> 'updatePos' selalu benar.  StelGuiItems.cpp 831 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V763</a> Parameter 'updatePos' selalu ditulis ulang di badan fungsi sebelum digunakan.  StelGuiItems.cpp 690 </li></ul><br>  Nilai parameter <i>updatePos</i> selalu ditimpa sebelum digunakan, mis.  fungsi akan bekerja sama, terlepas dari nilai yang diteruskan ke sana. <br><br>  Terlihat aneh, bukan?  Di semua tempat di mana parameter <i>updatePos terlibat</i> , itu <i>benar</i> .  Ini berarti bahwa kondisi <i>if (location-&gt; text ()! = NewLocation || updatePos)</i> dan <i>if (updatePos)</i> akan selalu benar. <br><br>  Cuplikan lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LandscapeMgr::onTargetLocationChanged(StelLocation loc) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pl &amp;&amp; flagEnvironmentAutoEnabling) { QSettings* conf = StelApp::getInstance().getSettings(); setFlagAtmosphere(pl-&gt;hasAtmosphere() &amp; conf-&gt;value(<span class="hljs-string"><span class="hljs-string">"landscape/flag_atmosphere"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>).toBool()); setFlagFog(pl-&gt;hasAtmosphere() &amp; conf-&gt;value(<span class="hljs-string"><span class="hljs-string">"landscape/flag_fog"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>).toBool()); setFlagLandscape(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } .... }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V792</a> Fungsi 'toBool' yang terletak di sebelah kanan operator '&amp;' akan dipanggil terlepas dari nilai operan kiri.  Mungkin, lebih baik menggunakan '&amp;&amp;'.  LandscapeMgr.cpp 782 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V792</a> Fungsi 'toBool' yang terletak di sebelah kanan operator '&amp;' akan dipanggil terlepas dari nilai operan kiri.  Mungkin, lebih baik menggunakan '&amp;&amp;'.  LandscapeMgr.cpp 783 </li></ul><br>  Penganalisis mendeteksi ekspresi mencurigakan dalam argumen ke fungsi <i>setFlagAtmosphere</i> dan <i>setFlagFog</i> .  Memang: di kedua sisi operator bit <i>&amp; ada</i> nilai tipe <i>bool</i> .  Alih-alih operator <i>&amp;</i> , Anda harus menggunakan operator <i>&amp;&amp;</i> , dan sekarang saya akan menjelaskan alasannya. <br><br>  Ya, hasil dari ungkapan ini akan selalu benar.  Sebelum menggunakan bitwise "dan", kedua operan akan dipromosikan ke <i>int</i> .  Di C ++, konversi seperti itu <a href="">tidak ambigu</a> : false dikonversi ke 0, dan true dikonversi ke 1. Oleh karena itu, hasil dari ekspresi ini akan sama seperti jika operator <i>&amp;&amp;</i> digunakan. <br><br>  Namun ada nuansa.  Saat menghitung hasil operasi <i>&amp;&amp;</i> , apa yang disebut "perhitungan malas" digunakan.  Jika nilai operan kiri <i>salah</i> , maka nilai kanan bahkan tidak dihitung, karena logika "dan" dalam hal apa pun akan mengembalikan <i>false</i> .  Ini dilakukan untuk menghemat sumber daya komputasi dan memungkinkan Anda untuk menulis desain yang lebih kompleks.  Misalnya, Anda dapat memverifikasi bahwa pointer bukan nol, dan jika demikian, lakukan referensi untuk melakukan pemeriksaan tambahan.  Contoh: <i>if (ptr &amp;&amp; ptr-&gt; foo ())</i> . <br><br>  "Perhitungan malas" seperti itu tidak dilakukan dengan menggunakan operator bitwise <i>&amp;</i> : ekspresi <i>conf-&gt; nilai ("...", true). ToBool ()</i> akan dievaluasi setiap waktu, terlepas dari nilai <i>pl-&gt; hasAtmosphere ()</i> . <br><br>  Dalam kasus yang jarang terjadi, ini dilakukan dengan sengaja.  Misalnya, jika menghitung operan yang tepat memiliki "efek samping," hasilnya akan digunakan kemudian.  Tidak terlalu baik untuk melakukannya, karena mempersulit pemahaman kode dan mempersulit pemeliharaan.  Selain itu, urutan penghitungan operan <i>&amp;</i> tidak ditentukan, sehingga dalam beberapa kasus menggunakan "trik" seperti itu Anda bisa mendapatkan perilaku yang tidak terdefinisi. <br><br>  Jika Anda perlu menyimpan efek samping - lakukan dalam baris terpisah dan simpan hasilnya dalam variabel terpisah.  Orang-orang yang akan bekerja dengan kode ini di masa depan akan berterima kasih kepada Anda :) <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/301/5a6/971/3015a69710bc07f948b5233dac04fc87.png"></div><br>  Kami melanjutkan ke topik berikutnya. <br><br><h2>  Penanganan memori salah </h2><br>  Mari kita mulai topik memori dinamis dengan fragmen ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/************ Basic Edge Operations ****************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* __gl_meshMakeEdge creates one edge, * two vertices, and a loop (face). * The loop consists of the two new half-edges. */</span></span> GLUEShalfEdge* __gl_meshMakeEdge(GLUESmesh* mesh) { GLUESvertex* newVertex1 = allocVertex(); GLUESvertex* newVertex2 = allocVertex(); GLUESface* newFace = allocFace(); GLUEShalfEdge* e; <span class="hljs-comment"><span class="hljs-comment">/* if any one is null then all get freed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( newVertex1 == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || newVertex2 == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || newFace == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertex1 != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { memFree(newVertex1); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertex2 != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { memFree(newVertex2); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newFace != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { memFree(newFace); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } e = MakeEdge(&amp;mesh-&gt;eHead); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } MakeVertex(newVertex1, e, &amp;mesh-&gt;vHead); MakeVertex(newVertex2, e-&gt;Sym, &amp;mesh-&gt;vHead); MakeFace(newFace, e, &amp;mesh-&gt;fHead); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V773</a> Fungsi itu keluar tanpa melepaskan pointer 'newVertex1'.  Kebocoran memori dimungkinkan.  mesh.c 312 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V773</a> Fungsi itu keluar tanpa melepaskan pointer 'newVertex2'.  Kebocoran memori dimungkinkan.  mesh.c 312 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V773</a> Fungsi itu keluar tanpa melepaskan pointer 'newFace'.  Kebocoran memori dimungkinkan.  mesh.c 312 </li></ul><br>  Fungsi ini mengalokasikan memori untuk beberapa struktur dan meneruskannya ke pointer <i>newVertex1</i> , <i>newVertex2</i> (nama yang menarik, bukan?) Dan <i>newFace</i> .  Jika salah satunya berubah menjadi nol, maka semua memori yang disimpan di dalam fungsi dibebaskan, setelah itu aliran kontrol meninggalkan fungsi. <br><br>  Apa yang terjadi jika memori untuk ketiga struktur dialokasikan dengan benar, dan fungsi <i>MakeEdge (&amp; mesh-&gt; eHead)</i> mengembalikan <i>NULL</i> ?  Aliran kontrol akan mencapai pengembalian kedua. <br><br>  Karena pointer <i>newVertex1</i> , <i>newVertex2</i> dan <i>newFace</i> adalah variabel lokal, mereka tidak akan ada lagi setelah keluar dari fungsi.  Tetapi pelepasan memori milik mereka tidak akan terjadi.  Itu akan tetap dicadangkan, tetapi kami tidak akan lagi memiliki akses ke sana. <br><br>  Situasi seperti ini disebut kebocoran memori.  Skenario khas dengan kesalahan seperti itu: dengan penggunaan program yang berkepanjangan, ia mulai mengkonsumsi lebih banyak dan lebih banyak RAM, hingga habisnya. <br><br>  Perlu dicatat bahwa dalam contoh ini, pengembalian ketiga tidak salah.  Fungsi <i>MakeVertex</i> dan <i>MakeFace</i> mentransfer alamat memori yang dialokasikan ke struktur data lain, sehingga mendelegasikan tanggung jawab untuk rilisnya. <br><br>  Kelemahan berikutnya adalah dalam metode, yang membutuhkan 90 baris.  Untuk kenyamanan, saya menguranginya, hanya menyisakan area masalah. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AstroCalcDialog::drawAngularDistanceGraph() { .... QVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; xs, ys; .... }</code> </pre> <br>  Hanya satu baris yang tersisa.  Biarkan saya memberi Anda petunjuk: ini adalah satu-satunya penyebutan objek <i>xs</i> dan <i>ys</i> . <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  Objek 'xs' V808 dari tipe 'QVector' telah dibuat tetapi tidak digunakan.  AstroCalcDialog.cpp 5329 </li><li>  Objek 'ys' V808 dari tipe 'QVector' telah dibuat tetapi tidak digunakan.  AstroCalcDialog.cpp 5329 </li></ul><br>  Vektor <i>xs</i> dan <i>ys</i> dibuat, tetapi tidak digunakan di mana pun.  Ternyata setiap kali Anda menggunakan metode <i>drawAngularDistanceGraph</i> , kreasi dan penghapusan ekstra dari wadah kosong terjadi.  Saya pikir iklan ini tetap dalam kode setelah refactoring.  Ini, tentu saja, bukan kesalahan, tetapi Anda harus menghapus kode tambahan. <br><br><h2>  Gips tipe aneh </h2><br>  Contoh lain setelah sedikit pemformatan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SatellitesDialog::updateSatelliteData() { .... <span class="hljs-comment"><span class="hljs-comment">// set default buttonColor = QColor(0.4, 0.4, 0.4); .... }</span></span></code> </pre> <br>  Untuk memahami apa kesalahannya, Anda harus melihat prototipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruktor kelas Qcolor</a> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/84e/798/f7d84e79849bca96f7a27016aec0e9d3.png"></div><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V674</a> '0,4' tipe 'ganda' literal secara implisit dilemparkan ke tipe 'int' sambil memanggil fungsi 'QColor'.  Periksa argumen pertama.  SatellitesDialog.cpp 413 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V674</a> '0,4' tipe 'ganda' literal secara implisit dilemparkan ke tipe 'int' sambil memanggil fungsi 'QColor'.  Periksa argumen kedua.  SatellitesDialog.cpp 413 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V674</a> '0,4' tipe 'ganda' literal secara implisit dilemparkan ke tipe 'int' sambil memanggil fungsi 'QColor'.  Periksa argumen ketiga.  SatellitesDialog.cpp 413 </li></ul><br>  Kelas <i>Qcolor</i> tidak memiliki konstruktor yang menerima tipe <i>ganda</i> , jadi argumen dalam contoh ini akan secara implisit dikonversi ke <i>int</i> .  Ini menyebabkan bidang <i>r</i> , <i>g</i> , <i>b</i> dari objek <i>buttonColor</i> memiliki nilai <i>0</i> . <br><br>  Jika programmer berniat untuk membuat objek dari nilai tipe <i>double</i> , ia harus menggunakan konstruktor yang berbeda. <br><br>  Misalnya, Anda bisa menggunakan konstruktor yang menerima <i>Qrgb</i> dengan menulis: <br><br><pre> <code class="cpp hljs">buttonColor = QColor(QColor::fromRgbF(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>));</code> </pre> <br>  Itu bisa dilakukan secara berbeda.  Qt menggunakan nilai nyata dalam kisaran [0,0, 1.0] atau nilai integer dalam kisaran [0, 255] untuk menunjukkan warna RGB. <br><br>  Oleh karena itu, programmer dapat menerjemahkan nilai dari real ke integer dengan menulis seperti ini: <br><br><pre> <code class="cpp hljs">buttonColor = QColor((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">0.4</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">0.4</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">0.4</span></span>));</code> </pre> <br>  atau adil <br><br><pre> <code class="cpp hljs">buttonColor = QColor(<span class="hljs-number"><span class="hljs-number">102</span></span>, <span class="hljs-number"><span class="hljs-number">102</span></span>, <span class="hljs-number"><span class="hljs-number">102</span></span>);</code> </pre> <br>  Apakah kamu bosan?  Jangan khawatir: ada kesalahan lebih menarik di depan kita. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/aa0/297/f18aa02975f89e9e6cc7c661706fc608.png"></div><br>  <font color="#999999"><i>"Unicorn di luar angkasa."</i></font>  <font color="#999999"><i>Pemandangan dari Stellarium.</i></font> <br><br><h2>  Kesalahan lainnya </h2><br>  Pada akhirnya, saya meninggalkan Anda lebih lezat :) Mari kita turun ke salah satu dari mereka. <br><br><pre> <code class="cpp hljs">HipsTile* HipsSurvey::getTile(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> order, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pix) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (order == orderMin &amp;&amp; !allsky.isNull()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbw = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">12</span></span> * <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * order)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (pix % nbw) * allsky.width() / nbw; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (pix / nbw) * allsky.width() / nbw; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = allsky.width() / nbw; QImage image = allsky.copy(x, y, s, s); .... } .... }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V634</a> Prioritas operasi '*' lebih tinggi daripada operasi '&lt;&lt;'.  Mungkin tanda kurung harus digunakan dalam ekspresi.  StelHips.cpp 271 <br><br>  Nah, apakah Anda bisa mendeteksi kesalahan?  Pertimbangkan ungkapan <i>(12 * 1 &lt;&lt; (2 * urutan))</i> lebih terinci.  Penganalisa mengingat bahwa operasi ' <i>*</i> ' memiliki prioritas lebih tinggi daripada operasi pergeseran bit ' <i>&lt;&lt;</i> '.  Sangat mudah untuk melihat bahwa mengalikan <i>12</i> dengan <i>1 tidak</i> ada gunanya, dan tanda kurung sekitar <i>2 *</i> tidak diperlukan. <br><br><pre> <code class="cpp hljs"> ,    : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbw = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">12</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * order));     &lt;i&gt;<span class="hljs-number"><span class="hljs-number">12</span></span> &lt;/i&gt;     .</code> </pre> <br>  Catatan  Selain itu, saya ingin mencatat bahwa jika nilai operan kanan ' <i>&lt;&lt;</i> ' lebih besar atau sama dengan jumlah bit dari operan kiri, maka hasilnya tidak ditentukan.  Karena literal numerik adalah <i>int</i> secara default, yang membutuhkan <i>32</i> bit, nilai parameter <i>urutan</i> tidak boleh lebih dari <i>15</i> .  Jika tidak, evaluasi ekspresi dapat mengakibatkan perilaku yang tidak terdefinisi. <br><br>  Kami melanjutkan.  Metode di bawah ini sangat membingungkan, tapi saya yakin pembaca yang canggih akan menangani deteksi kesalahan :) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* inherits documentation from base class */</span></span> QCPRange QCPStatisticalBox:: getKeyRange(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; foundRange, SignDomain inSignDomain) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inSignDomain == sdBoth) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inSignDomain == sdNegative) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inSignDomain == sdPositive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); } } foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); }</code> </pre> <br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V779</a> Kode yang tidak dapat dideteksi terdeteksi.  Mungkin saja ada kesalahan.  qcustomplot.cpp 19512. <br><br>  Faktanya adalah bahwa semua <i>jika ...</i> cabang <i>lain</i> memiliki <i>pengembalian</i> .  Oleh karena itu, aliran kontrol tidak pernah mencapai dua baris terakhir. <br><br>  Pada umumnya, contoh ini akan berjalan secara normal dan bekerja dengan benar.  Tetapi kehadiran kode yang tidak dapat dijangkau sendiri merupakan sinyal.  Dalam hal ini, ini menunjukkan struktur metode yang salah, yang sangat menyulitkan keterbacaan dan kelengkapan kode. <br><br>  Fragmen kode ini harus di refactored, mendapatkan fungsi yang lebih rapi pada output.  Misalnya, seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* inherits documentation from base class */</span></span> QCPRange QCPStatisticalBox:: getKeyRange(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; foundRange, SignDomain inSignDomain) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (inSignDomain) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sdBoth: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sdNegative: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sdPositive: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); }</code> </pre> <br>  Yang terakhir dalam ulasan kami adalah kesalahan yang paling saya sukai.  Kode tempat masalah pendek dan sederhana: <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br>  Pernahkah Anda memperhatikan sesuatu yang mencurigakan?  Tidak semua orang bisa :) <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V603</a> Objek telah dibuat tetapi tidak digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; Plane :: Plane (....)' harus digunakan.  Plane.cpp 29 <br><br>  Pemrogram berharap bahwa beberapa bidang objek akan diinisialisasi di dalam konstruktor bersarang, tetapi ternyata seperti ini: ketika konstruktor <i>Plane (Vec3f &amp; v1, Vec3f &amp; v2, Vec3f &amp; v3)</i> dipanggil, objek sementara yang tidak disebutkan namanya dibuat di dalamnya, yang segera dihapus.  Akibatnya, bagian dari objek tetap tidak diinisialisasi. <br><br>  Agar kode berfungsi dengan benar, Anda harus menggunakan fitur C ++ 11 yang nyaman dan aman - konstruktor yang mendelegasikan: <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f&amp; v1, Vec3f&amp; v2, Vec3f&amp; v3) : Plane(v1, v2, v3, SPolygon::CCW) { distance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; sDistance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre> <br>  Tetapi jika Anda menggunakan kompiler untuk versi bahasa yang lebih lama, maka Anda dapat menulis seperti ini: <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Plane::Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br>  Atau lebih: <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br>  Saya perhatikan bahwa dua metode terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat berbahaya</a> .  Karena itu, Anda harus sangat berhati-hati dan memahami dengan baik bagaimana metode tersebut bekerja. <br><br><h2>  Kesimpulan </h2><br>  Kesimpulan apa yang dapat dibuat tentang kualitas kode Stellarium?  Jujur saja, tidak banyak kesalahan.  Juga, dalam keseluruhan proyek, saya tidak menemukan kesalahan tunggal di mana kode terkait dengan perilaku yang tidak ditentukan.  Untuk proyek opensource, kualitas kode ternyata berada pada tingkat tinggi, yang saya angkat topi untuk para pengembang.  Kalian hebat!  Saya senang dan tertarik untuk meninjau proyek Anda. <br><br>  Bagaimana dengan planetarium itu sendiri - saya sering menggunakannya.  Sayangnya, tinggal di kota, saya jarang dapat menikmati langit malam yang cerah, dan Stellarium memungkinkan saya untuk berada di mana saja di dunia tanpa bangun dari sofa.  Sangat nyaman! <br><br>  Saya terutama menyukai mode "Constellation art".  Melihat sosok-sosok besar yang menutupi seluruh langit dalam tarian aneh sungguh menakjubkan. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/3d5/107/6133d51079ac983aa11a017acd1945ee.png"></div><br>  <font color="#999999"><i>"Tarian yang aneh."</i></font>  <font color="#999999"><i>Pemandangan dari Stellarium.</i></font> <br><br>  Earthlings cenderung membuat kesalahan, dan tidak ada yang memalukan dalam kenyataan bahwa kesalahan ini bocor ke dalam kode.  Untuk ini, alat analisis kode, seperti PVS-Studio, dikembangkan.  Jika Anda salah satu penduduk dunia - <strike>menyukainya, saya</strike> sarankan Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unduh dan coba sendiri</a> . <br><br>  Saya harap Anda tertarik membaca artikel saya, dan Anda mempelajari sesuatu yang baru dan berguna untuk diri Anda sendiri.  Dan saya berharap para pengembang koreksi awal dari kesalahan yang ditemukan. <br><br>  Berlangganan saluran kami dan tetap ikuti berita dari dunia pemrograman! <br><br><ul><li>  Vk: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li><li>  Telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li><li>  Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li><li>  YouTube: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@PVSStudioTool</a> </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: George Gribkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Into Space Again: bagaimana Unicorn Mengunjungi Stellarium</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432954/">https://habr.com/ru/post/id432954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432940/index.html">50 warna token</a></li>
<li><a href="../id432942/index.html">Pola corutin dan antipatterns di Kotlin</a></li>
<li><a href="../id432944/index.html">Optimalisasi kueri PostgreSQL paksa</a></li>
<li><a href="../id432946/index.html">Unity - Jebakan Pengembangan Game 2D</a></li>
<li><a href="../id432948/index.html">Cloud pintar, perusahaan pintar: bagaimana AI mengubah industri komputasi awan</a></li>
<li><a href="../id432956/index.html">Monster dari Id: bagaimana Doom dibuat</a></li>
<li><a href="../id432958/index.html">Paradoks kuantum baru mengklarifikasi bahwa ide-ide kita tentang kenyataan ternyata salah</a></li>
<li><a href="../id432960/index.html">Mengapa konsumen tidak takut pencurian identitas</a></li>
<li><a href="../id432964/index.html">Tentang kekuasaan baik atau tidak sama sekali: inisiatif legislatif baru di Federasi Rusia</a></li>
<li><a href="../id432966/index.html">Bootloader terenkripsi untuk STM32</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>