<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õìÔ∏è ‚ôøÔ∏è ü•• Palestra "Fundamentos do Processamento Digital de Sinais" ü§¶üèª üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üë®üèæ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Muitas vezes, as pessoas recorrem a mim com perguntas sobre tarefas do campo de processamento de sinal digital (DSP). Digo em detalhes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Palestra "Fundamentos do Processamento Digital de Sinais"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460445/">  Ol√° pessoal! <br><br>  Muitas vezes, as pessoas recorrem a mim com perguntas sobre tarefas do campo de processamento de sinal digital (DSP).  Digo em detalhes as nuances, sugiro as fontes de informa√ß√£o necess√°rias.  Mas todos os ouvintes, como o tempo demonstrou, carecem de tarefas e exemplos pr√°ticos no processo de aprendizado desta √°rea.  A esse respeito, decidi escrever um pequeno curso interativo sobre processamento de sinais digitais e coloc√°-lo em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dom√≠nio p√∫blico</a> . <br><br>  A maior parte do material de treinamento para apresenta√ß√£o visual e interativa √© implementada usando o <i>Jupyter Notebook</i> .  Sup√µe-se que o leitor tenha conhecimento b√°sico do campo da matem√°tica superior, bem como um pequeno comando da linguagem de programa√ß√£o Python. <br><br><img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2>  Lista de palestras </h2><br>  Este curso cont√©m materiais na forma de palestras conclu√≠das sobre v√°rios t√≥picos da √°rea de processamento de sinal digital.  Os materiais s√£o apresentados usando bibliotecas Python (pacotes numpy, scipy, matplotlib, etc.).  As informa√ß√µes b√°sicas deste curso foram extra√≠das de minhas palestras, que eu, como estudante de gradua√ß√£o, dei aos alunos do Instituto de Energia de Moscou (NRU MEI).  Parte das informa√ß√µes dessas palestras foi usada em semin√°rios de treinamento no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Center for Contemporary Electronics</a> , onde eu atuava como palestrante.  Al√©m disso, este material inclui a tradu√ß√£o de v√°rios artigos cient√≠ficos, compila√ß√£o de informa√ß√µes de fontes confi√°veis ‚Äã‚Äãe literatura sobre processamento de sinais digitais, al√©m de documenta√ß√£o oficial sobre pacotes de aplicativos e fun√ß√µes internas das bibliotecas scipy e numpy do Python. <br><br>  Para usu√°rios do MATLAB (GNU Octave), n√£o √© dif√≠cil dominar o material do ponto de vista do c√≥digo do programa, pois as principais fun√ß√µes e seus atributos s√£o amplamente id√™nticos e semelhantes aos m√©todos das bibliotecas Python. <br><br>  Todos os materiais s√£o agrupados pelos principais t√≥picos do processamento de sinal digital: <br><br><ol><li>  Sinais: anal√≥gico, discreto, digital.  Convers√£o Z </li><li>  Transformada de Fourier: amplitude e sinal de fase, DFT e FFT, </li><li>  Convolu√ß√£o e correla√ß√£o.  Convolu√ß√£o linear e c√≠clica.  Convolu√ß√£o r√°pida </li><li>  Processos aleat√≥rios.  Ru√≠do branco.  Fun√ß√£o densidade de probabilidade </li><li>  Sinais determin√≠sticos.  Modula√ß√£o: AM, FM, FM, LFM.  Manipula√ß√£o </li><li>  Filtro de Sinal: IIR, filtros FIR </li><li>  A janela funciona em tarefas de filtragem.  Detec√ß√£o de sinais fracos. </li><li>  Reamostragem: dizima√ß√£o e interpola√ß√£o.  Filtros CIC, filtros de m√©dia m√≥vel </li></ol><br><br>  A lista de palestras √© suficiente <s>, mas, √© claro, incompleta</s> para um conhecimento introdut√≥rio do DSP.  Com o tempo livre, pretendo apoiar e desenvolver este projeto. <br><br><h3>  Onde encontrar? </h3><br>  Todos os materiais s√£o <b>absolutamente gratuitos</b> e dispon√≠veis como reposit√≥rio aberto no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu github como um projeto de c√≥digo-fonte aberto</a> .  Os materiais s√£o apresentados em dois formatos - na forma de cadernos Jupyter para trabalho interativo, estudo e edi√ß√£o, e na forma de arquivos HTML compilados a partir desses cadernos (ap√≥s o download no github, eles t√™m um formato bastante adequado para leitura e impress√£o). <br><br>  A seguir, √© apresentada uma <u>breve</u> descri√ß√£o das se√ß√µes do curso, com breves explica√ß√µes, termos e defini√ß√µes.  Informa√ß√µes b√°sicas est√£o dispon√≠veis nas palestras iniciais, aqui est√° apenas uma breve vis√£o geral! <br><br><h3>  Sinais.  Convers√£o Z </h3><br>  Se√ß√£o introdut√≥ria, que cont√©m informa√ß√µes b√°sicas sobre os tipos de sinais.  O conceito de sequ√™ncia discreta, fun√ß√£o delta e fun√ß√£o Heaviside (salto unit√°rio) √© introduzido. <br><br>  Todos os sinais de acordo com o m√©todo de apresenta√ß√£o no aparelho podem ser divididos em quatro grupos: <br><ul><li>  anal√≥gico - s√£o descritos por fun√ß√µes cont√≠nuas no tempo, </li><li>  discreto - s√£o interrompidos no tempo com uma etapa especificada por amostragem, </li><li>  quantizado - possui um conjunto de n√≠veis finitos (geralmente em amplitude), </li><li>  digital - uma combina√ß√£o das propriedades de sinais discretos e quantizados. </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="Signals"><br><br>  Para a reconstru√ß√£o correta de um sinal anal√≥gico de um digital sem distor√ß√£o e perda, √© utilizado o teorema de amostragem conhecido como teorema de <b>Kotelnikov (Nyquist-Shannon)</b> . <br><blockquote>  Qualquer sinal cont√≠nuo com um espectro limitado pode ser restaurado de forma √∫nica e sem perda de suas amostras discretas, coletadas com uma frequ√™ncia estritamente maior que o dobro da frequ√™ncia superior do espectro de um sinal cont√≠nuo. </blockquote><br>  Essa interpreta√ß√£o √© v√°lida desde que a fun√ß√£o cont√≠nua do tempo ocupe uma faixa de frequ√™ncia de 0 ao valor da frequ√™ncia superior.  Se as etapas de quantiza√ß√£o e discretiza√ß√£o forem escolhidas incorretamente, o sinal ser√° distorcido de anal√≥gico para discreto. <br><br>  Tamb√©m nesta se√ß√£o, a <b>transforma√ß√£o Z</b> e suas propriedades s√£o descritas e a representa√ß√£o de sequ√™ncias discretas na forma Z √© mostrada. <br><br>  Exemplo de uma sequ√™ncia discreta finita: <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  . <br>  Um exemplo da mesma sequ√™ncia no formato Z: <br><br>  X (z) = 2 + z <sup>-1</sup> - 2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3>  Transformada de Fourier.  Propriedades  DFT e FFT </h3><br>  Esta se√ß√£o descreve o conceito do dom√≠nio do tempo e da frequ√™ncia de um sinal.  A defini√ß√£o da transformada discreta de Fourier (DFT) √© introduzida.  As DFTs diretas e inversas e suas principais propriedades s√£o consideradas.  √â mostrada a transi√ß√£o do DFT para o algoritmo de transformada r√°pida de Fourier (FFT) na base 2 (algoritmos de dizima√ß√£o em frequ√™ncia e tempo).  Refletiu a efic√°cia da FFT em compara√ß√£o com a DFT. <br><br>  Em particular, esta se√ß√£o descreve o pacote Python scipy.ffpack para calcular v√°rias transformadas de Fourier (seno, cosseno, direto, inverso, multidimensional, real). <br><br>  A transforma√ß√£o de Fourier permite representar qualquer fun√ß√£o como um conjunto de sinais harm√¥nicos!  A transformada de Fourier √© a base dos m√©todos de convolu√ß√£o e do design de correlacionadores digitais, √© usada ativamente na an√°lise espectral e usada ao trabalhar com n√∫meros longos. <br><br>  Caracter√≠sticas dos espectros de sinais discretos: <br>  1. A densidade espectral de um sinal discreto √© uma fun√ß√£o peri√≥dica com um per√≠odo igual √† frequ√™ncia de amostragem. <br>  2. Se a sequ√™ncia discreta for <i>real</i> , o m√≥dulo de densidade espectral dessa sequ√™ncia √© uma fun√ß√£o <i>par</i> e o argumento √© <i>uma</i> fun√ß√£o de frequ√™ncia <i>√≠mpar</i> . <br><br>  Espectro de Sinal Harm√¥nico: <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="FFT para cosseno"><br><br><h4>  Compara√ß√£o da efic√°cia da DFT e da FFT </h4><br>  A efici√™ncia do algoritmo FFT e o n√∫mero de opera√ß√µes realizadas linearmente dependem do comprimento da sequ√™ncia N: <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  N </th><th colspan="2">  DFT </th><th colspan="2">  FFT </th><th rowspan="2">  A propor√ß√£o do n√∫mero de adi√ß√µes complexas </th><th rowspan="2">  A propor√ß√£o do n√∫mero de multiplica√ß√µes complexas </th></tr><tr><th>  O n√∫mero de opera√ß√µes de multiplica√ß√£o </th><th>  N√∫mero de opera√ß√µes de adi√ß√£o </th><th>  O n√∫mero de opera√ß√µes de multiplica√ß√£o </th><th>  N√∫mero de opera√ß√µes de adi√ß√£o </th></tr></thead><tbody><tr><td>  2 </td><td>  4 </td><td>  2 </td><td>  1 </td><td>  2 </td><td>  4 </td><td>  1 </td></tr><tr><td>  4 </td><td>  16 </td><td>  12 </td><td>  4 </td><td>  8 </td><td>  4 </td><td>  1.5 </td></tr><tr><td>  8 </td><td>  64 </td><td>  56. </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  16 </td><td>  256 </td><td>  240 </td><td>  32. </td><td>  64 </td><td>  8 </td><td>  3,75 </td></tr><tr><td>  32. </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12,8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21,3 </td><td>  10,5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36,6 </td><td>  18,1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br>  Como voc√™ pode ver, quanto maior a dura√ß√£o da convers√£o, maiores as economias em recursos de computa√ß√£o (em termos de velocidade de processamento ou n√∫mero de unidades de hardware)! <br><br>  Qualquer forma de onda arbitr√°ria pode ser representada como um conjunto de sinais harm√¥nicos de diferentes frequ√™ncias.  Em outras palavras, um sinal de forma complexa no dom√≠nio do tempo possui um conjunto de amostras complexas no dom√≠nio da frequ√™ncia, denominadas * harm√¥nicas *.  Essas amostras expressam a amplitude e a fase do efeito harm√¥nico em uma frequ√™ncia espec√≠fica.  Quanto maior o conjunto de harm√¥nicos no dom√≠nio da frequ√™ncia, mais precisa √© a forma de onda complexa. <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT Gibbs"><br><br><h3>  Convolu√ß√£o e correla√ß√£o </h3><br>  Esta se√ß√£o apresenta o conceito de correla√ß√£o e convolu√ß√£o para seq√º√™ncias aleat√≥rias e determin√≠sticas discretas.  A rela√ß√£o entre autocorrela√ß√£o e fun√ß√µes de correla√ß√£o cruzada com convolu√ß√£o √© mostrada.  As propriedades da convolu√ß√£o s√£o descritas, em particular, s√£o considerados os m√©todos de convolu√ß√£o linear e c√≠clica de um sinal discreto com an√°lise detalhada no exemplo de uma sequ√™ncia discreta.  Al√©m disso, √© mostrado um m√©todo para calcular a convolu√ß√£o "r√°pida" usando algoritmos FFT. <br><br>  Em problemas reais, a quest√£o √© frequentemente levantada sobre o grau de semelhan√ßa de um processo com outro ou sobre a independ√™ncia de um processo em rela√ß√£o a outro.  Em outras palavras, √© necess√°rio determinar a rela√ß√£o entre os sinais, ou seja, para encontrar uma <i>correla√ß√£o</i> .  Os m√©todos de correla√ß√£o s√£o usados ‚Äã‚Äãem uma ampla gama de tarefas: busca de sinais, vis√£o computacional e processamento de imagens, em problemas de radar para determinar as caracter√≠sticas dos alvos e determinar a dist√¢ncia a um objeto.  Al√©m disso, a correla√ß√£o √© usada para procurar sinais fracos no ru√≠do. <br><br>  <b>A convolu√ß√£o</b> descreve a intera√ß√£o dos sinais entre si.  Se um dos sinais √© a resposta de impulso do filtro, a convolu√ß√£o da sequ√™ncia de entrada com a resposta de impulso n√£o passa de uma rea√ß√£o do circuito √† a√ß√£o de entrada.  Em outras palavras, o sinal resultante reflete a passagem do sinal atrav√©s do filtro. <br><br>  <i>A fun√ß√£o de autocorrela√ß√£o</i> (ACF) √© usada na informa√ß√£o de codifica√ß√£o.  A escolha da sequ√™ncia de codifica√ß√£o de acordo com os par√¢metros de comprimento, frequ√™ncia e forma √© em grande parte devido √†s propriedades de correla√ß√£o dessa sequ√™ncia.  A melhor sequ√™ncia de c√≥digo tem a menor probabilidade de detec√ß√£o ou opera√ß√£o falsa (para detectar sinais, para dispositivos de limite) ou sincroniza√ß√£o falsa (para transmitir e receber sequ√™ncias de c√≥digo). <br><br>  Esta se√ß√£o apresenta uma tabela comparando a efic√°cia da convolu√ß√£o r√°pida e da convolu√ß√£o calculada pela f√≥rmula direta (pelo n√∫mero de multiplica√ß√µes reais). <br><br>  Como voc√™ pode ver, para FFT de at√© 64, a convolu√ß√£o r√°pida <u>perde</u> para o m√©todo direto.  No entanto, com um aumento no comprimento da FFT, os resultados mudam na dire√ß√£o oposta - uma convolu√ß√£o r√°pida come√ßa a superar o m√©todo direto.  Obviamente, quanto maior a FFT, melhor o ganho no m√©todo de frequ√™ncia. <br><br><div class="scrollable-table"><table><thead><tr><th>  N </th><th>  Convolu√ß√£o </th><th>  Convolu√ß√£o r√°pida </th><th>  Atitude </th></tr></thead><tbody><tr><td>  8 </td><td>  64 </td><td>  448 </td><td>  0,14 </td></tr><tr><td>  16 </td><td>  256 </td><td>  1088 </td><td>  0,24 </td></tr><tr><td>  32. </td><td>  1024 </td><td>  2560 </td><td>  0,4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0,7 </td></tr><tr><td>  128 </td><td>  16K </td><td>  13312 </td><td>  1,23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4M </td><td>  311296 </td><td>  <b>13,5</b> </td></tr></tbody></table></div><br><h3>  Sinais aleat√≥rios e ru√≠do </h3><br>  Nesta se√ß√£o, √© introduzido o conceito de sinais aleat√≥rios, densidade de probabilidade e lei de distribui√ß√£o aleat√≥ria.  Momentos matem√°ticos s√£o considerados - m√©dia (expectativa matem√°tica) e vari√¢ncia (ou a raiz dessa quantidade √© o desvio padr√£o).  Tamb√©m nesta se√ß√£o, a distribui√ß√£o normal e o conceito relacionado de <i>ru√≠do branco</i> s√£o considerados como a principal fonte de ru√≠do (interfer√™ncia) durante o processamento do sinal. <br><br>  <i>Um sinal aleat√≥rio</i> √© uma fun√ß√£o do tempo cujos valores n√£o s√£o conhecidos antecipadamente e s√≥ podem ser previstos com alguma <i>probabilidade</i> .  As principais caracter√≠sticas dos sinais aleat√≥rios incluem: <br><br><ul><li>  lei de distribui√ß√£o (o tempo de perman√™ncia relativo do valor do sinal em um determinado intervalo), </li><li>  distribui√ß√£o espectral da pot√™ncia do sinal. </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="Noise AWGN"><br><br>  Nas tarefas DSP, os sinais aleat√≥rios s√£o divididos em duas classes: <br><br><ul><li>  ru√≠do - flutua√ß√µes aleat√≥rias constitu√≠das por um conjunto de diferentes frequ√™ncias e amplitudes, </li><li>  sinais que transportam informa√ß√µes, para cujo processamento √© necess√°rio recorrer a m√©todos probabil√≠sticos. </li></ul><br><br>  Usando vari√°veis ‚Äã‚Äãaleat√≥rias, podemos simular o efeito de um meio real na passagem de um sinal de uma fonte para um receptor de dados.  Quando um sinal passa por algum link barulhento, o chamado ru√≠do branco √© adicionado ao sinal.  Como regra, a densidade espectral de tal ru√≠do √© distribu√≠da uniformemente (igualmente) em todas as frequ√™ncias, e os valores de ru√≠do no dom√≠nio do tempo s√£o normalmente distribu√≠dos (lei de distribui√ß√£o gaussiana).  Como o ru√≠do branco √© fisicamente adicionado √†s amplitudes do sinal nas amostras de tempo selecionadas, ele √© chamado de ru√≠do gaussiano aditivo branco (AWGN). <br><br><h3>  Sinais, Modula√ß√£o e Manipula√ß√£o </h3><br>  Esta se√ß√£o mostra os m√©todos b√°sicos para alterar um ou mais par√¢metros de um sinal harm√¥nico.  Os conceitos de amplitude, frequ√™ncia e modula√ß√£o de fase s√£o introduzidos.  Em particular, a modula√ß√£o linear de frequ√™ncia usada em problemas de radar √© destacada.  As principais caracter√≠sticas dos sinais, os espectros dos sinais modulados, dependendo dos par√¢metros de modula√ß√£o s√£o mostrados. <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="Modula√ß√£o de frequ√™ncia"><br><br>  Por conveni√™ncia, um conjunto de fun√ß√µes foi criado no Python que implementa os tipos de modula√ß√£o acima.  Exemplo de implementa√ß√£o do sinal chirp: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="Modula√ß√£o Chirp"><br><br>  Tamb√©m nesta se√ß√£o da teoria da transmiss√£o de mensagens discretas s√£o descritos tipos de modula√ß√£o digital - manipula√ß√µes.  Como no caso de sinais anal√≥gicos, as seq√º√™ncias harm√¥nicas digitais podem ser manipuladas em amplitude, fase e frequ√™ncia (ou v√°rios par√¢metros ao mesmo tempo). <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="Manipula√ß√£o de Freq"><br><br><h3>  Filtros Digitais - IIR e FIR </h3><br>  Uma se√ß√£o suficientemente grande dedicada √† filtragem digital de sequ√™ncias discretas.  Nas tarefas de processamento de sinal digital, os dados fluem atrav√©s de circuitos chamados <b>filtros</b> .  Os filtros digitais, como os anal√≥gicos, t√™m caracter√≠sticas diferentes - frequ√™ncia: resposta de frequ√™ncia, resposta de fase, tempo: resposta de impulso, bem como a caracter√≠stica de transfer√™ncia do filtro.  Os filtros digitais s√£o usados ‚Äã‚Äãprincipalmente para melhorar a qualidade do sinal - para isolar um sinal de uma sequ√™ncia de dados ou para degradar sinais indesejados - para suprimir certos sinais nas seq√º√™ncias de amostras recebidas. <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="Sinais IIR FIR"><br><br>  A se√ß√£o lista as principais vantagens e desvantagens dos filtros digitais (comparados aos anal√≥gicos).  √â introduzido o conceito de caracter√≠sticas de impulso e transfer√™ncia do filtro.  Duas classes de filtros s√£o consideradas - com uma resposta de impulso infinito (IIR) e uma resposta de impulso finito (FIR).  Um m√©todo para projetar filtros na forma <b>can√¥nica</b> e <b>direta</b> √© mostrado.  Para filtros FIR, a quest√£o de como alternar para um formato recursivo √© considerada. <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="Esquema IIR FIR"><br><br>  Para filtros FIR, o processo de design do filtro √© mostrado desde o est√°gio de desenvolvimento das especifica√ß√µes t√©cnicas (com os principais par√¢metros indicados) at√© a implementa√ß√£o de software e hardware - procure coeficientes de filtro (levando em considera√ß√£o a forma de representa√ß√£o do n√∫mero, profundidade de bits etc.).  S√£o introduzidas as defini√ß√µes de filtros FIR sim√©tricos, resposta de fase linear e sua rela√ß√£o com o conceito de atraso de grupo. <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="Caminho completo da FIR"><br><br><h3>  Fun√ß√µes de janela em tarefas de filtragem </h3><br>  Nas tarefas de processamento de sinal digital, s√£o utilizadas fun√ß√µes de janela de v√°rias formas, as quais, quando sobrepostas a um sinal no dom√≠nio do tempo, podem melhorar qualitativamente suas caracter√≠sticas espectrais.  Um grande n√∫mero de v√°rias janelas se deve principalmente a um dos principais recursos de qualquer sobreposi√ß√£o de janela.  Esse recurso √© expresso na rela√ß√£o entre o n√≠vel dos lobos laterais e a largura do lobo central.  Regra: <br><blockquote>  Quanto mais forte a supress√£o dos lobos laterais do espectro, maior o l√≥bulo principal do espectro e vice-versa. </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="Vit√≥rias (tempo)"><br><br>  Uma das aplica√ß√µes das fun√ß√µes da janela: detec√ß√£o de sinais fracos contra o fundo dos mais fortes, suprimindo o n√≠vel dos lobos laterais.  As fun√ß√µes da janela principal nas tarefas DSP s√£o: ** triangular, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, janela Blackman-Harris, janela plana, Natall, Gauss, janela Kaiser ** e muitas outras.  A maioria deles √© expressa atrav√©s de uma s√©rie finita pela soma de sinais harm√¥nicos com pesos espec√≠ficos.  Tais sinais s√£o perfeitamente implementados na pr√°tica em qualquer dispositivo de hardware (circuitos l√≥gicos program√°veis ‚Äã‚Äãou processadores de sinais). <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="Vit√≥rias (freq)"><br><br><h3>  Reamostragem.  Dizima√ß√£o e interpola√ß√£o </h3><br>  Esta se√ß√£o discute os problemas do processamento de sinal em v√°rias velocidades - altera√ß√µes na frequ√™ncia de amostragem.  O processamento de sinais em v√°rias velocidades (processamento em m√∫ltiplas taxas) sugere que, no processo de convers√£o linear de sinais digitais, √© poss√≠vel alterar a frequ√™ncia de amostragem no sentido de diminuir ou aumentar, ou em um n√∫mero fracion√°rio de vezes.  Isso leva a um processamento de sinal mais eficiente, pois abre a possibilidade de usar as frequ√™ncias m√≠nimas de amostragem permitidas e, como resultado, uma redu√ß√£o significativa no desempenho computacional necess√°rio do sistema digital projetado. <br><br>  <i>Dizima√ß√£o</i> (dizima√ß√£o) - downsampling.  <i>Interpola√ß√£o</i> - aumentando a taxa de amostragem. <br><br>  A se√ß√£o tamb√©m considera a classe de filtros FIR homog√™neos, chamados de filtros de pente integral (CIC, integrador em cascata - pente).  A implementa√ß√£o, propriedades b√°sicas e recursos dos filtros CIC s√£o mostrados.  Devido √† linearidade das opera√ß√µes matem√°ticas que ocorrem no filtro CIC, √© poss√≠vel cascatear v√°rios filtros em sequ√™ncia, o que proporciona uma diminui√ß√£o proporcional no n√≠vel dos lobos laterais, mas tamb√©m aumenta o "bloqueio" do l√≥bulo principal da caracter√≠stica de amplitude-frequ√™ncia. <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="Filtro de cascata cic"><br><br>  Gr√°fico da resposta em frequ√™ncia do filtro, dependendo do coeficiente de dizima√ß√£o: <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="Resposta CIC Freq"><br><br>  Tamb√©m nesta se√ß√£o, discutimos a quest√£o de aumentar a profundidade de bits dos dados na sa√≠da do filtro CIC, dependendo de seus par√¢metros.  Isso √© especialmente importante nas tarefas de implementa√ß√£o de software, principalmente nos FPGAs. <br><br>  Para a implementa√ß√£o pr√°tica de filtros CIC em Python, uma classe separada <b>CicFilter foi desenvolvida</b> que implementa m√©todos de dizima√ß√£o e interpola√ß√£o.  Tamb√©m s√£o mostradas altera√ß√µes na taxa de amostra usando os m√©todos internos do pacote Python scipy. <br><br><div class="spoiler">  <b class="spoiler_title">Classe Python CicFilter para processamento de sinal digital</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="Dizima√ß√£o / Interpola√ß√£o CIC"><br><br>  Por fim, esta se√ß√£o fornece uma classe especial de filtros - a m√©dia m√≥vel.  Tr√™s m√©todos de implementa√ß√£o s√£o mostrados: atrav√©s da convolu√ß√£o de sinais, usando um filtro FIR e um filtro IIR. <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF, filtro de m√©dia m√≥vel"><br><br><h3>  Conclus√£o </h3><br>  Espero que este curso de palestras em conjunto com meus artigos anteriores sobre processamento digital de sinais FPGA traga benef√≠cios pr√°ticos e ajude o leitor a entender melhor os conceitos b√°sicos do processamento digital de sinais.  Este projeto ser√° aprimorado e complementado com novo material √∫til e n√£o menos interessante.  Siga o desenvolvimento! <br><br>  Al√©m deste material, apoio e desenvolvo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu projeto</a> nos principais m√≥dulos DSP (em Python).  Ele cont√©m um pacote para gerar v√°rios sinais, uma classe de filtros CIC para problemas de dizima√ß√£o e interpola√ß√£o, um algoritmo para calcular os coeficientes de um filtro FIR de corre√ß√£o, um filtro de m√©dia m√≥vel, um algoritmo para calcular uma FFT ultra longa atrav√©s de m√©todos de convers√£o bidimensional (este √∫ltimo foi muito √∫til ao trabalhar com implementa√ß√£o de hardware em FPGAs) . <br><br>  Obrigado pela aten√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460445/">https://habr.com/ru/post/pt460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460435/index.html">Petty little joy # 8: prazeres mesquinhos por trabalhar com o banco de dados</a></li>
<li><a href="../pt460437/index.html">Como colocamos uma bicicleta de suporte t√©cnico</a></li>
<li><a href="../pt460439/index.html">Linguagem de programa√ß√£o P4</a></li>
<li><a href="../pt460441/index.html">Gleb Nitzman: ‚ÄúEncontrei o final de uma era em que as pessoas ainda n√£o haviam perseguido o ouro contido nos elementos radioel√©tricos‚Äù</a></li>
<li><a href="../pt460443/index.html">Designers vs desenvolvedores: sobre a hist√≥ria da cria√ß√£o do aplicativo ‚ÄúMy smart city‚Äù</a></li>
<li><a href="../pt460451/index.html">O homem fez seu terceiro ouvido para o mundo inteiro usar - pelo bem da arte</a></li>
<li><a href="../pt460453/index.html">Impressora inteligente. Melhorando o Octoprint</a></li>
<li><a href="../pt460457/index.html">Esta√ß√£o de energia solar DIY 200 m2</a></li>
<li><a href="../pt460459/index.html">Arquivo de configura√ß√£o htaccess</a></li>
<li><a href="../pt460461/index.html">Simula√ß√£o de ataques direcionados como uma avalia√ß√£o de seguran√ßa. Instru√ß√µes de Cyber ‚Äã‚Äãdo Teaming vermelho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>