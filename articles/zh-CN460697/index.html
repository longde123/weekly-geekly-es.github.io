<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥋 👨‍⚖️ 🗓️ 最小的字体 🍚 🎠 👨🏿‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="任务：使用尽可能少的资源，渲染有意义的文本。 


- 可读字体可以有多小？ 
- 存储需要多少内存？ 
- 使用它需要多少代码？ 


 让我们看看我们得到了什么。 扰流板 



 位图简介 


计算机将位图显示为位图。 这与.bmp格式无关，而与在内存中存储像素的方式有关。 要了解正在发生的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>最小的字体</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460697/"><p> 任务：使用尽可能少的资源，渲染有意义的文本。 </p><br><ul><li> 可读字体可以有多小？ </li><li> 存储需要多少内存？ </li><li>使用它需要多少代码？ </li></ul><br><p> 让我们看看我们得到了什么。 扰流板 </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy"> 位图简介 </h2><br><p>计算机将位图显示为位图。 这与<code>.bmp</code>格式无关，而与在内存中存储像素的方式有关。 要了解正在发生的事情，我们需要学习一些有关这种方式的知识。 </p><br><h3 id="sloi"> 层数 </h3><br><p> 图像通常在彼此之上包含多个<em>图层</em> 。 通常，它们对应于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RGB颜色空间</a>的坐标。 一层代表<em>红色</em> ，一层代表<em>绿色</em> ，一层代表<em>蓝色</em> 。 如果图像格式支持透明度，则为其创建第四层，通常称为<em>alpha</em> 。 粗略地说，彩色图像是三个（如果有alpha通道，则为四个）黑白，一个位于另一个之上。 </p><br><ul><li>  RGB不是唯一的色彩空间。  JPEG格式例如使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">YUV</a> 。 但是在本文中，我们将不需要其余的色彩空间，因此我们不考虑它们。 </li></ul><br><p> 可以通过两种方式在内存中表示一组图层。 要么将它们分开存储，要么将来自不同层的值进行交错。 在后一种情况下，图层称为<em>channel</em> ，这就是大多数现代格式的工作方式。 </p><br><p> 假设我们有一个包含三个图层的4x4绘图： <em>R</em>代表红色， <em>G</em>代表绿色， <em>B</em>代表每个像素的蓝色分量。 可以这样表示： </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p> 所有三层都分别存储。 交替格式看起来有所不同： </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li> 每三个字符对应一个像素 </li><li> 三元组中的值按<em>RGB</em>顺序排列。 有时可以使用不同的顺序（例如<em>BGR</em> ），但这是最常见的顺序。 </li></ul><br><p> 为简单起见，我以二维矩阵的形式排列像素，因为这样可以更清楚地看到图像中这个或那个三元组的位置。 但实际上，计算机内存不是二维的，而是一维的，因此4x4图片将按以下方式存储： </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p> 缩写<em>bpp</em>表示每个像素的位数或字节数（每个像素的位数/字节）。 您可能在<code>3bpp</code>看到过<code>24bpp</code>或<code>3bpp</code> 。 这两个特性意味着同一件事- <strong>每个像素24 <em>位</em></strong>或<strong>每个像素</strong> <strong>3 <em>个字节</em></strong> 。 由于一个字节中总是有8位，因此您可以根据所讨论的单位的值进行猜测。 </p><br><h3 id="predstavlenie-v-pamyati"> 内存表示 </h3><br><p>  <code>24bpp</code> ，又名<code>3bpp</code>用于存储鲜花的最常见格式。 这就是<em>RGB</em>顺序的<strong>单个像素</strong>如何看待各个位的电平。 </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  <em>R的</em>一个字节， <em>G的</em>一个字节， <em>B的</em>一个字节，总共三个字节。 </li><li> 它们每个都包含从0到255的值。 </li></ul><br><p> 因此，如果给定像素具有以下颜色： </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p> 然后，在第一个字节<code>255</code>存储<code>255</code> ，在第二个字节<code>255</code>存储<code>80</code> ，在第三个字节<code>255</code>存储<code>100</code> 。 </p><br><p> 通常，这些值以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">十六进制表示</a> 。 说<code>#ff5064</code> 。 这更加方便和紧凑： <code>R = 0xff</code> （即<code>R=255</code>以十进制表示）， <code>G = 0x50</code> （= <code>G=80</code> ）， <code>B=0x64</code> （= <code>B=100</code> ）。 </p><br><ul><li> 十六进制表示法具有一个有用的属性。 由于颜色的每个字节都由两个字符表示，因此每个字符<strong>正好</strong>编码半个字节或四位。 顺便说一下，4位称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nibble</a> 。 </li></ul><br><h3 id="shirina-stroki"> 线宽 </h3><br><p> 当像素接一个又一个并且每个像素包含多个通道时，数据很容易混淆。 不知道一行的结束时间和下一行的开始时间，因此，要使用位图解释文件，您需要知道图像大小和<em>bpp</em> 。 在我们的例子中，图片的宽度为<code>w = 4</code>像素，每个像素包含3个字节，因此该字符串使用12个字节（通常为<code>w*bpp</code> ）进行编码。 </p><br><ul><li> 字符串不一定总是使用精确的<code>w*bpp</code>字节编码； 通常，将“隐藏”像素添加到其中以使图像宽度达到某个大小。 例如，当图片的像素大小等于2的幂时，缩放图片会更快，更方便。 因此，该文件可能包含（用户可访问）120x120像素的图像，但被存储为128x128的图像。 当屏幕上显示图像时，这些像素将被忽略。 但是，我们不需要了解它们。 </li></ul><br><p> 一维表示中任何像素<code>(x, y)</code>的坐标为<code>(y * w + x) * bpp</code> 。 通常，这很明显： <code>y</code>是行号，每行包含<code>w</code>像素，因此<code>y * w</code>是所需行的开头， <code>+x</code>将我们带到其中的所需<code>x</code> 。 而且由于坐标不是以字节为单位，而是以像素为单位，因此所有这些都乘以<code>bpp</code>像素的大小（在这种情况下为字节）。 由于像素的大小非零，因此您需要从接收到的坐标开始精确地读取<code>bpp</code>字节，我们将完整显示所需像素。 </p><br><h2 id="atlas-shrifta"> 字体图集 </h2><br><p> 实际上，现有的监视器并不整体显示一个像素，而是显示三个子像素-红色，蓝色和绿色。 如果以放大倍数查看监视器，将会看到类似以下内容： </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基百科</a>绘图 </li></ul><br><p> 我们对LCD感兴趣，因为最有可能是您从阅读此文本的监视器中获得的。 当然，有一些陷阱： </p><br><ul><li> 并非所有矩阵都使用此子像素顺序，有时使用BGR。 </li><li> 如果转动显示器（例如，以横向方向看手机），图案也会旋转，字体也会停止工作。 </li><li> 不同的矩阵方向和子像素的排列将需要对字体本身进行重新加工。 </li><li> 特别是，它不适用于使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PenTile布局的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AMOLED显示器</a> 。 此类显示器最常用于移动设备中。 </li></ul><br><p> 使用亚像素技巧提高分辨率称为亚<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">像素渲染</a> 。 例如，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关其在排版中的使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> 。 </p><br><p> 对我们来说幸运的是，马特·萨尔诺夫（Matt Sarnov）已经想出了使用亚像素渲染来创建微型字体的方法。 手工地，他创造了这张小图片： </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p> 如果您非常仔细地看一下显示器，则其外观如下所示： </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p> 在这里，它以编程方式增加了12倍： </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p> 根据他的工作，我创建了一个字体图集，其中每个字符对应于<code>1x5</code>像素的列。 字符顺序如下： </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p> 同一图集增加了12倍： </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p> 使用36个字符，可以精确地<code>365</code>像素。 如果我们假设每个像素占用3个字节，那么我们需要<code>36*5*3 = 540</code>个字节来存储整个图片（ <em>原始</em>图片中大约为<em>。::有关alpha通道的一系列令人困惑的编辑，删除元数据等）。在翻译中，我省略了它，只使用了文件的最终版本</em> 。 通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pngcrush</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optipng</a>传递的PNG文件花费更少： </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p> 但是，如果使用稍微不同的方法，则可以实现更小的尺寸 </p><br><h1 id="szhatie"> 压缩方式 </h1><br><p> 细心的读者会注意到地图集仅使用7种颜色： </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra"> 调色板 </h2><br><p> 在这种情况下，创建调色板通常更容易。 然后，对于每个像素，您不能存储三个字节的颜色，而只能存储调色板中的颜色编号。 在我们的例子中，3位（ <code>7 &lt; 2^3</code> ）足以从7种颜色中进行选择。 如果我们为每个像素分配一个三位的值，那么整个地图集将适合<em>68个字节</em> 。 </p><br><ul><li> 精通数据压缩的读者可以回答说，通常存在“分数位”之类的东西，在我们的例子中， <strong>每个像素2.875位就</strong>足够了。 这种密度可以使用称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算术编码的</a>黑魔法来实现。 我们不会这样做，因为算术编码是一件很复杂的事情，而且68个字节已经有点了。 </li></ul><br><h2 id="vyravnivanie"> 对齐方式 </h2><br><p> 三位编码具有一个严重的缺点。 像素不能均匀分布在8位字节上，这很重要，因为字节是最小的可寻址存储区。 假设我们要保存三个像素： </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p> 如果每个位占用3位，则将需要2个字节来存储它们（ <code>-</code>表示未使用的位）： </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p> 重要的是，像素<strong>C</strong>不仅会留下一堆空白； 它在两个字节之间被<em>撕裂</em> 。 当我们开始添加以下像素时，它们可以相对于字节边界任意定位。 最简单的解决方案是对每个像素使用半字节，因为8被完美地除以4，并允许您在每个字节中恰好放置两个像素。 但这会将地图集的大小增加了三分之一，从<strong>68个字节</strong>增加到<strong>90个字节</strong> 。 </p><br><ul><li> 实际上，使用回文编码，间隔编码和其他压缩技术可以使文件更小。 像算术编码一样，我们将这些技术推迟到下一篇文章。 </li></ul><br><h2 id="bitovyy-bufer"> 位缓冲器 </h2><br><p> 幸运的是，使用3位值根本没有什么不可能。 您只需要监视当前正在写入或读取的字节中的哪个位置。 以下简单类将3位数据流转换为字节数组。 </p><br><ul><li> 出于可读性原因，代码是用JS编写的，但是相同的方法可以推广到其他语言。 </li><li> 从低字节到高字节的使用顺序（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小端</a> ） </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p> 让我们下载并编码图集文件： </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p> 正如预期的那样，地图集可容纳<strong>68个字节</strong> ，比PNG文件小6倍。 </p><br><p>  （ <em>注：作者有点不屑一顾：他没有保存调色板和图像大小，根据我的估计，这将需要23个字节（具有固定的调色板大小，并将图像大小增加到91个字节</em> ）） </p><br><p> 现在，将图像转换为字符串，以便将其粘贴到源代码中。 本质上， <code>to_string</code>方法<code>to_string</code>此操作：它以十六进制数表示每个字节的内容。 </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p> 但是结果字符串仍然很长，因为我们将自己限制为16个字符的字母。 您可以将其替换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">base64</a> ，其中的字符数是原来的四倍。 </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p> 在base64中，地图集如下所示： </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p> 该行可以硬编码到JS模块，并用于光栅化文本。 </p><br><h1 id="rasterizaciya"> 栅格化 </h1><br><p> 为了节省内存，一次只能解码一个字母。 </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  <code>decode</code>功能将字符作为输入，并返回源图像中的相应列。 这里令人印象深刻的是，解码单个字符仅需<strong>5个字节的</strong>内存，再加上<strong>〜1.875</strong>个字节即可读取所需的数组片段，即 平均每封信<strong>6.875</strong> 。 如果您添加<strong>68个字节</strong>来存储数组并添加<strong>36个字节</strong>来存储字母，那么<em>理论上</em>可以用128个字节的RAM渲染文本。 </p><br><ul><li> 如果您用C或汇编器重写代码，则可以这样做。 在JS开销的背景下，这可以节省匹配项。 </li></ul><br><p> 剩下的只是将这些列收集为一个整体并返回带有文本的图片。 </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p> 这将是最小的字体。 </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p> 添加一点<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">imagemagick</a>以获得可读格式的图像： </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p> 这是最终结果： </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p> 它也增加了12倍： </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p> 是从校准不良的监视器宏拍摄的： </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p> 最后，最好在显示器上： </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460697/">https://habr.com/ru/post/zh-CN460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460675/index.html">机器学习数据提取</a></li>
<li><a href="../zh-CN460683/index.html">Laravel事件投影仪和事件生成概念</a></li>
<li><a href="../zh-CN460685/index.html">我们使用nginx分发Google云端硬盘中的文件</a></li>
<li><a href="../zh-CN460687/index.html">从内部看罐头</a></li>
<li><a href="../zh-CN460695/index.html">什么是DAA，该系统如何帮助无人机？</a></li>
<li><a href="../zh-CN460699/index.html">《哈伯周刊》第10期/超级服务和电子护照，智能手机和俄罗斯人，“间谍小工具”，无卫星生活</a></li>
<li><a href="../zh-CN460701/index.html">课程“数据科学入门”：处理数据的第一步</a></li>
<li><a href="../zh-CN460703/index.html">机遇之蓝：从零到40万视频采访</a></li>
<li><a href="../zh-CN460707/index.html">游戏开发人员该停止听粉丝们了吗？</a></li>
<li><a href="../zh-CN460709/index.html">关于敏捷的思考</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>