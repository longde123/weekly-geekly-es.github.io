<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíó ‚úÇÔ∏è üî¶ So sehen Sie Nachhall oder Video√ºbertragung durch Ton durch Wasser - 2 üñáÔ∏è üí• ü§ô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Schatz! 

 Heute werden wir das Bild wieder mit Ultraschall durch das Wasser √ºbertragen: Wir werden buchst√§blich Nachhall und Echo sehen und sog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So sehen Sie Nachhall oder Video√ºbertragung durch Ton durch Wasser - 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453678/"><h3>  Hallo Schatz! </h3><br><br>  Heute werden wir das Bild wieder mit Ultraschall durch das Wasser √ºbertragen: Wir werden buchst√§blich Nachhall und Echo sehen und sogar, wie sie sich je nach den Bedingungen √§ndern.  Alles, was ich Ihnen sagen werde, ist einfach. Es ist interessant, es selbst zu wiederholen und kann von fast jedem durchgef√ºhrt werden. <br><br>  Wenn durch diese Worte etwas in deiner Seele flattert, willkommen bei Kat, im dunklen Wasser unseres Teiches! <br><br><img src="https://habrastorage.org/webt/e7/dd/ql/e7ddqlsffkcu34ex7scxfsvt4fs.png"><br><a name="habracut"></a><br><br><blockquote>  "Der beste Rest ist, bekannte Wahrheiten zu interpretieren."  (C) ABS, Mittag, XXII Jahrhundert </blockquote><br><br><h3>  Vorspiel </h3><br>  Die Grundregel des Clubs der Zeugen der Hydroakustik lautet, dass Videos mit Hydroakustik in einer mehr oder weniger signifikanten Entfernung (mehr als einige Meter) im mittleren Gew√§sser nicht √ºbertragen werden k√∂nnen und immer unm√∂glich sein werden. <br>  Daf√ºr gibt es schwerwiegende Gr√ºnde - einen Kommunikationskanal mit einer sehr geringen Bandbreite, einer geringen Signalausbreitungsgeschwindigkeit (in Wasser nur 1.500 m / s) und einer hohen Fehlerwahrscheinlichkeit.  Das verf√ºgbare Frequenzband betr√§gt nur einige zehn Kilohertz. <br>  Dies ist jedoch noch nicht alles - wenn sich relativ gesehen ein Signal mit Frequenzen in der Gr√∂√üenordnung von 10 kHz in einer Entfernung von etwa 8 bis 10 km im Wasser ausbreitet, dann sind es bei einer Frequenz von 20 kHz bereits 3 bis 5 km, und je h√∂her die Frequenz, desto st√§rker die D√§mpfung .  Beispielsweise arbeiten unsere kleinsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uWAVE-</a> Modems der Welt im 20-30-kHz-Band und √ºbertragen Daten mit einer Geschwindigkeit von 78 Bit / s pro 1000 Meter und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RedLINE</a> mit einem Band von 5-15 bis 8000 Metern.  Der Rekord unter den kommerziellen Ger√§ten geh√∂rt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EvoLogics</a> - 68 kBit pro 300 Meter. <br>  Die Physik kann leider nicht get√§uscht werden und es ist unm√∂glich, ihr zuzustimmen - sie kann entweder sehr langsam und ger√§uschunempfindlich oder schnell, aber √ºber kurze Entfernungen √ºbertragen werden. <br>  In einigen F√§llen ist es jedoch m√∂glich, ‚Äûeinige Ecken abzuschneiden‚Äú, wobei die Ecken, die wir dieses Mal abschneiden, niedriger sind. <br><br><h3>  Was werden wir heute tun und was wird daf√ºr ben√∂tigt? </h3><br>  In fr√ºheren Artikeln haben wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûVideo‚Äú mit Ton durch Wasser √ºbertragen</a> . Ich erinnere Sie daran, dass dort der Rahmen ‚Äûauf das Spektrum gezeichnet‚Äú wurde, dh das Spektrum oder vielmehr das Spektrogramm des Signals war ein Bild. <br>  Sp√§ter haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfache hydroakustische Antennen aus M√ºll hergestellt</a> und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachste hydroakustische Modem hergestellt</a> .  Dort haben wir auch einen Vorverst√§rker f√ºr die Antenne hergestellt (hier liegt noch das Design der Leiterplatte zur Eigenproduktion durch LUT-Ohm). <br><br>  Wir dachten uns, wie sonst k√∂nnen Sie versuchen, das Bild so zu vermitteln, dass selbst ein <s>Kindergartensch√ºler</s> es herausfinden kann, und wie es uns scheint, haben sie einen noch einfacheren Weg gefunden als zuvor. <br><br>  Um es zusammenzufassen, erstellen Sie eine Liste dessen, was wir brauchen: <br><br>  - ein Paar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sonarantennen von Tortenpfl√ºckern</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorverst√§rker</a> von LUT <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode des</a> C # -Projekts <br>  - ein Paar Bleibatterien mit 12 Volt <br>  - ein Verst√§rker auf TDA, ich nahm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen</a> f√ºr nur 50 Rubel auf Ali <br><br><h3>  Ein bisschen Theorie </h3><br>  Denken Sie daran, dass unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sonarmodem</a> auf einem einfachen Tondetektor basiert, dessen Frequenz viermal niedriger ist als die Abtastfrequenz.  Erinnern Sie sich kurz daran, wie es funktioniert. <br><img src="https://habrastorage.org/webt/__/zm/oe/__zmoe1u0jzgjderykrsaogn0k8.png"><br><br>  Das Bild zeigt zwei Schwingungen, die auf Pi / 2 relativ zueinander verschoben sind, dh die Sinus- und die Cosinusphase.  Und wenn die Frequenz genau viermal niedriger als die Abtastfrequenz ist, fallen nur vier Abtastwerte auf die Periode. <br>  Ein aufmerksamer Habuchitel bemerkte sicherlich, dass beide Signale auf Pi / 4 verschoben sind.  Bei einer solchen Verschiebung nimmt das Signal nur zwei Werte an: ‚àö2 / 2 und -‚àö2 / 2. <br>  Und bestimmte Werte sind nicht einmal wichtig, es ist wichtig, dass Sie nur die Zeichen "+" und "-" verwenden k√∂nnen. <br><br>  Jetzt k√∂nnen wir die Sinusphase als Folge von Zeichen "+" "+" "-" "-" und die Cosinusphase als "+" "-" "-" "+" darstellen. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederholen Sie unter dem Spoiler den Detektor:</b> <div class="spoiler_text"> Wenn sich das Eingangssignal im sn-Puffer befindet, haben wir zwei Ringmittelungspuffer f√ºr die Sinus- und Cosinusphase - bs und bc der Gr√∂√üe N. Sie haben gemeinsame Kopf- und Schwanzzeiger - bH und bT.  Zum anf√§nglichen Zeitpunkt ist bH = N-1, bT = 0. Mittelungszyklusz√§hler C = 0. <br>  Wir nehmen 4 Samples aus dem Eingabepuffer und f√ºgen sie entsprechend den Zeichenfolgen hinzu. <br><br> <code>a = sn(i) <br> bs(bH) = a <br> bc(bH) = a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+1) <br> bs(bH) = a <br> bc(bH) = -a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+2) <br> bs(bH) = -a <br> bc(bH) = -a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+3) <br> bs(bH) = -a <br> bc(bH) = a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br></code> <br><br>  Nach jeder Verarbeitung von vier Abtastwerten √ºberpr√ºfen wir den Z√§hler der Mittelungszyklen und berechnen, wenn er N √ºberschritten hat, die Amplitude cA des Tr√§gers: <br><br> <code>if ++cycle &gt;= N <br> cA = sqrt(s1 * s1 + s2 * s2) <br> cycle = 0 <br> end <br></code> <br></div></div><br><br>  Wir nehmen diese Methode als Grundlage, sie wird f√ºr die ‚ÄûSynchronisation‚Äú verantwortlich sein. <br>  Nun wollen wir sehen, wie das Bild codiert ist.  Ich schlage vor, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amplitudenmanipulation zu verwenden</a> .  Manipulation ist, wenn ein Signal in gleiche Segmente unterteilt wird, die als Chips oder Symbole bezeichnet werden, und ein variabler Parameter (in unserem Fall die Amplitude) entlang der L√§nge des Chips gespeichert wird. <br>  Wenn wir beispielsweise die Amplitude im Bereich von 0 bis 32767 (16-Bit-Abtastwerte) variieren k√∂nnen und 255 Werte der Helligkeit der Pixel √ºbertragen m√ºssen, √§ndert sich die Amplitude des Chips pro √Ñnderungseinheit der Helligkeit des Pixels auf 32768/255 = 128. <br>  Ein weiterer wichtiger Parameter ist die L√§nge des Chips. Wir beginnen mit einer Tr√§gerperiode - in unserem Fall vier Samples. <br>  Das Bild wird also Pixel f√ºr Pixel √ºbertragen, jedes Pixel dauert 4 Abtastungen, und die Amplitude f√ºr diese Periode betr√§gt b [x, y] * 128, wobei b [x, y] der Helligkeitswert des Pixels mit x- und y-Koordinaten im Bild b ist. <br><br>  Lassen Sie uns die √úbertragungsgeschwindigkeit absch√§tzen. <br>  Im Beispiel habe ich eine Bildgr√∂√üe von 120 x 120 Pixel verwendet.  Dies bedeutet, dass wir zum √úbertragen eines Frames ben√∂tigen <br><br>  120 x 120 x 4 = 57600 Proben, <br><br>  Wenn die Abtastfrequenz 96 kHz betr√§gt, dauert die √úbertragung eines Frames einige Zeit: <br><br>  57600/96000 = 0,6 Sekunden <br><br>  Offensichtlich brauchen wir eine Art Pause, ein bestimmtes Schutzintervall, damit der Detektor den Beginn des n√§chsten Frames bestimmen kann.  Nehmen wir aus humanen Gr√ºnden an, dass 0,1 Sekunden f√ºr uns ausreichen, in denen alle Echos aussterben (eigentlich nicht).  Am Ende stellt sich dann die √úbertragungsrate heraus: <br><br>  1 / (0,6 + 0,1) = 1,428 Bilder pro Sekunde. <br><br>  Es ist sehr leicht, hier einen Fehler zu machen und zu versuchen, die Geschwindigkeit in Bit pro Sekunde zu berechnen.  Sehen Sie, wie unglaublich die √úbertragungsgeschwindigkeit ist: <br><br>  120 * 120 * 8 / 1,428 = 80 627 bps <br><br>  Aber was passiert, wenn ich keine 8-Bit-Pixel, sondern 16-Bit-Pixel habe? <br><br>  120 * 120 * 16 / 1,428 = 161344 bps <br><br>  Der Haken dabei ist, dass diese √úbertragungsmethode wiederum nicht als digital bezeichnet werden kann und das Konzept der Bitrate f√ºr sie nicht vollst√§ndig g√ºltig ist. <br>  Versuchen Sie, die Bitrate f√ºr ein analoges Fernsehsignal zu berechnen.  Und f√ºr den Detektorempf√§nger?  :) :) <br><br>  So sieht beispielsweise ein Teil des Signals aus und √ºbertr√§gt die Helligkeit von 10 Pixeln, deren Werte sich abwechselnd √§ndern: 1 2 1 2 1 2 1 2 1 2 <br><img src="https://habrastorage.org/webt/ul/kz/st/ulkzsthqa8tt4ykb7stgu7hehqe.png"><br><br>  Nun wollen wir im Beispiel sehen, wie das funktioniert.  Encode- und Decode-Methoden befinden sich in der <a href="">Encoder-</a> Klasse und sind f√ºr die Modulation und Demodulation des Bildes verantwortlich: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interframePauseMs</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFinished = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pSize; i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= pLimit) { phase -= pLimit; } samples.Add(alpha * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isFinished) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; pxAmplitude = (((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)frame.GetPixel(col, row).R) / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++row &gt;= rows) isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } samples.Add(alpha * pxAmplitude); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interframePauseMs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { samples.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)interframePauseMs) / <span class="hljs-number"><span class="hljs-number">1000.0</span></span>) * (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)sampleRate)]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples.ToArray(); }</code> </pre><br><br>  Aus dem Code ist ersichtlich, dass vor dem Modulieren des Bildes dem Ausgangssignal ein aus reinem Ton (pSize-Samples) bestehendes Synchronisationspr√§fix hinzugef√ºgt wird - dies ist erforderlich, damit auf der Empfangsseite eine Synchronisation vor dem Bild selbst <s>und im Allgemeinen</s> unter ung√ºnstigen Bedingungen stattfinden kann. <br>  Die Decodierungsmethode lautet wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; Bitmap result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(cols, rows); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxAmplitude = WaveUtils.GetMaxAmplitude(samples); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMin = maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> smp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = pSize; (i &lt; samples.Length) &amp;&amp; (row &lt; rows); i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; chipAmplitude = (Math.Max(Math.Abs(pxMax), Math.Abs(pxMin)) / maxAmplitude); pxMin = maxAmplitude; pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gs = Convert.ToByte(chipAmplitude * <span class="hljs-number"><span class="hljs-number">255</span></span>); result.SetPixel(col, row, Color.FromArgb(<span class="hljs-number"><span class="hljs-number">255</span></span>, gs, gs, gs)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { col = <span class="hljs-number"><span class="hljs-number">0</span></span>; row++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { smp = samples[i] * alpha; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &gt; pxMax) pxMax = smp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &lt; pxMin) pxMin = smp; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  Es ist ersichtlich, dass beide Methoden nicht an eine bestimmte Frequenz gebunden sind und mit einem anderen Detektor verwendet werden k√∂nnen. <br><br>  Die Signalsuche selbst (Erkennung, Synchronisation) erfolgt ebenfalls wie bei unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachsten hydroakustischen Modem</a> , mit dem einzigen Unterschied, dass ich sie zur √Ñnderung in eine separate Klasse <a href="">FsBy4CarrierDetector eingeordnet habe</a> . <br>  Alle unkomplizierte Magie geschieht in der bool ProcessSample-Methode (kurz a) <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessSample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ring1[ringHead] = a; ring2[ringHead] = a; s1 += a - ring1[ringTail]; s2 += a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ring1[ringHead] = a; ring2[ringHead] = -a; s1 += a - ring1[ringTail]; s2 += - a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">2</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = -a; s1 += -a - ring1[ringTail]; s2 += -a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = a; s1 += -a - ring1[ringTail]; s2 += a - ring2[ringTail]; } ringHead = (ringHead + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; ringTail = (ringTail + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++smpCount &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { smpCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= ringSize) { s = Math.Sqrt(s1 * s1 + s2 * s2) / ringSize; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; result = (s - sPrev) &gt;= Threshold; sPrev = s; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><br>  Es wird bei jeder eingehenden Probe aufgerufen und gibt im Falle der Tr√§gererkennung true zur√ºck. <br><br>  Da der Detektor alles andere als perfekt ist und leicht in der Mitte der Linie synchronisiert werden kann, habe ich einen speziellen Schieberegler hinzugef√ºgt, mit dem Sie eine genauere Synchronisation erzielen k√∂nnen. <br><br>  Nachdem wir nun kurz untersucht haben, wie dies alles funktioniert, gehen wir zum k√∂stlichsten Teil √ºber: Was kann daraus gewonnen werden? <br><br><h3>  Ein bisschen √úbung </h3><br>  Lassen Sie uns zun√§chst √ºberpr√ºfen, wie alles ohne Sonarkanal funktioniert - indem Sie einfach die Empfangs- und Sendeantennen aneinander anschlie√üen. <br>  Erstens ist das Bild gr√∂√üer (240x120), damit zumindest etwas erkannt werden kann: <br><img src="https://habrastorage.org/webt/ev/ys/1t/evys1t89oks6jpvgeyxtgafgbp4.gif"><br><br>  Und dann schnell, damit es <s>mehr Leben gibt</s> wie ein Video: <br><img src="https://habrastorage.org/webt/2j/2t/y_/2j2ty_dym0iowoiq_xgtf_oqdrg.gif"><br><br>  Es scheint nicht schlecht zu sein?  Aber beeilen Sie sich nicht zu Schlussfolgerungen und gehen Sie zum Schwimmbad: <br><img src="https://habrastorage.org/webt/_8/0u/jz/_80ujzh-1afojo46fevq6egccvg.jpeg"><br><br>  Und hier werden wir, wie ich im Titel versprochen habe, ein Echo mit eigenen Augen sehen: <br><img src="https://habrastorage.org/webt/lb/aq/xe/lbaqxezsgyzwjik0zxymshqjysi.gif"><br><br>  Wie <s>gef√§llt dir das, Elon Musk?</s>  Magst du HD?  Warum ist das so? <br>  Und alles ist sehr einfach - das Echo sind im Wesentlichen die verz√∂gerten Kopien des Originalsignals, die bekannterma√üen am Empfangspunkt st√∂ren, sich in einer anderen Phase falten und ein solches Bild ergeben.  Da wir das Bild √ºbertragen, erhalten wir am Ende viele, viele Bilder, die sich mit unterschiedlichen Amplituden √ºberlagern.  All dies f√ºhrt letztendlich zu Unsch√§rfe und Reproduktion. <br><br>  Lassen Sie uns im R√ºckblick alles auf dem gro√üen Bild des Modells √ºberpr√ºfen.  Ich habe ein zuf√§lliges Foto gemacht: <br><img src="https://habrastorage.org/webt/oo/hd/jb/oohdjbgoj4pqq-k8f9st0b9rdre.jpeg"><br><br>  Ich habe es moduliert, dann ein Echo und ein bisschen Rauschen hinzugef√ºgt, dann wurde es dekodiert und ja - das Ergebnis √§hnelt dem, was wir im Pool bekommen haben: <br><img src="https://habrastorage.org/webt/bk/dp/y_/bkdpy_9ztpti3b91ulbakqzokes.png"><br><br>  Im Prinzip ist es m√∂glich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entfaltung</a> durchzuf√ºhren und Reflexionen zu subtrahieren, aber <s>es sind Menschen von au√üerhalb unseres Gebiets,</s> die diesen Punkt f√ºr eine unabh√§ngige Arbeit verlassen. <br><br>  √úbrigens funktioniert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherige Methode</a> im Pool etwas besser, aber auch schlecht - bei Breitbandsignalen f√ºhren Multipath und Reverb zu frequenzselektivem Fading, das im Bild (im Spektrum gelesen) wie schwarze und wei√üe Streifen aussieht - wenn das Signal gegenphasig ist. und wo es sich in der Phase entwickelt hat (tats√§chlich gibt es immer noch eine Reihe von Zwischenoptionen): <br><img src="https://habrastorage.org/webt/zo/f-/pp/zof-ppqayi-rbz2h9yfgjlvc8da.gif"><br><br>  Im April nutzten wir den Moment und gingen mit einem Steckbrettmodell zum Teich und verw√∂hnten uns dort auch: <br><img src="https://habrastorage.org/webt/mv/c-/v4/mvc-v4-m9tys6na8hip-8t8kzyc.jpeg"><br><br><img src="https://habrastorage.org/webt/pp/wc/8u/ppwc8uemc0xlmsmt_rz5h24s664.jpeg"><br><br>  Das Ergebnis unterscheidet sich nicht wesentlich von den im Pool erzielten Ergebnissen: <br><img src="https://habrastorage.org/webt/1-/8j/et/1-8jetei8ly02aanoubjimfhlty.png"><br><br><img src="https://habrastorage.org/webt/_o/1q/ij/_o1qijulzi1p0pqxmch5dijhrcc.png"><br><br>  Und sofort zum Vergleich die vorherige Methode: <br><img src="https://habrastorage.org/webt/dh/8o/nk/dh8onkjtu5jly6kr7ios0k3td44.png"><br><br>  Und hier sind die GIF-Animationen, die aus den gespeicherten Frames gesammelt wurden, Methode 1: <br><img src="https://habrastorage.org/webt/b7/bq/nz/b7bqnzrvtoa1jkbc0cj4h0okv-u.gif"><br><br>  Und Methode 2, die wir in diesem Artikel diskutieren: <br><img src="https://habrastorage.org/webt/of/vg/gb/ofvggbrbktqq30iy0ihoybpx6le.gif"><br><br><h3>  Abschlie√üend </h3><br>  Wie versprochen haben wir gezeigt, wie Echo und Hall buchst√§blich aussehen, Zeit mit Nutzen verbracht und etwas mit unseren H√§nden gemacht. <br><br>  In dieser Form ist die Methode nat√ºrlich in der Praxis nicht anwendbar, aber die Arbeit damit ist f√ºr Anf√§nger sehr n√ºtzlich. <br><br>  Im Allgemeinen haben wir in einem flachen Teich nachgesehen, wo die Bedingungen sehr ung√ºnstig sind, und es w√§re cool, wenn jemand unsere Experimente in anderen Stauseen wiederholen und sicherlich √ºber ihre Ergebnisse berichten w√ºrde. <br><br>  Wenn der Leser es nur versuchen m√∂chte (auch in der Luft mit Mikrofon und Lautsprechern), dann sind hier die Links zu Ver√∂ffentlichungen: <br>  <a href="">Methode 1</a> <br>  <a href="">Methode 2 (aus diesem Artikel)</a> <br><br><h3>  PS </h3>  Wir freuen uns sehr auf das Feedback der Leser, da es sehr wichtig ist zu verstehen, dass Sie etwas vergeblich tun (oder vergeblich, und dann sollte dies sofort gestoppt werden). <br><br><h3>  PS / 2 </h3>  Ich werde gleich eine h√§ufig gestellte Frage beantworten: F√ºr Fische und andere Meereslebewesen in solchen Kindereinrichtungen ist dies alles nur unbemerkt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453678/">https://habr.com/ru/post/de453678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453664/index.html">Spring Boot - OAuth2 und JWT</a></li>
<li><a href="../de453666/index.html">Wie ich ein unbemanntes Taxi fuhr</a></li>
<li><a href="../de453668/index.html">10 Fehler eines jungen RO (Teil I - drei Fehler)</a></li>
<li><a href="../de453672/index.html">CardInfo - API zur Bestimmung des Logos, der Farben der Bank und anderer Dinge anhand der Kartennummer</a></li>
<li><a href="../de453676/index.html">Verbindung zu Windows √ºber SSH wie unter Linux</a></li>
<li><a href="../de453682/index.html">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs. Teil 2. Programmcode</a></li>
<li><a href="../de453686/index.html">Sicherheitswoche 22: Bedrohungsstatistiken, Bankentrojaner und beliebte Exploits</a></li>
<li><a href="../de453688/index.html">Java ist nicht nur ein blutiges Unternehmen, sondern auch schnell latenzempfindliche Anwendungen</a></li>
<li><a href="../de453692/index.html">3D Game Shader f√ºr Anf√§nger: Effekte</a></li>
<li><a href="../de453694/index.html">Stellen Sie wie unter Linux eine Verbindung zu Windows √ºber SSH her</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>