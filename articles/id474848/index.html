<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎼 🌒 👨🏼‍🔬 Tetris sebagai printer 👩‍🔧 😅 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengubah, mengatur ulang dan menurunkan urutan bentuk yang telah ditentukan, Algoritma Printer Tetris menggunakan mekanika Tetris untuk menghasilkan b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tetris sebagai printer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474848/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/az/2c/saaz2chpnuatbjn-rdg3zcryjwo.png"></div><br>  Mengubah, mengatur ulang dan menurunkan urutan bentuk yang telah ditentukan, Algoritma Printer Tetris menggunakan mekanika Tetris untuk menghasilkan bitmap yang sewenang-wenang. <br><br><h2>  Deskripsi algoritma </h2><br>  Algoritma mengubah piksel gambar sumber ke dalam kotak dari bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tetris</a> baris demi baris, bergerak dari bawah ke atas.  Untuk menghasilkan persegi tunggal, algoritma ini menyusun struktur yang terdiri dari area persegi panjang yang sepenuhnya didukung oleh satu persegi di bawahnya.  Setelah perakitan wilayah persegi panjang selesai, garis-garisnya dibersihkan, meninggalkan satu persegi di bawahnya.  Berikut adalah tiga contoh perilaku ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/c80/be8/895c80be864793bcd951c4edb6943f19.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/cdf/615/3c6cdf6159a7bbb9dd2dc95e87374055.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/674/951/104674951b666a97f36c4d069006df5d.gif"></div><br>  Seperti yang ditunjukkan di bawah ini, algoritma juga dapat menghasilkan beberapa kotak dengan satu struktur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/aef/04b/caaaef04b763c02d872079282d3b57d5.gif"></div><br>  Dalam proses membangun baris, semua kotak yang dibuat dengan cara ini harus didasarkan pada sesuatu.  Pada gambar yang ditunjukkan di atas, kotak yang dihasilkan berada di lantai lapangan bermain.  Namun, jika garis arbitrer berisi lubang, maka itu tidak akan dapat memberikan dukungan yang diperlukan untuk membangun garis di atasnya.  Algoritma memecahkan masalah ini dengan membuat platform datar di atas string berlubang.  Dalam animasi di bawah ini, platform yang dibangun di atas garis terdiri dari satu kotak merah.  Platform adalah struktur sementara, dan memasukkan bentuk terakhir akan menghapusnya. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acf/f14/c6d/acff14c6d078f15cc01523e4c24389cb.gif"></div><br>  Baris 5 kotak merah yang ditunjukkan di bawah ini berada di atas baris 3 kotak merah.  Ini diwujudkan dengan membangun platform datar di atas garis bawah.  Platform ini menyediakan dukungan yang dibutuhkan untuk menghasilkan 5 kotak merah.  Pada akhirnya, platform dihapus dengan memasukkan bentuk terakhir, dan baris baru jatuh ke tempatnya.  Perhatikan bahwa jika algoritma perlu menghasilkan garis dalam urutan terbalik (garis 3 kotak merah di atas garis 5 kotak merah), maka platform tidak akan diperlukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/0ad/35c/8510ad35cdbf5639b06b5f17957eec79.gif"></div><br><h2>  Satu Pola Kotak </h2><br>  Untuk referensi, saya akan memberikan nama 7 tetramino (potongan game). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/817/4aa/cef8174aa74b378cb17af2fe0c6f1c7b.png"></div><br>  Versi Tetris Printer Algorithm yang disajikan dalam artikel ini dirancang khusus untuk merender sprite dari video game lama.  Gim-gim ini mengemas gambar dalam 8 × 8 ubin, dan 2 byte dialokasikan untuk setiap piksel.  Karena itu, sprite biasanya hanya berisi 3 warna plus area transparan dan paling sering memiliki ukuran 16 × 16 atau 16 × 32 piksel. <br><br>  Animasi di bawah ini menunjukkan semua pola yang digunakan untuk membuat kotak individu.  Setiap pola menggunakan tetramino J, T, dan L yang dapat dipertukarkan, menciptakan satu kotak di bagian bawah.  Algoritma ini menetapkan tetramino ini ke salah satu dari 3 warna yang ada dalam sprite.  Sisa tetramino diberi warna sewenang-wenang.  Sepanjang permainan, semua warna tetap konstan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/b1f/efc/dfab1fefc65efed365513213cdf5ad12.gif"></div><br>  Karena bentuk tiga tetramino, tidak mungkin untuk membuat kotak dari ketiga warna di dua pertama dan dua terakhir kolom.  Oleh karena itu, lebar minimum bidang bermain untuk merender sprite dengan lebar 16 piksel adalah 2 + 16 + 2 = 20 kotak.  Namun, ternyata 20 terlalu sedikit. <br><br>  Seperti yang ditunjukkan di bawah ini, area di atas alun-alun tunggal tidak dapat terdiri dari hanya satu garis, karena satu-satunya angka yang dapat masuk di dalamnya (tetramino I) tidak memiliki dukungan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/1e5/645/87f1e56455f90295b076e72296cc58c1.gif"></div><br>  Dengan dua garis, satu-satunya cara untuk merentangkan seluruh lapangan bermain sehingga memiliki dukungan adalah dengan menggunakan tetramino S dan Z. Tetapi dalam kasus ini, lubang akan tetap berada di baris atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58c/ea6/8ef/58cea68ef0e7d83c102402e9ed0255fb.gif"></div><br>  Jumlah minimum garis yang diperlukan di atas kotak paling bawah adalah 3, dan seperti yang ditunjukkan beberapa kali di atas, pola tersebut ada.  20 kotak adalah lebar minimum yang diperlukan untuk menempatkan sprite dengan lebar 16 piksel.  Tetapi 20 × 3 + 1 = 61, dan angka ini tidak habis dibagi 4, yang berarti tidak dapat dibangun dari tetramino.  Namun, lebar 21 memberi kita 21 × 3 + 1 = 64, dan dapat dibangun dari 16 tetramino.  Bahkan, lebar ini memungkinkan algoritma untuk membuat sprite hingga 17 piksel lebar. <br><br>  Lapangan bermain Tetris asli memiliki ukuran 10 × 20 kotak (rasio 1: 2).  Rasio ini dipertahankan dalam versi algoritma ini - lapangan bermain memiliki ukuran 21 × 42 kotak. <br><br>  Karena tetramino J, T, dan L dapat dipertukarkan saat membuat satu kotak, dan 3 kotak dari tetramino ini terlibat dalam membuat garis di atasnya, ada 21 - 3 = 18 pola untuk membuat kotak tunggal.  Namun, karena simetri cermin, sebenarnya hanya ada 9. Ada 3 garis yang bekerja untuk sebagian besar dari 9. Ini, namun sebuah studi komputer menyeluruh menunjukkan bahwa kedua pola tersebut membutuhkan lebih banyak.  Opsi berikutnya yang mungkin adalah 7 baris, karena 21 × 7 + 1 = 148, yang membutuhkan 37 tetraminos.  Seperti yang ditunjukkan pada gambar di bawah, ada pola seperti itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/643/2ca/7a26432ca3f6e11d43f134057f3bfa73.gif"></div><br><h2>  Berbagai Pola Kotak </h2><br>  Pola untuk membuat beberapa kotak terbatas pada tiga warna yang sama yang dibuat oleh pola satu kotak.  Kotak yang dihasilkan dibuat dari tetramino J, T dan L, yang masing-masing menempati 3 kotak di garis di atas garis penciptaan.  Jumlah kotak maksimum yang berpotensi dapat dibuat dengan pola tunggal adalah 21/3 = 7. Namun, untuk sprite dengan lebar 16 piksel, tetramino paling kanan tidak dapat membuat kotak.  Bahkan dalam kasus sprite dengan lebar 17 piksel, itu dapat membuat kuadrat hanya satu warna.  Oleh karena itu, pola pembuatan dari 7 kotak jarang digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/9cc/957/e019cc9577348937886f2f160fd8ad1b.gif"></div><br>  Jumlah pola untuk membuat jumlah kuadrat sewenang-wenang dapat ditentukan dengan menggunakan kombinatorik enumerasi.  Pertimbangkan pola di bawah ini, yang mewakili satu baris di atas deretan tiga kotak.  Setiap blok dari tiga kotak putih yang berdekatan menunjuk bagian dari tetramino;  kotak yang dibuat tidak ditampilkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/b6d/fe5/cefb6dfe5d0c9c3b644189dc13901e63.gif"></div><br>  Tiga tetramino membuat 4 lubang.  Ada 21 - 3 × 3 = 12 kotak gelap yang dapat secara sewenang-wenang dimasukkan ke dalam rongga ini untuk membentuk pola tertentu.  Jumlah cara untuk mendistribusikan kotak gelap ini dapat dihitung dengan menempatkannya pada garis di mana kotak putih tunggal diperlakukan sebagai pembagi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/160/0fb/3731600fb90642ff32fa58ee059cf4c3.gif"></div><br>  Jadi, tugasnya dikurangi untuk menghitung nilai koefisien polinomial.  Melihat kotak putih ini, Anda dapat memahami bahwa ini adalah pertanyaan tentang jumlah cara untuk memilih 3 dari 15. <img src="https://habrastorage.org/getpro/habr/post_images/5d4/344/bdb/5d4344bdb66112361fa655447baff0a3.png">  = 455. <br><br>  Dalam kasus umum, untuk <i>n</i> sama dengan <img src="https://habrastorage.org/getpro/habr/post_images/f0d/252/47d/f0d25247d7defed1af6417ed76660ba6.png">  .  Tetapi karena simetri cermin, pada kenyataannya, mereka setengahnya;  jika kuantitasnya ganjil, kemudian membaginya dengan dua, kita membulatkan ke bilangan bulat terdekat untuk memasukkan pola simetris idealnya yang harus ada dalam set ini, seperti, misalnya, yang ditunjukkan di bawah untuk kasus dengan 455. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/093/98d/5e609398dfe585680459774fc3b96cdc.gif"></div><br>  Menerapkan rumus ini ke 7 tetramino, kami mengkonfirmasi yang sudah jelas: hanya ada satu pola untuk membuat 7 kotak. <br><br>  Pola pembuatan 6 kotak dapat dibangun dengan dua cara: dua baris diisi (2 × 21 + 6 = 48) dan enam baris diisi (6 × 21 + 6 = 132), yang membutuhkan 12 dan 33 tetramino.  Rumus di atas menunjukkan bahwa ada 84 pola untuk membuat 6 kotak, tetapi hanya 35 di antaranya yang dapat dibangun dari 2 garis penuh.  49 pola membutuhkan 6 baris.  Jumlahnya ganjil karena pola simetris yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c07/fe9/a24/c07fe9a243e3cdfe37103d4f16d01024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/8c5/91b/8a98c591b95b4fc8a533e67adead58ad.gif"></div><br>  Perlu juga dicatat bahwa 2 garis dimungkinkan di sini, karena berbeda dengan pola pembuatan satu kotak yang membutuhkan tetramino S dan Z, 6 angka digunakan dalam pola-pola ini. <br><br>  Tabel di bawah ini menunjukkan jumlah kotak yang dibuat oleh masing-masing jenis pola, jumlah garis lengkap, jumlah tetramino yang digunakan, dan jumlah pola. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Kotak yang dibuat </th><th>  Garis penuh </th><th>  Tetramino </th><th>  Pola </th></tr><tr><td>  1 </td><td>  7 dan 3 </td><td>  37 dan 16 </td><td>  19 (4 dan 15) </td></tr><tr><td>  2 </td><td>  6 </td><td>  32 </td><td>  136 </td></tr><tr><td>  3 </td><td>  5 </td><td>  27 </td><td>  455 </td></tr><tr><td>  4 </td><td>  4 </td><td>  22 </td><td>  715 </td></tr><tr><td>  5 </td><td>  3 </td><td>  17 </td><td>  462 </td></tr><tr><td>  6 </td><td>  2 dan 6 </td><td>  12 dan 33 </td><td>  84 (35 dan 49) </td></tr><tr><td>  7 </td><td>  1 </td><td>  7 </td><td>  1 </td></tr></tbody></table></div><br>  Contoh pola. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/9dc/055/5699dc0558af1a833b43b57defdefbf7.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/b83/682/1d1b83682d599094bcb138958706b8bf.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/510/bbb/efd510bbb099696e35b7e0b9156f35d4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/bd5/d7a/079bd5d7a149568bda463270a5b3baaf.gif"></div><br><h2>  Platform </h2><br>  Sebelum membuat garis, algoritma memeriksa garis di bawahnya.  Jika baris bawah tidak dapat memberikan dukungan untuk semua kotak di atasnya, maka diperlukan platform sementara.  Ketika platform dihapus, garis baru turun, dan karena bagaimana gravitasi diimplementasikan dalam Tetris asli, beberapa kotak tetap menggantung di udara. <br><br>  Ilustrasi di bawah ini menunjukkan 10 pola platform.  Pembangunan platform dimulai dengan menurunkan T tetramino di atas salah satu kotak dari garis yang dihasilkan terakhir.  Tetraminos yang tersisa bergantung pada T. pertama ini. Yaitu, jika garis yang dihasilkan sebelumnya berisi setidaknya 1 persegi, seperti kotak merah pada gambar di bawah ini, kita dapat membuat platform datar di atasnya untuk menghasilkan baris berikutnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/299/e1d/5b0299e1d7f2916a802a49ea11c4eb16.gif"></div><br>  Di tengah membangun platform, garis bawah selesai dan dihapus, meninggalkan tiga baris di atasnya.  Tetramino J atau L terakhir, yang akan menghapus garis-garis ini, tidak dimasukkan sampai pola pembuatan menghasilkan garis sprite berikutnya di atas platform.  Gambar terakhir ini mencegah pembuatan kotak di dua baris pertama dan terakhir.  Tetapi, seperti yang disebutkan di atas, karena geometri tetramino J, T, dan L yang digunakan dalam proses ini, pola untuk membuat kotak dibatasi hingga 17 kolom dalam. <br><br>  Selain itu, dari 19 cara yang memungkinkan untuk membangun platform di atas Tetramino T, hanya ada 10 yang ditunjukkan di atas. <br><br><h2>  Matriks Dikemas </h2><br>  Seperti yang dinyatakan di atas, satu himpunan bagian dari pola penciptaan 6 kotak melibatkan hanya membersihkan dua baris.  Semua pola lainnya membutuhkan 6 garis.  Untuk memahami mengapa hal ini terjadi, pertimbangkan pola di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/9bf/3aa/3709bf3aa8fd860b3dbcc04014dfef8b.gif"></div><br>  Tetramino ini dapat dipertukarkan dengan tetramino J dan L, dan masing-masing menambahkan 3 kotak yang berdekatan ke baris umum.  Baris yang harus diselesaikan diwakili oleh matriks yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ed/532/67a/3ed53267a1b216691289f68439470301.gif"></div><br>  Sekarang semuanya mengemas ruang kosong dengan tetramino.  Mulai di sebelah kiri, satu-satunya pilihan adalah menggunakan urutan tetramino I. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/b54/9f5/779b549f51bef09e54217790f2110eb5.gif"></div><br>  Satu-satunya cara untuk mengisi ruang yang tersisa adalah dengan menggunakan J dan O atau I dan L. Kedua opsi ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/08e/33a/de808e33aa8f69d807c60b798e8ed0c1.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/a24/be8/aeca24be817f0cc88dc0ef3175ada63c.gif"></div><br>  Sayangnya, tetramino O dan L tidak didukung dalam matriks yang ditunjukkan di atas.  Pola 6 kotak ini membutuhkan matriks yang lebih besar. <br><br>  Masalah serupa muncul dalam dua pola menciptakan satu kotak.  Pertimbangkan matriks di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fba/ec4/6ad/fbaec46ad778d94b5844c22d35ebc4ed.gif"></div><br>  Satu-satunya cara untuk mengisi garis bawah di sebelah kanan adalah dengan rantai urutan Z. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/3e1/5b2/5e83e15b210424010966f17b2ee1b72c.gif"></div><br>  Demikian pula, satu-satunya cara untuk mendapatkan 3 kotak kosong di kiri bawah adalah tetramino S. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/9ae/b51/2979aeb51a67c1c0a51c7e5105890744.gif"></div><br>  Di garis tengah ada kotak kosong antara S dan Z dan satu-satunya cara untuk mengisinya adalah dengan menggunakan tetramino J, T atau L, seperti yang ditunjukkan pada gambar di bawah ini. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/364/433/2a036443351a7c1ec90fe0d534c38049.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/f88/7e8/8f3f887e84bcdbd7176b530af8757666.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3c/dc1/a0a/e3cdc1a0a243388524f4e5ffb8ac13d8.gif"></div><br>  Memasukkan salah satu dari bentuk ini membagi ruang kosong.  Area kosong di sebelah kiri masing-masing berisi 5, 6, dan 7 lubang.  Karena tidak satu pun dari nilai-nilai ini yang dapat dibagi oleh 4, tidak mungkin untuk melanjutkan.  Matriks yang lebih besar diperlukan untuk pola kotak tunggal ini. <br><br>  Hal yang sama berlaku untuk pola lain untuk membuat satu kotak, yang ditunjukkan pada matriks di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/c11/c6c/fd3c11c6ce8d7e4b60a257486caef4e2.gif"></div><br>  Setelah menggunakan tetramino S dan Z untuk mengisi sebagian besar garis bawah, ada ruang kosong di antara mereka di garis tengah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/e39/49c/3a6e3949c8f9f0849921a11ccf54596a.gif"></div><br>  Seperti yang ditunjukkan pada gambar di bawah ini, sisipan lubang membagi ruang kosong, dan area kosong di sebelah kiri masing-masing berisi 9, 10, atau 11 kotak;  tidak ada angka yang habis dibagi 4. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15d/d8b/9b2/15dd8b9b24d8054598665cbff061344e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/928/f4d/6d6928f4d884b746af74059ec210b96d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/269/800/0c5269800d3ebdcb62e1131c03e32db0.gif"></div><br>  Tetapi mengepak matriks bukan satu-satunya cara untuk menghasilkan pola kotak.  Misalnya, lihatlah pembuat 4 kotak di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/22b/653/4fc22b6538117dca3baff88c595337e4.gif"></div><br>  Berikut ini adalah upaya untuk membuat pola sebagai satu set tetraminos paket. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f5/53f/bfc/3f553fbfc96ecfbbef8f7304c80a80fe.gif"></div><br>  L terakhir dilewati, karena ruang untuk itu terbentuk hanya setelah penyelesaian dan penghapusan baris ketiga. <br><br>  Tetapi setelah pencarian menyeluruh, ditemukan bahwa teknik ini tidak memberikan pola satu-persegi yang disebutkan sebelumnya dengan kemampuan untuk bekerja hanya dengan 3 garis.  Selain itu, tidak memungkinkan untuk menerapkan pola baru 6 kotak dalam dua baris.  Tidak perlu mencari pola yang tersisa di luar matriks yang dikemas, karena mereka sudah menggunakan tetramino dalam jumlah sekecil mungkin.  Dan membatasi diri kita pada matriks yang dikemas, kita akan menemukan semua pola yang diperlukan lebih cepat. <br><br><h2>  Pencarian Pola </h2><br>  Untuk menyederhanakan output data, Algoritma Tetris Printer terbatas untuk membuat tetramino di titik tengah atas bidang permainan, memutarnya, bergerak secara horizontal dan menurunkannya.  Dia tidak pernah harus memindahkan sosok secara horizontal setelah melewati jarak tertentu.  Pembatasan ini sangat mengurangi ruang pencarian, karena tidak memungkinkan pembentukan celah di bawah angka yang ditambahkan ke matriks.  Sebagai contoh, mari kita lihat matriks 3 kotak berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/4d1/250/4664d1250708c9d9daeb800eb2ac7f47.gif"></div><br>  Jika kita melempar J di tengah matriks, seperti yang ditunjukkan di atas, maka kita mendapatkan celah 2 kotak kosong, yang tidak dapat diisi dengan angka-angka berikutnya.  Karena itu, pencarian tidak akan mengikuti jalur ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/934/866/56293486665cf1557d513f63fa700622.gif"></div><br>  Karena celah tertutup tidak diizinkan, setiap kolom dalam matriks dapat dianggap sebagai tumpukan kotak yang diisi dan ketinggian tumpukan ini sepenuhnya menggambarkan isi seluruh matriks.  Terlepas dari jumlah baris, array integer satu dimensi dengan 21 elemen akan cukup untuk menggambarkan matriks dua dimensi. <br><br>  Ketika angka jatuh ke dalam matriks, ketinggian tumpukan tumpukan kolom yang sesuai meningkat.  Untuk mempercepat proses ini, semua tetramine dianalisis terlebih dahulu.  Ada 19 putaran tetramino, dan pencarian menganggap masing-masing sebagai sosok yang unik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/d13/9e0/40ed139e0a5612cac1f5d074a0093d96.png"></div><br>  Tetramino J di sudut kiri atas gambar menempati 3 kolom.  Ketika menurunkan ke matriks, ketinggian 3 tumpukan yang berdekatan masing-masing meningkat sebesar 1, 1 dan 2 kotak.  Tetapi sebelum angka dapat diturunkan, profil yang lebih rendah dari angka tersebut harus sesuai dengan profil atas tumpukan masing-masing.  Jika J ini tergeletak di lantai lapangan bermain, di bawah masing-masing kolom ini seharusnya ada kesenjangan 1, 1, dan 0 kotak kosong.  Karena jarak bebas dilarang, ketinggian relatif 3 tumpukan harus sepenuhnya sesuai dengan pola. <br><br>  Konsekuensi lain dari kurangnya kesenjangan adalah bahwa ketika angka-angka jatuh ke dalam matriks, baris diisi dari bawah ke atas.  Tidak mungkin untuk mengisi baris di tengah-tengah matriks sebelum atau tanpa menyelesaikan semua baris di bawahnya.  Dalam proses mengisi matriks, batas bawahnya benar-benar bergerak ke atas.  Akibatnya, tumpukan kolom matriks dapat memberikan dukungan hanya jika tingginya minus jumlah baris selesai lebih besar dari 0. Ketika suatu bentuk ditambahkan ke matriks, setidaknya salah satu kolom yang sesuai harus memberikan dukungan. <br><br>  Pencarian menyimpan array satu dimensi kedua yang berisi jumlah kuadrat terisi di setiap baris.  J di atas berisi dalam baris yang sesuai 3 dan 1 a persegi.  Ketika Anda memasukkannya ke dalam matriks, nilai-nilai ini ditambahkan ke elemen array yang sesuai.  Jumlah garis yang diselesaikan adalah jumlah elemen dengan nilai 21. <br><br>  Seperti yang dinyatakan pada bagian sebelumnya, jika angka yang ditambahkan membagi matriks, maka ukuran area yang dihasilkan harus dibagi dengan 4. Misalnya, pada gambar di bawah ini, menambahkan I membuat 2 area, yang masing-masing berisi 46 kotak kosong.  Karena 46 tidak dapat dibagi dengan 4, tidak ada lagi cara untuk mengisi sisa matriks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/c1e/91a/c0dc1e91a707d5b2fea279dd5c370ec4.gif"></div><br>  Pemisahan muncul ketika ketinggian tumpukan sama dengan ketinggian matriks.  Setelah memasukkan gambar dengan menambah ketinggian tumpukan masing-masing, dimensi dari semua area ruang kosong dapat ditentukan dengan memindai array ketinggian dan menambahkan ruang yang tersisa di setiap tumpukan.  Nomor ini dicentang dan disetel ulang ketika suatu perpecahan terdeteksi. <br><br>  Pencarian yang digunakan untuk menghasilkan semua pola menggunakan konstruksi inkremental acak, algoritma penelusuran balik yang secara sistematis memeriksa semua kombinasi dalam urutan acak.  Konstruksi inkremental dari suatu solusi dengan memasukkan bentuk secara acak membuatnya tumbuh seperti kristal.  Keacakan menyediakan ketidakberaturan yang mengandung wajah pecah yang berfungsi sebagai dasar untuk bentuk selanjutnya yang ditambahkan.  Sebagian besar matriks dikemas secara acak dengan sangat cepat, dan ketika ruang kosong menjadi langka, backtracking ikut bermain. <br><br>  Sebelum melakukan pencarian, permutasi acak dari 371 cara menambahkan angka ke matriks dilakukan.  Kode pseudo dari fungsi pencarian ditunjukkan di bawah ini. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remaining)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION } attempts := attempts + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt;= MAX_ATTEMPTS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (     S  Z) {        S  Z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (  ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } }          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(   ,    ) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NO_SOLUTION }</code> </pre> <br>  Matriks asli yang diteruskan ke fungsi pencarian kosong, kecuali untuk baris bawah yang berisi blok 3 kotak yang berdekatan.  Ini ditransmisikan bersama dengan jumlah tokoh yang tersisa yang perlu ditambahkan.  Jika yang <code>remaining</code> adalah 0, maka matriks berisi solusi dan fungsi kembali.  Setiap panggilan rekursif menambah jumlah upaya <code>attempts</code> global.  Jika melebihi <code>MAX_ATTEMPTS</code> , yang memiliki nilai 1000, maka pencarian dimulai lagi. <br><br>  <code>if</code> ketiga mencoba menambahkan tetramino S atau Z ke bagian bawah matriks jika ruang memungkinkan.  Arti dari ini adalah untuk menghindari situasi seperti yang ditunjukkan di bawah ini, ketika algoritma menghabiskan waktu mengisi bagian dari matriks, tidak dapat mengisi sisanya karena kurangnya dukungan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/3f9/b81/36d3f9b81275718dccb5d40e70d7843b.gif"></div><br>  Berkat <code>if</code> ia dengan cepat membentuk platform untuk membangun: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/aa1/ed7/1d0aa1ed7c08ed07b3f31e22ab92ea42.gif"></div><br>  Untuk mencoba menambahkan angka ke matriks, pemeriksaan di atas diperlukan.  Algoritma memeriksa apakah angka tersebut akan memiliki dukungan, mengingat garis yang telah selesai.  Ia juga memeriksa untuk melihat apakah ia membagi 4 ukuran setiap ruang kosong yang dibuat oleh penyisipan bentuk. <br><br><h2>  Konversi gambar </h2><br>  Algoritma Printer Tetris mengubah setiap baris bitmap menjadi serangkaian lintasan.  Bergerak dari kiri ke kanan, setiap bagian dengan cara "serakah" memasukkan tetramino J, T dan L ke tempat mereka ditempatkan.  Sebagai contoh, gambar di bawah ini menunjukkan deretan 16 bitmap bitmap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/4c5/b69/9c14c5b69ae9a4599ee0856a250256a8.gif"></div><br>  Gambar di bawah ini menunjukkan 5 pass yang diperlukan untuk menutupi 16 piksel ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/f7d/760/989f7d76010dd0d7e523361148e0e323.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/920/25a/4c492025a6033a3eda85fd240118b657.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/44f/373/0f144f3734988b25dd231a1a445c52fd.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/e37/392/6c1e373927f4842ad379ff2b6c42b123.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/64b/222/a9a64b222baaf24ed13674bdac9b8d01.gif"></div><br>  Urutan bentuk yang berusaha dimasukkan oleh algoritma ditentukan oleh warna piksel.  Agar bentuk tidak tumpang tindih, digunakan array satu dimensi dari nilai Boolean.  Untuk memasukkan angka, 3 elemen nol harus ada dalam array.  Setelah berhasil memasukkan gambar 3, elemen array yang sesuai mengambil nilai 1. <br><br>  Untuk melacak piksel yang diselesaikan antara beberapa lintasan, digunakan array satu dimensi dari nilai Boolean.  Ketika setiap item adalah 1, garisnya selesai. <br><br>  Pada akhir setiap pass, konverter gambar mencari tabel untuk semua pola untuk membuat satu atau lebih kotak.  Untuk output, ia melewati pola yang sesuai dengan tetramino J, T dan L. dimasukkan di bagian bawah.Sebagai contoh, pass pertama yang ditunjukkan di atas ditampilkan sebagai pola berikut untuk membuat 5 kotak: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/b1b/377/c67b1b3778a37bf7008438052679942e.gif"></div><br><h2>  Pencarian waktu nyata </h2><br>  Konverter gambar yang dijelaskan di bagian sebelumnya sangat cepat karena menggunakan tabel konstan yang berisi semua pola untuk membuat kotak, dan tidak mencari mereka secara real time.  Namun, pencarian waktu nyata dapat menggunakan pola yang tidak ada dalam tabel, dan oleh karena itu, sangat mengurangi jumlah tetramino yang dibutuhkan untuk menghasilkan gambar.  Dia menggunakan kotak yang dibuat di bagian sebelumnya, menggunakannya sebagai dukungan tambahan.  Misalnya, seperti yang disebutkan di atas, pola berikut untuk membuat satu kotak membutuhkan 7 garis penuh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br>  Tapi satu kotak merah yang dibuat di bagian sebelumnya di sudut kiri bawah gambar di bawah ini memberikan dukungan tambahan, mengurangi jumlah garis yang diisi menjadi 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/d3e/271/dfad3e271c5623daedc462821b82b8af.gif"></div><br>  Selain itu, pencarian waktu nyata dapat mencakup 3 piksel yang berdekatan dengan warna yang sama dengan membalik tetramino J, T atau L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/e09/776/a31e097766437cb13ebde1e35ee66453.gif"></div><br>  Bahkan, ia dapat menggabungkan tetramino terbalik dan terbalik, yang mencakup sejumlah besar piksel dalam satu lintasan.  Misalnya, 5 pass di atas yang diperlukan untuk menutupi 16 piksel dapat dikurangi menjadi pass tunggal yang ditunjukkan di bawah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/653/c31/64c653c31d38daeef85189e3b2eacaa8.gif"></div><br>  Untuk mendapatkan pola ini, konverter gambar dimulai dengan mengemas tetramino J, T, dan L. yang terbalik dengan bersemangat <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/e98/67e/e7ae9867e1419492f6f19f6816d18f04.gif"></div><br>  Kemudian dia dengan bersemangat mencoba untuk menambahkan versi yang tidak dilewatinya, dan dalam hal ini dia berhasil menambahkan J. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/4f3/1d4/ba24f31d49baa855fc449c3cf98f09ca.gif"></div><br>  Pada prinsipnya, tabel pencarian yang dihitung sebelumnya juga dapat digunakan dalam proses ini, tetapi ukuran tipis dari tabel tersebut membuatnya tidak dapat diterapkan dalam praktik. <br><br>  Dalam contoh ini, 8 kotak dalam satu baris di atas baris yang akan dibuat ditambahkan ke baris bawah dari matriks kosong.  Untuk <i>n</i> kuadrat pada lapangan bermain 21 persegi, ketinggian matriks <i>h</i> adalah bilangan bulat positif terkecil sehingga <i>21h - n</i> dapat dibagi 4. Dalam kasus ini, diperlukan matriks dengan ketinggian 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/c2e/d2b/b2ac2ed2bc3a422d0d94fff2b10bf9e0.gif"></div><br>  Pencarian waktu nyata bekerja dengan cara yang persis sama dengan algoritma pencarian yang dijelaskan di atas, tetapi memiliki sedikit perbaikan.  Seperti sebelumnya, tumpukan kolom matriks memberikan dukungan hanya jika tinggi kolom dikurangi jumlah baris yang diselesaikan lebih besar dari nol.  Ketika perbedaannya nol, tumpukan kolom seharusnya tidak memberikan dukungan.  Namun, dalam versi ini, jika sama dengan nol, ia memeriksa kotak pada baris yang dibuat yang dihasilkan oleh lintasan sebelumnya.  Yaitu, setiap kotak di baris di bawah baris bawah matriks memberikan dukungan untuk kolom kosong. <br><br>  Selain itu, karena pencarian dilakukan secara real time, tidak praktis untuk membuatnya lengkap.  Jika dia tidak menemukan solusi setelah sejumlah upaya yang diberikan, maka dia menambahkan 4 baris lagi di bagian atas matriks, dan kemudian mencoba lagi.  Setelah itu, jika ia masih tidak dapat menemukan solusi setelah sejumlah upaya yang diberikan, maka dalam bagian ini ia kembali ke metode dengan tabel pencarian yang telah dihitung sebelumnya dan konversi gambar yang dijelaskan pada bagian artikel sebelumnya. <br><br><h2>  Cetak </h2><br>  Untuk mencetak, Anda harus mengikuti instruksi yang ditampilkan oleh konverter gambar pada bidang Tetris playing.  Printer membuat tetramino tertentu di titik tengah atas bidang bermain dalam orientasi standar.  Kemudian printer memutarnya, memindahkannya secara horizontal dan menurunkannya.  Proses ini ditunjukkan dalam video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PJkHwulsac4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Kode sumber </h2><br>  Kode sumber untuk proyek Java 7 tersedia di <a href="">sini</a> . <br><br>  Algoritme pencarian untuk tabel yang sudah disiapkan dan waktu-nyata ada dalam paket <code>search.precomputed</code> dan <code>search.realtime</code> .  Mereka menggunakan beberapa kelas umum yang terletak di paket <code>search</code> .  Hasil pencarian pra-perhitungan disimpan dalam paket <code>patterns</code> sebagai urutan file teks.  File teks menyimpan matriks yang dikemas sebagai karakter ASCII, dimulai dengan <code>A</code>  Sebagai contoh, 3 matriks pertama di <code>emitters1.txt</code> (himpunan pola untuk membuat satu kotak) terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/yo/mo/lvyomov6ld5rle3bqj1jnjegic4.png"></div><br>  Seperti yang berulang kali dinyatakan dalam artikel, 3 simbol <code>A</code> berdekatan dalam matriks di atas dapat diganti dengan tetramino J, T atau L. Simbol <code>B</code> , <code>C</code> , <code>D</code> dan seterusnya mewakili urutan tetramino yang perlu Anda buat. <br><br>  Kelas <code>imageconverter.ImageConverter</code> berisi metode <code>main</code> , yang menerima argumen baris perintah tunggal: nama file gambar sprite.  Suatu gambar tidak boleh lebih besar dari 17 × 32 piksel dan tidak dapat mengandung lebih dari 3 warna buram.  Semua piksel lainnya harus transparan. <br><br>  Menariknya, di video game lama, pengembang sering menggunakan latar belakang untuk mendapatkan warna ekstra.  Misalnya, murid dan mulut Gelembung dari Gelembung berbandul, murid Donkey Kong dari Donkey Kong dan alis dengan tahi lalat Nona Pakman dari Ms.  Pac-Man sebenarnya transparan.  Hitam diperoleh dari latar belakang yang solid. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/67d/330/3fe67d330fce92bff0b4595902e5f5bb.png"></div><br>  Latar belakang bidang bermain Tetris dapat digunakan dengan cara yang sama. <br><br>  Output <code>ImageConverter</code> terlihat seperti potongan ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rs/vt/ms/rsvtmsq6olz9bm1huiqbqgbouj4.png"></div><br>  3 nilai hex pada baris pertama adalah 3 warna buram diekstraksi dari file gambar sprite.  Mereka sesuai dengan warna tetramino J, T dan L. Warna tetramino lainnya tidak mempengaruhi gambar.  Blok yang tersisa adalah pola paket yang dieksekusi di lapangan bermain (untuk karakter setelah <code>Z</code> dan hingga <code>a</code> lihat <a href="">tabel karakter ASCII</a> ).  Blok kuning yang disorot membentuk platform.  Blok pertama menambahkan platform, yang kedua menghapusnya. <br><br>  Kelas <code>printer.Printer</code> menerima file teks dalam format ini dan menghasilkan file gambar dengan memainkan Tetris. <br><br>  Algoritme printer yang digunakan untuk menghasilkan video yang menyerupai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi Tetes</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NES</a> menentukan setiap jenis tetramino di setiap blok file teks.  Kemudian bergerak dalam urutan yang berlawanan dari titik awal dan orientasi awal ke sudut rotasi dan koordinat penurunan angka yang ditunjukkan dalam file.  Catatan: karena kecepatan yang sangat tinggi dari angka yang jatuh, tidak mungkin untuk melampaui level 30 dalam versi SES sebenarnya dari Tetris.  Diasumsikan bahwa printer mengirimkan semua perintahnya ke lapangan dengan cukup cepat.  untuk mengimbangi ini. <br><br>  Untuk membuat ulang file pola, gunakan <code>search.precomputed.PatternSearcher</code> .  Itu dapat dikustomisasi dengan mengubah konstanta di awal file kode sumber. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_WIDTH = <span class="hljs-number"><span class="hljs-number">21</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_HEIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EMITTED_SQUARES = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RANDOM_SETS = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_ATTEMPTS = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  <code>RANDOM_SETS</code> adalah jumlah permutasi acak dari 371 cara untuk menambahkan angka ke matriks.  Ketika diatur ke <code>100000</code> , dibutuhkan beberapa detik untuk menginisialisasi permutasi saat startup.  Selain itu, penyimpanan mereka membutuhkan lebih dari satu gigabyte memori. <br><br>  <code>MAX_ATTEMPTS</code> mengontrol waktu eksekusi pencarian.  Nilai <code>1000</code> relatif kecil memungkinkan pencarian untuk dengan cepat membuang permulaan acak yang gagal menunjukkan diri dengan baik.  Namun, untuk membuktikan bahwa untuk ukuran matriks spesifik dan jumlah kotak yang dibuat tidak ada solusi, perlu untuk mengeksplorasi seluruh ruang pencarian secara penuh.  Untuk melakukan ini, Anda dapat mengatur <code>MAX_ATTEMPTS</code> ke <code>Integer.MAX_VALUE</code> . <br><br>  Konstanta serupa ditemukan di <code>search.realtime.RealtimeSearcher</code> , yang digunakan oleh konverter gambar.  Seperti disebutkan di atas, nilai <code>RANDOM_SETS</code> besar membutuhkan peningkatan memori maksimum dan mengarah ke awal yang lebih lama.  <code>MAX_RETRIES</code> mengontrol jumlah upaya, setelah itu pencarian real-time menyerah dan kembali ke pencarian dengan tabel yang sudah dihitung sebelumnya. <br><br>  Perlu diingat bahwa kedua algoritma pencarian menggunakan 100% CPU, menciptakan banyak utas paralel yang ukurannya sama dengan jumlah prosesor yang tersedia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/8b9/bd5/c2d8b9bd50fd64a3a7e739d51201c880.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474848/">https://habr.com/ru/post/id474848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474838/index.html">SIBUR Challenge 2019 - Kompetisi Analisis Data Industri</a></li>
<li><a href="../id474840/index.html">Apa yang mereka pelajari dalam kekhususan Ilmu Data di universitas asing</a></li>
<li><a href="../id474842/index.html">Kasus: Layanan mobil. Pengembangan kampanye iklan dan implementasi Bitrix24</a></li>
<li><a href="../id474844/index.html">Dell XPS 13 7390: laptop yang sangat ringkas bagi mereka yang sering bekerja di luar kantor</a></li>
<li><a href="../id474846/index.html">Program membersihkan sungai di dunia dari sampah</a></li>
<li><a href="../id474850/index.html">Taruhan kuantum Google untuk AI - dan apa maknanya bagi semua umat manusia</a></li>
<li><a href="../id474852/index.html">LexicalEnvironment dan Penutupan di EcmaScript</a></li>
<li><a href="../id474854/index.html">Email pemicu - cara melibatkan audiens Anda</a></li>
<li><a href="../id474856/index.html">Strategi Pelokalan Konten</a></li>
<li><a href="../id474858/index.html">Yang Perlu Anda Ketahui Tentang Red Hat OpenShift Service Mesh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>