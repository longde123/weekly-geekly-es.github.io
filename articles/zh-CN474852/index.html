<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😀 👨🏼‍🤝‍👨🏻 👎 EcmaScript中的词法环境和闭包 🤞🏽 ✌🏽 😫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 我已经很长时间没有写任何东西了，最近几个星期在该项目上做了很多工作，但是现在我有空闲时间，所以我决定向您介绍新文章。 

 今天，我们将继续分析关键的EcmaScript概念，讨论词法环境和闭包。 理解Lexical环境的概念对于理解闭包非常重要，而闭包是JS世界（基于EcmaScr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EcmaScript中的词法环境和闭包</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474852/">哈Ha！ <br><br> 我已经很长时间没有写任何东西了，最近几个星期在该项目上做了很多工作，但是现在我有空闲时间，所以我决定向您介绍新文章。 <br><br> 今天，我们将继续分析关键的EcmaScript概念，讨论词法环境和闭包。 理解Lexical环境的概念对于理解闭包非常重要，而闭包是JS世界（基于EcmaScript规范）中众多优秀技术的基础。 <br><br> 因此，让我们开始吧。 <br><br><h2> 词法环境（LexicalEnvironment，LO，LE） </h2><br> 正式的ES6规范将该术语定义为： <br><blockquote>  <b>词法环境</b>是一种规范类型，用于在基于ECMAScript代码嵌套的词法结构搜索特定变量和函数时解析标识符名称。 词法环境由环境记录以及对外部词法环境的空引用组成。 <br></blockquote> 让我们仔细看看。 <br><br> 我将想象词汇环境是一种存储上下文标识符及其含义的连接的结构。 这是在此上下文范围内声明的变量，函数，类的存储库。 <br><br> 从技术上讲，LO是具有两个属性的对象： <br><br><ul><li> 环境记录（这是所有广告的存储位置） </li><li> 链接到LO生成上下文。 </li></ul><a name="habracut"></a><br> 通过链接到当前上下文的父上下文，如有必要，我们可以链接到父上下文的“祖父上下文”，依此类推，链接到全局上下文，对全局上下文的引用将为null。 从这个定义可以得出，词法环境是实体与其来源上下文的连接。 函数中的一种ScopeChain类似于Lexical环境。 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>中详细讨论了ScopeChain。 <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y + z; } foo(<span class="hljs-number"><span class="hljs-number">30</span></span>);<span class="hljs-comment"><span class="hljs-comment">// 150.   foo    {record: {z: 30, x: 100}, parent: __parent}; // __parent      {record: {x: 10, y: 20}, parent: null}</span></span></code> </pre> <br> 从技术上讲，解析标识符名称的过程将像ScopeChain中一样发生，即 在LO循环中将对对象进行顺序轮询，直到找到所需的标识符为止。 如果找不到标识符，则引用错误。 <br><br> 在创建上下文的阶段创建并填充词汇环境。 当当前上下文完成执行时，会将其从调用堆栈中删除，但是只要至少有一个链接指向它的Lexical环境就可以继续存在。 这是现代编程语言设计方法的优点之一。 我认为值得一提！ <br><br><h3> 堆栈组织与动态共享内存 </h3><br> 在堆栈语言中，局部变量存储在堆栈中，当激活函数时会对其进行补充，而在函数退出时，将从堆栈中删除其局部变量。 <br><br> 对于堆叠式组织，将不可能从函数返回局部函数或将函数调用为自由变量。 <br><br>  <b>自由变量</b>是函数使用的变量，但它既不是形式参数，也不是该函数的局部变量。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> locaVar = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     innerFn function innerFn(p) { alert(p + localVar); } return innerFn; //  } var test = testFn();//  innerFn   test();//      </span></span></code> </pre><br> 使用堆栈组织，既不可能在外部LexicalEnvironment中进行locaVar搜索，也无法返回innerFn函数，因为  innerFn还是testFn的本地声明。 完成testFn后，只需将其所有局部变量从堆栈中删除即可。 <br><br> 因此，提出了另一个概念-动态分配的内存（堆，堆）+垃圾收集器+参考计数的概念。 这个概念的本质很简单：只要对一个对象至少有一个引用，就不会从内存中删除它。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到更多详细信息。 <br><br><h2> 封闭（封闭） </h2><br>  <b>闭包</b>是代码块和在其中生成该块的上下文数据的组合，即 它是实体与通过LO或SopeChain链生成的上下文之间的关系。 <br><br> 让我引用关于这个主题的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>非常好的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ： <br><br><blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// prints 'Peter'</span></span></code> </pre><br> 执行人员功能时，JavaScript将为该功能创建新的执行上下文和词法环境。 该函数完成后，它将返回displayName函数并分配给变量peter。 <br><br> 因此，她的词汇环境将如下所示： <br><br><pre> <code class="javascript hljs">personLexicalEnvironment = { <span class="hljs-attr"><span class="hljs-attr">environmentRecord</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span> : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">displayName</span></span>: &lt; displayName function reference&gt; } outer: &lt;globalLexicalEnvironment&gt; }</code> </pre><br> 当person函数完成时，其执行上下文将从堆栈中弹出。 但是其词法环境仍将保留在内存中，因为其内部displayName函数的词法环境引用了它。 因此，其变量仍将在内存中可用。 <br><br> 当执行peter函数（实际上是对displayName函数的引用）时，JavaScript会为此函数创建一个新的执行上下文和词法环境。 <br><br> 因此他的词汇环境将如下所示： <br><br><pre> <code class="javascript hljs">displayNameLexicalEnvironment = { <span class="hljs-attr"><span class="hljs-attr">environmentRecord</span></span>: { } outer: <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">personLexicalEnvironment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> }</span></span></code> </pre><br>  displayName函数中没有变量；其环境记录将为空。 在执行此函数期间，JavaScript将尝试在该函数的词法环境中查找name变量。 <br><br> 由于displayName函数的词法环境中没有变量，因此它将在仍在内存中的外部词法环境（即person函数的词法环境）中搜索。  JavaScript将找到此变量，并且名称会打印到控制台。 <br></blockquote>  ES中闭包的最重要特征是它使用静态作用域（在许多其他使用闭包的语言中，情况有所不同）。 <br><br> 一个例子： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(a); } (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">funArg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">20</span></span>; funArg();<span class="hljs-comment"><span class="hljs-comment">//  5 ..  ScopeChain/LexicalEnvironment testFn   ,    = 5 })(testFn)</span></span></code> </pre><br> 另一个重要的关闭属性是以下情况： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; first = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++a; } second = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> --a; } a = <span class="hljs-number"><span class="hljs-number">2</span></span>; first();<span class="hljs-comment"><span class="hljs-comment">//3 } testFn(); first();//4 second();//3</span></span></code> </pre><br> 即 我们看到存在于多个函数的闭包中的自由变量被它们的引用所改变。 <br><br><h2> 结论 </h2><br> 在本文的框架中，我们简要描述了EcmaScript的两个主要概念：词法环境和闭包。 实际上，这两个主题都更为广泛。 如果社区想要更深入地描述不同类型的词汇环境之间的差异，或者想了解v8如何构建闭包，请在注释中写上。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474852/">https://habr.com/ru/post/zh-CN474852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474842/index.html">案例：汽车服务。 开展广告活动并实施Bitrix24</a></li>
<li><a href="../zh-CN474844/index.html">Dell XPS 13 7390：非常紧凑的笔记本电脑，适合经常在办公室外工作的人们使用</a></li>
<li><a href="../zh-CN474846/index.html">从垃圾中清理世界河流的计划</a></li>
<li><a href="../zh-CN474848/index.html">俄罗斯方块作为打印机</a></li>
<li><a href="../zh-CN474850/index.html">Google对AI的量子赌注及其对全人类的意义</a></li>
<li><a href="../zh-CN474854/index.html">触发电子邮件-如何吸引观众</a></li>
<li><a href="../zh-CN474856/index.html">内容本地化策略</a></li>
<li><a href="../zh-CN474858/index.html">您需要了解的有关Red Hat OpenShift Service Mesh的知识</a></li>
<li><a href="../zh-CN474860/index.html">火星上的大脑：太空旅行如何影响认知功能</a></li>
<li><a href="../zh-CN474862/index.html">预测与解释：或者为什么在数据科学领域需要更多的“半价”购买</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>