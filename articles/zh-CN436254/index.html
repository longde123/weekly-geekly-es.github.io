<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅 👋🏿 👇🏾 适用于Rust，C或任何其他语言的Starcraft机器人 🛂 ♠️ ℹ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="《星际争霸：巢穴之战》 。 这个游戏对我来说意义非凡！ 我想对你们中的许多人来说。 如此之多，我想知道是否应该在Wikipedia上提供其页面的链接。 


 一次霍尔特给我发了PM并提议学习Rust 。 像任何普通人一样，我们决定从  你好世界  为Windows编写一个动态库，该库可以加载到St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>适用于Rust，C或任何其他语言的Starcraft机器人</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436254/"><img src="https://habrastorage.org/webt/qv/fa/ex/qvfaexsnkzmckmwrt_spqmc7nr4.png" align="left"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《星际争霸：巢穴之战》</a> 。 这个游戏对我来说意义非凡！ 我想对你们中的许多人来说。 如此之多，我想知道是否应该在Wikipedia上提供其页面的链接。 </p><br><p> 一次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">霍尔特</a>给我发了PM并提议学习<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a> 。 像任何普通人一样，我们决定从 <del> 你好世界 </del> 为Windows编写一个动态库，该库可以加载到StarCraft的地址空间中并管理单元。 </p><br><p> 下面的文章将描述寻找解决方案以及使用允许您学习Rust及其生态系统新事物的技术的过程。 可能还会启发您使用自己喜欢的语言（无论是C，C ++，Ruby，Python等）来实现机器人。 </p><a name="habracut"></a><br><p> 阅读本文时，绝对值得听听韩国的赞美诗： </p><br><div class="spoiler">  <b class="spoiler_title">星际争霸OST</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/pNt0iVG2VOA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2 id="bwapi"> 布瓦皮 </h2><br><p> 这场比赛已经有20年历史了。 而且仍然<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很受欢迎</a> ; 甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在2017年</a> ，冠军争夺战在美国也引起了人们的注意， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>那里大师级的Jaedong与Bisu的战斗发生了。 除了人类玩家之外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">毫无灵魂的机器</a>还参加了SC战斗！ 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BWAPI</a> ，这是可能的。 更有用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> 。 </p><br><p> 十多年来，围绕这个游戏的机器人开发者社区已经出现。 热心者创造机器人并参加各种锦标赛。 他们中的许多人都学习AI和机器学习。 大学使用BWAPI训练学生。 甚至还有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽搐频道</a>播放此类比赛。 </p><br><p> 因此，几年前，一个粉丝团队扭转了星际争霸的后端，并开发了C ++ API，该API可让您创建机器人，在游戏过程中进行注入并控制可悲的人类。 </p><br><p> 经常发生 <del> 盖房子，有必要开采矿石，锻造工具 </del> 创建一个机器人，您需要实现一个API。  Rust必须提供什么？ </p><br><h2 id="ffi"> 联邦调查局 </h2><br><p> 使用Rust中的其他语言非常简单。 为此有一个<abbr title="外部功能界面">FFI</abbr> 。 让我从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>摘录<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一下</a> 。 </p><br><p> 想象一下，我们有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快照</a>库，其中包含一个头文件<a href="">snappy-ch</a> ，其中包含函数声明。 </p><br><p> 让我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cargo</a>创建一个项目。 </p><br><pre><code class="bash hljs">$ cargo new --bin snappy Created binary (application) `snappy` project $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> snappy snappy$ tree . ├── Cargo.toml └── src └── main.rs 1 directory, 2 files</code> </pre> <br><p>  Cargo为该项目创建了标准文件结构。 </p><br><p> 在<code>Cargo.toml</code>我们指定对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libc的</a>依赖关系： </p><br><pre> <code class="plaintext hljs">[dependencies] libc = "0.2"</code> </pre> <br><p>  <code>src/main.rs</code>文件将如下所示： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> libc; <span class="hljs-comment"><span class="hljs-comment">// To import C types, in our case for size_t use libc::size_t; #[link(name = "snappy")] // Specify the name of the library for linking the function extern { // We write the declaration of the function which we want to import // in C the declaration looks like this: // size_t snappy_max_compressed_length(size_t source_length); fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t; } fn main() { let x = unsafe { snappy_max_compressed_length(100) }; println!("max compressed length of a 100 byte buffer: {}", x); }</span></span></code> </pre> <br><p> 让我们构建并运行项目： </p><br><pre> <code class="bash hljs">snappy$ cargo build ... snappy$ cargo run Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.02s Running `target/debug/snappy` max compressed length of a 100 byte buffer: 148</code> </pre> <br><p> 您只能叫<code>cargo run</code> ，这要在运行前叫<code>cargo build</code> 。 另一种选择是构建项目并直接调用二进制文件： </p><br><pre> <code class="bash hljs">snappy$ ./target/debug/snappy max compressed length of a 100 byte buffer: 148</code> </pre> <br><p> 如果已安装snappy库，则将编译代码（对于Ubuntu，应安装libsnappy-dev软件包）。 </p><br><pre> <code class="bash hljs">snappy$ ldd target/debug/snappy ... libsnappy.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libsnappy.so.1 (0x00007f8de07cf000)</code> </pre> <br><p> 如您所见，我们的二进制文件链接到libsnappy共享库。 在我们的代码中对<code>snappy_max_compressed_length</code>的调用是从该库进行的函数调用。 </p><br><h2 id="rust-bindgen"> 锈结合 </h2><br><p> 如果我们能够自动生成FFI，那将是很好的。 幸运的是，Rust瘾君子的工具箱中有一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rust-bindgen</a>的实用程序。 它能够生成与C（和某些C ++）库的FFI绑定。 </p><br><p> 安装方式： </p><br><pre> <code class="bash hljs">$ cargo install bindgen</code> </pre> <br><p>  <strong>锈菌结合素</strong>看起来像什么？ 我们使用C / C ++头文件，将<strong>bindgen</strong>实用程序指向它们，然后将获得的输出生成带有适当声明的Rust代码，以使我们使用C结构和函数。 这是<code>bindgen</code>为<code>bindgen</code>生成的： </p><br><pre> <code class="rust hljs">$ bindgen /usr/include/snappy-ch | grep -C <span class="hljs-number"><span class="hljs-number">1</span></span> snappy_max_compressed_length <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snappy_max_compressed_length</span></span></span></span>(source_length: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; }</code> </pre> <br><p> 事实证明，bindgen无法应付BWAPI标头，生成大量不可用的代码（由于虚拟成员函数，公共API中的std ::字符串等）。 事实是BWAPI用C ++编写。 即使在C ++项目中，C ++通常也很难使用。 库组装完成后，最好使用相同的链接器（相同版本）链接它，头文件应使用相同的编译器（相同版本）进行解析。 所有这些因素都可能影响结果。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重整</a> ，仍然<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无法</a>在GNU GCC中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">没有错误地实现</a> 。 这些因素非常重要，甚至<abbr title="Google的C ++测试框架">gtest</abbr>也无法克服。 并且在<a href="">文档中</a>说：您最好使用相同的编译器和相同的链接器将gtest构建为项目的一部分。 </p><br><h2 id="bwapi-c"> 布瓦比克 </h2><br><p>  C是软件工程的通用语。 如果rust-bindgen适用于C语言，为什么不为C实现BWAPI，然后使用其API？ 好主意！ </p><br><p> 是的，这是一个好主意，直​​到您深入研究BWAPI的内部并看到应该实现的类和方法的数量。 特别是所有这些我们没有时间进行的内存布局，asm代码，内存修补和其他“恐怖”。 有必要完全使用现有解决方案。 </p><br><p> 但是，我们需要以某种方式击败混乱，C ++代码，继承和虚拟成员函数。 </p><br><p> 在C ++中，有两个功能强大的工具<code>extern "C"</code>来解决问题： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不透明的指针</a>和<code>extern "C"</code> 。 </p><br><p>  <code>extern "C" {}</code>允许C ++代码在C语言下“屏蔽”自身。它可以生成函数名称而无需处理。 </p><br><p> 不透明的指针使我们可以清除类型并创建指向“某种类型”的指针，而无需提供其实现。 由于这只是某种类型的声明，因此无法通过值使用此类型，只能通过指针使用它。 </p><br><p> 假设我们有以下C ++代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> cpp { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bar; } }; } <span class="hljs-comment"><span class="hljs-comment">// namespace cpp</span></span></code> </pre> <br><p> 我们可以将其转换为C标头： </p><br><pre> <code class="plaintext hljs">extern "C" { typedef struct Foo_ Foo; // Opaque pointer to Foo // call cpp::Foo::get_bar int Foo_get_bar(Foo* self); }</code> </pre> <br><p> 这是C ++部分，它将成为C标头和C ++实现之间的链接： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo_get_bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Foo* self)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// cast the opaque pointer to the certain cpp::Foo and call the method ::get_bar return reinterpret_cast&lt;cpp::Foo*&gt;(self)-&gt;get_bar(); }</span></span></code> </pre> <br><p> 并非所有的类方法都必须以这种方式处理。 在BWAPI中，可以使用这些结构的字段来实现自己的类，例如<code>typedef struct Position { int x; int y; } Position;</code> <code>typedef struct Position { int x; int y; } Position;</code> 以及<code>Position::get_distance</code>类的方法。 </p><br><p> 有些课程我必须以特殊的方式对待。 例如，AIModule应该是指向具有特定虚拟成员函数集的C ++类的指针。 不过，这是<a href="">标题</a>和<a href="">实现</a> 。 </p><br><p> 因此，经过几个月的努力， <strong>554</strong>种方法和十几个类，跨平台库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BWAPI-C</a>诞生了，它使您<a href="">可以用C创建机器人。</a> 副产品是交叉编译的可能性以及以支持FFI和cdecl调用约定的任何其他语言实现API的能力。 </p><br><p> 如果要编写库，请使用C编写其API。 </p><br><p>  BWAPI-C的最重要功能是与其他编程语言的尽可能广泛的集成。  <code>Python</code> ， <code>Ruby</code> ， <code>Rust</code> ， <code>PHP</code> ， <code>Java</code>和许多其他功能都可以使用C，因此，如果您解决了一些难题并实现了自己的包装器，则还可以在它们的帮助下编写一个机器人。 </p><br><h2 id="writing-a-bot-in-c"> 用C编写机器人 </h2><br><p> 本部分描述了Starcraft模块内部组织的一般原理。 </p><br><p> 机器人有2种类型：模块和客户端。 让我们看一个编写模块的例子。 </p><br><p> 该模块是一个动态库。 加载动态库的一般原理可以在<a href="">这里</a>查看。 该模块应导出2个函数： <code>newAIModule</code>和<code>gameInit</code> 。 </p><br><p>  <code>gameInit</code>很容易。 调用此函数可将指针传递给当前游戏。 该指针非常重要，因为在代码的某些部分中使用了BWAPI的通配符，其中包含全局静态变量。 让我们描述<code>gameInit</code> ： </p><br><pre> <code class="plaintext hljs">DLLEXPORT void gameInit(void* game) { BWAPIC_setGame(game); }</code> </pre> <br><p>  <code>newAIModule</code>有点复杂。 它应该返回指向C ++类的指针，该类具有一个虚拟方法表，其名称类似于<strong>onXXXXX</strong> ，在某些游戏事件中会被调用。 让我们声明模块的结构： </p><br><pre> <code class="plaintext hljs">typedef struct ExampleAIModule { const AIModule_vtable* vtable_; const char* name; } ExampleAIModule;</code> </pre> <br><p> 第一个字段应该是指向方法表的指针（这是一种魔术）。 这是<code>newAIModule</code>函数： </p><br><pre> <code class="plaintext hljs">DLLEXPORT void* newAIModule() { ExampleAIModule* const module = (ExampleAIModule*) malloc( sizeof(ExampleAIModule) ); module-&gt;name = "ExampleAIModule"; module-&gt;vtable_ = &amp;module_vtable; return createAIModuleWrapper( (AIModule*) module ); }</code> </pre> <br><p>  <code>createAIModuleWrapper</code>是另一个魔术，可以将C指针转换为指向C ++类的指针， <del> 虚方法 </del> 成员函数。 </p><br><p>  <code>module_vtable</code>是方法表上的静态变量，方法值填充有指向全局函数的指针： </p><br><pre> <code class="plaintext hljs">static AIModule_vtable module_vtable = { onStart, onEnd, onFrame, onSendText, onReceiveText, onPlayerLeft, onNukeDetect, onUnitDiscover, onUnitEvade, onUnitShow, onUnitHide, onUnitCreate, onUnitDestroy, onUnitMorph, onUnitRenegade, onSaveGame, onUnitComplete }; void onEnd(AIModule* module, bool isWinner) { } void onFrame(AIModule* module) {} void onSendText(AIModule* module, const char* text) {} void onReceiveText(AIModule* module, Player* player, const char* text) {} void onPlayerLeft(AIModule* module, Player* player) {} void onNukeDetect(AIModule* module, Position target) {} void onUnitDiscover(AIModule* module, Unit* unit) {} void onUnitEvade(AIModule* module, Unit* unit) {} void onUnitShow(AIModule* module, Unit* unit) {} void onUnitHide(AIModule* module, Unit* unit) {} void onUnitCreate(AIModule* module, Unit* unit) {} void onUnitDestroy(AIModule* module, Unit* unit) {} void onUnitMorph(AIModule* module, Unit* unit) {} void onUnitRenegade(AIModule* module, Unit* unit) {} void onSaveGame(AIModule* module, const char* gameName) {} void onUnitComplete(AIModule* module, Unit* unit) {}</code> </pre> <br><p> 如果查看函数的名称及其签名，则很清楚在什么条件下以及需要使用哪些参数调用它们。  <a href="">例如，</a>我将所有功能都清空了，除了 </p><br><pre> <code class="plaintext hljs">void onStart(AIModule* module) { ExampleAIModule* self = (ExampleAIModule*) module; Game* game = BWAPIC_getGame(); Game_sendText(game, "Hello from bwapi-c!"); Game_sendText(game, "My name is %s", self-&gt;name); }</code> </pre> <br><p> 游戏运行时调用此函数。 该参数是指向当前模块的指针。  <code>BWAPIC_getGame</code>返回指向游戏的全局指针，我们使用对<code>BWAPIC_setGame</code>的调用来设置该<code>BWAPIC_setGame</code> 。 因此，让我们展示一个交叉编译模块的工作示例： </p><br><pre> <code class="bash hljs">bwapi-c/example$ tree . ├── BWAPIC.dll └── Dll.c 0 directories, 2 files bwapi-c/example$ i686-w64-mingw32-gcc -mabi=ms -shared -o Dll.dll Dll.c -I../include -L. -lBWAPIC bwapi-c/example$ cp Dll.dll ~/Starcraft/bwapi-data/ bwapi-c/example$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Starcraft/bwapi-data/ Starcraft$ wine bwheadless.exe -e StarCraft.exe -l bwapi-data/BWAPI.dll --headful ... ... ...</code> </pre> <br><p> 按下按钮并运行游戏。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BWAPI</a>网站和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BWAPI-C中</a>找到有关编译和执行的更多信息。 </p><br><p> 模块的结果： </p><br><p><img src="https://habrastorage.org/webt/cw/a-/41/cwa-41ihsyva-pj2stpef1xjn2g.png" alt="图片"></p><br><p> 您可以在<a href="">bwapi-c / example / Dll.c中</a>找到一个更复杂的模块示例，其中显示了如何使用迭代器，单元管理，矿物搜索和统计信息输出。 </p><br><h2 id="bwapi-sys">  bwapi系统 </h2><br><p> 在Rust生态系统中，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一种</a>命名程序包的方式可以链接到本机库。 任何软件包foo-sys都执行两个重要功能： </p><br><ul><li> 与本地库libfoo的链接； </li><li> 提供libfoo库中函数的声明。 但是只有声明！  * -sys包装箱中未提供高级抽象。 </li></ul><br><p> 为了使* -sys软件包能够成功链接，您必须告诉cargo <a href="">搜索</a>本机库和/或从源代码<a href="">构建</a>库。 </p><br><p> 为了使* -sys包提供声明，您需要自己编写它们或使用bindgen生成它们。 再次bindgen。 尝试第二个=） </p><br><p> 绑定的生成非常简单： </p><br><pre> <code class="bash hljs">bindgen BWAPI.h -o lib.rs \ --opaque-type <span class="hljs-string"><span class="hljs-string">".+_"</span></span> \ --blacklist-type <span class="hljs-string"><span class="hljs-string">"std.*|__.+|.+_$|Game_v(Send|Print|Draw).*|va_list|.+_t$"</span></span> \ --no-layout-tests \ --no-derive-debug \ --raw-line <span class="hljs-string"><span class="hljs-string">"#![allow(improper_ctypes, non_snake_case)]"</span></span> \ -- -I../submodules/bwapi-c/include sed -i -r -- <span class="hljs-string"><span class="hljs-string">'s/.+\s+(.+)_;/pub struct \1;/'</span></span> lib.rs</code> </pre> <br><p>  <code>BWAPI.h</code>是具有BWAPI-C中所有C头的文件。 </p><br><p> 例如，bindgen已经为上面的函数生成了这样的声明： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-comment"><span class="hljs-comment">/// BWAPIC_setGame must be called from gameInit to initialize BWAPI::BroodwarPtr pub fn BWAPIC_setGame(game: *mut Game); } extern "C" { pub fn BWAPIC_getGame() -&gt; *mut Game; }</span></span></code> </pre> <br><p> 有两种策略：将生成的代码存储在存储库中，以及在构建过程中即时生成代码。 两种方法都有其优点和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缺点</a> 。 </p><br><p> 很高兴认识您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bwapi-sys</a> ; 朝着我们的目标又迈出了一步。 </p><br><p> 您还记得我之前谈论过跨平台吗？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">nlinker</a>加入了该项目并实施了一项狡猾的策略。 如果目标主机是Windows，则从GitHub下载已经组装好的BWAPIC。 对于其余的目标，我们从OpenBW的来源中收集BWAPI-C（稍后再介绍）。 </p><br><h2 id="bwapi-rs"> 布瓦皮尔 </h2><br><p> 现在我们有了绑定，我们可以定义高级抽象了。 我们有两种类型可以使用：纯值和不透明指针。 </p><br><p> 一切都很简单，只有纯价值。 让我们以颜色为例。 我们需要使Rust代码易于使用，以便以方便自然的方式使用颜色： </p><br><pre> <code class="rust hljs">game.draw_line(CoordinateType::Screen, (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>), (<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>), Color::Red); ^^^</code> </pre> <br><p> 因此，为了方便使用，有必要使用C ++ <a href="">常量</a>定义枚举，还应使用Rust惯用的枚举，并定义使用std :: convert :: From在bwapi_sys :: Color中对其进行转换的方法： </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// FFI version #[repr(C)] #[derive(Copy, Clone)] pub struct Color { pub color: ::std::os::raw::c_int, } // Idiomatic version #[derive(PartialEq, PartialOrd, Copy, Clone)] pub enum Color { Black = 0, Brown = 19, ...</span></span></code> </pre> <br><p> 为了您的方便，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">枚举基元派生的</a>板条箱。 </p><br><p> 使用不透明指针也很容易。 让我们使用<a href="">Newtype</a>模式： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Player</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sys::Player);</code> </pre> <br><p> 这意味着Player是一种带有私有字段的结构-C语言的原始不透明指针。这是定义Player :: color的方式： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Player { <span class="hljs-comment"><span class="hljs-comment">// so the method is declared Player::getColor in bwapi-sys //extern "C" { // pub fn Player_getColor(self_: *mut Player) -&gt; Color; //} pub fn color(&amp;self) -&gt; Color { // bwapi_sys::Player_getColor - wrapper function from BWAPI-C // self.0 - opaque pointer let color = unsafe { bwapi_sys::Player_getColor(self.0) }; color.into() // cast bwapi_sys::Color -&gt; Color } }</span></span></code> </pre> <br><p> 现在我们可以用Rust编写我们的第一个机器人了！ </p><br><h2 id="creating-a-bot-in-rust"> 在Rust中创建一个机器人 </h2><br><p> 作为概念验证，该机器人将类似于一个知名的countru：整个任务是雇用工人并收集矿物质。 </p><br><p><img src="https://habrastorage.org/webt/hx/r_/jm/hxr_jmj2fbsitx-tfw96p2pa2tu.png" alt="北朝鲜"></p><br><p><img src="https://habrastorage.org/webt/ww/gf/lr/wwgflrekcnxtv75thaurrwcm0g8.png" alt="韩国"></p><br><p> 让我们从所需的功能<code>gameInit</code>和<code>newAIModule</code> ： </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gameInit</span></span></span></span>(game: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> void) { bwapi_sys::BWAPIC_setGame(game <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bwapi_sys::Game); } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newAIModule</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> void { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> module = ExampleAIModule { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"ExampleAIModule"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = wrap_handler(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(module)); result }</code> </pre> <br><p>  <code>#[no_mangle]</code>与C ++中的<code>extern "C"</code>执行相同的功能。 在<code>wrap_handler</code>内部， <code>wrap_handler</code>所有魔术，其中包括虚拟函数表的替换和“掩盖” C ++类。 </p><br><p> 模块结构的定义比C语言更简单，更奇特： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleAIModule</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p> 让我们添加一些方法来呈现统计信息和发出订单： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ExampleAIModule { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_stat</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> game = Game::get(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Frame {}"</span></span>, game.frame_count()); game.draw_text(CoordinateType::Screen, (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), &amp;message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give_orders</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> player = Game::get().self_player(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> player.units() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> unit.get_type() { UnitType::Terran_SCV | UnitType::Zerg_Drone | UnitType::Protoss_Probe =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !unit.is_idle() { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit.is_carrying_gas() || unit.is_carrying_minerals() { unit.return_cargo(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(mineral) = Game::get() .minerals() .min_by_key(|m| unit.distance_to(m)) { <span class="hljs-comment"><span class="hljs-comment">// WE REQUIRE MORE MINERALS unit.right_click(&amp;mineral, false); } } UnitType::Terran_Command_Center =&gt; { unit.train(UnitType::Terran_SCV); } UnitType::Protoss_Nexus =&gt; { unit.train(UnitType::Protoss_Probe); } UnitType::Zerg_Hatchery | UnitType::Zerg_Lair | UnitType::Zerg_Hive =&gt; { unit.train(UnitType::Zerg_Drone); } _ =&gt; {} }; } } }</span></span></code> </pre> <br><p> 要将ExampleAIModule类型转换为实际模块，您需要使其对<strong>onXXXX</strong>事件做出响应。 为此，您需要实现EventHandler类型，该类型类似于C语言中的AIModule_vtable虚拟表： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> EventHandler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ExampleAIModule { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { Game::get().send_text(&amp;<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello from Rust! My name is {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_end</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _is_winner: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_frame</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.draw_stat(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.give_orders(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_send_text</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_receive_text</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _player: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Player, _text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_player_left</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _player: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Player) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_nuke_detect</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _target: Position) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_discover</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_evade</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_show</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_hide</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_destroy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_morph</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_renegade</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_save_game</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _game_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_unit_complete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _unit: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Unit) {} }</code> </pre> <br><p> 生成和运行模块就像使用C一样简单： </p><br><pre> <code class="bash hljs">bwapi-rs$ cargo build --example dll --target=i686-pc-windows-gnu bwapi-rs$ cp ./target/i686-pc-windows-gnu/debug/examples/dll.dll ~/Starcraft/bwapi-data/Dll.dll bwapi-rs$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Starcraft/bwapi-data/ Starcraft$ wine bwheadless.exe -e StarCraft.exe -l bwapi-data/BWAPI.dll --headful ... ... ...</code> </pre> <br><p> 和作品的视频： </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rACbnWpI01M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="openbw">  Openbw </h2><br><p> 这些家伙走得更远。 他们决定编写SC的开源版本：BW！ 他们很擅长。 他们的目标之一是实现HD图像，但SC：Remastered领先于他们=（目前，您可以使用其API编写机器人程序（是的，在C ++中也是如此），但是最令人惊奇的功能是能够查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">直接在浏览器中</a>回放。 </p><br><h2 id="conclusion"> 结论 </h2><br><p> 该实现存在一个未解决的问题：我们不控制引用的唯一性，因此在修改对象时， <code>&amp;mut</code>和<code>&amp;</code>到同一区域的存在将导致未定义的行为。 有点麻烦。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Halt</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试</a>实现惯用的绑定，但是他没有设法找到解决方案。 另外，如果您想完成此任务，则必须仔细“铲起” C ++ API并正确放置<code>const</code>限定符。 </p><br><p> 我真的很享受这个项目的工作，观看了重播종일，并沉浸在氛围中。 该游戏在宇宙中产生了凹痕。 在SC：BW中，没有一款游戏能像现在这样流行，它对대한민국정치的影响是不可想象的。 韩国的职业玩家与黄金时段的韩国多拉姆广播一样受欢迎。  또한，프로프이수수수수수수수수 </p><br><p> 星际争霸万岁！ </p><br><h2 id="links"> 友情链接 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">reddit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布瓦皮尔</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bwapi系统</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布瓦比</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布瓦皮</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Openbw</a> </li></ul><br><hr><br><p> 非常感谢Steve Klabnik帮助我审阅了这篇文章。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436254/">https://habr.com/ru/post/zh-CN436254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436242/index.html">YOLO和其他宽松方法</a></li>
<li><a href="../zh-CN436244/index.html">劳伦斯教授的新大脑</a></li>
<li><a href="../zh-CN436246/index.html">现代汽车工程-02.关于操作系统的论文</a></li>
<li><a href="../zh-CN436248/index.html">卡尔曼滤波</a></li>
<li><a href="../zh-CN436250/index.html">吸血鬼头目脱离上下文或为何总是失败</a></li>
<li><a href="../zh-CN436256/index.html">在德国找工作会更容易</a></li>
<li><a href="../zh-CN436260/index.html">初创企业在为其IP申请专利时的失误和陷阱</a></li>
<li><a href="../zh-CN436262/index.html">*由于最后一刻发现潜在的漏洞，以太坊的“君士坦丁堡”更新被推迟</a></li>
<li><a href="../zh-CN436264/index.html">单一存储库：请不要（第2部分）</a></li>
<li><a href="../zh-CN436266/index.html">阿里巴巴JDK中的极限扩展</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>