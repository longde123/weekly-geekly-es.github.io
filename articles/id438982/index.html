<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¾ğŸ¼ ğŸ‘©ğŸ¾â€âš–ï¸ ğŸ’… Panduan Kubernetes, Bagian 1: Aplikasi, Layanan Mikro, dan Wadah ğŸ¤¹ğŸ¾ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ›¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Atas permintaan kami, Habr menciptakan hub Kubernetes dan kami senang memposting publikasi pertama di dalamnya. Berlangganan! 
 Kubernet mudah. Mengap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Kubernetes, Bagian 1: Aplikasi, Layanan Mikro, dan Wadah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438982/"><blockquote>  Atas permintaan kami, Habr menciptakan hub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes</a> dan kami senang memposting publikasi pertama di dalamnya.  Berlangganan! </blockquote><br>  Kubernet mudah.  Mengapa bank membayar saya banyak uang untuk bekerja di bidang ini, sementara ada yang bisa menguasai teknologi ini hanya dalam beberapa jam? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/d3/4l/ic/d34licaikjsxfxisetkc9arcpdi.jpeg"></a> <br><a name="habracut"></a><br>  Jika Anda ragu bahwa Kubernet dapat dipelajari dengan cepat, saya sarankan Anda mencoba melakukannya sendiri.  Yaitu, setelah menguasai materi ini, Anda akan dapat menjalankan aplikasi berdasarkan pada microservices di kluster Kubernetes.  Saya bisa menjamin ini, karena justru dengan metodologi yang digunakan di sini saya melatih Kubernetes untuk bekerja dengan klien kami.  Apa yang membedakan manual ini dari yang lain?  Bahkan - banyak hal.  Jadi, sebagian besar materi ini dimulai dengan penjelasan tentang hal-hal sederhana - konsep Kubernetes dan fitur-fitur dari tim kubectl.  Para penulis materi ini percaya bahwa pembaca mereka akrab dengan pengembangan aplikasi, layanan microser, dan wadah Docker.  Kami akan pergi ke arah lain.  Pertama, mari kita bicara tentang cara menjalankan aplikasi berbasis pada layanan microser di komputer.  Kemudian pertimbangkan perakitan gambar wadah untuk setiap layanan mikro.  Setelah itu, kita akan mengenal Kubernetes dan menganalisis penyebaran aplikasi berbasis microservice dalam sebuah cluster yang dikelola oleh Kubernetes. <br><br>  Pendekatan semacam itu, dengan pendekatan bertahap ke Kubernetes, akan memberikan kedalaman pemahaman yang terjadi pada orang biasa untuk memahami bagaimana sederhananya semuanya diatur dalam Kubernetes.  Kubernetes, tentu saja, teknologi sederhana, asalkan siapa pun yang ingin mempelajarinya tahu di mana dan bagaimana ia digunakan. <br><br>  Sekarang, tanpa basa-basi lagi, mari kita mulai bekerja dan berbicara tentang aplikasi yang dengannya kita akan bekerja. <br><br><h2>  <font color="#3AC1EF">Aplikasi eksperimental</font> </h2><br>  Aplikasi kita hanya akan melakukan satu fungsi.  Ia menerima, sebagai input, satu kalimat, dan kemudian, menggunakan sarana analisis teks, melakukan analisis sentimen kalimat ini, menerima perkiraan sikap emosional penulis kalimat terhadap objek tertentu. <br><br>  Seperti inilah tampilan jendela utama aplikasi ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/7e1/415/6747e14151585819867c880f52fa9d21.gif"></div><br>  <i><font color="#999999">Aplikasi web untuk analisis sentimen teks</font></i> <br><br>  Dari sudut pandang teknis, aplikasi terdiri dari tiga layanan microser, yang masing-masing menyelesaikan serangkaian tugas: <br><br><ul><li>  SA-Frontend adalah server web Nginx yang menyajikan Bereaksi file statis. </li><li>  SA-WebApp adalah aplikasi web berbasis Java yang memproses permintaan dari front-end. </li><li>  SA-Logic adalah aplikasi Python yang melakukan analisis sentimen teks. </li></ul><br>  Penting untuk dicatat bahwa layanan microser tidak ada dalam isolasi.  Mereka menerapkan gagasan "pemisahan tugas", tetapi mereka, bagaimanapun, perlu berinteraksi satu sama lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/f93/0c0/94bf930c03220c1eec6957a0f7308046.gif"></div><br>  <i><font color="#999999">Aliran Data Aplikasi</font></i> <br><br>  Dalam diagram di atas, Anda dapat melihat tahapan bernomor sistem, menggambarkan aliran data dalam aplikasi.  Mari kita analisa mereka: <br><br><ol><li> Browser meminta file <code>index.html</code> dari server (yang, pada gilirannya, mengunduh paket aplikasi Bereaksi). </li><li>  Pengguna berinteraksi dengan aplikasi, ini menyebabkan panggilan ke aplikasi web berbasis pada Spring. </li><li>  Aplikasi web mengalihkan permintaan untuk analisis teks ke aplikasi Python. </li><li>  Aplikasi Python menganalisis nada suara teks dan mengembalikan hasilnya sebagai respons terhadap permintaan. </li><li>  Aplikasi Spring mengirim respons ke aplikasi Bereaksi (dan itu, pada gilirannya, menunjukkan hasil analisis teks kepada pengguna). </li></ol><br>  Kode untuk semua aplikasi ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Saya sarankan Anda sekarang menyalin repositori ini ke diri Anda sendiri, karena ada banyak eksperimen menarik di depannya. <br><br><h2>  <font color="#3AC1EF">Memulai aplikasi berbasis microservice di komputer lokal</font> </h2><br>  Agar aplikasi berfungsi, kita perlu menjalankan ketiga layanan microser.  Mari kita mulai dengan yang paling lucu dari mereka - dengan aplikasi front-end. <br><br><h3>  <font color="#3AC1EF">â– Mengkonfigurasi Bereaksi untuk pengembangan lokal</font> </h3><br>  Untuk menjalankan aplikasi Bereaksi, Anda harus menginstal platform Node.js dan NPM di komputer Anda.  Setelah Anda menginstal semua ini, buka terminal ke folder proyek <code>sa-frontend</code> dan jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">npm install</code> </pre> <br>  Berkat pelaksanaan perintah ini, dependensi aplikasi Bereaksi, entri tentang yang ada di file <code>package.json</code> , akan dimuat ke folder <code>node_modules</code> .  Setelah dependensi diunduh di folder yang sama, jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Itu saja.  Sekarang aplikasi Bereaksi berjalan, akses ke sana dapat diperoleh dengan pergi ke alamat <code>localhost:3000</code> di browser.  Anda dapat mengubah sesuatu dalam kodenya.  Anda akan segera melihat efek dari perubahan ini di browser.  Ini dimungkinkan berkat penggantian modul yang disebut "hot".  Berkat ini, pengembangan front-end berubah menjadi tugas yang sederhana dan menyenangkan. <br><br><h3>  <font color="#3AC1EF">â–Persiapan aplikasi Bereaksi untuk output ke produksi</font> </h3><br>  Untuk penggunaan sebenarnya dari aplikasi Bereaksi, kita perlu mengubahnya menjadi satu set file statis dan memberikannya kepada klien menggunakan server web. <br><br>  Untuk membangun aplikasi Bereaksi, sekali lagi, menggunakan terminal, pergi ke folder <code>sa-frontend</code> dan jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> <br>  Ini akan membuat direktori <code>build</code> di folder proyek.  Ini akan berisi semua file statis yang diperlukan agar aplikasi Bereaksi berfungsi. <br><br><h3>  <font color="#3AC1EF">ErvMelayani file statis menggunakan alat Nginx</font> </h3><br>  Pertama, Anda perlu menginstal dan menjalankan server web Nginx.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat mengunduhnya dan menemukan petunjuk pemasangan dan memulai.  Maka Anda perlu menyalin isi folder <code>sa-frontend/build</code> ke folder <code>[your_nginx_installation_dir]/html</code> . <br><br>  Dengan pendekatan ini, file <code>index.html</code> dihasilkan selama pembuatan aplikasi Bereaksi akan tersedia di <code>[your_nginx_installation_dir]/html/index.html</code> .  Ini adalah file yang, secara default, masalah server Nginx ketika mengaksesnya.  Server dikonfigurasikan untuk mendengarkan pada port <code>80</code> , tetapi Anda dapat mengkonfigurasinya seperti yang Anda perlukan dengan mengedit file <code>[your_nginx_installation_dir]/conf/nginx.conf</code> . <br><br>  Sekarang buka browser Anda dan pergi ke <code>localhost:80</code> .  Anda akan melihat halaman Bereaksi aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a50/b83/f39/a50b83f390ff0434ef817f357a041941.png"></div><br>  <i><font color="#999999">Bereaksi Aplikasi Dilayani oleh Nginx Server</font></i> <br><br>  Jika Anda mengetik sesuatu di bidang <code>Type your sentence</code> sekarang dan klik tombol <code>Send</code> , tidak ada yang terjadi.  Tetapi, jika Anda melihat konsol, Anda dapat melihat pesan kesalahan di sana.  Untuk memahami dengan tepat di mana kesalahan ini terjadi, mari kita menganalisis kode aplikasi. <br><br><h3>  <font color="#3AC1EF">â– Analisis kode aplikasi front-end</font> </h3><br>  <code>App.js</code> melihat kode file <code>App.js</code> , kita dapat melihat bahwa mengklik tombol <code>Send</code> memanggil metode <code>analyzeSentence()</code> .  Kode untuk metode ini diberikan di bawah ini.  Pada saat yang sama, perhatikan fakta bahwa untuk setiap baris yang ada komentar dari bentuk <code># </code> , ada penjelasan yang diberikan di bawah kode.  Dengan cara yang sama, kita akan mem-parsing potongan kode lainnya. <br><br><pre> <code class="plaintext hljs">analyzeSentence() {   fetch('http://localhost:8080/sentiment', {  // #1       method: 'POST',       headers: {           'Content-Type': 'application/json'       },       body: JSON.stringify({                      sentence: this.textField.getValue()})// #2   })       .then(response =&gt; response.json())       .then(data =&gt; this.setState(data));  // #3 }</code> </pre> <br>  <b>1.</b> URL tempat permintaan POST dijalankan.  Dapat dipahami bahwa alamat ini berisi aplikasi yang menunggu permintaan tersebut. <br><br>  <b>2.</b> Badan permintaan dikirim ke aplikasi.  Berikut ini contoh badan permintaan: <br><br><pre> <code class="plaintext hljs">{   sentence: "I like yogobella!" }</code> </pre> <br>  <b>3.</b> Setelah menerima tanggapan atas permintaan, status komponen diperbarui.  Ini menyebabkan komponen merender ulang.  Jika kami menerima data (yaitu, objek JSON yang berisi data yang dimasukkan dan skor teks yang dihitung), kami akan menampilkan komponen <code>Polarity</code> , karena kondisi yang sesuai akan dipenuhi.  Ini adalah bagaimana kami menggambarkan komponen: <br><br><pre> <code class="plaintext hljs">const polarityComponent = this.state.polarity !== undefined ?   &lt;Polarity sentence={this.state.sentence}             polarity={this.state.polarity}/&gt; :   null;</code> </pre> <br>  Kode ini tampaknya berfungsi dengan baik.  Apa yang salah di sini?  Jika Anda berasumsi bahwa di alamat tempat aplikasi mencoba mengirim permintaan POST, sejauh ini tidak ada yang dapat menerima dan memproses permintaan ini, maka Anda akan benar.  Yaitu, untuk memproses permintaan yang tiba di alamat <code>http://localhost:8080/sentiment</code> , kita perlu menjalankan aplikasi web berdasarkan Spring. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/f16/5a3/848f165a308f9ae73ffd3f8186b23aee.png"></div><br>  <i><font color="#999999">Kami membutuhkan aplikasi Spring yang dapat menerima permintaan POST.</font></i> <br><br><h3>  <font color="#3AC1EF">â–Mengatur aplikasi web berbasis pegas</font> </h3><br>  Untuk menyebarkan aplikasi Spring, Anda perlu JDK8 dan Maven dan variabel lingkungan yang dikonfigurasi dengan benar.  Setelah Anda menginstal semua ini, Anda dapat terus mengerjakan proyek kami. <br><br><h3>  <font color="#3AC1EF">â–Paket aplikasi dalam file jar</font> </h3><br>  Pergi, menggunakan terminal, ke folder <code>sa-webapp</code> dan masukkan perintah berikut: <br><br><pre> <code class="plaintext hljs">mvn install</code> </pre> <br>  Setelah menjalankan perintah ini, direktori <code>target</code> akan dibuat di folder <code>sa-webapp</code> .  Akan ada aplikasi Java yang dikemas dalam file jar yang diwakili oleh <code>sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> . <br><br><h3>  <font color="#3AC1EF">â–Mulai aplikasi Java</font> </h3><br>  Buka folder <code>target</code> dan luncurkan aplikasi dengan perintah berikut: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> </pre> <br>  Kesalahan akan terjadi selama pelaksanaan perintah ini.  Untuk mulai memperbaikinya, kami dapat menganalisis informasi pengecualian di data jejak tumpukan: <br><br><pre> <code class="plaintext hljs">Error creating bean with name 'sentimentController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'sa.logic.api.url' in value "${sa.logic.api.url}"</code> </pre> <br>  Bagi kami, hal terpenting di sini adalah penyebutan ketidakmungkinan untuk memastikan makna dari <code>sa.logic.api.url</code> .  Mari kita menganalisis kode di mana kesalahan terjadi. <br><br><h3>  <font color="#3AC1EF">â– Analisis kode aplikasi Java</font> </h3><br>  Berikut ini cuplikan kode tempat kesalahan terjadi. <br><br><pre> <code class="plaintext hljs">@CrossOrigin(origins = "*") @RestController public class SentimentController {   @Value("${sa.logic.api.url}")    // #1   private String saLogicApiUrl;   @PostMapping("/sentiment")   public SentimentDto sentimentAnalysis(       @RequestBody SentenceDto sentenceDto)   {       RestTemplate restTemplate = new RestTemplate();       return restTemplate.postForEntity(               saLogicApiUrl + "/analyse/sentiment",    // #2               sentenceDto, SentimentDto.class)               .getBody();   } }</code> </pre> <br><ol><li>  S <code>entimentController</code> memiliki bidang <code>saLogicApiUrl</code> .  Nilainya ditentukan oleh properti <code>sa.logic.api.url</code> . </li><li>  String <code>saLogicApiUrl</code> digabungkan dengan nilai <code>/analyse/sentiment</code> .  Bersama-sama mereka membentuk alamat untuk mengakses layanan mikro yang melakukan analisis teks. </li></ol><br><h3>  <font color="#3AC1EF">â–Mengatur nilai properti</font> </h3><br>  Di Spring, sumber standar nilai properti adalah file <code>application.properties</code> , yang dapat ditemukan di <code>sa-webapp/src/main/resources</code> .  Tetapi penggunaannya bukan satu-satunya cara untuk menetapkan nilai properti.  Anda dapat melakukan ini dengan perintah seperti berikut: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=WHAT.IS.THE.SA.LOGIC.API.URL</code> </pre> <br>  Nilai properti ini harus mengarah ke alamat aplikasi Python kami. <br><br>  Dengan mengonfigurasinya, kami memberi tahu aplikasi web Spring di mana ia harus pergi untuk mengeksekusi permintaan analisis teks. <br><br>  Agar tidak menyulitkan hidup kita, kami memutuskan bahwa aplikasi Python akan tersedia di <code>localhost:5000</code> dan mencoba untuk tidak melupakannya.  Akibatnya, perintah untuk meluncurkan aplikasi Spring akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=http://localhost:5000</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/445/815/30d44581533865907366e867c029124e.png"></div><br>  <i><font color="#999999">Sistem kami tidak memiliki aplikasi Python</font></i> <br><br>  Sekarang kita hanya perlu menjalankan aplikasi Python dan sistem akan berfungsi seperti yang diharapkan. <br><br><h3>  <font color="#3AC1EF">â– Mengkonfigurasi aplikasi Python</font> </h3><br>  Untuk menjalankan aplikasi Python, Anda harus menginstal Python 3 dan Pip, dan Anda perlu mengatur variabel lingkungan yang sesuai dengan benar. <br><br><h3>  <font color="#3AC1EF">â–Penginstalan dependensi</font> </h3><br>  Buka folder proyek <code>sa-logic/sa</code> dan jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">python -m pip install -r requirements.txt python -m textblob.download_corpora</code> </pre> <br><h3>  <font color="#3AC1EF">â–Mulai aplikasi</font> </h3><br>  Setelah menginstal dependensi, kami siap meluncurkan aplikasi: <br><br><pre> <code class="plaintext hljs">python sentiment_analysis.py</code> </pre> <br>  Setelah menjalankan perintah ini, kami akan diberitahu hal berikut: <br><br><pre> <code class="plaintext hljs">* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</code> </pre> <br>  Ini berarti bahwa aplikasi sedang berjalan dan sedang menunggu permintaan di <code>localhost:5000/</code> <br><br><h3>  <font color="#3AC1EF">â– Penelitian Kode</font> </h3><br>  Pertimbangkan kode aplikasi Python untuk memahami bagaimana responsnya terhadap permintaan: <br><br><pre> <code class="plaintext hljs">from textblob import TextBlob from flask import Flask, request, jsonify app = Flask(__name__)                                   #1 @app.route("/analyse/sentiment", methods=['POST'])      #2 def analyse_sentiment():   sentence = request.get_json()['sentence']           #3   polarity = TextBlob(sentence).sentences[0].polarity #4   return jsonify(                                     #5       sentence=sentence,       polarity=polarity   ) if __name__ == '__main__':   app.run(host='0.0.0.0', port=5000)                #6</code> </pre> <br><ol><li>  Inisialisasi Objek <code>Flask</code> . </li><li>  Mengatur alamat untuk mengeksekusi permintaan POST untuk itu. </li><li>  Mengambil properti <code>sentence</code> dari badan permintaan. </li><li>  Menginisialisasi objek <code>TextBlob</code> anonim dan mendapatkan nilai <code>polarity</code> untuk kalimat pertama di badan permintaan (dalam kasus kami, ini adalah satu-satunya kalimat yang dilewati untuk analisis). </li><li>  Kembalinya respons, yang berisi teks proposal dan indeks <code>polarity</code> dihitung untuknya. </li><li>  Meluncurkan aplikasi Flask, yang akan tersedia di alamat <code>0.0.0.0:5000</code> (Anda juga dapat mengaksesnya menggunakan desain formulir <code>localhost:5000</code> ). </li></ol><br>  Sekarang layanan microser yang membentuk aplikasi sedang berjalan.  Mereka dikonfigurasikan untuk saling berinteraksi.  Beginilah tampilan diagram aplikasi pada tahap kerja ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75a/fcc/135/75afcc1352ed237efaf0a2280c2df295.png"></div><br>  <i><font color="#999999">Semua layanan microser yang membentuk aplikasi dibawa ke keadaan sehat.</font></i> <br><br>  Sekarang, sebelum melanjutkan, buka aplikasi Bereaksi di browser dan cobalah untuk menganalisis beberapa saran menggunakannya.  Jika semuanya dilakukan dengan benar, setelah mengklik tombol <code>Send</code> , Anda akan melihat hasil analisis di bawah kotak teks. <br><br>  Di bagian berikutnya, kita akan berbicara tentang cara menjalankan layanan microser kami dalam wadah Docker.  Ini diperlukan untuk menyiapkan aplikasi untuk diluncurkan di kluster Kubernetes. <br><br><h2>  <font color="#3AC1EF">Wadah Docker</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes</a> adalah sistem untuk mengotomatiskan penyebaran, penskalaan, dan pengelolaan aplikasi kemas.  Itu juga disebut "wadah orkestra".  Jika Kubernet bekerja dengan kontainer, pertama-tama kita harus memperoleh kontainer ini sebelum menggunakan sistem ini.  Tapi pertama-tama, mari kita bicara tentang wadah apa.  Mungkin jawaban terbaik untuk pertanyaan tentang apa itu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> untuk Docker: <br><br>  <i>Gambar kontainer adalah paket yang ringan, berdiri sendiri, dan dapat dijalankan yang berisi aplikasi yang mencakup semua yang Anda perlukan untuk menjalankannya: kode aplikasi, runtime, alat sistem dan pustaka, dan pengaturan.</i>  <i>Program kemas dapat digunakan di lingkungan Linux dan Windows, dan mereka akan selalu bekerja sama terlepas dari infrastruktur.</i> <br><br>  Ini berarti bahwa kontainer dapat dijalankan di komputer mana pun, termasuk server produksi, dan dalam lingkungan apa pun aplikasi yang disertakan di dalamnya akan bekerja dengan cara yang sama. <br><br>  Untuk menjelajahi fitur wadah dan membandingkannya dengan cara lain untuk meluncurkan aplikasi, pertimbangkan contoh melayani aplikasi Bereaksi menggunakan mesin virtual dan wadah. <br><br><h3>  <font color="#3AC1EF">ErvMelayani React file aplikasi statis menggunakan mesin virtual</font> </h3><br>  Mencoba mengatur pemeliharaan file statis dengan menggunakan mesin virtual, kita akan menghadapi kekurangan berikut: <br><br><ol><li>  Penggunaan sumber daya yang tidak efisien, karena setiap mesin virtual adalah sistem operasi yang lengkap. </li><li>  Ketergantungan platform.  Apa yang berfungsi pada komputer lokal tertentu mungkin tidak berfungsi pada server produksi. </li><li>  Penskalaan lambat dan sumber daya intensif dari solusi berbasis mesin virtual. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/927/523/c26927523b6072ce65bfaf8b01a1e330.png"></div><br>  <i><font color="#999999">Server web server statis Nginx berjalan pada mesin virtual</font></i> <br><br>  Jika kontainer digunakan untuk memecahkan masalah yang sama, maka, dibandingkan dengan mesin virtual, kekuatan berikut dapat dicatat: <br><br><ol><li>  Penggunaan sumber daya yang efisien: bekerja dengan sistem operasi menggunakan Docker. </li><li>  Kemandirian platform.  Wadah yang dapat dijalankan oleh pengembang di komputernya akan berfungsi di mana saja. </li><li>  Penerapan ringan melalui penggunaan lapisan gambar. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28b/593/b01/28b593b01ce003c246843d9c9f2bd05f.png"></div><br>  <i><font color="#999999">Nginx server statis server web berjalan dalam wadah</font></i> <br><br>  Kami membandingkan mesin dan wadah virtual hanya pada beberapa titik, tetapi bahkan ini sudah cukup untuk merasakan kekuatan dari wadah tersebut.  Cari tahu lebih lanjut tentang wadah Docker di sini. <br><br><h3>  <font color="#3AC1EF">â– Merakit gambar kontainer untuk aplikasi Bereaksi</font> </h3><br>  Blok bangunan utama wadah Docker adalah <code>Dockerfile</code> .  Pada awal file ini, buatlah rekaman gambar dasar wadah, kemudian mereka memasukkan urutan instruksi yang menunjukkan urutan pembuatan wadah yang akan memenuhi kebutuhan aplikasi tertentu. <br><br>  Sebelum kita mulai bekerja dengan <code>Dockerfile</code> , mari kita mengingat kembali apa yang telah kita lakukan untuk mempersiapkan file aplikasi Bereaksi untuk diunggah ke server Nginx: <br><br><ol><li>  Bangun paket aplikasi Bereaksi ( <code>npm run build</code> ). </li><li>  Mulai server Nginx. </li><li>  Salin isi direktori <code>build</code> dari folder <code>sa-frontend</code> project ke folder server <code>nginx/html</code> . </li></ol><br>  Di bawah ini Anda dapat melihat kesejajaran antara membuat wadah dan tindakan di atas dilakukan pada komputer lokal. <br><br><h3>  <font color="#3AC1EF">â–Menyiapkan Dockerfile untuk SA-Frontend</font> </h3><br>  Instruksi yang akan dimuat dalam <code>Dockerfile</code> untuk aplikasi <code>SA-Frontend</code> hanya terdiri dari dua perintah.  Faktanya adalah bahwa tim pengembangan Nginx menyiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar</a> dasar untuk Nginx, yang akan kita gunakan untuk membuat gambar kita.  Berikut adalah dua langkah yang perlu kami jelaskan: <br><br><ol><li>  Dasar dari gambar yang Anda butuhkan untuk membuat gambar Nginx. </li><li>  Isi folder <code>sa-frontend/build</code> harus disalin ke folder gambar <code>nginx/html</code> . </li></ol><br>  Jika kita berpindah dari deskripsi ini ke <code>Dockerfile</code> , maka akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">FROM nginx COPY build /usr/share/nginx/html</code> </pre> <br>  Seperti yang Anda lihat, semua yang ada di sini sangat sederhana, sementara isi file tersebut ternyata cukup mudah dibaca dan dimengerti.  File ini memberi tahu sistem untuk mengambil gambar <code>nginx</code> dengan segala yang sudah dimiliki dan menyalin isi direktori <code>build</code> ke direktori <code>nginx/html</code> . <br><br>  Di sini Anda mungkin memiliki pertanyaan tentang di mana saya tahu tentang di mana tepatnya menyalin file dari folder <code>build</code> , yaitu dari mana path <code>/usr/share/nginx/html</code> berasal.  Bahkan, dan tidak ada yang rumit.  Faktanya adalah bahwa informasi yang relevan dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi</a> gambar. <br><br><h3>  <font color="#3AC1EF">â–Membangun gambar dan mengunggahnya ke repositori</font> </h3><br>  Sebelum kita dapat bekerja dengan gambar yang sudah jadi, kita perlu mengirimkannya ke repositori gambar.  Untuk melakukan ini, kami akan menggunakan platform cloud gratis untuk hosting gambar Docker Hub.  Pada tahap pekerjaan ini, Anda perlu melakukan hal berikut: <br><br><ol><li>  Instal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> . </li><li>  Daftar di situs Docker Hub. </li><li>  Masuk ke akun dengan menjalankan perintah berikut di terminal: <br><br><pre> <code class="plaintext hljs">docker login -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD"</code> </pre> </li></ol><br>  Sekarang Anda perlu menggunakan terminal untuk pergi ke direktori <code>sa-frontend</code> dan menjalankan perintah berikut di sana: <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend .</code> </pre> <br>  Selanjutnya dalam perintah serupa, <code>$DOCKER_USER_ID</code> perlu diganti dengan nama pengguna Anda di Docker Hub.  Sebagai contoh, bagian dari perintah ini mungkin terlihat seperti ini: <code>rinormaloku/sentiment-analysis-frontend</code> . <br><br>  Pada saat yang sama, perintah ini dapat dipersingkat dengan menghapus <code>-f Dockerfile</code> darinya, karena file ini sudah ada di folder tempat kami menjalankan perintah ini. <br><br>  Untuk mengirim gambar yang sudah jadi ke repositori, kita memerlukan perintah berikut: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Setelah eksekusi, periksa daftar repositori Anda di Docker Hub untuk memahami apakah gambar berhasil dikirim ke cloud. <br><br><h3>  <font color="#3AC1EF">â– Mulai wadah</font> </h3><br>  Sekarang siapa pun dapat mengunduh dan menjalankan gambar yang dikenal sebagai <code>$DOCKER_USER_ID/sentiment-analysis-frontend</code> .  Untuk melakukan ini, Anda harus menjalankan urutan perintah berikut: <br><br><pre> <code class="plaintext hljs">docker pull $DOCKER_USER_ID/sentiment-analysis-frontend docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Sekarang wadah diluncurkan, dan kami dapat terus bekerja, menciptakan gambar lain yang kami butuhkan.  Tapi, sebelum melanjutkan, mari kita <code>80:80</code> konstruksi <code>80:80</code> , yang ditemukan dalam perintah peluncuran gambar dan mungkin tampak tidak bisa dipahami. <br><br><ul><li>  Angka pertama <code>80</code> adalah nomor port host (yaitu, komputer lokal). </li><li>  Angka kedua <code>80</code> adalah pelabuhan wadah yang permintaannya harus dialihkan. </li></ul><br>  Perhatikan ilustrasi berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/394/6cd/7753946cde3287113b82f00921ced889.png"></div><br>  <i><font color="#999999">Penerusan port</font></i> <br><br>  Sistem mengalihkan permintaan dari port <code>&lt;hostPort&gt;</code> ke port <code>&lt;containerPort&gt;</code> .  Artinya, akses ke port <code>80</code> komputer dialihkan ke port <code>80</code> wadah. <br><br>  Karena port <code>80</code> terbuka di komputer lokal, Anda dapat mengakses aplikasi dari komputer ini di <code>localhost:80</code> .  Jika sistem Anda tidak mendukung Docker, Anda dapat menjalankan aplikasi pada mesin virtual Docker, yang alamatnya akan terlihat seperti <code>&lt;docker-machine ip&gt;:80</code> .  Untuk mengetahui alamat IP mesin virtual Docker, Anda dapat menggunakan <code>docker-machine ip</code> . <br><br>  Pada tahap ini, setelah berhasil meluncurkan wadah aplikasi frontend, Anda harus dapat membuka halamannya di browser. <br><br><h3>  <font color="#3AC1EF">â– .dockerignore file</font> </h3><br>  Mengumpulkan gambar aplikasi <code>SA-Frontend</code> , kita dapat melihat bahwa proses ini sangat lambat.  Ini terjadi karena fakta bahwa konteks build dari gambar harus dikirim ke daemon Docker.  Direktori yang mewakili konteks build ditentukan oleh argumen terakhir ke <code>docker build</code> .  Dalam kasus kami, pada akhir perintah ini adalah titik.  Ini menghasilkan struktur berikut yang termasuk dalam konteks perakitan: <br><br><pre> <code class="plaintext hljs">sa-frontend: |   .dockerignore |   Dockerfile |   package.json |   README.md +---build +---node_modules +---public \---src</code> </pre> <br>  Tapi dari semua folder yang ada di sini, kita hanya perlu folder <code>build</code> .  Mengunduh hal lain adalah buang-buang waktu.  Build dapat dipercepat dengan memberi tahu Docker direktori mana yang harus diabaikan.  Untuk melakukan ini kita perlu file <code>.dockerignore</code> .  Jika Anda terbiasa dengan file <code>.gitignore</code> , struktur file ini pasti tampak akrab.  Ini daftar direktori yang mungkin diabaikan sistem perakitan gambar.  Dalam kasus kami, isi file ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">node_modules src public</code> </pre> <br>  File <code>.dockerignore</code> harus berada di folder yang sama dengan <code>Dockerfile</code> .  Sekarang merakit gambar akan membutuhkan waktu beberapa detik. <br><br>  Sekarang mari kita lihat aplikasi Java. <br><br><h3> <font color="#3AC1EF">â–    Java-</font> </h3><br>  ,           .       . <br><br>   <code>Dockerfile</code> ,      <code>sa-webapp</code> .      ,         ,     <code>ENV</code>  <code>EXPOSE</code> : <br><br><pre> <code class="plaintext hljs">ENV SA_LOGIC_API_URL http://localhost:5000 â€¦ EXPOSE 8080</code> </pre> <br>   <code>ENV</code>       Docker.  ,       URL    API ,   . <br><br>   <code>EXPOSE</code>   Docker  ,    .          .   ,   <code>Dockerfile</code>   <code>SA-Frontend</code>   .      ,  ,     ,    <code>Dockerfile</code> . <br><br>           ,    .           â€”       <code>README.md</code>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">â–    Python-</font> </h3><br>       <code>Dockerfile</code>   <code>sa-logic</code> ,         .               ,  ,        ,     <code>README.md</code>   <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">â–  </font> </h3><br>     - ,    ?    .   . <br><br><ol><li>    <code>sa-logic</code>       <code>5050</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 5050:5000 $DOCKER_USER_ID/sentiment-analysis-logic</code> </pre> </li><li>    <code>sa-webapp</code>       <code>8080</code> .  ,    ,   Python-     Java-,    <code>SA_LOGIC_API_URL</code> : <br><br><pre> <code class="plaintext hljs">$ docker run -d -p 8080:8080 -e SA_LOGIC_API_URL='http://&lt;container_ip or docker machine ip&gt;:5000' $DOCKER_USER_ID/sentiment-analysis-web-app</code> </pre> </li></ol><br>      ,   IP-     Docker â€”    <a href="">README</a> . <br><br>    <code>sa-frontend</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>     ,       <code>localhost:80</code>   . <br><br>    ,       <code>sa-webapp</code> ,        Docker,     <code>App.js</code>   <code>sa-frontend</code> ,  IP-      <code>analyzeSentence()</code> ,      .         . <br><br>       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/71e/87a/79671e87adea76c8873cac180e2fe8c0.png"></div><br> <i><font color="#999999">   </font></i> <br><br><h2> <font color="#3AC1EF">:    Kubernetes?</font> </h2><br>      <code>Dockerfile</code> ,   ,         Docker.  ,     ,   <code>.dockerignore</code> .         Docker.          ,   Kubernetes.          .      : <br> ,   -      .       .  ,   <code>sa-webapp</code>  <code>sa-logic</code>     .   ,    ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438982/">https://habr.com/ru/post/id438982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438972/index.html">Otak dari dalam (visualisasi bagian dari pola melalui model jaringan saraf tiruan)</a></li>
<li><a href="../id438974/index.html">Realitas Virtual Membantu Menangani Gangguan Mental</a></li>
<li><a href="../id438976/index.html">Buku "Spring. Semua pola desain Â»</a></li>
<li><a href="../id438978/index.html">Belajar selalu dan di mana saja! Podcast untuk pengembang dalam bahasa Inggris</a></li>
<li><a href="../id438980/index.html">Spring Boot 2: apa yang baru?</a></li>
<li><a href="../id438984/index.html">Panduan Kubernetes, Bagian 2: Membuat dan Bekerja dengan Cluster</a></li>
<li><a href="../id438986/index.html">React Tutorial Bagian 14: Workshop Komponen Berbasis Kelas, Status Komponen</a></li>
<li><a href="../id438988/index.html">React Tutorial Bagian 15: Lokakarya State Komponen</a></li>
<li><a href="../id438992/index.html">Diary Pengembang atau Keputusan Buruk</a></li>
<li><a href="../id438994/index.html">Intel Xeon W-3175X, drummer panas. Pengujian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>