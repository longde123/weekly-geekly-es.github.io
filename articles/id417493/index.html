<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ‚òòÔ∏è üë®üèΩ‚Äçüè´ Cara mengompres bootloader untuk STM8 ke ukuran 18 byte dalam memori FLASH üíáüèΩ üöî üöè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika mencari bootloader untuk mikrokontroler STM8S103F3, ditemukan bahwa bootloader yang tersedia terutama ditulis dalam "C", "mencuri" sejumlah bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengompres bootloader untuk STM8 ke ukuran 18 byte dalam memori FLASH</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417493/">  Ketika mencari bootloader untuk mikrokontroler STM8S103F3, ditemukan bahwa bootloader yang tersedia terutama ditulis dalam "C", "mencuri" sejumlah besar memori FLASH, dan mentransfer tabel vektor interupsi. <br><br>  Bootloader diperlukan untuk beberapa perangkat yang tidak mungkin menghubungkan programmer. <br><br>  Diputuskan untuk mencoba menulis sendiri bootloader dengan persyaratan berikut: <br><br>  - loader harus disebut STM8uLoader; <br>  - Kode harus ditulis dalam assembler (manfaat assembler belum dilarang secara hukum); <br>  - bootloader harus menempati jumlah terkecil yang mungkin dalam memori FLASH, jumlah yang ditempati di komputer akan dianggap tidak terbatas; <br>  - loader tidak boleh memindahkan tabel vektor interupsi; <br>  - bootloader harus memiliki fungsionalitas minimal, semua fungsi utama harus diambil alih oleh komputer; <br>  - bootloader harus mentransfer kontrol ke program aplikasi dalam waktu yang wajar setelah reset / power-on jika tidak ada koneksi ke komputer. <br><br>  Kondisi pertama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipenuhi secara</a> instan, tetapi persyaratan berikutnya harus dikerjakan. <br><a name="habracut"></a><br><h4>  Tahap pertama.  Kode 65 byte dalam memori FLASH </h4><br>  Untuk menyimpan tabel vektor di tempatnya, diputuskan untuk menempatkan kode di akhir memori FLASH dan segera beralih ke sana dari vektor dump $ 8000. <br><br>  Saat boot, kontrol ditransfer ke kode bootloader dengan harga $ 9FC2.  Bootloader mengkonfigurasi UART 9600 8N1, menunggu dua byte pada UART, dan tanpa menunggu, mentransfer kontrol ke program aplikasi di alamat yang disimpan dalam pasangan yang $ 9FFE: $ 9FFF. <br><br>  Jika loader menerima byte tinggi dan rendah dari ukuran dump yang diharapkan dari program host, ia mengambil dump itu sendiri, menempatkan dump dalam memori RAM dan mentransfer kontrol ke sana. <br>  Selanjutnya, semua perawatan terletak pada program di komputer dan dump yang dikirimkannya.  Seharusnya mengirimkan persis dump yang diperlukan untuk menyelesaikan tugas saat ini (baca / hapus / tulis / salin sel memori STM8).  Dumps harus dapat saling menggantikan dalam memori RAM dan mentransfer kontrol ke program aplikasi. <br><br>  Alamat transisi ke aplikasi adalah $ 9FFE: $ 9FFF. <br><br><div class="spoiler">  <b class="spoiler_title">File boot_FLASH.asm:</b> <div class="spoiler_text"><pre><code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: jp boot_FLASH_start dc.b $00 ; boot_FLASH ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FC1      WORDS ; segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FC2 <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span>; Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> mov UART1_CR2, #%00001100;  / ;   UART1   RST_SR boot_FLASH_RST_SR_tx: mov UART1_DR, RST_SR ;    ,      ;      ;    X    ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ldw X,#<span class="hljs-number"><span class="hljs-number">0</span></span> boot_FLASH_wait_byte1: decw X jreq boot_FLASH_exit;       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_wait_byte1 ;   ,   , ;  X     ld A, UART1_DR ld XH, A ;      boot_FLASH_wait_byte2: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_wait_byte2 ;    ld A, UART1_DR ld XL, A ;  X -    ;   X       ldw Y, #$0400 ;  Y   <span class="hljs-number"><span class="hljs-number">0x0400</span></span> (RAM_END + <span class="hljs-number"><span class="hljs-number">1</span></span>) ;    boot_FLASH_rx_block_wait: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_rx_block_wait boot_EEPROM_rx_block_entry: decw Y ;      Y     ld A, UART1_DR ld (Y), A decw X ;      X      jrne boot_FLASH_rx_block_wait ;      jp (Y) ;    ()  boot_FLASH_exit: dc.b $CC boot_FLASH_exit_addr: dc.w main_FLASH_start end ;</code> </pre> <br></div></div><br><h4>  Tahap kedua.  Ukuran kode 21 byte dalam FLASH dan 52 byte dalam memori EEPROM </h4><br>  Memilih 65 byte dari memori FLASH (dalam STM8S103F3 hanya 8192 byte) tidak manusiawi.  Lagi pula, memori EEPROM yang tidak perlu dengan 640 byte-nya terletak di dekatnya.  Mari kita membagi kode bootloader menjadi dua bagian boot_FLASH dan boot_EEPROM. <br><br>  Saat memuat, kontrol ditransfer ke kode boot_FLASH seharga $ 9FEF.  boot_FLASH menyalin gambar kode boot_EEPROM dari EEPROM ke dalam memori RAM dan mentransfer kontrol ke sana. <br><br>  Sekarang boot_EEPROM mengkonfigurasi UART 9600 8N1, menunggu byte UART, dan tanpa menunggu, mentransfer kontrol ke program aplikasi (kami akan meninggalkan alamat di tempat yang sama $ 9FFE: $ 9FFF). <br><br>  Jika boot_EEPROM menerima byte dengan ukuran dump yang diharapkan untuk memori RAM, dibutuhkan dump berikutnya, menempatkan dump di area memori RAM lain dan mentransfer kontrol ke sana. <br><br>  Selanjutnya, semuanya seperti pada tahap pertama. <br><br><div class="spoiler">  <b class="spoiler_title">File boot_FLASH_EEPROM.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH_EEPROM.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-string"><span class="hljs-string">'eeprom'</span></span> ;  boot_EEPROM dc.b $35, $0D, $52, $32, $35, $0C, $52, $35 dc.b $35, $01, $52, $31, $5A, $27, $16, $72 dc.b $0B, $52, $30, $F8, $C6, $52, $31, $72 dc.b $0B, $52, $30, $FB, $3B, $52, $31, $4A dc.b $26, $F5, $96, $5C, $FC, $CE, $9F, $FE dc.b $2B, $FA, $90, $AE, $42, $7F, $AE, $02 dc.b $7F, $CC, $9F, $F4 segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: jp boot_FLASH_start dc.b $01 ; boot_FLASH_EEPROM ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FEE      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;   main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret ;   EEPROM -&gt; RAM segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FEF <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: ldw X, SP ; Y &lt;- { EEPROM_START + RAM_END} ; Y &lt;- { $4000 + $03FF = $43FF } ldw Y, #$43FF boot_FLASH_copy: ld A, (Y) ld (X), A decw Y decw X jrpl boot_FLASH_copy incw X jp (X) boot_FLASH_exit_address: dc.w main_FLASH_start end ;</code> </pre><br></div></div><br>  Jalankan file <a href="">runSTM8uLoader.bat</a> , tekan tombol reset di papan tulis, bootloader mengirimkan byte 0x01.  Sebuah dump dengan kode dari file main_RAM.hex dikirim ke RAM STM8 melalui UART.  Papan mulai berkedip LED dan mengirimkan byte 0x20 dan 0x02.  Tekan tombol reset lagi.  Program aplikasi dari memori FLASH diluncurkan, LED mulai berkedip lebih cepat dan mengirimkan byte 0x80 dan 0x08. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/582/519/9bc/5825199bc0f6dfaf10b3e297e1339c06.png"></div><br><h4>  Tahap ketiga.  Ukuran kode 18 byte dalam memori FLASH dan 52 byte dalam OPTION Bytes </h4><br>  Tentu saja, kami bergegas dengan memori EEPROM.  Di mana menyimpan sinus dan meja lainnya sekarang?  Dan dengan memori FLASH, tidak semuanya jelas.  Siapa yang memutuskan untuk menyimpan alamat kontrol transfer program aplikasi dalam memori FLASH?  Dan byte yang sama dari versi bootloader umumnya disimpan di dua tempat sekaligus.  Di mana memeras 52 byte yang ditujukan untuk EEPROM? <br><br>  Di sini, litografi membantu kita.  Memori EEPROM terdiri dari 10 blok masing-masing 64 byte.  Menambahkan blok lain ke blok ini, tetapi dengan ukuran yang berbeda, tidak layak secara ekonomi.  STMicroelectronics melakukan hal itu, menambahkan blok 64-byte lainnya, menamakan area ini OPTION Bytes dan menyimpan pengaturan mikrokontroler non-volatil yang penting di sana (untuk STM8S103F3 jumlahnya mencapai 11 byte)  Dan tentu saja, STM lupa menyebutkan bahwa masih ada 53 sel fungsional yang tersisa di area ini.  Rupanya ada banyak model STM8, Anda harus meninggalkan ruang untuk pengaturan penting di masa depan. <br><br>  Bootloader kami hanya mengklaim pada model STM8 tanpa bootloader bawaan.  Oleh karena itu, kami mengambil sel cadangan blok Byte OPSI sejauh ini tidak ada yang melihat.  Benar, ada satu ketidaknyamanan kecil, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tetapi diselesaikan</a> ,.  Seorang programmer konvensional tidak akan memungkinkan Anda untuk menulis informasi ke sel-sel ini. <br><br>  Saat memuat, kontrol ditransfer ke kode copy_boot_FLASH awal pada $ 9FF2.  boot_FLASH mentransfer gambar bootloader boot_OPTION dari area OPTION Bytes ke RAM. <br><br>  boot_OPTION mengkonfigurasi UART 9600 8N1, mengirimkan byte UART dengan versinya, menunggu byte UART dari program host, dan tanpa menunggu 0,2 detik transfer kontrol ke program aplikasi pada alamat yang terletak di pasangan $ 4831: $ 4832. <br><br>  Jika boot_OPTION, setelah mengirim byte dengan versinya, mengambil satu byte dari ukuran dump yang diharapkan, maka itu mengambil dump itu sendiri, menempatkan dump ke dalam memori RAM dan mentransfer kontrol ke sana. <br>  Selanjutnya, semua perawatan terletak pada program di komputer dan dump yang dikirimkannya.  Seharusnya mengirimkan persis dump yang diperlukan untuk menyelesaikan tugas saat ini (baca / hapus / tulis / salin sel memori STM8).  Dumps harus dapat saling menggantikan dalam memori RAM dan mentransfer kontrol ke program aplikasi. <br><br>  Alamat transisi ke aplikasi adalah $ 4831: $ 4832. <br><br><div class="spoiler">  <b class="spoiler_title">Loader dan kode aplikasi untuk dijalankan dalam memori FLASH:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH_OPTION.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_OPTION'</span></span> ;    boot_OPTION dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00 dc.b $FF, $00, $FF, $35, $0D, $52, $32, $35 dc.b $0C, $52, $35, $35, $25, $52, $31, $5A dc.b $27, $16, $72, $0B, $52, $30, $F8, $C6 dc.b $52, $31, $72, $0B, $52, $30, $FB, $3B dc.b $52, $31, $4A, $26, $F5, $96, $5C, $FC dc.b $AE, $80, $04, $2B, $FA, $90, $AE, $42 dc.b $7F, $AE, $02, $7F, $CC, $9F, $F6, $00 segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: ldw X, SP jp boot_FLASH_start ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FF1      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;   main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret ;   OPTION -&gt; RAM segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF2 <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: ; Y &lt;- { OPTION_START + RAM_END} ; Y &lt;- { $4800 + $03FF = $43FF } ldw Y, #$43FF boot_FLASH_copy: ld A, (Y) ld (X), A decw Y decw X jrpl boot_FLASH_copy incw X jp (X) boot_FLASH_exit_address: dc.w main_FLASH_start end ;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Kode aplikasi untuk dieksekusi dalam memori RAM:</b> <div class="spoiler_text"><pre> <code class="hljs 1c">stm8/ TITLE ‚Äúboot_RAM.asm‚Äù MOTOROLA <span class="hljs-meta"><span class="hljs-meta">#include "STM8S103F3P.inc" BYTES segment byte at 0000 'boot_RAM_data' boot_RAM_start: ;  pull-up   (</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   ) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> ,   ,  14  ; ld A, #%01001100 ; [A6 4C] ; cpl A ; [43] ; ld PA_CR1, A ; [C7 50 03] ; ld PB_CR1, A ; [C7 50 08] ; ld PC_CR1, A ; [C7 50 0D] ; ld PD_CR1, A ; [C7 50 12]   PD6(UART1_RX), PD2, PD1 ;  UART1  /   9600,   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  (8 ,   , 1  ) ; mov UART1_BRR2, #0 ; [35 00 52 33] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> Fmaster=16/8=2  9600 mov UART1_BRR1, #13 ; [35 0D 52 32] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> Fmaster=16/8=2  9600 mov UART1_CR2, #%00001100 ; [35 0C 52 35] UART1_CR2.TEN &lt;- 1 UART1_CR2.REN &lt;- 1  / ;   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> UART1 boot_RAM_byte1_tx: mov UART1_DR, #$02 boot_RAM_byte1_wait_tx btjf UART1_SR, #7, boot_RAM_byte1_wait_tx ldw X,#0 ; [AE 00 00] boot_FLASH     X boot_RAM_wait1: decw X ; [5A] jreq boot_RAM_exit1 ; jra boot_RAM_wait1 boot_RAM_exit1: ;   bres PB_DDR,#5 ; bres PB_CR1,#5 ; ;   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> UART1 boot_RAM_byte2_tx: mov UART1_DR, #$20 ; [35 11 52 31] boot_RAM_byte2_wait_tx btjf UART1_SR, #7, boot_RAM_byte2_wait_tx ldw X,#0 ; [AE 00 00] boot_FLASH     X boot_RAM_wait2: decw X ; [5A] jreq boot_RAM_exit2 ; jra boot_RAM_wait2 boot_RAM_exit2: ;   bset PB_DDR,#5 ; bset PB_CR1,#5 ; jra boot_RAM_byte1_tx end</span></span></code> </pre> </div></div><br>  Jalankan file <a href="">runSTM8uLoader.bat</a> , tekan tombol reset di papan tulis, bootloader mengirimkan byte 0x25.  Sebuah dump dengan kode dari file main_RAM.hex dikirim ke RAM STM8 melalui UART.  Papan mulai berkedip LED dan mengirimkan byte 0x20 dan 0x02.  Tekan tombol reset lagi.  Program aplikasi dari memori FLASH diluncurkan, LED mulai berkedip lebih cepat dan mengirimkan byte 0x80 dan 0x08. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/ceb/14d/ab1ceb14d6c5aa19ad29084223298e07.png"></div><br>  Pada tahap terakhir, untuk menulis image bootloader ke area OPTION Bytes, Anda harus menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode ini</a> .  Inti dari metode ini adalah bahwa pertama-tama Anda memerlukan programmer untuk menulis file firmware boot_OPTION_rev25.hex ke memori STM8 FLAH, restart mikrokontroler, area Byte OPSI akan diisi dengan informasi yang diperlukan dan LED akan menyala.  Kemudian lagi, programmer menulis ke file firmware FLASH dari artikel ini <a href="">boot_FLASH_OPTION.hex</a> . <br><br>  Menambahkan "clean" kode bootloader versi 0x14 tanpa kode aplikasi.  Menyebarkan gambar boot_OPTION ke kode sumber.  Komentar yang diperbaiki.  Berbeda dengan versi $ 25, alamat transfer kontrol aplikasi dalam sel FLASH $ 9FFE: $ 9FFFF.  Ukuran dalam FLASH adalah masing-masing 20 byte. <br><div class="spoiler">  <b class="spoiler_title">boot_uC_rev14.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_uC_rev14.asm"</span></span> ; boot_uC = boot_OPTION + boot_FLASH MOTOROLA .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST WORDS ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> ;<span class="hljs-number"><span class="hljs-number">0000</span></span>FF00FF00FF00FF00FF350D523235 ;<span class="hljs-number"><span class="hljs-number">0</span></span>C5235351452315A2716720B5230F8C6 ;<span class="hljs-number"><span class="hljs-number">5231720</span></span>B5230FB3B52314A26F5965CFC ;CE9FFE2BFA90AE427FAE027FCC9FF400 ;    ; $4800    RAM dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF ; OPTION (RAM) ; $480B ($0000)    boot_O boot_O_start: ;  UART <span class="hljs-number"><span class="hljs-number">96008</span></span>N1 Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> ; mov UART1_BRR2, #<span class="hljs-number"><span class="hljs-number">0</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>]     mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>D <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>] ; UART1_CR2.TEN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> UART1_CR2.REN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>  / mov UART1_CR2, #%00001100 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>] ; $4813 ($0008) boot_E_byte1_tx: ;   $14  mov UART1_DR, #$14 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ;    ,     ;      ;  X   ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ; clrw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>F]  X   boot_F ; $4817 ($000C) boot_O_rx_wait_byte: decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jreq boot_O_exit ; [<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>]       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_byte ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> F8] ;   ,   ,  A    ; $481F ($0014) ld A, UART1_DR ; [C6 <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ; $4822 ($0017)    boot_O_rx_wait_block: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> FB] push UART1_DR ; [<span class="hljs-number"><span class="hljs-number">3</span></span>B <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] dec A ; [<span class="hljs-number"><span class="hljs-number">4</span></span>A] ;      A      jrne boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">26</span></span> F5] ; $482D ($0022)      ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] boot_O_exit_to_FLASH: jp (X) ; [FC] ; $4830 ($0025)     boot_O_exit: ldw X, boot_F_exit_address ; [CE <span class="hljs-number"><span class="hljs-number">9</span></span>F FE] jrmi boot_O_exit_to_FLASH ; [<span class="hljs-number"><span class="hljs-number">2</span></span>B FA] ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X &lt; $8000     $0000 ;     EEPROM boot_O_exit_to_EEPROM: ; Y &lt;- { EEPROM_END} ldw Y, #$427F ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] ; X &lt;- { EEPROM_END - EEPROM_START } ;   EEPROM  RAM ldw X, #$027F ; [AE <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] jp boot_F_copy ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F4] ; $483F ($0034) dc.b $00 ;   boot_O_end: ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_vector'</span></span> ;<span class="hljs-number"><span class="hljs-number">96</span></span>CC9FF0 ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] X &lt;- RAM_END jp boot_F_start ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F0] ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FEF      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] ; ******************************************************** ;   boot_FLASH segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF0 <span class="hljs-string"><span class="hljs-string">'boot_F'</span></span> ;<span class="hljs-number"><span class="hljs-number">90</span></span>AE4C0A90F6F7905A5A2AF85CFC8004 boot_F_start: ; Y &lt;- { boot_O_START + RAM_END} { $480B + $03FF = $4C0A } ldw Y, #$4C0A ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>A] ;     ; boot_FLASH, boot_OPTION      boot_F_copy: ld A, (Y) ; [<span class="hljs-number"><span class="hljs-number">90</span></span> F6] ld (X), A ; [F7] decw Y ; [<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>A] decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jrpl boot_F_copy ; [<span class="hljs-number"><span class="hljs-number">2</span></span>A F8]  X(Y) &gt;= RAM_START(boot_O_START) incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] jp (X) ; [FC] boot_F_exit_address: dc.w $8004 ; [<span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; dc.w $0000 ; [<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>] end ;</code> </pre></div></div><br>  Menambahkan kode bootloader "bersih" versi 0x25 tanpa kode aplikasi.  Menyebarkan gambar boot_OPTION ke kode sumber.  Komentar yang diperbaiki.  Berbeda dengan versi $ 14, alamat transfer kontrol aplikasi dalam sel $ 4831: $ 4832 dari area Byte OPSI.  Ukuran yang ditempati dalam memori FLASH, masing-masing, menurun menjadi 18 byte.  Ukuran yang ditempati di area OPTION Bytes tidak berubah (cadangan 52 byte + 1). <br><div class="spoiler">  <b class="spoiler_title">boot_uC_rev14.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_uC_rev25.asm"</span></span> ; boot_uC = boot_OPTION + boot_FLASH MOTOROLA .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST BYTES ; ******************************************************** ;        EEPROM  ; boot_O_exit_address    $0000 (   &lt;$8000) ;       ;          segment byte at <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> main_ram: ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] WORDS ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> ;<span class="hljs-number"><span class="hljs-number">0000</span></span>FF00FF00FF00FF00FF350D523235 ;<span class="hljs-number"><span class="hljs-number">0</span></span>C5235351452315A2716720B5230F8C6 ;<span class="hljs-number"><span class="hljs-number">5231720</span></span>B5230FB3B52314A26F5965CFC ;AE80042BFA90AE427FAE027FCC9FF600 ;    ; $4800    RAM dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF ; OPTION (RAM) ; $480B ($0000)    boot_OPTION boot_O_start: ;  UART <span class="hljs-number"><span class="hljs-number">96008</span></span>N1 Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> ; mov UART1_BRR2, #<span class="hljs-number"><span class="hljs-number">0</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>]     mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>D <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>] ; UART1_CR2.TEN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> UART1_CR2.REN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>  / mov UART1_CR2, #%00001100 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>] ; $4813 ($0008) boot_E_byte1_tx: ;   $14  mov UART1_DR, #$14 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ;    ,     ;      ;  X   ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ; clrw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>F]  X   boot_F ; $4817 ($000C) boot_O_rx_wait_byte: decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jreq boot_O_exit ; [<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>]       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_byte ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> F8] ;   ,   ,  A    ; $481F ($0014) ld A, UART1_DR ; [C6 <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ; $4822 ($0017)    boot_O_rx_wait_block: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> FB] push UART1_DR ; [<span class="hljs-number"><span class="hljs-number">3</span></span>B <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] dec A ; [<span class="hljs-number"><span class="hljs-number">4</span></span>A] ;      A      jrne boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">26</span></span> F5] ; $482D ($0022)      ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] boot_O_exit_to_FLASH: jp (X) ; [FC] ; $4830 ($0025)     boot_O_exit: dc.b $AE ; ldw X, #boot_O_exit_address ; [AE <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; $4831 ($0026) ;      boot_O_exit_address: dc.w main_flash ; [<span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; dc.w main_ram ; [<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>] jrmi boot_O_exit_to_FLASH ; [<span class="hljs-number"><span class="hljs-number">2</span></span>B FA] ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X &lt; $8000     $0000 ;     EEPROM boot_O_exit_to_EEPROM: ; Y &lt;- { EEPROM_END} ldw Y, #$427F ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] ; X &lt;- { EEPROM_END - EEPROM_START } ;   EEPROM  RAM ldw X, #$027F ; [AE <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] jp boot_F_copy ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F4] ; $483F ($0034) dc.b $00 ;   boot_O_end: ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span><span class="hljs-number"><span class="hljs-number">-8003</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_vector'</span></span> ;<span class="hljs-number"><span class="hljs-number">96</span></span>CC9FF2 ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] X &lt;- RAM_END jp boot_F_start ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F2] ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FF1      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> main_flash: ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] ; ******************************************************** ;   boot_FLASH segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF2<span class="hljs-number"><span class="hljs-number">-9</span></span>FFF <span class="hljs-string"><span class="hljs-string">'boot_F'</span></span> ;<span class="hljs-number"><span class="hljs-number">90</span></span>AE4C0A90F6F7905A5A2AF85CFC boot_F_start: ; Y &lt;- { boot_O_START + RAM_END} { $480B + $03FF = $4C0A } ldw Y, #$4C0A ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>A] ;     ; boot_FLASH, boot_OPTION      boot_F_copy: ld A, (Y) ; [<span class="hljs-number"><span class="hljs-number">90</span></span> F6] ld (X), A ; [F7] decw Y ; [<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>A] decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jrpl boot_F_copy ; [<span class="hljs-number"><span class="hljs-number">2</span></span>A F8]  X(Y) &gt;= RAM_START(boot_O_START) incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] jp (X) ; [FC] end ;</code> </pre></div></div><br>  Alamat transfer kontrol aplikasi dalam memori FLASH dapat dipilih dari kisaran $ 8004 ... $ 9FF1.  Untuk gambar kode aplikasi dari memori EEPROM, transfer kontrol hanya dimungkinkan pada alamat $ 0000 dalam memori RAM. <br>  Program host dapat meneruskan semua alamat transfer kontrol sebagai argumen baris perintah kedua. <br>  Kode sumber program host dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ada juga kontak untuk komunikasi yang lebih rinci. <br>  Saya meminta pembaca untuk kritik dan saran yang ditargetkan untuk pengurangan kode lebih lanjut. <br><br>  Saya juga mengusulkan untuk membaca artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Cara mengompres bootloader untuk STM8 ke ukuran 8 byte di memori FLASH"</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417493/">https://habr.com/ru/post/id417493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417481/index.html">Tentang generator di JavaScript ES6, dan mengapa itu opsional untuk mempelajarinya</a></li>
<li><a href="../id417483/index.html">Perbandingan kerangka JS: React, Vue, dan Hyperapp</a></li>
<li><a href="../id417485/index.html">[bookmark] Lembar contekan administrator sistem untuk alat jaringan Linux</a></li>
<li><a href="../id417487/index.html">Tempat di mana Internet Rusia dimulai</a></li>
<li><a href="../id417489/index.html">Laporan Club of Rome 2018, Bab 3.4: ‚ÄúEnergi Terdesentralisasi‚Äù</a></li>
<li><a href="../id417495/index.html">Tim Rusia dan Ukraina menang atas orang Eropa di Final Eropa Kompetisi InnovateFPGA Intel</a></li>
<li><a href="../id417497/index.html">4 tahun Ilmu Data di Grup Media Schibsted</a></li>
<li><a href="../id417501/index.html">Lifehacks memproduksi papan dua lapis (LUT)</a></li>
<li><a href="../id417503/index.html">Apa yang harus diingat pengembang web untuk melakukan SEO-Feng Shui</a></li>
<li><a href="../id417505/index.html">Intel Merilis Patch untuk Kerentanan Firmware ME Baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>