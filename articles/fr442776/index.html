<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛅 🖖🏾 👩🏾‍⚕️ Index dans PostgreSQL - 3 (Hash) 🦏 🏻 ⚜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le premier article décrit le moteur d'indexation de PostgreSQL , le second traite de l'interface des méthodes d'accès , et maintenant nous sommes prêt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 3 (Hash)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442776/">  Le premier article décrit le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation de PostgreSQL</a> , le second traite de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'interface des méthodes d'accès</a> , et maintenant nous sommes prêts à discuter de types spécifiques d'index.  Commençons par l'index de hachage. <br><br><h1>  Hash </h1><br><h2>  La structure </h2><br><h3>  Théorie générale </h3><br>  De nombreux langages de programmation modernes incluent des tables de hachage comme type de données de base.  À l'extérieur, une table de hachage ressemble à un tableau standard indexé avec n'importe quel type de données (par exemple, une chaîne) plutôt qu'avec un nombre entier.  L'index de hachage dans PostgreSQL est structuré de la même manière.  Comment ça marche? <br><br>  En règle générale, les types de données ont de très grandes plages de valeurs autorisées: combien de chaînes différentes peut-on potentiellement envisager dans une colonne de type "texte"?  Dans le même temps, combien de valeurs différentes sont réellement stockées dans une colonne de texte d'une table?  Habituellement, pas beaucoup d'entre eux. <br><br>  L'idée du hachage est d'associer un petit nombre (de 0 à <em>N</em> -1, <em>N</em> valeurs au total) à une valeur de n'importe quel type de données.  Une telle association est appelée <em>fonction de hachage</em> .  Le nombre obtenu peut être utilisé comme index d'un tableau régulier où les références aux lignes de table (TID) seront stockées.  Les éléments de ce tableau sont appelés <em>compartiments de table de hachage</em> - un compartiment peut stocker plusieurs TID si la même valeur indexée apparaît dans différentes lignes. <br><br>  Plus une fonction de hachage répartit uniformément les valeurs source par compartiments, mieux c'est.  Mais même une bonne fonction de hachage produit parfois des résultats égaux pour différentes valeurs de source - c'est ce qu'on appelle <em>une collision</em> .  Ainsi, un compartiment peut stocker des TID correspondant à différentes clés, et par conséquent, les TID obtenus à partir de l'index doivent être revérifiés. <br><a name="habracut"></a><br>  Par exemple: à quelle fonction de hachage pour les chaînes peut-on penser?  Soit le nombre de compartiments à 256. Ensuite, par exemple pour un numéro de compartiment, nous pouvons prendre le code du premier caractère (en supposant un codage de caractères à un octet).  Est-ce une bonne fonction de hachage?  Évidemment, non: si toutes les chaînes commencent par le même caractère, toutes entreront dans un seul compartiment, donc l'uniformité est hors de question, toutes les valeurs devront être revérifiées, et le hachage n'aura aucun sens.  Et si nous résumons les codes de tous les caractères modulo 256?  Ce sera beaucoup mieux, mais loin d'être idéal.  Si vous êtes intéressé par les fonctions internes d'une telle fonction de hachage dans PostgreSQL, examinez la définition de hash_any () dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hashfunc.c</a> . <br><br><h3>  Structure de l'index </h3><br>  Revenons à l'index de hachage.  Pour une valeur d'un certain type de données (une clé d'index), notre tâche consiste à trouver rapidement le TID correspondant. <br><br>  Lors de l'insertion dans l'index, calculons la fonction de hachage pour la clé.  Les fonctions de hachage dans PostgreSQL renvoient toujours le type "entier", qui se situe dans une plage de 2 <sup>32 à</sup> 4 milliards de valeurs.  Le nombre de compartiments est initialement égal à deux et augmente dynamiquement pour s'adapter à la taille des données.  Le numéro de compartiment peut être calculé à partir du code de hachage à l'aide de l'arithmétique des bits.  Et c'est le seau où nous mettrons notre TID. <br><br>  Mais cela est insuffisant car les TID correspondant à différentes clés peuvent être placés dans le même compartiment.  Que ferons-nous?  Il est possible de stocker la valeur source de la clé dans un compartiment, en plus du TID, mais cela augmenterait considérablement la taille de l'index.  Pour économiser de l'espace, au lieu d'une clé, le compartiment stocke le code de hachage de la clé. <br><br>  Lors de la recherche dans l'index, nous calculons la fonction de hachage pour la clé et obtenons le numéro de compartiment.  Il reste maintenant à parcourir le contenu du compartiment et à renvoyer uniquement les TID correspondants avec les codes de hachage appropriés.  Cela se fait efficacement car les paires "code de hachage - TID" stockées sont ordonnées. <br><br>  Cependant, deux clés différentes peuvent arriver non seulement pour entrer dans un seul compartiment, mais aussi pour avoir les mêmes codes de hachage à quatre octets - personne n'a éliminé la collision.  Par conséquent, la méthode d'accès demande au moteur d'indexation général de vérifier chaque TID en revérifiant la condition dans la ligne du tableau (le moteur peut le faire avec la vérification de la visibilité). <br><br><h3>  Mappage des structures de données aux pages </h3><br>  Si nous regardons un index tel qu'il est vu par le gestionnaire de cache de tampon plutôt que du point de vue de la planification et de l'exécution des requêtes, il s'avère que toutes les informations et toutes les lignes d'index doivent être regroupées dans des pages.  Ces pages d'index sont stockées dans le cache tampon et en sont supprimées exactement de la même manière que les pages de table. <br><br><img src="https://habrastorage.org/web/aa7/83b/c8c/aa783bc8cbfc4be49baec029339eb539.png"><br><br>  L'index de hachage, comme indiqué sur la figure, utilise quatre types de pages (rectangles gris): <br><br><ul><li>  Meta page - numéro de page zéro, qui contient des informations sur ce qui se trouve à l'intérieur de l'index. </li><li>  Pages de compartiment - pages principales de l'index, qui stockent les données sous forme de paires "code de hachage - TID". </li><li>  Pages de débordement - structurées de la même manière que les pages de compartiment et utilisées lorsqu'une page est insuffisante pour un compartiment. </li><li>  Pages bitmap - qui gardent une trace des pages de débordement qui sont actuellement claires et peuvent être réutilisées pour d'autres compartiments. </li></ul><br>  Les flèches vers le bas commençant aux éléments de la page d'index représentent les TID, c'est-à-dire les références aux lignes de table. <br><br>  Chaque fois que l'index augmente, PostgreSQL crée instantanément deux fois plus de compartiments (et donc de pages) que la dernière fois.  Pour éviter l'allocation de ce nombre potentiellement important de pages à la fois, la version 10 a augmenté la taille plus facilement.  Quant aux pages de débordement, elles sont allouées au fur et à mesure des besoins et sont suivies dans des pages bitmap, qui sont également allouées au fur et à mesure des besoins. <br><br>  Notez que l'indice de hachage ne peut pas diminuer en taille.  Si nous supprimons certaines des lignes indexées, les pages une fois allouées ne seront pas renvoyées au système d'exploitation, mais ne seront réutilisées pour de nouvelles données qu'après VACUUMING.  La seule option pour diminuer la taille de l'index est de le reconstruire à partir de zéro à l'aide de la commande REINDEX ou VACUUM FULL. <br><br><h2>  Exemple </h2><br>  Voyons comment est créé l'index de hachage.  Pour éviter de concevoir nos propres tables, nous utiliserons désormais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la base</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">données</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démonstration</a> du transport aérien, et cette fois-ci nous considérerons la table des vols. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> hash(flight_no);</code> </pre> <pre> <code class="plaintext hljs">WARNING: hash indexes are not WAL-logged and their use is discouraged CREATE INDEX</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0001'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (flight_no = 'PG0001'::bpchar) -&gt; Bitmap Index Scan on flights_flight_no_idx Index Cond: (flight_no = 'PG0001'::bpchar) (4 rows)</code> </pre><br>  L'inconvénient de l'implémentation actuelle de l'index de hachage est que les opérations avec l'index ne sont pas enregistrées dans le journal d'écriture anticipée (dont PostgreSQL avertit lorsque l'index est créé).  Par conséquent, les index de hachage ne peuvent pas être récupérés après l'échec et ne participent pas aux réplications.  En outre, l'indice de hachage est bien inférieur à "B-tree" en termes de polyvalence, et son efficacité est également discutable.  Il n'est donc plus possible d'utiliser de tels index. <br><br>  Cependant, cela changera dès cet automne (2017) une fois la version 10 de PostgreSQL publiée.  Dans cette version, l'index de hachage a finalement pris en charge le journal d'écriture anticipée;  en outre, l'allocation de mémoire a été optimisée et le travail simultané rendu plus efficace. <br><br><blockquote>  C'est vrai.  Depuis PostgreSQL 10, les index de hachage ont une prise en charge complète et peuvent être utilisés sans restrictions.  L'avertissement ne s'affiche plus. <br></blockquote><br><h2>  Hashing sémantique </h2><br>  Mais pourquoi l'index de hachage a-t-il survécu presque depuis la naissance même de PostgreSQL jusqu'à 9.6 étant inutilisable?  Le fait est que le SGBD utilise largement l'algorithme de hachage (en particulier, pour les jointures et les regroupements de hachage), et le système doit savoir quelle fonction de hachage s'applique à quels types de données.  Mais cette correspondance n'est pas statique et ne peut pas être définie une fois pour toutes, car PostgreSQL autorise l'ajout de nouveaux types de données à la volée.  Et c'est une méthode d'accès par hachage, où cette correspondance est stockée, représentée comme une association de fonctions auxiliaires avec des familles d'opérateurs. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_name, amproc.amproc::<span class="hljs-type"><span class="hljs-type">regproc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_procedure <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amproc amproc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amproc.amprocfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_procedure;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_procedure --------------------+-------------------- abstime_ops | hashint4 aclitem_ops | hash_aclitem array_ops | hash_array bool_ops | hashchar ...</code> </pre><br>  Bien que ces fonctions ne soient pas documentées, elles peuvent être utilisées pour calculer le code de hachage pour une valeur du type de données approprié.  Par exemple, la fonction "hashtext" si utilisée pour la famille d'opérateurs "text_ops": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'one'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 127722028 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'two'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 345620034 (1 row)</code> </pre><br><h2>  Propriétés </h2><br>  Examinons les propriétés de l'index de hachage, où cette méthode d'accès fournit au système des informations sur lui-même.  Nous avons fourni des requêtes la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernière fois</a> .  Maintenant, nous n'irons pas au-delà des résultats: <br><br><pre> <code class="plaintext hljs"> name | pg_indexam_has_property ---------------+------------------------- can_order | f can_unique | f can_multi_col | f can_exclude | t name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | t name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Une fonction de hachage ne conserve pas la relation d'ordre: si la valeur d'une fonction de hachage pour une clé est plus petite que pour l'autre clé, il est impossible de tirer des conclusions sur la façon dont les clés elles-mêmes sont ordonnées.  Par conséquent, en général, l'index de hachage peut prendre en charge la seule opération "égale": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_name, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_operator ---------------+---------------------- abstime_ops | =(abstime,abstime) aclitem_ops | =(aclitem,aclitem) array_ops | =(anyarray,anyarray) bool_ops | =(boolean,boolean) ...</code> </pre><br>  Par conséquent, l'index de hachage ne peut pas renvoyer les données ordonnées ("can_order", "orderable").  L'index de hachage ne manipule pas les NULL pour la même raison: l'opération "égal" n'a pas de sens pour NULL ("search_nulls"). <br><br>  Étant donné que l'index de hachage ne stocke pas les clés (mais uniquement leurs codes de hachage), il ne peut pas être utilisé pour l'accès uniquement à l'index ("renvoyable"). <br><br>  Cette méthode d'accès ne prend pas non plus en charge les index multi-colonnes ("can_multi_col"). <br><br><h2>  Internes </h2><br>  À partir de la version 10, il sera possible de regarder dans les index internes de hachage via l'extension " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pageinspect</a> ".  Voici à quoi cela ressemblera: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  La méta page (on obtient le nombre de lignes dans l'index et le nombre maximal de bucket utilisé): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- metapage (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ntuples, maxbucket <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> ntuples | maxbucket ---------+----------- 33121 | 127 (1 row)</code> </pre><br>  Une page bucket (on obtient le nombre de tuples vivants et tuples morts, c'est-à-dire ceux qui peuvent être aspirés): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- bucket (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> live_items, dead_items <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_page_stats(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> live_items | dead_items ------------+------------ 407 | 0 (1 row)</code> </pre><br>  Et ainsi de suite.  Mais il est à peine possible de comprendre la signification de tous les champs disponibles sans examiner le code source.  Si vous le souhaitez, vous devriez commencer par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">README</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez à lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442776/">https://habr.com/ru/post/fr442776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442760/index.html">Un article sur la façon dont CommVault sauvegarde PostgreSQL</a></li>
<li><a href="../fr442762/index.html">Stagiaire Vasya et ses histoires sur l'API idempotency</a></li>
<li><a href="../fr442764/index.html">Recueil sur la gestion des produits. Ce qui excite les produits et les spécialistes du marketing en 2019</a></li>
<li><a href="../fr442770/index.html">Présentation des scanners de codes-barres JavaScript</a></li>
<li><a href="../fr442772/index.html">Mathématiques pour Data Scientist: Sections nécessaires</a></li>
<li><a href="../fr442778/index.html">Learning Go: une sélection de reportages vidéo</a></li>
<li><a href="../fr442780/index.html">Idées fausses les plus courantes en physique populaire</a></li>
<li><a href="../fr442782/index.html">VShard - mise à l'échelle horizontale dans Tarantool</a></li>
<li><a href="../fr442784/index.html">Détournement BGP en ajoutant AS victime à AS-SET de l'attaquant</a></li>
<li><a href="../fr442786/index.html">7 conseils utiles pour utiliser la pièce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>