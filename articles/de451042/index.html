<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔧 🙍 👨‍👩‍👦 Grundlagen des Datenbankdesigns - PostgreSQL-, Cassandra- und MongoDB-Vergleich ⛸️ 🛫 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde. Bevor wir in den zweiten Teil der Mai-Ferien aufbrechen, teilen wir Ihnen das Material mit, das wir am Vorabend des Starts eines neuen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen des Datenbankdesigns - PostgreSQL-, Cassandra- und MongoDB-Vergleich</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/451042/">  Hallo Freunde.  Bevor wir in den zweiten Teil der Mai-Ferien aufbrechen, teilen wir Ihnen das Material mit, das wir am Vorabend des Starts eines neuen Streams mit der Rate von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Relational DBMS“ übersetzt haben</a> . <br><br><img src="https://habrastorage.org/webt/tg/jk/pk/tgjkpk23xr333l_ee0lddnylafa.png"><br><br>  Anwendungsentwickler verbringen viel Zeit damit, mehrere Betriebsdatenbanken zu vergleichen, um diejenige auszuwählen, die für ihre beabsichtigte Arbeitslast am besten geeignet ist.  Zu den Anforderungen können eine vereinfachte Datenmodellierung, Transaktionsgarantien, Lese- / Schreibleistung, horizontale Skalierung und Fehlertoleranz gehören.  Traditionell beginnt die Auswahl mit einer Datenbankkategorie, SQL oder NoSQL, da jede Kategorie eine klare Reihe von Kompromissen bietet.  Eine hohe Leistung in Bezug auf niedrige Latenz und hohen Durchsatz wird normalerweise als Kompromissanforderung angesehen und ist daher für jede Datenbank in der Stichprobe erforderlich. <a name="habracut"></a><br><br>  Der Zweck dieses Artikels besteht darin, Anwendungsentwicklern dabei zu helfen, im Kontext der Modellierung von Anwendungsdaten die richtige Wahl zwischen SQL und NoSQL zu treffen.  Wir werden uns eine SQL-Datenbank ansehen, nämlich PostgreSQL und zwei NoSQL-Datenbanken - Cassandra und MongoDB -, um über die Grundlagen des Datenbankdesigns zu sprechen, z. B. das Erstellen, Auffüllen von Tabellen, Lesen von Daten aus der Tabelle und Löschen von Tabellen.  Im nächsten Artikel werden wir uns definitiv mit Indizes, Transaktionen, JOINs, TTL-Direktiven und dem JSON-basierten Datenbankdesign befassen. <br><br>  <b>Was ist der Unterschied zwischen SQL und NoSQL?</b> <br><br><blockquote>  SQL-Datenbanken erhöhen die Anwendungsflexibilität durch ACID-Transaktionsgarantien sowie ihre Fähigkeit, Daten mithilfe von JOINs auf unerwartete Weise zusätzlich zu vorhandenen normalisierten relationalen Datenbankmodellen abzufragen. </blockquote><br>  Aufgrund ihrer monolithischen Architektur / Einzelknotenarchitektur und der Verwendung eines Master-Slave-Replikationsmodells für Redundanz weisen herkömmliche SQL-Datenbanken keine zwei wichtigen Merkmale auf - lineare Skalierbarkeit des Datensatzes (d. H. Automatische Aufteilung in mehrere Knoten) und automatischer Datenverlust / Null.  Dies bedeutet, dass die empfangene Datenmenge den maximalen Schreibdurchsatz eines Knotens nicht überschreiten darf.  Darüber hinaus sollte ein vorübergehender Datenverlust bei der Fehlertoleranz berücksichtigt werden (in einer Architektur ohne gemeinsame Nutzung von Ressourcen).  Hier müssen Sie berücksichtigen, dass die letzten Commits noch nicht in der Slave-Kopie berücksichtigt wurden.  Updates ohne Ausfallzeiten sind auch in SQL-Datenbanken schwer zu erreichen. <br><br>  NoSQL-Datenbanken werden typischerweise von Natur aus verteilt, d.h.  In ihnen werden Daten in Abschnitte unterteilt und auf mehrere Knoten verteilt.  Sie erfordern eine Denormalisierung.  Dies bedeutet, dass die eingegebenen Daten auch mehrmals kopiert werden müssen, um auf bestimmte von Ihnen gesendete Anfragen zu antworten.  Das übergeordnete Ziel besteht darin, eine hohe Leistung zu erzielen, indem die Anzahl der beim Lesen verfügbaren Shards verringert wird.  Es folgt der Aussage, dass Sie in NoSQL Ihre Abfragen modellieren müssen, während Sie in SQL Ihre Daten modellieren müssen. <br><br><blockquote> NoSQL konzentriert sich auf die Erzielung einer hohen Leistung in einem verteilten Cluster. Dies ist der Hauptgrund für viele Kompromisse beim Datenbankdesign, zu denen Transaktionsverlust-ACIDs, JOINs und konsistente globale Sekundärindizes gehören. </blockquote><br>  Es wird angenommen, dass NoSQL-Datenbanken zwar eine lineare Schreibskalierbarkeit und eine hohe Fehlertoleranz bieten, der Verlust von Transaktionsgarantien sie jedoch für geschäftskritische Daten ungeeignet macht. <br><br>  Die folgende Tabelle zeigt, wie sich die Datenmodellierung in NoSQL von SQL unterscheidet. <br><br><img src="https://habrastorage.org/webt/sv/6k/or/sv6kor2fwminli9ywljf1hf5h34.png"><br><br>  <b>SQL und NoSQL: Warum werden beide benötigt?</b> <br><br>  Reale Anwendungen mit einer großen Anzahl von Benutzern wie Amazon.com, Netflix, Uber und Airbnb führen komplexe, vielfach sortierte Aufgaben aus.  Beispielsweise muss eine E-Commerce-Anwendung wie Amazon.com leichte, hochkritische Daten wie Informationen zu Benutzern, Produkten, Bestellungen, Rechnungen sowie schwere, aber weniger sensible Daten wie Produktbewertungen und Supportnachrichten speichern , Benutzeraktivität, Benutzerbewertungen und Empfehlungen.  Natürlich basieren diese Anwendungen auf mindestens einer SQL-Datenbank zusammen mit mindestens einer NoSQL-Datenbank.  In interregionalen und globalen Systemen fungiert die NoSQL-Datenbank als geoverteilter Cache für Daten, die in einer vertrauenswürdigen Quelle, einer SQL-Datenbank, gespeichert sind und in einer bestimmten Region ausgeführt werden. <br><br>  <b>Wie kombiniert YugaByte DB SQL und NoSQL?</b> <br><br>  YugaByte DB basiert auf einer protokollorientierten Mixed-Storage-Engine, automatischem Sharding, Sharding verteilter Konsensreplikation und verteilten ACID-Transaktionen (inspiriert von Google Spanner) und ist die erste Open-Source-Datenbank der Welt, die gleichzeitig mit NoSQL (Cassandra &amp; Redis) kompatibel ist ) und SQL (PostgreSQL).  Wie in der folgenden Tabelle gezeigt, fügt YSQL, die Cassandra-kompatible YugaByte DB-API, den NoSQL-APIs die Konzepte von ACID-Transaktionen mit einem und mehreren Schlüsseln und globalen Sekundärindizes hinzu und eröffnet damit die Ära der transaktionalen NoSQL-Datenbanken.  Darüber hinaus erweitert YSQL, eine PostgreSQL-kompatible YugaByte DB-API, die SQL-API um den Begriff der linearen Schreibskalierung und der automatischen Fehlertoleranz und führt verteilte SQL-Datenbanken in die Welt ein.  Da es sich bei der YugaByte DB-Datenbank im Wesentlichen um eine Transaktionsdatenbank handelt, kann die NoSQL-API jetzt im Kontext geschäftskritischer Daten verwendet werden. <br><br><img src="https://habrastorage.org/webt/ln/1a/_9/ln1a_9ouduu15ccxhvud1nssmme.png"><br><br>  Wie bereits im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Einführung in YSQL: Eine PostgreSQL-kompatible verteilte SQL-API für YugaByte DB“ erwähnt</a> , hängt die Wahl zwischen SQL oder NoSQL in YugaByte DB vollständig von den Merkmalen der Hauptarbeitslast ab: <br><br><ul><li>  Wenn die Hauptauslastung Mehrschlüsseloperationen mit JOINs sind, sollten Sie bei der Auswahl von YSQL verstehen, dass Ihre Schlüssel auf mehrere Knoten verteilt werden können, was zu einer höheren Verzögerung und / oder einem geringeren Durchsatz als in NoSQL führt. </li><li>  Wählen Sie andernfalls eine der beiden NoSQL-APIs aus, und berücksichtigen Sie dabei, dass Sie eine bessere Leistung erzielen, wenn Abfragen von jeweils einem Knoten ausgeführt werden.  YugaByte DB kann als einzelne Betriebsdatenbank für sehr komplexe Anwendungen dienen, in denen Sie mehrere Workloads gleichzeitig verwalten müssen. </li></ul><br>  Das Datenmodellierungslabor im nächsten Abschnitt basiert im Gegensatz zu den Quelldatenbanken auf YugaByte DB-Datenbanken, die mit PostgreSQL und Cassandra API kompatibel sind.  Dieser Ansatz betont die einfache Interaktion mit zwei verschiedenen APIs (an zwei verschiedenen Ports) desselben Datenbankclusters, im Gegensatz zur Verwendung völlig unabhängiger Cluster aus zwei verschiedenen Datenbanken. <br><br>  In den folgenden Abschnitten werden wir uns mit dem Datenmodellierungslabor treffen, um die Unterschiede und einige gemeinsame Merkmale der betreffenden Datenbanken zu veranschaulichen. <br><br>  <b>Datenmodellierungslabor</b> <br><br>  <b>Datenbankinstallation</b> <br><br>  Angesichts des Schwerpunkts auf dem Entwerfen eines Datenmodells (anstelle komplexer Bereitstellungsarchitekturen) werden wir die Datenbanken in Docker-Containern auf dem lokalen Computer installieren und dann mit ihnen über die entsprechenden Befehlszeilen-Shells interagieren. <br><br>  <b>Kompatibel mit PostgreSQL &amp; Cassandra, YugaByte DB-Datenbank</b> <br><br><pre><code class="sql hljs">mkdir ~/yugabyte &amp;&amp; cd ~/yugabyte wget https://downloads.yugabyte.com/yb-docker-ctl &amp;&amp; chmod +x yb-docker-ctl docker pull yugabytedb/yugabyte ./yb-docker-ctl <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-comment"><span class="hljs-comment">--enable_postgres</span></span></code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">docker run <span class="hljs-comment"><span class="hljs-comment">--name my-mongo -d mongo:latest</span></span></code> </pre> <br>  <b>Befehlszeilenzugriff</b> <br><br>  Stellen Sie über die Befehlszeilen-Shell für die entsprechenden APIs eine Verbindung zu den Datenbanken her. <br><br>  <b>PostgreSQL</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">psql</a> ist eine Befehlszeilen-Shell für die Interaktion mit PostgreSQL.  Zur Vereinfachung der Verwendung wird YugaByte DB mit psql direkt im Ordner bin geliefert. <br><br><pre> <code class="sql hljs">docker exec -it yb-postgres-n1 /home/yugabyte/postgres/bin/psql -p 5433 -U postgres</code> </pre> <br>  <b>Cassandra</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cqlsh</a> ist eine Befehlszeilen-Shell für die Interaktion mit Cassandra und seinen kompatiblen Datenbanken über CQL (Cassandra Query Language).  Zur Vereinfachung der Verwendung enthält YugaByte DB <code>cqlsh</code> im <code>bin</code> . <br><br>  Beachten Sie, dass CQL von SQL inspiriert wurde und ähnliche Konzepte wie Tabellen, Zeilen, Spalten und Indizes hat.  Als NoSQL-Sprache werden jedoch bestimmte Einschränkungen hinzugefügt, von denen die meisten auch in anderen Artikeln behandelt werden. <br><br><pre> <code class="sql hljs">docker exec -it yb-tserver-n1 /home/yugabyte/bin/cqlsh</code> </pre> <br>  <b>Mongodb</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mongo</a> ist eine Befehlszeilen-Shell für die Interaktion mit MongoDB.  Es befindet sich im bin-Verzeichnis der MongoDB-Installation. <br><br><pre> <code class="sql hljs">docker exec -it my-mongo bash cd bin mongo</code> </pre> <br>  <b>Tabellenerstellung</b> <br><br>  Jetzt können wir mit der Datenbank interagieren, um verschiedene Operationen über die Befehlszeile auszuführen.  Beginnen wir mit der Erstellung einer Tabelle, in der Informationen zu Songs gespeichert sind, die von verschiedenen Künstlern geschrieben wurden.  Diese Songs können Teil eines Albums sein.  Auch optionale Attribute für den Song - Erscheinungsjahr, Preis, Genre und Bewertung.  Wir müssen zusätzliche Attribute berücksichtigen, die möglicherweise in Zukunft über das Feld "Tags" benötigt werden.  Es kann halbstrukturierte Daten als Schlüssel-Wert-Paare speichern. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>), CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Das Erstellen einer Tabelle in Cassandra ist PostgreSQL sehr ähnlich.  <b>Einer der Hauptunterschiede ist das Fehlen von Integritätsbeschränkungen (z. B. NICHT NULL). Dies liegt jedoch in der Verantwortung der Anwendung und nicht der NoSQL-Datenbank</b> .  Der Primärschlüssel besteht aus einem Abschnittsschlüssel (Artist-Spalte im folgenden Beispiel) und einer Reihe von Clustering-Spalten (SongTitle-Spalte im folgenden Beispiel).  Der Partitionsschlüssel bestimmt, in welcher Partition / in welchem ​​Shard die Zeile platziert werden soll, und die Clustering-Spalten geben an, wie die Daten innerhalb des aktuellen Shards organisiert werden sollen. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> KEYSPACE myapp; <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> myapp; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Mongodb</b> <br><br>  MongoDB organisiert die Daten in Datenbanken (Database) (ähnlich wie Keyspace in Cassandra), in denen Sammlungen (Collections) (ähnlich wie Tabellen) vorhanden sind, die Dokumente (Documents) enthalten (ähnlich wie Zeilen in einer Tabelle).  MongoDB erfordert grundsätzlich nicht die Definition des ursprünglichen Schemas.  Der unten gezeigte Befehl <i>"Datenbank verwenden"</i> erstellt beim ersten Aufruf eine Instanz der Datenbank und ändert den Kontext für die neu erstellte Datenbank.  Auch Sammlungen müssen nicht explizit erstellt werden, sondern werden automatisch erstellt, einfach wenn Sie das erste Dokument zu einer neuen Sammlung hinzufügen.  Beachten Sie, dass MongoDB standardmäßig die Testdatenbank verwendet. Daher wird standardmäßig jede Operation auf Sammlungsebene ohne Angabe einer bestimmten Datenbank ausgeführt. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase;</code> </pre> <br>  <b>Abrufen von PostgreSQL-Tabelleninformationen</b> <br><br><pre> <code class="sql hljs">\d Music Table "public.music" Column | Type | Collation | Nullable | Default <span class="hljs-comment"><span class="hljs-comment">--------------+-----------------------+-----------+----------+-------- artist | character varying(20) | | not null | songtitle | character varying(30) | | not null | albumtitle | character varying(25) | | | year | integer | | | price | double precision | | | genre | character varying(10) | | | criticrating | double precision | | | tags | text | | | Indexes: "music_pkey" PRIMARY KEY, btree (artist, songtitle)</span></span></code> </pre> <br>  <b>Cassandra</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DESCRIBE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MUSIC; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> myapp.music ( artist <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, songtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, albumtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, price <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, genre <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, tags <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (artist, songtitle) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (songtitle <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> default_time_to_live = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> transactions = {<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>};</code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> collections;</code> </pre> <br>  <b>Daten in eine PostgreSQL-Tabelle posten</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span>, Price, Genre, CriticRating, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'Somewhat Famous'</span></span>, <span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">2.14</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">7.8</span></span>, <span class="hljs-string"><span class="hljs-string">'{"Composers": ["Smith", "Jones", "Davis"],"LengthInSeconds": 214}'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, CriticRating) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey Now'</span></span>, <span class="hljs-number"><span class="hljs-number">1.98</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">8.4</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">2.47</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'{"radioStationsPlaying": ["KHCR", "KBQX", "WTNR", "WJJH"], "tourDates": { "Seattle": "20150625", "Cleveland": "20150630"}, "rotation": Heavy}'</span></span> );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Im Allgemeinen sieht der <code>INSERT</code> Ausdruck in Cassandra dem in PostgreSQL sehr ähnlich.  Es gibt jedoch einen großen Unterschied in der Semantik.  In Cassandra ist <code>INSERT</code> eine <code>UPSERT</code> Operation, bei der die letzten Werte zur Zeichenfolge hinzugefügt werden, falls die Zeichenfolge bereits vorhanden ist. <br><blockquote>  Die Dateneingabe ähnelt der obigen <code>INSERT</code> von PostgreSQL <code>INSERT</code> </blockquote><br>  <b>Mongodb</b> <br><br>  Obwohl MongoDB wie Cassandra eine NoSQL-Datenbank ist, hat ihre Einfügeoperation nichts mit semantischem Verhalten in Cassandra zu tun.  In MongoDB verfügt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">insert ()</a> nicht über <code>UPSERT</code> Funktionen, <code>UPSERT</code> es wie PostgreSQL aussieht.  Durch Hinzufügen von Standarddaten ohne <code>_idspecified</code> wird der Sammlung ein neues Dokument <code>_idspecified</code> . <br><br> <code>db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "Call Me Today", <br> albumTitle: "Somewhat Famous", <br> year: 2015, <br> price: 2.14, <br> genre: "Country", <br> tags: { <br> Composers: ["Smith", "Jones", "Davis"], <br> LengthInSeconds: 214 <br> } <br> } <br> ); <br> db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "My Dog Spot", <br> albumTitle: "Hey Now", <br> price: 1.98, <br> genre: "Country", <br> criticRating: 8.4 <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Look Out, World", <br> albumTitle:"The Buck Starts Here", <br> price: 0.99, <br> genre: "Rock" <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Still In Love", <br> albumTitle:"The Buck Starts Here", <br> price: 2.47, <br> genre: "Rock", <br> tags: { <br> radioStationsPlaying:["KHCR", "KBQX", "WTNR", "WJJH"], <br> tourDates: { <br> Seattle: "20150625", <br> Cleveland: "20150630" <br> }, <br> rotation: "Heavy" <br> } <br> } <br> );</code> <br> <br>  <b>Tabellenabfrage</b> <br><br>  Der vielleicht bedeutendste Unterschied zwischen SQL und NoSQL im Hinblick auf das Abfragedesign ist die Verwendung der <code>FROM</code> und <code>WHERE</code> Anweisungen.  Mit SQL können Sie mehrere Tabellen nach einer <code>FROM</code> auswählen, und eine <code>WHERE</code> kann beliebig komplex sein (einschließlich <code>JOIN</code> Operationen zwischen Tabellen).  NoSQL neigt jedoch dazu, <code>FROM</code> strikt einzuschränken und nur mit einer angegebenen Tabelle zu arbeiten. In <code>WHERE</code> muss immer der Primärschlüssel angegeben werden.  Dies ist auf den Wunsch zurückzuführen, die Leistung von NoSQL zu verbessern, über den wir bereits gesprochen haben.  Dieser Wunsch führt zu jeder möglichen Reduzierung einer tabellen- und schlüsselübergreifenden Interaktion.  Dies kann zu einer großen Verzögerung der Kommunikation zwischen Knoten führen, wenn auf eine Anfrage geantwortet wird, und wird daher im Prinzip am besten vermieden.  Cassandra verlangt beispielsweise, dass Abfragen auf bestimmte Operatoren (nur <code>=, IN, &lt;, &gt;, =&gt;, &lt;=</code> sind zulässig) für Partitionsschlüssel beschränkt sind, außer wenn ein Sekundärindex angefordert wird (hier ist nur der Operator = zulässig). <br><br>  <b>PostgreSQL</b> <br><br>  Im Folgenden werden drei Beispiele für Abfragen aufgeführt, die von einer SQL-Datenbank problemlos ausgeführt werden können. <br><br><ul><li>  Drucken Sie alle Songs des Künstlers; </li><li>  Drucken Sie alle Songs des Künstlers, die dem ersten Teil des Namens entsprechen. </li><li>  Listen Sie alle Songs des Künstlers auf, die ein bestimmtes Wort im Titel haben und einen Preis von weniger als 1,00 haben. </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'Call%'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%Today%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Von den oben genannten PostgreSQL-Abfragen funktioniert nur die erste in Cassandra unverändert, da die <code>LIKE</code> Anweisung nicht auf Clustering-Spalten wie <code>SongTitle</code> .  In diesem Fall sind nur Operatoren <code>=</code> und <code>IN</code> zulässig. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Mongodb</b> <br><br>  Wie in den vorherigen Beispielen gezeigt, ist die Hauptmethode zum Erstellen von Abfragen in MongoDB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">db.collection.find ()</a> .  Diese Methode enthält explizit den Namen der Sammlung ( <code>music</code> im folgenden Beispiel), sodass die Anforderung mehrerer Sammlungen verboten ist. <br><br><pre> <code class="sql hljs">db.music.find( { artist: "No One You Know" } ); db.music.find( { artist: "No One You Know", songTitle: /<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>/ } );</code> </pre> <br>  <b>Lesen Sie alle Tabellenzeilen</b> <br><br>  Das Lesen aller Zeilen ist nur ein Sonderfall der zuvor untersuchten Abfragevorlage. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music;</code> </pre> <br><br>  <b>Cassandra</b> <br><br><blockquote>  Ähnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br><br>  Mongodb <br><br><pre> <code class="sql hljs">db.music.find( {} );</code> </pre> <br>  <b>Bearbeiten von Daten in einer Tabelle</b> <br><br>  <b>PostgreSQL</b> <br><br>  PostgreSQL bietet eine <code>UPDATE</code> zum Ändern von Daten.  Es verfügt nicht über <code>UPSERT</code> Funktionen, daher <code>UPSERT</code> die Ausführung dieser Anweisung fehl, wenn sich die Zeile nicht mehr in der Datenbank befindet. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Genre = <span class="hljs-string"><span class="hljs-string">'Disco'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Cassandra hat ein <code>UPDATE</code> ähnlich wie PostgreSQL.  <code>UPDATE</code> hat dieselbe <code>UPSERT</code> Semantik <code>UPSERT</code> <code>INSERT</code> . <br><br><blockquote>  Ähnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br>  <b>Mongodb</b> <br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">update ()</a> -Operation in MongoDB kann ein vorhandenes Dokument vollständig aktualisieren oder nur bestimmte Felder aktualisieren.  Standardmäßig wird nur ein Dokument mit <code>UPSERT</code> Semantik aktualisiert.  Das Aktualisieren mehrerer Dokumente und das Verhalten ähnlich wie bei <code>UPSERT</code> können angewendet werden, indem zusätzliche Flags für den Vorgang gesetzt werden.  Im folgenden Beispiel wird beispielsweise das Genre eines bestimmten Künstlers durch sein Lied aktualisiert. <br><br><pre> <code class="sql hljs">db.music.update( {"artist": "The Acme Band"}, { $<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: { <span class="hljs-string"><span class="hljs-string">"genre"</span></span>: <span class="hljs-string"><span class="hljs-string">"Disco"</span></span> } }, {<span class="hljs-string"><span class="hljs-string">"multi"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"upsert"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} );</code> </pre> <br>  <b>Daten aus einer Tabelle entfernen</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Ähnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br>  <b>Mongodb</b> <br><br>  MongoDB bietet zwei Arten von Vorgängen zum Löschen von Dokumenten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deleteOne ()</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ deleteMany ()</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">remove ()</a> .  Beide Typen löschen Dokumente, geben jedoch unterschiedliche Ergebnisse zurück. <br><br><pre> <code class="sql hljs">db.music.deleteMany( { artist: "The Acme Band" } );</code> </pre><br>  <b>Tabelle löschen</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Ähnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">db.music.drop();</code> </pre> <br>  <b>Fazit</b> <br><br>  Die Debatte über die Wahl zwischen SQL und NoSQL tobt seit über 10 Jahren.  Es gibt zwei Hauptaspekte dieser Debatte: die Architektur des Datenbankmoduls (monolithisches, transaktionales SQL im Vergleich zu verteiltem, nicht transaktionalem NoSQL) und den Ansatz für das Datenbankdesign (Datenmodellierung in SQL im Vergleich zur Modellierung Ihrer Abfragen in NoSQL). <br><br>  Mit einer verteilten Transaktionsdatenbank wie YugaByte DB kann die Debatte über die Datenbankarchitektur leicht zerstreut werden.  Wenn das Datenvolumen größer wird als das, was auf einen einzelnen Knoten geschrieben werden kann, ist eine vollständig verteilte Architektur erforderlich, die die lineare Skalierbarkeit von Aufzeichnungen mit automatischem Sharding / Neuausgleich unterstützt. <br><br>  Zusätzlich zu einem Artikel in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Cloud-</a> Artikel werden transaktionsorientierte, streng konsistente Architekturen heute häufiger verwendet, um eine bessere Entwicklungsflexibilität zu bieten als nicht transaktionale, letztendlich konsistente Architekturen. <br><br>  Zurück zur Diskussion des Datenbankdesigns: Man kann mit Recht sagen, dass beide Designansätze (SQL und NoSQL) für jede komplexe reale Anwendung erforderlich sind.  Der SQL-Ansatz „Datenmodellierung“ ermöglicht es Entwicklern, sich ändernde Geschäftsanforderungen einfacher zu erfüllen, während der NoSQL-Ansatz „Datenmodellierung“ es denselben Entwicklern ermöglicht, große Datenmengen mit geringer Latenz und hohem Durchsatz zu verarbeiten.  Aus diesem Grund stellt YugaByte DB SQL- und NoSQL-APIs in einem gemeinsamen Kernel bereit, anstatt einen der Ansätze zu fördern.  Durch die Kompatibilität mit gängigen Datenbanksprachen wie PostgreSQL und Cassandra stellt YugaByte DB außerdem sicher, dass Entwickler keine andere Sprache lernen müssen, um mit einer verteilten, streng konsistenten Datenbank-Engine zu arbeiten. <br><br>  In diesem Artikel haben wir herausgefunden, wie sich die Grundlagen des Datenbankdesigns in PostgreSQL, Cassandra und MongoDB unterscheiden.  In den folgenden Artikeln werden wir uns mit fortgeschrittenen Designkonzepten wie Indizes, Transaktionen, JOINs, TTL-Direktiven und JSON-Dokumenten befassen. <br><br>  Wir wünschen Ihnen einen schönen Aufenthalt für den Rest des Wochenendes und laden Sie zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen Webinar ein</a> , das am 14. Mai stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451042/">https://habr.com/ru/post/de451042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451026/index.html">Warum haben wir so wenig vom frühen Internet übrig?</a></li>
<li><a href="../de451028/index.html">Leitfaden: Arten von Aufsätzen in englischer Sprache und Tipps zum Schreiben</a></li>
<li><a href="../de451032/index.html">Schreiben von HTTP / 1.1- und HTTP / 2-Clients und -Servern in Golang</a></li>
<li><a href="../de451034/index.html">Phantom-SQL-Abfragen</a></li>
<li><a href="../de451040/index.html">Runaway Fun im Mai oder Standoff Approaching</a></li>
<li><a href="../de451044/index.html">IMaskjs - 3 Jahre in Open Source</a></li>
<li><a href="../de451050/index.html">Ember.js: (wieder) Zeit zu versuchen</a></li>
<li><a href="../de451054/index.html">DO-RA: Vorbereitung auf die industrielle Produktion</a></li>
<li><a href="../de451056/index.html">Einführung in MS Dynamics CRM</a></li>
<li><a href="../de451058/index.html">Unternehmensworkshop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>