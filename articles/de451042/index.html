<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüîß üôç üë®‚Äçüë©‚Äçüë¶ Grundlagen des Datenbankdesigns - PostgreSQL-, Cassandra- und MongoDB-Vergleich ‚õ∏Ô∏è üõ´ üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde. Bevor wir in den zweiten Teil der Mai-Ferien aufbrechen, teilen wir Ihnen das Material mit, das wir am Vorabend des Starts eines neuen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen des Datenbankdesigns - PostgreSQL-, Cassandra- und MongoDB-Vergleich</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/451042/">  Hallo Freunde.  Bevor wir in den zweiten Teil der Mai-Ferien aufbrechen, teilen wir Ihnen das Material mit, das wir am Vorabend des Starts eines neuen Streams mit der Rate von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûRelational DBMS‚Äú √ºbersetzt haben</a> . <br><br><img src="https://habrastorage.org/webt/tg/jk/pk/tgjkpk23xr333l_ee0lddnylafa.png"><br><br>  Anwendungsentwickler verbringen viel Zeit damit, mehrere Betriebsdatenbanken zu vergleichen, um diejenige auszuw√§hlen, die f√ºr ihre beabsichtigte Arbeitslast am besten geeignet ist.  Zu den Anforderungen k√∂nnen eine vereinfachte Datenmodellierung, Transaktionsgarantien, Lese- / Schreibleistung, horizontale Skalierung und Fehlertoleranz geh√∂ren.  Traditionell beginnt die Auswahl mit einer Datenbankkategorie, SQL oder NoSQL, da jede Kategorie eine klare Reihe von Kompromissen bietet.  Eine hohe Leistung in Bezug auf niedrige Latenz und hohen Durchsatz wird normalerweise als Kompromissanforderung angesehen und ist daher f√ºr jede Datenbank in der Stichprobe erforderlich. <a name="habracut"></a><br><br>  Der Zweck dieses Artikels besteht darin, Anwendungsentwicklern dabei zu helfen, im Kontext der Modellierung von Anwendungsdaten die richtige Wahl zwischen SQL und NoSQL zu treffen.  Wir werden uns eine SQL-Datenbank ansehen, n√§mlich PostgreSQL und zwei NoSQL-Datenbanken - Cassandra und MongoDB -, um √ºber die Grundlagen des Datenbankdesigns zu sprechen, z. B. das Erstellen, Auff√ºllen von Tabellen, Lesen von Daten aus der Tabelle und L√∂schen von Tabellen.  Im n√§chsten Artikel werden wir uns definitiv mit Indizes, Transaktionen, JOINs, TTL-Direktiven und dem JSON-basierten Datenbankdesign befassen. <br><br>  <b>Was ist der Unterschied zwischen SQL und NoSQL?</b> <br><br><blockquote>  SQL-Datenbanken erh√∂hen die Anwendungsflexibilit√§t durch ACID-Transaktionsgarantien sowie ihre F√§higkeit, Daten mithilfe von JOINs auf unerwartete Weise zus√§tzlich zu vorhandenen normalisierten relationalen Datenbankmodellen abzufragen. </blockquote><br>  Aufgrund ihrer monolithischen Architektur / Einzelknotenarchitektur und der Verwendung eines Master-Slave-Replikationsmodells f√ºr Redundanz weisen herk√∂mmliche SQL-Datenbanken keine zwei wichtigen Merkmale auf - lineare Skalierbarkeit des Datensatzes (d. H. Automatische Aufteilung in mehrere Knoten) und automatischer Datenverlust / Null.  Dies bedeutet, dass die empfangene Datenmenge den maximalen Schreibdurchsatz eines Knotens nicht √ºberschreiten darf.  Dar√ºber hinaus sollte ein vor√ºbergehender Datenverlust bei der Fehlertoleranz ber√ºcksichtigt werden (in einer Architektur ohne gemeinsame Nutzung von Ressourcen).  Hier m√ºssen Sie ber√ºcksichtigen, dass die letzten Commits noch nicht in der Slave-Kopie ber√ºcksichtigt wurden.  Updates ohne Ausfallzeiten sind auch in SQL-Datenbanken schwer zu erreichen. <br><br>  NoSQL-Datenbanken werden typischerweise von Natur aus verteilt, d.h.  In ihnen werden Daten in Abschnitte unterteilt und auf mehrere Knoten verteilt.  Sie erfordern eine Denormalisierung.  Dies bedeutet, dass die eingegebenen Daten auch mehrmals kopiert werden m√ºssen, um auf bestimmte von Ihnen gesendete Anfragen zu antworten.  Das √ºbergeordnete Ziel besteht darin, eine hohe Leistung zu erzielen, indem die Anzahl der beim Lesen verf√ºgbaren Shards verringert wird.  Es folgt der Aussage, dass Sie in NoSQL Ihre Abfragen modellieren m√ºssen, w√§hrend Sie in SQL Ihre Daten modellieren m√ºssen. <br><br><blockquote> NoSQL konzentriert sich auf die Erzielung einer hohen Leistung in einem verteilten Cluster. Dies ist der Hauptgrund f√ºr viele Kompromisse beim Datenbankdesign, zu denen Transaktionsverlust-ACIDs, JOINs und konsistente globale Sekund√§rindizes geh√∂ren. </blockquote><br>  Es wird angenommen, dass NoSQL-Datenbanken zwar eine lineare Schreibskalierbarkeit und eine hohe Fehlertoleranz bieten, der Verlust von Transaktionsgarantien sie jedoch f√ºr gesch√§ftskritische Daten ungeeignet macht. <br><br>  Die folgende Tabelle zeigt, wie sich die Datenmodellierung in NoSQL von SQL unterscheidet. <br><br><img src="https://habrastorage.org/webt/sv/6k/or/sv6kor2fwminli9ywljf1hf5h34.png"><br><br>  <b>SQL und NoSQL: Warum werden beide ben√∂tigt?</b> <br><br>  Reale Anwendungen mit einer gro√üen Anzahl von Benutzern wie Amazon.com, Netflix, Uber und Airbnb f√ºhren komplexe, vielfach sortierte Aufgaben aus.  Beispielsweise muss eine E-Commerce-Anwendung wie Amazon.com leichte, hochkritische Daten wie Informationen zu Benutzern, Produkten, Bestellungen, Rechnungen sowie schwere, aber weniger sensible Daten wie Produktbewertungen und Supportnachrichten speichern , Benutzeraktivit√§t, Benutzerbewertungen und Empfehlungen.  Nat√ºrlich basieren diese Anwendungen auf mindestens einer SQL-Datenbank zusammen mit mindestens einer NoSQL-Datenbank.  In interregionalen und globalen Systemen fungiert die NoSQL-Datenbank als geoverteilter Cache f√ºr Daten, die in einer vertrauensw√ºrdigen Quelle, einer SQL-Datenbank, gespeichert sind und in einer bestimmten Region ausgef√ºhrt werden. <br><br>  <b>Wie kombiniert YugaByte DB SQL und NoSQL?</b> <br><br>  YugaByte DB basiert auf einer protokollorientierten Mixed-Storage-Engine, automatischem Sharding, Sharding verteilter Konsensreplikation und verteilten ACID-Transaktionen (inspiriert von Google Spanner) und ist die erste Open-Source-Datenbank der Welt, die gleichzeitig mit NoSQL (Cassandra &amp; Redis) kompatibel ist ) und SQL (PostgreSQL).  Wie in der folgenden Tabelle gezeigt, f√ºgt YSQL, die Cassandra-kompatible YugaByte DB-API, den NoSQL-APIs die Konzepte von ACID-Transaktionen mit einem und mehreren Schl√ºsseln und globalen Sekund√§rindizes hinzu und er√∂ffnet damit die √Ñra der transaktionalen NoSQL-Datenbanken.  Dar√ºber hinaus erweitert YSQL, eine PostgreSQL-kompatible YugaByte DB-API, die SQL-API um den Begriff der linearen Schreibskalierung und der automatischen Fehlertoleranz und f√ºhrt verteilte SQL-Datenbanken in die Welt ein.  Da es sich bei der YugaByte DB-Datenbank im Wesentlichen um eine Transaktionsdatenbank handelt, kann die NoSQL-API jetzt im Kontext gesch√§ftskritischer Daten verwendet werden. <br><br><img src="https://habrastorage.org/webt/ln/1a/_9/ln1a_9ouduu15ccxhvud1nssmme.png"><br><br>  Wie bereits im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEinf√ºhrung in YSQL: Eine PostgreSQL-kompatible verteilte SQL-API f√ºr YugaByte DB‚Äú erw√§hnt</a> , h√§ngt die Wahl zwischen SQL oder NoSQL in YugaByte DB vollst√§ndig von den Merkmalen der Hauptarbeitslast ab: <br><br><ul><li>  Wenn die Hauptauslastung Mehrschl√ºsseloperationen mit JOINs sind, sollten Sie bei der Auswahl von YSQL verstehen, dass Ihre Schl√ºssel auf mehrere Knoten verteilt werden k√∂nnen, was zu einer h√∂heren Verz√∂gerung und / oder einem geringeren Durchsatz als in NoSQL f√ºhrt. </li><li>  W√§hlen Sie andernfalls eine der beiden NoSQL-APIs aus, und ber√ºcksichtigen Sie dabei, dass Sie eine bessere Leistung erzielen, wenn Abfragen von jeweils einem Knoten ausgef√ºhrt werden.  YugaByte DB kann als einzelne Betriebsdatenbank f√ºr sehr komplexe Anwendungen dienen, in denen Sie mehrere Workloads gleichzeitig verwalten m√ºssen. </li></ul><br>  Das Datenmodellierungslabor im n√§chsten Abschnitt basiert im Gegensatz zu den Quelldatenbanken auf YugaByte DB-Datenbanken, die mit PostgreSQL und Cassandra API kompatibel sind.  Dieser Ansatz betont die einfache Interaktion mit zwei verschiedenen APIs (an zwei verschiedenen Ports) desselben Datenbankclusters, im Gegensatz zur Verwendung v√∂llig unabh√§ngiger Cluster aus zwei verschiedenen Datenbanken. <br><br>  In den folgenden Abschnitten werden wir uns mit dem Datenmodellierungslabor treffen, um die Unterschiede und einige gemeinsame Merkmale der betreffenden Datenbanken zu veranschaulichen. <br><br>  <b>Datenmodellierungslabor</b> <br><br>  <b>Datenbankinstallation</b> <br><br>  Angesichts des Schwerpunkts auf dem Entwerfen eines Datenmodells (anstelle komplexer Bereitstellungsarchitekturen) werden wir die Datenbanken in Docker-Containern auf dem lokalen Computer installieren und dann mit ihnen √ºber die entsprechenden Befehlszeilen-Shells interagieren. <br><br>  <b>Kompatibel mit PostgreSQL &amp; Cassandra, YugaByte DB-Datenbank</b> <br><br><pre><code class="sql hljs">mkdir ~/yugabyte &amp;&amp; cd ~/yugabyte wget https://downloads.yugabyte.com/yb-docker-ctl &amp;&amp; chmod +x yb-docker-ctl docker pull yugabytedb/yugabyte ./yb-docker-ctl <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-comment"><span class="hljs-comment">--enable_postgres</span></span></code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">docker run <span class="hljs-comment"><span class="hljs-comment">--name my-mongo -d mongo:latest</span></span></code> </pre> <br>  <b>Befehlszeilenzugriff</b> <br><br>  Stellen Sie √ºber die Befehlszeilen-Shell f√ºr die entsprechenden APIs eine Verbindung zu den Datenbanken her. <br><br>  <b>PostgreSQL</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">psql</a> ist eine Befehlszeilen-Shell f√ºr die Interaktion mit PostgreSQL.  Zur Vereinfachung der Verwendung wird YugaByte DB mit psql direkt im Ordner bin geliefert. <br><br><pre> <code class="sql hljs">docker exec -it yb-postgres-n1 /home/yugabyte/postgres/bin/psql -p 5433 -U postgres</code> </pre> <br>  <b>Cassandra</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cqlsh</a> ist eine Befehlszeilen-Shell f√ºr die Interaktion mit Cassandra und seinen kompatiblen Datenbanken √ºber CQL (Cassandra Query Language).  Zur Vereinfachung der Verwendung enth√§lt YugaByte DB <code>cqlsh</code> im <code>bin</code> . <br><br>  Beachten Sie, dass CQL von SQL inspiriert wurde und √§hnliche Konzepte wie Tabellen, Zeilen, Spalten und Indizes hat.  Als NoSQL-Sprache werden jedoch bestimmte Einschr√§nkungen hinzugef√ºgt, von denen die meisten auch in anderen Artikeln behandelt werden. <br><br><pre> <code class="sql hljs">docker exec -it yb-tserver-n1 /home/yugabyte/bin/cqlsh</code> </pre> <br>  <b>Mongodb</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mongo</a> ist eine Befehlszeilen-Shell f√ºr die Interaktion mit MongoDB.  Es befindet sich im bin-Verzeichnis der MongoDB-Installation. <br><br><pre> <code class="sql hljs">docker exec -it my-mongo bash cd bin mongo</code> </pre> <br>  <b>Tabellenerstellung</b> <br><br>  Jetzt k√∂nnen wir mit der Datenbank interagieren, um verschiedene Operationen √ºber die Befehlszeile auszuf√ºhren.  Beginnen wir mit der Erstellung einer Tabelle, in der Informationen zu Songs gespeichert sind, die von verschiedenen K√ºnstlern geschrieben wurden.  Diese Songs k√∂nnen Teil eines Albums sein.  Auch optionale Attribute f√ºr den Song - Erscheinungsjahr, Preis, Genre und Bewertung.  Wir m√ºssen zus√§tzliche Attribute ber√ºcksichtigen, die m√∂glicherweise in Zukunft √ºber das Feld "Tags" ben√∂tigt werden.  Es kann halbstrukturierte Daten als Schl√ºssel-Wert-Paare speichern. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>), CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Das Erstellen einer Tabelle in Cassandra ist PostgreSQL sehr √§hnlich.  <b>Einer der Hauptunterschiede ist das Fehlen von Integrit√§tsbeschr√§nkungen (z. B. NICHT NULL). Dies liegt jedoch in der Verantwortung der Anwendung und nicht der NoSQL-Datenbank</b> .  Der Prim√§rschl√ºssel besteht aus einem Abschnittsschl√ºssel (Artist-Spalte im folgenden Beispiel) und einer Reihe von Clustering-Spalten (SongTitle-Spalte im folgenden Beispiel).  Der Partitionsschl√ºssel bestimmt, in welcher Partition / in welchem ‚Äã‚ÄãShard die Zeile platziert werden soll, und die Clustering-Spalten geben an, wie die Daten innerhalb des aktuellen Shards organisiert werden sollen. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> KEYSPACE myapp; <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> myapp; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Mongodb</b> <br><br>  MongoDB organisiert die Daten in Datenbanken (Database) (√§hnlich wie Keyspace in Cassandra), in denen Sammlungen (Collections) (√§hnlich wie Tabellen) vorhanden sind, die Dokumente (Documents) enthalten (√§hnlich wie Zeilen in einer Tabelle).  MongoDB erfordert grunds√§tzlich nicht die Definition des urspr√ºnglichen Schemas.  Der unten gezeigte Befehl <i>"Datenbank verwenden"</i> erstellt beim ersten Aufruf eine Instanz der Datenbank und √§ndert den Kontext f√ºr die neu erstellte Datenbank.  Auch Sammlungen m√ºssen nicht explizit erstellt werden, sondern werden automatisch erstellt, einfach wenn Sie das erste Dokument zu einer neuen Sammlung hinzuf√ºgen.  Beachten Sie, dass MongoDB standardm√§√üig die Testdatenbank verwendet. Daher wird standardm√§√üig jede Operation auf Sammlungsebene ohne Angabe einer bestimmten Datenbank ausgef√ºhrt. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase;</code> </pre> <br>  <b>Abrufen von PostgreSQL-Tabelleninformationen</b> <br><br><pre> <code class="sql hljs">\d Music Table "public.music" Column | Type | Collation | Nullable | Default <span class="hljs-comment"><span class="hljs-comment">--------------+-----------------------+-----------+----------+-------- artist | character varying(20) | | not null | songtitle | character varying(30) | | not null | albumtitle | character varying(25) | | | year | integer | | | price | double precision | | | genre | character varying(10) | | | criticrating | double precision | | | tags | text | | | Indexes: "music_pkey" PRIMARY KEY, btree (artist, songtitle)</span></span></code> </pre> <br>  <b>Cassandra</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DESCRIBE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MUSIC; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> myapp.music ( artist <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, songtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, albumtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, price <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, genre <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, tags <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (artist, songtitle) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (songtitle <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> default_time_to_live = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> transactions = {<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>};</code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> collections;</code> </pre> <br>  <b>Daten in eine PostgreSQL-Tabelle posten</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span>, Price, Genre, CriticRating, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'Somewhat Famous'</span></span>, <span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">2.14</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">7.8</span></span>, <span class="hljs-string"><span class="hljs-string">'{"Composers": ["Smith", "Jones", "Davis"],"LengthInSeconds": 214}'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, CriticRating) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey Now'</span></span>, <span class="hljs-number"><span class="hljs-number">1.98</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">8.4</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">2.47</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'{"radioStationsPlaying": ["KHCR", "KBQX", "WTNR", "WJJH"], "tourDates": { "Seattle": "20150625", "Cleveland": "20150630"}, "rotation": Heavy}'</span></span> );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Im Allgemeinen sieht der <code>INSERT</code> Ausdruck in Cassandra dem in PostgreSQL sehr √§hnlich.  Es gibt jedoch einen gro√üen Unterschied in der Semantik.  In Cassandra ist <code>INSERT</code> eine <code>UPSERT</code> Operation, bei der die letzten Werte zur Zeichenfolge hinzugef√ºgt werden, falls die Zeichenfolge bereits vorhanden ist. <br><blockquote>  Die Dateneingabe √§hnelt der obigen <code>INSERT</code> von PostgreSQL <code>INSERT</code> </blockquote><br>  <b>Mongodb</b> <br><br>  Obwohl MongoDB wie Cassandra eine NoSQL-Datenbank ist, hat ihre Einf√ºgeoperation nichts mit semantischem Verhalten in Cassandra zu tun.  In MongoDB verf√ºgt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">insert ()</a> nicht √ºber <code>UPSERT</code> Funktionen, <code>UPSERT</code> es wie PostgreSQL aussieht.  Durch Hinzuf√ºgen von Standarddaten ohne <code>_idspecified</code> wird der Sammlung ein neues Dokument <code>_idspecified</code> . <br><br> <code>db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "Call Me Today", <br> albumTitle: "Somewhat Famous", <br> year: 2015, <br> price: 2.14, <br> genre: "Country", <br> tags: { <br> Composers: ["Smith", "Jones", "Davis"], <br> LengthInSeconds: 214 <br> } <br> } <br> ); <br> db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "My Dog Spot", <br> albumTitle: "Hey Now", <br> price: 1.98, <br> genre: "Country", <br> criticRating: 8.4 <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Look Out, World", <br> albumTitle:"The Buck Starts Here", <br> price: 0.99, <br> genre: "Rock" <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Still In Love", <br> albumTitle:"The Buck Starts Here", <br> price: 2.47, <br> genre: "Rock", <br> tags: { <br> radioStationsPlaying:["KHCR", "KBQX", "WTNR", "WJJH"], <br> tourDates: { <br> Seattle: "20150625", <br> Cleveland: "20150630" <br> }, <br> rotation: "Heavy" <br> } <br> } <br> );</code> <br> <br>  <b>Tabellenabfrage</b> <br><br>  Der vielleicht bedeutendste Unterschied zwischen SQL und NoSQL im Hinblick auf das Abfragedesign ist die Verwendung der <code>FROM</code> und <code>WHERE</code> Anweisungen.  Mit SQL k√∂nnen Sie mehrere Tabellen nach einer <code>FROM</code> ausw√§hlen, und eine <code>WHERE</code> kann beliebig komplex sein (einschlie√ülich <code>JOIN</code> Operationen zwischen Tabellen).  NoSQL neigt jedoch dazu, <code>FROM</code> strikt einzuschr√§nken und nur mit einer angegebenen Tabelle zu arbeiten. In <code>WHERE</code> muss immer der Prim√§rschl√ºssel angegeben werden.  Dies ist auf den Wunsch zur√ºckzuf√ºhren, die Leistung von NoSQL zu verbessern, √ºber den wir bereits gesprochen haben.  Dieser Wunsch f√ºhrt zu jeder m√∂glichen Reduzierung einer tabellen- und schl√ºssel√ºbergreifenden Interaktion.  Dies kann zu einer gro√üen Verz√∂gerung der Kommunikation zwischen Knoten f√ºhren, wenn auf eine Anfrage geantwortet wird, und wird daher im Prinzip am besten vermieden.  Cassandra verlangt beispielsweise, dass Abfragen auf bestimmte Operatoren (nur <code>=, IN, &lt;, &gt;, =&gt;, &lt;=</code> sind zul√§ssig) f√ºr Partitionsschl√ºssel beschr√§nkt sind, au√üer wenn ein Sekund√§rindex angefordert wird (hier ist nur der Operator = zul√§ssig). <br><br>  <b>PostgreSQL</b> <br><br>  Im Folgenden werden drei Beispiele f√ºr Abfragen aufgef√ºhrt, die von einer SQL-Datenbank problemlos ausgef√ºhrt werden k√∂nnen. <br><br><ul><li>  Drucken Sie alle Songs des K√ºnstlers; </li><li>  Drucken Sie alle Songs des K√ºnstlers, die dem ersten Teil des Namens entsprechen. </li><li>  Listen Sie alle Songs des K√ºnstlers auf, die ein bestimmtes Wort im Titel haben und einen Preis von weniger als 1,00 haben. </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'Call%'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%Today%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Von den oben genannten PostgreSQL-Abfragen funktioniert nur die erste in Cassandra unver√§ndert, da die <code>LIKE</code> Anweisung nicht auf Clustering-Spalten wie <code>SongTitle</code> .  In diesem Fall sind nur Operatoren <code>=</code> und <code>IN</code> zul√§ssig. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Mongodb</b> <br><br>  Wie in den vorherigen Beispielen gezeigt, ist die Hauptmethode zum Erstellen von Abfragen in MongoDB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">db.collection.find ()</a> .  Diese Methode enth√§lt explizit den Namen der Sammlung ( <code>music</code> im folgenden Beispiel), sodass die Anforderung mehrerer Sammlungen verboten ist. <br><br><pre> <code class="sql hljs">db.music.find( { artist: "No One You Know" } ); db.music.find( { artist: "No One You Know", songTitle: /<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>/ } );</code> </pre> <br>  <b>Lesen Sie alle Tabellenzeilen</b> <br><br>  Das Lesen aller Zeilen ist nur ein Sonderfall der zuvor untersuchten Abfragevorlage. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music;</code> </pre> <br><br>  <b>Cassandra</b> <br><br><blockquote>  √Ñhnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br><br>  Mongodb <br><br><pre> <code class="sql hljs">db.music.find( {} );</code> </pre> <br>  <b>Bearbeiten von Daten in einer Tabelle</b> <br><br>  <b>PostgreSQL</b> <br><br>  PostgreSQL bietet eine <code>UPDATE</code> zum √Ñndern von Daten.  Es verf√ºgt nicht √ºber <code>UPSERT</code> Funktionen, daher <code>UPSERT</code> die Ausf√ºhrung dieser Anweisung fehl, wenn sich die Zeile nicht mehr in der Datenbank befindet. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Genre = <span class="hljs-string"><span class="hljs-string">'Disco'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Cassandra hat ein <code>UPDATE</code> √§hnlich wie PostgreSQL.  <code>UPDATE</code> hat dieselbe <code>UPSERT</code> Semantik <code>UPSERT</code> <code>INSERT</code> . <br><br><blockquote>  √Ñhnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br>  <b>Mongodb</b> <br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">update ()</a> -Operation in MongoDB kann ein vorhandenes Dokument vollst√§ndig aktualisieren oder nur bestimmte Felder aktualisieren.  Standardm√§√üig wird nur ein Dokument mit <code>UPSERT</code> Semantik aktualisiert.  Das Aktualisieren mehrerer Dokumente und das Verhalten √§hnlich wie bei <code>UPSERT</code> k√∂nnen angewendet werden, indem zus√§tzliche Flags f√ºr den Vorgang gesetzt werden.  Im folgenden Beispiel wird beispielsweise das Genre eines bestimmten K√ºnstlers durch sein Lied aktualisiert. <br><br><pre> <code class="sql hljs">db.music.update( {"artist": "The Acme Band"}, { $<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: { <span class="hljs-string"><span class="hljs-string">"genre"</span></span>: <span class="hljs-string"><span class="hljs-string">"Disco"</span></span> } }, {<span class="hljs-string"><span class="hljs-string">"multi"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"upsert"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} );</code> </pre> <br>  <b>Daten aus einer Tabelle entfernen</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  √Ñhnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br>  <b>Mongodb</b> <br><br>  MongoDB bietet zwei Arten von Vorg√§ngen zum L√∂schen von Dokumenten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deleteOne ()</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ deleteMany ()</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">remove ()</a> .  Beide Typen l√∂schen Dokumente, geben jedoch unterschiedliche Ergebnisse zur√ºck. <br><br><pre> <code class="sql hljs">db.music.deleteMany( { artist: "The Acme Band" } );</code> </pre><br>  <b>Tabelle l√∂schen</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  √Ñhnlich wie im obigen Beispiel in PostgreSQL. </blockquote><br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">db.music.drop();</code> </pre> <br>  <b>Fazit</b> <br><br>  Die Debatte √ºber die Wahl zwischen SQL und NoSQL tobt seit √ºber 10 Jahren.  Es gibt zwei Hauptaspekte dieser Debatte: die Architektur des Datenbankmoduls (monolithisches, transaktionales SQL im Vergleich zu verteiltem, nicht transaktionalem NoSQL) und den Ansatz f√ºr das Datenbankdesign (Datenmodellierung in SQL im Vergleich zur Modellierung Ihrer Abfragen in NoSQL). <br><br>  Mit einer verteilten Transaktionsdatenbank wie YugaByte DB kann die Debatte √ºber die Datenbankarchitektur leicht zerstreut werden.  Wenn das Datenvolumen gr√∂√üer wird als das, was auf einen einzelnen Knoten geschrieben werden kann, ist eine vollst√§ndig verteilte Architektur erforderlich, die die lineare Skalierbarkeit von Aufzeichnungen mit automatischem Sharding / Neuausgleich unterst√ºtzt. <br><br>  Zus√§tzlich zu einem Artikel in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Cloud-</a> Artikel werden transaktionsorientierte, streng konsistente Architekturen heute h√§ufiger verwendet, um eine bessere Entwicklungsflexibilit√§t zu bieten als nicht transaktionale, letztendlich konsistente Architekturen. <br><br>  Zur√ºck zur Diskussion des Datenbankdesigns: Man kann mit Recht sagen, dass beide Designans√§tze (SQL und NoSQL) f√ºr jede komplexe reale Anwendung erforderlich sind.  Der SQL-Ansatz ‚ÄûDatenmodellierung‚Äú erm√∂glicht es Entwicklern, sich √§ndernde Gesch√§ftsanforderungen einfacher zu erf√ºllen, w√§hrend der NoSQL-Ansatz ‚ÄûDatenmodellierung‚Äú es denselben Entwicklern erm√∂glicht, gro√üe Datenmengen mit geringer Latenz und hohem Durchsatz zu verarbeiten.  Aus diesem Grund stellt YugaByte DB SQL- und NoSQL-APIs in einem gemeinsamen Kernel bereit, anstatt einen der Ans√§tze zu f√∂rdern.  Durch die Kompatibilit√§t mit g√§ngigen Datenbanksprachen wie PostgreSQL und Cassandra stellt YugaByte DB au√üerdem sicher, dass Entwickler keine andere Sprache lernen m√ºssen, um mit einer verteilten, streng konsistenten Datenbank-Engine zu arbeiten. <br><br>  In diesem Artikel haben wir herausgefunden, wie sich die Grundlagen des Datenbankdesigns in PostgreSQL, Cassandra und MongoDB unterscheiden.  In den folgenden Artikeln werden wir uns mit fortgeschrittenen Designkonzepten wie Indizes, Transaktionen, JOINs, TTL-Direktiven und JSON-Dokumenten befassen. <br><br>  Wir w√ºnschen Ihnen einen sch√∂nen Aufenthalt f√ºr den Rest des Wochenendes und laden Sie zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen Webinar ein</a> , das am 14. Mai stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451042/">https://habr.com/ru/post/de451042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451026/index.html">Warum haben wir so wenig vom fr√ºhen Internet √ºbrig?</a></li>
<li><a href="../de451028/index.html">Leitfaden: Arten von Aufs√§tzen in englischer Sprache und Tipps zum Schreiben</a></li>
<li><a href="../de451032/index.html">Schreiben von HTTP / 1.1- und HTTP / 2-Clients und -Servern in Golang</a></li>
<li><a href="../de451034/index.html">Phantom-SQL-Abfragen</a></li>
<li><a href="../de451040/index.html">Runaway Fun im Mai oder Standoff Approaching</a></li>
<li><a href="../de451044/index.html">IMaskjs - 3 Jahre in Open Source</a></li>
<li><a href="../de451050/index.html">Ember.js: (wieder) Zeit zu versuchen</a></li>
<li><a href="../de451054/index.html">DO-RA: Vorbereitung auf die industrielle Produktion</a></li>
<li><a href="../de451056/index.html">Einf√ºhrung in MS Dynamics CRM</a></li>
<li><a href="../de451058/index.html">Unternehmensworkshop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>