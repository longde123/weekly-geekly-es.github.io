<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔭 📓 🧙 Crie ferramentas em projetos de aprendizado de máquina, uma visão geral 🖇️ 🈴 🏔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu estava pensando sobre a estrutura do projeto / aprendizado de máquina / ciência de dados / fluxo de trabalho e estava lendo opiniões diferentes sob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie ferramentas em projetos de aprendizado de máquina, uma visão geral</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Eu estava pensando sobre a estrutura do projeto / aprendizado de máquina / ciência de dados / fluxo de trabalho e estava lendo opiniões diferentes sobre o assunto.  E quando as pessoas começam a falar sobre fluxo de trabalho, desejam que seus fluxos de trabalho sejam reproduzíveis.  Existem muitas postagens por aí que sugerem o uso do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">make</a> para manter o fluxo de trabalho reproduzível.  Embora <code>make</code> seja muito estável e amplamente utilizado, eu pessoalmente gosto de soluções de plataforma cruzada.  Afinal, é 2019, não 1977. Pode-se argumentar que se faz multiplataforma, mas, na realidade, você terá problemas e gastará tempo consertando sua ferramenta em vez de fazer o trabalho real.  Decidi dar uma olhada e verificar quais outras ferramentas estão disponíveis.  Sim, eu decidi gastar algum tempo em ferramentas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="imagem"></div><br>  Esta postagem é mais um convite para um diálogo do que para um tutorial.  Talvez sua solução seja perfeita.  Se for, será interessante ouvir sobre isso. <br><br>  Neste post, usarei um pequeno projeto Python e executarei as mesmas tarefas de automação com sistemas diferentes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pavimentadora</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">doit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Luigi</a> </li></ul><br>  Haverá uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela de comparação</a> no final da postagem. <br><a name="habracut"></a><br>  A maioria das ferramentas que examinarei são conhecidas como <em>software de automação de</em> <em>compilação</em> ou <em>sistemas de compilação</em> .  Existem inúmeras em todos os diferentes sabores, tamanhos e complexidades.  A idéia é a mesma: o desenvolvedor define regras para produzir alguns resultados de maneira automatizada e consistente.  Por exemplo, um resultado pode ser uma imagem com um gráfico.  Para criar essa imagem, é necessário fazer o download dos dados, limpá-los e fazer algumas manipulações de dados (exemplo clássico, na verdade).  Você pode começar com alguns scripts de shell que farão o trabalho.  Depois que você voltar ao projeto, um ano depois, será difícil lembrar de todas as etapas e da ordem que você precisa seguir para criar essa imagem.  A solução óbvia é documentar todas as etapas.  Boas notícias!  Os sistemas de compilação permitem documentar as etapas em uma forma de programa de computador.  Alguns sistemas de compilação são como os scripts de shell, mas com sinos e assobios adicionais. <br><br>  A base desta publicação é uma série de publicações de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mateusz Bednarski</a> no fluxo de trabalho automatizado para um projeto de aprendizado de máquina.  Mateusz explica seus pontos de vista e fornece receitas para o uso do <code>make</code> .  Convido você a verificar as postagens dele primeiro.  Usarei principalmente o código dele, mas com diferentes sistemas de compilação. <br><br>  Se você quiser saber mais sobre o <code>make</code> , <code>make</code> seguir algumas referências para algumas postagens.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brooke Kennedy</a> fornece uma visão geral de alto nível em 5 etapas fáceis para tornar seu projeto de ciência de dados reproduzível.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zachary Jones</a> fornece mais detalhes sobre a sintaxe e os recursos, além dos links para outras postagens.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">David Stevens</a> escreve um post muito hype sobre por que você absolutamente precisa começar a usar o <code>make</code> imediatamente.  Ele fornece bons exemplos comparando <i>a maneira antiga</i> e <i>a nova</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Samuel Lampa</a> , por outro lado, escreve sobre por que usar <code>make</code> é uma má idéia. <br><br>  Minha seleção de sistemas de construção não é abrangente nem imparcial.  Se você quiser fazer sua lista, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia</a> pode ser um bom ponto de partida.  Conforme mencionado acima, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abordarei</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">doit</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Luigi</a> .  A maioria das ferramentas nesta lista é baseada em python e faz sentido, pois o projeto está em Python.  Esta postagem não abordará como instalar as ferramentas.  Presumo que você seja bastante proficiente em Python. <br><br>  Estou interessado principalmente em testar esta funcionalidade: <br><br><ol><li>  Especificando alguns destinos com dependências.  Eu quero ver como fazê-lo e como é fácil. </li><li>  Verificando se compilações incrementais são possíveis.  Isso significa que o sistema de compilação não reconstruirá o que não foi alterado desde a última execução, ou seja, você não precisa baixar novamente seus dados brutos.  Outra coisa que procurarei é compilações incrementais quando a dependência muda.  Imagine que temos um gráfico de dependências <code>A -&gt; B -&gt; C</code>  O alvo <code>C</code> será reconstruído se <code>B</code> mudar?  Se um? </li><li>  Verificando se a reconstrução será acionada se o código-fonte for alterado, ou seja, alteramos o parâmetro do gráfico gerado, da próxima vez que construirmos a imagem, ela deverá ser reconstruída. </li><li>  Verificando as maneiras de limpar artefatos de construção, ou seja, remover arquivos que foram criados durante a construção e reverter para o código-fonte limpo. </li></ol><br>  Não usarei todos os alvos de compilação do post de Mateusz, apenas três deles para ilustrar os princípios. <br><br>  Todo o código está disponível no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h2><a name="CMake"></a>  CMake </h2><br>  O CMake é um gerador de script de construção, que gera arquivos de entrada para vários sistemas de construção.  E seu nome significa marca de plataforma cruzada.  O CMake é uma ferramenta de engenharia de software.  Sua principal preocupação é sobre a criação de executáveis ​​e bibliotecas.  Portanto, o CMake sabe como criar <i>destinos a</i> partir do código-fonte nos idiomas suportados.  O CMake é executado em duas etapas: configuração e geração.  Durante a configuração, é possível configurar a futura compilação de acordo com uma necessidade.  Por exemplo, variáveis ​​fornecidas pelo usuário são fornecidas durante esta etapa.  A geração é normalmente simples e produz arquivos com os quais os sistemas de construção podem funcionar.  Com o CMake, você ainda pode usar o <code>make</code> , mas, em vez de escrever diretamente o makefile, você cria um arquivo CMake, que irá gerar o makefile para você. <br><br>  Outro conceito importante é que o CMake incentiva <i>compilações fora da fonte</i> .  Construções fora da fonte mantêm o código fonte longe de qualquer artefato produzido.  Isso faz muito sentido para executáveis ​​nos quais a base de código de fonte única pode ser compilada sob diferentes arquiteturas de CPU e sistemas operacionais.  Essa abordagem, no entanto, pode contradizer a maneira como muitos cientistas de dados trabalham.  Parece-me que a comunidade de ciência de dados tende a ter um alto acoplamento de dados, código e resultados. <br><br>  Vamos ver o que precisamos para alcançar nossos objetivos com o CMake.  Existem duas possibilidades para definir itens personalizados no CMake: destinos personalizados e comandos personalizados.  Infelizmente, precisaremos usar os dois, o que resulta em mais digitação em comparação com o vanila makefile.  Um destino personalizado é considerado sempre desatualizado, ou seja, se houver um destino para o download de dados brutos, o CMake sempre o fará novamente.  Uma combinação de comando personalizado com destino personalizado permite manter os destinos atualizados. <br><br>  Para o nosso projeto, criaremos um arquivo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMakeLists.txt</a> e o colocaremos na raiz do projeto.  Vamos conferir o conteúdo: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Esta parte é básica.  A segunda linha define o nome do seu projeto, versão e especifica que não usaremos nenhum suporte à linguagem incorporada (seno chamaremos de scripts Python). <br><br>  Nosso primeiro destino fará o download do conjunto de dados IRIS: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  A primeira linha define o parâmetro <code>IRIS_URL</code> , que é exposto ao usuário durante a etapa de configuração.  Se você usar a GUI do CMake, poderá definir esta variável através da GUI: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  Em seguida, definimos variáveis ​​com o local baixado do conjunto de dados IRIS.  Em seguida, adicionamos um comando personalizado, que produzirá <code>IRIS_FILE</code> conforme a saída.  No final, definimos um dado <code>rawdata</code> destino personalizado que depende de <code>IRIS_FILE</code> o que significa que, para criar dados <code>rawdata</code> <code>IRIS_FILE</code> deve ser construído.  A opção <code>ALL</code> do destino personalizado diz que os dados <code>rawdata</code> serão um dos destinos padrão a serem construídos.  Observe que eu uso <code>CMAKE_CURRENT_SOURCE_DIR</code> para manter os dados baixados na pasta de origem e não na pasta de compilação.  Isso é apenas para torná-lo o mesmo que Mateusz. <br><br>  Tudo bem, vamos ver como podemos usá-lo.  Atualmente, estou executando-o no Windows com o compilador MinGW instalado.  Pode ser necessário ajustar a configuração do gerador para suas necessidades (execute <code>cmake --help</code> para ver a lista de geradores disponíveis).  Inicie o terminal e vá para a pasta pai do código-fonte e, em seguida: <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text">  - Configuração concluída <br>  - Gerando feito <br>  - Os arquivos de compilação foram gravados em: C: / home / espaço de trabalho / superar o caos-compilar <br></div></div><br>  Com o CMake moderno, podemos construir o projeto diretamente do CMake.  Este comando chamará o comando <code>build all</code> : <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text">  Dependências de varredura de dados brutos de destino <br>  [100%] Dados brutos de destino criados <br></div></div><br>  Também podemos visualizar a lista de destinos disponíveis: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  E podemos remover o arquivo baixado por: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Veja que não precisamos criar o destino limpo manualmente. <br><br>  Agora vamos para o próximo alvo - dados pré-processados ​​do IRIS.  Mateusz cria dois arquivos a partir de uma única função: <code>processed.pickle</code> e <code>processed.xlsx</code>  Você pode ver como ele se sai limpando esse arquivo do Excel usando <code>rm</code> com curinga.  Eu acho que essa não é uma abordagem muito boa.  No CMake, temos duas opções de como lidar com isso.  A primeira opção é usar a propriedade de diretório <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  O código será: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  A segunda opção é especificar uma lista de arquivos como uma saída de comando customizada: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  Veja que nesse caso eu criei a lista, mas não a usei dentro do comando personalizado.  Não conheço uma maneira de referenciar argumentos de saída de comando personalizado dentro dele. <br><br>  Outra coisa interessante a ser observada é o uso de <code>depends</code> neste comando personalizado.  Definimos a dependência não apenas de um destino personalizado, mas também da saída e do script python.  Se não adicionarmos dependência ao <code>IRIS_FILE</code> , a modificação manual do <code>iris.csv</code> não resultará na reconstrução do destino de <code>preprocess</code> -processo.  Bem, você não deve modificar os arquivos no diretório de construção manualmente, em primeiro lugar.  Apenas deixando você saber.  Mais detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post de Sam Thursfield</a> .  A dependência do script python é necessária para reconstruir o destino se o script python mudar. <br><br>  E finalmente o terceiro alvo: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Esse objetivo é basicamente o mesmo que o segundo. <br><br>  Para encerrar.  O CMake parece confuso e mais difícil que o Make.  De fato, muitas pessoas criticam o CMake por sua sintaxe.  Na minha experiência, o entendimento chegará e é absolutamente possível entender até arquivos CMake muito complicados. <br><br>  Você ainda se colará bastante, pois precisará passar as variáveis ​​corretas.  Não vejo uma maneira fácil de referenciar a saída de um comando personalizado em outro.  Parece que é possível fazê-lo através de destinos personalizados. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  A parte do PyBuilder é muito curta.  Eu usei o Python 3.7 no meu projeto e a versão atual do PyBuilder 0.11.17 não o suporta.  A solução proposta é usar a versão de desenvolvimento.  No entanto, essa versão é limitada ao pip v9.  Pip é v19.3 até o momento da redação.  Que chatice.  Depois de brincar um pouco, não funcionou para mim.  A avaliação do PyBuilder foi de curta duração. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt é baseado em python, o que significa que podemos usar funções python diretamente.  Não é necessário agrupá-los com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">clique</a> e fornecer uma interface de linha de comando.  No entanto, o pynt também é capaz de executar comandos do shell.  Vou usar funções python. <br><br>  Os comandos de compilação são fornecidos em um arquivo <code>build.py</code> .  Os alvos / tarefas são criados com decoradores de funções.  As dependências da tarefa são fornecidas pelo mesmo decorador. <br><br>  Como gostaria de usar funções python, preciso importá-las no script de construção.  O Pynt não inclui o diretório atual como script python, portanto, escrever algo assim: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  não vai funcionar.  Temos que fazer: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  Meu arquivo <code>build.py</code> inicial era assim: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  E o destino do <code>preprocess</code> não funcionou.  Ele estava constantemente reclamando dos argumentos de entrada da função <code>pypreprocess</code> .  Parece que o Pynt não lida com argumentos de função opcionais muito bem.  Eu tive que remover o argumento para criar o arquivo do Excel.  Lembre-se disso se seu projeto tiver funções com argumentos opcionais. <br><br>  Podemos executar o pynt na pasta do projeto e listar todos os destinos disponíveis: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Vamos fazer a distribuição aos pares: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Se agora executarmos o mesmo comando novamente (ou seja, <code>pynt exploratory</code> ), haverá uma reconstrução completa.  Pynt não rastreou que nada mudou. <br><br><h2><a name="Paver"></a>  Pavimentadora </h2><br>  Pavimentadora parece quase exatamente como Pynt.  É um pouco diferente de uma maneira que define as dependências entre os alvos (outro decorador <code>@needs</code> ).  A Pavimentadora realiza uma reconstrução completa a cada vez e não funciona bem com funções que possuem argumentos opcionais.  As instruções de compilação são encontradas no arquivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  doit </h2><br>  Doit parece uma tentativa de criar uma ferramenta de automação de compilação verdadeiramente em python.  Pode executar código python e comandos de shell.  Parece bastante promissor.  O que parece faltar (no contexto de nossos objetivos específicos) é a capacidade de lidar com dependências entre alvos.  Digamos que queremos criar um pequeno pipeline em que a saída do destino A seja usada como entrada do destino B. E digamos que estamos usando arquivos como saídas, portanto, o destino A crie um arquivo denominado <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Para criar esse pipeline, precisamos especificar o arquivo <code>outA</code> duas vezes no destino A (como resultado de um destino, mas também retornar seu nome como parte da execução do destino).  Em seguida, precisaremos especificá-lo como entrada para o destino B. Portanto, existem 3 locais no total onde precisamos fornecer informações sobre a <code>outA</code> .  E mesmo depois de fazer isso, a modificação do arquivo <code>outA</code> não levará à reconstrução automática do destino B. Isso significa que, se pedirmos ao doit para construir o destino B, ele verificará apenas se o destino B está atualizado sem verificar nenhuma das dependências.  Para superar isso, precisaremos especificar <code>outA</code> 4 vezes - também como dependência de arquivo do destino B. Vejo isso como uma desvantagem.  Make e CMake são capazes de lidar com essas situações corretamente. <br><br>  Dependências no doit são baseadas em arquivo e expressas como seqüências de caracteres.  Isso significa que as dependências <code>./myfile.txt</code> e <code>myfile.txt</code> são vistas como diferentes.  Como escrevi acima, acho a maneira de passar informações de destino para destino (ao usar destinos em python) um pouco estranha.  O destino possui uma lista de artefatos que será produzida, mas outro destino não pode usá-lo.  Em vez disso, a função python, que constitui o destino, deve retornar um dicionário, que pode ser acessado em outro destino.  Vamos ver em um exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Aqui, o <code>preprocess</code> destino depende dos dados <code>rawdata</code> .  A dependência é fornecida através da propriedade <code>getargs</code> .  Ele diz que o argumento <code>input_file</code> da função <code>doit_pypreprocess</code> é o <code>filename</code> do <code>filename</code> de saída dos dados <code>rawdata</code> destino.  Veja o exemplo completo no arquivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dodo.py.</a> <br><br>  Pode valer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> pena ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as histórias</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sucesso</a> do uso do doit.  Definitivamente, possui recursos interessantes, como a capacidade de fornecer uma verificação de destino personalizada e atualizada. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  O Luigi se mantém afastado de outras ferramentas, pois é um sistema para construir dutos complexos.  Apareceu no meu radar depois que um colega me disse que tentou o Make, nunca foi capaz de usá-lo no Windows / Linux e se mudou para Luigi. <br><br>  Luigi visa sistemas prontos para produção.  Ele vem com um servidor, que pode ser usado para visualizar suas tarefas ou para obter um histórico de execuções de tarefas.  O servidor é chamado de <em>agendador central</em> .  Um agendador local está disponível para fins de depuração. <br><br>  Luigi também é diferente de outros sistemas de uma maneira como as tarefas são criadas.  O Lugi não age em arquivos pré-definidos (como <code>dodo.py</code> , <code>pavement.py</code> ou makefile).  Em vez disso, é preciso passar um nome de módulo python.  Portanto, se tentarmos usá-lo da mesma maneira que outras ferramentas (coloque um arquivo com tarefas na raiz do projeto), ele não funcionará.  Temos que instalar nosso projeto ou modificar a variável ambiental <code>PYTHONPATH</code> adicionando o caminho ao projeto. <br><br>  O que é ótimo no luigi é a maneira de especificar dependências entre tarefas.  Cada tarefa é uma classe.  A <code>output</code> método informa ao Luigi onde os resultados da tarefa serão finalizados.  Os resultados podem ser um único elemento ou uma lista.  O método <code>requires</code> especifica as dependências da tarefa (outras tarefas; embora seja possível fazer uma dependência por si só).  E é isso.  O que for especificado como <code>output</code> na tarefa A será passado como entrada para a tarefa B se a tarefa B se basear na tarefa A. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  Luigi não se importa com modificações de arquivo.  Ele se preocupa com a existência do arquivo.  Portanto, não é possível disparar recriações quando o código fonte é alterado.  Luigi não tem uma funcionalidade <i>limpa</i> embutida. <br><br>  As tarefas do Luigi para este projeto estão disponíveis no arquivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">luigitasks.py</a> .  Eu os corro do terminal: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Comparação </h2><br>  A tabela abaixo resume como os diferentes sistemas funcionam em relação aos nossos objetivos específicos. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Definir destino com dependência </th><th>  Construções incrementais </th><th>  Construções incrementais se o código fonte for alterado </th><th>  Capacidade de descobrir quais artefatos remover durante o comando <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  sim </td><td>  sim </td><td>  sim </td><td>  sim </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  sim </td><td>  não </td><td>  não </td><td>  não </td></tr><tr><td>  <strong>Pavimentadora</strong> </td><td>  sim </td><td>  não </td><td>  não </td><td>  não </td></tr><tr><td>  <strong>doit</strong> </td><td>  Um pouco sim </td><td>  sim </td><td>  sim </td><td>  sim </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  sim </td><td>  não </td><td>  não </td><td>  não </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451962/">https://habr.com/ru/post/pt451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451950/index.html">Usinas virtuais. É possível gerenciar as fontes de energia "verde"?</a></li>
<li><a href="../pt451954/index.html">Mais telegramas secretos</a></li>
<li><a href="../pt451956/index.html">Usando o AppDynamics com o Red Hat OpenShift v3</a></li>
<li><a href="../pt451958/index.html">Assistimos torrents na TV inteligente sem SMS e registro</a></li>
<li><a href="../pt451960/index.html">90 vulnerabilidades de execução remota de código em maio, atualização terça-feira</a></li>
<li><a href="../pt451966/index.html">Os modernos dispositivos de E / S são mais rápidos que os processadores. Visão geral do artigo</a></li>
<li><a href="../pt451968/index.html">Top 3D Academy - treinamento em tecnologias aditivas nas principais empresas russas</a></li>
<li><a href="../pt451970/index.html">Thrangrycat: vulnerabilidade crítica no firmware do dispositivo Cisco permite que hackers instalem backdoors neles</a></li>
<li><a href="../pt451972/index.html">QuadCast - Soa Real</a></li>
<li><a href="../pt451974/index.html">História da AMD: 50 anos de desenvolvimento rápido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>