<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📮 🏉 🎴 Cara kerja Yandex.Market berfungsi dan apa yang akan terjadi jika salah satu server mogok 🛃 🥨 ♍️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, nama saya Eugene. Saya bekerja di infrastruktur pencarian Yandex.Market. Saya ingin memberi tahu komunitas Habr tentang dapur internal Pasar - te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja Yandex.Market berfungsi dan apa yang akan terjadi jika salah satu server mogok</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/475848/">  Hai, nama saya Eugene.  Saya bekerja di infrastruktur pencarian Yandex.Market.  Saya ingin memberi tahu komunitas Habr tentang dapur internal Pasar - tetapi ada sesuatu untuk diceritakan.  Pertama-tama, bagaimana Pencarian Pasar, proses dan arsitektur bekerja.  Bagaimana kita menghadapi situasi darurat: apa yang terjadi jika satu server lumpuh?  Dan jika ada 100 server seperti itu? <br><br>  Anda juga akan belajar bagaimana kami menerapkan fungsionalitas baru pada sekelompok server segera.  Dan bagaimana menguji layanan kompleks langsung dalam produksi, tanpa memberi pengguna ketidaknyamanan.  Secara umum, cara pencarian Pasar bekerja, sehingga semua orang baik-baik saja. <br><br><img src="https://habrastorage.org/webt/-x/ye/eb/-xyeebvixa2pxxh3ad-peaoukyo.png"><br><a name="habracut"></a><br><h2>  Sedikit tentang kita: masalah apa yang kita pecahkan </h2><br>  Saat Anda memasukkan teks, mencari produk dengan parameter atau membandingkan harga di toko yang berbeda, semua permintaan tiba di layanan pencarian.  Pencarian adalah layanan terbesar di Pasar. <br><br>  Kami memproses semua permintaan pencarian: dari market.yandex.ru, beru.ru, layanan Supercheck, Yandex.Advisor, dan aplikasi seluler.  Kami juga menyertakan penawaran barang dalam hasil pencarian di yandex.ru. <br><br><img width="500" src="https://habrastorage.org/webt/yt/_h/5d/yt_h5de7hmx0zmkv8gdk7glq-kc.png"><br><br>  Dengan layanan pencarian, maksud saya tidak hanya mencari secara langsung, tetapi juga database dengan semua penawaran di Pasar.  Skalanya adalah ini: lebih dari satu miliar permintaan pencarian diproses per hari.  Dan semuanya harus bekerja dengan cepat, tanpa gangguan dan selalu menghasilkan hasil yang diinginkan. <br><br><h2>  Apa itu: Arsitektur pasar </h2><br>  Jelaskan secara singkat arsitektur Pasar saat ini.  Secara konvensional, dapat dijelaskan oleh skema di bawah ini: <br><img src="https://habrastorage.org/webt/ra/yq/jv/rayqjvvmbjvxhsc8lokpysg_rvw.jpeg"><br>  Katakanlah toko mitra datang kepada kita.  Dia bilang aku ingin menjual mainan: kucing jahat ini dengan alat penyapu.  Dan kucing jahat tanpa tweeter.  Dan hanya seekor kucing.  Maka toko perlu menyiapkan penawaran yang dicari Pasar.  Toko membentuk xml khusus dengan penawaran dan mengkomunikasikan jalur ke xml ini melalui antarmuka mitra.  Kemudian pengindeks secara berkala mengunduh xml ini, memeriksa kesalahan dan menyimpan semua informasi dalam database besar. <br><br>  Ada banyak xml yang disimpan.  Indeks pencarian dibuat dari database ini.  Indeks disimpan dalam format internal.  Setelah membuat indeks, layanan Tata Letak mengunggahnya ke mesin pencari. <br><br>  Akibatnya, kucing jahat dengan pencabik muncul di database, dan indeks kucing muncul di server. <br><br>  Saya akan berbicara tentang bagaimana kita mencari kucing di bagian tentang arsitektur pencarian. <br><br><h2>  Arsitektur Pencarian Pasar </h2><br>  Kita hidup di dunia layanan-mikro: setiap permintaan masuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">market.yandex.ru</a> menyebabkan banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">subkueri</a> , dan lusinan layanan berpartisipasi dalam pemrosesan mereka.  Diagram hanya menunjukkan beberapa: <br><br><img src="https://habrastorage.org/webt/92/n9/iu/92n9iutvet9ls6k7djh29brfdq0.jpeg"><br>  <i>Skema pemrosesan permintaan yang disederhanakan</i> <br><br>  Setiap layanan memiliki hal yang luar biasa - penyeimbangnya sendiri dengan nama yang unik: <br><br><img src="https://habrastorage.org/webt/qb/_c/t4/qb_ct4mdpio2xprdlos2pi1oym8.jpeg"><br><br>  Penyeimbang memberi kami fleksibilitas besar dalam mengelola layanan: misalnya, Anda dapat mematikan server, yang sering diperlukan untuk pembaruan.  Penyeimbang melihat bahwa server tidak tersedia dan secara otomatis mengalihkan permintaan ke server lain atau pusat data.  Ketika Anda menambah atau menghapus server, beban secara otomatis didistribusikan kembali antara server. <br><br>  Nama unik penyeimbang tidak bergantung pada pusat data.  Ketika layanan A membuat permintaan ke B, maka secara default, penyeimbang B mengalihkan permintaan ke pusat data saat ini.  Jika layanan tidak tersedia atau tidak ada di pusat data saat ini, permintaan dialihkan ke pusat data lainnya. <br><br>  FQDN tunggal untuk semua pusat data memungkinkan layanan A untuk secara umum melepaskan diri dari lokasi.  Permintaannya untuk layanan B akan selalu diproses.  Pengecualian adalah kasus ketika layanan di semua pusat data. <br><br>  Tapi tidak semuanya begitu cerah dengan penyeimbang ini: kami memiliki komponen perantara tambahan.  Penyeimbang mungkin tidak stabil, dan masalah ini diselesaikan oleh server yang berlebihan.  Ada juga penundaan tambahan antara layanan A dan B. Namun dalam praktiknya, itu kurang dari 1 ms dan untuk sebagian besar layanan ini tidak kritis. <br><br><h3>  Memerangi yang tak terduga: menyeimbangkan dan layanan pencarian tangguh </h3><br>  Bayangkan bahwa keruntuhan terjadi: Anda perlu menemukan kucing dengan alat penyapu, tetapi server macet.  Atau 100 server.  Bagaimana cara keluar?  Akankah kami benar-benar meninggalkan pengguna tanpa kucing? <br><br>  Situasinya mengerikan, tetapi kami siap untuk itu.  Aku akan memberitahumu dalam rangka. <br><br>  Infrastruktur pencarian terletak di beberapa pusat data: <br><br><img src="https://habrastorage.org/webt/_i/wa/f9/_iwaf97__hrhmaspgxcl-euqqnq.jpeg"><br><br>  Saat mendesain, kami meletakkan kemungkinan menonaktifkan satu pusat data.  Hidup ini penuh kejutan - misalnya, sebuah ekskavator dapat memotong kabel bawah tanah (ya, memang seperti itu).  Kapasitas di pusat data yang tersisa harus cukup untuk menahan beban puncak. <br><br>  Pertimbangkan pusat data tunggal.  Di setiap pusat data, skema penyeimbang yang sama: <br><br><img src="https://habrastorage.org/webt/x6/rp/hx/x6rphx-hrlcb1gciennukyjeudi.jpeg"><br>  Satu penyeimbang setidaknya tiga server fisik.  Redundansi tersebut dibuat untuk keandalan.  Balancers bekerja pada HAProx. <br><br>  Kami memilih HAProx karena kinerjanya yang tinggi, persyaratan sumber daya yang kecil, dan fungsionalitas yang luas.  Di dalam setiap server, perangkat lunak pencarian kami berfungsi. <br><br>  Probabilitas kegagalan satu server kecil.  Tetapi jika Anda memiliki banyak server, kemungkinan setidaknya satu jatuh akan meningkat. <br><br>  Inilah yang terjadi pada kenyataannya: server mengalami crash.  Karena itu, Anda harus terus memantau status semua server.  Jika server berhenti merespons, maka server terputus secara otomatis dari lalu lintas.  Untuk ini, HAProxy memiliki pemeriksaan kesehatan bawaan.  Ia pergi ke semua server dengan permintaan HTTP "/ ping" satu detik sekali. <br><br>  Fitur lain dari HAProxy: agent-check memungkinkan Anda memuat semua server secara merata.  Untuk melakukan ini, HAProxy terhubung ke semua server, dan mereka mengembalikan beratnya tergantung pada beban saat ini dari 1 hingga 100. Berat dihitung berdasarkan jumlah permintaan dalam antrian pemrosesan dan beban pada prosesor. <br><br>  Sekarang tentang mencari kucing.  Pertanyaan tentang formulir <b>/ pencarian? Teks = angry + cat</b> tiba untuk <b>mencari</b> .  Agar pencarian cepat, seluruh indeks kucing harus ditempatkan dalam RAM.  Bahkan membaca dari SSD tidak cukup cepat. <br><br>  Sekali waktu, basis penawaran kecil, dan ada cukup RAM untuk satu server untuk itu.  Ketika basis data proposal bertambah, semuanya tidak lagi sesuai dengan RAM ini, dan data dibagi menjadi dua bagian: pecahan 1 dan pecahan 2. <br><br><img src="https://habrastorage.org/webt/kz/od/j5/kzodj5ghrqccc_necth6gmylzgy.jpeg"><br>  Tapi itu selalu terjadi: solusi apa pun, bahkan solusi yang baik, menimbulkan masalah lain. <br><br>  Penyeimbang masih pergi ke server mana pun.  Tetapi pada mesin di mana permintaan itu datang, hanya ada setengah indeks.  Sisanya ada di server lain.  Oleh karena itu, server harus pergi ke beberapa mesin tetangga.  Setelah menerima data dari kedua server, hasilnya digabungkan dan direorganisasi. <br><br>  Karena penyeimbang mendistribusikan permintaan secara merata, semua server terlibat dalam mengatur ulang, dan tidak hanya memberikan data. <br><br>  Masalah terjadi jika server tetangga tidak tersedia.  Solusinya adalah menetapkan beberapa server dengan prioritas berbeda sebagai server "tetangga".  Pertama, permintaan dikirim ke server di rak saat ini.  Jika tidak ada respons yang diterima, permintaan dikirim ke semua server di pusat data ini.  Dan yang tak kalah pentingnya, permintaan tersebut dikirim ke pusat data lainnya. <br>  Ketika jumlah proposal meningkat, data dibagi menjadi empat bagian.  Tapi ini bukan batasnya. <br><br>  Sekarang konfigurasi delapan pecahan digunakan.  Selain itu, untuk lebih menghemat memori, indeks dibagi menjadi bagian pencarian (dimana pencarian berlangsung) dan bagian potongan (yang tidak terlibat dalam pencarian). <br><br>  Satu server berisi informasi hanya pada satu shard.  Oleh karena itu, untuk melakukan pencarian pada indeks lengkap, Anda perlu mencari di delapan server yang berisi pecahan yang berbeda. <br><br>  Server dikelompokkan dalam kelompok.  Setiap klaster berisi delapan mesin pencari dan satu cuplikan. <br><br><img src="https://habrastorage.org/webt/1b/om/dl/1bomdlbzui-uxhswoq1kfq9h7os.jpeg"><br>  Database kunci-nilai dengan data statis sedang berjalan di server snippet.  Mereka diperlukan untuk mengeluarkan dokumen, misalnya, deskripsi kucing dengan alat pencicit.  Data secara khusus diambil pada server yang terpisah sehingga tidak memuat memori mesin pencari. <br><br>  Karena ID dokumen unik hanya dalam kerangka satu indeks, sebuah situasi dapat muncul bahwa tidak ada dokumen dalam snippet.  Baik atau bahwa pada satu ID akan ada konten lain.  Oleh karena itu, agar pencarian bekerja dan pencarian terjadi, suatu kebutuhan telah muncul untuk konsistensi seluruh cluster.  Saya akan berbicara tentang bagaimana kita memantau konsistensi sedikit kemudian. <br><br>  Pencarian itu sendiri diatur sebagai berikut: permintaan pencarian dapat datang ke salah satu dari delapan server.  Katakanlah dia datang ke server 1. Server ini memproses semua argumen dan mengerti apa dan bagaimana mencari.  Tergantung pada permintaan yang masuk, server dapat membuat permintaan tambahan ke layanan eksternal untuk informasi yang diperlukan.  Satu permintaan dapat diikuti hingga sepuluh permintaan ke layanan eksternal. <br><br>  Setelah mengumpulkan informasi yang diperlukan, pencarian dimulai pada database penawaran.  Untuk melakukan ini, subqueries dibuat untuk semua delapan server di cluster. <br><br>  Setelah menerima jawaban, hasilnya digabungkan.  Pada akhirnya, untuk menghasilkan masalah, Anda mungkin perlu beberapa subquery lagi ke server snippet. <br><br>  <b>Permintaan</b> pencarian dalam cluster adalah: <b>/ shard1? Teks = angry + cat</b> .  Selain itu, subqueries dari form: <b>/ status</b> secara konstan dibuat antara semua server di dalam cluster sekali per detik. <br><br>  Permintaan <b>/ status</b> mendeteksi situasi ketika server tidak tersedia. <br><br>  Ini juga mengontrol bahwa di semua server versi mesin pencari dan versi indeks adalah sama, jika tidak akan ada data yang tidak konsisten di dalam cluster. <br><br>  Terlepas dari kenyataan bahwa satu server cuplikan memproses permintaan dari delapan mesin pencari, prosesornya dimuat dengan sangat ringan.  Karenanya, sekarang kami mentransfer data cuplikan ke layanan terpisah. <br><br><img src="https://habrastorage.org/webt/3u/q5/ng/3uq5ngicgxwxg60diggqot7iiky.jpeg"><br><br>  Untuk mentransfer data, kami memperkenalkan kunci universal untuk dokumen.  Sekarang situasinya tidak mungkin ketika satu kunci mengembalikan konten dari dokumen lain. <br><br>  Namun transisi ke arsitektur lain belum lengkap.  Sekarang kami ingin menyingkirkan server cuplikan khusus.  Dan kemudian umumnya menjauh dari struktur cluster.  Ini akan memungkinkan kami untuk terus skala dengan mudah.  Bonus tambahan adalah penghematan zat besi yang signifikan. <br><br>  Dan sekarang untuk kisah-kisah menakutkan dengan akhir yang bahagia.  Pertimbangkan beberapa kasus tidak tersedianya server. <br><br><h4>  Mengerikan terjadi: satu server tidak tersedia </h4><br>  Katakanlah satu server tidak tersedia.  Kemudian server lain di cluster dapat terus merespons, tetapi hasil pencarian tidak akan lengkap. <br><br>  Melalui pemeriksaan status, server tetangga memahami bahwa ada yang tidak tersedia.  Oleh karena itu, untuk menjaga kelengkapan, semua server di kluster mulai menanggapi permintaan <b>/ ping</b> ke penyeimbang bahwa mereka juga tidak tersedia.  Ternyata semua server di cluster meninggal (yang tidak terjadi).  Ini adalah kelemahan utama dari skema cluster kami - oleh karena itu, kami ingin menjauh darinya. <br><br><img src="https://habrastorage.org/webt/hr/ko/2o/hrko2ovb9b5q2hjb8xqgnubynec.jpeg"><br><br>  Permintaan yang diakhiri dengan kesalahan, penyeimbang bertanya lagi di server lain. <br>  Selain itu, penyeimbang berhenti mengirim lalu lintas pengguna ke server yang mati, tetapi terus memeriksa statusnya. <br><br>  Ketika server menjadi tersedia, ia mulai merespons <b>/ ping</b> .  Segera setelah respons normal terhadap ping dari server mati mulai berdatangan, penyeimbang mulai mengirimkan lalu lintas pengguna ke sana.  Cluster dipulihkan, tepuk tangan. <br><br><h4>  Lebih buruk lagi: banyak server tidak tersedia </h4><br>  Sebagian besar server di pusat data terputus.  Apa yang harus dilakukan, ke mana harus lari?  Penyeimbang datang untuk menyelamatkan lagi.  Setiap penyeimbang secara konstan menyimpan dalam memori jumlah server saat ini.  Dia selalu mempertimbangkan jumlah maksimum lalu lintas yang dapat ditangani oleh pusat data saat ini. <br><br>  Ketika banyak server di pusat data jatuh, penyeimbang memahami bahwa pusat data ini tidak dapat memproses semua lalu lintas. <br><br>  Kemudian kelebihan lalu lintas mulai didistribusikan secara acak ke pusat data lainnya.  Semuanya berfungsi, semua orang senang. <br><br><img src="https://habrastorage.org/webt/cp/g-/if/cpg-ifevj3dzyvmedn1v-g5lzpg.jpeg"><br><h2>  Bagaimana kami melakukannya: rilis rilis </h2><br>  Sekarang tentang bagaimana kami mempublikasikan perubahan yang dilakukan pada layanan.  Di sini kami mengambil jalur proses perampingan: meluncurkan rilis baru hampir sepenuhnya otomatis. <br>  Ketika sejumlah perubahan diakumulasi dalam proyek, rilis baru secara otomatis dibuat dan perakitannya diluncurkan. <br><br><img src="https://habrastorage.org/webt/cy/to/0f/cyto0f3qhsuxs7bgd2momnccebe.jpeg"><br><br>  Kemudian layanan diluncurkan untuk pengujian, di mana stabilitas diperiksa. <br><br>  Pada saat yang sama, pengujian kinerja otomatis diluncurkan.  Dia terlibat dalam layanan khusus.  Saya tidak akan membicarakannya sekarang - deskripsinya layak untuk artikel terpisah. <br><br>  Jika publikasi dalam pengujian berhasil, publikasi rilis dalam prestable secara otomatis dimulai.  Prestable adalah gugus khusus tempat lalu lintas pengguna normal diarahkan.  Jika itu mengembalikan kesalahan, penyeimbang melakukan permintaan ulang dalam produksi. <br><br>  Dalam prestable, waktu respons diukur dan dibandingkan dengan rilis sebelumnya dalam produksi.  Jika semuanya baik-baik saja, maka orang tersebut menghubungkan: memeriksa grafik dan hasil pengujian beban dan kemudian mulai meluncurkan ke produksi. <br><br><h2>  Semua yang terbaik untuk pengguna: pengujian A / B </h2><br>  Tidak selalu jelas apakah perubahan dalam layanan akan membawa manfaat nyata.  Untuk mengukur manfaat perubahan, orang-orang datang dengan pengujian A / B.  Saya akan berbicara sedikit tentang cara kerjanya di pencarian Yandex.Market. <br><br>  Semuanya dimulai dengan penambahan parameter CGI baru yang mencakup fungsionalitas baru.  Biarkan parameter kami menjadi: <i>market_new_functionality = 1</i> .  Kemudian, dalam kode, aktifkan fungsi ini dengan tanda: <br><br><pre><code class="cpp hljs">If (cgi.experiments.market_new_functionality) { <span class="hljs-comment"><span class="hljs-comment">// enable new functionality }</span></span></code> </pre> <br>  Fungsionalitas baru diluncurkan dalam produksi. <br><br>  Ada layanan khusus untuk mengotomatisasi pengujian A / B, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Eksperimen dibuat dalam layanan.  Pangsa lalu lintas ditetapkan, misalnya, 15%.  Minat ditetapkan bukan untuk permintaan, tetapi untuk pengguna.  Waktu percobaan, misalnya, seminggu, juga ditunjukkan. <br><br>  Beberapa percobaan dapat dimulai secara bersamaan.  Di pengaturan, Anda dapat menentukan apakah persimpangan dengan eksperimen lain dimungkinkan. <br><br>  Akibatnya, layanan ini secara otomatis menambahkan argumen <i>market_new_functionality = 1</i> hingga 15% pengguna.  Dia juga secara otomatis menghitung metrik yang dipilih.  Setelah percobaan, analis melihat hasilnya dan menarik kesimpulan.  Berdasarkan temuan, keputusan dibuat untuk memulai dalam produksi atau penyempurnaan. <br><br><h2>  Tangan gesit pasar: pengujian produksi </h2><br>  Sering terjadi bahwa perlu untuk memeriksa operasi fungsi baru dalam produksi, tetapi tidak ada kepastian bagaimana itu akan berperilaku dalam kondisi "pertempuran" di bawah beban berat. <br><br>  Ada solusinya: flag dalam parameter CGI dapat digunakan tidak hanya untuk pengujian A / B, tetapi juga untuk menguji fungsionalitas baru. <br><br>  Kami membuat alat yang memungkinkan Anda untuk langsung mengubah konfigurasi pada ribuan server tanpa membuat layanan berisiko.  Ini disebut "Stop Crane."  Ide aslinya adalah kemampuan untuk dengan cepat mematikan beberapa fungsi tanpa tata letak.  Kemudian alat diperluas dan menjadi lebih kompleks. <br><br>  Skema layanan disajikan di bawah ini: <br><br><img src="https://habrastorage.org/webt/va/la/n8/valan8guj5dkld2j788pw7ytbwy.jpeg"><br><br>  API menetapkan nilai bendera.  Layanan manajemen menyimpan nilai-nilai ini dalam database.  Semua server pergi ke database sekali setiap sepuluh detik, memompa nilai-nilai bendera dan menerapkan nilai-nilai ini untuk setiap permintaan. <br><br>  Di Stop Crane, Anda dapat menetapkan dua jenis nilai: <br><br>  1) Ekspresi bersyarat.  Terapkan ketika salah satu nilai dieksekusi.  Sebagai contoh: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>:<span class="hljs-string"><span class="hljs-string">"IS_DC1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>: <span class="hljs-string"><span class="hljs-string">"CLUSTER==2 and IS_BERU"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"4!"</span></span> }</code> </pre> <br>  Nilai "3" akan diterapkan ketika permintaan diproses di lokasi DC1.  Dan nilainya adalah "4" ketika permintaan diproses pada cluster kedua untuk situs beru.ru. <br><br>  2) Nilai tanpa syarat.  Mereka digunakan secara default jika tidak ada kondisi yang terpenuhi.  Sebagai contoh: <br><br>  <i>nilai, nilai!</i> <br><br>  Jika nilai berakhir dengan tanda seru, itu diberikan prioritas yang lebih tinggi. <br><br>  Pengurai parameter CGI mem-parsing URL.  Kemudian terapkan nilai dari stop tap. <br><br>  Nilai dengan prioritas berikut berlaku: <br><br><ol><li>  Prioritas lebih tinggi dari stop tap (tanda seru). </li><li>  Nilai dari kueri. </li><li>  Nilai default adalah dari stop tap. </li><li>  Nilai default dalam kode. </li></ol><br>  Ada banyak flag yang ditunjukkan dalam nilai kondisional - mereka cukup untuk semua skenario yang kita ketahui: <br><br><ul><li>  Pusat data. </li><li>  Lingkungan: produksi, pengujian, bayangan. </li><li>  Tempat: pasar, beru. </li><li>  Nomor cluster. </li></ul><br>  Dengan alat ini, Anda dapat mengaktifkan fungsionalitas baru pada sekelompok server (misalnya, hanya dalam satu pusat data) dan memeriksa pengoperasian fungsi ini tanpa banyak risiko pada seluruh layanan.  Bahkan jika Anda secara serius membuat kesalahan di suatu tempat, semuanya mulai turun dan seluruh pusat data turun, penyeimbang akan mengarahkan permintaan ke pusat data lainnya.  Pengguna akhir tidak akan melihat apa pun. <br><br>  Jika Anda melihat masalah, Anda dapat segera mengembalikan nilai bendera sebelumnya, dan perubahan akan dibatalkan. <br><br>  Layanan ini memiliki kekurangan: pengembang sangat menyukainya dan sering mencoba untuk mendorong semua perubahan ke dalam Stop Crane.  Kami berusaha memerangi penyalahgunaan. <br><br>  Pendekatan Stop Crane berfungsi dengan baik ketika Anda sudah memiliki kode stabil, siap untuk diluncurkan dalam produksi.  Pada saat yang sama, Anda masih memiliki keraguan, dan Anda ingin memeriksa kode dalam kondisi "pertempuran". <br><br>  Namun, stopcock tidak cocok untuk pengujian selama pengembangan.  Untuk pengembang, ada cluster terpisah yang disebut "shadow cluster". <br><br><h2>  Pengujian Terselubung: Shadow Cluster </h2><br>  Permintaan dari salah satu kelompok digandakan ke kelompok bayangan.  Tetapi penyeimbang benar-benar mengabaikan tanggapan dari gugus ini.  Skema karyanya disajikan di bawah ini. <br><br><img src="https://habrastorage.org/webt/ie/xt/dp/iextdpgmvcam7ehqatcbwdjyjxe.jpeg"><br><br>  Kami mendapatkan kelompok uji yang dalam kondisi "pertempuran" nyata.  Lalu lintas pengguna normal terbang di sana.  Perangkat keras di kedua cluster adalah sama, sehingga Anda dapat membandingkan kinerja dan kesalahan. <br><br>  Dan karena penyeimbang sepenuhnya mengabaikan jawaban, pengguna akhir tidak akan melihat respons dari kelompok bayangan.  Karena itu, tidak menakutkan untuk melakukan kesalahan. <br><br><h2>  Kesimpulan </h2><br>  Jadi, bagaimana kami membangun pencarian Pasar? <br><br>  Agar semuanya berjalan lancar, kami memisahkan fungsionalitas menjadi layanan terpisah.  Jadi, Anda hanya dapat menskala komponen-komponen yang kami butuhkan dan membuat komponen lebih sederhana.  Sangat mudah untuk memberikan komponen terpisah kepada tim lain dan berbagi tanggung jawab untuk mengerjakannya.  Dan penghematan yang signifikan dalam zat besi dengan pendekatan ini merupakan nilai tambah yang jelas. <br><br>  Shadow cluster juga membantu kami: Anda dapat mengembangkan layanan, mengujinya dalam proses dan pada saat yang sama tidak mengganggu pengguna. <br><br>  Baik dan periksa produksi, tentu saja.  Perlu mengubah konfigurasi pada seribu server?  Mudah, gunakan stop crane.  Jadi, Anda dapat segera meluncurkan solusi kompleks yang sudah jadi dan mengembalikan ke versi stabil jika muncul masalah. <br><br>  Saya harap saya bisa menunjukkan bagaimana kita membuat Pasar cepat dan stabil dengan basis penawaran yang terus berkembang.  Bagaimana mengatasi masalah server, menangani sejumlah besar permintaan, meningkatkan fleksibilitas layanan dan melakukan ini tanpa mengganggu proses kerja. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475848/">https://habr.com/ru/post/id475848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475834/index.html">Scrum tidak akan membantu Anda. Kami mengerti mengapa</a></li>
<li><a href="../id475836/index.html">Wawancara dengan Arthur Khachuyan: bagaimana cara menghitung miliarder di jejaring sosial?</a></li>
<li><a href="../id475838/index.html">MENGUBAH orang. Atau ... ubah Orang. Tentang cara "melepas" proyek transformasi</a></li>
<li><a href="../id475840/index.html">Badoo Jira API Client: magic in Jira dalam PHP</a></li>
<li><a href="../id475842/index.html">Mengganti URL Tindakan & URI di telepon SIP atau mengelola melalui websockets?</a></li>
<li><a href="../id475850/index.html">Bagaimana memulai membangun karir di bidang IT, jika Anda belum memiliki pengalaman</a></li>
<li><a href="../id475854/index.html">JDBC pools dan penanganan file yang efisien: Java mitap 3 Desember di St. Petersburg</a></li>
<li><a href="../id475856/index.html">Google App Script, Mikrotik, Telegram dan VPNBook mulai memainkan kuartet</a></li>
<li><a href="../id475858/index.html">Menghibur energi crypto: panas penambangan untuk manusia dan panas manusia untuk penambangan</a></li>
<li><a href="../id475860/index.html">Apache NiFi. 28 November di ruang kuliah Deworkacy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>