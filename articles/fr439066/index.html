<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ω ‚ôêÔ∏è üë®üèø‚Äçüé§ Syst√®me d'exploitation sur Rust. M√©moire de page: Avanc√© ‚úçüèª ‚è±Ô∏è üèôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article explique comment le noyau du syst√®me d'exploitation peut acc√©der aux trames de m√©moire physique. Nous √©tudierons la fonction de conversion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®me d'exploitation sur Rust. M√©moire de page: Avanc√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/">  Cet article explique comment le noyau du syst√®me d'exploitation peut acc√©der aux trames de m√©moire physique.  Nous √©tudierons la fonction de conversion des adresses virtuelles en adresses physiques.  Nous d√©couvrirons √©galement comment cr√©er de nouveaux mappages dans les tableaux de pages. <br><br>  Ce blog est publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Si vous avez des questions ou des probl√®mes, ouvrez-y le ticket correspondant.  Toutes les sources de l'article sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h1>  Pr√©sentation </h1><br>  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article,</a> nous avons d√©couvert les principes de la m√©moire de pagination et le fonctionnement des tables de pages √† quatre niveaux sur x86_64.  Nous avons √©galement constat√© que le chargeur avait d√©j√† configur√© la hi√©rarchie des tables de pages pour notre noyau, donc le noyau s'ex√©cute sur des adresses virtuelles.  Cela am√©liore la s√©curit√©, mais le probl√®me se pose: comment acc√©der aux adresses physiques r√©elles qui sont stock√©es dans les entr√©es de table de pages ou le <code>CR3</code> ? <br><a name="habracut"></a><br>  Dans la premi√®re section de l'article, nous discuterons du probl√®me et des diff√©rentes approches pour le r√©soudre.  Ensuite, nous impl√©mentons une fonction qui se faufile √† travers la hi√©rarchie des tables de pages pour convertir des adresses virtuelles en adresses physiques.  Enfin, apprenez √† cr√©er de nouveaux mappages dans les tableaux de pages et √† trouver des cadres de m√©moire inutilis√©s pour cr√©er de nouveaux tableaux. <br><br><h2>  Mises √† jour des d√©pendances </h2><br>  Pour fonctionner, vous avez besoin de <code>x86_64</code> version 0.4.0 ou ult√©rieure.  Mettez √† jour la d√©pendance dans notre <code>Cargo.toml</code> : <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1>  Acc√®s aux tableaux de pages </h1><br>  Acc√©der aux tables de pages √† partir du noyau n'est pas aussi simple qu'il y para√Æt.  Pour comprendre le probl√®me, jetez un autre coup d'≈ìil √† la hi√©rarchie des tables √† quatre niveaux de l'article pr√©c√©dent: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  L'important est que chaque entr√©e de page stocke l'adresse <i>physique</i> du tableau suivant.  Cela √©vite la traduction de ces adresses, ce qui r√©duit les performances et conduit facilement √† des boucles sans fin. <br><br>  Le probl√®me est que nous ne pouvons pas acc√©der directement aux adresses physiques √† partir du noyau, car cela fonctionne √©galement sur les adresses virtuelles.  Par exemple, lorsque nous allons √† l'adresse <code>4 KiB</code> , nous avons acc√®s √† l'adresse <i>virtuelle</i> <code>4 KiB</code> , et non √† l'adresse <i>physique</i> o√π est stock√© le tableau des pages du 4e niveau.  Si nous voulons acc√©der √† l'adresse physique de <code>4 KiB</code> , nous devons utiliser une adresse virtuelle, qui est traduite en elle. <br><br>  Par cons√©quent, pour acc√©der aux cadres des tables de pages, vous devez mapper certaines pages virtuelles √† ces cadres.  Il existe diff√©rentes fa√ßons de cr√©er de tels mappages. <br><br>  1. Une solution simple est l' <b>affichage identique de tous les tableaux de pages</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Dans cet exemple, nous voyons l'affichage identique des images.  Les adresses physiques des tables de pages sont en m√™me temps des adresses virtuelles valides, afin que nous puissions facilement acc√©der aux tables de pages de tous les niveaux, √† commencer par le registre CR3. <br><br>  Cependant, cette approche encombre l'espace d'adressage virtuel et rend difficile de trouver de grandes zones contigu√´s de m√©moire libre.  Disons que nous voulons cr√©er une zone de m√©moire virtuelle de 1000 Ko dans la figure ci-dessus, par exemple, pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afficher un fichier en m√©moire</a> .  Nous ne pouvons pas commencer par la r√©gion des <code>28  KiB</code> , car elle repose sur une page d√©j√† occup√©e √† <code>1004  KiB</code> .  Par cons√©quent, vous devrez regarder plus loin jusqu'√† ce que nous trouvions un grand fragment appropri√©, par exemple, avec <code>1008  KiB</code> .  Il y a le m√™me probl√®me de fragmentation que dans la m√©moire segment√©e. <br><br>  De plus, la cr√©ation de nouveaux tableaux de pages est beaucoup plus compliqu√©e, car nous devons trouver des cadres physiques dont les pages correspondantes ne sont pas encore utilis√©es.  Par exemple, pour notre fichier, nous avons r√©serv√© une zone de 1000 Ko de m√©moire <i>virtuelle</i> , √† partir de l'adresse <code>1008  KiB</code> .  Maintenant, nous ne pouvons plus utiliser de trame avec une adresse physique comprise entre <code>1000  KiB</code> et <code>2008  KiB</code> , car elle ne peut pas √™tre affich√©e de mani√®re identique. <br><br>  2. Une autre option consiste √† <b>diffuser des tableaux de pages uniquement temporairement</b> lorsque vous devez y acc√©der.  Pour les comparaisons temporaires, un affichage identique de la seule table de premier niveau est requis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br>  Sur cette figure, une table de niveau 1 g√®re les 2 premiers Mo d'espace d'adressage virtuel.  Cela est possible car l'acc√®s √† partir du registre CR3 se fait par z√©ro entr√©e dans les tables des niveaux 4, 3 et 2. L'enregistrement avec l'index <b>8</b> traduit la page virtuelle √† <code>32 KiB</code> en une trame physique √† <code>32 KiB</code> , identifiant ainsi la table de niveau 1 elle-m√™me. Dans la figure, cela est indiqu√© par une fl√®che horizontale. <br><br>  En √©crivant dans la table de niveau 1 √† mappage identique, notre noyau peut cr√©er jusqu'√† 511 comparaisons temporelles (512 moins l'enregistrement n√©cessaire pour le mappage d'identit√©).  Dans l'exemple ci-dessus, le noyau correspondait √† l'enregistrement nul d'une table de niveau 1 avec une trame √† <code>24 KiB</code> .  Cela a cr√©√© un mappage temporaire de la page virtuelle √† <code>0 KiB</code> au cadre physique du tableau de niveau de la page 2 indiqu√© par la fl√®che en pointill√©s.  Maintenant, le noyau peut acc√©der √† la table de niveau 2 en √©crivant sur une page qui commence √† <code>0 KiB</code> . <br><br>  Ainsi, l'acc√®s √† un cadre arbitraire de la table des pages avec des mappages temporaires comprend les actions suivantes: <br><br><ul><li>  Trouvez une entr√©e gratuite dans le tableau de niveau 1 affich√© de mani√®re identique. <br></li><li>  Mappez cette entr√©e au cadre physique du tableau de pages auquel nous voulons acc√©der. <br></li><li>  Acc√©dez √† ce cadre via la page virtuelle associ√©e √† l'entr√©e. <br></li><li>  Red√©finissez l'enregistrement sur inutilis√©, supprimant ainsi le mappage temporaire. </li></ul><br>  Avec cette approche, l'espace d'adressage virtuel reste propre, car les m√™mes 512 pages virtuelles sont constamment utilis√©es.  L'inconv√©nient est une certaine lourdeur, d'autant plus qu'une nouvelle comparaison peut n√©cessiter de modifier plusieurs niveaux de la table, c'est-√†-dire que nous devons r√©p√©ter le processus d√©crit plusieurs fois. <br><br>  3. Bien que les deux approches ci-dessus fonctionnent, il existe une troisi√®me m√©thode: <b>les tableaux de pages r√©cursifs</b> .  Il combine les avantages des deux approches: il compare constamment tous les cadres des tables de pages sans n√©cessiter de comparaisons temporaires, et conserve √©galement les pages mapp√©es c√¥te √† c√¥te, √©vitant la fragmentation de l'espace d'adressage virtuel.  C'est la m√©thode que nous utiliserons. <br><br><h2>  Tables de pages r√©cursives </h2><br>  L'id√©e est de traduire certains enregistrements de la table de quatri√®me niveau en elle-m√™me.  Ainsi, nous r√©servons en fait une partie de l'espace d'adressage virtuel et mappons tous les cadres de table actuels et futurs √† cet espace. <br><br>  Regardons un exemple pour comprendre comment tout cela fonctionne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  La seule diff√©rence avec l'exemple au d√©but de l'article est un enregistrement suppl√©mentaire avec l'index <code>511</code> dans la table de niveau 4, qui est mapp√© √† la trame physique <code>4 KiB</code> , qui se trouve dans cette table elle-m√™me. <br><br>  Lorsque le processeur va sur cet enregistrement, il ne fait pas r√©f√©rence √† la table de niveau 3, mais se r√©f√®re √† nouveau √† la table de niveau 4. Ceci est similaire √† une fonction r√©cursive qui s'appelle elle-m√™me.  Il est important que le processeur suppose que chaque entr√©e de la table de niveau 4 pointe vers une table de niveau 3. Par cons√©quent, il traite maintenant la table de niveau 4 comme une table de niveau 3. Cela fonctionne car les tables de tous les niveaux dans x86_64 ont la m√™me structure. <br><br>  En suivant une ou plusieurs fois un enregistrement r√©cursif avant de d√©marrer la conversion r√©elle, nous pouvons effectivement r√©duire le nombre de niveaux que le processeur traverse.  Par exemple, si nous suivons une fois l'enregistrement r√©cursif, puis passons √† la table de niveau 3, le processeur pense que la table de niveau 3 est une table de niveau 2. En poursuivant, il consid√®re la table de niveau 2 comme une table de niveau 1 et la table de niveau 1 comme mapp√©e trame dans la m√©moire physique.  Cela signifie que nous pouvons maintenant lire et √©crire dans la table de niveau de page 1 car le processeur pense qu'il s'agit d'un cadre mapp√©.  La figure ci-dessous montre les cinq √©tapes d'une telle traduction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  De m√™me, nous pouvons suivre une entr√©e r√©cursive deux fois avant de d√©marrer la conversion pour r√©duire le nombre de niveaux pass√©s √† deux: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Passons en revue cette proc√©dure √©tape par √©tape.  Tout d'abord, le CPU suit une entr√©e r√©cursive dans la table de niveau 4 et pense qu'il a atteint la table de niveau 3. Ensuite, il suit √† nouveau l'enregistrement r√©cursif et pense qu'il a atteint le niveau 2. Mais en r√©alit√©, il est toujours au niveau 4. Ensuite, le CPU va √† la nouvelle adresse et entre dans la table de niveau 3, mais pense qu'il est d√©j√† dans la table de niveau 1. Enfin, au point d'entr√©e suivant dans la table de niveau 2, le processeur pense qu'il a acc√©d√© √† la trame de m√©moire physique.  Cela nous permet de lire et d'√©crire dans une table de niveau 2. <br><br>  Les tables des niveaux 3 et 4 sont √©galement accessibles. Pour acc√©der √† la table du niveau 3, nous suivons un enregistrement r√©cursif trois fois: le processeur pense qu'il est d√©j√† dans la table du niveau 1, et √† l'√©tape suivante, nous atteignons le niveau 3, que le CPU consid√®re comme un cadre mapp√©.  Pour acc√©der √† la table de niveau 4 elle-m√™me, nous suivons simplement l'enregistrement r√©cursif quatre fois jusqu'√† ce que le processeur traite la table de niveau 4 elle-m√™me comme un cadre mapp√© (en bleu dans la figure ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Le concept est difficile √† comprendre au d√©but, mais dans la pratique, il fonctionne plut√¥t bien. <br><br><h4>  Calcul d'adresse </h4><br>  Ainsi, nous pouvons acc√©der aux tables de tous les niveaux en suivant une ou plusieurs fois un enregistrement r√©cursif.  √âtant donn√© que les index des tables de quatre niveaux sont d√©riv√©s directement de l'adresse virtuelle, des adresses virtuelles sp√©ciales doivent √™tre cr√©√©es pour cette m√©thode.  Comme nous le rappelons, les index des tables de pages sont extraits de l'adresse comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Supposons que nous voulons acc√©der √† un tableau de niveau 1 qui affiche une page sp√©cifique.  Comme nous l'avons appris ci-dessus, vous devez passer par un enregistrement r√©cursif une fois, puis par les indices des 4e, 3e et 2e niveaux.  Pour ce faire, nous d√©pla√ßons tous les blocs d'adresse d'un bloc vers la droite et mettons l'index de l'enregistrement r√©cursif √† la place de l'index initial de niveau 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Pour acc√©der au tableau de niveau 2 de cette page, nous d√©pla√ßons tous les blocs d'index deux blocs vers la droite et d√©finissons l'index r√©cursif √† la place des deux blocs source: niveau 4 et niveau 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Pour acc√©der au tableau de niveau 3, on fait de m√™me, on d√©cale juste √† droite d√©j√† trois blocs d'adresse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Enfin, pour acc√©der √† la table de niveau 4, d√©placez les quatre blocs vers la droite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Vous pouvez maintenant calculer des adresses virtuelles pour les tables de pages des quatre niveaux.  Nous pouvons m√™me calculer une adresse qui pointe exactement vers une entr√©e de table de pages sp√©cifique en multipliant son index par 8, la taille de l'entr√©e de table de pages. <br><br>  Le tableau ci-dessous montre la structure des adresses pour acc√©der √† diff√©rents types de trames: <br><br><table><thead><tr><th>  Adresse virtuelle pour </th><th>  Structure d'adresse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octale</a> ) </th></tr></thead><tbody><tr><td>  La page </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entr√©e dans le tableau de niveau 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entr√©e dans une table de niveau 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entr√©e dans une table de niveau 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entr√©e dans le tableau de niveau 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Ici, <code></code> est l'indice de niveau 4, <code></code> est de niveau 3, <code></code> est de niveau 2 et <code>DDD</code> est l'indice de niveau 1 pour la trame affich√©e, <code>EEEE</code> est son d√©calage.  <code>RRR</code> est l'indice de l'enregistrement r√©cursif.  Un index (trois chiffres) est converti en d√©calage (quatre chiffres) en multipliant par 8 (la taille de l'entr√©e du tableau de pages).  Avec ce d√©calage, l'adresse r√©sultante pointe directement vers l'entr√©e de table de pages correspondante. <br><br>  <code>SSSS</code> sont des bits d'extension du chiffre sign√©, c'est-√†-dire qu'ils sont tous des copies du bit 47. Il s'agit d'une exigence sp√©ciale pour les adresses valides dans l'architecture x86_64, dont nous avons discut√© dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> . <br><br>  Les adresses sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octales</a> , car chaque caract√®re octal repr√©sente trois bits, ce qui vous permet de s√©parer clairement les index de 9 bits des tables √† diff√©rents niveaux.  Ce n'est pas possible dans le syst√®me hexad√©cimal, o√π chaque caract√®re repr√©sente quatre bits. <br><br><h2>  Impl√©mentation </h2><br>  Apr√®s toute cette th√©orie, nous pouvons enfin proc√©der √† la mise en ≈ìuvre.  Id√©alement, le chargeur a g√©n√©r√© non seulement des tables de pages, mais √©galement un affichage r√©cursif dans le dernier enregistrement de la table de niveau 4. Le chargeur l'a fait car sinon il y aurait un probl√®me de poule ou d'oeuf: nous devons acc√©der √† la table de niveau 4 pour cr√©er une carte r√©cursive mais nous ne pouvons y acc√©der sans aucun affichage. <br><br>  Nous avons d√©j√† utilis√© ce mappage r√©cursif √† la fin de l'article pr√©c√©dent pour acc√©der √† la table de niveau 4 via l'adresse cod√©e en dur <code>0xffff_ffff_ffff_f000</code> .  Si nous convertissons cette adresse en octal et la comparons avec le tableau ci-dessus, nous verrons qu'elle correspond exactement √† la structure de l'enregistrement dans le tableau de niveau 4 avec <code>RRR</code> = <code>0o777</code> , <code>AAAA</code> = <code>0</code> et les bits d'extension du signe <code>1</code> : <br><br><pre>  structure: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
 adresse: 0o_177777_777_777_777_777_0000 </pre><br>  Gr√¢ce √† la connaissance des tables r√©cursives, nous pouvons d√©sormais cr√©er des adresses virtuelles pour acc√©der √† toutes les tables actives.  Et faites la fonction de diffusion. <br><br><h3>  Traduction d'adresse </h3><br>  Dans un premier temps, cr√©ez une fonction qui convertit une adresse virtuelle en une adresse physique, en passant par la hi√©rarchie des tables de pages: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br>  Tout d'abord, nous introduisons des variables pour l'index r√©cursif (511 = <code>0o777</code> ) et les bits d'extension de signe (chacun est 1).  Ensuite, nous calculons les index des tables de pages et le d√©calage par le biais d'op√©rations au niveau du bit, comme indiqu√© dans l'illustration: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  L'√©tape suivante consiste √† calculer les adresses virtuelles des quatre tables de pages, comme d√©crit dans la section pr√©c√©dente.  Ensuite, dans la fonction, nous convertissons chacune de ces adresses en liens <code>PageTable</code> .  Ce sont des op√©rations dangereuses car le compilateur ne peut pas savoir que ces adresses sont valides. <br><br>  Apr√®s avoir calcul√© l'adresse, nous utilisons l'op√©rateur d'index pour afficher l'enregistrement dans la table de niveau 4. Si cet enregistrement est nul, il n'y a pas de table de niveau 3 pour cet enregistrement de niveau 4. Cela signifie que <code>addr</code> mapp√© √† aucune m√©moire physique.  Nous retournons donc <code>None</code> .  Sinon, nous savons qu'il existe une table de niveau 3.  Ensuite, nous r√©p√©tons la proc√©dure, comme au niveau pr√©c√©dent. <br><br>  Apr√®s avoir v√©rifi√© trois pages d'un niveau sup√©rieur, nous pouvons enfin lire l'enregistrement de la table de niveau 1, qui nous indique le cadre physique avec lequel l'adresse est mapp√©e.  Comme derni√®re √©tape, ajoutez-y le d√©calage de page - et renvoyez l'adresse. <br><br>  Si nous savions avec certitude que l'adresse √©tait mapp√©e, nous pourrions acc√©der directement √† la table de niveau 1 sans regarder les pages d'un niveau sup√©rieur.  Mais comme nous ne le savons pas, nous devons d'abord v√©rifier si une table de niveau 1 existe, sinon notre fonction renverra une erreur de page manquante pour les adresses sans correspondance. <br><br><h4>  Essayez </h4><br>  Essayons d'utiliser la fonction de traduction des adresses virtuelles dans notre fonction <code>_start</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br>  Apr√®s le d√©marrage, nous voyons le r√©sultat suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br>  Comme pr√©vu, l'adresse 0xb8000 associ√©e √† l'identifiant se traduit par la m√™me adresse physique.  La page de codes et la page de pile sont converties en quelques adresses physiques arbitraires, qui d√©pendent de la fa√ßon dont le chargeur a cr√©√© le mappage initial pour notre noyau. <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64 fournit un type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>RecursivePageTable</code></a> qui impl√©mente des abstractions s√ªres pour diverses op√©rations de table de pages.  En utilisant ce type, vous pouvez impl√©menter la fonction <code>translate_addr</code> mani√®re beaucoup plus succincte: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  Le type <code>RecursivePageTable</code> encapsule enti√®rement l'analyse non s√©curis√©e des tables de pages, de sorte que le code <code>unsafe</code> de la fonction <code>translate_addr</code> n'est plus n√©cessaire.  La fonction <code>init</code> reste dangereuse en raison de la n√©cessit√© de garantir l'exactitude du <code>level_4_table_addr</code> pass√©. <br><br>  Notre fonction <code>_start</code> doit √™tre mise √† jour pour signer √† nouveau la fonction comme suit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>  Maintenant, au lieu de transmettre <code>LEVEL_4_TABLE_ADDR</code> √† <code>translate_addr</code> et d'acc√©der aux tables de pages via des pointeurs bruts non s√©curis√©s, nous transmettons des r√©f√©rences au type <code>RecursivePageTable</code> .  Ainsi, nous avons maintenant une abstraction s√ªre et une s√©mantique claire de la propri√©t√©.  Cela garantit que nous ne serons pas en mesure de modifier accidentellement la table des pages en acc√®s partag√©, car sa modification n√©cessite la possession exclusive de <code>RecursivePageTable</code> . <br><br>  Cette fonction donne le m√™me r√©sultat que la fonction de traduction originale √©crite manuellement. <br><br><h4>  Rendre les fonctionnalit√©s dangereuses plus s√ªres </h4><br> <code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est une fonction dangereuse: elle n√©cessite un bloc pour l'appeler </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car l'appelant doit garantir que certaines conditions sont remplies. Dans notre cas, l'exigence est que l'adresse transmise soit pr√©cis√©ment mapp√©e √† la trame physique de la table de pages de niveau 4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corps entier de la fonction non s√©curis√©e est plac√© </font><font style="vertical-align: inherit;">dans le bloc </font><font style="vertical-align: inherit;">afin que toutes sortes d'op√©rations soient effectu√©es sans cr√©er de blocs suppl√©mentaires </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par cons√©quent, nous n'avons pas besoin d'un bloc dangereux pour le d√©r√©f√©rencement </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me est que nous ne voyons pas imm√©diatement quelles pi√®ces sont dangereuses. </font><font style="vertical-align: inherit;">Par exemple, sans regarder la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finition d'une fonction,</font></font></a> <code>RecursivePageTable::new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous ne pouvons pas dire si elle est s√ªre ou non. </font><font style="vertical-align: inherit;">Il est donc tr√®s facile de sauter accidentellement du code dangereux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©viter ce probl√®me, vous pouvez ajouter une fonction int√©gr√©e s√©curis√©e:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le bloc est √† </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau requis pour le d√©r√©f√©rencement </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et nous voyons imm√©diatement que ce sont les seules op√©rations dangereuses. </font><font style="vertical-align: inherit;">Rust a actuellement un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ouvert </font><font style="vertical-align: inherit;">pour modifier cette propri√©t√© infructueuse des fonctions dangereuses.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©er une nouvelle cartographie </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous lisons les tables de pages et cr√©ons la fonction de conversion, l'√©tape suivante consiste √† cr√©er un nouveau mappage dans la hi√©rarchie des tables de pages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La complexit√© de cette op√©ration d√©pend de la page virtuelle que nous voulons afficher. Dans le cas le plus simple, un tableau de pages de niveau 1 existe d√©j√† pour cette page, et il suffit de faire une entr√©e. Dans le cas le plus difficile, la page se trouve dans la zone m√©moire pour laquelle le niveau 3 n'existe pas encore, vous devez donc d'abord cr√©er de nouvelles tables de niveau 3, niveau 2 et niveau 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par un cas simple lorsque vous n'avez pas besoin de cr√©er de nouvelles tables. Le chargeur est charg√© dans le premier m√©gaoctet de l'espace d'adressage virtuel, nous savons donc que pour cette r√©gion, il existe une table de niveau 1. Pour notre exemple, nous pouvons s√©lectionner n'importe quelle page inutilis√©e dans cette zone de m√©moire, par exemple, la page √† l'adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous utilisons le </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cadre du tampon de texte VGA </font><font style="vertical-align: inherit;">comme cadre souhait√© </font><font style="vertical-align: inherit;">. Il est si facile de v√©rifier le fonctionnement de notre traduction d'adresses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous l'impl√©mentons dans une nouvelle fonction </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du module </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction accepte une r√©f√©rence mutable √† </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(elle la changera) et </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui est expliqu√© ci-dessous. Ensuite, il applique la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le bac </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour mapper la page √† l'adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le cadre physique √† l'adresse </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La fonction n'est pas s√ªre, car il est possible de violer la s√©curit√© de la m√©moire avec des arguments non valides. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus des arguments </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la fonction </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend deux autres arguments. Le troisi√®me argument est l'ensemble des indicateurs de la table de pages. Nous d√©finissons le drapeau </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessaire pour toutes les entr√©es valides et le drapeau </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour l'√©criture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le quatri√®me argument devrait √™tre une structure qui impl√©mente le trait </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cet argument est n√©cessaire √† la m√©thode.</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car la cr√©ation de nouveaux tableaux de pages peut n√©cessiter des cadres inutilis√©s. La mise en </font><font style="vertical-align: inherit;">≈ìuvre n√©cessite le trait d'argument </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que les </font><font style="vertical-align: inherit;">types </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PhysFrame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">universels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le trait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PageSize</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le </font><font style="vertical-align: inherit;">travail avec 4 pages standards Kio et pages √©normes 2 MiB / 1 Gio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √©chouer, elle revient donc </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme il ne s'agit que d'un exemple de code qui ne devrait pas √™tre fiable, nous l'utilisons simplement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec panique lorsqu'une erreur se produit. En cas de succ√®s, la fonction renvoie un type </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui fournit un moyen simple d'effacer la page r√©cemment mise en correspondance de la m√©thode TLB (associative translation buffer) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le type utilise l'attribut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>#[must_use]</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et √©met un avertissement si nous oublions accidentellement de l'appliquer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous savons que l'adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne n√©cessite pas de nouvelles tables de pages, elle </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut toujours revenir </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour tester la fonction, cr√©ez ceci </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Si l'erreur ¬´la m√©thode </font></font><code>allocate_frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est pas membre de trait </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font><font style="vertical-align: inherit;">appara√Æt </font><font style="vertical-align: inherit;">, vous devez mettre </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">niveau </font><font style="vertical-align: inherit;">vers la version 0.4.0.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant tester la nouvelle fonction de traduction:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous cr√©ons un mappage pour la page √† l'adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en appelant la fonction </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un lien mutable vers l'instance </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela traduit la page </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un tampon de texte VGA, donc nous verrons un r√©sultat √† l'√©cran. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous √©crivons une valeur dans cette page </font></font><code>0xf021f077f065f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui correspond √† la ligne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Nouveau!" </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur fond blanc. </font><font style="vertical-align: inherit;">Vous n'avez tout simplement pas besoin d'√©crire cette valeur imm√©diatement en haut de la page </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car la ligne sup√©rieure se d√©placera ensuite √† partir de l'√©cran </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'√©crira avec un d√©calage </font></font><code>0x900</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situ√© approximativement au milieu de l'√©cran. </font><font style="vertical-align: inherit;">Comme nous le savons dans l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´Mode texte VGA¬ª</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'√©criture dans le tampon VGA doit √™tre volatile, nous utilisons donc la m√©thode </font></font><code>write_volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque nous l'ex√©cutons dans QEMU, nous voyons ceci: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'inscription √† l'√©cran. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code a fonctionn√© car il y avait d√©j√† une table de niveau 1 pour afficher la page </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous essayons de traduire une page pour laquelle une telle table n'existe pas encore, la fonction </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renverra une erreur, car elle essaiera de s√©lectionner des cadres pour cr√©er de nouvelles tables de pages </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous verrons cela si nous essayons de traduire la page </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au lieu de </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(‚Ä¶) { [‚Ä¶] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au d√©marrage, une panique commence avec le message d'erreur suivant: </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> paniqu√© √† 'map_to a √©chou√©: FrameAllocationFailed', /.../result.rs:999haps </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher les pages qui n'ont pas encore de table de niveau 1, vous devez cr√©er la bonne </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais comment savoir quelles images sont libres et combien de m√©moire physique est disponible?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informations de d√©marrage </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rents ordinateurs ont diff√©rentes quantit√©s de m√©moire physique et diff√©rentes zones r√©serv√©es par des p√©riph√©riques tels que VGA diff√®rent. Seul le micrologiciel BIOS ou UEFI sait exactement quelles zones de m√©moire peuvent √™tre utilis√©es et lesquelles sont r√©serv√©es. Les deux normes de micrologiciel fournissent des fonctions pour obtenir une carte d'allocation de m√©moire, mais elles ne peuvent √™tre appel√©es qu'au tout d√©but du t√©l√©chargement. Par cons√©quent, notre chargeur de d√©marrage a d√©j√† demand√© ces informations (et d'autres) au BIOS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transmettre des informations au noyau de l'OS, le chargeur comme argument lors de l'appel de la fonction </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donne un lien vers la structure d'information du d√©marrage. Ajoutez cet argument √† notre fonction:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La structure est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>BootInfo</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toujours en cours de finalisation, alors ne soyez pas surpris lorsqu'elle se bloque lors de la mise √† niveau vers les futures versions du chargeur de d√©marrage qui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seront </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">pas compatibles avec semver</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Ä l'heure actuelle , </font><font style="vertical-align: inherit;">il a trois champs </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le champ </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient une adresse virtuelle r√©cursive de la table des pages de niveau 4. Gr√¢ce √† cela, il n'est pas n√©cessaire d'enregistrer l'adresse en dur </font></font><code>0o_177777_777_777_777_777_0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le champ </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est le plus int√©ressant, car il contient une liste de toutes les zones de m√©moire et leur type (inutilis√©, r√©serv√© ou autres).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le champ </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est la fonction actuelle pour associer des donn√©es suppl√©mentaires au chargeur. </font><font style="vertical-align: inherit;">L'impl√©mentation n'est pas termin√©e, nous pouvons donc l'ignorer pour l'instant.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'utiliser le champ </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour cr√©er le bon </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous voulons garantir le bon type d'argument </font></font><code>boot_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Macro </font></font><code>entry_point</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'elle </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est appel√©e en externe, la signature de la fonction n'est pas v√©rifi√©e. </font><font style="vertical-align: inherit;">Cela signifie que des arguments arbitraires n'entra√Æneront pas d'erreurs de compilation, mais peuvent provoquer un blocage ou un comportement d'ex√©cution non d√©fini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour v√©rifier la signature, la caisse </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour d√©finir la fonction Rust comme point d'entr√©e utilise une macro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>entry_point</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec des types valid√©s. </font><font style="vertical-align: inherit;">Nous r√©√©crivons notre fonction pour cette macro:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; [‚Ä¶] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le point d'entr√©e, vous n'avez plus besoin d'utiliser </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puisque la macro d√©finit le v√©ritable point d'entr√©e de bas niveau </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La fonction est </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant devenue une fonction Rust compl√®tement normale, nous pouvons donc lui donner un nom arbitraire. </font><font style="vertical-align: inherit;">Il est important qu'il soit d√©j√† tap√©, afin qu'une erreur de compilation se produise si vous modifiez la signature de la fonction, par exemple, en ajoutant un argument ou en changeant son type. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que nous envoyons maintenant √† une </font></font><code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adresse cod√©e en dur, mais </font></font><code>boot_info.p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ainsi, le code fonctionnera m√™me si la future version du chargeur de d√©marrage s√©lectionne une autre entr√©e dans la table du niveau de page 4 pour un affichage r√©cursif.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√©lection du cadre </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, gr√¢ce aux informations du BIOS, nous avons acc√®s √† la carte d'allocation de m√©moire, afin que vous puissiez faire un distributeur de trame normal. </font><font style="vertical-align: inherit;">Commen√ßons par le squelette g√©n√©ral:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le champ est </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initialis√© par un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it√©rateur de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trame </font><font style="vertical-align: inherit;">arbitraire </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela vous permet de simplement d√©l√©guer des appels </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la m√©thode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'initialisation </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a lieu dans une nouvelle fonction </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette fonction, √† l'aide d'un combinateur, convertit la carte d'allocation de m√©moire d'origine en un it√©rateur des trames physiques utilis√©es: </font></font><br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> range</a> Rust          . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La troisi√®me √©tape est la plus difficile: nous convertissons chaque plage en it√©rateur en utilisant la m√©thode </font></font><code>into_iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis s√©lectionnons chaque 4096e adresse avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>step_by</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque la taille de la page est de 4096 octets (4 Ko), nous obtenons l'adresse du d√©but de chaque trame. </font><font style="vertical-align: inherit;">La page du chargeur aligne toutes les zones de m√©moire utilis√©es, nous n'avons donc pas besoin d'un code d'alignement ou d'arrondi. </font><font style="vertical-align: inherit;">Remplacer </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flat_map</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous obtenons √† la </font></font><code>Iterator&lt;Item = u64&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place </font></font><code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade final, nous convertirons les adresses de d√©part en types </font></font><code>PhysFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin de construire celle qui est requise </font></font><code>Iterator&lt;Item = PhysFrame&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Utilisez ensuite cet it√©rateur pour cr√©er et renvoyer un nouveau </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons changer notre fonction </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'elle passe l'instance √† la </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la traduction d'adresse est r√©ussie - et nous voyons √† nouveau le message en noir et blanc </font><i><font style="vertical-align: inherit;">"Nouveau!"</font></i><font style="vertical-align: inherit;"> Sur l'√©cran</font></font><i><font style="vertical-align: inherit;"></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En arri√®re-plan, la m√©thode </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©e les tableaux de pages manquants comme suit:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait une trame inutilis√©e de </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correspond √† une entr√©e de table de niveau sup√©rieur avec ce cadre. </font><font style="vertical-align: inherit;">Le cadre est d√©sormais accessible via une table de pages r√©cursive.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Met le cadre √† z√©ro pour cr√©er un nouveau tableau de pages vide. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passe au tableau de niveau suivant. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que notre fonction </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne soit qu'un exemple, nous pouvons maintenant cr√©er de nouveaux mappages pour des pages arbitraires. </font><font style="vertical-align: inherit;">Ceci est tr√®s utile lors de l'allocation de m√©moire et de l'impl√©mentation du multithreading dans les prochains articles.</font></font><br><br><h1>  R√©sum√© </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, vous avez appris √† utiliser une table r√©cursive de niveau 4 pour traduire toutes les trames en adresses virtuelles calculables. </font><font style="vertical-align: inherit;">Nous avons utilis√© cette m√©thode pour impl√©menter la fonction de traduction d'adresse et cr√©er un nouveau mappage dans les tables de pages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons vu que la cr√©ation de nouveaux mappages n√©cessite des cadres inutilis√©s pour les nouvelles tables. </font><font style="vertical-align: inherit;">Un tel r√©partiteur de trames peut √™tre impl√©ment√© sur la base des informations du BIOS que le chargeur de d√©marrage transmet √† notre noyau.</font></font><br><br><h1>  Et ensuite </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le prochain article, nous allons cr√©er une zone de m√©moire de tas pour notre noyau, ce qui nous permettra d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allouer de la m√©moire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et d'utiliser diff√©rents </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types de collections</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439066/">https://habr.com/ru/post/fr439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439050/index.html">Formation Cisco 200-125 CCNA v3.0. Sp√©cialiste r√©seau certifi√© Cisco (CCNA). Jour 2. Mod√®les OSI et TCP-IP</a></li>
<li><a href="../fr439056/index.html">Int√©gration de la marque de ciment</a></li>
<li><a href="../fr439060/index.html">7 types de clients</a></li>
<li><a href="../fr439062/index.html">Compositeur Anisoprint: impression 3D haute r√©sistance</a></li>
<li><a href="../fr439064/index.html">Une erreur de grille typique (Bootstrap Grid), ou pourquoi le concepteur et le concepteur de mise en page ne se comprennent pas</a></li>
<li><a href="../fr439068/index.html">Campagne de spam ¬´Love you¬ª redirig√©e vers le Japon</a></li>
<li><a href="../fr439070/index.html">La Chine abandonnera le syst√®me d'IA anti-corruption Zero Trust en raison de sa haute efficacit√©</a></li>
<li><a href="../fr439072/index.html">Manifeste du d√©veloppeur Smart Home: 15 principes</a></li>
<li><a href="../fr439076/index.html">Dans quelles applications attendre un code malveillant inconnu?</a></li>
<li><a href="../fr439078/index.html">Un programmeur de Perm arr√™t√© pour avoir cr√©√© une application mobile par laquelle un p√©dophile a agi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>