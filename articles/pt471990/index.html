<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòæ üë©üèº‚Äçüíª ü¶ì Meta gram√°tica para analisador PEG üë∞ üåØ üôÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesta semana, estamos tornando o gerador de analisador "independente", ou seja, ele gera seu pr√≥prio analisador. 
 Conte√∫do da s√©rie Ps Parser Python ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta gram√°tica para analisador PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471990/"><p>  Nesta semana, estamos tornando o gerador de analisador "independente", ou seja, ele gera seu pr√≥prio analisador. </p><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do da s√©rie Ps Parser Python</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisadores de Peg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o do Analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gera√ß√£o de analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualiza√ß√£o do analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gram√°tica PEG recursiva esquerda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adicionando a√ß√µes √† gram√°tica PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meta gram√°tica para analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementando os recursos restantes do PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEG no Core Developer Sprint</a> </li></ul></div></div><br><p> Portanto, j√° temos um gerador de analisador, parte do qual √© um analisador de gram√°tica.  Poder√≠amos cham√°-lo de um meta-analisador.  O meta-analisador funciona de maneira semelhante √† gerada: <code>GrammarParser</code> herda do <code>Parser</code> e usa o mesmo mecanismo de <code>mark()</code> / <code>reset()</code> / <code>hope()</code> .  No entanto, l√° estava tudo escrito √† m√£o.  Mas isso est√° certo? </p><a name="habracut"></a><br><p>  Ao projetar um compilador, √© habitual que o compilador seja escrito na linguagem que compila.  Lembro com amor que o compilador Pascal que usei quando aprendi a programar foi escrito no pr√≥prio Pascal, o GCC est√° escrito em C e o compilador Rust est√° escrito em Rust. </p><br><p>  Como fazer isso?  No in√≠cio, implemente um compilador para um subconjunto ou vers√£o anterior de um idioma em outro idioma.  (Deixe-me lembr√°-lo de que o compilador Pascal original foi escrito em FORTRAN!) Em seguida, o novo compilador √© escrito no idioma de destino e compilado usando o compilador de auto-inicializa√ß√£o implementado no in√≠cio.  Assim que o novo compilador come√ßa a funcionar bem o suficiente, o compilador de inicializa√ß√£o √© removido e cada vers√£o subsequente do idioma ou compilador √© limitada ao que pode ser compilado usando a vers√£o anterior do compilador. </p><br><p>  Vamos fazer isso para o nosso meta-analisador.  Escreveremos uma gram√°tica para as gram√°ticas (meta-gram√°tica) e, em seguida, geraremos um novo meta-analisador a partir disso.  Felizmente, planejei essa mudan√ßa desde o in√≠cio, por isso ser√° bem simples.  As a√ß√µes que adicionamos no epis√≥dio anterior s√£o um componente importante porque n√£o precisamos alterar o gerador, portanto, precisamos criar uma estrutura de dados compat√≠vel. </p><br><p>  Aqui est√° uma vers√£o simplificada do metagrama sem a√ß√µes: </p><br><pre> <code class="plaintext hljs">start: rules ENDMARKER rules: rule rules | rule rule: NAME ":" alts NEWLINE alts: alt "|" alts | alt alt: items items: item items | item item: NAME | STRING</code> </pre> <br><p>  Vou mostrar como adicionar a√ß√£o de baixo para cima.  Lembre-se da Parte 3 que existem objetos <code>Rule</code> que possuem os <code>alts</code> <code>name</code> e <code>alts</code> .  Inicialmente, <code>alts</code> era apenas uma lista de listas de linhas (uma lista externa para alternativas e uma lista interna para cada elemento da alternativa), mas para implementar as a√ß√µes, mudei para que as alternativas fossem representadas por objetos <code>Alt</code> com <code>items</code> e atributos de <code>action</code> .  Os elementos ainda s√£o representados como cadeias simples.  Para o <code>item</code> , obtemos: </p><br><pre> <code class="plaintext hljs">item: NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  Isso requer uma pequena explica√ß√£o: quando o analisador processa o token, ele retorna um objeto <code>TokenInfo</code> que possui <code>type</code> , <code>string</code> e outros atributos.  N√£o queremos que o gerador lide com objetos <code>TokenInfo</code> , portanto, as a√ß√µes aqui extraem a string do token.  Observe que, para todos os tokens mai√∫sculos, como <code>NAME</code> , o analisador gerado usa a vers√£o da string (aqui <code>name</code> ) como o nome da vari√°vel. </p><br><p>  A seguir, s√£o <code>items</code> que devem retornar uma lista de cadeias de caracteres: </p><br><pre> <code class="plaintext hljs">items: item items { [item] + items } | item { [item] }</code> </pre> <br><p>  Aqui eu uso regras de recursividade √† direita, para que n√£o dependamos do processamento da recurs√£o √† esquerda, adicionada na Parte 5. (Por que n√£o? √â sempre bom manter as coisas o mais simples poss√≠vel, e essa gram√°tica n√£o se beneficiar√° muito de uma altera√ß√£o na recurs√£o √† esquerda). <code>item</code> listado, mas recursivamente os <code>items</code> n√£o est√£o, pois j√° √© uma lista. </p><br><p>  Regra <code>alt</code> para criar um objeto <code>Alt</code> : </p><br><pre> <code class="plaintext hljs">alt: items { Alt(items) }</code> </pre> <br><p>  Vou omitir as a√ß√µes para <code>rules</code> e <code>start</code> , como elas s√£o definidas dessa maneira. </p><br><p>  No entanto, existem duas quest√µes em aberto.  Primeiro, como encontro a defini√ß√£o das classes <code>Rule</code> e <code>Alt</code> ?  Para fazer isso, precisamos adicionar v√°rias instru√ß√µes de <code>import</code> ao c√≥digo gerado.  A maneira mais simples seria passar a bandeira para o gerador, que diz ‚Äúisso √© uma meta-gram√°tica‚Äù, e deixar o gerador inserir uma <code>import</code> adicional no in√≠cio do programa gerado.  Mas agora que temos as a√ß√µes, muitos outros analisadores tamb√©m querer√£o personalizar sua importa√ß√£o. Por que n√£o ver se podemos implementar uma abordagem mais geral. </p><br><p>  Existem muitas maneiras de implement√°-lo.  Um mecanismo simples e geral √© adicionar uma se√ß√£o de "defini√ß√µes de vari√°veis" na parte superior da gram√°tica e permitir que o gerador use essas vari√°veis ‚Äã‚Äãpara controlar v√°rios aspectos do c√≥digo gerado.  Decidi usar o s√≠mbolo <code>@</code> para come√ßar a definir a vari√°vel, seguida pelo nome da vari√°vel ( <code>NAME</code> ) e valor ( <code>STRING</code> ).  Por exemplo, podemos colocar o seguinte bloco de c√≥digo na parte superior da meta-gram√°tica: </p><br><pre> <code class="plaintext hljs">@subheader "from grammar import Rule, Alt"</code> </pre> <br><p>  O gerador do analisador imprimir√° o valor da vari√°vel do <code>subheader</code> ap√≥s a importa√ß√£o padr√£o, que √© adicionada por padr√£o (por exemplo, para importar <code>memoize</code> ).  Se voc√™ desejar v√°rios elementos de <code>import</code> , poder√° usar uma sequ√™ncia com aspas triplas, por exemplo, </p><br><pre> <code class="plaintext hljs">@subheader """ from token import OP from grammar import Rule, Alt """</code> </pre> <br><p>  √â f√°cil adicionar isso √† meta-gram√°tica: quebraremos a regra de <code>start</code> do seguinte modo: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER | rules ENDMARKER metas: meta metas | meta meta: "@" NAME STRING NEWLINE</code> </pre> <br><p>  (N√£o me lembro por que o chamei de "meta", mas escolhi esse nome quando escrevi o c√≥digo, e continuarei com ele. :-) </p><br><p>  N√≥s devemos adicionar isso ao metaparser de auto-inicializa√ß√£o.  Agora que a gram√°tica n√£o √© apenas uma lista de regras, vamos adicionar um objeto de gram√°tica com os atributos <code>metas</code> e <code>rules</code> .  Podemos definir as seguintes a√ß√µes: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING { (name.string, eval(string.string)) }</code> </pre> <br><p>  (Observe que <code>meta</code> retorna uma tupla; e tamb√©m usa <code>eval()</code> para processar aspas de seq√º√™ncia de caracteres.) </p><br><p>  N√£o mencionei a implementa√ß√£o de a√ß√µes nas regras do <code>alt</code> !  A raz√£o √© que eles saem um pouco bagun√ßados.  Mas n√£o faz sentido adiar ainda mais, ent√£o aqui: </p><br><pre> <code class="plaintext hljs">alt: items action { Alt(items, action) } | items { Alt(items, None) } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  A sujeira na defini√ß√£o √© causada pelo meu desejo de validar o c√≥digo arbitr√°rio do Python entre colchetes de a√ß√£o, incluindo aninhados em mais um colchete.  Para esse prop√≥sito, usamos um token <code>OP</code> especial que gera nosso tokenizer para toda pontua√ß√£o reconhecida pelo Python (retornando um √∫nico token com o tipo <code>OP</code> para operadores com v√°rios caracteres, como <code>&lt;=</code> ou <code>**</code> ).  Os √∫nicos outros tokens que podem ocorrer nas express√µes Python s√£o nomes, n√∫meros e seq√º√™ncias de caracteres.  Assim, o c√≥digo entre os colchetes externos da a√ß√£o, ao que parece, pode ser expresso atrav√©s de repeti√ß√µes de <code>NAME | NUMBER | STRING | OP</code> <code>NAME | NUMBER | STRING | OP</code>  <code>NAME | NUMBER | STRING | OP</code> . </p><br><p>  Infelizmente, isso n√£o funcionar√° porque o <code>OP</code> tamb√©m corresponde a chaves, e como o analisador PEG √© sempre ganancioso, isso captura o suporte de fechamento e nunca veremos o final da a√ß√£o.  Portanto, adicionamos um pequeno ajuste, permitindo que a a√ß√£o gere um erro de escolha alternativo, retornando Nenhum.  N√£o sei se essa √© uma ocorr√™ncia padr√£o em outros analisadores de PEG - eu vim com isso imediatamente quando tive que resolver o problema de reconhecer os par√™nteses de fechamento (mesmo sem pares aninhados).  Isso parece funcionar bem e acho que se encaixa na filosofia geral da an√°lise PEG.  Isso pode ser considerado como uma forma especial de previs√£o (que discutirei abaixo). </p><br><p>  Usando esse pequeno truque, podemos fazer a compara√ß√£o no <code>OP</code> cair em uma chave.  Ent√£o uma compara√ß√£o de <code>stuff</code> e <code>action</code> ser√° poss√≠vel. </p><br><p>  Com essas coisas, uma meta-gram√°tica pode ser analisada por um metaparser de autoinicializa√ß√£o e o gerador pode transform√°-lo em um novo meta-analisador que pode se analisar.  E, o mais importante, o novo meta-analisador ainda pode analisar a mesma meta-gram√°tica.  Se compilarmos a meta-gram√°tica com o novo meta-compilador, o resultado ser√° o mesmo: isso prova que o meta-analisador gerado est√° funcionando corretamente. </p><br><p>  Aqui est√° a meta gram√°tica de a√ß√£o completa.  Ele pode se analisar, pois sabe combinar linhas longas: </p><br><pre> <code class="plaintext hljs">@subheader """ from grammar import Grammar, Rule, Alt from token import OP """ start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING NEWLINE { (name.string, eval(string.string)) } rules: rule rules { [rule] + rules } | rule { [rule] } rule: NAME ":" alts NEWLINE { Rule(name.string, alts) } alts: alt "|" alts { [alt] + alts } | alt { [alt] } alt: items action { Alt(items, action) } | items { Alt(items, None) } items: item items { [item] + items } | item { [item] } item: NAME { name.string } | STRING { string.string } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Agora que temos uma meta-gram√°tica funcional, estamos quase prontos para fazer algumas melhorias. </p><br><p>  Mas primeiro voc√™ precisa pensar um pouco: linhas vazias!  Acontece que o m√≥dulo stdlib <code>tokenize</code> cria tokens adicionais para rastrear <code>tokenize</code> linha insignificantes (token <code>NL</code> ) e coment√°rios (token <code>COMMENT</code> ).  Em vez de inclu√≠-los na gram√°tica (tentei, n√£o h√° muita divers√£o!), Existe um peda√ßo de c√≥digo muito simples que podemos adicionar √† nossa classe de tokenizer para filtr√°-los.  Aqui est√° o m√©todo <code>peek_token</code> aprimorado: </p><br><pre> <code class="plaintext hljs"> def peek_token(self): if self.pos == len(self.tokens): while True: token = next(self.tokengen) if token.type in (NL, COMMENT): continue break self.tokens.append(token) self.report() return self.tokens[self.pos]</code> </pre> <br><p>  Isso remove completamente os tokens <code>NL</code> e <code>COMMENT</code> , portanto, n√£o precisamos mais nos preocupar com eles na gram√°tica. </p><br><p>  Finalmente, vamos fazer melhorias na meta-gram√°tica!  Eles ser√£o puramente cosm√©ticos: n√£o gosto quando sou for√ßado a escrever todas as alternativas em uma linha.  A meta gram√°tica que mostrei acima, na verdade, n√£o se analisa devido a essas coisas: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  Isso ocorre porque o tokenizer cria um token <code>NEWLINE</code> no final da primeira linha e, neste momento, o meta-analisador considerar√° que este √© o fim da regra.  Al√©m disso, esta <code>NEWLINE</code> ser√° seguida pelo token <code>INDENT</code> , porque a pr√≥xima linha √© recuada.  At√© o in√≠cio da pr√≥xima regra, um token <code>DEDENT</code> tamb√©m estar√° presente. </p><br><p>  Veja como lidar com isso.  Para entender o comportamento do m√≥dulo <code>tokenize</code> , podemos observar a sequ√™ncia de tokens gerados para blocos recuados, executando o m√≥dulo <code>tokenize</code> como um script e passando algum texto: </p><br><pre> <code class="plaintext hljs">$ python -m tokenize foo bar baz dah dum ^D</code> </pre> <br><p>  Vemos que isso produz a seguinte sequ√™ncia de tokens (simplifiquei um pouco a sa√≠da do c√≥digo acima): </p><br><pre> <code class="plaintext hljs">NAME 'foo' NAME 'bar' NEWLINE INDENT NAME 'baz' NEWLINE NAME 'dah' NEWLINE DEDENT NAME 'dum' NEWLINE</code> </pre> <br><p>  Assim, um grupo selecionado de strings √© indicado pelos <code>DEDENT</code> e <code>DEDENT</code> .  Agora podemos reescrever a <code>rule</code> meta-gram√°tica para <code>rule</code> seguinte maneira: </p><br><pre> <code class="plaintext hljs">rule: NAME ":" alts NEWLINE INDENT more_alts DEDENT { Rule(name.string, alts + more_alts) } | NAME ":" alts NEWLINE { Rule(name.string, alts) } | NAME ":" NEWLINE INDENT more_alts DEDENT { Rule(name.string, more_alts) } more_alts: "|" alts NEWLINE more_alts { alts + more_alts } | "|" alts NEWLINE { alts }</code> </pre> <br><p>  (Divido as a√ß√µes em linhas para que elas sejam lidas normalmente em uma coluna estreita de texto. Isso √© poss√≠vel porque o tokenizador ignora quebras de linha dentro dos chavetas correspondentes.) </p><br><p>  A vantagem disso √© que nem precisamos alterar o gerador: a estrutura de dados criada por essa meta-gram√°tica aprimorada √© a mesma de antes.  Preste aten√ß√£o tamb√©m √† terceira op√ß√£o de <code>rule</code> : isso nos permite escrever: </p><br><pre> <code class="plaintext hljs">start: | metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  que alguns podem achar mais limpo que a vers√£o que mostrei anteriormente.  Ambos os formul√°rios s√£o f√°ceis de resolver, por isso n√£o precisamos discutir sobre estilo. </p><br><p>  No pr√≥ximo post, mostrarei como implementei v√°rias fun√ß√µes do PEG, como elementos opcionais, repeti√ß√µes e dicas de ferramentas.  (Para ser sincero, planejei falar sobre eles neste artigo, mas ele j√° √© muito grande. Por isso, vou dividi-lo em duas partes.) </p><br><p>  Licen√ßa para este artigo e c√≥digo citado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471990/">https://habr.com/ru/post/pt471990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471978/index.html">N√£o podemos confiar nos sistemas de IA constru√≠dos apenas com aprendizado profundo</a></li>
<li><a href="../pt471980/index.html">Golpistas por telefone. Ato Quatro, Final ...</a></li>
<li><a href="../pt471982/index.html">Discutindo o futuro do PHP</a></li>
<li><a href="../pt471986/index.html">Gram√°tica PEG recursiva esquerda</a></li>
<li><a href="../pt471988/index.html">Adicionando a√ß√µes √† gram√°tica PEG</a></li>
<li><a href="../pt471992/index.html">Implementando os recursos restantes do PEG</a></li>
<li><a href="../pt471994/index.html">Trabalhar no PEG no Core Developer Sprint</a></li>
<li><a href="../pt471998/index.html">F # 10: Listas</a></li>
<li><a href="../pt472000/index.html">‚Äú√â fundamental que a comunidade estabele√ßa padr√µes‚Äù: Marchin Moskala sobre Kotlin</a></li>
<li><a href="../pt472002/index.html">Reembalagem de pacotes em Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>