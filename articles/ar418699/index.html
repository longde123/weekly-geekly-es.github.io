<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⭕️ 👨🏾‍⚕️ 🈚️ إنشاء آلة ممر المحاكي. الجزء 3 👰🏾 🚦 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="الجزء الأول والثاني . 

 8080 محاكي المعالج 
 قذيفة المحاكي 
 يجب أن يكون لديك الآن كل المعرفة اللازمة لبدء إنشاء محاكي معالج 8080. 

 سأحاول أن أجعل ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إنشاء آلة ممر المحاكي. الجزء 3</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="الصورة"></div><br>  الجزء <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأول</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والثاني</a> . <br><br><h1 style=";text-align:right;direction:rtl">  8080 محاكي المعالج </h1><br><h1 style=";text-align:right;direction:rtl">  قذيفة المحاكي </h1><br>  يجب أن يكون لديك الآن كل المعرفة اللازمة لبدء إنشاء محاكي معالج 8080. <br><br>  <em>سأحاول أن أجعل الكود الخاص بي واضحًا قدر الإمكان ، يتم تنفيذ كل كود op بشكل منفصل.</em>  <em>عندما تشعر بالراحة تجاهه ، قد ترغب في إعادة كتابته لتحسين الأداء أو إعادة استخدام التعليمات البرمجية.</em> <br><br>  بادئ ذي بدء ، سوف أقوم بإنشاء بنية ذاكرة تحتوي على حقول لكل شيء بدا لي ضروريًا عند كتابة أداة تفكيك.  سيكون هناك أيضًا مكان لمخزن الذاكرة المؤقت ، والذي سيكون ذاكرة الوصول العشوائي. <br><a name="habracut"></a><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  الآن قم بإنشاء إجراء باستدعاء خطأ سينهي البرنامج بخطأ.  سيبدو شيء من هذا القبيل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  دعونا ننفذ بعض الشفرات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  ها أنت ذا.  لكل كود تشغيل ، نقوم بتغيير الحالة والذاكرة ، كما يفعل الأمر الذي يتم تنفيذه على 8080 حقيقي. <br><br>  يحتوي 8080 على حوالي 7 أنواع ، اعتمادًا على كيفية تصنيفهم: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نقل البيانات </li><li style=";text-align:right;direction:rtl">  الحساب </li><li style=";text-align:right;direction:rtl">  منطقي </li><li style=";text-align:right;direction:rtl">  الفروع </li><li style=";text-align:right;direction:rtl">  المكدس </li><li style=";text-align:right;direction:rtl">  المدخلات والمخرجات </li><li style=";text-align:right;direction:rtl">  خاص </li></ul><br>  دعونا نلقي نظرة على كل منها على حدة. <br><br><h1 style=";text-align:right;direction:rtl">  المجموعة الحسابية </h1><br>  التعليمات الحسابية هي العديد من 256 شفرة لمعالج 8080 ، والتي تشمل أنواعًا مختلفة من الجمع والطرح.  تعمل معظم التعليمات الحسابية مع السجل A وتحفظ النتيجة في A. (يُسمى السجل A أيضًا المجمع). <br><br>  من المثير للاهتمام ملاحظة أن هذه الأوامر تؤثر على رموز الشروط.  يتم تعيين رموز الدولة (تسمى أيضًا الأعلام) اعتمادًا على نتيجة الأمر الذي تم تنفيذه.  لا تؤثر جميع الأوامر على الأعلام ، ولا تؤثر جميع الفرق التي تؤثر على الأعلام على جميع الأعلام في وقت واحد. <br><br><h3 style=";text-align:right;direction:rtl">  الأعلام 8080 </h3><br>  في معالج 8080 ، تسمى الأعلام Z و S و P و CY و AC. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  Z (صفر ، صفر) تأخذ القيمة 1 عندما تكون النتيجة صفر </li><li style=";text-align:right;direction:rtl">  تأخذ S (العلامة) القيمة 1 عندما يتم إعطاء البتة 7 (البتة الأكثر أهمية ، البتة الأكثر أهمية ، MSB) للأمر الرياضي </li><li style=";text-align:right;direction:rtl">  يتم تعيين P (التماثل ، التماثل) عندما تكون النتيجة زوجية ، ويتم إعادة ضبطها عندما تكون فردية </li><li style=";text-align:right;direction:rtl">  CY (حمل) يأخذ القيمة 1 عندما ، نتيجة للأمر ، يتم تنفيذ التحويل أو الاقتراض في بت عالي الترتيب </li><li style=";text-align:right;direction:rtl">  يستخدم AC (حمل مساعد) بشكل رئيسي للرياضيات BCD (عشري مشفر ثنائي).  لمزيد من التفاصيل ، انظر الدليل ، في غزاة الفضاء لا يتم استخدام هذه العلامة. </li></ul><br>  يتم استخدام رموز الولاية في أوامر الفرع الشرطي ، على سبيل المثال ، ينفذ JZ التفرع فقط إذا تم تعيين علامة Z. <br><br>  تحتوي معظم التعليمات على ثلاثة أشكال: للسجلات والقيم الفورية والذاكرة.  دعنا ننفذ بعض التعليمات لفهم أشكالها ونرى كيف يبدو العمل مع رموز الولاية.  (لاحظ أني لا أقوم بتطبيق علامة النقل المساعدة لأنها غير مستخدمة. إذا قمت بتطبيقها ، فلن أتمكن من اختبارها.) <br><br><h4 style=";text-align:right;direction:rtl">  نموذج التسجيل </h4><br>  هنا مثال على تنفيذ تعليماتين مع نموذج التسجيل ؛  في الأول ، قمت بنشر الشفرة لتسهيل فهم عملها ، وفي الثانية ، يتم تقديم نموذج أكثر إحكاما يقوم بنفس الشيء. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  أقوم بمحاكاة أوامر الرياضيات ذات 8 بت برقم 16 بت.  وهذا يجعل من السهل تتبع الحالات التي تولد فيها الحسابات حملًا. <br><br><h4 style=";text-align:right;direction:rtl">  نموذج للقيم الفورية </h4><br>  نموذج القيم المباشرة هو نفسه تقريبًا ، باستثناء أن البايت بعد الأمر هو مصدر الإضافة.  نظرًا لأن "opcode" هو مؤشر للأمر الحالي في الذاكرة ، فسيكون opcode [1] على الفور البايت التالي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4 style=";text-align:right;direction:rtl">  شكل للذاكرة </h4><br>  في نموذج الذاكرة ، ستتم إضافة بايت يشير إليه العنوان المخزن في زوج من تسجيلات HL. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  ملاحظات </h3><br>  يتم تنفيذ التعليمات الحسابية المتبقية بطريقة مماثلة.  الإضافات: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  في إصدارات مختلفة مع حمل (ADC ، ACI ، SBB ، SUI) ، وفقًا للدليل المرجعي ، نستخدم بتات الحمل في الحسابات. </li><li style=";text-align:right;direction:rtl">  يؤثر كل من INX و DCX على أزواج التسجيل ؛ ولا تؤثر هذه الأوامر على العلامات. </li><li style=";text-align:right;direction:rtl">  DAD هو أمر آخر لزوجين من السجلات ، فهو يؤثر فقط على علم الحمل </li><li style=";text-align:right;direction:rtl">  INR و DCR لا تؤثر على علم الحمل </li></ul><br><h1 style=";text-align:right;direction:rtl">  مجموعة الفرع </h1><br>  بعد التعامل مع رموز الولاية ، ستصبح مجموعة الفروع واضحة بما يكفي بالنسبة لك.  هناك نوعان من التفرع - التحولات (JMP) والمكالمات (CALL).  يقوم JMP فقط بتعيين الكمبيوتر إلى قيمة وجهة القفز.  يستخدم CALL للروتين ، ويكتب عنوان المرسل إلى المكدس ، ثم يعين الكمبيوتر عنوان الوجهة.  إرجاع RET من CALL ، تلقي العنوان من المكدس وكتابته إلى الكمبيوتر. <br><br>  ينتقل كل من JMP و CALL فقط إلى العناوين المطلقة التي يتم ترميزها بالبايت بعد شفرة التشغيل. <br><br><h3 style=";text-align:right;direction:rtl">  Jmp </h3><br>  يتفرع أمر JMP دون قيد أو شرط إلى عنوان الوجهة.  هناك أيضًا أوامر فرع شرطية لجميع رموز الحالة (باستثناء AC): <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  JNZ و JZ للصفر </li><li style=";text-align:right;direction:rtl">  JNC و JC للهجرة </li><li style=";text-align:right;direction:rtl">  JPO و JPE من أجل التكافؤ </li><li style=";text-align:right;direction:rtl">  JP (زائد) و JM (ناقص) للعلامة </li></ul><br>  هنا تنفيذ بعضها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  اتصل وأعد </h3><br>  يدفع CALL عنوان التعليمات على المكدس بعد المكالمة ، ثم ينتقل إلى عنوان الوجهة.  يتلقى RET العنوان من المكدس ويحفظه على جهاز الكمبيوتر.  توجد نسخ شرطية من CALL و RET لجميع الدول. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  CZ ، CNZ ، RZ ، RNZ للصفر </li><li style=";text-align:right;direction:rtl">  CNC ، CC ، RNC ، RC للتحويل </li><li style=";text-align:right;direction:rtl">  CPO ، CPE ، RPO ، RPE من أجل التكافؤ </li><li style=";text-align:right;direction:rtl">  CP ، CM ، RP ، RM للتوقيع </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  ملاحظات </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ينتقل الأمر PCHL دون قيد أو شرط إلى عنوان في زوج من تسجيلات HL. </li><li style=";text-align:right;direction:rtl">  لم أقوم بتضمين RST الذي تمت مناقشته سابقًا في هذه المجموعة.  يكتب عنوان الإرجاع إلى المكدس ، ثم ينتقل إلى العنوان المحدد مسبقًا في الجزء السفلي من الذاكرة. </li></ul><br><h1 style=";text-align:right;direction:rtl">  مجموعة منطقية </h1><br>  تقوم هذه المجموعة بتنفيذ العمليات المنطقية (انظر المنشور <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأول من</a> البرنامج التعليمي).  بحكم طبيعتها ، فهي تشبه مجموعة حسابية في أن معظم العمليات تعمل مع السجل A (محرك الأقراص) ، ومعظم العمليات تؤثر على الأعلام.  يتم تنفيذ جميع العمليات على قيم 8 بت ، في هذه المجموعة لا توجد أوامر تؤثر على أزواج من السجلات. <br><br><h3 style=";text-align:right;direction:rtl">  العمليات المنطقية </h3><br>  AND ، أو ، NOT (CMP) و "خاص أو" (XOR) تسمى العمليات المنطقية.  أو ووضحت في وقت سابق.  يغير الأمر NOT (للمعالج 8080 الذي يطلق عليه CMA ، أو المجمع المتراكم) قيم البت ببساطة - تصبح جميع الوحدات أصفارًا ، وتصبح الأصفار منها. <br><br>  أرى XOR على أنه "أداة التعرف على الاختلافات".  جدول الحقيقة الخاص بها يبدو كما يلي: <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><td>  س </td><td>  ذ </td><td>  النتيجة </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td></tr></tbody></table><br>  AND و OR و XOR لها نموذج للسجلات والذاكرة والقيم الفورية.  (يحتوي CMP فقط على أمر حساس لحالة الأحرف).  هنا تنفيذ زوج من opcodes: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  أوامر التحول الدوري </h3><br>  تغير هذه الأوامر ترتيب البتات في السجلات.  يؤدي النقل إلى اليمين إلى تحريكها يمينًا بمقدار بت واحد ، والتحول إلى اليسار - يسارًا بت واحد: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  يبدو أنها لا قيمة لها ، ولكن في الواقع الأمر ليس كذلك.  يمكن استخدامها للتكاثر والقسمة بسلطات اثنين.  خذ التحول الأيسر كمثال.  <code>0b00000001</code> هو رقم عشري 1 ، <code>0b00000001</code> إلى اليسار يجعله <code>0b00000010</code> ، أي رقم عشري 2. إذا قمنا بتحول آخر إلى اليسار ، نحصل على <code>0b00000100</code> ، أي 4. تحول آخر إلى اليسار ، <code>0b00000100</code> 8. هذا سيعمل مع أي بالأرقام: 5 ( <code>0b00000101</code> ) عند <code>0b00000101</code> إلى اليسار يعطي 10 ( <code>0b00001010</code> ).  يعطي التحول الأيسر الآخر 20 ( <code>0b00010100</code> ).  التحول إلى اليمين يفعل نفس الشيء ، ولكن للانقسام. <br><br>  لا يحتوي 8080 على أمر ضرب ، ولكن يمكن تنفيذه باستخدام هذه الأوامر.  إذا فهمت كيفية القيام بذلك ، فستحصل على نقاط إضافية.  بمجرد طرح هذا السؤال علي في مقابلة.  (لقد فعلت ذلك ، على الرغم من أنني استغرقت بضع دقائق). <br><br>  تقوم هذه الأوامر بتدوير محرك الأقراص دوريًا وتؤثر فقط على علم الحمل.  فيما يلي أمرين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  مقارنة </h3><br>  مهمة CMP و CPI هي فقط تعيين العلامات (للتفرع).  يفعلون ذلك عن طريق طرح الأعلام ، ولكن ليس تخزين النتيجة. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بالتساوي: إذا كان رقمان متساويين ، فسيتم تعيين علامة Z ، حيث أن طرحهما من بعضهما يعطي صفرًا. </li><li style=";text-align:right;direction:rtl">  أكبر من: إذا كانت A أكبر من القيمة التي تتم مقارنتها ، فسيتم مسح علامة CY (حيث يمكن إجراء الطرح بدون الاقتراض). </li><li style=";text-align:right;direction:rtl">  أصغر: إذا كانت A أقل من القيمة المقارنة ، فسيتم تعيين علامة CY (لأنه يجب على A إكمال الاقتراض لإكمال الطرح). </li></ul><br>  هناك إصدارات من هذه الأوامر للسجلات والذاكرة والقيم الفورية.  التنفيذ هو طرح بسيط بدون حفظ النتيجة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  CMC و STC </h3><br>  يكملون المجموعة المنطقية.  يتم استخدامها لتعيين ومسح علم الحمل. <br><br><h1 style=";text-align:right;direction:rtl">  مجموعة المدخلات والمخرجات والأوامر الخاصة </h1><br>  لا يمكن تعيين هذه الأوامر لأي فئة أخرى.  سأذكرها من أجل الاكتمال ، ولكن يبدو لي أنه سيتعين علينا العودة إليها مرة أخرى عندما نبدأ في محاكاة أجهزة Space Invaders. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يعمل كل من EI و DI على تمكين أو تعطيل قدرة المعالج على معالجة المقاطعات.  أضفت إشارة interrupt_enabled إلى بنية حالة المعالج ، وقمت بتعيين / إعادة تعيينها باستخدام هذه الأوامر. </li><li style=";text-align:right;direction:rtl">  يبدو أن RIM و SIM يستخدمان بشكل أساسي في I / O التسلسلي.  إذا كنت مهتمًا ، يمكنك قراءة الدليل ، ولكن لا يتم استخدام هذه الأوامر في Space Invaders.  لن أقوم بمحاكاة لهم. </li><li style=";text-align:right;direction:rtl">  HLT هي محطة.  لا أعتقد أننا بحاجة إلى محاكاة ذلك ، ولكن يمكنك استدعاء رمز الإقلاع عن التدخين (أو الخروج (0)) عندما ترى هذا الأمر. </li><li style=";text-align:right;direction:rtl">  IN و OUT هما أمران يستخدمهما جهاز المعالج 8080 للتواصل مع المعدات الخارجية.  بينما نقوم بتنفيذها ، لكنهم لن يفعلوا أي شيء سوى تخطي بايت البيانات الخاصة بهم.  (في وقت لاحق سنعود لهم). </li><li style=";text-align:right;direction:rtl">  NOP "لا يوجد عملية".  أحد تطبيقات NOP هو التحكم في توقيت اللوحة (يستغرق تنفيذ أربع دورات لوحدة المعالجة المركزية). </li></ul><br>  تطبيق آخر من NOP هو تعديل التعليمات البرمجية.  لنفترض أننا بحاجة إلى تغيير رمز ROM الخاص باللعبة.  لا يمكننا فقط حذف الرموز غير الضرورية ، لأننا لا نريد تغيير جميع أوامر CALL و JMP (ستكون غير صحيحة إذا تم نقل جزء واحد على الأقل من التعليمات البرمجية).  مع NOP يمكننا التخلص من الرمز.  <em>إضافة رمز أكثر صعوبة بكثير!</em>  <em>يمكنك إضافته من خلال إيجاد مساحة في مكان ما في ROM وتغيير الأمر إلى JMP.</em> <br><br><h1 style=";text-align:right;direction:rtl">  مجموعة المكدس </h1><br>  لقد أكملنا بالفعل الآليات لمعظم الفرق في مجموعة المكدس.  إذا قمت بالعمل معي ، فسيكون من السهل تنفيذ هذه الأوامر. <br><br><h3 style=";text-align:right;direction:rtl">  PUSH و POP </h3><br>  يعمل PUSH و POP فقط مع أزواج التسجيل.  يكتب PUSH زوج من السجلات إلى المكدس ، ويأخذ بروتوكول POP 2 بايت من أعلى المكدس ويكتبها إلى زوج من السجلات. <br><br>  هناك أربعة شفرات opcodes لـ PUSH و POP ، واحد لكل زوج من الأزواج: BC و DE و HL و PSW.  PSW هو زوج خاص من سجلات إشارة محرك الأقراص ورموز الحالة.  هنا تنفيذي لـ PUSH و POP لـ BC و PSW.  لا توجد تعليقات فيه - لا أعتقد أن هناك أي شيء صعب بشكل خاص هنا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  SPHL و XTHL </h3><br>  هناك فريقان آخران في مجموعة المكدس - SPHL و XTHL. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>SPHL</code> بنقل HL إلى SP (مما يجبر SP على الحصول على عنوان جديد). </li><li style=";text-align:right;direction:rtl">  <code>XTHL</code> ما يوجد فوق المكدس بما يوجد في زوج من تسجيلات HL.  لماذا تحتاج للقيام بذلك؟  لا اعرف. </li></ul><br><h1 style=";text-align:right;direction:rtl">  المزيد عن الأرقام الثنائية </h1><br>  عند كتابة برنامج كمبيوتر ، فإن أحد القرارات التي تحتاج إلى اتخاذها هو اختيار نوع البيانات المستخدمة للأرقام - ما إذا كنت تريد أن تكون سلبية وما هو الحد الأقصى لحجمها.  بالنسبة لمحاكي وحدة المعالجة المركزية ، نحتاج إلى نوع البيانات لمطابقة نوع البيانات لوحدة المعالجة المركزية المستهدفة. <br><br><h3 style=";text-align:right;direction:rtl">  موقعة وغير موقعة </h3><br>  عندما بدأنا في الحديث عن الأرقام السداسية ، اعتبرناها غير موقعة - أي أن كل رقم ثنائي من الرقم السداسي العشري له قيمة موجبة ، وكان كل واحد يعتبر قوة لاثنين (وحدات ، اثنان ، أربعة ، إلخ). <br><br>  تعاملنا مع قضية تخزين الكمبيوتر للأرقام السالبة.  إذا كنت تعلم أن البيانات المعنية تحتوي على علامة ، أي أنها يمكن أن تكون سالبة ، فيمكنك التعرف على رقم سالب بأهم بت من الرقم (أهم بت ، MSB).  إذا كان حجم البيانات بايت واحد ، يكون كل رقم بقيمة بت MSB معينة سالبة ، ويكون كل رقم له صفر MSB موجبًا. <br><br>  يتم تخزين قيمة رقم سالب كرمز إضافي.  إذا كان لدينا رقم موقع وكان MSB يساوي واحدًا ، ونريد معرفة ما هو الرقم ، فيمكننا تحويله على النحو التالي: تنفيذ ثنائي "NOT" للأرقام السداسية ، ثم إضافة واحد. <br><br>  على سبيل المثال ، بالنسبة للرقم السداسي 0x80 ، يتم تعيين بت MSB ، أي أنه سلبي.  ثنائي "NOT" للرقم 0x80 هو 0x7f ، أو العشري 127. 127 + 1 = 128. أي أن 0x80 في الرقم العشري هو -128.  المثال الثاني: 0xC5.  ليس (0xC5) = 0x3A = عشري 58 +1 = عشري 59. أي أن 0xC5 عشري -59. <br><br>  ما يثير الدهشة في الأرقام التي تحتوي على رمز إضافي هو أنه يمكننا إجراء حسابات معهم كما هو الحال مع الأرقام غير الموقعة ، <em>وستظل تعمل</em> .  لا يحتاج الكمبيوتر لعمل أي شيء خاص بالعلامات.  سوف أعرض بضعة أمثلة تثبت ذلك. <br><br><pre style=";text-align:right;direction:rtl">  مثال 1<font></font>
<font></font>
      ثنائي عشري عشري    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ يتم تسجيل هذا في بت الحمل<font></font>
<font></font>
    مثال 2    <font></font>
<font></font>
      ثنائي عشري عشري    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  في المثال 1 ، نرى أن إضافة 10 و -3 نتائج في 7. تم نقل نتيجة الإضافة ، بحيث يمكن تعيين علامة C. في المثال 2 ، كانت نتيجة الإضافة سالبة ، لذلك نقوم بفك شفرة هذا: Not (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> انفجار الدماغ! <br><br>  إذا كنت تريد ، اقرأ المزيد عن الكود الإضافي على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ويكيبيديا</a> . <br><br><h3 style=";text-align:right;direction:rtl">  أنواع البيانات </h3><br>  في لغة C ، هناك علاقة بين أنواع البيانات وعدد البايتات المستخدمة لهذا النوع.  في الواقع ، نحن مهتمون فقط بالأعداد الصحيحة.  أنواع البيانات القياسية / القديمة في المدرسة هي char ، int ، و long ، وكذلك أصدقاءهم char غير الموقعة ، int غير الموقعة ، وغير الموقعة طويلة.  المشكلة هي أنه على منصات مختلفة وفي مترجمين مختلفين يمكن أن يكون لهذه الأنواع أحجام مختلفة. <br><br>  لذلك ، من الأفضل تحديد نوع بيانات لمنصتنا التي تعلن عن حجم البيانات بشكل صريح.  إذا كان النظام الأساسي الخاص بك يحتوي على stdint.h ، فيمكنك استخدام int8_t و uint8_t وما إلى ذلك. <br><br>  يحدد حجم العدد الصحيح العدد الأقصى الذي يمكن تخزينه فيه.  في حالة الأعداد الصحيحة غير الموقعة ، يمكنك تخزين الأرقام من 0 إلى 255 في 8 بت. إذا قمت بالترجمة إلى ست عشري ، فسيكون من 0x00 إلى 0xFF.  نظرًا لأن 0xFF يحتوي على "مجموعة البتات جميعها" ، ويتوافق مع الرقم العشري 255 ، فمن المنطقي تمامًا أن يكون الفاصل بين عدد صحيح بلا إشارة أحادية البايت هو 0-255.  تخبرنا الفواصل الزمنية أن جميع أحجام الأعداد الصحيحة ستعمل بنفس الطريقة تمامًا - تتوافق الأرقام مع الرقم الذي يتم الحصول عليه عند تعيين جميع البتات. <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><th>  اكتب </th><th>  الفاصل الزمني </th><th>  عرافة </th></tr><tr><td>  8 بت غير موقعة </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  توقيع 8 بت </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16 بت غير موقعة </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  موقع 16 بت </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32 بت غير موقعة </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  توقيع 32 بت </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  والأكثر إثارة للاهتمام هو أن -1 في كل نوع بيانات موقعة هو رقم تم تعيين كافة وحدات البت له (0xFF للبايتات الموقعة و 0xFFFF لرقم 16 بت الموقعة و 0xFFFFFFFF لرقم 32 بت الموقَّع).  إذا اعتبرت البيانات غير موقعة ، فسيتم الحصول على أقصى عدد ممكن لهذا النوع من البيانات لجميع البتات المحددة. <br><br>  لمحاكاة تسجيلات المعالج ، نختار نوع البيانات المقابلة لحجم هذا السجل.  ربما يكون من المفيد تحديد الأنواع غير الموقعة بشكل افتراضي وتحويلها عندما تحتاج إلى اعتبارها موقعة.  على سبيل المثال ، نستخدم نوع بيانات uint8_t لتمثيل تسجيل 8 بت. <br><br><h3 style=";text-align:right;direction:rtl">  تلميح: استخدم المصحح لتحويل أنواع البيانات </h3><br>  إذا تم تثبيت gdb على النظام الأساسي الخاص بك ، فمن المناسب استخدامه للعمل مع الأرقام الثنائية.  أدناه سأعرض مثالاً - في الجلسة الموضحة أدناه ، الخطوط التي تبدأ بـ # هي التعليقات التي أضفتها لاحقًا. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  عندما أعمل بالأرقام السداسية ، أفعل ذلك دائمًا في gdb - ويحدث ذلك تقريبًا كل يوم.  أسهل بكثير من فتح الآلة الحاسبة للمبرمج باستخدام واجهة المستخدم الرسومية.  على أجهزة Linux (و Mac OS X) ، لبدء جلسة gdb ، ما عليك سوى فتح الوحدة الطرفية وإدخال "gdb".  إذا كنت تستخدم Xcode على OS X ، فبعد بدء البرنامج ، يمكنك استخدام وحدة التحكم داخل Xcode (التي يتم إخراج إخراج printf إليها).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في Windows ، يتوفر مصحح أخطاء gdb من Cygwin. </font></font><br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنهاء محاكي وحدة المعالجة المركزية </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد تلقي كل هذه المعلومات ، أنت جاهز لرحلة طويلة. </font><font style="vertical-align: inherit;">يجب أن تقرر كيفية تنفيذ المحاكي - إما إنشاء مضاهاة 8080 كاملة ، أو تنفيذ الأوامر اللازمة لإكمال اللعبة فقط. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا قررت القيام بمحاكاة كاملة ، فستحتاج إلى عدد قليل من الأدوات. </font><font style="vertical-align: inherit;">سأتحدث عنها في القسم التالي. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقة أخرى هي محاكاة التعليمات التي تستخدمها اللعبة فقط. </font><font style="vertical-align: inherit;">سنستمر في ملء بنية التبديل الضخمة التي أنشأناها في قسم Emulator Shell. </font><font style="vertical-align: inherit;">سنكرر العملية التالية حتى يكون لدينا أمر واحد غير محقق:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قم بتشغيل المحاكي مع ROM Space Invaders </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تنتهي </font><font style="vertical-align: inherit;">المكالمة </font><font style="vertical-align: inherit;">إذا لم يكن الأمر جاهزًا</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قم بمحاكاة هذه التعليمات </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اذهب 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أول شيء فعلته عند بدء كتابة محاكي هو إضافة رمز من أداة تفكيكي. </font><font style="vertical-align: inherit;">لذلك تمكنت من إخراج أمر يجب تنفيذه على النحو التالي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضفت أيضًا رمزًا في النهاية لعرض جميع السجلات وأعلام الدولة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بشرى سارة: من أجل الخوض في البرنامج لـ 50 ألف فريق ، نحتاج فقط إلى مجموعة فرعية من 8080 شفرة ، وسأعطي قائمة من رموز الشفرة التي يجب تنفيذها:</font></font><br><br><table style=";text-align:right;direction:rtl"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> كود التشغيل </font></font></th><th>  الفريق </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لا </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B ، D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B ، D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أبي ب </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 × 0 د </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 × 0 هـ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C ، D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ص ص </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D ، D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنكس د </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أبي د </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX د </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H ، D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx ح </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H ، D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أبي ح </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP ، D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI م ، د 8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A ، D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> موف د ، م </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E ، M. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV ح ، م </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L ، A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M ، A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> موف ، د </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A ، E </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A ، H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV أ ، م </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA أ </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بوب ب </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> جنز ادر </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JMP adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH ب </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إعادة </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اتصل adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> البوب ​​د </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> خارج D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH د </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> البوب ​​ح </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH ح </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> دفع PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إي </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هذه ليست سوى تعليمات 50 ، و 10 منها هي الحركات التي يتم تنفيذها بشكل تافه. </font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تصحيح الأخطاء </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكن لدي بعض الأخبار السيئة. </font><font style="vertical-align: inherit;">من شبه المؤكد أن المحاكي الخاص بك لن يعمل بشكل صحيح ، ومن الصعب جدًا العثور على الأخطاء في هذا الرمز. </font><font style="vertical-align: inherit;">إذا كنت تعرف أي أمر يتصرف بشكل سيء (على سبيل المثال ، انتقال أو مكالمة تذهب إلى رمز لا معنى له) ، فيمكنك محاولة إصلاح الخطأ عن طريق فحص الرمز الخاص بك. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالإضافة إلى فحص الكود ، هناك طريقة أخرى لإصلاح المشكلة - من خلال مقارنة محاكيك بأخرى تعمل بالضبط. </font><font style="vertical-align: inherit;">نفترض أن محاكيًا آخر يعمل دائمًا بشكل صحيح ، وجميع الاختلافات هي أخطاء في محاكيك. </font><font style="vertical-align: inherit;">على سبيل المثال ، يمكنك استخدام محاكي الخاص بي. </font><font style="vertical-align: inherit;">يمكنك تشغيلها يدويًا بالتوازي. </font><font style="vertical-align: inherit;">يمكنك توفير الوقت إذا قمت بدمج الكود الخاص بي في مشروعك للحصول على العملية التالية:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء حالة لمحاكيك </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء دولة لي </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> للفريق القادم </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> استدعاء المحاكي الخاص بك مع دولتك </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> استدعاء منجم مع ثروتي </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قارن بين دولتينا </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تبحث عن أخطاء في أي اختلافات </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اذهب 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقة أخرى هي استخدام </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذا الموقع</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يدويًا </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">هذا هو محاكي معالج 8080 Javascript حتى يتضمن ROM Space Invaders. </font><font style="vertical-align: inherit;">هنا العملية:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قم بإعادة تشغيل مضاهاة Space Invaders بالنقر فوق الزر Space Invaders </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اضغط على زر "تشغيل 1" لتنفيذ الأمر. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نقوم بتنفيذ الأمر التالي في محاكينا </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قارن بين حالة المعالج وحالتك </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إذا تطابقت الشروط ، انتقل إلى 2 </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا لم تتطابق الشروط ، فإن محاكاة التعليمات الخاصة بك خاطئة. </font><font style="vertical-align: inherit;">قم بتصحيحها ، ثم ابدأ مرة أخرى من الخطوة 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد استخدمت هذه الطريقة في البداية لتصحيح محاكي 8080 الخاص بي. لن أكذب - يمكن أن تكون العملية طويلة. ونتيجة لذلك ، تحولت العديد من مشاكلي إلى أخطاء مطبعية ولصق نسخ ، والتي كان من السهل جدًا إصلاحها بعد الكشف. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا قمت خطوة بخطوة بتنفيذ التعليمات البرمجية الخاصة بك ، ثم يتم تنفيذ معظم الإرشادات الثلاثين ألف الأولى في دورة حول $ 1a5f. إذا نظرت </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلى جافا سكريبت</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">المحاكي</font></a><font style="vertical-align: inherit;"> ، يمكنك أن ترى أن هذا الرمز ينسخ البيانات إلى الشاشة. أنا متأكد من أن هذا الرمز يسمى في كثير من الأحيان. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد العرض الأول للشاشة ، بعد 50 ألف أمر ، يتعثر البرنامج في هذه الحلقة اللانهائية:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تنتظر حتى تتغير القيمة في الذاكرة عند $ 20c0 إلى الصفر. </font><font style="vertical-align: inherit;">نظرًا لأن الرمز في هذه الحلقة لا يغير تمامًا $ 20c0 ، فيجب أن يكون إشارة من مكان آخر. </font><font style="vertical-align: inherit;">حان الوقت للحديث عن محاكاة "الحديد" لآلة الورق. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قبل أن ننتقل إلى القسم التالي ، تأكد من أن محاكي وحدة المعالجة المركزية يقع في هذه الحلقة اللانهائية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كمرجع ، انظر </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مصادري</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مضاهاة 8080 كاملة </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">درس كلفني الكثير: لا تنفذ فرقًا لا يمكنك اختبارها. </font><font style="vertical-align: inherit;">هذه قاعدة جيدة لأي برنامج قيد التطوير. </font><font style="vertical-align: inherit;">إذا لم تتحقق من الفريق ، فسيتم كسرها بالتأكيد. </font><font style="vertical-align: inherit;">وكلما ابتعدت عن تنفيذه ، زادت صعوبة إيجاد المشاكل. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هناك حل آخر إذا كنت ترغب في عمل محاكي 8080 كامل والتأكد من أنه يعمل. </font><font style="vertical-align: inherit;">اكتشفت </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">رمزًا لـ 8080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يسمى cpudiag.asm ، تم تصميمه لاختبار كل أمر معالج 8080. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أقدم لك هذه العملية بعد الأول لعدة أسباب:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كنت أرغب في تكرار وصف هذه العملية لمعالج آخر. </font><font style="vertical-align: inherit;">لا أعتقد أن نظير cpudiag.asm موجود لجميع المعالجات.</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما ترون ، فإن العملية شاقة للغاية. </font><font style="vertical-align: inherit;">أعتقد أن المبتدئ في تصحيح رمز التجميع سيواجه صعوبات كبيرة إذا لم يتم سرد هذه الخطوات.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هكذا استخدمت هذا الاختبار مع محاكي. </font><font style="vertical-align: inherit;">يمكنك استخدامه أو ابتكار طريقة أفضل لدمجها.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تجميع الاختبار </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد جربت شيئين ، ونتيجة لذلك استقرت على استخدام </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذه الصفحة الرائعة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">قمت بلصق النص cpudiag.asm في الجزء الأيسر وأكمل البناء دون أي مشاكل. </font><font style="vertical-align: inherit;">لقد استغرق الأمر مني دقيقة لمعرفة كيفية تنزيل النتيجة ، ولكن بالنقر فوق الزر "إنشاء رمز جميل" في أسفل اليسار ، قمت بتنزيل ملف يسمى test.bin ، وهو رمز برمجي 8080. تمكنت من التحقق من ذلك باستخدام أداة التفكيك الخاصة بي. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم بتنزيل cpudiag.asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من المرآة على موقع الويب الخاص بي. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم بتنزيل cpudiag.bin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (الرمز </font><a href=""><font style="vertical-align: inherit;">المتراكم</font></a><font style="vertical-align: inherit;"> 8080) من موقعي.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحميل اختبار لمحاكي الخاص بي </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بدلاً من تحميل الغزاة. * الملفات ، أقوم بتحميل هذا الثنائي. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تنشأ صعوبات صغيرة هنا. أولاً ، يوجد سطر في التعليمات البرمجية للمجمع المصدر </font></font><code>ORG 00100H</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، أي أنه يعني أن الملف بأكمله تم تجميعه بافتراض أن السطر الأول من التعليمات البرمجية في 0x100 سداسي عشري. لم أكتب كودًا في المجمّع 8080 من قبل ، لذلك لم أكن أعرف ما يفعله هذا السطر. استغرق الأمر دقيقة واحدة فقط لمعرفة أن جميع عناوين فروع الفروع كانت غير صحيحة وكان من الضروري أن تبدأ الذاكرة عند 0x100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثانيًا ، نظرًا لأن محاكي يبدأ من الصفر ، يجب أن أقوم أولاً بالانتقال إلى الكود الحقيقي. بعد إدراج القيمة السداسية في الذاكرة عند العنوان صفر </font></font><code>JMP $0100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، تعاملت مع هذا. (أو يمكنك فقط تهيئة جهاز الكمبيوتر بقيمة 0x100.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثالثًا ، وجدت خطأً في الشفرة المترجمة. </font><font style="vertical-align: inherit;">أعتقد أن السبب هو المعالجة غير الصحيحة للسطر الأخير من الشفرة </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، لكنني لست متأكدًا. </font><font style="vertical-align: inherit;">على أي حال ، كان المكدس أثناء التجميع موجودًا في $ 6ad ، وبدأ PUSH القليلة الأولى في إعادة كتابة التعليمات البرمجية. </font><font style="vertical-align: inherit;">اقترحت أن المتغير يجب أن يقابله أيضًا 0x100 ، مثل باقي الكود ، لذلك قمت بإصلاحه عن طريق إدخال "0x7" في سطر الكود الذي يهيئ مؤشر المكدس. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أخيرًا ، نظرًا لأنني لم أقوم بتطبيق DAA أو الترحيل الإضافي في محاكي الخاص بي ، فأنا أقوم بتعديل الشفرة لتخطي هذا الاختيار (ببساطة نتخطاها باستخدام JMP).</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يحاول الاختبار التوصل إلى نتيجة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من الواضح أن هذا الاختبار يعتمد على المساعدة من CP / M OS. اكتشفت أن CP / M يحتوي على بعض التعليمات البرمجية بمبلغ 0005 دولار يطبع الرسائل إلى وحدة التحكم ، وغيرت مضاهاة CALL للتعامل مع هذا السلوك. لست متأكدًا مما إذا كان كل شيء يسير على ما يرام ، ولكنه نجح مع الرسالتين اللتين يحاول البرنامج طباعتهما. يبدو مضاهاة CALL لتشغيل هذا الاختبار كما يلي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مع هذا الاختبار ، وجدت العديد من المشاكل في محاكي الخاص بي. لست متأكدًا من منهم سيشارك في اللعبة ، ولكن إذا كانوا مشاركين ، فسيكون من الصعب جدًا العثور عليهم. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تقدمت وقمت بتطبيق جميع رموز opcodes (باستثناء DAA وأصدقائه). استغرق الأمر مني 3-4 ساعات لإصلاح المشكلات في تحدياتي وتنفيذ تحديات جديدة. لقد كانت بالتأكيد أسرع من العملية اليدوية التي وصفتها أعلاه - قبل أن أجد هذا الاختبار ، أمضيت أكثر من 4 ساعات في العملية اليدوية. إذا كان بإمكانك معرفة هذا الشرح ، فإنني أوصي باستخدام هذه الطريقة بدلاً من المقارنة يدويًا. ومع ذلك ، فإن معرفة العملية اليدوية هي أيضًا مهارة رائعة ، وإذا كنت تريد محاكاة معالج آخر ، فيجب عليك العودة إليها.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا لم تتمكن من إجراء هذه العملية أو كانت تبدو معقدة للغاية ، فمن الجدير بالتأكيد اختيار النهج الموصوف أعلاه مع محاكيين مختلفين يعملان داخل برنامجك. </font><font style="vertical-align: inherit;">عند ظهور عدة ملايين من الأوامر في البرنامج وإضافة المقاطعات ، سيكون من المستحيل مقارنة محاكيين يدويًا.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar418699/">https://habr.com/ru/post/ar418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar418687/index.html">3.5 "ثورة: تفاصيل طفرة صغيرة من الأقراص المرنة مع الأبخرة</a></li>
<li><a href="../ar418689/index.html">كيفية إنشاء مكتبات المكونات في Figma ، حفظ الميزانية ، باستخدام مثال المزاد عبر الإنترنت</a></li>
<li><a href="../ar418691/index.html">رانشر: Kubernetes في 5 دقائق على المعدن</a></li>
<li><a href="../ar418693/index.html">لماذا يصعب اكتشاف السعادة في الدماغ</a></li>
<li><a href="../ar418695/index.html">حروب مكافحة القرصنة - الإمبراطورية تعيد الضربات</a></li>
<li><a href="../ar418701/index.html">ندرس المحلل اللغوي للغة الروسية</a></li>
<li><a href="../ar418705/index.html">أساسيات فوتكس</a></li>
<li><a href="../ar418707/index.html">KDispatcher - Eventbus خفيفة الوزن ومريحة للاستخدام اليومي</a></li>
<li><a href="../ar418709/index.html">تحتاج إلى فرض نفسك: السائقين وحواجز الواجهة</a></li>
<li><a href="../ar418711/index.html">تسجيلات الرمز المُدار 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>